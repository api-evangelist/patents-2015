---

title: Generic test automation for graphical user interface (GUI) applications
abstract: A method for generic test automation comprises mapping generic interface commands for objects to be tested to tool-specific interface commands of a test automation tool. An application-specific element map based on an application for test is identified, and the application-specific element map includes label names for the elements of the application-specific element map. Application-specific user actions, which are created based on the generic interface commands and the application-specific element map, are sent to the test automation tool for testing the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09658944&OS=09658944&RS=09658944
owner: CA, Inc.
number: 09658944
owner_city: Islandia
owner_country: US
publication_date: 20150820
---
This application is related to U.S. patent application Ser. No. 14 831 050 entitled GENERIC TEST AUTOMATION FOR RESTFUL WEB SERVICES APPLICATIONS by Ganda et al. which is filed concurrently herewith the entirety of which is incorporated by reference.

Various aspects of the present disclosure relate generally to testing applications and specifically to automated testing of graphical user interface applications. Therefore the present disclosure advances an improvement in the technical field of application development and testing.

Software applications require extensive testing before being released to the general public to ensure proper functionality. Basically application specific test cases with sets of test operations pair with application specific test data in a test driver which is used to test the application. In the case of graphical user interface GUI applications an element map specific to the GUI under test is used with the test driver to test each page of the application in an automation tool e.g. Selenium HP UFT Hewlett Packard Unified Functional Testing Appium etc. . Selenium is a registered trademark of Software Freedom Conservancy a corporation of New York located at 137 Montague Street Suite 380 Brooklyn N.Y. 11201. HP is a registered trademark of Hewlett Packard Development Company L.P. a limited partnership of Texas located at 11445 Compaq Center Drive West Houston Tex. 77070. 

During testing if an exception occurs then if the error is due to a change in a GUI screen then the application mapping test cases test data or combinations thereof must be analyzed and updated. However if the exception is not due to a change in screen then an error is reported. If no exceptions occur then a verification manager determines whether the test was successful or not and reports either success or an error.

Through extensive testing software developers may ensure a more robust release of the application under test.

According to aspects of the present disclosure a method for generic test automation comprises mapping generic interface commands for objects to be tested to tool specific interface commands of a test automation tool. An application specific element map based on an application for test is identified and the application specific element map includes label names for the elements of the application specific element map. Application specific user actions which are created based on the generic interface commands and the application specific element map are sent to the test automation tool for testing the application.

According to further aspects of the present disclosure an application specific test case is translated to the application specific user actions and values from application specific test data are used to populate the application specific user actions. The populated application specific user actions are translated to the generic interface commands to create populated generic interface commands which are translated to tool specific interface commands based on the mapping of the generic interface commands to tool specific interface commands.

According to aspects of the present disclosure software application test automation is performed using a generic mapping between a test automation tool and application specific test cases and data. Thus application specific test cases which are a sequence of test steps and application specific test data which supply values to the application test cases are isolated from the test automation tool and the elements within the application itself in some regard.

Basically generic interface commands i.e. interface commands that may be used across applications and across test automation tools are created and mapped to one or more tool specific commands of one or more test automation tools. Further application specific user actions i.e. simulated user actions are created based on the generic interface commands and elements of an application under test. Thus the user actions are specific to the application but generic to test automation tools.

Referring now to a method for generic test automation of an application is presented. In this regard the method may be implemented on computer readable hardware that stores machine executable program code where the program code instructs a processor to implement the described method. The method may also be executed by a processor coupled to memory where the processor is programmed by program code stored in the memory to perform the described method.

At generic interface commands for objects in general to be tested are created. For example in a graphical user interface GUI application generic interface commands may be created for objects found in GUI applications e.g. setInputField click selectFromList focus launch close verify switchToFrame waitForElementToLoad setCheckBox etc. . While these generic interface commands may be of any language or verbiage the generic interface commands should be easy to understand based on the commands themselves. For example setInputField is used to set text in an input field of a GUI screen.

At the generic interface commands are mapped to tool specific interface commands of a test automation tool in any practical way e.g. via an application programming interface . For example the command check is used in Selenium to place a check in a check box. Thus when mapping the generic interface commands to the Selenium commands setCheckBox is mapped to check in Selenium. However to check a checkbox in HP UFT the command is set with an object of the command being the checkbox. Therefore the generic interface command setCheckBox would be mapped to set in HP UFT. As such the generic interface commands may be mapped to different test automation tools via the mapping at . Also different versions of the same tool may have different application programming interfaces APIs . If so then the generic interface commands may be mapped to different versions of the same test automation tool which allows for easy upgrading of test automation tools.

At an application specific element map of an application for test is identified and elements of the element map include a label name. For example if the application for testing is a GUI application then elements of the GUI application may be automatically created from the GUI application by parsing source code of the application and finding the screens and elements within the GUI. As another example the list of elements may be received from a separate tool or the application itself.

The application specific element map may take any form and any language. However the application map should include meaningful application specific label names e.g. username password etc. which may be determined from the source code of the application itself as shown below.

The application specific element map shown above maps to a GUI screen that includes three text boxes e.g. username password and tenant name a sign in button and a forgot password link resulting in a screen similar to the screen illustrated in discussed below in an example of the method . As noted above the application specific element map is specific to the application under test. Since the application specific element map may be auto generated label names may be taken from a screen label if the screen labels are meaningful. Otherwise the label names in the application specific element map may be given application agnostic names. For example the output label errorMessage is not necessarily application specific i.e. application agnostic but is easily understood by a user as an error message but application specific elements may be included in the value e.g. value formError .

The application specific element map may be represented in any desired way. For example the application specific element map may be written in extensible markup language XML as shown above as a spreadsheet etc.

At application specific user actions are created based on the application specific element map and the generic interface commands. For example the user actions may be based on a screen label from the application specific element map and may use the generic interface commands as functions within each user action where variables for the function are defined by labels within the application specific element map.

For example a user action that simulates a user interacting with the login screen may include the generic interface actions setInputField and click because there are three boxes a button and a link on the Login screen. As such the application specific user action for the Login screen may be Login setInputField username password tenant name click sign in 

In the example above Login is a logical name for the user action and is not necessarily tied to a login screen which may be named Login Sign In etc. . Once the logical name for the user action is defined then elements from a screen e.g. username password etc. may be defined.

A user may then create an application specific test case by creating a sequence of the application specific user actions. Further the user may include application specific test data to supply values for the user actions within the test case. An example of an application specific test case is shown in and an example of application specific test data is shown in and will be discussed in greater detail below.

The application specific test case i.e. sequence of application specific user actions is used as an input to the test automation tool which fills in values for the generic interface commands using the application specific test data as discussed above. At the application specific user actions are sent to the test automation tool for testing the application and the generic interface commands of the application specific user actions are translated to the tool specific interface commands using the mapping created at . Thus the application specific user actions are isolated from whichever tool is used to run the test automation. The translation of the generic interface commands to tool specific commands may be performed before or during testing.

The method allows a user to create application specific test cases and application specific test data using generic interface commands. Thus users do not need to learn specific scripting or programming languages for test automation. Instead the users may use plain English to create the application specific test cases and application specific test data based on the generic interface commands. Further the method allows portability between tools. For example if a test is written for Selenium then to port to HP UFT the user just needs to specify a different mapping e.g. at above . Therefore the user does not need to know which test automation tool will be used to test the application.

Referring now to a flow chart illustrates an overall test flow according to various aspects of the present disclosure. Generic interface commands are created and mapped to an exposed application programming interface API of a test automation tool . Further an application specific element map is created from source code of an application under test . From the generic interface commands and the application specific element map application specific user actions which are used to simulate user actions within the test automation tool are created . The generic interface commands application specific element map and application specific user actions may then be used for testing the application in a test automation tool to which the generic interface commands are mapped.

When a user wants to test an application e.g. a GUI application the user creates application specific test data . The application specific test data is used in conjunction with application specific test cases with a set of test operations as input to test driver . Further the test driver and the application specific user actions feed an automation translator plugin which is coupled to the test automation tool and maps operations of the application specific test cases to application specific user actions. At the test automation tool executes the application specific user actions using reflection by referencing the application specific element map and the generic interface commands . Basically the test automation tool reads the application specific test case and references the application specific test data to retrieve values for variables of the first user action. Then the first user action is simulated using the application specific element map and the generic interface commands. For example using the Login user command listed above the translator plugin reads the test operation i.e. Login and translates it to a sequence of the generic interface commands e.g. SetInputField and click . Then those generic interface commands are translated to a sequence for the test automation tool.

At it is determined whether the first user action produces an exception. If not then at if there are more user actions in the application specific test case that have not been performed then the test automation tool selects a next user action and executes the selected user action using reflection as indicated above at . If there are no more user actions at then a verification manager uses a script to verify the results at . For example a user may supply a sequence that looks to see if a certain element is present or compare text from a text box to a value. The verification sequence may be part of the application specific test case or may be separate from the application specific test case. If the test automation is successful then the verification manager reports success at otherwise an error is reported at .

The verification manager may use the generic interface commands as described herein for the application agnostic GUI verification sequence. For example a generic interface command may be created for sending a success message e.g. VerifySuccessMessage sending an error message e.g. VerifyErrorMessage verifying that an element is present e.g. VerifyElementPresent  verifying text from a text box reflects a value e.g. VerifyTextFrom  etc. Thus if the test automation tool is Selenium for example then VerifyElementPresent  can be mapped to getText API VerifyElementPresent  can be mapped to isDisplayed API VerfiyMessage can be mapped to assert etc.

If there is an exception at then it is determined whether the exception is from a change in a GUI screen of the application under test at . If so then a screenshot is captured at which may then be used for analysis at to determine if the application element should be updated if the application specific test case should be updated or if the application specific user actions should be updated. If the error is not due to a change in screen at then an error is reported at .

Referring now to an example of using generic test automation is provided in reference to the methods of . Generic interface commands are created for different objects that may appear in a GUI screen not necessarily only the interface commands that may be seen in a specific application under test . In this case the generic interface commands include setInputField click selectFromList focus launch close verify switchToFrame waitForElementToLoad and setCheckBox. These generic interface commands are mapped to one or more similar commands within a Selenium test automation tool exposed by an API of the Selenium tool. For example setInputField and setCheckBox are mapped to sendKeys and check in Selenium respectively.

Continuing with the example an application with a screen is under test in the Selenium test automation tool. The screen includes a Username text box a Password text box a Tenant Name text box a Sign In button and a Forgot Password link . Source code for the application is parsed to generate an application specific element map of the screen which returns the following application specific element map.

Using the application specific element map i.e. the user interface element map and the generic interface commands application specific user actions are created. In this case the following user actions automatically created for this application are 

The application specific user actions may be in any format. As shown above they are in a list form with a mapping to elements. illustrates the application specific user actions in a test case as a spreadsheet. As another example the application specific user action may be manually created based on the application specific element map without specific mention of the generic user interface commands in a block form. For example A login test case can have following simple instructions with Key Value Pairs keys are label names in Login section of UI Element Map i.e. application specific element map and values to be substituted from the test data 

At run time the Username Password and TenantName will be determined as inputs using the type parameter in application specific element map and the generic interface command SetInputText function will be invoked based on the input type. Similarly for SignIn the type parameter has a value of button. Thus the generic interface command click function will be invoked. The variables e.g. username etc. will be dynamically substituted from the test data.

Also the application specific test data may be hard coded in the application specific test cases for instant execution instead of writing in a spreadsheet as shown in XML etc. For example a successful login test with an output verification for a presence of a mainnavlink element to confirm that the user actually did login onto the screen could look like the following which provides for quicker verifications in certain cases e.g. application modifications bug fixes etc. 

Therefore instead of dynamically substituting the variables in at run time the variables are hard coded within the application specific test case. Further the mainnavlink element is known to be an output from the type parameter for mainnavlink within the application specific element map set to output as shown above.

Thus every element in the application specific element map for the Login screen does not need to be used in creating a user action. Instead a subset of the elements may be used as shown above.

The user creates an application specific test case of test operations as shown in and creates application specific test data that is used to provide values for the application specific user actions as shown in . Both the application specific test case and the application specific test data are written using a spreadsheet in this example. However they may be created in any desired format e.g. XML Quality Center etc. . The application specific test data is used with the application specific test cases with a set of test operations as an input to the test automation tool via a test driver. An automation translator plugin has been coupled to the Selenium test automation tool so the application specific user actions which are based off of the generic interface commands may be understood by the Selenium tool. Thus the Selenium test automation tool starts the automation.

The test driver selects the first test operation found in the application specific test cases which in this example is Login. Using reflection invokes the test automation tool e.g. Selenium to populate values read from the application specific test data into the application under test. In this example the first user action in the sequence of the application specific test case for the Login operation is setInputField for username password and tenantname textboxes and the second user action for the Login operation is to click on the sign in button

The values associated with the first Login data set in the application specific test data are plugged into the label names within the user action. This first user action will simulate an end user properly entering a valid username password and tenant name and clicking the sign in button. Specifically the username input field i.e. text box is set to username1 the password input field is set to valid pwd the tenant name input field is set to tenant1 the sign in button is pushed. The user action which is just a series of interface commands is then translated from the generic interface commands to the tool e.g. Selenium specific commands through the generic interface command map set up earlier. Thus the Selenium test automation tool can run the user action. As such it is as if an end user has typed in username1 into the username text box valid pwd into the password text box tenant1 into the tenant name text box and clicked the sign in button.

In this case there is no exception so the Selenium tool determines that there is another user action in the application specific test cases to be executed so the Selenium tool selects the next user action in the application specific test cases which is another Login action. This user action simulates the end user entering an invalid password. Specifically the username input field i.e. text box is set to username1 the password input field is set to invalid pwd the tenant name input field is set to tenant2 the sign in button is pushed and nothing happens with the forgot password link. Just as before the user action is translated from the generic interface commands to Selenium specific user commands through the generic interface command map set up earlier. Thus the Selenium test automation tool can run the user action. As such it is as if an end user has typed in username1 into the username text box invalid pwd into the password text box tenant1 into the tenant name text box and clicked the sign in button. In this case no exception occurs because the GUI functions properly by indicating that the password is invalid.

When there are no more actions to perform in the application specific test cases the verification manager determines whether the test automation was a success. In this case the verification manager determines that the operation was a success and issues a success message.

If the operation was not a success due to changes in the application then the application specific element map may need to be updated to reflect new labels screens etc. If that is the case then the application specific user actions may need to be updated which may be done automatically. However if the application specific user actions are updated the application specific test cases do not necessarily need to updated because the test cases are independent of the application specific element map. This reduces the amount of time needed between an application version for test and actual testing because only minimal changes may need to be changed instead of having to rewrite the test cases based on the new element map.

Further if the user decides to run the test in the HP UFT tool or any other test automation tool then neither the application specific test data nor the application specific test cases need to be rewritten. Instead a mapping from the generic interface commands to HP UFT commands instead of the mapping to Selenium as described in the example is created as an input to the translator plugin. Thus application specific test cases and application specific test data written for a specific application may be used to test that application regardless of the test automation tool.

Also if a new version of a test automation tool is released or if an old version of a test automation tool is no longer supported by the manufacturer then the user may upgrade to a newer version of the test automation tool with a different API by creating a new mapping for the new API for the newer version of the test automation tool. Thus application specific test cases and application specific test data written for a specific application may be used to test that application regardless of the version of the test automation tool.

Moreover the generic interface commands should include most if not all of the possible commands an end user may perform. Thus once a generic interface command mapping file is created for a tool it can be used to test any application.

Still further the generic interface commands allow a user to write test cases test data and verification scripts without knowing any specific scripting language or test automation tool language.

Referring to a block diagram of a data processing system is depicted in accordance with the present disclosure. Data processing system may comprise a symmetric multiprocessor SMP system or other configuration including a plurality of processors connected to system bus . Alternatively a single processor may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . An I O bus bridge is connected to the system bus and provides an interface to an I O bus . The I O bus may be utilized to support one or more buses and corresponding devices such as bus bridges input output devices I O devices storage network adapters etc. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks.

Also connected to the I O bus may be devices such as a graphics adapter storage and a computer usable storage medium having computer usable program code embodied thereon. The computer usable program code may be executed to implement any aspect of the present disclosure for example to implement any aspect of any of the methods and or system components illustrated in .

As will be appreciated by one skilled in the art aspects of the present disclosure may be embodied as a system method or computer program product. Accordingly aspects of the present disclosure may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable storage medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. A computer storage medium does not include propagating signals.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java programming language Java is a registered trademark owned by Oracle America Inc. a Delaware Corporation located at 500 Oracle Parkway Redwood Shores CA 94065 Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Network using an Network Service Provider .

Aspects of the present disclosure are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. Aspects of the disclosure were chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

