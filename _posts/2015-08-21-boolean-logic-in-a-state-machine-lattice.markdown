---

title: Boolean logic in a state machine lattice
abstract: Disclosed are methods and devices, among which is a device that includes a finite state machine lattice. The lattice may includes a programmable Boolean logic cell that may be programmed to perform various logic functions on a data stream. The programmability includes an inversion of a first input to the Boolean logic cell, an inversion of a last output of the Boolean logic cell, and a selection of an AND gate or an OR gate as a final output of the Boolean logic cell. The Boolean logic cell also includes end of data circuitry configured to cause the Boolean logic cell to only output after an end of data signifying the end of a data stream is received at the Boolean logic cell.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09509312&OS=09509312&RS=09509312
owner: Micron Technology, Inc.
number: 09509312
owner_city: Boise
owner_country: US
publication_date: 20150821
---
The present application is a continuation of U.S. application Ser. No. 14 087 973 entitled Boolean Logic in a State Machine Lattice and filed Nov. 22 2013 now U.S. Pat. No. 9 118 327 which issued Aug. 25 2015 which is a continuation of U.S. application Ser. No. 13 327 510 entitled Boolean Logic in a State Machine Lattice and filed Dec. 15 2011 now U.S. Pat. No. 8 593 175 which issued on Nov. 26 2013 the entirety of which is incorporated by reference herein for all purposes.

Embodiments of the invention relate generally to electronic devices and more specifically in certain embodiments to parallel finite state machines for pattern recognition.

In the field of computing pattern recognition tasks are increasingly challenging. Ever larger volumes of data are transmitted between computers and the number of patterns that users wish to detect is increasing. For example spam and malware are often detected by searching for patterns in a data stream e.g. particular phrases or pieces of code. The number of patterns increases with the variety of spam and malware as new patterns may be implemented to search for new variants.

Recognizing a pattern may often involve determining whether various combinations of matched conditions indicative of the pattern are met. Boolean logic may be implemented to determine various combinations of matched conditions in pattern recognition computing. For example AND OR NOR and NAND gates may be used to determine various combinations of matched conditions. The inventors have determined that it may be useful to increase the versatility of Boolean logic by increasing the number of logical operations available for pattern recognition computing.

Turning now to the figures illustrates an embodiment of a processor based system generally designated by reference numeral . The system may be any of a variety of types such as a desktop computer laptop computer pager cellular phone personal organizer portable audio player control circuit camera etc. The system may also be a network node such as a router a server or a client e.g. one of the previously described types of computers . The system may be some other sort of electronic device such as a copier a scanner a printer a game console a television a set top video distribution or recording system a cable box a personal digital media player a factory automation system an automotive computer system or a medical device. The terms used to describe these various examples of systems like many of the other terms used herein may share some referents and as such should not be construed narrowly in virtue of the other items listed. 

In a typical processor based device such as the system a processor such as a microprocessor controls the processing of system functions and requests in the system . Further the processor may comprise a plurality of processors that share system control. The processor may be coupled directly or indirectly to each of the elements in the system such that the processor controls the system by executing instructions that may be stored within the system or external to the system .

In accordance with the embodiments described herein the system includes a state machine engine which may operate under control of the processor . The state machine engine may employ any one of a number of state machine architectures including but not limited to Mealy architectures Moore architectures Finite State Machines FSMs Deterministic FSMs DFSMs Bit Parallel State Machines BPSMs etc. Though a variety of architectures may be used for discussion purposes the application refers to FSMs. However those skilled in the art will appreciate that the described techniques may be employed using any one of a variety of state machine architectures.

As discussed further below the state machine engine may include a number of e.g. one or more finite state machine FSM lattices. Each FSM lattice may include multiple FSMs that each receive and analyze the same data in parallel. Further the FSM lattices may be arranged in groups e.g. clusters such that clusters of FSM lattices may analyze the same input data in parallel. Further clusters of FSM lattices of the state machine engine may be arranged in a hierarchical structure wherein outputs from state machine lattices on a lower level of the hierarchical structure may be used as inputs to state machine lattices on a higher level. By cascading clusters of parallel FSM lattices of the state machine engine in series through the hierarchical structure increasingly complex patterns may be analyzed e.g. evaluated searched etc. .

Further based on the hierarchical parallel configuration of the state machine engine the state machine engine can be employed for pattern recognition in systems that utilize high processing speeds. For instance embodiments described herein may be incorporated in systems with processing speeds of 1 GByte sec. Accordingly utilizing the state machine engine data from high speed memory devices or other external devices may be rapidly analyzed for various patterns. The state machine engine may analyze a data stream according to several criteria and their respective search terms at about the same time e.g. during a single device cycle. Each of the FSM lattices within a cluster of FSMs on a level of the state machine engine may each receive the same search term from the data stream at about the same time and each of the parallel FSM lattices may determine whether the term advances the state machine engine to the next state in the processing criterion. The state machine engine may analyze terms according to a relatively large number of criteria e.g. more than 100 more than 110 or more than 10 000. Because they operate in parallel they may apply the criteria to a data stream having a relatively high bandwidth e.g. a data stream of greater than or generally equal to 1 GByte sec without slowing the data stream.

In one embodiment the state machine engine may be configured to recognize e.g. detect a great number of patterns in a data stream. For instance the state machine engine may be utilized to detect a pattern in one or more of a variety of types of data streams that a user or other entity might wish to analyze. For example the state machine engine may be configured to analyze a stream of data received over a network such as packets received over the Internet or voice or data received over a cellular network. In one example the state machine engine may be configured to analyze a data stream for spam or malware. The data stream may be received as a serial data stream in which the data is received in an order that has meaning such as in a temporally lexically or semantically significant order. Alternatively the data stream may be received in parallel or out of order and then converted into a serial data stream e.g. by reordering packets received over the Internet. In some embodiments the data stream may present terms serially but the bits expressing each of the terms may be received in parallel. The data stream may be received from a source external to the system or may be formed by interrogating a memory device such as the memory and forming the data stream from data stored in the memory . In other examples the state machine engine may be configured to recognize a sequence of characters that spell a certain word a sequence of genetic base pairs that specify a gene a sequence of bits in a picture or video file that form a portion of an image a sequence of bits in an executable file that form a part of a program or a sequence of bits in an audio file that form a part of a song or a spoken phrase. The stream of data to be analyzed may include multiple bits of data in a binary format or other formats e.g. base ten ASCII etc. The stream may encode the data with a single digit or multiple digits e.g. several binary digits.

As will be appreciated the system may include memory . The memory may include volatile memory such as Dynamic Random Access Memory DRAM Static Random Access Memory SRAM Synchronous DRAM SDRAM Double Data Rate DRAM DDR SDRAM DDR2 SDRAM DDR3 SDRAM etc. The memory may also include non volatile memory such as read only memory ROM PC RAM silicon oxide nitride oxide silicon SONOS memory metal oxide nitride oxide silicon MONOS memory polysilicon floating gate based memory and or other types of flash memory of various architectures e.g. NAND memory NOR memory etc. to be used in conjunction with the volatile memory. The memory may include one or more memory devices such as DRAM devices that may provide data to be analyzed by the state machine engine . Such devices may be referred to as or include solid state drives SSD s MultimediaMediaCards MMC s SecureDigital SD cards CompactFlash CF cards or any other suitable device. Further it should be appreciated that such devices may couple to the system via any suitable interface such as Universal Serial Bus USB Peripheral Component Interconnect PCI PCI Express PCI E Small Computer System Interface SCSI IEEE 1394 Firewire or any other suitable interface. To facilitate operation of the memory such as the flash memory devices the system may include a memory controller not illustrated . As will be appreciated the memory controller may be an independent device or it may be integral with the processor . Additionally the system may include an external storage such as a magnetic storage device. The external storage may also provide input data to the state machine engine .

The system may include a number of additional elements. For instance a complier may be used to program the state machine engine as described in more detail with regard to . An input device may also be coupled to the processor to allow a user to input data into the system . For instance an input device may be used to input data into the memory for later analysis by the state machine engine . The input device may include buttons switching elements a keyboard a light pen a stylus a mouse and or a voice recognition system for instance. An output device such as a display may also be coupled to the processor . The display may include an LCD a CRT LEDs and or an audio display for example. They system may also include a network interface device such as a Network Interface Card NIC for interfacing with a network such as the Internet. As will be appreciated the system may include many other components depending on the application of the system .

The programmable elements can be programmed to implement many different functions. For instance the programmable elements may include state machine elements SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . To route signals between the hierarchically organized SMEs a hierarchy of programmable switching elements can be used including inter block switching elements shown in intra block switching elements shown in and intra row switching elements shown in .

As described below the switching elements may include routing structures and buffers. A SME can correspond to a state of a FSM implemented by the FSM lattice . The SMEs can be coupled together by using the programmable switching elements as described below. Accordingly a FSM can be implemented on the FSM lattice by programming the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to or reading from the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switching element it should be understood that in other examples fewer or more conductors may be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to only one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT as will be better illustrated with respect to . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity . In an example the row can also include a special purpose element such as a counter a programmable Boolean logic element look up table RAM a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. a microprocessor or other element for performing a special purpose function.

In an example the special purpose element comprises a counter also referred to herein as counter . In an example the counter comprises a 12 bit programmable down counter. The 12 bit programmable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted during the clock cycle when the counter decrements to zero and at the next clock cycle the zero count output is no longer asserted. When the counter is set to hold mode the zero count output is asserted during the clock cycle when the counter decrements to zero and stays asserted until the counter is reset by the reset input being asserted.

In another example the special purpose element comprises Boolean logic. In some examples this Boolean logic can be used to extract information from terminal state SMEs corresponding to terminal nodes of a FSM as discussed later herein in FSM lattice . The information extracted can be used to transfer state information to other FSM lattices and or to transfer programming information used to reprogram FSM lattice or to reprogram another FSM lattice .

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input on the data stream line is decoded to select one of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the input block can be provided to a decoder not shown and the decoder can select one of the data stream lines . In an example the decoder can convert an 8 bit ACSII character to the corresponding 1 of 256 data stream lines .

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line corresponds to the memory cell . When the data on the data stream line corresponds to the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detection cell .

In an example the signal on an input line sets the respective detection cell to either an active or inactive state. When set to the inactive state the detection cell outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detection cell outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detection cell outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detection cell is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be programmed by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. and bits. The image can program the FSM lattice to operate as a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detection cell to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detection cell of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM lattice .

In an example a single FSM lattice is implemented on a single physical device however in other examples two or more FSM lattices can be implemented on a single physical device e.g. physical chip . In an example each FSM lattice can include a distinct data input block a distinct output block a distinct programming interface and a distinct set of programmable elements. Moreover each set of programmable elements can react e.g. output a high or low signal to data at their corresponding data input block . For example a first set of programmable elements corresponding to a first FSM lattice can react to the data at a first data input block corresponding to the first FSM lattice . A second set of programmable elements corresponding to a second FSM lattice can react to a second data input block corresponding to the second FSM lattice . Accordingly each FSM lattice includes a set of programmable elements wherein different sets of programmable elements can react to different input data. Similarly each FSM lattice and each corresponding set of programmable elements can provide a distinct output. In some examples an output block from a first FSM lattice can be coupled to an input block of a second FSM lattice such that input data for the second FSM lattice can include the output data from the first FSM lattice in a hierarchical arrangement of a series of FSM lattices .

In an example an image for loading onto the FSM lattice comprises a plurality of bits of information for configuring the programmable elements the programmable switching elements and the special purpose elements within the FSM lattice . In an example the image can be loaded onto the FSM lattice to program the FSM lattice to provide a desired output based on certain inputs. The output block can provide outputs from the FSM lattice based on the reaction of the programmable elements to data at the data input block . An output from the output block can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and a state vector corresponding to the state of all or certain programmable elements at a given moment. As described a number of FSM lattices may be included in a state machine engine such as state machine engine to perform data analysis such as pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others.

Each of the nodes can be in either an active or an inactive state. When in the inactive state a node does not react e.g. respond to input data. When in an active state a node can react to input data. An upstream node can react to the input data by activating a node that is downstream from the node when the input data matches criteria specified by an edge between the upstream node and the downstream node . For example a first node that specifies the character b will activate a second node connected to the first node by an edge when the first node is active and the character b is received as input data. As used herein upstream refers to a relationship between one or more nodes where a first node that is upstream of one or more other nodes or upstream of itself in the case of a loop or feedback configuration refers to the situation in which the first node can activate the one or more other nodes or can activate itself in the case of a loop . Similarly downstream refers to a relationship where a first node that is downstream of one or more other nodes or downstream of itself in the case of a loop can be activated by the one or more other nodes or can be activated by itself in the case of a loop . Accordingly the terms upstream and downstream are used herein to refer to relationships between one or more nodes but these terms do not preclude the use of loops or other non linear paths among the nodes.

In the diagram the root node can be initially activated and can activate downstream nodes when the input data matches an edge from the root node . Nodes can activate nodes when the input data matches an edge from the node . Nodes throughout the diagram can be activated in this manner as the input data is received. A terminal node corresponds to a match of a sequence of interest by the input data. Accordingly activation of a terminal node indicates that a sequence of interest has been received as the input data. In the context of the FSM lattice implementing a pattern recognition function arriving at a terminal node can indicate that a specific pattern of interest has been detected in the input data.

In an example each root node standard node and terminal node can correspond to a programmable element in the FSM lattice . Each edge can correspond to connections between the programmable elements. Thus a standard node that transitions to e.g. has an edge connecting to another standard node or a terminal node corresponds to a programmable element that transitions to e.g. provides an output to another programmable element. In some examples the root node does not have a corresponding programmable element.

When the FSM lattice is programmed each of the programmable elements can also be in either an active or inactive state. A given programmable element when inactive does not react to the input data at a corresponding data input block . An active programmable element can react to the input data at the data input block and can activate a downstream programmable element when the input data matches the setting of the programmable element. When a programmable element corresponds to a terminal node the programmable element can be coupled to the output block to provide an indication of a match to an external device.

An image loaded onto the FSM lattice via the programming interface can configure the programmable elements and special purpose elements as well as the connections between the programmable elements and special purpose elements such that a desired FSM is implemented through the sequential activation of nodes based on reactions to the data at the data input block . In an example a programmable element remains active for a single data cycle e.g. a single character a set of characters a single clock cycle and then becomes inactive unless re activated by an upstream programmable element.

A terminal node can be considered to store a compressed history of past events. For example the one or more patterns of input data required to reach a terminal node can be represented by the activation of that terminal node . In an example the output provided by a terminal node is binary that is the output indicates whether the pattern of interest has been matched or not. The ratio of terminal nodes to standard nodes in a diagram may be quite small. In other words although there may be a high complexity in the FSM the output of the FSM may be small by comparison.

In an example the output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of programmable elements of the FSM lattice . In an example the state vector includes the states for the programmable elements corresponding to terminal nodes . Thus the output can include a collection of the indications provided by all terminal nodes of a diagram . The state vector can be represented as a word where the binary indication provided by each terminal node comprises one bit of the word. This encoding of the terminal nodes can provide an effective indication of the detection state e.g. whether and what sequences of interest have been detected for the FSM lattice . In another example the state vector can include the state of all or a subset of the programmable elements whether or not the programmable elements corresponds to a terminal node .

As mentioned above the FSM lattice can be programmed to implement a pattern recognition function. For example the FSM lattice can be configured to recognize one or more data sequences e.g. signatures patterns in the input data. When a data sequence of interest is recognized by the FSM lattice an indication of that recognition can be provided at the output block . In an example the pattern recognition can recognize a string of symbols e.g. ASCII characters to for example identify malware or other information in network data.

The first FSM lattice A is configured to receive input data for example raw data at a data input block. The first FSM lattice A reacts to the input data as described above and provides an output at an output block. The output from the first FSM lattice A is sent to a data input block of the second FSM lattice B. The second FSM lattice B can then react based on the output provided by the first FSM lattice A and provide a corresponding output signal of the hierarchical structure . This hierarchical coupling of two FSM lattices A and B in series provides a means to transfer information regarding past events in a compressed word from a first FSM lattice A to a second FSM lattice B. The information transferred can effectively be a summary of complex events e.g. sequences of interest that were recorded by the first FSM lattice A.

The two level hierarchy of FSM lattices A B shown in allows two independent programs to operate based on the same data stream. The two stage hierarchy can be similar to visual recognition in a biological brain which is modeled as different regions. Under this model the regions are effectively different pattern recognition engines each performing a similar computational function pattern matching but using different programs signatures . By connecting multiple FSM lattices A B together increased knowledge about the data stream input may be obtained.

The first level of the hierarchy implemented by the first FSM lattice A can for example perform processing directly on a raw data stream. That is a raw data stream can be received at an input block of the first FSM lattice A and the programmable elements of the first FSM lattice A can react to the raw data stream. The second level implemented by the second FSM lattice B of the hierarchy can process the output from the first level. That is the second FSM lattice B receives the output from an output block of the first FSM lattice A at an input block of the second FSM lattice B and the programmable elements of the second FSM lattice B can react to the output of the first FSM lattice A. Accordingly in this example the second FSM lattice B does not receive the raw data stream as an input but rather receives the indications of patterns of interest that are matched by the raw data stream as determined by the first FSM lattice A. The second FSM lattice B can implement a FSM that recognizes patterns in the output data stream from the first FSM lattice A.

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM lattice . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to program the FSM lattice . The compiler can be implemented by instructions for a computer having a von Neumann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler . For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor .

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include criteria for the analysis of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

At block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. That is different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example the automaton can be converted based partly on the hardware of the FSM lattice .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q. In an example a reversal of an automaton produces a new automaton where each transition p q on some symbol is reversed q p on the same symbol. In a reversal start state becomes a final state and the final states become start states. In an example the language recognized e.g. matched by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language recognized by the automaton traces a path from the start state to one or more final states.

At block after the automaton is constructed the automaton is optimized to among other things reduce its complexity and size. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to a hardware element e.g. SMEs other elements on the FSM lattice and determines the connections between the hardware elements.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements corresponding to each node of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM lattice .

At block the placed netlist is routed to determine the settings for the programmable switching elements e.g. inter block switching elements intra block switching elements and intra row switching elements in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the programmable switching elements are determined by determining specific conductors of the FSM lattice that will be used to connect the selected hardware elements and the settings for the programmable switching elements. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM lattice .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for programming of a FSM lattice . The plurality of bits are referred to herein as an image.

At block an image is published by the compiler . The image comprises a plurality of bits for programming specific hardware elements of the FSM lattice . In embodiments where the image comprises a plurality of bits e.g. and the image can be referred to as a binary image. The bits can be loaded onto the FSM lattice to program the state of SMEs the special purpose elements and the programmable switching elements such that the programmed FSM lattice implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM lattice to specific states in the automaton. Accordingly the bits in the image can program the specific hardware elements to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a programming device for loading the image onto the FSM lattice . In yet another example the image can be published by loading the image onto a FSM lattice e.g. the FSM lattice .

In an example an image can be loaded onto the FSM lattice by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements. In an example the hardware elements e.g. SMEs special purpose elements programmable switching elements of the FSM lattice are memory mapped such that a programming device and or computer can load the image onto the FSM lattice by writing the image to one or more memory addresses.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Referring now to an embodiment of the state machine engine is illustrated. As previously described the state machine engine is configured to receive data from a source such as the memory over a data bus. In the illustrated embodiment data may be sent to the state machine engine through a bus interface such as a DDR3 bus interface . The DDR3 bus interface may be capable of exchanging data at a rate greater than or equal to 1 GByte sec. As will be appreciated depending on the source of the data to be analyzed the bus interface may be any suitable bus interface for exchanging data to and from a data source to the state machine engine such as a NAND Flash interface PCI interface etc. As previously described the state machine engine includes one or more FSM lattices configured to analyze data. Each FSM lattice may be divided into two half lattices. In the illustrated embodiment each half lattice may include 24K SMEs e.g. SMEs such that the lattice includes 48K SMEs. The lattice may comprise any desirable number of SMEs arranged as previously described with regard to . Further while only one FSM lattice is illustrated the state machine engine may include multiple FSM lattices as previously described.

Data to be analyzed may be received at the bus interface and transmitted to the FSM lattice through a number of buffers and buffer interfaces. In the illustrated embodiment the data path includes data buffers process buffers and an inter rank IR bus and process buffer interface . The data buffers are configured to receive and temporarily store data to be analyzed. In one embodiment there are two data buffers data buffer A and data buffer B . Data may be stored in one of the two data buffers while data is being emptied from the other data buffer for analysis by the FSM lattice . In the illustrated embodiment the data buffers may be 32 KBytes each. The IR bus and process buffer interface may facilitate the transfer of data to the process buffer . The IR bus and process buffer ensures that data is processed by the FSM lattice in order. The IR bus and process buffer may coordinate the exchange of data timing information packing instructions etc. such that data is received and analyzed in the correct order. Generally the IR bus and process buffer allows the analyzing of multiple data sets in parallel through logical ranks of FSM lattices .

In the illustrated embodiment the state machine engine also includes a de compressor and a compressor to aid in the transfer of the large amounts of data through the state machine engine . The compressor and de compressor work in conjunction such that data can be compressed to minimize the data transfer times. By compressing the data to be analyzed the bus utilization time may be minimized. Based on information provided by the compiler a mask may be provided to the state machine engine to provide information on which state machines are likely to be unused. The compressor and de compressor can also be configured to handle data of varying burst lengths. By padding compressed data and including an indicator as to when each compressed region ends the compressor may improve the overall processing speed through the state machine engine . The compressor and de compressor may also be used to compress and decompress match results data after analysis by the FSM lattice .

As previously described the output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of programmable elements of the FSM lattice . Each state vector may be temporarily stored in the state vector cache memory for further hierarchical processing and analysis. That is the state of each state machine may be stored such that the final state may be used in further analysis while freeing the state machines for reprogramming and or further analysis of a new data set. Like a typical cache the state vector cache memory allows storage of information here state vectors for quick retrieval and use here by the FSM lattice for instance. Additional buffers such as the state vector memory buffer state vector intermediate input buffer and state vector intermediate output buffer may be utilized in conjunction with the state vector cache memory to accommodate rapid analysis and storage of state vectors while adhering to packet transmission protocol through the state machine engine .

Once a result of interest is produced by the FSM lattice match results may be stored in a match results memory . That is a match vector indicating a match e.g. detection of a pattern of interest may be stored in the match results memory . The match result can then be sent to a match buffer for transmission over the bus interface to the processor for example. As previously described the match results may be compressed.

Additional registers and buffers may be provided in the state machine engine as well. For instance the state machine engine may include control and status registers . In addition restore and program buffers may be provided for using in programming the FSM lattice initially or restoring the state of the machines in the FSM lattice during analysis. Similarly save and repair map buffers may also be provided for storage of save and repair maps for setup and usage.

As discussed in some embodiments each of the rows in the block may include one or more special purpose elements such as a counter a programmable Boolean logic cell a look up table RAM a field programmable gate array FPGA an application specific integrated circuit ASIC a programmable processor e.g. microprocessor or other element for performing a special purpose function. The special purpose element may be connected to intra row switching elements with one or more GOT in each row . Furthermore outputs from each row may be connected to intra block switching elements which may be connected by inter block switching elements .

It should be noted that while depicts each row as having one counter cell A or one Boolean logic cell B the rows are not limited to having only one special purpose element . For example in some embodiments one or more rows may have one or more counters A as well as additional special purpose elements . The special purpose elements including the counters A may be able to communicate with other special purpose elements via for example intra row switching elements within a row . Furthermore the counters A are not limited to 12 bit decrementing counters. In some embodiments suitable counters of different bit sizes and or counters that increment to a initial value may also be used.

In some embodiments each active GOT in each row may output a signal indicating the detection of one or more conditions and the special purpose elements may receive the outputs of GOTs selectively coupled thereto to perform at least one of various possible functions. For example the Boolean logic cells B may be used to perform logical functions such as AND OR NAND NOR Sum of Products SoP Negated Output Sum of Products NSoP Negated Output Product of Sum NPoS and Product of Sums PoS functions. Furthermore outputs from the counter A and or the Boolean logic cell B may be communicated through for example the intra row switching elements and the intra block switching elements to perform counting or logic functions with greater complexity. In some embodiments different special purpose elements such as counters A and Boolean logic cells B may be used together. For example an output of one or more Boolean logic cells B may be counted by one or more counters A in a block .

While the possible connections between the Boolean logic cells B and the other elements of the block are simplified in the Boolean logic cells B may have multiple inputs which may be selectively coupled to for example GOTs as well as multiple programmable inputs. A representation of a Boolean logic cell B is illustrated in the logic diagram of . The logic diagram is one example of a configuration of logic elements in the Boolean logic cell B. In some embodiments the Boolean logic cell B may have three programmable bits. A first programmable bit includes inverting a first input of the cell B a second programmable bit includes inverting a last output of the cell B and a third programmable bit includes a selection of an AND gate or an OR gate as the final output gate of the cell B. In some embodiments the three programmable bits for a particular logic cell B may be programmed by a the image produced by the compiler to perform a selected one of a variety of possible logical operations on the GOT outputs selectively coupled to the logic element. Depending on the logical operations to be performed any combination of the three programmable bits may be programmed to result in different logical operations through the Boolean logic cell B.

As represented by the logic diagram in a particular embodiment a Boolean logic cell B may have for example 16 inputs that may be selectively coupled to outputs of other elements such as GOTs through programming of the lattice. Additionally a Boolean logic cell may also be selectively couple to other elements in other rows or other elements in other blocks via intra row switching elements intra block switching elements and inter block switching elements . Different selective couplings between different elements may be at least partially determined by the image loaded by the compiler . The first programmable bit the inversion of the first input i.e. the inputs may be applied through the inverting input . The inverting input may apply a suitable voltage to inputs of the XOR gates which may function as controlled inverters. In some embodiments a GOT input may be passed through the XOR gate if the inverting input is low and the GOT input may be inverted when output through the XOR gate when the inverting input is high.

The output from the XOR gates may be a first input into OR gates . A second input into the OR gates may be a mask input line . The mask input line may input a high signal in one or more OR gates associated with the inputs to selectively disable one or more inputs or input a low signal in one or more OR gates to selectively enable one or more of the inputs . In some embodiments the mask input line may be determined for example by a register setting or by the selective couplings in each row or block .

If the mask inputs enable the OR gates to carry through the outputs from the XOR gates either the GOT inputs or the inverse GOT inputs the output of the OR gates may be transmitted through a series of AND gates and . The first set of AND gates may perform the AND operation on two or more outputs of the OR gate associated with each input and the second set of AND gates may perform an AND operation on the outputs of the first set of AND gates .

The outputs of the second set of AND gates may be input into either an AND gate or an OR gate . The selection of the AND gate or the OR gate may be the second programmable bit of the Boolean logic cell B. The third programming bit includes an inverting output signal which may be input to the XOR gate which may represent a controlled inverter for the output of either the AND gate or the OR gate .

In some embodiments the Boolean logic cell B may be used to determine whether a match has occurred after all data in a data stream to be evaluated has been processed. For example a Boolean logic cell B may be used to determine whether a combination of conditions A and B have been detected where it may be possible that condition A may be detected in a data stream before condition B may be detected in the data stream or vice versa . For example the Boolean logic cell B may be used to determine a match at end of data situation where a match may only be determined at the end of a data stream. Furthermore the Boolean logic cell B may be used to determine a this and not that situation where a match may occur when a condition A this has been occurred and a condition B that has not occurred.

In some embodiments the Boolean logic cell B may include an end of data input also referred to as an anchor which may be coupled to the OR gate . The end of data input may be used for example to determine a match at end of data situation or a this and not that situation. The end of data input may block the output of the Boolean logic cell B until an end of data input is high. The other input of the OR gate may be a mask input which may disable the transmission of the end of data signal through OR gate when the mask input is high or enable the output of the end of data signals when the mask input is low. The end of data output from the OR gate may be input into the AND gate . The output from the AND gate is low when the end of data input is low. If the end of data input is high and the output of the XOR gate is also high the output of the XOR gate may pass through the AND gate as the output . Therefore the output is high only if the output of the XOR gate is high and the end of data signal has been input at the AND gate indicating that the processing of the data stream is complete.

Different programming combinations of the three programmable bits e.g. the inverting input signal the inverting output signal and the selection between the final outputting AND gate or OR gate may result in 8 i.e. 2 possible logical functions that may be performed in each Boolean logic cell B. Equivalent logic circuit diagrams are represented in where functions are a result of not inverting the first inverting input signal and functions are a result of inverting the first inverting input signal . are a result of not inverting the last inverting output signal and are a result of inverting the last inverting output signal . Furthermore are a result of selecting the AND gate as the final output gate of the Boolean logic cell B and are a result of selecting the OR gate as the final output gate of the Boolean logic cell B.

Each of the logical functions represented in depicts the function performed on an input selectively coupled to an output of an element such as a GOT in the row . However each function may be performed on one or more inputs selectively coupled to the output s of one or more elements such as GOTs and more than one function may be performed on the inputs by a Boolean logic cell B in each row . Moreover for operations where an entire data set will be processed before a match is determined each logical function may include the last AND gate which outputs when the end of data signal is input. For operations in which the end of data signal is not considered the OR gate may be masked by the mask input which may not output the end of data signal to the AND gate .

While the invention may be susceptible to various modifications and alternative forms specific embodiments have been shown by way of example in the drawings and have been described in detail herein. However it should be understood that the invention is not intended to be limited to the particular forms disclosed. Rather the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the following appended claims.

