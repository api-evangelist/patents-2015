---

title: Systems and methods for active operating system kernel protection
abstract: Systems and methods for intercepting computing device system calls for a computing device including a kernel having a system call table. A hypervisor is executed on the computing device, the hypervisor configured to control at least one of the computing device processor registers. At least one modified kernel structure is created, the modified kernel structure including a modified system call table. A memory address of an original system call handler is determined, the original system call handler configured to receive kernel operation commands. A size of a loaded image of the original system call handler is determined. A copy of the original system call handler as a second system call handler is created, and the second system call handler intercepts a computing device system call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639698&OS=09639698&RS=09639698
owner: AO KASPERSKY LAB
number: 09639698
owner_city: Moscow
owner_country: RU
publication_date: 20151116
---
This Application is a continuation application of U.S. application Ser. No. 14 601 331 filed Jan. 21 2015 now U.S. Pat. No. 9 189 630 which is incorporated by reference herein in its entirety.

The invention relates generally to antivirus systems and methods and more particularly to computing systems and associated methods for handling system calls.

Traditionally antivirus systems utilize the interception of systems calls in order to detect malicious programs. Detection can occur as early as the execution stage. For example systems calls that are performing suspicious activities such as the writing of an executable file to the Windows folder can be intercepted. The originating executable can be identified as potentially or likely malicious. As a result it is possible to block even unknown malicious programs which is an advantage of current antivirus systems.

However the ability to intercept system service calls in particular versions of the Windows operating system OS is limited by the Microsoft implemented protections. Kernel Patch Protection KPP informally known as PatchGuard is a feature of 64 bit x64 editions of Microsoft Windows that prevents patching the kernel. PatchGuard prevents the use of the aforementioned traditional interception methods. PatchGuard tracks changes in a number of important objects of the kernel of the OS for example malicious changes caused by the operation of rootkits or modifications by outside software such as antiviruses and take appropriate action if changes are detected. For example PatchGuard can cause a system crash when detecting changes in the system calls table or the Interrupt Descriptor Table IDT .

Existing solutions offer the ability to bypass the protections of PatchGuard and other similar solutions. For example a hypervisor can be utilized to bypass PatchGuard to create interceptors of the kernel objects without a system crash. Bypassing PatchGuard is therefore possible with the help of hardware virtualization. However the creation of interceptors for kernel objects for example SSDT monitoring requires knowledge of the internal structure of those kernel objects. The kernel object structure can vary depending on OS version. As a result multiple versions of the interceptor are required to support multiple versions of an OS and its particular kernel object structure s .

Therefore there is a need for systems and methods for handling system calls that are effective efficient and implementable in multiple versions of operating systems having varying kernel object structures.

Embodiments of the present application substantially meet the aforementioned needs of the industry. In an embodiment a machine implemented method for intercepting computing device system calls wherein the computing device includes a kernel including a system call table comprises executing a hypervisor on the computing device the hypervisor configured to control at least one computing device processor register the at least one computing device processor register configured to be used by the kernel creating at least one modified kernel structure the modified kernel structure including a modified system call table determining a memory address of an original system call handler the original system call handler configured to receive and execute kernel operation commands determining a size of a loaded image of the original system call handler creating a copy of the original system call handler as a second system call handler and intercepting by the second system call handler as directed by the hypervisor a computing device system call.

In an embodiment a system for intercepting computing device system calls comprises a computing platform including computing hardware of at least one processor data storage and input output facilities an operating system implemented on the computing hardware a kernel including a system call table and a system call handler configured to receive and execute kernel operation commands a plurality of computing platform processor registers and instructions that when executed on the computing platform cause the computing platform to implement a hypervisor configured to control at least one of the computing platform processor registers the at least one computing platform processor register configured to be used by the kernel and an intercept engine configured to create a copy of the system call table as a second system call table create a copy of the system call handler as a second system call handler and intercept by the second system call handler as directed by the hypervisor a computing platform system call.

In an embodiment a system for intercepting computing device system calls the computing device including a kernel including a system call table comprises means for executing a hypervisor configured to control at least one computing device processor register the at least one computing device processor register configured to be used by the kernel means for creating a modified system call table means for determining a memory address of an original system call handler the original system call handler configured to receive and execute kernel operation commands means for determining a size of a loaded image of the original system call handler means for creating a copy of the original system call handler as a second system call handler and means for intercepting by the second system call handler as directed by the hypervisor a computing device system call.

The above summary is not intended to describe each illustrated embodiment or every implementation of the invention. The figures and the detailed description that follow more particularly exemplify these embodiments.

While the invention is amenable to various modifications and alternative forms specifics thereof have been shown by way of example in the drawings and will be described in detail. It should be understood however that the intention is not to limit the invention to the particular embodiments described. On the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

Aspects of the invention are directed towards systems and methods for handling computer system calls that are implementable in multiple versions of operating systems having varying internal kernel object structures.

The computer system can be one physical machine or can be distributed among multiple physical machines such as by role or function or by process thread in the case of a cloud computing distributed model. In various embodiments aspects of the invention can be configured to run in virtual machines that in turn are executed on one or more physical machines. It will be understood by persons of skill in the art that features of the invention may be realized by a variety of different suitable machine implementations.

The system includes various engines each of which is constructed programmed configured or otherwise adapted to autonomously carry out a function or set of functions. The term engine as used herein is defined as a real world device component or arrangement of components implemented using hardware such as by an application specific integrated circuit ASIC or field programmable gate array FPGA for example or as a combination of hardware and software such as by a microprocessor system and a set of program instructions that adapt the engine to implement the particular functionality which while being executed transform the microprocessor system into a special purpose device. An engine can also be implemented as a combination of the two with certain functions facilitated by hardware alone and other functions facilitated by a combination of hardware and software. In certain implementations at least a portion and in some cases all of an engine can be executed on the processor s of one or more computing platforms that are made up of hardware e.g. one or more processors data storage devices such as memory or drive storage input output facilities such as network interface devices video devices keyboard mouse or touchscreen devices etc. that execute an operating system system programs and application programs while also implementing the engine using multitasking multithreading distributed e.g. cluster peer peer cloud etc. processing where appropriate or other such techniques. Accordingly each engine can be realized in a variety of physically realizable configurations and should generally not be limited to any particular implementation exemplified herein unless such limitations are expressly called out. In addition an engine can itself be composed of more than one sub engines each of which can be regarded as an engine in its own right. Moreover in the embodiments described herein each of the various engines corresponds to a defined autonomous functionality however it should be understood that in other contemplated embodiments each functionality can be distributed to more than one engine. Likewise in other contemplated embodiments multiple defined functionalities may be implemented by a single engine that performs those multiple functions possibly alongside other functions or distributed differently among a set of engines than specifically illustrated in the examples herein.

As an initial matter a description of the operation of system function call in a Windows OS is provided. Referring to a flowchart of an exemplary execution of an API function in a Windows operating system is depicted. In the example illustrated the API function WriteFile is depicted. In an embodiment WriteFile writes data to a specified file or input output I O device.

At a Windows application attempts to write data to a file by calling the relevant Win32 API function WriteFile in dynamic link library DLL Kernel32.dll. For example the Windows applications Microsoft Word or Notepad can respectively call the API function WriteFile.

At a call for NtWriteFile is made. In embodiments a corresponding call to the related system function is made. For example in embodiments the call to NtWriteFile is made via Ntdll.dll. In other embodiments other system function DLLs are utilized for the respective system function called.

At a call for a system interrupt at is made. In an embodiment a search for the relevant handler is likewise conducted. In an embodiment a search for the relevant handler is done by the KiSystemService function in Ntoskrnl.exe during the call for NtWriteFile. In other embodiments other system service functions are utilized for the search for the relevant handler.

At a call for NtWriteFile occurs. In an embodiment the call for the operation is done in Ntoskrnl.exe. In other embodiments other DLLs are utilized for the call for the respective operation.

At execution of the operation occurs. In the illustrated embodiment a direct writing of a file or I O device occurs. In an embodiment NtWriteFile is executed in Ntoskrnl.exe. In other embodiments execution utilizes other executables or DLLs to execute the respective operations.

In an embodiment as depicted in a user mode comprises the operations of and . The operations of and occur in the user mode and after the call for the interruption a transition to the kernel mode occurs. In an embodiment as depicted in a kernel mode comprises the operations of and . Referring again to in x86 architecture processors the transition from user mode to kernel mode requires a call for the SYSCALL SYSENTER instruction hereinafter only SYSCALL will be used . In x64 architecture processors the address of this handler is stored in the LSTAR Long System Target Address Register register which belongs to MSRs Machine Specific Registers .

Referring to a block diagram of such a system service call is depicted according to an embodiment. As shown user mode and kernel mode likewise map to the corresponding user mode and kernel mode described in .

During the transition to kernel mode in a call for system service the system services dispatcher copies the system call arguments from the user mode thread stack to its own kernel mode stack so that the user cannot change the arguments when the kernel accesses them . For example in Windows OSs the dispatcher is KiSystemService. System services dispatcher is further configured to run the particular system service from the system services table . For example in Windows OSs the system services table is the System Service Dispatch Table SSDT .

As a result when operating protection tools such as Patch Guard are utilized a modification of system service requires a modification of system services table itself which can cause a system crash. In an embodiment in order to bypass such a restriction a separate copy of system services table can be created with a separate handler for the SYSCALL call hereinafter we will use the term handler for simplicity in order to use the separate copy of the system services table. In an embodiment the copy of the system services table comprises operating system structures related to system function calls.

Referring to a block diagram of address space of a kernel implementing a system call handler is depicted according to an embodiment. In an embodiment the call handler comprises a handler of a particular file operation. depicts an address space for the kernel.

In an embodiment at a particular address location an original handler is loaded. Original handler can be modified as will be described by any number of suitable techniques. In an embodiment modification of original handler comprises address substitution for example by modifying SSDT IDT tables . In another embodiment modification of original handler comprises direct modification of the original handler for example using splicing . In another embodiment modification of original handler comprises modification of the body of the system function itself. For example by substituting the address of the original handler with the address of a substitute handler an antivirus check of a number of file or register operations can be conducted as will be described. Any of the aforementioned approaches can be utilized in combination or in partial combination.

In an embodiment since PatchGuard checks the values of the MSR register it may not be possible to substitute the values of the MSR register this register is discussed below in more detail using the above described techniques.

Referring to virtualization utilizing a hypervisor can bypass KPP tools such as PatchGuard. In an embodiment the virtualization using a hypervisor can be implemented on systems such as those depicted in as will be discussed. In an embodiment hypervisor is utilized to bypass PatchGuard . In an embodiment hypervisor comprises a virtual machine monitor VMM . In embodiments the VMM is a piece of computer software firmware or hardware that creates and runs virtual machines.

Hypervisor can include a high privilege level for execution. For example hypervisor can be level 1 the kernel can be level 0 and user application level can be 3 . In embodiments hypervisor can be loaded at any time for example at the start of the OS or during operation of the OS. At the initialization of hypervisor a list of instructions is assigned which can be intercepted. For example in order to intercept the SYSCALL instruction it is sufficient to specify the interception of RDMSR reading of MSRs and WRMSR writing to MSRs instructions.

Therefore using hypervisor the MSR register can be controlled. In an embodiment for example the MSR register is the LSTAR. In certain embodiments hereinafter for readability purposes simply the term MSR is used. In an embodiment controlling the MSR register comprises writing the required value to the MSR and further saving the original value as a copied value . This allows the copied value to be read by protection tools like PatchGuard without causing a system crash and at the same time allows a modified handler to use the required value

Referring to a flowchart of a method for loading a system call handler is depicted according to an embodiment. In an embodiment a loading engine is configured to load a system call handler as described herein.

The method of comprises at determining in the memory the address of the code of original handler . In an embodiment at a determination of the size of the loaded image and its location in the memory is made. In embodiments this is referred to as localization of the code of the original handler .

At a copy of original handler is created. In an embodiment the copy of original handler is made in the form of an image thereby creating substitute handler . According to embodiments the memory size for the copy can be allocated by taking into account the possible changes of substitute handler and its respective variables and operations. In an embodiment space can be allocated in the memory of an already loaded driver which can simplify the modification of substitute handler .

At modification of relative references is performed. In an embodiment the relative references related to substitute handler are modified.

At substitution of service address tables is performed. In an embodiment replacement of addresses of service tables for example SSDT can be made in the code of substitute handler .

At initialization of one or more exceptions tables is performed. In an embodiment once initialized the exceptions related to the execution of the code of substitute handler can be correctly handled. All the above mentioned modifications can be made using a disassembler which can be utilized for disassembly of original handler commands and their subsequent modification for example to . These modifications can be utilized to completely and properly replace original handler . Further. other modifications can relate to various issues of computer security related to the analysis of intercepted calls.

Once substitute handler is initialized substitute handler can be used to intercept system calls. For example substitute handler can intercept file and register operations as well as operations related to the taking of screenshots. In the latest Windows OS versions substitute handler can intercept file and register operations using the OS s API itself.

Within various operating systems a certain class of malicious programs generates screenshots with the purpose of isolating important user information for example passwords . In order to counter such programs embodiments ensure monitoring of the interceptions of the functions related to the taking of screenshots. A number of techniques can be utilized that allow a descriptor of a window of the required application to be obtained from which a copy the bitmap from can be made. In other embodiments Direct3D surfaces can be converted into a bitmap directly in the memory which can be subsequently saved for analysis. In order to be able to track malicious applications which use such techniques embodiments ensure the interception of the SYSCALL call but also modify the SSDT table for the interception of the required calls.

According to embodiments hypervisor does not need to always be loaded or held in memory during operation of the OS. For example hypervisor can also be loaded during operation of the OS in a number of conditional situations or combination of conditional situations.

In an embodiment hypervisor can be loaded during operation of the OS if a critical application for example a banking application is loaded for which it is also useful to ensure protection from the taking of screenshots.

In an embodiment hypervisor can be loaded during operation of the OS if a user access a site of a bank or of a payment system for example PayPal for which it is also useful to ensure protection from the taking of screenshots.

In an embodiment hypervisor can be loaded during operation of the OS if an antivirus application requires the presence of self protection i.e. protection from attempts to end the antivirus application process or to stop the operation of the antivirus driver . In such embodiments tracking the relevant system calls is likewise useful.

In an embodiment hypervisor can be loaded during operation of the OS if a flexible application control is utilized by the OS. For example if an OS is using the substitution of system calls or if an OS is utilizing an isolated environment sandbox tracking the relevant system calls is likewise useful.

In an embodiment hypervisor can be loaded during operation of the OS as part of a check of a suspicious application and any emulation of the suspicious application. For example a suspicious application may implement calls not for the actual handlers of the kernel s service functions but for special functions of the OS s behavior emulator. In such cases the application thinks that it is being run on the actual system but no modifications to the actual OS are made. On the basis of emulator protocols the degree of the application s hazardousness is determined. In embodiments such a check can be performed either on the user s machine or on a dedicated cloud service.

In embodiments additional situations or conditional scenarios can be utilized to load a hypervisor. Further a hypervisor can be loaded prior to or any time up to a termination of the OS. The foregoing conditional situations in no way limit when a hypervisor may be loaded as these embodiments are given only by way of example and are not intended to limit the scope of the invention.

Referring to a flowchart of a method for handling system calls is depicted according to an embodiment. In an embodiment a handling engine is configured to intercept one or more system calls as described herein.

The method of comprises if one of the aforementioned conditional situations is satisfied loading a hypervisor at . In other embodiments a hypervisor can be loaded according to other criteria. In embodiments the hypervisor can be substantially similar to hypervisor described above.

At the SSDT table is modified. In an embodiment both SSDT and IDT tables are modified. Such modification can comprise address substitution as described with respect to .

At a SYSCALL function handler is loaded. In an embodiment the loading of a SYSCALL function handler comprises a method for loading a system call handler substantially similar to the method described with respect to . In an embodiment the system call handler comprises a handler substantially similar to substitute handler .

At the system call handler i.e. substitute handler intercepts a system call. In an embodiment the system call handler utilizes the modified SSDT table to obtain a context of the system call. For example based on data about the system call it can be determined what process made the call.

At an antivirus analysis can be conducted. In an embodiment the antivirus analysis determines if the process that made the call is malicious. In embodiments malicious behavior can be determined. Therefore at the modified handler is called and the address is specified in the modified SSDT table.

It should be also noted that in some cases a synchronization of the original and modified SSDT tables may be required. The original SSDT table can be updated as part of a hot patching procedure.

In addition embodiments of an interception system using a hypervisor can be implemented so as to not decrease any OS protection level ensured by the PatchGuard or similar technology. Because all the modules loaded on x64 systems undergo a signature check it is possible to use a hypervisor to protect a copy of the interceptor and a copy of service tables from being modified ensuring an even more reliable equivalent of the PatchGuard protection.

The computer system can comprise a computing device such as a personal computer includes one or more processing units a system memory and a system bus which contains various system components including a memory connected with the one or more processing units . In various embodiments the processing units can include multiple logical cores that are able to process information stored on computer readable media. The system bus is realized as any bus structure known at the relevant technical level containing in turn a bus memory or a bus memory controller a peripheral bus and a local bus which is able to interact with any other bus architecture. The system memory can include non volatile memory such as Read Only Memory ROM or volatile memory such as Random Access Memory RAM . The Basic Input Output System BIOS contains basic procedures ensuring transfer of information between the elements of personal computer for example during the operating system boot using ROM .

Personal computer in turn has a hard drive for data reading and writing a magnetic disk drive for reading and writing on removable magnetic disks and an optical drive for reading and writing on removable optical disks such as CD ROM DVD ROM and other optical media. The hard drive the magnetic drive and the optical drive are connected with system bus through a hard drive interface a magnetic drive interface and an optical drive interface respectively. The drives and the corresponding computer information media represent energy independent means for storage of computer instructions data structures program modules and other data on personal computer .

The system depicted includes hard drive a removable magnetic drive and a removable optical drive but it should be understood that it is possible to use other types of computer media capable of storing data in a computer readable form solid state drives flash memory cards digital disks random access memory RAM etc. connected to system bus through a controller .

The computer comprises a file system where the recorded operating system is stored as well as additional program applications other program engines and program data . The user can input commands and information into the personal computer using input devices keyboard mouse . Other input devices not shown can also be used such as a microphone a joystick a game console a scanner etc. Such input devices are usually connected to the computer system through a serial port which in turn is connected to a system bus but they can also be connected in a different way for example using a parallel port a game port or a Universal Serial Bus USB . The monitor or another type of display device is also connected to system bus through an interface such as a video adapter . In addition to monitor personal computer can be equipped with other peripheral output devices not shown such as speakers a printer etc.

Personal computer is able to work in a network environment in this case it uses a network connection with one or several other remote computers . Remote computer s is are similar personal computers or servers which have most or all of the above elements noted earlier when describing the substance of personal computer shown in . The computing network can also have other devices such as routers network stations peering devices or other network nodes.

Network connections can constitute a Local Area Network LAN and a World Area Network WAN . Such networks are used in corporate computer networks or in corporate intranets and usually have access to the Internet. In LAN or WAN networks personal computer is connected to the Local Area Network through a network adapter or a network interface . When using networks personal computer can use a modem or other means for connection to a world area network such as the Internet. Modem which is an internal or an external device is connected to system bus through serial port . It should be clarified that these network connections are only examples and do not necessarily reflect an exact network configuration i.e. in reality there are other means of establishing a connection using technical means of communication between computers.

Referring to a block diagram of a system for handling system calls is depicted according to an embodiment. System comprises a processor address or memory space a kernel and one or more user applications .

In an embodiment processor can be any programmable device that accepts digital data as input is configured to process the input according to instructions or algorithms and provides results as outputs. In an embodiment processor can be a central processing unit CPU configured to carry out the instructions of a computer program. Processor is therefore configured to perform basic arithmetical logical and input output operations.

The address space of operably coupled memory can comprise volatile or non volatile memory as required by the coupled processor and kernel to not only provide space to execute the instructions or algorithms but to provide the space to store the instructions themselves. In embodiments volatile memory can include random access memory RAM dynamic random access memory DRAM or static random access memory SRAM for example. In embodiments non volatile memory can include read only memory flash memory ferroelectric RAM hard disk floppy disk magnetic tape or optical disc storage for example. The foregoing lists in no way limit the type of memory that can be used as these embodiments are given only by way of example and are not intended to limit the scope of the invention.

Kernel comprises an engine that manages input output requests from software and translates the requests into data processing instructions for processor . In an embodiment kernel mediates access to the resources of a computer.

User applications comprises one or more programs designed to carry out operations for a specific application. In embodiments one of the user applications can comprise a malicious program that embodiments of systems can detect.

System can therefore comprise a loading engine and or intercept engine as described herein with respect to for example . For example the respective hardware calls from one or more engine instruction sets can be executed by processor taking into account address space kernel and user applications as described herein.

For example referring to a block diagram of a system for handling system calls that can be implemented on the computer system of is depicted according to an embodiment.

System comprises an intercept engine and a hypervisor . Intercept engine comprises processor instructions for loading a system call handler. In embodiments intercept engine further comprises processor instructions for intercepting system calls. In other embodiments a loading engine comprises processor instructions for loading a system call handler and an intercept engine comprises processor instructions for intercepting system calls. The functionality or scope of the respective engines are not intended to be limited by the descriptions herein rather these embodiments are given only by way of example and are not intended to limit the scope of the invention.

In an embodiment hypervisor is substantially similar to hypervisor described herein. Hypervisor is configured to control at least one of the processor registers for example those implemented or accessible by kernel and or processor .

In operation intercept engine is configured to create modified kernel structures as described herein. In embodiments a modified system call handler is generated. In embodiments a modified system call table is generated. Intercept engine is further configured to determine a memory address of an original system call handler. Intercept engine is further configured to determine a size of a loaded image of the original system call handler. Intercept engine is further configured to create a copy of the original system call handler as a second handler. Intercept engine is further configured to intercept by the second handler a computing device system call. In an embodiment intercept engine is further configured to conduct an antivirus analysis on the intercepted computing device call.

The embodiments above are intended to be illustrative and not limiting. Additional embodiments are within the claims. In addition although as aspects of the present invention have been described with reference to particular embodiments those skilled in the art will recognize that changes can be made in form and detail without departing from the scope of the invention as defined by the claims.

Persons of ordinary skill in the relevant arts will recognize that the invention may comprise fewer features than illustrated in any individual embodiment described above. The embodiments described herein are not meant to be an exhaustive presentation of the ways in which the various features of the invention may be combined. Accordingly the embodiments are not mutually exclusive combina tions of features rather the invention may comprise a combination of different individual features selected from different individual embodiments as will be understood by persons of ordinary skill in the art.

Any incorporation by reference of documents above is limited such that no subject matter is incorporated that is contrary to the explicit disclosure herein. Any incorporation by reference of documents above is further limited such that no claims that are included in the documents are incorporated by reference into the claims of the present application. The claims of any of the documents are however incorporated as part of the disclosure herein unless specifically excluded. Any incorporation by reference of documents above is yet further limited such that any definitions provided in the documents are not incorporated by reference herein unless expressly included herein.

For purposes of interpreting the claims for the present invention it is expressly intended that the provisions of Section 112 sixth paragraph of 35 U.S.C. are not to be invoked unless the specific terms means for or step for are recited in a claim.

