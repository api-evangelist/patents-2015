---

title: Apparatus and method for controlling execution of a single thread by multiple processors
abstract: An apparatus includes a plurality of processors and a holder unit. The plurality of processors execute a task as a unit of processing by dividing the task into multiple threads including single and parallel threads, where the single thread is executed by only one of the plurality of processors whose respective pieces of processing have reached the thread, and the parallel thread is executed in parallel with another parallel thread by the plurality of processors. The holder unit is configured to held information to be shared by the plurality of processors. Each processor executes one of the multiple threads at a time, and causes the holder unit to hold reaching-state information indicating an extent to which the multiple threads executed by the plurality of processors have reached the single thread. Each processor determines whether to execute the single thread, based on the reaching-state information held in the holder unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569273&OS=09569273&RS=09569273
owner: FUJITSU LIMITED
number: 09569273
owner_city: Kawasaki
owner_country: JP
publication_date: 20150617
---
This application is based upon and claims the benefit of priority of the prior Japanese Patent Application No. 2014 165172 filed on Aug. 14 2014 the entire contents of which are incorporated herein by reference.

The embodiment discussed herein is related to apparatus and method for controlling execution of a single thread by multiple processors.

A parallel computer including multiple processors operable in parallel enhances processing efficiency by dividing a task as a unit of processing into multiple threads and then making the multiple processors to execute the threads. A processor device such as a central processing unit CPU including multiple cores is one of parallel computers.

For a parallel computer of this type there has been proposed a technique in which a storage area is first allocated to a thread continuously activating from the start to the end of a program and then variables used in the other treads threads are stored in the storage area for example see Japanese Laid open Patent Publication No. 2002 99426 . This technique ensures that even when another thread executed in parallel ends a variable used in the other thread is held in the storage area without being lost during the execution of the program.

Another proposed technique is that based on a value set to a flag allocated to a main memory a thread waits for execution of synchronous processing until execution of an instruction code by another thread completes and executes the synchronous processing after the execution of the instruction code is completed for example see Japanese Laid open Patent Publication No. 2011 134145 .

According to an aspect of the invention an apparatus includes a plurality of processors and a holder unit. The plurality of processors execute a task as a unit of processing by dividing the task into multiple threads including a single thread and a parallel thread where the single thread is a thread to be executed by only one of the plurality of processors whose respective pieces of processing have reached the thread and the parallel thread is a thread to be executed in parallel with another parallel thread by the plurality of processors. The holder unit is configured to held information to be shared by the plurality of processors. Each of the plurality of processors executes one of the multiple threads at a time and causes the holder unit to hold reaching state information indicating an extent to which the multiple threads executed by the plurality of processors have reached the single thread. Each processor determines whether to execute the single thread based on the reaching state information held in the holder unit.

The object and advantages of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the claims.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are not restrictive of the invention as claimed.

A storage area used by multiple threads is allocated to an external storage device such as a main memory in order to enable access from multiple threads. For this reason the number of cycles for access to the storage area is larger than the number of cycles for access to a register provided in a processor device and thereby the access efficiency is low. As a result processing efficiency during execution of multiple threads in parallel may be lowered.

Hereinafter embodiments are described with reference to the accompanying drawings. A signal line for transmitting a signal is described by using a reference numeral same as a signal name.

The execution units may execute multiple threads in parallel or a single thread alone. The holder unit is shared by both of the processors and is configured to hold reaching state information indicating an extent to which processing executed by the execution units has reached a single thread STH STH or STH . The single thread STH is a thread exclusively executed only by any one of the execution units . For example when the execution unit of the processor executes a single thread STH the execution unit of the other processor skips the single thread STH without executing. In the example illustrated in the holder unit holds reaching state information corresponding to one single thread STH.

Each of the control units stores reaching state information into the holder unit when processing of execution units reach an entrance of the single thread STH. Each of the determination units determines based on the reaching state information held by the holder unit whether to cause execution units to execute the single thread.

Lower part of illustrates that after a thread PTH is executed by execution units in parallel a single thread STH is executed by the execution unit and further after a thread PTH is executed by execution units in parallel a single thread STH is executed by the execution unit . Reference numerals T T T T T and T represent time indicating that processing by the execution unit is faster than processing by the execution unit .

At times T T processing of both the execution units has not reached an entrance of a single thread STH. Therefore the holder unit holds reaching state information indicating no execution unit whose processing has reached the single thread STH .

At a time T processing executed by the execution unit reaches the entrance of the single thread STH and the control unit stores reaching state information indicating processing of the execution unit has reached the single thread STH into the holder unit . Since the holder unit is provided in the processor device time for storing the reaching state information is shorter than time for storing reaching state information into an external storage device of the processor device. The determination unit of the processor including the execution unit whose processing has reached the entrance of the single thread STH causes the execution unit based on the reaching state information for the single thread STH held by the holder unit to execute the single thread STH. Next at a time T the execution unit executes a thread PTH and the execution unit executes a thread PTH.

At a time T processing executed by the execution unit reaches an entrance of a single thread STH. However reaching state information held by the holder unit indicates processing of the execution unit has reached the single thread STH that is processing of the execution unit has not yet reached an entrance of the single thread STH . Since reaching state information which the holder unit is able to hold is information corresponding to one single thread STH the control unit of the processor does not store reaching state information indicating processing of the execution unit has reached the single thread STH into the holder unit . Since reaching state information for the single thread STH is not held by the holder unit the determination unit of the processor determines to suspend execution of the single thread STH by the execution unit .

That is the determination unit detects that before processing executed by the execution unit reaches the entrance of the single thread STH processing executed by the execution unit has reached the entrance of the single thread STH executed after the single thread STH. Then when the holder unit has no area to store reaching state information corresponding to the single thread STH the execution unit suspends execution of the single thread STH.

Next at a time T processing executed by the execution unit reaches the entrance of the single thread STH. The determination unit of the processor determines by referring to reaching state information held by the holder unit that entire processing of execution units has reaches the entrance of the single thread STH. The determination unit detects based on reaching state information held by the holder unit that the execution unit of the other processor has executed the single thread STH and causes processing executed by the execution unit to jump from the entrance of the single thread STH to the exit thereof. Thus execution of the single thread STH by the execution unit is skipped.

Time for referring to the reaching state information is shorter than time for referring to reaching state information held by an external storage device of the processor device. Then the control unit of the processor initializes reaching state information held by the holder unit to no execution unit whose processing has reached the single thread STH .

Then referring to reaching state information held by the holder unit the control unit of the processor stores reaching state information indicating processing of execution unit has reached the single thread STH into the holder unit since reaching state information for the single thread STH is held therein. Then the determination unit of the processor causes the execution unit based on the reaching state information for the single thread STH held by the holder unit to execute the single thread STH.

In the embodiment illustrated in since the processor device includes the holder unit for holding reaching state information time for access to reaching state information may be reduced compared with reaching state information stored in an external storage device of the processor device. Access time used herein refers to a storage time for storing reaching state information into the holder unit and a read time for reading reaching state information from the holder unit . This enables processors to reduce a time for storing reaching state information indicating reach of the single thread STH or STH into the holder unit and a time for determining the propriety of executing the single thread STH or STH . Thus processing efficiency of threads PTH STH PTH and STH may be improved.

When the holder unit does not hold reaching state information indicating processing of the processor has reached the single thread STH the determination unit of the processor determines to hold execution of the single thread STH by the execution unit . When an area for storing new reaching state information is not available in the holder unit propriety of executing the single thread STH may be controlled according to a storage capacity of the holder unit by suspending execution of the single thread STH.

The core C includes an operation unit OPU a data register unit DREG an address register unit AREG a program counter PC an incrementer INC an instruction register unit IREG a decoder unit DEC and selectors S S. The operation unit OPU includes a register file REG an arithmetic unit EX and a flag registers SF ZF. The operation unit OPU is an example of an execution unit for executing a thread.

The program counter PC outputs an address received from the selector S to the incrementer INC and the selector S. The incrementer INC increments an address received from the program counter PC and outputs the incremented address to the selector S.

The selector S selects an address from the incrementer INC when sequentially fetching instruction codes and selects an address from the operation unit OPU when a branch instruction a jump instruction or the like is executed. The selector S outputs a selected address to the program counter PC. The selector S selects an address outputted from the program counter PC when fetching an instruction code and selects an address outputted from the address register unit AREG when executing a load instruction or a store instruction. The selector S outputs the selected address to the cache memory CM via the address bus AD.

When the core C fetches an instruction an instruction code is read from the cache memory CM according to the address bus AD and a read instruction code is stored into the instruction register unit IREG via the data bus DIN. When the instruction code is not held in the cache memory the cache memory CM outputs an address to the main memory MM via the address bus AD and receives the instruction code from the main memory MM via the data bus DT. For example the address AD is a high order address of the address AD and the instruction code program corresponding to one cache line of the cache memory CM is read from the main memory MM. Then the cache memory CM holds the instruction code read from the main memory MM and outputs the read target instruction code out of held instruction codes to the instruction register unit IREG via the data bus DIN.

When the core C executes a load instruction data is read from the cache memory CM according to the address bus AD and a read data is stored into the register file REG via the data bus DIN. When target data of the load instruction is not held in the cache memory CM the cache memory CM reads data corresponding to one cache line from the main memory MM in a manner similar to the reading of the instruction code. Then the cache memory CM holds the data read from the main memory MM and outputs a load target data out of the held data to the register file REG via the data bus DIN.

When the core C executes a store instruction data outputted from the data register unit DREG to the data bus DOUT is written into the cache memory CM according to an address outputted to the address bus AD.

The instruction register unit IREG has multiple areas for holding instruction codes received from the cache memory CM and outputs the held instruction codes sequentially to the decoder unit DEC. The decoder unit DEC decodes the instruction codes received from the instruction register unit IREG and based on the decoding results generates control signals for controlling operations of the operation unit OPU selectors S S and so on.

The data register unit DREG includes multiple areas for holding data outputted from the operation unit OPU during execution of the store instruction. The address register unit AREG includes multiple areas for holding addresses outputted from the operation unit OPU during execution of the load instruction or store instruction.

The register file REG includes multiple registers for holding data read from the cache memory CM or data outputted from the arithmetic unit EX. Based on a control signal from the decoder unit DEC the register file REG outputs data held in at least one of the multiple registers of the register file REG to the arithmetic unit EX.

The arithmetic unit EX executes operation in accordance with an instruction code decoded by the decoder unit DEC and outputs operation results to the register file REG data register unit DREG address register unit AREG or selector S. The arithmetic unit EX sets or resets flag registers SF ZF based on the operation results and refers to values of the flag registers SF ZF when executing the logical operation instruction or branch instruction. The operation unit OPU may include a flag register other than flag registers SF ZF.

The register unit REGU includes multiple registers REGi i represents any one of 0 1 2 3 and 4 and registers REGj. Here I the number of storage areas of the register REGi is not limited to 5 but may be any number greater than or equal to 1 . However as illustrated in and the like larger the number I of storage areas of the registers REGi larger the number of parallel processes performed by the multiple cores C thereby improving the processing efficiency of the CPU. The register unit REGU is an example of the holder unit for holding reaching state information indicating that processing executed by each of cores C to C has reached an entrance of the single processing block SIB.

In a value held by each of registers REGi is represented by a reference numeral Xi any one of X to X . For example a bit width of each of registers REGi and a bit width of the register REGj are equal to each other.

Registers REGi REGj are accessed when each of cores C to C executes the instruction code TEST IDA TEST Increment Decrement and Assignment which will be illustrated in . Registers REGi are used cyclically as processing illustrated in proceeds and each of registers REGi store an unreached thread count Xi indicating the number of threads THs which have not reached the entrance of the single processing block SIB illustrated in . A value obtained by subtracting the unreached thread count Xi from the number of cores C to C 4 indicates the number of threads THs which have reached the entrance of the single processing block SIB. In other words the unreached thread count Xi may be regarded as an example of reached processor count information indicating the number of cores C to C whose respective pieces of processing have reached the entrance of the single processing block SIB. Each of registers REGi may store the number of threads THs which have reached the entrance of the single processing block SIB. In registers REGi of the register unit REGU each area where the unreached thread count Xi is stored is an example of a reached processor count area.

The register REGj stores a total passing count j which represents the total number of single processing blocks SIBs through which all the threads THs have passed. The total passing count j is an example of total passing count information indicating the number of single processing blocks SIBs through which processing of all the cores C to C has passed. The register REGj is an example of total passing count area for holding the total passing count information. Usage of registers REGi REGj are described with reference to to .

The instruction code TEST IDA is processed when the microprogram is executed by the arithmetic unit EX in a manner similar to the addition instruction multiplication instruction load instruction and store instruction. Operation of the arithmetic unit EX executing the instruction code TEST IDA may be implemented by a wired logic. However by employing the microcode the instruction code TEST IDA may be added easily compared with the wired logic system and a hardware function architecture of instruction set may be easily modified.

The cache memory CM operates as an instruction cache and a data cache. The cache memory CM may be provided for each of cores C and may include a primary cache and a secondary cache. The main memory MM is a memory module such as a synchronous dynamic random access memory SDRAM or a flash memory and stores a program executed by the CPU and data handled by the CPU. The main memory MM includes a storage area for holding a core number n indicating the number of cores C and a storage area for holding passing counts m m m m m indicating the number of single processing blocks SIBs illustrated in through which respective pieces of processing of cores C to C have passed. The core number n and the passing count m are held in the cache memory CM as well. In the case where the cache memory CM holds the core number n and the passing count m each of cores may refer to the core number n and the passing count m and rewrite the passing count m just by accessing to the cache memory CM without accessing to the main memory MM.

The single processing block SIB is a processing block that is executed by one thread at a time. Except when there is no free space in the register REGi illustrated in a thread TH executing the single processing block SIB may execute the single processing block SIB without waiting for completion of the parallel processing block PAB by the other thread TH. The thread TH executing the single processing block SIB is an example of the single thread which is a thread executed only by any one of multiple cores C to C.

Upon reaching the entrance of the single processing block SIB each thread TH executes the instruction code TEST IDA. n and m of the instruction code TEST IDA are operands variables respectively representing the core number n and the passing count m held in the main memory MM or the cache memory CM.

Based on values of flag registers SF ZF that are set by execution of the instruction code TEST IDA each thread TH determines whether to execute the single processing block SIB or pass the single processing block SIB without executing the same. An example of determination processing executed by each thread TH is illustrated in . Examples of the single processing block SIB and the parallel processing block PAB are illustrated in to .

Upon reaching the entrance of the single processing block SIB cores C execute in the step S a load instruction to load the core number n and the passing count m from the main memory MM. When the cache memory CM holds the core number n and the passing count m the core number n and the passing count m are read from the cache memory CM.

Next in the step S cores C execute the instruction code TEST IDA with the core number n and the passing count m loaded from the main memory MM as variables. An example of the processing executed by the instruction code TEST IDA is illustrated in .

Next in the step S when the value of the flag register SF after execution of the instruction code TEST IDA is 1 cores C determines that there is an available register in the registers REGi and causes the processing to shift to the step S. When the value of the flag register SF after execution of the instruction code TEST IDA is not 1 that is 0 cores C determines that there is no available register in the registers REGi and causes the processing to shift to the step S.

In the step S cores C return the processing to the step S after waiting for a predetermined period of time. In the step S cores C may execute the other processing while waiting for the predetermined period of time.

In the step S when the value of the flag register ZF after execution of the instruction code TEST IDA is 1 the core C determines that the core C has first reached the entrance of the single processing block SIB and causes the processing to shift to the step S. When the value of the flag register ZF after execution of the instruction code TEST IDA is not 1 that is 0 the core C determines that the other thread has reached the entrance of the single processing block SIB earlier and causes the processing to shift to the step S.

In the step S processing of the core C jumps to the single processing block SIB and the core C executes the single processing block SIB. In the step S processing of the core C jumps to the exit of the single processing block SIB and the core C starts next processing without executing the single processing block SIB. That is the core C determines not to execute the single processing block SIB and jumps the processing to the exit of the single processing block SIB. This inhibits the single processing block SIB from being executed by multiple cores C and also suppresses malfunction of the CPU. After execution of steps S and S the processing is shifted to the step S.

In the step S the core C increments the passing count m loaded from the main memory MM in the step S by 1 . Next in the step S the core C executes the store instruction to store the passing count m incremented in the step S into the main memory MM. When the cache memory CM holds a passing count m the passing count m incremented in the step S is stored into the cache memory CM and thereafter stored into the main memory MM. Then the processing executed by the core C ends.

In the step S when a difference between the passing count m and the total passing count j is smaller than I indicating the number of registers REGi 5 in there is an available register REGi. Therefore the arithmetic unit EX causes the processing to shift to the step S. When the difference between the passing count m and the total passing count j is equal to or larger than I indicating the number of registers REGi there is no available register REGi. Therefore the arithmetic unit EX causes the processing to shift to the step S.

In the step S the arithmetic unit EX sets the flag register SF at 1 to indicate that the processing has reached the entrance of the single processing block SIB and then causes the processing to shift to the step S. In the step S the arithmetic unit EX calculates a remainder i m I by dividing the passing count m by I indicating the number of registers REGi as the number i that is assigned to a register REGi to be used and causes the processing to shift to the step S.

In the step S when the unreached thread count Xi stored in the register REGi whose number i is obtained in the step S is 0 the arithmetic unit EX determines that the processing has first reached the entrance of the single processing block SIB and causes the processing to shift to the step S. On the other hand when the unreached thread count Xi is not 0 the arithmetic unit EX determines that processing of the other core C has reached the entrance of the single processing block SIB and causes the processing to shift to the step S.

In the step S the arithmetic unit EX stores a value obtained by subtracting 1 from the core number n 4 in into the register REGi as the unreached thread count Xi and causes the processing to shift to the step S. In the step S the arithmetic unit EX sets the flag register ZF at 1 to indicate that the processing has first reached the entrance of the single processing block SIB and ends the processing.

When processing of the other core C has reached the entrance of the single processing block SIB the arithmetic unit EX reduces the unreached thread count Xi by 1 in the step S and causes the processing to shift to the step S. In the step S the arithmetic unit EX resets the flag register ZF at 0 to indicate that the processing has failed to first reach the entrance of the single processing block SIB and causes the processing to shift to the step S.

In the step S when the unreached thread count Xi is 0 the arithmetic unit EX determines that the processing has last reached the entrance of the single processing block SIB and causes the processing to shift to the step S. When the unreached thread count Xi is not 0 the arithmetic unit EX determines that there is a Core C whose processing has not yet reached the entrance of the single processing block SIB and ends the processing. In the step S since the processing of all cores C has reached the entrance of the single processing block SIB the arithmetic unit EX increments the total passing count j by 1 and ends the processing.

On the other hand when there is no available register REGi the arithmetic unit EX sets the flag register SF at 0 to artificially indicate that the processing has not reached the entrance of the single processing block SIB although already having reached actually in the step S and ends the processing.

Thus the processing of steps S and S is performed by a core C whose processing has first reached the entrance of the single processing block SIB. The processing of steps S to S is performed by a core C whose processing has reached the entrance of the single processing block SIB secondly or later. Further the processing of the step S is performed by a core C whose processing has last reached the entrance of the single processing block SIB. The step S is processing executed by a core C when there is no free space in the register REGi.

The mark of flag registers SF ZF represents 0 or 1 . A broken line pointed by arrow represents a single processing block SIB to SIB and a section above or below the single processing block represents a parallel processing block PAB PAB to PAB . A number i of the register REGi illustrated along with single processing blocks SIB to SIB is calculated in the step S illustrated in and is cyclically allocated to any one of 0 to 4 .

Processing executed by each of cores C proceeds from above downward in . A small black circle illustrated on a progression line dotted line in a vertical direction of the figures of each of cores C indicates a position of processing. A polygonal line connecting small black circles with each other indicates an arbitrary time in a manner similar to the time being provided for convenience sake to easily recognize a difference in the progress status of the processing executed by each of cores C. A white circle on a broken line illustrating the single processing block SIB indicates that a core C which has first reached the entrance of the single processing block SIB has executed the single processing block SIB.

First at a time T each of cores C to C starts the parallel processing block PAB. In the initialized state registers REGi REGj and passing counts m to m are initialized.

At a time T the core C completes execution of the parallel processing block PAB first reaches the entrance of the single processing block SIB and executes the instruction code TEST IDA a in . Before the processing of the core C reaches the entrance of the single processing block SIB the passing count m and the total passing count j are 0 and m j 0 is smaller than the number I 4 of the register REGi. Thus in the step S illustrated in the register REGi is determined to have a free space and the flag register SF is set at 1 in the step S illustrated in b of .

Since the unreached thread count X of the register REGi is initialized to 0 before the processing reaches the entrance of the single processing block SIB the processing of the core C is determined to have first reached the entrance of the single processing block SIB. Thus in the step S illustrated in the unreached thread count X is set at 3 core number 1 and the flag register ZF is set at 1 in the step S c and d of .

After executing the instruction code TEST IDA the core C causes the processing in the step S illustrated in to jump to the single processing block SIB since flag registers SF and ZF are 1 . In steps S and S illustrated in the core C increments the passing count m and stores the incremented passing count m into the main memory MM e of . After executing the single processing block SIB the core C executes a parallel processing block PAB.

Next at a time T the core C completes execution of the parallel processing block PAB reaches the entrance of the single processing block SIB in second place and executes the instruction code TEST IDA f of . Similarly with the operation of the core C at the time T the core C sets the flag register SF at 1 g of . Since the unreached thread count X of the register REGi is set at 3 at the time T the core C changes in steps S and S illustrated in the unreached thread count X to 2 and resets the flag register ZF to 0 h and i of .

After executing the instruction code TEST IDA the core C causes the processing in the step S illustrated in to jump to the exit of the single processing block SIB since the flag register SF is 1 and the flag register ZF is 0 . In steps S and S illustrated in the core C increments the passing count m and stores the incremented passing count m into the main memory MM j of . After executing the single processing block SIB the core C executes the parallel processing block PAB.

Next at a time T the core C completes execution of the parallel processing block PAB reaches the entrance of the single processing block SIB in the third place and executes the instruction code TEST IDA k of . Similarly with the operation of the core C at the time T the core C sets the flag register SF at 1 changes the unreached thread count X to 1 and resets the flag register ZF to 0 l m and n of . Then after executing the instruction code TEST IDA the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM o of . After executing the single processing block SIB the core C executes the parallel processing block PAB.

Next at a time T the core C completes execution of the parallel processing block PAB reaches the entrance of the single processing block SIB in the last place and executes the instruction code TEST IDA p of . Similarly with the operation of the core C at the time T the core C sets the flag register SF at 1 changes the unreached thread count X to 0 and resets the flag register ZF to 0 q r and s of . Further since the unreached thread count X becomes 0 the core C increments the total passing count j to 1 in the step S illustrated in t of . Then after executing the instruction code TEST IDA the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM u of .

Next at a time T of the core C completes execution of the parallel processing block PAB reaches the entrance of the single processing block SIB in the first place and executes the instruction code TEST IDA a of . Similarly with the time T since the register REGi is determined to have a free space the flag register SF is set at 1 b of .

Since the unreached thread count X of the register REGi is initialized to 0 before the processing reaches the entrance of the single processing block SIB the processing of the core C is determined to have reached the entrance of the single processing block SIB in the first place. Thus similarly with the operation at the time T the core C sets the unreached thread count X at 3 core number 1 and sets the flag register ZF at 1 c and d of . Then after executing the instruction code TEST IDA the core C causes the processing to jump to the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM e of .

Next at a time T the core C completes execution of the parallel processing block PAB reaches the entrance of the single processing block SIB f of and operates similarly with the core C at the time T. The core C sets the flag register SF at 1 changes the unreached thread count X to 2 and resets the flag register ZF to 0 g h and i of . Then after executing the instruction code TEST IDA the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM j of . Thereafter at a time T the core C operates similarly with the time T.

Next at a time T before the processing of the core C reaches the entrance of the single processing block SIB the processing of the core C reaches the entrance of the single processing block SIB k of . The core C operates similarly with the core C at the time T by using a storage area of an unreached thread count X of the register REGi. Next at a time T the processing of the core C reaches the entrance of the single processing block SIB I of . The core C operates similarly as in the time T by using a storage area of the unreached thread count X of the register REGi.

Next at a time T of the processing of the core C reaches the entrance of the single processing block SIB a of . The core C operates similarly with the core C at the time T by using a storage area of the unreached thread count X of the register REGi.

Next at a time T before the processing of the core C reaches the entrance of the single processing block SIB the processing of the core C reaches the entrance of the single processing block SIB b of . The core C operates similarly with the time T by using a storage area of an unreached thread count X of the register REGi.

Next at a time T the processing of the core C reaches the entrance of the single processing block SIB c of . The core C operates similarly with the time T by using a storage area of the unreached thread count X of the register REGi. Next at a time T the processing of the core C reaches the entrance of the single processing block SIB d of . The core C operates similarly with the time T by using a storage area of the unreached thread count X of the register REGi.

Next at a time T before the processing of the core C reaches the entrance of the single processing block SIB the processing of the core C reaches the entrance of the single processing block SIB e of . The core C operates similarly with the time T by using a storage area of an unreached thread count X of the register REGi.

Next at a time T of the processing of the core C reaches the entrance of the single processing block SIB a of . The core C operates similarly with the core C at the time T by using a storage area of the unreached thread count X of the register REGi.

Next at a time T before the processing of the core C reaches the entrance of the single processing block SIB the processing of the core C reaches the entrance of the single processing block SIB b of . Before the processing of the core C reaches the entrance of the single processing block SIB the passing count m is 5 the total passing count j is 1 and m j 4 is smaller than the number I 5 of the register REGi. Thus in the step S illustrated in the register REGi is determined to have a free space. In the step S illustrated in the core C calculates a remainder 0 by dividing the passing count m 5 by the number I 5 of the registers REGi and determines to use a storage area of the unreached thread count X of the register REGi c of . Then the core C operates similarly with the core C at the time T by using a storage area of the unreached thread count X.

Next at a time T before the processing of the core C reaches the entrance of the single processing block SIB the processing of the core C reaches the entrance of the single processing block SIB d of . Before the processing of the core C reaches the entrance of the single processing block SIB the passing count m is 6 the total passing count j is 1 and m j 5 is same as the number I 5 of the register REGi. Thus in the step S illustrated in the core C determines that there is no free space in the register REGi sets the flag register SF at 0 and ends the instruction code TEST IDA e of .

In the step S of the core C determines that the flag register SF is 0 and waits for a predetermined period of time in the step S. That is the core C waits without causing the processing to jump to the single processing block SIB and does not increment the passing count m as well.

Next at a time T the core C completes execution of the parallel processing block PAB and reaches the entrance of the single processing block SIB f of . Before the processing of the core C reaches the entrance of the single processing block SIB the passing count m is 1 the total passing count j is 1 and m j 0 is smaller than the number I 5 of the register REGi. Thus in the step S of the core C sets the flag register SF at 1 g of .

Before the processing of the core C reaches the entrance of the single processing block SIB the unreached thread count X is 1 . Thus in steps S and S of the core C changes the unreached thread count X to 0 and resets the flag register ZF to 0 h and i of . Further since the unreached thread count X becomes 0 the core C increments the total passing count j to 2 in the step S of j of .

After executing the instruction code TEST IDA the core C causes the processing in the step S illustrated in to jump to the exit of the single processing block SIB since the flag register SF is 1 and the flag register ZF is 0 . In steps S and S illustrated in the core C increments the passing count m and stores the incremented passing count m into the main memory MM k of . When the core C executes the other arithmetic operation while waiting for a predetermined period of time values of flag registers SF ZF become indefinite 0 or 1 .

Thereafter at a time T the core C waits for a predetermined period of time and then executes the instruction code TEST IDA. Although times T and T are provided separately for the purpose of illustration operations indicated at times T and T are executed consecutively.

Before reaching the time T the passing count m is 6 the total passing count j is 2 and m j 4 is smaller than the number I 5 of the register REGi. Thus the core C sets the flag register SF at 1 l of . In the step S illustrated in the core C calculates a remainder 1 by dividing the passing count m 6 by the number I 5 of the registers REGi and determines to use a storage area of the unreached thread count X of the register REGi. Since the unreached thread count X is 0 before reaching the time T the core C sets the unreached thread count X at 3 core number 1 in steps S and S illustrated in and sets the flag register ZF at 1 m and n of .

After executing the instruction code TEST IDA the core C causes the processing in the step S illustrated in to jump to the single processing block SIB since flag registers SF and ZF are 1 o of . In steps S and S illustrated in the core C increments the passing count m and stores the incremented passing count m into the main memory MM p of .

Next at a time T of the core C completes execution of the parallel processing block PAB and reaches the entrance of the single processing block SIB a of . Similarly with the operation of the core C at the time T of the core C sets the flag register SF at 1 decrements the unreached thread count X to 0 and resets the flag register ZF to 0 b c and d of . Thus a storage area of the unreached thread count X of the register REGi becomes available. Further since the unreached thread count X becomes 0 similarly with the time T of the core C increments the total passing count j to 3 e of .

After executing the instruction code TEST IDA since the flag register SF is 1 and the flag register ZF is 0 the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM f of .

Next at a time T the core C completes execution of the parallel processing block PAB and reaches the entrance of the single processing block SIB g of . Similarly with the operation of the core C at the time T the core C sets the flag register SF at 1 decrements the unreached thread count X to 0 and resets the flag register ZF to 0 h i and j of . Thus a storage area of the unreached thread count X of the register REGi becomes available. Further similarly with the operation at the time T the core C increments the total passing count j to 4 causes the processing to the exit of the single processing block SIB and increments the passing count m k and l of .

Operations at times T and T are the same as operations at times T and T illustrated in . At the time T the core C which has completed processing in the parallel processing block PAB and whose processing has reached the entrance of the single processing block SIB in first place causes the processing to jump to the single processing block SIB in the step S illustrated in . However start of the single processing block SIB is suspended until other cores C to C complete processing of the parallel processing block PAB and reach the entrance of the single processing block SIB a of .

Next at a time T the processing of the core C reaches the entrance of the single processing block SIB and at a time T the processing of the core C reaches the entrance of the single processing block SIB b and c of . In the step S illustrated in after causing the processing to jump to the exit of the single processing block SIB cores C and C suspend start of the parallel processing block PAB until execution of the single processing block SIB by the core C completes.

Next at a time T the processing of the core C reaches the entrance of the single processing block SIB and the total passing count j is set at 1 d and e of . The core C executes the single processing block SIB after processing of all cores C to C reaches the entrance of the single processing block SIB and starts the parallel processing block PAB after completion of the single processing block SIB f of . Cores C to C start processing of the parallel processing block PAB. In the case although passing counts m m and m are changed from 0 to 1 respectively at times T to T the passing counts m m and m may be changed after the core C executes the single processing block SIB at a time T.

Next at a time T of the processing of the core C reaches the entrance of the single processing block SIB in first place in the step S illustrated in the core C causes the processing to jump to the single processing block SIB. However similarly with the operation at the time T illustrated in start of the single processing block SIB is suspended until processing of other cores C C and C reaches the entrance of the single processing block SIB a of .

Thereafter at times T T and T processing of core C C and C reach the entrance of the single processing block SIB sequentially b c and d of . The core C whose processing reaches the entrance of the single processing block SIB in last place sets the total passing count j at 2 e of . Then the core C executes the single processing block SIB after all other cores C C and C have reached the entrance of the single processing block SIB f of .

A statement pragma omp parallel indicates that blocks enclosed in are executed in parallel with each other. A statement pragma omp single indicates that a block enclosed in is executed by a single thread. A clause nowait indicates that a thread which has completed a single processing block SIB directed by the statement pragma omp single shifts to a next processing regardless of the status of other threads. Operations illustrated in to are implemented by a program illustrated in including description of the statement pragma omp single nowait .

On the other hand an exit of a statement pragma omp single modified by excluding a clause nowait from a statement pragma omp single nowait includes an implicit barrier for waiting for a next processing until completion of processing of all threads. Thus when the statement pragma omp single nowait illustrated in is modified to the statement pragma omp single the operation illustrated in and is implemented.

A statement pragma omp parallel for indicates that for sentence in a next line is executed in parallel. In a program illustrated in a parallel processing block PAB a single processing block SIB and a parallel block PAB are executed repeatedly by the number indicated by a variable COUNT. Similarly with the program illustrated in the program illustrated in implements the operation illustrated in to .

A statement pragma omp sections indicates that blocks enclosed in are executed in parallel by allocating a thread for each statement pragma omp sections . An exit of a block specified by the statement pragma omp sections includes an implicit barrier for waiting for a next processing until completion of processing of all the threads. Thus when re writing the statement pragma omp sections to the statement pragma omp single nowait a statement pragma omp barrier is added to the end of the block for sentence . The statement pragma omp barrier is used for synchronization.

As described above even in this embodiment the CPU includes a register REGU which holds reaching state information including the unreached thread count Xi and the total passing count j similarly with the embodiment illustrated in . Thus time for access to the reaching state information may be reduced compared with the reaching state information stored in the main memory MM. As a result a processing efficiency of the thread executed by multiple cores C to C may be enhanced.

Further a core C whose processing has reached the entrance of the single processing block SIB in the last place initializes areas corresponding to a register REGi to a state ready for holding a new unreached thread count Xi. This enables execution of a single processing block SIB whose execution has been suspended and also enables control of the propriety of executing a new single processing block SIB by using the initialized area. That is the propriety of executing the single processing block SIB may be controlled by cyclically using multiple areas for storing the unreached thread count Xi in the register REGi.

The passing count m managed for each of cores C to C is incremented for every passing of the single processing block SIB and the total passing count j of cores C to C is incremented every time any processing of cores C to C reaches the entrance of each of single processing blocks SIB in the last place. Thus execution or suspension of a single processing block SIB corresponding to the passing count m may be determined by comparing a difference between the passing count m and the total passing count j and the number I indicating the number of areas for storing the unreached thread count Xi in the register REGi with each other.

A core C whose processing has reached the entrance of the single processing block SIB in the second place or later determines not to execute the single processing block SIB and causes the processing to jump to the exit of the single processing block SIB to suppress execution of the single processing block SIB by multiple cores C.

Each of cores C whose processing has reached the entrance of the single processing block SIB fetches an instruction code TEST IDA. The instruction code TEST IDA is executed by a microprogram. Thus a hardware function architecture of instruction set may be easily altered.

The CPU illustrated in includes a register unit REGU different from the register illustrated in . The register unit REGU includes one storage area i 0 for storing the unreached thread count X. The other configuration of the CPU is the same as the CPU illustrated in . That is the CPU illustrated in includes multiple cores C C C C and C a cash memory CM and a register unit REGU. In a manner similar to the CPU in each of cores C includes an operation unit OPU a data register unit DREG an address register unit AREG a program counter PC an incrementer INC an instruction register unit IREG a decoder unit DEC and selectors S S.

Processing executed by the CPU illustrated in is the same as the processing illustrated in . Processing executed by each of cores C to C at the entrance of the single processing block SIB is the same as or similar to the processing illustrated in and the operation of the instruction code TEST IDA executed by each of cores C to C is the same as or similar to the operation illustrated in .

At a time T before the processing of cores C and C reaches the entrance of the single processing block SIB the core C completes the parallel processing block PAB and the processing thereof reaches the entrance of the single processing block SIB a and b of . Before the processing of the core C reaches the entrance of the single processing block SIB the passing count m is 1 the total passing count j is 0 and m j 1 is the same as the number I 1 indicating the number of the registers REGi. Thus in the step S illustrated in the core C determines that there is no free space in the register REGi resets the flag register SF to 0 and ends the instruction code TEST IDA c of .

In the step S of the core C determines that the flag register SF is 0 and waits for a predetermined period of time in the step S. That is the core C waits without causing the processing to jump to the single processing block SIB and does not increment the passing count m as well.

Next at a time T the core C completes execution of the parallel processing block PAB the processing thereof reaches the entrance of the single processing block SIB and the unreached thread count X of the register REGi is changed to 1 d and e of . However since m j 1 is the same as the number I 1 indicating the number of the registers REGi in a manner similar to the time T the core C resets the flag register SF to 0 again and waits for a predetermined period of time f of .

Next at a time T of the core C completes execution of the parallel processing block PAB the processing thereof reaches the entrance of the single processing block SIB and the unreached thread count X of the register REGi is changed to 0 a and b of . Since the unreached thread count X becomes 0 the core C sets the total passing count j at 1 c of .

The core C which has waited for the predetermined period of time in the step S illustrated in executes the instruction code TEST IDA . Since the passing count m is 1 and m j 0 is smaller than the number I 1 indicating the number of the registers REGi the core C sets the flag register SF at 1 d of . The core C calculates a remainder i 0 by dividing the passing count m 1 by the number I 1 indicating the number of the registers REGi and determines to use a storage area of the unreached thread count X of the register REGi.

Thereafter at a time T since the unreached thread count X is 0 the core C determines that the storage area of the unreached thread count X is empty sets 3 at the unreached thread count X and sets the flag register ZF at 1 e and f of . After executing the instruction code TEST IDA since flag registers SF ZF are 1 the core C causes the processing to jump to the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM g of . Although times T and T are provided separately for purpose of illustration operations indicated at times T and T are executed consecutively.

Next at a time T processing of the core C reaches the entrance of the single processing block SIB the unreached thread count X is changed to 2 and the flag register ZF is reset to 0 h and i of . After executing the instruction code TEST IDA since the flag register SF is 1 and the flag register ZF is 0 the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM j of .

Next at a time T before processing of cores C and C reaches the entrance of the single processing block SIB the core C completes the parallel processing block PAB and processing thereof reaches the entrance of the single processing block SIB k and l of . The core C waits until the storage area of the unreached thread count X becomes empty in a manner similar to the core C at the time T of .

Next at a time T processing of the core C reaches the entrance of the single processing block SIB and processing of the core C reaches the entrance of the single processing block SIB m and n of . The core C waits until the storage area of the unreached thread count X becomes empty in a manner similar to the time T of . When the core C executes the other arithmetic operation while waiting for a predetermined period of time values of flag registers SF ZF become indefinite 0 or 1 .

Next at a time T of the processing of the core C reaches the entrance of the single processing block SIB a of . The core C changes the unreached thread count X to 0 and sets the total passing count j at 2 b and c of . The core C which has executed the instruction code TEST IDA for a predetermined period of time sets the flag register SF at 1 since m j 0 is smaller than the number I 1 of the register REGi d of .

Next at a time T the core C calculates a remainder i 0 by dividing the passing count m 2 by the number I 1 indicating the number of the registers REGi and determines to use a storage area of the unreached thread count X. Then the core C sets 3 to the unreached thread count X and sets the flag register ZF at 1 e and f of . After executing the instruction code TEST IDA since flag registers SF ZF are 1 the core C causes the processing to jump to the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM g and h of .

Thereafter the core C which has executed the instruction code TEST IDA when the passing count m is 2 sets the flag register SF at 1 since m j 0 is smaller than the number I 1 indicating the number of the registers REGi i of . The core C changes the unreached thread count X to 2 and resets the flag register ZF to 0 j and k of . Although times T and T are provided separately for the purpose of illustration operations indicated at times T and T are executed consecutively.

After executing the instruction code TEST IDA since the flag register SF is 1 and the flag register ZF is 0 the core C causes the processing to jump to the exit of the single processing block SIB increments the passing count m and stores the incremented passing count m into the main memory MM l of . When the core C whose processing has reached the entrance of the single processing block SIB executes the instruction code TEST IDA prior to the core C processing of the core C jumps to the single processing block SIB and processing of the core C jumps to the exit of the single processing block SIB. That is the core C executes the operation of the core C illustrated at times T T and the core C executes the operation of the core C illustrated at times T T.

Then at a time T cores C C execute the parallel processing block PAB and cores C C execute the parallel processing block PAB.

In the embodiment illustrated in to since the CPU includes the register unit REGU for holding reaching state information time for access to the reaching state information may be reduced compared with a case where the reaching state information is stored in the main memory MM. As a result a processing efficiency of the thread executed by multiple cores C to C may be enhanced.

The embodiments illustrated in to may be implemented by multiple CPUs respectively including multiple cores C. For example when one CPU includes cores C and C and the other CPU includes cores C and C each CPU operates as illustrated in to and to .

Each of cores C may execute multiple threads in parallel. In this case when the core C illustrated in executes two threads in parallel and the core C illustrated in executes two threads the operation illustrated in to is implemented by replacing processing of cores C and C with processing of cores C and C respectively. Similarly parallel execution of multiple threads by each of cores C illustrated in to is implemented by replacing processing of cores C and C with processing of cores C and C respectively.

Characteristics and advantages of the embodiments shall be apparent from the above detailed description. This intends that the appended claims cover the characteristics and advantages of the above embodiments within a scope not deviating from the spirit and the right thereof. Any modifications and variations may be readily conceivable to those of ordinary skill in the art. Therefore it is not intended to limit the scope of embodiments having inventiveness to the foregoing and appropriate modifications and equivalents included in the scope disclosed in the embodiments may be covered.

All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art and are to be construed as being without limitation to such specifically recited examples and conditions nor does the organization of such examples in the specification relate to a showing of the superiority and inferiority of the invention. Although the embodiment of the present invention has been described in detail it should be understood that the various changes substitutions and alterations could be made hereto without departing from the spirit and scope of the invention.

