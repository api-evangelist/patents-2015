---

title: Application security testing
abstract: The present disclosure provides a system that includes a server hosting an application under test (AUT), an observer configured to monitor instructions executed by the AUT, and a computing device communicatively coupled to the AUT and the observer through a common communication channel. The computing device may be configured to send an application request to the AUT, wherein the application request is configured to expose a potential vulnerability of the AUT. The computing device may receive an application response from the AUT in accordance with the AUT's programming. The computing device may send a service request to the observer, and receive a service response from the observer that contains information corresponding to the instructions executed by the AUT due to the application request, information about the AUT, or information about a server hosting the AUT.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501650&OS=09501650&RS=09501650
owner: HEWLETT PACKARD ENTERPRISE DEVELOPMENT LP
number: 09501650
owner_city: Houston
owner_country: US
publication_date: 20150904
---
Software security testing is used to identify vulnerabilities in an application such as a Web application. Traditional black box security testing for Web based software works by using a security testing application often referred to as a scanner which poses as an attacker. In a black box approach the scanner explores an Application Under Test AUT by making HTTP requests and evaluating the HTTP responses in order to find all of the URLs where the AUT accepts input. The URLs where the AUT accepts input may be referred to the attack surface of the AUT. The scanner then creates attacks based on the attack surface and likely categories of vulnerabilities. The scanner applies the attacks to diagnose the presence or absence of vulnerabilities by evaluating the program s HTTP responses. In a black box approach the scanner does not have any insight into the internal workings of the AUT.

Black box vulnerability testing is straightforward in concept but in practice it presents a number of challenges. For example exploring the AUT might not reveal all of the attack surface so the scanner might not launch attacks against all of the places where the AUT is vulnerable. Additionally some vulnerabilities cannot be accurately identified through the information returned in the HTTP response. If the scanner does discover a vulnerability the scanner cannot provide information about where the vulnerability is inside the code of the AUT. Furthermore the scanner may report several vulnerabilities that are all related to the same underlying problem in the AUT causing a programmer trying to fix the vulnerabilities to carry out a great deal of repetitive work.

Embodiments described herein provide techniques for performing gray box security testing of a Web application. In gray box security testing a software program referred to herein as an observer is used to watch the internal operations performed by the AUT. The observer enables the scanner to determine the operation of the AUT and how it behaves in response to attacks. The observer also enables the scanner to determine the behavior of the AUT in response to normal application requests which the scanner may use to determine what types of attacks to send. The scanner continues to deliver attacks to the AUT and the scanner receives knowledge of the internal workings of the AUT from the observer. In this way the scanner can find more vulnerabilities and produce better vulnerability reports thereby providing a more comprehensive and detailed software security test of web based applications.

In accordance with embodiments a communication channel is provided between the observer and the scanner. The scanner uses this communication channel to get insight into the AUT during its scanning. The communication channel between the scanner and the observer may be implemented by using the communication channel already in use by the AUT. In this way the person conducting the test does not have to perform additional configuration or setup work and the communication channel does not interfere with the normal operation of the AUT or the computer system on which the AUT is running. Additional benefits of the present invention may be better understood with reference to the description provided below.

As illustrated in the system may include a computing device which will generally include a processor connected through a bus to a display a keyboard and one or more input devices such as a mouse touch screen or keyboard. In an embodiment the computing device is a general purpose computing device for example a desktop computer laptop computer server and the like. The computing device can also have one or more types of non transitory computer readable media such as a memory that may be used during the execution of various operating programs including operating programs used in embodiments of the present invention. The memory may include read only memory ROM random access memory RAM and the like. The device can also include other non transitory computer readable media such as a storage system for the long term storage of operating programs and data including the operating programs and data used in embodiments of the present invention.

In an embodiment the computing device includes a network interface controller NIC for connecting the device to a server . The computing device may be communicatively coupled to the server through a network such as the internet a local area network LAN a wide area network WAN or another network configuration. The server may have a non transitory computer readable media such as storage device for storing data buffering communications and storing operating programs of the server . Communications between the device and the server may be conducted using a request response protocol such as the Hyper Text Transfer Protocol HTTP .

The server may be an application server that hosts the AUT . The server also includes an observer that monitors the AUT during execution. The computing device may include a scanner that performs a security test against the AUT . For example the scanner may send HTTP requests to the AUT through the network wherein the HTTP request is configured to attempt to expose a vulnerability of the AUT . The HTTP requests may include HTTPS requests which combine the Hypertext Transfer Protocol with the SSL Secure Sockets Layer and TLS Transport Layer Security protocols to provide encrypted communication and secure identification of a network Web server. During the processing of the HTTP request by the AUT the observer monitors the internal processes performed by the AUT . For example the observer can identify lines of code that are executed by the AUT files that are accessed database queries that are performed and the like. Both the observer and the AUT may be configured to communicate with the scanner over a same HTTP channel. As described further in reference to some requests sent from the scanner to the server may target the AUT to elicit a response from the AUT in accordance with its programming. Other requests sent from the scanner to the server may target the observer to obtain additional information regarding the effect that a particular request had on the operations performed by the AUT or other information related to the AUT the observer or the server hosting the AUT . Data received by the scanner in responses to application requests and service requests may be used by the scanner to generate vulnerability reports. Vulnerability reports may be displayed to the user though a user interface provided by the scanner .

The AUT includes a network interface for enabling communications between the scanner and the AUT through the network . The network interface exposes the attack surface of the AUT and is the same interface that would eventually be used to provide access to the AUT when the AUT is made available for general use. Communication between the scanner and the AUT over the network interface may be conducted through HTTP requests issued from the scanner to the AUT and HTTP responses issued from the AUT to the scanner . Requests targeting the AUT may be referred to as application requests and responses received from the AUT may be referred to as application responses. The application requests generated by the scanner may be configured to expose potential vulnerabilities of the AUT .

The AUT may be coupled to a file system a database and other resources used by the AUT . The database may include a variety of user information such as a table of usernames and passwords used to grant access to various resources of the AUT for example. The file system may include data and programs used by the AUT as well data which may be requested by a user such as HTTP pages software programs media files and the like.

The observer operates within the execution environment of the AUT and has access to the internal operations performed by the AUT . For example the observer may modify the bytecode of the AUT by injecting additional code such as a JAVA class at various program points. The injected code acts as a monitor that observes the AUT . The injected monitor code may be located at strategic program points in the AUT for example application programming interface API calls that perform specific operations such as reading a URL parameter or writing to the file system . Whenever such a program point in the AUT is executed the monitor calls into services provided by the observer to record operations performed by AUT . The observer may be coupled to a buffer for storing information that has been collected regarding the internal operations of the AUT . The buffer may be used to store data that has been collected but has not yet been reported to the scanner . The buffer may be stored in non volatile storage medium such as a hard disk solid state drive and the like.

The observer may also include an additional network interface for enabling communications between the observer and the scanner through the network . As noted above both network interfaces and may use the same communication channel for example the same HTTP channel. Communications between the scanner and the observer may be implemented through the use of custom request and response headers. Custom headers may be added to the application requests by the scanner and custom headers may be added to the application responses by the observer . In this way at least some of the communications between the scanner and the observer may be piggy backed on normal communications with the AUT . Using a single channel of communication eliminates any problems with opening a dedicated secondary channel and adding HTTP headers typically does not interfere with the normal operation of the AUT .

The scanner may add one or more custom headers to each application request wherein the custom headers include information that the observer may use to diagnose a vulnerability related to an attack in progress. Information within the custom header can include the version of the scanner or the payload that the scanner is using in the attack. The payload information may be used by the observer to determine whether the attack succeeded.

The scanner may also use custom request headers to generate requests that target the observer to obtain additional information regarding the internal processes performed by the AUT or information about AUT the server or the observer . Requests targeting the observer may be referred to as service requests and responses received from the observer may be referred to as service responses. Service responses issued by the observer may include supplemental information in the body of the service response as described further below.

In embodiments the observer is configured to receive the application requests and the service requests sent from the scanner to the AUT . The observer may then analyze the header information to determine whether the request is an application request or a service request. Upon receiving an application request the observer may analyze the header information to acquire data used by the observer regarding the specific application request. Application requests may then be delivered by the observer to AUT for processing by the AUT according to the AUT s programming. When the AUT generates the application response the observer may add one or more custom headers to the application response to send additional information back to the scanner . The custom headers added to application requests and application responses may be referred to as per request headers and are further described in the section entitles Per request Headers. 

Upon receiving a service request the observer may process the request without delivering the service request to the AUT . The service request may include one or more custom headers that include information configured to request a particular service of the observer such as name of the service being requested. The observer may respond with the requested information in the body of an HTTP response referred to herein as a service response. In embodiments the information provided by the observer in the body of the service response may be formatted using Java Script Object Notation JSON and may be a self identifying JSON object. If the observer has no information to send the response body may be empty. Service requests are further described in the sections entitled Service Requests . 

The per request headers may be custom HTTP headers which may include a custom field name followed by one or more field values that are understood by the observer and the scanner . The custom HTTP headers are ignored by the AUT . It will be appreciated that the field names described herein are merely used as examples of field names that could be used in a particular implementation and are not intended to limit the scope of the claims.

The per request headers may include a version header used to coordinate the interaction between the scanner and the observer . The observer may add a version header to every application response. The scanner may use the version header to verify that the observer is installed. As an example the version header may be formatted as follows X WIPP Version 

In the example version header the prefix X WIPP identifies the header as a custom header that is used by the observer . The field name X WIPP VERSION is a string of characters that uniquely identifies the custom header as a version header. The field value may be the name of a runtime environment used by the AUT to process the application request such as Java or .NET among others. In some cases the AUT may execute two or more processes which may be handled by different runtime instances. For example the AUT may use a load balancer or other work distribution arrangement for processing application requests. The scanner may use the field value to identify the process within the AUT handling the application request. For example the field value may be a name that uniquely identifies the runtime instance that processed the application request such as a specific JVM instance in the case of JAVA CLR instance in the case of .NET or other type of runtime instance. The field value may be a number or character string that identifies the version of the observer . The scanner may use the identified version of the observer to properly coordinate interactions with the observer in the event that the observer s interface changes between versions of the observer software.

The per request headers may also include a Foe Not Found FNF header used by the scanner to identify a file not found condition. In HTTP if a client requests a resource that doesn t exist or cannot be found the Web application may generate a standard error code referred to as HTTP code . Simple Web applications often indicate the file not found condition by returning the HTTP code in the HTTP response. A more complex Web application may swallow the code. In other words rather than simply returning the HTTP code error in the HTTP response the code may trigger the Web application to redirect the client to an error page landing page or any other part of the Web application. In traditional black box testing redirecting the scanner to a different part of the Web application rather than simply reporting the error may cause the scanner to incorrectly report a false positive. The FNF header can be used to avoid this result. Because the observer is operating inside the application the observer can detect the file not found error and report the file not found error by adding the FNF header to the application response. For example If the application request provokes an file not found response from the AUT the observer may add the following header to the application response X WIPP FNF 404 In this way the file not found error can be reported to the scanner regardless of the HTTP response provided by the AUT .

The per request headers may also include a Request ID header. The Request ID header may be formatted as follows X WIPP RequestID 

As described further below under the section entitled Service Requests the scanner may request additional information that was gathered by the observer in response to an application request but not reported in the application response. The additional information may be included in a data structure referred to herein as a trace. The information included in the trace describes the operations of the AUT that were triggered by a specific application request. To support the trace request service the observer may add the Request ID header to each application response to enable the scanner to associate the requested trace with the specific application response corresponding to the requested trace. In embodiments the field value is assigned by the scanner and included in the application request. The observer may then use the same request id value in the Request ID header that is added to the corresponding application response. In embodiments the scanner does not add a request ID header to application requests in which case the observer may generate a unique value for the request id and include the request id in a Request ID header added to the application response. In either case the same request id value may be used by the scanner to request the corresponding trace from the observer .

The per request headers may also include an update header used by the observer to notify the scanner of various types of changes regarding the AUT . The update header may be formatted as follows X WIPP Update 

The value may be a comma separated list of service names each of which refers to a services provided by the observer that may provide new information as a result of a change in the AUT . When new information about the AUT becomes available the observer may notify the scanner by adding the update header to an application response. In this way the update header informs the scanner that new information about the AUT is available and what service to request to obtain the information. For example if the observer detects additional URLs that have been generated during the security test of the AUT the observer may send an update header to the scanner wherein equals AttackSurface. Upon receiving the update header the scanner may send a service request to the observer requesting the identified service or services. The observer may continue to send the update header in every application response until the scanner issues a service request for the named service or services.

In response to an application request the observer may determine the effect of the application request by determining for example particular lines of code that have been executed by the AUT files that have been accessed by the AUT database queries executed by the AUT or other information. The data collected by the observer can be stored to a data structure referred to herein as a trace. In embodiments each trace may be stored to the buffer . Each trace may include the Request ID of the application request and the application response that corresponds with the trace. The scanner can learn about the internal operations of the AUT that were triggered by a particular application request by retrieving the corresponding trace from the observer . To retrieve a trace the scanner may issue a service request to the observer that includes a header field name value pair configured to indicate the request of the trace corresponding to a particular application request or response. For example the field name value pair for requesting a trace may be formatted as follows Trace 

The value is the value assigned bye scanner or the observer that corresponds with the application request and or application response associated with the requested trace as described above in relation to the section entitled PER REQUEST HEADERS. Upon receiving the trace service request the observer may bypass the AUT and generate a service response that includes the requested trace. In embodiments the requested trace may be retrieved by the observer from the buffer and added to the body of the service response which may then be sent to the scanner . The service response header includes the request id value of the requested trace and the body of the service response may be formatted as a JSON object.

The observer may maintain a plurality of traces in the buffer so that the scanner can request a trace for any application request that has been made. The buffer may be of any size suitable for a particular implementation. In an embodiment traces stored to the buffer may be removed from the buffer in a first in first out manner if the buffer becomes full. If the scanner requests an unknown request ID the observer may return an error. A request ID may be unknown if it is invalid was never used or has aged out of the buffer of traces maintained by the observer .

The scanner may be configured to send a separate trace service request after the corresponding application request was made and a response received from the AUT . The request id enables the observer to receive trace requests out of sequence while still being able to associate the received trace with the appropriate application request and response. Trace requests may be received out of sequence due in part because the scanner might have multiple threads of execution issuing application requests to the AUT . The scanner may also be configured to abort a timed out application request in which case the scanner may retrieve an incomplete trace from the observer . To differentiate between complete and incomplete traces the observer may be configured to add a special node to each completed trace that indicates that the application request corresponding to this trace request was successfully completed. For example the observer may add a special node of type request complete at the end of each completed trace. The absence of the request complete node may indicate to the scanner that the corresponding application request failed.

The observer may monitor processes performed by the AUT that occur outside the context of an application request such as processes initiated by the additional monitor code injected by the observer . To avoid incurring an unacceptable level of performance overhead the observer may be configured to minimize the performance overhead of monitoring processes that are unrelated to application requests. For example the performance overhead may be minimized by injecting the monitor code to selectively monitor specific API calls and relevant portions of the AUT s user code.

The trace returned to the scanner may include one or more trace nodes of various types. Each trace node conveys some bit of information corresponding to the internal processes performed by the AUT . In embodiments each trace node includes a type property which may be any suitable string of characters that uniquely identifies the type of the trace node. Some trace node types may be based on the type of action that was performed by the AUT .

In embodiments the observer may record information about a call stack used by the AUT and the container code. A call stack is a data structure that stores information about the active subroutines of a computer program. For example the call stack may keep track of a line of code to which an active subroutine should return control when it finishes executing. The call stack may also be used to pass parameters to a subroutine and allocate memory for variables local to the subroutine among other functions. The call stack may include a top stack frame that represents a currently executing subroutine called by the AUT or the AUT s container code. The top stack frame may include a file name and line number that identifies a particular line of code.

Each trace may include one of more trace nodes wherein each trace node describes details regarding a particular call stack generated by the AUT . Trace nodes may include a location property that identifies a file name and line number of the top stack frame outside the observer in the AUT container code. Trace nodes may also include a user context property giving a file name and line number for the top stack frame in the AUT user code if such a stack frame can be identified. The context property enables the scanner to create a vulnerability report that includes a root cause analysis for vulnerabilities and enables the scanner to group together vulnerabilities that are associated with the same location in the code.

In embodiments the observer is configured to detect vulnerabilities. For example the scanner may send an attack to the AUT in the form of an application request configured to create of an arbitrary file on the file system . The application request may include custom header information that informs the observer regarding the nature of the attack. If the AUT is vulnerable the observer will encounter a file creation API call thus informing the observer that the File Upload attack was successful and a vulnerability has been detected.

If the observer detects a vulnerability the observer may generate a trace node referred to herein as a vulnerability trace node. A vulnerability trace node may include one or more stack traces which provide code location information to the scanner such as sink program points and when available one or more potential source program points. A source program points is a code location where malicious input is consumed by the AUT and a sink program point is a code location where the malicious input modifies the behavior of the AUT . For example in the case of a Cross Site Scripting vulnerability the source program point is where a user supplied value is read from a URL parameter and the sink program point is where the tainted parameter value is written to an HTML page. Stack traces may be elided such that they do not include stack frames from the observer . The vulnerability trace node may include stack frames relating to both the AUT code and the container code and each stack frame may include an indication of whether the stack frame relates to user code or container code. Due to the code location information provided by the observer the scanner can create vulnerability reports that pinpoint the location of the vulnerability in the AUT and can group vulnerabilities that occur at the same location in the AUT thus reducing duplication in the vulnerability reports generated by the scanner . The code location information also provides the user insight into the nature of the vulnerability and therefore reduces the amount of remediation effort used to repair the problem.

The vulnerability trace node may also include a vulnerability category such as Cross Site Scripting or SQL Injection and standard vulnerability identifier such as a Common Weakness Enumeration CWE identifier corresponding to each vulnerability category. The vulnerability trace node may also include relevant details about the detection of the vulnerability. For example if the vulnerability is an SQL injection vulnerability the vulnerability trace node may include the SQL query involved in the detection of the vulnerability by the observer . In this way the observer is able to detect and report an SQL injection vulnerability to the scanner even if the vulnerability does not manifest itself in the application response returned to the scanner .

The observer may also generate a trace node referred to herein as a database trace node if the AUT performs a query against a database such as an SQL query. The database trace node may include the text of the database query and values for the bind parameters used by the AUT in the database query. Other types of trace nodes may include begin nodes and end nodes for source code files invoked by the AUT such as JAVA servlets JAVA Server Pages JSPs and the like. Begin nodes and end nodes refer to the nodes in the control flow structure representing the flow of execution through the AUT . Begin nodes and end nodes may include the file name of the source code file and parameters passed to the source code file. The observer may also generate other types of trace nodes to represent for example reads and writes of the file system performed by the AUT Web service calls performed by the AUT and network service operations performed by the AUT among others.

As stated above the scanner may use trace information to group together duplicate vulnerabilities. The grouping of duplicate vulnerabilities may be performed by a de duplication process implemented buy the scanner . In de duplication the scanner may apply a hashing algorithm to portions of a vulnerability trace node such as the user context property and vulnerability category in order to create an identifier for the vulnerability. Two vulnerabilities that have the same identifier can be considered duplicates from the perspective of the AUT . The vulnerability identifier may be used to notify the user that fixing one of these vulnerabilities will likely remedy other vulnerabilities with the same vulnerability identifier. The scanner s user interface may be configured to present duplicate vulnerabilities to the user in a group.

In embodiments the scanner is configured to optimize the attacks it sends to the AUT based on the trace information. For example if a trace shows that a particular application request does not access the file system the scanner can be configured to omit similar attacks related to that application request that are directed at vulnerabilities related to the file system . Similarly if a trace shows that a particular application request does not invoke a database query the scanner can be configured to omit similar attacks related to that application request that are directed at vulnerabilities in the database such as SQL injection.

In embodiments database query information from database trace nodes may be used to identify more persistent cross site scripting vulnerabilities. For example application requests targeting the database may be associated with the database tables and columns that are accessed by the AUT due to the application request. The scanner can use this information to send an attack that attempts to store data in the database with an application request that writes the data to a particular location in the database . The scanner may determine the effect of the attack by sending an application request that reads from me location in the database .

The observer may be configured to provide a service referred to herein as a server information service used to inform the scanner about the server . To retrieve server information the scanner may issue a server information service request to the observer that includes a header field name such as Server which is configured to indicate the request of server information. Upon receiving a server information service request the observer may bypass the AUT and return the requested server information to the scanner .

The requested server information may be returned in the body of a service response generated by the observer and formatted for example as a JSON object. Examples of server information included in the service response may include the name and version of the host operating system the name and version of the application server the amount of time that the application server has been running without any downtime number of threads currently being processed and the amount of memory currently in use among other information. The scanner may use the server information to generate attacks that are appropriate for the server hosting the AUT . For example the scanner may be configured to avoid sending Microsoft Windows based attacks to the AUT if the server hosting the AUT is running Linux.

The observer may be configured to provide a service referred to herein as an application information service that is used to inform the scanner about the AUT . To retrieve application information the scanner may issue an application information service request to the observer that includes a field name such as Application which is configured to indicate the request of application information. Upon receiving the application information service request the observer may bypass the AUT and return the requested application information to the scanner .

The requested application information may be returned in the body of a service response generated by the observer and formatted for example as a JSON object. If there is no application information available to be sent the body of the service response may be empty. Examples of application information returned by the service response may include the name and version of all of the databases that the AUT interacts with file libraries used by the AUT Web services subsystems and other subsystems and software frameworks that the AUT interacts with among other information. The scanner can use the application information to generate attacks more efficiently. For example information about the databases being used by the AUT may enable the scanner to generate attacks that are appropriate for the identified databases and avoid generating attacks for databases that are not in use. Additionally the scanner can avoid sending attacks that target a Microsoft SQL Server to an AUT that uses only an Oracle database.

The observer may be configured to provide a service referred to herein as an attack surface service used to identify components of the attack surface that might not be detected by simple Web crawler. To retrieve attack surface information the scanner may issue an attack surface service request that includes a header field name such as AttackSurface which is configured to indicate the request of attack surface information. Upon receiving the application information service request the observer may bypass the AUT and return the requested attack surface information to the scanner . The attack surface information may be returned in the body of a service response generated by the observer and formatted for example as a JSON object. If there is no attack surface information available to be sent the body of the service response may be empty.

The attack surface of the AUT includes the resources that are accessible to the scanner such as Web page links for example. The scanner or the observer may be configured to analyze or crawl the AUT to discover such Web page links. Some resources that are accessible to the scanner may not be associated with a Web page link and are in this sense hidden resources that are not discoverable by crawling the AUT . Hidden resources may exist as files in the file system and may be discovered by the observer which has access to the file system . Additionally some resources may be generated by the AUT dynamically at runtime in other words during execution of the AUT in response to a received application request. Dynamic resources may be generated during runtime based on configuration files and mapping files such as Web.xml files which are files that map a requested URL to a resource on the file system based on pre defined rules. Dynamically generated resources may be discovered by the observer by examining mapping and configuration files and by observing the execution of the AUT to identify Uniform Resource Locators URLs that are bound dynamically at runtime.

Each resource accessible to the scanner may be referred to as an attack surface component. Each attack surface component discovered by the observer may be formatted as a URL and reported to the scanner in the body of the attack surface service response. Each attack surface component may also be tagged within the body of the attack surface service response to identify the attack surface component as static or dynamic. Resources discovered by exploring the file system including files located in the root directory of the file system and below may be tagged as static. Resources discovered by examining mapping and configuration files may be tagged as dynamic. In the case of containers such as WebLogic that do not expand a Web application ARchive WAR file as part of running the application the observer may let the container code handle the task of extracting the resources from the WAR files and then use the list of extracted resources to define the attack surface.

In some cases the scanner may issue a service request that cannot be fulfilled by the observer . For example the scanner may issue a service request that is not recognized by the observer or a service request with a header field value that is not recognized by the observer such as a trace request with an unknown request ID. If the observer encounters a service requests that cannot be fulfilled the observer may return an error to the scanner in the header of a service response or application response. For example the observer may issue a service response formatted as follows X WIPP Error 

The header field value may be any suitable text string that gives a brief description of the error encountered. The text string describing the error may be stored by the scanner to an error log that is viewable by the user. Furthermore the observer may maintain an error log wherein each error log entry includes a more detailed description of the problem. The error log maintained by the observer may records any errors encountered during the operation of observer .

Errors may be generated by the observer in response to service requests or the portion of an application request header that includes information intended to target the observer . If the error is generated in response to a service request the error message may be returned in a service response and the body of the service response may be empty. If the error is generated in response to information included in an application request the error message may be returned in an application response and the body of the application response may contain whatever data the AUT provides in accordance with its programming.

At block the scanner may receive an application response from the AUT in accordance with the AUT s programming. If the scanner is configured to add request IDs to each application request the observer may add the same request ID to the header of the application response. Otherwise the scanner may generate a unique request ID and add the request ID to the header of the application response. As described above the observer may also add additional information to the header of the application response such as a file not found header an observer version header an update header and the like.

At block the scanner may send a service request to the observer . In embodiments the service request may be included in the application request of block by adding additional header information to the application request. In embodiments the service request may be a separate request in other words not combined with an application request. Service requests are processed by the observer and not passed to the AUT . Service requests may be configured to request information such as attack surface information server or application information and trace information that relates to the internal processes of the AUT among others. The scanner may add the request ID to the header of the service request to obtain trace information corresponding to a particular application response.

At block the scanner may receive a service response from the observer . The service response may include information about the processes performed by the AUT due to the application request. For example the service response may include stack trace information identifying processes performed by the AUT as a result of the application request. The service response may include vulnerability trace nodes that contain code locations corresponding to a vulnerability detected by the observer . The service response may also include information corresponding to a database query performed by the AUT as a result of the application request. In embodiments the service response may include information about the AUT such as the programming language of the AUT the name and version of the AUT and the attack surface of the AUT including static and dynamic URLs among other information. The service response may also include information about the observer such as the operating system name and version application server name and version number of threads memory usage and amount that the server has been running without any downtime among other information.

It will be appreciated that method is merely an example process flow used to explain embodiments of the present techniques and that the actual process flow may vary depending on a particular implementation. For example the scanner may not issue a service request for every application request. Additionally the scanner may send and receive multiple application requests and responses before sending a service request related to a particular one of the application responses.

At block the scanner may generate a vulnerability report based on the information received from the AUT and the observer . The vulnerability report may group detected vulnerabilities based on the code location information included in the trace nodes received at block . The vulnerability report may be presented to the user through a user interface provided by the scanner . The vulnerability report may also be stored to memory printed and the like.

As shown in the various components discussed herein can be stored on the non transitory machine readable medium . A region on the non transitory machine readable medium can include an application interface configured to send application requests to the AUT wherein the application requests are configured to expose a potential vulnerability of the AUT . The application interface can also receive application responses from the AUT wherein the application responses are generated by the AUT in accordance with the AUT s programming. A region can include an observer interface configured to send service requests to the observer . The observer interface also receives the service responses which contain information corresponding to processes performed by the AUT due to the application request information about the AUT or information about the server hosting the AUT for example. A region can include a vulnerability report generator configured to analyze the data received from the AUT and the observer and generate a vulnerability report based in the analysis.

