---

title: Automatic generation of domain-aware phase ordering for effective optimization of code for a model
abstract: A device receives a model, in a technical computing environment, that includes blocks and lines, and determines an application domain associated with the model. The device determines code generation optimizations for the model, determines dependencies of the code generation optimizations, and determines performance characteristics for the device. The device determines capabilities of a target compiler for the code generated based on the model, and determines a profile for target hardware to be used to execute the code. The device identifies an order for the code generation optimizations based on the determined information, generates optimal code for the model based on the identified order for the code generation optimizations, and outputs and/or store the optimal code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268537&OS=09268537&RS=09268537
owner: The MathWorks, Inc.
number: 09268537
owner_city: Natick
owner_country: US
publication_date: 20150224
---
This application is a continuation in part of U.S. patent application Ser. No. 14 264 474 filed on Apr. 29 2014 the entire contents of which are hereby incorporated by reference.

The following detailed description of example implementations refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements.

A technical computing environment TCE may include a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business or the like more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal or the like. The TCE may use an array a vector and or a matrix as basic elements.

A user may utilize the TCE to generate models such as a textual model a graphical model with one or more model elements e.g. blocks one or more input signals e.g. data and one or more output signals e.g. data a combination of a textual model and a graphical model or the like. Each of the blocks may represent a physical device a subsystem another model or the like of a system being modeled. In some models signals may be generated from various blocks and may point to other blocks of the model. The user may arrange or group one or more blocks of the model into subsystem blocks. The user may utilize a code generator to define and generate code based on the model. However the code generator may not effectively optimize the code based on the model due to the arrangement of the model.

As shown in the user may utilize the TCE to create receive and or display a control logic domain model and a signal processing domain model. The control logic domain model may include multiple blocks and signals provided between the blocks. The control logic domain model may include a single rate discrete time model with a summation block that performs addition a delay block X a switch block and or other blocks. The signal processing domain model may include an accumulator block and or other blocks. Assume that the user wishes to generate code for the control logic domain model and the signal processing domain model and provides a command e.g. by selecting a generate code button to instruct the TCE to provide the control logic domain model and the signal processing domain model to a code generator. As further shown in the code generator may generate code based on the control logic domain model and may generate code based on the signal processing domain model.

The user may wish the generated code to be efficient code since inefficient code may cause the physical systems represented by the control logic domain model and the signal processing domain model to be inefficient. Additional resources may be required to build the inefficient physical systems than required to build efficient physical systems which may increase costs for the physical systems.

In some implementations the code generator may utilize optimization techniques to convert the control logic domain model and the signal processing domain model to optimized generated code. For example the code generator may utilize loop unrolling constant inlining constant folding or the like optimization techniques to generate optimal code. As used herein the term optimal is to be construed as meaning that optimization techniques have been applied to the code. For example loop unrolling may optimize an execution speed of the generated code by reducing or eliminating instructions that control a loop such as pointer arithmetic and end of loop tests on each iteration branch penalties or the like. Constant inlining may improve speed and memory usage during execution of the generated code. For example constant inlining may enable the code generator to eliminate superfluous signals between blocks of the model from which the code is generated. Constant folding may enable the code generator to accurately propagate constants and simultaneously remove dead code from the generated code. For example constant folding may enable recognition and evaluation of constant expressions in the generated code at compile time rather than at execution.

Typically the code generator performs such optimization techniques in any order which may cause the code generator to generate non optimized or inefficient code. For example as shown in the bottom left portion of the code generator may utilize constant inlining constant folding and loop unrolling in no particular order and may generate non optimal code for the control logic domain model. As shown in the bottom right portion of the code generator may utilize constant folding constant inlining and loop unrolling in no particular order and may generate non optimal code for the signal processing domain model.

In some implementations the code generator may determine an optimal order e.g. an optimal domain aware phase order of the optimization techniques based on a domain associated with a model and may generate optimal code for the model based on performance of the optimization techniques in the optimal domain aware phase order. For example as shown in the upper left portion of the code generator may determine an optimal order for the optimization techniques e.g. for the control logic domain model to be loop unrolling constant inlining and constant folding. Based on the optimal order the code generator may first apply loop unrolling to the control logic domain model then may apply constant inlining to the control logic domain model and finally may apply constant folding to the control logic domain model. Application of the optimization techniques in the optimal order may enable the code generator to generate optimal code e.g. u 20 for the control logic domain model. As shown in the upper right portion of the code generator may determine an optimal order for the optimization techniques e.g. for the signal processing domain model to be constant inlining loop unrolling and constant folding. Based on the optimal order the code generator may first apply constant inlining to the signal processing domain model then may apply loop unrolling to the signal processing domain model and finally may apply constant folding to the signal processing domain model. Application of the optimization techniques in the optimal order may enable the code generator to generate optimal code e.g. u 11 for the signal processing domain model.

Systems and or methods described herein may automatically generate a domain aware order for optimization techniques utilized to generate code for a model. The domain aware order for the optimization techniques may be applied to different application domains of a model different use cases of modeling constructs different design and implementation of modeling constructs different efficiency metrics of the generated code different time and memory requirements for the generated code or the like. The systems and or methods may generate efficient code that is tailored towards particular efficiency metrics and may enable control of time and memory used to generate the code.

Client device may include one or more devices capable of receiving generating storing processing executing and or providing information in a manner described herein. For example client device may include a computing device such as a desktop computer a laptop computer a tablet computer a handheld computer a server a mobile phone e.g. a smart phone a radiotelephone or the like or a similar device. In some implementations client device may receive information from and or transmit information to server device .

TCE may be provided within a computer readable medium of client device . Alternatively or additionally TCE may be provided in another device e.g. server device that is accessible by client device . TCE may include hardware or a combination of hardware and software that provides a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business or the like more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal or the like. In some implementations TCE may include a modeling language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language a textual modeling language a graphical modeling language a dynamically typed programming language an array based programming language or the like that can be used to express problems and or solutions in mathematical notations.

For example TCE may use an array as a basic element where the array may not require dimensioning. These arrays may be used to support array based programming e.g. modeling where an operation may apply to an entire set of values included in the arrays. Array based programming may allow array based operations to be treated as high level programming e.g. modeling that may allow for example operations to be performed on entire aggregations of data without having to resort to explicit loops of individual non array operations. In some implementations TCE may provide high level programming with a dynamically typed language or an array based programming language that may be a form of modeling. In some implementations the array based programming language may be utilized to create models. In addition TCE may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development or the like. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design or the like. In some implementations TCE may provide high level programming with a dynamically typed language or an array based language that may be a form of modeling.

TCE may further provide mathematical functions and or graphical tools e.g. for creating plots surfaces images volumetric representations or the like . In some implementations TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing or the like . In some implementations TCE may provide these functions as block sets or in another way such as via a library or the like.

TCE may be implemented as a text based environment e.g. MATLAB software Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence Modelica or Dymola from Dassault Systemes or the like a graphically based environment e.g. Simulink software Stateflow software SimEvents software Simscape software or the like by The MathWorks Inc. VisSim by Visual Solutions LabView by National Instruments Dymola by Dassault Systemes SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhapsody or Tau from Telelogic Ptolemy from the University of California at Berkeley aspects of a Unified Modeling Language UML or SysML environment or the like or another type of environment such as a hybrid environment that includes one or more of the above referenced text based environments and one or more of the above referenced graphically based environments.

TCE may include a programming language e.g. the MATLAB language that may be used to express problems and or solutions in mathematical notations. The programming language may be dynamically typed and or array based. In a dynamically typed array based programming language data may be contained in arrays and data types of the data may be determined e.g. assigned at program execution time. In some implementations the arrays may include a cell array. A cell array may include a data type with indexed data containers called cells. Each cell may contain any type of data. A cell array may commonly contain lists of text strings combinations of text and numbers from spreadsheets or text files or numeric arrays of different sizes.

For example suppose a program written in a dynamically typed array based programming language includes the following statements 

Now suppose the program is executed for example in TCE . During run time when the statement A hello is executed the data type of variable A may be a string data type. Later when the statement A int32 2 3 is executed the data type of variable A may be a 1 by 2 array containing elements whose data type are 32 bit integers. Later when the statement A 1.1 2.2 3.3 is executed since the language is dynamically typed the data type of variable A may be changed from the above 1 by 2 array to a 1 by 3 array containing elements whose data types are floating point. As can be seen by this example data in a program written in a dynamically typed array based programming language may be contained in an array. Moreover the data type of the data may be determined during execution of the program. Thus in a dynamically type array based programming language data may be represented by arrays and data types of data may be determined at run time.

In some implementations TCE may provide mathematical routines and a high level programming language suitable for non professional programmers and may provide graphical tools that may be used for creating plots surfaces images volumetric representations or other representations. TCE may provide these routines and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing or the like . TCE may also provide these routines in other ways such as for example via a library local or remote database e.g. a database operating in a computing cloud remote procedure calls RPCs and or an application programming interface API . TCE may be configured to improve runtime performance when performing computing operations. For example TCE may include a just in time JIT compiler and may be used with a complex instruction set computer CISC reduced instruction set computing RISC a microprocessor without interlocked pipeline stages MIPS quantum computing or the like.

A dynamic system either natural or man made may be a system whose response at any given time may be a function of its input stimuli its current state and a current time. Such systems may range from simple to highly complex systems. Natural dynamic systems may include for example a falling body the rotation of the earth bio mechanical systems muscles joints or the like bio chemical systems gene expression protein pathways weather and climate pattern systems and or any other natural dynamic system. Man made or engineered dynamic systems may include for example a bouncing ball a spring with a mass tied on an end automobiles aircrafts control systems in major appliances communication networks audio signal processing systems and a financial or stock market and or any other man made or engineered dynamic system.

The system represented by a model may have various execution semantics that may be represented in the model as a collection of modeling entities often referred to as blocks. A block may generally refer to a portion of functionality that may be used in the model. The block may be represented graphically textually and or stored in some form of internal representation. Also a particular visual depiction used to represent the block for example in a graphical block diagram may be a design choice.

A block may be hierarchical in that the block itself may include one or more blocks that make up the block. A block including one or more blocks sub blocks may be referred to as a subsystem block. A subsystem block may be configured to represent a subsystem of the overall system represented by the model. A subsystem block may be a masked subsystem block that is configured to have a logical workspace that contains variables only readable and writeable by elements contained by the subsystem block.

A graphical model e.g. a functional model may include entities with relationships between the entities and the relationships and or the entities may have attributes associated with them. The entities may include model elements such as blocks and or ports. The relationships may include model elements such as lines or signals e.g. connector lines and references e.g. textual labels . The attributes may include model elements such as value information and meta information for the model element associated with the attributes. A graphical model may be associated with configuration information. The configuration information may include information for the graphical model such as model execution information e.g. numerical integration schemes fundamental execution period or the like model diagnostic information e.g. whether an algebraic loop should be considered an error or result in a warning model optimization information e.g. whether model elements should share memory during execution model processing information e.g. whether common functionality should be shared in code that is generated for a model or the like.

In some implementations a graphical model may have executable semantics and or may be executable. An executable graphical model may be a time based block diagram model. A time based block diagram model may include for example blocks connected by lines e.g. connector lines . The blocks may include elemental dynamic systems such as a differential equation system e.g. to specify continuous time behavior a difference equation system e.g. to specify discrete time behavior an algebraic equation system e.g. to specify constraints a state transition system e.g. to specify finite state machine behavior an event based system e.g. to specify discrete event behavior or the like. The lines may represent signals e.g. to specify input output relations between blocks or to specify execution dependencies between blocks variables e.g. to specify information shared between blocks physical connections e.g. to specify electrical wires pipes with volume flow rigid mechanical connections or the like or the like. The attributes may consist of meta information such as sample times dimensions complexity whether there is an imaginary component to a value data type or the like associated with the model elements.

In a time based block diagram ports may be associated with blocks. A relationship between two ports may be created by connecting a line e.g. a connector line between the two ports. Lines may also or alternatively be connected to other lines for example by creating branch points. For instance three or more ports can be connected by connecting a line to each of the ports and by connecting each of the lines to a common branch point for all of the lines. A common branch point may be a dynamic system for example for the lines that represent physical connections e.g. by summing all variables of a certain type to 0 or by equating all variables of a certain type . A port may be an input port an output port a non causal port an enable port a trigger port a function call port a publish port a subscribe port an exception port an error port a physics port a power port an entity flow port a data flow port a control flow port or the like.

In some implementations TCE may receive a model and may provide a user with an option to generate code based on the model for target hardware. If the user elects to utilize the option TCE may provide the model to code generator .

Code generator may be provided in client device or may be provided in another device e.g. server device that is accessible by client device . In some implementations code generator may generate an intermediate representation IR based on the model received by TCE . An intermediate representation or IR may include a translation of a model a representation of a model e.g. a data structure that may be stored in memory a file a database and or other storage media or the like. An IR may be constructed from input data contained within a source language e.g. a language used by a model and from which part or all of output data contained in a target language e.g. generated code may be constructed. An IR may include a control flow graph CFG a data flow graph DFG a hybrid graph e.g. a graph that includes a CFG and a DFG and or another representation that preserves properties of information in the source language. An IR may allow for serial and or parallel processing of the representation in the source language within the IR. The use of an IR may permit translation of a representation in a source language into a representation in a target language such that a system implementation may be generated from an initial system model.

In some implementations an IR may be generated from a model created via TCE before emitting code represented by a programming language e.g. C C Fortran Java or the like a hardware description language e.g. Verilog or the like a scripting language e.g. Perl Python Javascript or the like and or a machine or assembly language. In some implementations code generator may parse a model into syntactical components and may use the syntactical components to construct an IR such that the IR may represent the semantics of the model. In some implementations code generator may allow a user to develop an IR for user specified elements. The IR may be based on computations to be performed and may not follow model elements e.g. as they are presented in a model . The IR may permit optimizations to be applied across multiple elements of a model.

In some implementation code generator may identify a region of operations as belonging to a specific domain and may determine dependencies of code generation optimizations for such a domain. For example a region of operations may contain blocks of a common type. The common type of blocks e.g. certain signal processing blocks may share similar algorithmic characteristics e.g. loops parameterized or templatized in a certain manner either because of the application domain requirements or the programming habits of the developers of the blocks. The algorithmic characteristics may be used to form an effective an optimization sequence. As another example a region of operations may contain a particular use pattern of a collection of modeling and or programming constructs. The particular use pattern e.g. control system common low level components may result in certain code patterns e.g. recursion or a state machine implementation structured in a certain way in the generated code. The certain code patterns may be prone toward certain optimization sequences. Additionally the region of operations may include different levels of granularity that may be used to identify useful domains and patterns.

In some implementations code generator may determine performance characteristics of a host device e.g. client device server device or the like and may determine capabilities of a target compiler for the generated code. In some implementations code generator may determine a target hardware profile for the generated code to be executed and may identify an order for the code generation optimizations based on the application domain the dependency of the code generation optimizations the host device performance characteristics the target compiler capabilities and or the target hardware profile. In some implementations code generator may generate optimal code for the model based on the identified order for the code generation optimizations.

In some implementations the target hardware may include a homogeneous hardware platform of the same type of processing components e.g. a central processing unit CPU a graphical processing unit GPU an application specific integrated circuit ASIC a field programmable gate array FPGA or the like . A homogeneous hardware platform may include a combination of the same type of computing components e.g. the same type of processing components . In some implementations the target hardware may include a heterogeneous hardware platform of different types of processing components. A heterogeneous hardware platform may include a combination of different types of computing components e.g. different types of computing cores computing cores combined with signal processing intrinsics computing cores combined with FPGAs or the like .

Server device may include one or more devices capable of receiving generating storing processing executing and or providing information in a manner described herein. For example server device may include a computing device such as a server a desktop computer a laptop computer a tablet computer a handheld computer or a similar device. In some implementations server device may host TCE and or code generator .

Network may include one or more wired and or wireless networks. For example network may include a cellular network a public land mobile network PLMN a local area network LAN a wide area network WAN a metropolitan area network MAN a telephone network e.g. the Public Switched Telephone Network PSTN an ad hoc network an opportunistic network an intranet the Internet a fiber optic based network and or a combination of these or other types of networks.

The number and arrangement of devices and or networks shown in are provided as an example. In practice there may be additional devices and or networks fewer devices and or networks different devices and or networks or differently arranged devices and or networks than those shown in . Furthermore two or more devices shown in may be implemented within a single device or a single device shown in may be implemented as multiple distributed devices. Additionally one or more of the devices of environment may perform one or more functions described as being performed by another one or more devices of environment .

Bus may include a path that permits communication among the components of device . Processor may include a processor e.g. a central processing unit a graphics processing unit an accelerated processing unit or the like a microprocessor a digital signal processor DSP and or any processing component e.g. a field programmable gate array FPGA an application specific integrated circuit ASIC or the like that interprets and or executes instructions and or that is designed to implement a particular function. In some implementations processor may include multiple processor cores for parallel computing. Memory may include a random access memory RAM a read only memory ROM and or another type of dynamic or static storage component e.g. a flash magnetic or optical memory that stores information and or instructions for use by processor . In some implementations processor may include for example an ASIC.

Storage component may store information and or software related to the operation and use of device . For example storage component may include a hard disk e.g. a magnetic disk an optical disk a magneto optic disk a solid state disk or the like a compact disc CD a digital versatile disc DVD a floppy disk a cartridge a magnetic tape and or another type of computer readable medium along with a corresponding drive. In some implementations storage component may store TCE .

Input component may include a component that permits a user to input information to device e.g. a touch screen display a keyboard a keypad a mouse a button a switch or the like . Output component may include a component that outputs information from device e.g. a display a speaker one or more light emitting diodes LEDs or the like .

Communication interface may include a transceiver like component such as a transceiver and or a separate receiver and transmitter that enables device to communicate with other devices such as via a wired connection a wireless connection or a combination of wired and wireless connections. For example communication interface may include an Ethernet interface an optical interface a coaxial interface an infrared interface a radio frequency RF interface a universal serial bus USB interface a high definition multimedia interface HDMI or the like.

Device may perform various operations described herein. Device may perform these operations in response to processor executing software instructions included in a computer readable medium such as memory and or storage component . A computer readable medium is defined as a non transitory memory device. A memory device includes memory space within a single physical storage device or memory space spread across multiple physical storage devices.

Software instructions may be read into memory and or storage component from another computer readable medium or from another device via communication interface . When executed software instructions stored in memory and or storage component may cause processor to perform one or more processes described herein. Additionally or alternatively hardwired circuitry may be used in place of or in combination with software instructions to perform one or more processes described herein. Thus implementations described herein are not limited to any specific combination of hardware circuitry and software.

The number and arrangement of components shown in are provided as an example. In practice device may include additional components fewer components different components or differently arranged components than those shown in . Additionally or alternatively one or more components of device may perform one or more functions described as being performed by another one or more components of device .

As shown in process may include receiving a model generated by a technical computing environment TCE block . For example a user may utilize client device and TCE to define and create a model and or to display the model. In some implementations the user may utilize client device to receive the model from another device e.g. server device or to retrieve the model from memory associated with client device . In some implementations the model may include a graphical model with one or more blocks one or more input signals e.g. data and one or more output signals e.g. data . In some implementations each of the blocks may represent a portion of a system being modeled. In some implementations signals may be generated from various blocks and may point to other blocks of the model. In some implementations the user may utilize TCE to group certain blocks together into subsystem blocks. Each subsystem block may be defined by a user defined boundary that is provided around the blocks grouped together in the subsystem block.

As further shown in process may include determining an application domain of the model block . For example the user may instruct TCE and code generator to generate code based on the model. In some implementations TCE may cause client device to display to the user an option to generate code based on the model and the user may select the option to generate code based on the model. Based on the selection code generator may generate code based on the model. In some implementations the code may not be emitted prior to TCE and or code generator analyzing and or optimizing the code.

In some implementations code generator may determine an application domain of the model so that a domain aware phase order may be determined for effective optimization of the generated code. For example the model or a region of the model may be associated with different application domains or sub domains e.g. physical systems such as an electrical domain a mechanical domain a hydraulic domain a control logic domain a signal processing domain or the like. Code generator may analyze the model to determine the application domain of the model or regions of the model. For example if a region of the model includes control logic blocks and or signals code generator may determine that the region of the model is associated with the control logic domain. In another example if a region of the model includes signal processing blocks and or signals code generator may determine that the region of the model is associated with the signal processing domain. In some implementations code generator may determine that one or more different regions of the model are associated with one or more different application domains. For example a first region of the model may be associated with the mechanical domain and a second region of the model may be associated with the electrical domain. The different domains or sub domains may have different implications for the code generated from them such as how algorithms and data dependencies are modeled how constants and temporary variables are used and how computation complexity and component boundaries are laid out. As such code generator may identify effective and different optimization orderings for these domains.

In some implementations code generator may detect modeling patterns in the model based on specific usage of modeling constructs blocks signals algorithms componentization connectivity or the like. In some implementations code generator may determine an effectiveness of an order for code generation optimizations e.g. loop unrolling constant folding or the like based on the determined application domain of the model and or the detected modeling patterns of the model.

As further shown in process may include determining a dependency of code generation optimizations for the model block . For example code generator may determine a dependency of code generation optimizations for the model. In some implementations code generator may identify one or more code generation optimizations e.g. constant inlining constant folding or the like for the model and may determine whether each of the identified code generation optimizations is dependent on other code generation optimizations independent of other code generation optimizations or the like. For example assume that code generator determines that constant folding and constant inlining may be used as code generation optimizations and that performance of constant folding makes performance of constant inlining more efficient. In such an example code generator may determine that constant folding and constant inlining share a dependency. In another example assume that code generator determines that loop unrolling and constant folding may be used as code generation optimizations and that performance of loop unrolling does not affect performance of constant folding and vice versa. In such an example code generator may determine that loop unrolling and constant folding do not share a dependency.

In some implementations constant inlining may enable code generator to improve speed and memory usage during execution of code generated based on the model referred to herein as generated code . In some implementations code generator may utilize constant inlining to eliminate superfluous signals between blocks of the model. For example assume that the model utilizes a signal e.g. a call instruction to invoke a function in a block. In such an example the constant inlining may enable the content of the function to be invoked without the call instruction e.g. by eliminating the signal from the model which may improve memory usage and or execution speed of the generated code.

In some implementations loop unrolling may enable code generator to optimize an execution speed of the generated code by reducing or eliminating instructions that control a loop such as pointer arithmetic and end of loop tests on each iteration branch penalties or the like. In some implementations constant folding may enable code generator to accurately propagate constants and simultaneously remove dead code from the generated code. For example constant folding may enable recognition and evaluation of constant expressions in the generated code at compile time rather than at execution.

In some implementations code generator may perform a code motion optimization to reduce a frequency with which a computation is performed by the model. For example the code motion optimization may enable code generator to group one or more of the blocks of the model together so that the blocks may be executed in parallel. In another example the code motion optimization may enable code generator to move statements or expressions of the generated code outside of a loop without affecting the semantics of the generated code. This may enable the statements or expressions to be executed less frequently which may increase the execution speed of the generated code.

As further shown in process may include determining host device performance characteristics block . For example code generator may determine performance characteristics associated with a host device e.g. client device or server device that includes code generator . In some implementations the performance characteristics may include performance characteristics of the host device e.g. time and or resource requirements that are required to generate the code for the model. In some implementations the performance characteristics may include a time required for the host device to generate the code for the model usage of the host device s memory required to generate the code usage of the host device s processor required to generate the code or the like.

In some implementations the performance characteristics may include time and or resource usage of the host device required to perform the determined code generation optimizations for the model. For example assume that the loop unrolling optimization requires a first amount of time T e.g. in seconds minutes hours or the like for the host device to complete and utilizes a first amount M e.g. a percentage of a memory of the host device. Further assume that the constant inlining optimization requires a second amount of time Tfor the host device to complete and utilizes a second amount Mof the memory of the host device. In such an example code generator may determine that the code generation optimizations require a particular amount of time e.g. T T of the host device and a particular amount of memory usage e.g. M M of the host device.

As further shown in process may include determining capabilities of a target compiler for the generated code block . For example code generator may determine capabilities of a target compiler provided for a target device e.g. client device or server device for the generated code. In some implementations code generator may utilize code efficiency metrics to determine capabilities e.g. effectiveness of the target compiler for the generated code. In some implementations the code efficiency metrics may include metrics utilized to measure an efficiency of the generated code created by code generator . In some implementations the code efficiency metrics may include metrics that determine a number of global variables in the generated code stack utilization by the generated code a number of data copies in the generated code or the like.

In some implementations a global variable may include a variable that is accessible in multiple portions of the generated code. A global variable may be modified in any portion of the generated code and any portion of the generated code may depend on the global variable. Therefore a global variable may create mutual dependencies in the generated code which may increase the complexity of the generated code. In some implementations code generator may attempt to create generated code that minimizes the number of global variables in the generated code. For example code generator may eliminate and or modify code that includes a number of global variables greater than a threshold value e.g. two three four or the like .

In some implementations stack utilization may include utilization of a stack to store a return address of functions in the generated code registers associated with the generated code local variables e.g. local arrays structures classes or the like associated with generated code or the like. In some implementations code generator may attempt to create generated code that minimizes stack utilization. For example code generator may eliminate and or modify code that utilizes a stack more than a threshold amount e.g. in bytes kilobytes or the like .

In some implementations one or more functions of the blocks of the model may cause data copies to be in the generated code provided by code generator which may increase memory usage by the generated code. For example a function of a block may produce a copy of output data for every destination to which the output data is to be passed. Such data copies may be temporarily stored in memory associated with the target device. In some implementations code generator may attempt to create generated code that minimizes the number of data copies in the generated code. For example code generator may eliminate and or modify code that includes a number of data copies greater than a threshold value e.g. two three four or the like .

As further shown in process may include determining a target hardware profile for the generated code block . For example code generator may determine a profile of target hardware e.g. a cache a memory a processor or the like provided on a target device e.g. client device or server device for the generated code. In some implementations code generator may utilize metrics associated with the target hardware to determine the profile of the target hardware for the generated code.

In some implementations the metrics associated with the target hardware may include metrics utilized to measure performance characteristics of the target hardware on which the generated code is to be executed. For example the target hardware metrics may include metrics that determine an instruction set of the target hardware a register set of the target hardware a cache size of the target hardware RAM and or ROM sizes of the target hardware parallel computing capabilities of the target hardware power consumption or the like.

In some implementations the instruction set of the target hardware may include information associated with native data types addressing modes a memory architecture interrupt and exception handling input output components or the like of the target hardware. In some implementations code generator may attempt to create generated code that best utilizes the instruction set of the target hardware. For example code generator may eliminate and or modify code that over utilizes or underutilizes the addressing modes the input output components or the like of the target hardware.

In some implementations the register set of the target hardware may include information associated with a set of registers of the target hardware. A register may include storage available as part of a processor e.g. processor . In some implementations code generator may attempt to generate code that best utilizes the register set of the target hardware. For example code generator may eliminate and or modify code that over utilizes or underutilizes the registers of the target hardware.

In some implementations the cache size of the target hardware may include information associated with a size of cache memory of the target hardware. In some implementations code generator may attempt to generate code that best utilizes the cache memory of the target hardware. For example code generator may eliminate and or modify code that over utilizes or underutilizes the cache memory of the target hardware.

In some implementations code generator may attempt to generate code that best utilizes the RAM and or the ROM of the target hardware. For example code generator may eliminate and or modify code that over utilizes or underutilizes the RAM and or the ROM of the target hardware.

In some implementations the parallel computing capabilities of the target hardware may include information associated with parallel computing e.g. via multiple cores multiple processes or threads distributed parallel computing devices or the like capabilities of the target hardware. In some implementations code generator may attempt to generate code that best utilizes the parallel computing capabilities of the target hardware. For example code generator may determine that particular code cannot be executed in parallel. In such an example code generator may eliminate and or modify the particular code so that the generated code may be executed in parallel.

As further shown in process may include identifying an ordering and parameterization for the code generation optimizations based on the determined information block . For example code generator may identify optimal ordering and parameterization for the code generation optimizations e.g. an optimal domain aware phase order based on the determined information. In some implementations code generator may identify the optimal order for the code generation optimizations for each application domain in the model based on the dependency of the code generation optimizations the host device performance characteristics the capabilities of the target compiler and or the target hardware profile.

For an example of the ordering of the optimizations based on the determined information assume that code generator determines that performance of a loop unrolling optimization improves the performance of a constant folding optimization and subsequently that performance of the constant folding optimization improves the performance of a constant inlining optimization. In such an example code generator may determine the optimal order for the code generation optimizations to be performance of the loop unrolling optimization first performance of the constant folding optimization second and performance of the constant inlining optimization third.

For an example of the parameterization of the optimizations based on the determined information assume that code generator determines that the performance of loop unrolling optimization should only be applied to a set of loops sharing a common characteristic in one domain and a set of loops sharing a different common characteristic in another domain. In such an example code generator may determine the optimal application of a loop fusion to parameterize the loop fusion optimization differently for different domains.

In some implementations code generator may repeat the determinations of the application domain the dependency of the code generation optimizations the host device performance characteristics the capabilities of the target compiler and the target hardware profile until a fixed point or a threshold is attained. In some implementations code generator may perform these determinations and may generate code based on the optimal order of the code generation optimizations. Code generator may repeat the determinations until further improvements e.g. as measured by the code efficiency metrics and or the target hardware metrics cannot be made to the generated code e.g. until a fixed point is reached for the improvements .

In some implementations code generator may perform these determinations and may generate code based on the optimal order of the code generation optimizations until a time threshold or a stack threshold is reached. For example the time threshold may include a threshold value indicating a time period e.g. in minutes hours or the like during which code generator is to generate the code. In another example the time threshold may include a threshold value indicating a time period during which TCE is to execute the generated code. In another example the stack threshold may include a threshold value indicating a size of the stack needed to execute the generated code. In such an example as the size of the stack increases the cost of the target hardware may increase. In a third example the time threshold may include a given number of permutations of optimization ordering and the optimal ordering found so far will be produced and used.

As further shown in process may include generating optimal code based on the optimal order of the code generation optimizations block . For example code generator may utilize the optimal order of the code generation optimizations to generate optimal code for the model. In some implementations the optimal code may be referred to as a function interface or an efficient function interface. In some implementations code generator may perform the code generation optimizations in the optimal order in order to generate the optimal code for the model. For example assume that code generator determines the optimal order for the code generation optimizations to be performance of a loop unrolling optimization first performance of a constant folding optimization second and performance of a constant inlining optimization third for a particular application domain. In such an example code generator may perform the loop unrolling optimization first the constant folding optimization second and the constant inlining optimization third in order to generate the optimal code for the model.

In some implementations code generator may generate the optimal code based on a determined data passing scheme such as for example a function argument pass by value scheme a function argument pass by reference scheme a data passing through a function return value scheme a global data access function scheme or the like. In some implementations the optimal code may include one or more methods that are provided or passed arguments e.g. a constant or a variable when the one or more methods are called. Pass by value may refer to passing a constant or a variable with a primitive data type to a method. Pass by reference may refer to passing an object variable to a method. Data passing through a function return value or return value optimization may refer to eliminating a temporary object created to hold a function s return value which may change a behavior of the optimal code. Global access data function may refer to eliminating message passing between components e.g. processors of the target hardware when executing the optimal code.

In some implementations the optimal code may include code provided in a programming language such as C or C an assembly language an intermediate representation language e.g. low level virtual machine LLVM or the like or the like. In some implementations the optimal code may include code that is customized without manual input from the user for the target hardware. The optimal code may be customized since the code is adjusted to specific target hardware on which the code will be executed.

In some implementations the optimal code may reduce data storage and copying between portions of the code which may reduce code execution time and memory consumption. For example the optimal code may reduce data storage and copying between portions of the code since the optimal code is based on the optimal order of the code generation optimizations and one of the data passing schemes.

In some implementations the optimal code may maintain locality of data references which may reduce cache and register over utilization. For example the optimal code may maintain locality of data references since the optimal code is based on the code efficiency metrics and the target hardware metrics.

In some implementations the optimal code may facilitate code reuse which may reduce code size. For example the optimal code may facilitate code reuse since the optimal code may be based on performing checksums e.g. which identify code reuse opportunities on the model.

In some implementations code generator may cause client device to display the optimal code to the user. In some implementations the optimal code may be displayed with or without the model. In some implementations code generator may cause client device to store the optimal code the determined information and or the optimal order of the code generation optimizations in a library e.g. in memory associated with client device . In some implementations the optimal order may be presented to the user and the user may modify the optimal order and may utilize the modified order to generate code. In some implementations performance metrics may be presented to the user so that the user can see the effect of the changes.

In some implementations given the knowledge of application domains common components and modeling patterns e.g. blocks lines or the like regions of operations the implementation of modeling constructs and the optimal code code generator may determine an optimal order and or parameterization for compiler transforms via an exhaustive search machine learning trial and error or the like. For example model developers may build a modeling pattern library to capture past design experience. Based on this library of patterns code generator may analyze optimization orderings to identify effective optimization orderings for each pattern either through traditional search algorithms or through more intelligent search based on advanced artificial intelligence techniques. In some implementations code generator may utilize the knowledge to control compiler transforms the optimal order the parameterization e.g. depth of expression folding satisfaction of an objective e.g. minimal ROM RAM execution speed etc. or the like. In some implementations the patterns may be provided by a user may be utilized with an exhaustive search to determine desired compiler transform ordering and or parameterization meeting some objective may be received from users and redistributed to other users may be received from users utilized with an exhaustive search to solve an objective and redistributed to other users may be utilized with a smart search and existing knowledge of transform dependencies to determine desired transform ordering and or parameterization or the like.

In some implementations a user may provide feedback e.g. approval or disapproval about an objective via an interactive objective search. In some implementations the objective may take into account target information such as compiler information profile result embedded device information host performance information or the like. In some implementations machine learning neural networks genetic algorithms or the like may be utilized to create a rules database for the objective.

In some implementations code generator may automatically partition a model in order to recognize patterns in the model and may generate a user interface that enables a user to specify patterns. In some implementations code generator may generate a user interface that provides pattern results e.g. to link code back to model and patterns and vice versa and or provides user results for different patterns or no patterns .

In some implementations code generator may adaptively create or identify effective orderings and parameterizations of the optimizations for a specific region of operations a modeling pattern a domain a use context or the like. To achieve this code generator may summarize the region of operations with a characterization that captures characteristics relevant to optimizations. Additionally code generator may formulate a search of effective optimization orderings and parameterizations as an optimization problem and may adaptively solve the optimization problem. For example code generator may encode an optimization ordering search space so that the optimization ordering space may be explored with methods such as a genetic algorithm. As such code generator may explore the optimization ordering space to determine an effective ordering for a particular characterization. Furthermore given an effective optimization ordering for a class of regions sharing the same characterization code generator may explore the search space starting from an effective ordering to find an effective ordering for a slightly different characterization. In another example code generator may use a knowledge base of effective optimization orderings and parameterizations and their associated characterization. With this approach code generator may encode the knowledge base into training data for machine learning techniques such as a neural network algorithm. As such with sufficient training code generator may identify an effective optimization ordering for a previously unknown characterization.

Although shows example blocks of process in some implementations process may include additional blocks fewer blocks different blocks or differently arranged blocks than those depicted in . Additionally or alternatively two or more of the blocks of process may be performed in parallel.

After the user selects modeling pattern the user may utilize a menu to instruct code generator to determine feedback for modeling pattern as shown in . For example the user may utilize menu to determine common information for modeling pattern attributes for modeling pattern attributes for the application domain e.g. a control logic domain of model efficiency information for modeling pattern and inefficiency information for modeling pattern . As further shown in the user may utilize buttons to instruct code generator to generate code based on model and or modeling pattern .

As shown in based on the selection of one of buttons code generator may receive model modeling pattern and user inputs . User inputs may include information indicating which of buttons the user selected and information indicating which item s of menu that the user selected. As further shown code generator may be associated with a phase ordering library that stores information associated with domain aware phase orders previously determined and or received by code generator . Code generator may determine one or more code generation optimizations e.g. loop unrolling constant inlining or the like based on model modeling pattern user inputs and or information provided in phase ordering library .

As further shown in code generator may determine an application domain for model and may determine a dependency of code generation optimizations for model and or modeling pattern . For example assume that code generator determines that application domain includes a control logic domain. Further assume that dependency includes information indicating that a performance of a constant inlining optimization is improved by performance of a loop unrolling optimization and that a performance of a constant folding optimization is improved by performance of the constant inlining optimization.

Code generator may determine host device performance characteristics for generating code based on model and or modeling pattern and target compiler capabilities for the generated code. For example assume that code generator determines a usage of the host device s memory required to generate the code as one of host device performance characteristics and a time required to compile the generated code as one of target compiler capabilities . Code generator may determine a target hardware profile for the generated code to include a processing power of a target processor used to execute the generated code. As further shown in application domain dependency of code generation optimizations host device performance characteristics target compiler capabilities and target hardware profile may be provided to and stored by phase ordering library .

Code generator may communicate with phase ordering library and may repeat the determinations of application domain dependency of code generation optimizations host device performance characteristics target compiler capabilities and target hardware profile as indicated by reference number until code generator determines an optimal order for code generation optimizations .

Code generator may utilize the optimal order for code generation optimizations to generate optimal code for model and or modeling pattern as shown in . Assume that code generator determines the optimal order for code generation optimizations to be performance of the loop unrolling optimization first performance of the constant inlining optimization second and performance of the constant folding optimization third. Based on the optimal order code generator may perform the loop unrolling optimization first the constant inlining optimization second and the constant folding optimization third in order to generate optimal code .

As further shown in code generator may provide optimal code to a target compiler provided in client device or server device . Target compiler may compile optimal code to generate compiled code . For example target compiler may transform optimal code written in a source programming language into an executable program written in a target representation e.g. compiled code . Target hardware may execute compiled code to generate results as further shown in . TCE may cause client device to display results to the user to store results and or to provide results to server device .

As indicated above are provided merely as an example. Other examples are possible and may differ from what was described with regard to . In some implementations the various operations described in connection with may be performed automatically or at the request of the user.

After the user selects region of operations the user may instruct code generator to generate code based on model and or region of operations . As shown in based on the instruction code generator may receive model region of operations and user inputs . User inputs may include information indicating a type of code to generate information indicating attributes of an application domain of model or the like. Code generator may determine one or more code generation optimizations e.g. constant inlining loop unrolling or the like based on model region of operations user inputs and or information provided in phase ordering library .

As further shown in code generator may determine an application domain for model and may determine a dependency of code generation optimizations for model and or region of operations . For example assume that code generator determines that application domain includes a signal processing domain. Further assume that dependency includes information indicating that a performance of a loop unrolling optimization is improved by performance of a constant inlining optimization and that a performance of a constant folding optimization is improved by performance of the loop unrolling optimization.

Code generator may determine host device performance characteristics for generating code based on model and or region of operations and target compiler capabilities for the generated code. For example assume that code generator determines a speed of the host device s processor required to generate the code as one of host device performance characteristics and a compiler capacity required to compile the generated code as one of target compiler capabilities . Code generator may determine a target hardware profile for the generated code to include a size and availability of a target memory used to execute the generated code. As further shown in application domain dependency of code generation optimizations host device performance characteristics target compiler capabilities and target hardware profile may be provided to and stored by phase ordering library .

Code generator may communicate with phase ordering library and may repeat the determinations of application domain dependency of code generation optimizations host device performance characteristics target compiler capabilities and target hardware profile as indicated by reference number until code generator determines an optimal order for code generation optimizations . Code generator may utilize the optimal order for code generation optimizations to generate optimal code for model and or region of operations . Code generator may perform code generation optimizations in the optimal order in order to generate the optimal code. Assume that code generator determines the optimal order for code generation optimizations to be performance of the constant inlining optimization first performance of the loop unrolling optimization second and performance of the constant folding optimization third. Based on the optimal order code generator may perform the constant inlining optimization first the loop unrolling optimization second and the constant folding optimization third in order to generate the optimal code.

As indicated above are provided merely as an example. Other examples are possible and may differ from what was described with regard to . In some implementations the various operations described in connection with may be performed automatically or at the request of the user.

The foregoing disclosure provides illustration and description but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above disclosure or may be acquired from practice of the implementations.

A component is intended to be broadly construed as hardware firmware or a combination of hardware and software.

User interfaces may include graphical user interfaces GUIs and or non graphical user interfaces such as text based interfaces. The user interfaces may provide information to users via customized interfaces e.g. proprietary interfaces and or other types of interfaces e.g. browser based interfaces or the like . The user interfaces may receive user inputs via one or more input devices may be user configurable e.g. a user may change the sizes of the user interfaces information displayed in the user interfaces color schemes used by the user interfaces positions of text images icons windows or the like in the user interfaces or the like and or may not be user configurable. Information associated with the user interfaces may be selected and or manipulated by a user of a technical computing environment TCE e.g. via a touch screen display a mouse a keyboard a keypad voice commands or the like .

Some implementations are described herein in connection with thresholds. As used herein satisfying a threshold may refer to a value being greater than the threshold more than the threshold higher than the threshold greater than or equal to the threshold less than the threshold fewer than the threshold lower than the threshold less than or equal to the threshold equal to the threshold etc.

It will be apparent that systems and or methods described herein may be implemented in different forms of hardware firmware or a combination of hardware and software. The actual specialized control hardware or software code used to implement these systems and or methods is not limiting of the implementations. Thus the operation and behavior of the systems and or methods were described herein without reference to specific software code it being understood that software and hardware can be designed to implement the systems and or methods based on the description herein.

Even though particular combinations of features are recited in the claims and or disclosed in the specification these combinations are not intended to limit the disclosure of possible implementations. In fact many of these features may be combined in ways not specifically recited in the claims and or disclosed in the specification. Although each dependent claim listed below may directly depend on only one claim the disclosure of possible implementations includes each dependent claim in combination with every other claim in the claim set.

No element act or instruction used herein should be construed as critical or essential unless explicitly described as such. Also as used herein the articles a and an are intended to include one or more items and may be used interchangeably with one or more. Furthermore as used herein the term set is intended to include one or more items and may be used interchangeably with one or more. Where only one item is intended the term one or similar language is used. Also as used herein the terms has have having or the like are intended to be open ended terms. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

