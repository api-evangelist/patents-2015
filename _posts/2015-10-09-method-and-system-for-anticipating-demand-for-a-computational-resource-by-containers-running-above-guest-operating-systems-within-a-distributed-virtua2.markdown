---

title: Method and system for anticipating demand for a computational resource by containers running above guest operating systems within a distributed, virtualized computer system
abstract: The current document is directed to methods and systems for efficiently executing OSL-virtualization containers within the execution environments provided by virtual machines that execute above traditional virtualization layers within large, virtualized, distributed computing systems. The currently disclosed methods and systems anticipate the need for additional virtual machines in order to meet anticipated demands for one or more computational resources by the containers. In addition, the methods and systems provision and launch virtual machines with computational-resource allocations that minimize overhead and computational-resource wastage. In one implementation, computational-resource utilization of ATMs and containers within the virtualized, distributed computer system are periodically monitored in order to estimate future demand for the computational resource and, when necessary, to launch additional virtual machines to meet the estimated future demand for the computational resource.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619261&OS=09619261&RS=09619261
owner: VMware, Inc.
number: 09619261
owner_city: Palo Alto
owner_country: US
publication_date: 20151009
---
Benefit is claimed under 35 U.S.C. 119 a d to Foreign application Serial No. 3318 CHE 2015 filed in India entitled METHOD AND SYSTEM FOR ANTICIPATING DEMAND FOR A COMPUTATIONAL RESOURCE BY CONTAINERS RUNNING ABOVE GUEST OPERATING SYSTEMS WITHIN A DISTRIBUTED VIRTUALIZED COMPUTER SYSTEM filed on Jun. 29 2015 by VMware Inc. which is herein incorporated in its entirety by reference for all purposes.

The current document is directed to virtualized distributed computer systems such as virtualized distributed computer systems that operate as cloud computing facilities and in particular to methods and systems for elastic scheduling of virtual machines to host containers that in turn provide execution environments for applications within the cloud computing facility.

During the past 60 years computer systems have evolved from primitive single processor computer systems that lacked operating systems and compilers for modern structured programming languages to enormous geographically distributed computer systems comprising hundreds thousands or more individual multi processor computer systems linked together with network communications and shared mass storage facilities concurrently running many different sophisticated applications. These large distributed computer systems are often virtualized to provide virtual data centers and virtual data center aggregations that in turn provide for flexible and efficient system administration. Many cloud computing facilities provide interfaces to large virtualized distributed computing systems that allow clients of the cloud computing facilities to rapidly and dynamically configure virtual host systems for running client applications that can in turn provide computing services to thousands millions or more remote users. Many of the virtualization technologies employed within cloud computing facilities involve virtualization layers that execute above the hardware layer of host computers to provide execution environments for virtual machines. The virtual machines in turn provide execution environments for guest operating systems which in turn provide execution environments for applications. This type of virtualization technology provides enormous advantages to owners and administrators of cloud computing facilities as well as to cloud computing facility clients. These virtualization technologies as one example can simulate any of many different types of underlying hardware and can therefore provide a virtual hardware platform on which many different types of operating systems can execute. However the enormous flexibility provided by this type of virtualization technology is associated with certain computational overheads and costs. Another approach to virtualization is referred to as operating system level virtualization OSL virtualization . While not as flexible and powerful as the traditional virtualization technologies that provide virtualization layers to support virtual machine execution OSL virtualization has significantly lower computational overheads and costs and is for that reason an increasingly popular choice for virtual hosting environments such as those used to run client applications in cloud computing facilities. Designers and developers of distributed computing systems designers and developers of cloud computing facilities owners and administrators of cloud computing facilities and other distributed computing systems and ultimately users of distributed computing systems continue to seek efficient and cost effective technologies that provide a foundation for cloud computing and other virtualized distributed computing systems applications.

The current document is directed to methods and systems for efficiently executing OSL virtualization containers within the execution environments provided by virtual machines that execute above traditional virtualization layers within large virtualized distributed computing systems. The currently disclosed methods and systems anticipate the need for additional virtual machines in order to meet anticipated demands for one or more computational resources by the containers. In addition the methods and systems provision and launch virtual machines with computational resource allocations that minimize overhead and computational resource wastage. In one implementation computational resource utilization of VMs and containers within the virtualized distributed computer system are periodically monitored in order to estimate future demand for the computational resource and when necessary to launch additional virtual machines to meet the estimated future demand for the computational resource.

The current document is directed to methods and systems for elastic scheduling of virtual machines within a virtualized distributed computer system in order to provide execution environments for OSL virtualization containers that in turn provide execution environments for client applications. In a first subsection below traditional virtualization technologies are described with reference to . In a following subsection contains and containers supported by virtualization layers are discussed. In a third subsection the methods and systems for elastic scheduling of VMs in order to anticipate resource needs of containers is discussed in detail with reference to flow diagrams and C implementation.

The term abstraction is not in any way intended to mean or suggest an abstract idea or concept. Computational abstractions are tangible physical interfaces that are implemented ultimately using physical computer hardware data storage devices and communications systems. Instead the term abstraction refers in the current discussion to a logical level of functionality encapsulated within one or more concrete tangible physically implemented computer systems with defined interfaces through which electronically encoded data is exchanged process execution launched and electronic services are provided. Interfaces may include graphical and textual data displayed on physical display devices as well as computer programs and routines that control physical computer processors to carry out various tasks and operations and that are invoked through electronically implemented application programming interfaces APIs and other electronically implemented interfaces. There is a tendency among those unfamiliar with modem technology and science to misinterpret the terms abstract and abstraction when used to describe certain aspects of modem computing. For example one frequently encounters assertions that because a computational system is described in terms of abstractions functional layers and interfaces the computational system is somehow different from a physical machine or device. Such allegations are unfounded. One only needs to disconnect a computer system or group of computer systems from their respective power supplies to appreciate the physical machine nature of complex computer technologies. One also frequently encounters statements that characterize a computational technology as being only software and thus not a machine or device. Software is essentially a sequence of encoded symbols such as a printout of a computer program or digitally encoded computer instructions sequentially stored in a file on an optical disk or within an electromechanical mass storage device. Software alone can do nothing. It is only when encoded computer instructions are loaded into an electronic memory within a computer system and executed on a physical processor that so called software implemented functionality is provided. The digitally encoded computer instructions are an essential and physical control component of processor controlled machines and devices no less essential and physical than a cam shaft control system in an internal combustion engine. Multi cloud aggregations cloud computing services virtual machine containers and virtual machines communications interfaces and many of the other topics discussed below are tangible physical components of physical electro optical mechanical computer systems.

Of course there are many different types of computer system architectures that differ from one another in the number of different memories including different types of hierarchical cache memories the number of processors and the connectivity of the processors with other system components the number of internal communications busses and serial links and in many other ways. However computer systems generally execute stored programs by fetching instructions from memory and executing the instructions in one or more processors. Computer systems include general purpose computer systems such as personal computers PCs various types of servers and workstations and higher end mainframe computers but may also include a plethora of various types of special purpose computing devices including data storage systems communications routers network nodes tablet computers and mobile telephones.

Until recently computational services were generally provided by computer systems and data centers purchased configured managed and maintained by service provider organizations. For example an e commerce retailer generally purchased configured managed and maintained a data center including numerous web servers back end computer systems and data storage systems for serving web pages to remote customers receiving orders through the web page interface processing the orders tracking completed orders and other myriad different tasks associated with an e commerce enterprise.

Cloud computing facilities are intended to provide computational bandwidth and data storage services much as utility companies provide electrical power and water to consumers. Cloud computing provides enormous advantages to small organizations without the resources to purchase manage and maintain in house data centers. Such organizations can dynamically add and delete virtual computer systems from their virtual data centers within public clouds in order to track computational bandwidth and data storage needs rather than purchasing sufficient computer systems within a physical data center to handle peak computational bandwidth and data storage demands. Moreover small organizations can completely avoid the overhead of maintaining and managing physical computer systems including hiring and periodically retraining information technology specialists and continuously paying for operating system and database management system upgrades. Furthermore cloud computing interfaces allow for easy and straightforward configuration of virtual computing facilities flexibility in the types of applications and operating systems that can be configured and other functionalities that are useful even for owners and administrators of private cloud computing facilities used by a single organization.

While the execution environments provided by operating systems have proved to be an enormously successful level of abstraction within computer systems the operating system provided level of abstraction is nonetheless associated with difficulties and challenges for developers and users of application programs and other higher level computational entities. One difficulty arises from the fact that there are many different operating systems that run within various different types of computer hardware. In many cases popular application programs and computational systems are developed to run on only a subset of the available operating systems and can therefore be executed within only a subset of the various different types of computer systems on which the operating systems are designed to run. Often even when an application program or other computational system is ported to additional operating systems the application program or other computational system can nonetheless run more efficiently on the operating systems for which the application program or other computational system was originally targeted. Another difficulty arises from the increasingly distributed nature of computer systems. Although distributed operating systems are the subject of considerable research and development efforts many of the popular operating systems are designed primarily for execution on a single computer system. In many cases it is difficult to move application programs in real time between the different computer systems of a distributed computer system for high availability fault tolerance and load balancing purposes. The problems are even greater in heterogeneous distributed computer systems which include different types of hardware and devices running different types of operating systems. Operating systems continue to evolve as a result of which certain older application programs and other computational entities may be incompatible with more recent versions of operating systems for which they are targeted creating compatibility issues that are particularly difficult to manage in large distributed systems.

For all of these reasons a higher level of abstraction referred to as the virtual machine has been developed and evolved to further abstract computer hardware in order to address many difficulties and challenges associated with traditional computing systems including the compatibility issues discussed above. illustrate two types of virtual machine and virtual machine execution environments. use the same illustration conventions as used in . shows a first type of virtualization. The computer system in includes the same hardware layer as the hardware layer shown in . However rather than providing an operating system layer directly above the hardware layer as in the virtualized computing environment illustrated in features a virtualization layer that interfaces through a virtualization layer hardware layer interface equivalent to interface in to the hardware. The virtualization layer provides a hardware like interface to a number of virtual machines such as virtual machine executing above the virtualization layer in a virtual machine layer . Each virtual machine includes one or more application programs or other higher level computational entities packaged together with an operating system referred to as a guest operating system such as application and guest operating system packaged together within virtual machine . Each virtual machine is thus equivalent to the operating system layer and application program layer in the general purpose computer system shown in . Each guest operating system within a virtual machine interfaces to the virtualization layer interface rather than to the actual hardware interface . The virtualization layer partitions hardware resources into abstract virtual hardware layers to which each guest operating system within a virtual machine interfaces. The guest operating systems within the virtual machines in general are unaware of the virtualization layer and operate as if they were directly accessing a true hardware interface. The virtualization layer ensures that each of the virtual machines currently executing within the virtual environment receive a fair allocation of underlying hardware resources and that all virtual machines receive sufficient resources to progress in execution. The virtualization layer interface may differ for different guest operating systems. For example the virtualization layer is generally able to provide virtual hardware interfaces for a variety of different types of computer hardware. This allows as one example a virtual machine that includes a guest operating system designed for a particular computer architecture to run on hardware of a different architecture. The number of virtual machines need not be equal to the number of physical processors or even a multiple of the number of processors.

The virtualization layer includes a virtual machine monitor module VMM that virtualizes physical processors in the hardware layer to create virtual processors on which each of the virtual machines executes. For execution efficiency the virtualization layer attempts to allow virtual machines to directly execute non privileged instructions and to directly access non privileged registers and memory. However when the guest operating system within a virtual machine accesses virtual privileged instructions virtual privileged registers and virtual privileged memory through the virtualization layer interface the accesses result in execution of virtualization layer code to simulate or emulate the privileged resources. The virtualization layer additionally includes a kernel module that manages memory communications and data storage machine resources on behalf of executing virtual machines VM kernel . The VM kernel for example maintains shadow page tables on each virtual machine so that hardware level virtual memory facilities can be used to process memory accesses. The VM kernel additionally includes routines that implement virtual communications and data storage devices as well as device drivers that directly control the operation of underlying hardware communications and data storage devices. Similarly the VM kernel virtualizes various other types of I O devices including keyboards optical disk drives and other such devices. The virtualization layer essentially schedules execution of virtual machines much like an operating system schedules execution of application programs so that the virtual machines each execute within a complete and fully functional virtual hardware layer.

In the layers are somewhat simplified for clarity of illustration. For example portions of the virtualization layer may reside within the host operating system kernel such as a specialized driver incorporated into the host operating system to facilitate hardware access by the virtualization layer.

It should be noted that virtual hardware layers virtualization layers and guest operating systems are all physical entities that are implemented by computer instructions stored in physical data storage devices including electronic memories mass storage devices optical disks magnetic disks and other such devices. The term virtual does not in any way imply that virtual hardware layers virtualization layers and guest operating systems are abstract or intangible. Virtual hardware layers virtualization layers and guest operating systems execute on physical processors of physical computer systems and control operation of the physical computer systems including operations that alter the physical states of physical devices including electronic memories and mass storage devices. They are as physical and tangible as any other component of a computer since such as power supplies controllers processors busses and data storage devices.

A virtual machine or virtual application described below is encapsulated within a data package for transmission distribution and loading into a virtual execution environment. One public standard for virtual machine encapsulation is referred to as the open virtualization format OVF . The OVF standard specifies a format for digitally encoding a virtual machine within one or more data files. illustrates an OVF package. An OVF package includes an OVF descriptor an OVF manifest an OVF certificate one or more disk image files and one or more resource files . The OVF package can be encoded and stored as a single file or as a set of files. The OVF descriptor is an XML document that includes a hierarchical set of elements each demarcated by a beginning tag and an ending tag. The outermost or highest level element is the envelope element demarcated by tags and . The next level element includes a reference element that includes references to all files that are part of the OVF package a disk section that contains meta information about all of the virtual disks included in the OVF package a networks section that includes meta information about all of the logical networks included in the OVF package and a collection of virtual machine configurations which further includes hardware descriptions of each virtual machine . There are many additional hierarchical levels and elements within a typical OVF descriptor. The OVF descriptor is thus a self describing XML file that describes the contents of an OVF package. The OVF manifest is a list of cryptographic hash function generated digests of the entire OVF package and of the various components of the OVF package. The OVF certificate is an authentication certificate that includes a digest of the manifest and that is cryptographically signed. Disk image files such as disk image file are digital encodings of the contents of virtual disks and resource files are digitally encoded content such as operating system images. A virtual machine or a collection of virtual machines encapsulated together within a virtual application can thus be digitally encoded as one or more files within an OVF package that can be transmitted distributed and loaded using well known tools for transmitting distributing and loading files. A virtual appliance is a software service that is delivered as a complete software stack installed within one or more virtual machines that is encoded within an OVF package.

The advent of virtual machines and virtual environments has alleviated many of the difficulties and challenges associated with traditional general purpose computing. Machine and operating system dependencies can be significantly reduced or entirely eliminated by packaging applications and operating systems together as virtual machines and virtual appliances that execute within virtual environments provided by virtualization layers running on many different types of computer hardware. A next level of abstraction referred to as virtual data centers which are one example of a broader virtual infrastructure category provide a data center interface to virtual data centers computationally constructed within physical data centers. illustrates virtual data centers provided as an abstraction of underlying physical data center hardware components. In a physical data center is shown below a virtual interface plane . The physical data center consists of a virtual infrastructure management server VI management server and any of various different computers such as PCs on which a virtual data center management interface may be displayed to system administrators and other users. The physical data center additionally includes generally large numbers of server computers such as server computer that are coupled together by local area networks such as local area network that directly interconnects server computer and and a mass storage array . The physical data center shown in includes three local area networks and that each directly interconnects a bank of eight servers and a mass storage array. The individual server computers such as server computer each includes a virtualization layer and runs multiple virtual machines. Different physical data centers may include many different types of computers networks data storage systems and devices connected according to many different types of connection topologies. The virtual data center abstraction layer a logical abstraction layer shown by a plane in abstracts the physical data center to a virtual data center comprising one or more resource pools such as resource pools one or more virtual data stores such as virtual data stores and one or more virtual networks. In certain implementations the resource pools abstract banks of physical servers directly interconnected by a local area network.

The virtual data center management interface allows provisioning and launching of virtual machines with respect to resource pools virtual data stores and virtual networks so that virtual data center administrators need not be concerned with the identities of physical data center components used to execute particular virtual machines. Furthermore the VI management server includes functionality to migrate running virtual machines from one physical server to another in order to optimally or near optimally manage resource allocation provide fault tolerance and high availability by migrating virtual machines to most effectively utilize underlying physical hardware resources to replace virtual machines disabled by physical hardware problems and failures and to ensure that multiple virtual machines supporting a high availability virtual appliance are executing on multiple physical computer systems so that the services provided by the virtual appliance are continuously accessible even when one of the multiple virtual appliances becomes compute bound data access bound suspends execution or fails. Thus the virtual data center layer of abstraction provides a virtual data center abstraction of physical data centers to simplify provisioning launching and maintenance of virtual machines and virtual appliances as well as to provide high level distributed functionalities that involve pooling the resources of individual physical servers and migrating virtual machines among physical servers to achieve load balancing fault tolerance and high availability.

The distributed services include a distributed resource scheduler that assigns virtual machines to execute within particular physical servers and that migrates virtual machines in order to most effectively make use of computational bandwidths data storage capacities and network capacities of the physical data center. The distributed services further include a high availability service that replicates and migrates virtual machines in order to ensure that virtual machines continue to execute despite problems and failures experienced by physical hardware components. The distributed services also include a live virtual machine migration service that temporarily halts execution of a virtual machine encapsulates the virtual machine in an OVF package transmits the OVF package to a different physical server and restarts the virtual machine on the different physical server from a virtual machine state recorded when execution of the virtual machine was halted. The distributed services also include a distributed backup service that provides centralized virtual machine backup and restore.

The core services provided by the VI management server include host configuration virtual machine configuration virtual machine provisioning generation of virtual data center alarms and events ongoing event logging and statistics collection a task scheduler and a resource management module. Each physical server also includes a host agent virtual machine through which the virtualization layer can be accessed via a virtual infrastructure application programming interface API . This interface allows a remote administrator or user to manage an individual server through the infrastructure API. The virtual data center agents access virtualization layer server information through the host agents. The virtual data center agents are primarily responsible for offloading certain of the virtual data center management server functions specific to a particular physical server to that physical server. The virtual data center agents relay and enforce resource allocations made by the VI management server relay virtual machine provisioning and configuration change commands to host agents monitor and collect performance statistics alarms and events communicated to the virtual data center agents by the local host agents through the interface API and to carry out other similar virtual data management tasks.

The virtual data center abstraction provides a convenient and efficient level of abstraction for exposing the computational resources of a cloud computing facility to cloud computing infrastructure users. A cloud director management server exposes virtual resources of a cloud computing facility to cloud computing infrastructure users. In addition the cloud director introduces a multi tenancy layer of abstraction which partitions virtual data centers VDCs into tenant associated VDCs that can each be allocated to a particular individual tenant or tenant organization both referred to as a tenant. A given tenant can be provided one or more tenant associated VDCs by a cloud director managing the multi tenancy layer of abstraction within a cloud computing facility. The cloud services interface in exposes a virtual data center management interface that abstracts the physical data center.

Considering the VI management server and cloud director layers of abstraction can be seen as discussed above to facilitate employment of the virtual data center concept within private and public clouds. However this level of abstraction does not fully facilitate aggregation of single tenant and multi tenant virtual data centers into heterogeneous or homogeneous aggregations of cloud computing facilities.

As mentioned above while the traditional virtual machine based virtualization layers described in the previous subsection have enjoyed widespread adoption and use in a variety of different environments from personal computers to enormous distributed computing systems traditional virtualization technologies are associated with computational overheads. While these computational overheads have steadily decreased over the years and often represent ten percent or less of the total computational bandwidth consumed by an application running above a guest operating system in a virtualized environment traditional virtualization technologies nonetheless involve computational costs in return for the power and flexibility that they provide.

Another approach to virtualization as also mentioned above is referred to as operating system level virtualization OSL virtualization . illustrates OSL virtualization. In as in previously discussed an operating system runs above the hardware of a host computer. The operating system provides an interface for higher level computational entities that includes a system call interface and the non privileged instructions memory addresses and registers provided by the hardware layer . However unlike in in which applications run directly above the operating system OSL virtualization involves an OS level virtualization layer that provides an operating system interface to each of one or more containers . The containers in turn provide an execution environment for one or more applications such as application running within the execution environment provided by container . The container can be thought of as a partition of the resources generally available to higher level computational entities through the operating system interface . While a traditional virtualization layer can simulate the hardware interface expected by any of many different operating systems OSL virtualization essentially provides a secure partition of the execution environment provided by a particular operating system. As one example OSL virtualization provides a file system to each container but the file system provided to the container is essentially a view of a partition of the general file system provided by the underlying operating system. In essence OSL virtualization uses operating system features such as namespace support to isolate each container from the remaining containers so that the applications executing within the execution environment provided by a container are isolated from applications executing within the execution environments provided by the other containers. As a result a container can be booted up much faster than a virtual machine since the container uses operating system kernel features that are already available and functioning within the host computer. Furthermore the containers share computational bandwidth memory network bandwidth and other computational resources provided by the operating system without the overhead associated with computational resources allocated to virtual machines and virtualization layers. Again however OSL virtualization does not provide many desirable features of traditional virtualization. As mentioned above OSL virtualization does not provide a way to run different types of operating systems for different groups of containers within the same host system and OSL virtualization does not provide for live migration of containers between host computers high availability functionality distributed resource scheduling and other computational functionality provided by traditional virtualization technologies.

Running containers above a guest operating system within a virtualized host computer provides advantages of traditional virtualization in addition to the advantages of OSL virtualization. Containers can be quickly booted in order to provide additional execution environments and associated resources for additional application instances. The resources available to the guest operating system are efficiently partitioned among the containers provided by the OSL virtualization layer since there is almost no additional computational overheads associated with container based partitioning of computational resources. However many of the powerful and flexible features of the traditional virtualization technology can be applied to virtual machines in which containers run above guest operating systems including live migration from one host computer to another various types of high availability and distributed resource scheduling and other such features. Containers provide share based allocation of computational resources to groups of applications with guaranteed isolation of applications in one container from applications in the remaining containers executing above a guest operating system. Moreover resource allocation can be modified at run time between containers. The traditional virtualization layer provides for flexible and easy scaling over large numbers of host computers within large distributed computing systems and a simple approach to operating system upgrades and patches. Thus the use of OSL virtualization above traditional virtualization in a hybrid virtualized distributed computing system as illustrated in provides many of the advantages of both a traditional virtualization layer and the advantages of OSL virtualization.

The current disclosure is particularly directed to an elastic scheduling method and system that anticipates the need for additional resources to support launching additional containers in a hybrid virtualized distributed computing system. Virtual data center administration facilities provided by the virtualization layer anticipates the future need for additional physical computational resources such as additional host computers memory mass storage devices and other such resources. However running OSL virtualization containers above guest operating systems introduces new computational resource issues not previously addressed within virtualization layers including the need to anticipate when to provision and launch additional virtual machines in order to provide sufficient computational resources for launching of new containers to run additional client application programs and or additional instances of already running application programs. When launching new VMs the number of VMs to provision and launch and the amount of resources allocated to each of the VMs need to be carefully considered in order to minimize wastage of computational resources. Each VM is associated with a certain amount of overhead so that in general it is best to launch fewer VMs with greater resource allocations provided that the allocated resources match the anticipated need for additional computational resources to support launching of additional containers.

In the state of a hybrid virtualized distributed computing system is illustrated. The virtualized distributed computing system includes four host computers represented by four sets of horizontal bars . The large horizontal bars represent the amount of a physical memory resource within each of the host computers respectively. A scale shows the correspondence between gigabytes of memory and the lengths of the horizontal bars representing the memory resource. Shorter horizontal bars representing the virtual machines currently running within the host computer are shown in above the horizontal bars representing the available physical memory within host computers. The shorter horizontal bars representing the virtual machines such as horizontal bar indicate the local name for the virtual machine the guest operating system running within the virtual machine and the available memory for supporting OSL virtualization containers. A third level of short horizontal bars above the shorter horizontal bars representing virtual machines represent containers running within the guest operating system provided execution environment. For example short horizontal bars represent three containers C C and C respectively running within a Linux execution environment within virtual machine VM executing on host computer . The local name of the container and the amount of memory utilized by the container are shown within each short horizontal bar representing a container. A clock symbol is used to indicate a time point at which the state snapshot represented by the sets of horizontal bars was obtained. The min and max arrows represent the minimum amount of memory and the maximum amount of memory that can be allocated to a virtual machine when the virtual machine is provisioned and launched. Thus according to the example hybrid virtualized distributed computing system includes 1 a first host computer on which two virtual machines and are currently executing the first virtual machine supporting three containers and the second virtual machine supporting a single container 2 a second host computer on which two virtual machines and are currently executing the first of which is currently supporting three containers and the second of which currently supports a single container 3 a third host computer on which a single virtual machine is currently running and supporting two containers and and a fourth host computer on which two virtual machines and are currently running the first of which currently supports two containers and and the second of which is currently supporting a single container .

A better approach to launching and provisioning VMs to support containers in a hybrid virtualized distributed computing system would be to attempt to anticipate the need for new virtual machines well before they are actually needed so that sufficient computational resources are available to launch new containers on demand. Moreover by anticipating the demand for resources to launch of new containers new VMs can be launched with appropriate amounts of allocated resources to efficiently satisfy expected demands for computational resources.

There are a variety of different well known methods for estimating or extrapolating a subsequent data point from a time series of data points. illustrate three of the many different data point extrapolation methods. In each of a plot of the values of a discrete function with respect to time is shown. The data points such as data point in represent the function value at a particular point in time such as time point on the horizontal axis corresponding to data point with value equal to the height of the data point above the horizontal time axis . One method for estimating a subsequent data point shown in is to use linear regression to determine a best estimated line that fits the data points in the time series of data points. In one approach a line is computes that minimizes the squared vertical deviations of the data points from the line. Once a best fitting line is obtained a next data point in the time series is estimated as the intersection between the best fitting line and a vertical line passing through the time at which the estimated function value is desired. Another approach shown in is to attempt to fit some type of constrained curve to the data points. The curve may have local radius of curvature constraints for example so that it is reasonably smooth. Once the curve is determined then the value of the next data point in the time series can be estimated as the intersection of the curve and the vertical line corresponding to the next time point . Yet another approach as shown in is to attempt to optimally fit some number of lines or curves to the data points and estimate the subsequent data point from the intersection of the vertical line to the next time interval and the final linear or curved segment estimated from the time series of data points. There are many additional methods that can be used to extrapolate the values of subsequent data points in a data point time series.

In step the monitoring routine pushes the amount of the computational resource data os .C utilized utilized by the containers running within guest operating systems of the currently considered type of operating system that were launched during the most recent monitoring interval onto the end of the data point window. The push operation may remove the first data point of the window when necessary in order to make space to push the most recently determined data point onto the data point window. When there are as sufficient number of data points in the data point window to estimate the projected utilization of the computational resource for the next future time interval as determined in step the monitoring routine estimates the next data point d in step using a data point extrapolation method such as one of those discussed above with reference to . The monitoring routine then uses the estimated data point to carry out eager provision of new VMs when a future need for more resources is indicated by the estimated data point value d in step . The routine eager provision is discussed below with reference to . When there are more OS types in the set of OS types OSset as determined in step control returns to step to estimate the demand for the computation resource for a next operating system type. When all the operating system types have been considered the data point windows for any operating system types for which no data point was computed in the current monitoring interval are cleared in step since there would otherwise a discontinuity in the time series of data points. A data point is not computed for an operating system type for example when there are no currently executing VMs that run an operating system of that type.

An enumeration OS includes a listing of the various types of operating systems run by VMs in the distributed computing system. The type definition time produces a type time used for the start times of containers and for other purposes. As with all the particular implementation details in this C like implementation various alternative types constants constant values and other such details may be used in alternative implementations. In general time stamps generated by the distributed system may be integer values that express the number of some time unit such as milliseconds seconds or other time units that have elapsed since some arbitrary initial time. Alternatively time stamps may be encoded in date time formats corresponding to calendar and clock time.

The function wait causes a routine to wait for an indicated amount of time before resuming execution. No implementation for this routine is provided since it is highly dependent on platform hardware choice of virtualization technology and or choice of operating system. The routine extrapolate extrapolates a next data point in a time series of data points by any of various different methods discussed above or by other extrapolation methods. Data extrapolation routines may be based on simple linear extrapolation using linear regression may be based on various types of curve fitting or may be based on more sophisticated time sequence progression estimation techniques. The type definition for the type Ct is used to store the memory utilization and start time for a container in an array of elements of type Ct that is sorted as part of the method implemented below in a monitor routine.

Next four class declarations are provided. In all cases only the public function member portions of the declaration are provided since there are many different and generally straightforward ways of implementing these classes. The class Container represents a container running within the distributed computing system. Member functions allow for the memory utilization and start time for the container to be extracted from an instance of the class Container including the member functions get Utilization and getStart and an operator initialization routine and constructor are also defined for the class Container.

The class VM represents a virtual machine executing within the distributed computing system. The class VM includes an operator initialization routine and constructor like the Container class. In addition the member functions get Utilization and getConfigured are used to determine the amount of memory utilized by the VM and the amount of configured memory for the VM respectively. The member function getOS is used to extract an indication of the type of operating system run by the VM. The member function getNumContainers is used to determine the number of containers currently executing within the execution environment provided by the VM. The pair of member functions getFirstContainer and getNextContainer are used to traverse the containers currently executing within the execution environment provided by the VM.

The type definitions for VMptr and Ctptr are provided as convenient types for pointers to instances of the VM and Container classes respectively . The class set is a generalized class representing a set of objects of type M . The class set includes member functions for adding an element to the set the pair of member functions first and next which allow the elements in the set to be traversed a member function getNum which returns the number of elements in the set and the member function in which returns a Boolean value to indicate whether the reference to an element supplied as an argument to the function in is currently contained in the set.

A final declaration is for the class dSystem . This class represents the distributed computing system. The class provides a pair of functions getFirstVM and getNextVM provides a mechanism for traversing the VMs associated with the distributed computing system. In certain implementations this may mean those VMs currently executing within the distributed computing system. In other implementations this may mean both the currently executing VMs as well as any VMs that were executing during some more recent period of time such as in one example during the past n time intervals considered by the subsequently described monitoring method. In other words in order to estimate future demand for container associated resources one may consider only the currently executing VMs or one may consider a historical record of all VMs that were executing over a considered previous time period. In many cases the number of executing VMs in the distributed computing system may be relatively stable over the considered periods of time and may generally increase in which case a historical perspective is unnecessary. In other cases the number of executing VMs may fluctuate with demand over the considered time period as a result of which a historical perspective provides a better estimate of future demand for resources. Two member functions provision and launch provide for provisioning and launching VMs within the distributed computing system. The member function getCurrentTime is used to obtain a current time stamp from the distributed computing system. The member functions beginMonitor and endMonitor are used in the subsequently described monitoring routine to signal beginning of routine execution and ending of routine execution in case that the distributed computing system wishes to temporarily suspend certain activities while the monitoring routine executes in order to ensure that the monitoring routine produces a best possible prediction.

Turning to when no containers are currently being executed by VMs supported the currently considered operating system then further execution of the current iteration of the main while loop is terminated and execution resumes at the beginning of the main loop . Otherwise Ct data structures representing the containers launched within the considered time period stored in the array sortedCts are sorted by a quicksort operation . The local variable nextTime is set to the final time in the first time interval within the considered period . In a while loop local variable mStart is incremented until the start time of the first container in the array sortedCts falls within the time interval within the considered time period represented by the current value of mStart. Local variable j is set to . Local variable j represents the next element of the array sortedCts to be considered in the following for loop . In for loop each data point corresponding to considered time intervals within the considered time period are computed. The data points are stored in the array MbyInterval. During each iteration of the for loop the value of the currently considered data point is first initialized to 0 . When the index i for the data point is greater than or equal to the current value of mStart then all of the Ct data structures that include start times less than the final time for the currently considered interval stored in the local variable nextTime are used to compute the currently considered data point as the sum of the memory utilized by all of the containers launched within the currently considered time interval in the inner while loop . Following execution of for loop a next memory demand or total memory utilized data point is predicted or estimated using the extrapolation routine .

Although the present invention has been described in terms of particular embodiments it is not intended that the invention be limited to these embodiments. Modifications within the spirit of the invention will be apparent to those skilled in the art. For example any of many different design and implementation parameters may be varied in order to generate a variety of different implementations of the above disclosed methods and systems including choice of native virtualization layers programming languages communications protocols modular organization data structures control structures and other such design and implementation parameters. Any of many different data point extrapolation routines can be employed. The length of the monitoring period may vary and may in certain implementations dynamically vary. Many different types of computational resource utilization may be monitored concurrently in order to ensure that adequate amounts of the resources are available to allow for launch of containers on demand without needing to first provision and launch VMs.

It is appreciated that the previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present disclosure. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the disclosure. Thus the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

