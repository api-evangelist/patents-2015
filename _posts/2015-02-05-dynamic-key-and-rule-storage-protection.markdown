---

title: Dynamic key and rule storage protection
abstract: A media processing device includes a key store memory to store a plurality of cryptographic keys and a rule set memory to store a plurality of rules for the plurality of cryptographic keys. The media processing device further includes an integrity module to determine a first cyclical redundancy check (CRC) value from the plurality of rules stored in the rule set memory and compare the first CRC with a second CRC value associated with the plurality of rules. The media processing device further includes an arbitration module to prevent further access to the plurality of rules in the rule set memory responsive to the integrity verification module signaling a mismatch between the first CRC and the second CRC.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501429&OS=09501429&RS=09501429
owner: VIXS Systems Inc.
number: 09501429
owner_city: Toronto
owner_country: CA
publication_date: 20150205
---
The present application claims priority as a continuation in part application to U.S. patent application Ser. No. 14 048 391 filed on May 15 2014 and entitled Secure key access with one time programmable memory and applications thereof which claims priority as a continuation in part application to U.S. patent application Ser. No. 12 651 996 filed on Jan. 4 2010 and entitled Secure Key Access With One Time Programmable Memory and Applications Thereof which in turn claims priority as a continuation in part application to U.S. patent application Ser. No. 12 490 777 filed Jun. 24 2009 and entitled Device With Privileged Memory and Applications Thereof which claims priority to U.S. Patent Application Ser. No. 61 094 541 filed Sep. 5 2008 and entitled Methods for System on a Chip Cryptographic Key Access and Storage the entireties of which are incorporated by reference herein.

The present application is related to co pending U.S. patent application Ser. No. 14 614 797 entitled Provisioning of Secure Storage for Both Static and Dynamic Rules of Cryptographic Key Information and filed on even date herewith the entirety of which is incorporated by reference herein.

The present disclosure relates generally to techniques for securing data and more particularly techniques for storing and providing access to cryptographic keys and other secret values used to secure data.

The desire to keep media content or other proprietary information secure from unauthorized use e.g. unauthorized copying distribution etc. is driven by a sector of the population that places little to no value on the intellectual properties rights of others. As such the battle between creating security systems for digital information and the hackers that attempt to break them continues.

This battle is intensifying with the integration of electronic device features being implemented on a single device e.g. computer with DVD functionality and is further intensified by video processing hardware being implemented as stand alone system on a chip SOC devices. In many instances the video processing hardware SOC uses an operating system that allows end users to write their own applications which means that the user s application may share the same processors and memory space as the security system. This makes the security operations vulnerable. To reduce the vulnerability media processing hardware needs to be constrained to performing only specific intended types of cryptographic operations.

In addition media processing devices which include the media processing hardware SOC are embedded with licensed secret keys for compliance with one or more of a plurality of media application standards e.g. BD DTCP CPRM Cable Card etc. . Typically such a media application standard includes a revocation mechanism whereby if a secret key value is made public the security functions of the compromised devices are revoked and the devices are rendered inoperable. As such it is highly desirable that the secret keys are stored in such a way that they are not accessible to the firmware of the device in order to avoid revocation . This is typically done by storing the secret keys in a one time programmable OTP memory.

While using OTP memory has become a primary mechanism for storing secret keys within media processing devices it is not a failsafe approach. For example a security issue arises when multiple cryptographic clients e.g. a hardware block that performs a specific cryptographic algorithm such as RSA TSD ECC DMA etc. may issue read or write requests to the OTP memory asynchronously and that the requests are not atomic. In addition as a result of granularity associated with OTP memory large key values are partitioned into smaller blocks which have special read write rules that are imposed on every block. Thus it becomes necessary to associate a macro level restriction on cryptographic clients down to every micro level block access performed by the client.

As a specific example the RSA algorithm can perform a 2048 bit RSA operation which requires 32 reads of 64 bit blocks from the key store to assemble the exponent. If a key is intended to be used as a 2048 bit exponent then every 64 bit block read must be associated with the intended purpose of the key i.e. blocks have to have an attribute indicating which cryptographic client is permitted to access a particular block associated with a larger key.

Another security problem is that cryptographic strength often relies on using large keys e.g. up to 2048 bits for RSA or 256 bits for some AES modes . However if the large key is used one 64 bit block at a time by a weaker cryptographic client then large keys may be attacked 64 bits or less at a time. Yet another way to attack large keys is to decimate a large key by overwriting portions of the key with 0 s and then perform the intended operations but with the remainder of the weakened key. Every time a portion of the key is decimated in this way the remainder can be determined because portions of the key are now known.

Still further some cryptographic clients have the ability to perform operations at various levels of strength for example the RSA algorithm can be configured for variable size modulus or 3DES can be degraded into a DES operation. This can be exploited by a hacker to perform weaker operations and thereby attack large keys with degraded operations. Even further some cryptographic clients use control words CWs and initial vectors IVs within the security operations. The integrity of a security system may be attacked by using an unknown CW as an IV in an operation where the clear text and the CW are known which could be used to reveal the unknown CW value.

Another important aspect of maintaining the integrity of cryptographic operations is controlling the destination of the cryptographic operation results. For example content exported from the SOC poses a far greater risk than content which is retained within the SOC. Yet another mode of attack involves using a key a CW or an IV to decrypt content instead of encrypting the content. For example the intention may be to encrypt content however a hacker may use a key store value to decrypt the content.

In addition to the threat of hackers the security of the secure content information is at risk from unauthorized public disclosure. For example if a disgruntled employee posts the algorithm and location of the keys on the Internet the security of the algorithm is lost. As such the risk to security systems is not just from outsider breaking the security of the algorithm but also from an insider intentionally compromising the integrity of the security system.

Therefore a need exists for a security device architecture that at least partially overcomes one or more of the above mentioned security issues.

The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor microcontroller digital signal processor microcomputer central processing unit CPU graphics processing unit GPU field programmable gate array FPGA programmable logic device state machine logic circuitry analog circuitry digital circuitry and or any device that manipulates signals analog and or digital based on hard coding of the circuitry and or executable instructions. The processing module may have an associated memory and or memory element such as the main memory which may be a single memory device a plurality of memory devices and or embedded circuitry of the processing module. Such a memory device may be a read only memory random access memory volatile memory non volatile memory static memory dynamic memory flash memory cache memory and or any device that stores digital information. Note that when the processing module implements one or more of its functions via a state machine analog circuitry digital circuitry and or logic circuitry the memory and or memory element storing the corresponding operational instructions may be embedded within or external to the circuitry comprising the state machine analog circuitry digital circuitry and or logic circuitry. Further note that the memory element stores and the processing module executes hard coded and or operational instructions corresponding to at least some of the steps and or functions illustrated in .

In an example of operation one or more of the IO interfaces and receives an instruction to display a media file e.g. a video file an audio file or a combination thereof . The media file may be from an optical disk stored in the hard disk and or flash memory received from a satellite receiver received from a cable set top box streamed wirelessly via a cellular data connection or via a wireless local area network WLAN and or any other source of content data. Note that the one or more of the JO interfaces and or may receive the media file. The media file is encrypted using a particular encryption program and one or more cryptographic keys as prescribed by one or more media standards.

In this example the processing module coordinates the retrieval of the media file from the main memory the hard disk and or flash memory the IO interface and or and or other source. The encrypted media file may include video data audio data video graphics data and or any other type of data requiring security. The processing module evokes a cryptographic client algorithm e.g. RSA DES etc. and retrieves a cryptographic key from a secure memory location e.g. a privileged memory . The secure memory location will be described below with reference to one or more of .

The processing module decrypts the encrypted data using the cryptographic client algorithm and the cryptographic key to produce decrypted data. The decrypted data is provided the graphics processing module . The graphics processing module may be a graphics card a graphics engine a graphics processor a combination thereof and or any other device for rendering video data. In this example the graphics processing module converts the decrypted data into video data and stores it in the graphics memory for subsequent display.

The media processing device has three classes of memory access. The most secure class allows access to the system memory e.g. main memory and or the hard disk and or flash memory and to IO devices via the IO interfaces and allows access to the graphics memory e.g. frame buffer and allows access to the secure memory location. The next level of secure access allows access to the system memory and to IO devices via the IO interfaces and . The third access level allows access to system memory.

The privileged memory section may be implemented using one or more one time programmable OTP memories random access memory RAM and or read only memory ROM . The OTP memory may be used to store a default set of the cryptographic keys and a rule set section . The key store section stores one or more cryptographic keys for one or more of the cryptographic clients in an OTP memory RAM and or ROM. The key store section may include memory blocks where one or more blocks store a cryptographic key. The rule set section stores rules for accessing the key store section . The various rules will be described in greater detail with reference to at least some of .

The device of also includes an arbitration module which may be part of the operation system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the key store section based on the rule sets in the rule set section . In this manner access requests must come from authorized firmware components e.g. real cryptographic clients and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

With such an embodiment the security of a hardware system and the flexibility of a software system are substantially achieved. For instance by utilizing a single OTP to store permanent rules for accessing the keys the vulnerability of a software system is substantially avoided and the inflexibility of a hardware system which uses hard wired single function for a single standard is also substantially avoided.

If however at step the request is determined to be valid the method continues at step where the arbitration module interprets the request for access to the cryptographic key to produce an interpreted request. This will be described in greater detail with reference to . The method continues at step where the arbitration module accesses the rule set section based on the interpreted request to retrieve a rule of the set of rules. An example of a rule will be described with reference to .

The method continues at step where the arbitration module grants access to the cryptographic key in accordance with the rule. Note that the rule set may indicate that the access is not to be granted as such in accordance with the rule includes denying the request ignoring the request or providing random data. The method continues at step where when access to the cryptographic key is granted the cryptographic client executes a cryptographic function regarding at least a portion of the cryptographic key to produce a cryptographic result.

The source section indicates an initiator of the cryptographic result and the destination section indicates where the cryptographic result will be sent. The valid sources and destinations include the system main memory e.g. as a frame buffer FB the key store section the IO registers and or the graphics memory. The cryptographic algorithm being used may be identified as ANY NONE AES DES 3DES Multi 2 DVB C2 CSS MDMI HDCP 1394 M6 RSA ECC and or Register.

In an embodiment an adjacency rule may be used. For instance when a particular client initiates an encryption operation the corresponding rule in the rule set section determines what key blocks in the key store section can be accessed. By the improvement a further bit is included in the rule whereby when the rule is implemented it determines the order in which the key store blocks may be accessed. More restrictively a particular sequence of blocks is prescribed. Less restrictively groups of key store blocks are accessed in a prescribed order.

In this embodiment a rule is a group of bits e.g. 16 which dictates how a corresponding block e.g. 64 bits in the key store may be accessed. By default since all bits in the OTP default to 0 the blocks that have un initialized rules provide unlimited access i.e. no restrictions . The rule set section thus contains bit masks associated to key store blocks. The bit mapping for rules is as follows 

With respect to an adjacency rule it provides certain cryptographic clients the ability to write the result of a cryptographic operation back into the key store . This is may be useful in cases where the security system makes use of key ladders e.g. a structure where a key is used to decrypt an encrypted key the resulting decrypted key may then be used in a subsequent key ladder step or it may be used to decrypt content and where the key is used to decrypt content is itself the end product of several cryptographic operations. In this context the adjacent rule is used to enforce a particular order to be adhered to when deriving the key i.e. the 1st key must be adjacent to step which must be adjacent to step etc. . . . where the last step of the ladder culminates with the key intended to decrypt content. Note that the adjacent rule field may contain more than 1 bit to indicate a range of adjacent locations e.g. 5 bits to provide 32 adjacent locations . For example instead of the result or an operation being permitted to be written to just the next i.e. adjacent location the rule has extra bits allocated that define the permission to write the result to the next N blocks i.e. a plurality of adjacent locations . This adds flexibility when dealing with a multi stream system where multiple end keys are calculated using the same ladder.

If the request is valid the method continues at step where the arbitration module provides at least a portion of the cryptographic key to the cryptographic client. For example the key may be stored in multiple blocks of the key store section and the arbitration module provides some or all of the blocks the cryptographic client in response to one request. The method continues at step where the cryptographic client executes the cryptographic algorithm utilizing the at least a portion of the cryptographic key on content data to produce encrypted data or decrypted data. Note that in an embodiment even though a cryptographic client may make multiple requests and get portions of the key it typically will use the entire key for a cryptographic operation.

If however the request is valid the method continues at step where the arbitration module provides access to a block in the key store section for the at least a portion of the cryptographic key for the cryptographic client. The method continues at step where the cryptographic client executes the cryptographic function to write the at least a portion of the cryptographic key into the block of the key store section .

The method branches at step depending on whether the type of cryptographic algorithm is in a class type of a plurality of class types. If not the method continues at step where the request is denied. If however the type is in a class the method continues at step where the arbitration module establishes a bit boundary corresponding to the class type for accessing the cryptographic key. For example If Algorithm ANY DES DVB C2 CSS M6 Multi 2 HDCP Register then the Key Store may be accessed on a 64 bit boundary If Algorithm AES 3DES ECC then the Key Store may be accessed on a 128 bit boundary If Algorithm RSA then the Key Store may be accessed on a 1024 bit boundary and If Algorithm NONE then the Key store may be not be accessed on any boundary.

The OTP register interface corresponds to a set of registers which permit reading or writing of 64 bits at a time into a specific OTP block. For every block there are 2 bits of associated OTP memory i.e. the Read Lock Out Bits . . . and the Write Lock Out Bits . . . . These bits default to 0 factory default and may be programmed one time to 1. Once the bit is set to 1 it may never be re programmed to a 0. When the corresponding read lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be read via the OTP register interface . When the corresponding write lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be written via the OTP register interface .

This is a fundamental interlock required to secure secret values into the hardware device. There are a few scenarios 

Note that even if an OTP block s read write lock out bits are set the block may still be used by a cryptographic client within the hardware device i.e. H W blocks may use the key values to perform a cryptographic operation but the value itself may never be exposed .

During the initial writing the cryptographic key to the key store memory at step from the OTP memory the copy may utilize an obfuscation function. For example blocks of 64 bits i.e. Block j which are to be written to the OTP memory i.e. OTP i are obfuscated using a function comprising symmetric binary operators OP n and a re mapping function i.e. j i j . The obfuscation function h may be defined as follows Block EQ. 1

The corresponding de obfuscation function h implemented between the OTP and the key store section uses the following obfuscation function. KeyStore EQ. 2 Note that h is a j op j i mapping and h 1 is a i op j j mapping which means that the bit ordering in the Block and the HKB are different i.e. if a hacker had access to the Block value and the HKB value then the bit ordering would not correspond.

An obfuscation key block may be a 64 bit pattern written into one or more blocks of the OTP. The obfuscation key block may default to 0x0 . . . 0 and may be programmed uniquely per device or uniquely per customer or uniquely per product model or may default to 0x0 . . . 0. In addition the obfuscation key block should have a similar number of 0 s as 1 s 10 i.e. a non trivial value to ensure secure obfuscation.

The obfuscation functions may be used to secure the key store loading stage of secure key deployment. It allows for a secure way to embed keys in to the OTP memory . This provides an important operational security mechanism which secures cryptographic values within the OTP and provides some security in the factory environment.

The privileged memory section which may be implemented using one or more one time programmable memories such as the OTP memory includes a privileged data section e.g. one embodiment of the key store section and a rule set section e.g. one embodiment of the rule set section . The privileged data section stores data that is of a privileged nature and should not be accessible to a user of the device or to a hacker. Such data includes one or more cryptographic keys for one or more of the cryptographic clients other device security features etc. The privileged data section may include memory blocks where one or more blocks store a privileged data element. The rule set section stores rules for accessing the privileged data section .

The device of also includes the arbitration module which may be part of the operating system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the privileged data section based on the rule set of the rule set section . In this manner access requests must come from authorized firmware components e.g. real cryptographic clients operating system firmware functions other device security functions etc. and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

The method continues at step where the arbitration module determines whether the request is valid. This may be done by accessing the rule set based on the requestor and the type of request e.g. read privileged data and or to write privileged data . In addition the arbitration module may verify the format of the request to insure that includes a read write indication an address of the at least a portion of the privileged data and an indication regarding use of the privileged data. If any of these checks fail the request is invalid and the method proceeds to step via step where the request fails. If however the request is valid the method continues at step where the arbitration module interprets the request to produce an interpreted request. The interpretation will be described in greater detail with reference to . The method continues at step where the arbitration module grants access to the at least a portion of the privileged data in accordance with the rule.

A further embodiment may include an additional multi bit field for encrypt decrypt that specifies whether a cryptographic client is required to perform an encrypt or decrypt operation e.g. ANY 00 Encrypt 10 Decrypt 01 NONE 11 . A least constraining state is the 00 un programmed state and a most constraining state is 11 None . Another embodiment may include increasing the size of the read and write algorithm field from 4 bits to 6 bits to specify 64 different algorithms which allows for many more algorithms to be added.

In another embodiment a skip function may be used to reduce the number of one time programming OTP steps required to populate a key store section by loading one root key into the key store section and then having the keys for other sections of the key ladder calculated from the root rather than having them all loaded during successive steps of the OTP process. In this way certain OTP steps are obviated.

In yet another embodiment a repeat function may be used to avoid redundancy. For instance the OTP block includes an indicator stored with certain of the rules in the rule set section to indicate whether that rule is to be repeated to load it in other locations in the key store ladder. Once again this obviates the requirement of having an OTP step for every location in the key store ladder.

In a further embodiment an Encrypt Decrypt rule may be used. In particular a pair of bits are added to each rule which signify that the client can encrypt and decrypt 00 that the client can do one of encrypt and decrypt 1 0 and 0 1 and that the client can copy but not encrypt or decrypt the result to another location in the key store section.

In an additional embodiment the adjacency constraint can be expanded to define additional types such as CW Key IV Data Any None or other types.

In yet a further embodiment the type constraint can be expanded to define a range of adjacency not just the immediate next.

In the example shown an application utility or other software supplies encrypted key and encrypted codeword that are decrypted in the key ladder based on private exponent to generate codeword . The codeword is used in this example to descramble an encrypted audio video A V data such as from a transport stream de multiplexor TSD in digital video broadcast module to generate audio video data that can be written to a frame buffer memory.

In operation key store memory stores cryptographic keys of the key ladder. This can include prestored keys such as private exponent used by RSA module to extract key from encrypted key . In addition key store memory such as key store section can store key and codeword generated in AES module by decrypting encrypted codeword based on key . Rule set memory such as rule set section stores a set of rules for accessing the cryptographic keys of key store memory used in conjunction with the key ladder. Key store arbitration module such as arbitration module operates based on the rules in rules set memory to control access to key store memory . In particular arbitration module allows reading and writing the keys stored in key store memory only in accordance with the set of rules. Examples of such rules are set forth in conjunction with and otherwise while specific examples are presented below.

In a particular embodiment there is a different set of rules constraints for each of the three portions of the key store memory which dictate how values in that portion may be used. The definition of the ladder is based on rules which are hard coded into one time programmable OTP memory such as OTP memories and rather than being hard wired into a chip. These constraints enforce the specific sequence of operations which is equivalent to the security provided by a hard wired key ladder.

For instance private exponent portion of key store memory has constraints which enforce the value to be loaded from OTP memory Write Rule OTP the value may only be used by the RSA module Read Rule RSA the value may only be used as a Key Type Key the RSA operation must read a value E Key from the frame buffer Source FB and the result of the RSA calculation Key E Key must be written to the key store memory dest KS the RSA operation is a decryption operation i.e. E D D the location of key must be adjacent to the location of private exponent adjacent 1 .

Similarly the key portion of key store memory has constraints which enforce the value to be the result of an operation of RSA module Write Rule RSA the value may only be used by the AES module Read Rule AES the value may only be used as a key Type Key the AES operation must read a value E CW from the frame buffer Source FB and the result of the AES calculation i.e. CW AES E CW Key must be written to the key store memory dest KS the AES operation must be a Decryption i.e. E D D the location of codeword must be adjacent to the location of key adjacent 1 .

In addition the codeword portion of the key store memory has constraints which enforce the value to be the result of an operation of AES module Write Rule AES the value may only be used by the DVB module Read Rule DVB the value may only be used as a Key Type Key the DVB operation must decrypt content received from an device i.e. source I O and the resulting decrypted content must be written to the frame buffer dest FB the DVB operation must be a decryption operation i.e. E D D and the CW may not be used to derive any further key store locations adjacent NONE .

The rules can also have fields which allow for de compression of rule set and key values when loading the rule set memory and key store memory . These constraints are referred to as the SKIP and REPEAT fields and generally permit 1 N mapping of OTP memory storage to key store memory and rule set memory . This allows for more optimum use of OTP memory . Examples of such fields are presented below 

As previously discussed device includes OTP memory for storing the prestored key or keys and the set of rules. Load module controls the loading of key store memory with the prestored key or keys and the rule set memory with the set of rules. In an embodiment of the present disclosure the set of rules includes a signature rule that defines at signature corresponding to at least one of the set of rules and the at least one cryptographic key. The validation module validates based on the signature the loading of the prestored keys in the key store memory and or the loading of the rule set memory . Further details regarding this aspect of the present disclosure will be discussed in conjunction with that follow.

While shown in conjunction with descrambling of broadcast A V data the key ladder shown could likewise be used for encrypting or decrypting other media data multimedia data or other data to be protected. In particular nearly all CA and DRM systems may be expressed as a key ladder i.e. they may have more or less stages and or may use different specific algorithms . The reason for this is that such security systems are based on a root of trust philosophy where trust is propagated though various stages from most trusted to less trusted. A key ladder is a natural extension of standard cryptographic philosophy. There are proprietary systems which operate with Smart Cards or Cable Cards and use secret algorithms and undocumented protocols and are usually associated with set top boxes distributed by Broadcasters where the CA system is used to control access to only valid customers. On the other hand DRM systems are generally based on published standards like AACS DTCP CPRM etc. These systems use standard published algorithms and licensed device keys and are usually associated with consumer electronics devices like players or networked devices which are distributed as retail devices. One thing CA and DRM systems have in common is that they can both be expressed as a key ladder i.e. they have a root key usually stored in Non Volatile Memory which is used to cryptographically qualify derived intermediate keys which are then used to qualify final keys which are used to de scramble A V content.

An obvious point of attack is the storage of rules and keys. Procedures are put in place to protect against hackers modifying or adding rules or keys. During the loading process load module reads the OTP memory and determines the number of rules M extracts the signature from the signature rule and then copies the rule set into the rule set memory . Along with the rules the load module will also determine the number of prestored keys N and load the prestored keys into the key store memory . When complete the load module will report the number of rules M and keys N which have been loaded to software . After the loading is complete the validation module will receive the signature value from the load module and perform a hardware hash check. For example the load module can evaluate the signature of the key store memory and the rule set memory and compare it against the signature embedded within the signature rule. If the two signatures do not match the validation module can take action to disable access to the keys and the rule set e.g. erase the key store memory and the rule set memory .

If the keys and rule set are validated the validation module will also make the signature value available to a software function to perform a software hash check. The software function can be a separate utility or embedded in the operating system an application or in other software. Software can be implemented as a process on a single SOC that includes the other components presented in conjunction with or can run on another device. Software reads the signature calculated by the load module the number of rules M and number of keys N and uses this information to construct a message digest and perform a asymmetric signature of the contents of the key store memory and rule set memory . For example an RSA based signature check may be defined as Digest Hash value rules keys Signature Digest

This mechanism allows a trusted authority to define correct signature and number of rules and keys have been processed i.e. to prevent hackers from altering or adding rules or keys . If this second signature check fails then the software takes action to disable the system. Note there are various possible hash functions and various possible asymmetrical functions which may be used.

The device architecture of the present disclosure also provides the option to implement multiple CA and DRM systems on the same system on a chip SOC . This is an important distinction where a customer could field a system containing a single SOC which is provisioned with keys and key ladders which implement more than one CA or DRM system. This provides the customer with a remarkable economy and flexibility since the CA DRM systems can share resources and co exist at the same time.

It is common in the CA industry to have breaches of security. The typical response in this situation in prior art removable CA systems is to distribute new smart cards or cable cards to customers. These removable CA systems typically implement a new key ladder or contain new keys. In the system of the present disclosure an End of Rules rule can be implemented that defines un programmed space in the rule and key areas of the OTP memory . In the case of a security breach it is feasible to download new rules and new keys to update the OTP memory of previously fielded SOC chips in effect downloading a new CA or DRM system to previously fielded systems. This provides the customer with a remarkable economy and flexibility since the CA DRM systems can be renewed without a large expense. The Renewed CA or DRM system may be downloaded to fielded products via various communication channels for example Cable Satellite Terrestrial RF links the Internet or via media such as DVD s and BD disks .

It is also common to selectively disable fielded products usually because they have been identified as being used by hackers this is referred to as revocation. Since the architecture of the present disclosure is based on the contents of OTP memory and these contents can be used to record unique chip ID s. It is possible to identify and disable individual SOC devices. The hard coded key ladder approach provides new methods for revoking devices i.e. 

In effect since the architecture of the present disclosure support renewability this creates new and flexible methods for revoking SOC s.

In step the number of rules in the set of rules is determined along with the number of cryptographic keys. The first signature and the number of rules in the set of rules stored in the rule set memory and the number of cryptographic keys stored in the key store memory are passed for further validation such as a second security check.

In an embodiment of the present disclosure step includes determining a second signature based on the set of rules stored in the rule set memory and the at least one cryptographic key stored in the key store memory comparing the first signature to the second signature and determining the failed validation when the second signature does not match the first signature.

As described above in some embodiments the key usage in a key store memory can be enforced through rules programmed in an OTP memory during the chip device provisioning stage. In such instances once the OTP memory is programmed the key storage usage is fixed or static through the entire life of the device. However in many implementations the application use cases of key values and other privileged data may change curing the device life cycle. Such changes may not be foreseeable during device design and manufacture. Accordingly one approach is to provision a large number of key store blocks in the OTP memory to accommodate as many use cases as possible. However in most applications the many of these key store blocks will not be used thereby leading to an unnecessarily large key store space. illustrate a dynamic partitioning scheme to address this problem. For this scheme the key store memory and rule set memory are implemented at least in part by one or more random access memories such as SRAM memories. The key store memory is divided into two segments a static key segment SKS and a dynamic key segment DKS . Likewise the rule set memory is divided into two segments a static rule segment SRS and a dynamic rule segment DRS . The SRS is used to store static rules from the OTP memory and the SKS is used to store the keys covered by these static rules. However it should be noted that while the rules in the SRS are static that is cannot be changed the keys in the corresponding SKS may not be static and instead may be created or modified during device operation. Thus the term static in static key segment alludes to the fact that access to the keys of the SKS is controlled by the static rules of the SRS rather than implying that the keys themselves are static. In contrast the DRS is used to store rules that may be dynamically created and or dynamically changed and the DKS is used to store keys whose access is controlled by the dynamic rules in the DRS. In either instance the keys of the SKS and the DKS may be received from a register interface received from a cipher engine output e.g. as part of a key ladder operation obtained from the OTP memory for the SKS only and the like.

To illustrate for a key store memory of 512 blocks total if the rule set from the OTP memory covers 100 blocks the SKS will be sized to 100 blocks and the remaining 412 blocks will be used for the DKS. This approach permits the device to accommodate future expansion of key usage without having to provision an OTP memory sized large enough to permit a worst case scenario and thus incur unused space in OTP memory in many applications. Further illustrate example techniques for ensuring or verifying the integrity of these segmented key store and rule set spaces using obfuscation and cyclical redundancy check CRC calculations as described in greater detail below.

The device of also includes an arbitration module one embodiment of the arbitration module an integrity module and a loader module each of which may be part of the operating system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . As similarly described above with reference to the arbitration module the arbitration module coordinates access to the key store memory based on the rules in the rule set memory such that access requests must come from authorized firmware components e.g. real cryptographic clients and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails the arbitration module will deny the request ignore the request or provide random data in response to the request.

The loader module operates during the boot process of the device to copy the keys of the keys in the OTP memory to a static key segment of the key store memory and to copy the rules of the static rule set to a static rule segment of the rule set memory . The loader module further operates to load dynamically generated keys and corresponding rules to the dynamic key segment and the dynamic rule segment of the key store memory and rule set memory respectively. The operation of the loader module is described in greater detail with reference to .

The integrity module operates to ensure the integrity of the key store memory and rule set memory . In some embodiments the integrity module utilizes obfuscation techniques to obfuscate the data stored in one or both of the key store memory and rule set memory so as to prevent access to the secrets contained therein in the event that a hacker is able to obtain access to the key store memory or the rule set memory . Further in some embodiments the integrity module utilizes CRC calculations and comparisons to verify the integrity of one or both of the key store memory and the rule set memory to ensure that data contained therein has not been corrupted or otherwise modified without authorization. The operation of the integrity module is described in greater detail with reference to .

At the conclusion of this initialization process the loader module has provisioned the SRS of the rule set memory to statically store the rule set and provisioned the SKS of the key store memory to store the keys governed by the static rules of the SRS . As such at block of the method the loader module may provision the remaining blocks of the key store memory starting at the key store watermark as a dynamic key segment DKS for storing cryptographic keys dynamically generated by hardware for temporary use during operation of the device after boot up and at step the loader module may provision the remaining blocks of the rule set memory stating at the rule set watermark as a dynamic rule segment DRS for storing rules for accessing the corresponding dynamic keys of the DKS .

Under this segmentation method the device can accommodate the storage of dynamic keys that is keys not intended to persist between power on cycles of the device solely in RAM as opposed to convention implementations whereby the OTP memory is used to store dynamic keys and thus requiring an excessively large OTP memory in order to accommodate foreseeable dynamic key usage over the life cycle of the device.

To illustrate assuming a key block is 64 bits if a rule for a key in the key store memory specifies a 128 bit key a read or write request for any of the blocks associated with this key must be aligned to an even number that is the initial block addressed or indexed by the request must be an even number . As another example assuming again a key block size of 64 bits if a rule for a key in the key store memory specifies a 256 bit key that is 64 bits 4 a read or write request for any of the blocks associated with this key must be equal to 4 n where n 0 1 2 Similarly for a key associated with a 1024 bit key that is 64 bits 16 a read or write request to any blocks associated with this key must have an index or initial address equal to 16 n where n 0 1 2 . . . .

With this alignment requirement enforced a newly loaded key will not straddle two existing keys in the key store and a newly loaded longer key can replace two or more shorter keys. Moreover a short key can be loaded into one or more blocks of an existing longer key but this will not permit decimation of the existing longer key as a different rule will also be generated for the replaced blocks. Thus the modified longer key will be useless to a hacker as different key blocks along the whole key length will have different algorithms or rules and the rule checking performed during the retrieval of the modified longer key will fail due to the different rules being present for the same key.

Returning to step if the arbitration module determines that the request is not valid the method continues at step where the request fails silently e.g. no response is given the request is ignored false information is provided or an error status is provided. If however the request is valid the method continues at step where the arbitration module provides access to the necessary one or more blocks of the DKS of the key store memory and the component requesting the storage of the dynamically generated key executes the cryptographic function to write the dynamically generated key into the one or more blocks of the DKS .

At the same time that the key is stored to the DKS at step the device stores the appropriate rule for the key in the corresponding set of one or more blocks of the DRS of the rule set memory . In some embodiments the rule is supplied by a component via an interface such as the registers of the IO interfaces and . In such instances the supplied rule is received and then stored to the DRS . In other embodiments usage information for the key is supplied by a component and the hardware of the device then generates a rule based on this usage information and the generated rule is then stored to the DRS . In further embodiments the key is generated as part of a key ladder operation and usage information for the key e.g. the particular cryptographic algorithm to be used may be based on a static rule from the OTP involved in the key ladder operation

To illustrate a cryptograph client using an AES cryptographic operation generates a 128 bit AES key and stores the key to a register interface . Concurrently the cryptographic client stores an algorithm ALG indicator representing the 128 bit AES algorithm to a register interface . Further the cryptographic client specifies block as the starting key store index for storing the key into a register interface not shown in this example and then triggers the write operation. Upon verifying the write operation including performing an alignment check the arbitration module accesses the ALG indicator from the register interface and generates a rule for the key based on the algorithm indicated by the ALG indicator . In this example the rule would have the following attributes referring to Table 1 above Write Algorithm ANY Read Algorithm AES Type CW Source Destination FB E D ANY the remaining rule fields are not relevant in this example . The arbitration module stores the key to blocks and the blocks are 64 bits in this example in the DKS and concurrently stores the generated rule to the blocks of the DRS that correspond to blocks and of the DKS .

The example of illustrates a loading of a dynamically generated key as a key ladder element key that is part of a key ladder operation. In at least one embodiment a key ladder element key is identified as such by the Destination field of the corresponding rule. The destination field is KS SRS or KS DRS the key is identified as a key ladder element key. In such instances the adjacency field is redefined thusly when the destination field has the value KS SRS the corresponding key is defined to be an up layer key ladder element key which means that it is not the key for generating content keys for storage in the DKS . In this case the adjacency will be the actual allowable destination key store location offset from the element key block. Conversely when the destination field has the value KS DRS the corresponding key is defined to be the last key ladder element key which will be used to generate the content keys. In such instances the value of the adjacency field will be the read algorithm to be used by the generated content keys as specified by the corresponding rule accessed from the static rule segment . As such the arbitration module will enforce that the output content keys can only be routed into the DKS and no adjacency will be used.

During the last or final key ladder element operation for generating a content key cipher hardware will receive key ladder input along with the last key ladder codeword from the SKS and an indication of the algorithm ALG used in the last key ladder element operation. The key ladder input may comprise algorithm bits ALG obtained from the static rule used for the key ladder operation as specified by the adjacency field and which indicate the particular cryptographic algorithm for generated content key. The cipher hardware uses the codeword and the key ladder input to generate a content key which is supplied to the arbitration module along with a key store block index and the algorithm bits ALG for storage at one or more blocks of the DKS . Concurrently the arbitration module generates a rule for accessing the content key based on the algorithm bits ALG provided by the cipher hardware and the key ladder input and stores the generated rule at the corresponding block s of the DRS . In this case the rule would have the following attributes referring to Table 1 above Write Algorithm ANY Read Algorithm ALG that is ALG from cipher hardware Type CW Source Destination FB E D ANY the remaining rule fields are not relevant in this example .

The example of illustrates a loading of a dynamically generated key from a hardware cryptographic component such as the identified certified IP component . In this example the component generates a content key and provides the content key to the arbitration module via a corresponding interface not shown along with usage bits that indicate the manner in which the content key is to be used. In one embodiment the usage bits include data indicating the algorithm whether the content key is to be used for encryption decryption or both and the length of the key which may instead be indicated or inferred from the algorithm . In this case after verifying the write access request including alignment check the arbitration module stores the content key at the DKS starting at a specified key block index. Concurrently the arbitration module uses the usage bits to generate a rule for accessing the content key and stores the generated rule to the corresponding blocks of the DRS . Typically the arbitration module generates the rule through translation of the usage bits into the corresponding fields of the rule e.g. as shown in Table 1 above .

While the segmentation of the key store memory and the rule set memory into static and dynamic segments permits adaptation to dynamic rule generation and key generation modification without requiring excessive OTP storage provisioning the ability to dynamically store and modify keys and rules in non volatile memory introduces potential vulnerabilities. To illustrate attackers may attempt to directly retrieve the privileged information along the path where it is used or transferred or attempt to change the corresponding rules to allow otherwise prohibited usage so that the security of the key store can be compromised. describe various mechanisms for the segmented key store and rule set to ensure the secrecy of the privileged information and the integrity of the rules protecting access to the privileged information.

Subsequently at step the device initiates a boot process from reset or power on. In response at step the integrity module seeds an obfuscation function with a value that is specific to that particular iteration of the boot process. To illustrate the integrity module may use a randomly generated or pseudo randomly generated value as a seed value for the obfuscation function. At step the loader module accesses the keys and rule set so as to transfer copies to the SKS and SRS respectively implemented in non volatile memory of the device . However prior to storing the copies at step the integrity module de obfuscates the obfuscated versions of these values stored in the OTP memory using a reverse obfuscation algorithm that corresponds to the obfuscation algorithm used at step e.g. the reverse obfuscation process represented by EQ. 2 above . At step the integrity module re obfuscates the keys using the obfuscation function seeded at block to generate obfuscated versions of the keys for loading into the SKS . Similarly the rule set can be re obfuscated using the seeded obfuscation function and the resulting obfuscated version of the rule set can be stored to the SRS .

The process described protects the secrets represented by the keys and the rule set by de obfuscating and re obfuscating the keys and rule set in a manner particular to each power cycle. In this manner the scrambled data stored in the SKS and the SRS differs for each time the device is reset which in turn reduces the likelihood that an attacker can successfully break the obfuscation process and gain access to the unscrambled version of the keys or the rule set .

As described above an attacker may attempt to derive a key either through decimation whereby the entropy of a key is reduced by overwriting a portion of the key with a known value or through unauthorized modification of the rule so as to give the attacker authorized access to the entire key. illustrate example mechanisms for detecting such modifications through the use of cyclical redundancy check CRC values.

After these values have been transferred at step the integrity module accesses the CRC value from the OTP memory and at step the integrity module calculates a second CRC value based on one or both of the keys and the rule set depending on which values were used to calculate the CRC value in the method of . If there has been no modification or corruption of the values during the copying from the OTP memory to the key store rule set memories the CRC value and the second CRC value should be exact matches. Accordingly at step the integrity module compares the CRC value with the CRC value calculated at step . If there is a match the integrity of the secrets of the OTP memory have been maintained during the boot process and thus the device is ready to enter an operational mode with the key store memory at step .

Otherwise if the comparison at step reveals a mismatch then one or both of the keys or the rule set has been corrupted or compromised. In such instances at step the arbitration module presents further access to the key store memory and the rule set memory such as by wiping out at least the key store memory e.g. by overwriting the entire key store memory with all 1 s or all 0 s setting a configuration parameter that prevents addressing of any block of the key store memory under any condition and the like. In this manner if an attacker is able to corrupt the transfer process so as to reconfigure a static rule or decimate a static key this corruption is detected through the CRC value mismatch and any further use of the corrupted secret or corrupted rule is prevented.

At step the integrity module determines whether the CRC calculation trigger detected at step is a read access trigger or timeout trigger. If not the method returns to step to await the next detected CRC calculation. However if the CRC calculation trigger is a read access trigger or timeout trigger at step the CRC value calculated at step is compared with the CRC value calculated at a previous iteration of the method of . That is the CRC value calculated at step serves as the reference CRC value for the next iteration of the method of . Note that as represented by step if the CRC calculation trigger was a write access a CRC value is calculated for the rule set memory after the write has completed and this CRC value then serves as the reference CRC for the next iteration of the method. The CRC value calculated in response to a read access trigger or timeout trigger should match the reference CRC. If there is a match the method returns to step to await the next detected CRC calculation trigger for another iteration of the method. If there is a mismatch then one or both of the key store memory or the rule set memory have been compromised or corrupted and thus at step the arbitration module prevents further access to the key store memory and the rule set memory such as by overwriting them with all 1 s all 0 s or random data or by applying a configuration that prevents addressing any of the blocks of the memories and .

As may be used herein the terms substantially and approximately provides an industry accepted tolerance for its corresponding term and or relativity between items. Such an industry accepted tolerance ranges from less than one percent to fifty percent and corresponds to but is not limited to component values integrated circuit process variations temperature variations rise and fall times and or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein the term s coupled to and or coupling includes direct coupling between items and or indirect coupling between items via an intervening item e.g. an item includes but is not limited to a component an element a circuit and or a module where for indirect coupling the intervening item does not modify the information of a signal but may adjust its current level voltage level and or power level. As may further be used herein inferred coupling i.e. where one element is coupled to another element by inference includes direct and indirect coupling between two items in the same manner as coupled to . As may even further be used herein the term operable to indicates that an item includes one or more of power connections input s output s etc. to perform when activated one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein the term associated with includes direct and or indirect coupling of separate items and or one item being embedded within another item. As may be used herein the term compares favorably indicates that a comparison between two or more items signals etc. provides a desired relationship. For example when the desired relationship is that signal has a greater magnitude than signal a favorable comparison may be achieved when the magnitude of signal is greater than that of signal or when the magnitude of signal is less than that of signal .

The present disclosure has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope of the claimed invention.

The present disclosure has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope of the claimed invention. One of average skill in the art will also recognize that the functional building blocks and other illustrative blocks modules and components herein can be implemented as illustrated or by discrete components application specific integrated circuits processors executing appropriate software and the like or any combination thereof. In some embodiments certain aspects of the techniques described above may implemented by one or more processors of a processing system executing software. The software comprises one or more sets of executable instructions stored or otherwise tangibly embodied on a non transitory computer readable storage medium. The software can include the instructions and certain data that when executed by the one or more processors manipulate the one or more processors to perform one or more aspects of the techniques described above. The non transitory computer readable storage medium can include for example a magnetic or optical disk storage device solid state storage devices such as Flash memory a cache random access memory RAM or other non volatile memory device or devices and the like. The executable instructions stored on the non transitory computer readable storage medium may be in source code assembly language code object code or other instruction format that is interpreted or otherwise executable by one or more processors.

A computer readable storage medium may include any tangible non transitory storage medium or combination of tangible non transitory storage media accessible by a computer system during use to provide instructions and or data to the computer system. Such storage media can include but is not limited to optical media e.g. compact disc CD digital versatile disc DVD Blu Ray disc magnetic media e.g. floppy disc magnetic tape or magnetic hard drive volatile memory e.g. random access memory RAM or cache non volatile memory e.g. read only memory ROM or Flash memory or microelectromechanical systems MEMS based storage media. The computer readable storage medium may be embedded in the computing system e.g. system RAM or ROM fixedly attached to the computing system e.g. a magnetic hard drive or removably attached to the computing system e.g. an optical disc or Universal Serial Bus USB based Flash memory .

Note that not all of the activities or elements described above in the general description are required that a portion of a specific activity or device may not be required and that one or more further activities may be performed or elements included in addition to those described. Still further the order in which activities are listed are not necessarily the order in which they are performed. Also the concepts have been described with reference to specific embodiments. However one of ordinary skill in the art appreciates that various modifications and changes can be made without departing from the scope of the present disclosure as set forth in the claims below. Accordingly the specification and figures are to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope of the present disclosure.

Benefits other advantages and solutions to problems have been described above with regard to specific embodiments. However the benefits advantages solutions to problems and any feature s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as a critical required or essential feature of any or all the claims. Moreover the particular embodiments disclosed above are illustrative only as the disclosed subject matter may be modified and practiced in different but equivalent manners apparent to those skilled in the art having the benefit of the teachings herein. No limitations are intended to the details of construction or design herein shown other than as described in the claims below. It is therefore evident that the particular embodiments disclosed above may be altered or modified and all such variations are considered within the scope of the disclosed subject matter. Accordingly the protection sought herein is as set forth in the claims below.

