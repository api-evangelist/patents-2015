---

title: Framework for finding one or more solutions to a problem
abstract: In an embodiment, information for use in identifying a plurality of sub-solvers may be acquired. The plurality of sub-solvers may be used in a first attempt to find at least one solution to a problem that may be defined in the acquired information. At least two of the sub-solvers in the plurality of sub-solvers may be of different sub-solver types. The sub-solvers may be identified based on the acquired information. One or more starting points for the identified sub-solvers may be identified and transferred to the identified sub-solvers. One or more outputs, that indicate one or more results associated with the first attempt to find at least one solution to the problem, may be acquired from the identified sub-solvers. One or more sub-solvers may be identified, based on the acquired one or more outputs, for use in a second attempt to find at least one solution to the problem.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514413&OS=09514413&RS=09514413
owner: The MathWorks, Inc.
number: 09514413
owner_city: Natick
owner_country: US
publication_date: 20150501
---
This application is a continuation of U.S. patent application Ser. No. 12 896 493 filed on Oct. 1 2010 which claims priority to U.S. Provisional Patent Application No. 61 266 818 filed on Dec. 4 2009.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate one or more embodiments described herein and together with the description explain these embodiments. In the drawings 

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar features illustrated in the drawings.

One or more embodiments of the invention may be implemented on one or more computing devices. The one or more computing devices may be a system or part of a system. The one or more computing devices may include for example a desktop computer laptop computer client computer server computer mainframe computer personal digital assistant PDA netbook computer tablet computer web enabled cellular telephone smart phone or some other computing device.

The I O bus may be an interconnect bus that may enable communication between various components in the computing device such as processing logic secondary storage input device output device and communication interface . The communication may include among other things transferring information e.g. data control information executable instructions between the components.

The memory bus may be an interconnect bus that may enable information to be transferred between the processing logic and the primary storage . The information may include instructions and or data that may be executed manipulated and or otherwise processed by processing logic . The instructions and or data may include instructions and or data that may implement one or more embodiments of the invention.

The processing logic may include logic that may interpret execute and or otherwise process information contained in for example the primary storage and or secondary storage . The information may include computer executable instructions and or data that may implement one or more embodiments of the invention. The processing logic may comprise a variety of heterogeneous hardware. The hardware may include for example some combination of one or more processors microprocessors field programmable gate arrays FPGAs application specific instruction set processors ASIPs application specific integrated circuits ASICs complex programmable logic devices CPLDs graphics processing units GPUs or other types of processing logic that may interpret execute manipulate and or otherwise process the information. The processing logic may comprise a single core or multiple cores. Moreover processing logic may comprise a system on chip SoC or system in package SiP . An example of a processor that may be used to implement processing logic is the Intel Xeon processor available from Intel Corporation Santa Clara Calif.

The secondary storage may be a non transient tangible computer readable media that is accessible to the processing logic via I O bus . The secondary storage may store information for the processing logic . The information may be executed interpreted manipulated and or otherwise processed by the processing logic . The secondary storage may comprise for example a storage device such as a magnetic disk optical disk random access memory RAM disk and or flash drive. The information may be stored on one or more non transient tangible computer readable media contained in the storage device. The media may include for example magnetic discs optical discs and or memory devices e.g. flash memory devices static RAM SRAM devices dynamic RAM DRAM devices or other memory devices . The information may include data and or computer executable instructions that may implement one or more embodiments of the invention.

Input device s may include one or more devices that may be used to input information into computing device . Devices that may be used to input information into computing device may include for example a keyboard e.g. hardware keyboard software keyboard computer mouse microphone camera trackball gyroscopic device e.g. gyroscope mini mouse touch pad stylus graphics tablet touch screen joystick isotonic or isometric pointing stick accelerometer palm mouse foot mouse eyeball controlled device finger mouse light pen light gun neural device eye tracking device gesture tracking device steering wheel yoke jog dial space ball directional pad dance pad soap mouse haptic device tactile device neural device multipoint input device discrete pointing device or some other input device. The information may include spatial e.g. continuous multi dimensional data that may be input into computing device for example using a device such as for example a computer mouse. The information may also include other forms of data such as for example text that may be input using a keyboard.

Output device s may include one or more devices that may output information from the computing device . Devices that may output information from the computing device may include for example a cathode ray tube CRT plasma display device light emitting diode LED display device liquid crystal display LCD device vacuum florescent display VFD device surface conduction electron emitter display SED device field emission display FED device haptic device tactile device neural stimulation device printer e.g. a three dimensional 3D printer laser printer speaker video projector volumetric display device plotter actuator e.g. electrical motor or some other output device. Output device may be directed by for example the processing logic to output the information from the computing device . The information may be presented e.g. displayed printed by output device . The information may include for example graphical user interface GUI elements e.g. windows widgets dialog boxes or other GUI elements graphical representations pictures text or other information that may be presented by output device . Note that the information may be presented on one or more output devices in a stereoscopic view to enable for example a perception of depth.

Communication interface s may include one or more devices that may include logic for 1 interfacing the computing device with for example one or more communication networks and 2 enabling the computing device to communicate with one or more devices connected to the communication networks. An example of a communication network that may be used with computing device will be described further below with respect to .

A communication interface may include one or more transceiver like mechanisms that may enable the computing device to communicate with devices connected to the communication networks. Examples of a communication interface may include a built in network adapter network interface card NIC Personal Computer Memory Card International Association PCMCIA network card card bus network adapter wireless network adapter Universal Serial Bus USB network adapter modem or other device suitable for interfacing the computing device to the communication networks.

The primary storage is accessible to the processing logic via bus . The primary storage may be a non transient tangible computer readable media that may store information for processing logic . The information may include computer executable instructions and or data that may implement operating system OS windows manager WM an application APP and a technical computing environment TCE . The instructions may be executed interpreted and or otherwise processed by processing logic .

The primary storage may comprise a RAM that may include RAM devices that may store the information. The RAM devices may be volatile or non volatile and may include for example one or more DRAM devices flash memory devices SRAM devices zero capacitor RAM ZRAM devices twin transistor RAM TTRAM devices read only memory ROM devices ferroelectric RAM FeRAM devices magneto resistive RAM MRAM devices phase change memory RAM PRAM devices or other types of RAM devices.

OS may be a conventional operating system that may implement various conventional operating system functions. These functions may include for example scheduling one or more portions of APP and or TCE to run on the processing logic managing the primary storage controlling access to various components associated with the computing device e.g. secondary storage input device output device communication interface and controlling access to data received and or transmitted by these components.

Examples of operating systems that may be used to implement OS may include but are not limited to the Linux operating system Microsoft Windows operating system the Symbian operating system Mac OS Chrome OS and the Android operating system. A version of the Linux operating system that may be used is Red Hat Linux available from Red Hat Corporation Raleigh N.C. Versions of the Microsoft Windows operating system that may be used include Microsoft Windows 7 Microsoft Windows Vista and Microsoft Windows XP operating systems available from Microsoft Inc. Redmond Wash. The Chrome OS and Android operating systems are available from Google Inc. Mountain View Calif. The Mac OS operating system is available from Apple Inc. Cupertino Calif. The Symbian operating system is available from the Symbian Foundation London United Kingdom.

WM may be a conventional window manager that may manage GUI elements such as widgets dialog boxes and windows that may be part of the OS TCE and or APP . The GUI elements may be displayed on an output device . The WM may also be configured to 1 capture one or more positions of interactions with input device and or other data associated with the input device and 2 provide the positions and or data to for example OS APP and or TCE . The positions and or data may be provided in messages that may be sent to the OS APP and or TCE . Examples of window managers that may be used to implement WM may include but are not limited to X windows GNOME and KDE which are often used with the Linux operating system and window managers used with the Microsoft Windows XP Microsoft Windows Vista and Microsoft Windows 7 operating systems. It should be noted that other window managers or components that implement various functions associated with window managers may be used to implement WM .

APP may be designed to perform a particular task or tasks. APP may be an executable and or interpretable version of a software application that may be written in a programming language such as C C Java or some other programming language. Some or all of APP may be for example written by a user of computing device supplied by a vendor and or generated by TCE . Some or all of APP may operate under the control of OS . APP may include computer executable instructions and or data that may implement one or more embodiments of the invention.

TCE may be a technical computing environment that may contain provisions for solving one or more problems. As will be described further below TCE may include a framework that may be used to solve one or more problems. The framework may contain a meta solver and one or more sub solvers. Some or all of TCE may operate under the control of OS . TCE may include computer executable instructions and or data that may implement one or more embodiments of the invention.

The TCE may include hardware based and or software based logic which may provide a computing environment that may allow various tasks related to various disciplines such as mathematics science engineering mechanics physics medicine business biology and or finance to be performed. The TCE may include a dynamically typed programming language e.g. the MATLAB language where a data type of data may be determined at runtime.

The dynamically typed programming language may use an array as a basic data element where the array may not require dimensioning. The array may be used to support array based programming where an operation may apply to an entire set of values included in the array. Array based programming may allow array based operations to be treated as a high level programming technique that may allow for example operations to be performed on entire aggregations of data without having to resort to explicit loops of individual non array operations.

In addition the TCE may perform matrix and or vector formulations that may be used for data analysis data visualization application development simulation modeling and or algorithm development. These matrix and or vector formulations may be used in many areas such as mathematics science engineering mechanics physics medicine business biology and or finance.

The TCE may further provide functions and or tools for generating for example plots surfaces images volumetric representations or other representations. The TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting and or parallel processing . In addition the TCE may provide these functions as block sets. The TCE may also provide these functions in other ways such as via a library or a database.

Examples of TCEs that may be adapted to implement one or more embodiments of the invention may include but are not limited to MATLAB Simulink Stateflow Simscape SimMechanics and SimEvents which are available from MathWorks Inc. Unified Modeling Language UML profiles associated with UML e.g. Modeling Analysis and Real Time Embedded Systems MARTE Systems Modeling Language SysML Avionics Architecture Description Language AADL GNU Octave from the GNU Project MATRIXx and LabView from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab and Scicos from The French Institution for Research in Computer Science and Control INRIA Modelica or Dymola from Dynasim AB VisSim from Visual Solutions SoftWIRE from Measurement Computing Corporation WiT from DALSA Coreco Advanced Design System VEE Pro and SystemVue from Agilent Technologies Inc. Vision Program Manager from PPT Vision Inc. Khoros from Khoral Research Inc. VisiQuest from Pegasus Imaging Corporation Gedae from Gedae Inc. Virtuoso from Cadence Design Systems Inc. Rational Rose Rhapsody and Tau from International Business Machines IBM Inc. SCADE from Esterel Technologies and Ptolemy from the University of California at Berkeley.

Interface may be a textual and or graphical interface that may allow for example a user to specify edit annotate save publish and or print information that may be used and or provided by framework . As will be described further below the information may include a description of a problem problem description that may be provided to framework . Moreover interface may contain provisions for generating elements e.g. objects of framework and controlling e.g. establishing settings starting stopping the operation of framework . Interface may include a command line interface that may enable one or more commands which may be used to invoke some or all of the functionality associated with these provisions to be entered into TCE . In addition interface may contain provisions for outputting information that may be provided by framework such as one or more solutions to a problem that may be found by framework . The information may be outputted by interface in the form of for example text graphics or some combination thereof. Examples of information that may be provided by framework and may be output by interface will be described further below with respect to .

Framework may be used to for example find one or more solutions to a problem. The problem may be related to various disciplines such as mathematics science engineering mechanics physics medicine business biology and or finance. The framework may contain provisions for 1 identifying one or more solvers for use in finding one or more solutions to a problem 2 identifying one or more points e.g. starting points that may be used by one or more of the identified solvers 3 transferring the identified points to the one or more of the identified solvers 4 acquiring one or more outputs from one or more of the identified solvers and 5 identifying one or more solutions to the problem based on for example the acquired outputs. Framework may include a solver framework and a point framework . Note that framework may include other components associated with finding one or more solutions to a problem.

The meta solvers may include for example a global search meta solver a multi start meta solver and or one or more other meta solvers . The sub solvers may include a numeric solver a symbolic solver or some other type of solver. Note that framework may include two or more sub solvers that may be of different types. For example framework may include a first sub solver that may be a numeric solver and a second sub solver that may be a symbolic solver.

A meta solver may have one or more meta solver settings. The settings may be used to control a behavior of the meta solver . The settings may include for example one or more settings that may 1 control information that may be output from the meta solver 2 control a number of attempts made to find one or more solutions to one or more problems 3 specify an amount of time for finding one or more solutions to one or more problems 4 specify one or more tolerances for information e.g. points that may be used to find one or more solutions to one or more problems and or other settings.

Likewise a sub solver may have one or more sub solver settings. These settings may be used to control a behavior of the sub solver .

The solver framework may be implemented using one or more objects. illustrates a class diagram of objects that may be included in solver framework . Referring to the class diagram includes a meta solver MetaSolver class a multi start MultiStart class and a global search GlobalSearch class . The solver framework may include an object that is of the MultiStart class MultiStart object and or an object that is of the GlobalSearch class GlobalSearch object . Note that classes illustrated in are an example of classes for objects that may be contained in framework . Other embodiments of framework may include other objects that may for example implement various functionality associated with framework . Some or all of other objects may be based on other class definitions.

The MetaSolver class may define member functions and data members that may be associated with meta solvers in general. The MetaSolver class may be a parent class of the MultiStart class and the GlobalSearch class . Thus a MultiStart object and a GlobalSearch object may include member functions and data members . Note that the MetaSolver class may be a parent class to other meta solvers .

The MetaSolver class may define various data members and member functions that may implement functionality associated with a meta solver . The data members may include a display flag Display function tolerance TolFun X tolerance TolX time limit MaxTime and points to run PointsToRun . The member functions may include a run member function. Note that MetaSolver class may define other data members and or other member functions.

The Display data member may hold a value that may indicate which information may be outputted by an object derived from the MetaSolver class such as a MultiStart object and a GlobalSearch object. For example the Display data member may hold a value that may indicate one or more of the following information may be outputted by the object a global optimum solution to a problem one or more intermediate results one or more partial results status or other information.

The TolFun data member may hold a value that may be used to determine whether two points are identical in terms of a function value. The MaxTime data member may hold a value that may indicate a maximum amount of time that may be allowed for finding one or more solutions to a problem. The run member function may be used to run e.g. execute an object derived from the MetaSolver class .

The PointsToRun data member may hold a value that may be used to determine which points in a point set are to be used by one or more sub solvers that may be called by a MultiStart object or a GlobalSearch object. For example the PointsToRun data member may indicate that all the points in the point set are to be used certain points that fall within certain constraints e.g. bounds linear inequality constraints non linear inequality constraints are to be used or some other indication. Note that the point set may include one or more start points that may be used by the one or more sub solvers. The point set may be part of a point framework such as point framework . Examples of point frameworks will be discussed further below.

The MultiStart class may be a child class of the MetaSolver class . The MultiStart class may define data members and member functions that may be specific to the MultiStart class . The data members may include for example a parallelization flag data member UseParallel . The member functions may include for example a constructor function MultiStart and a run function run . Note that the MultiStart class may define other data members and or member functions.

The UseParallel data member may hold a value that may indicate whether for example sub solvers called by a MultiStart object may execute in parallel. For example execution of the sub solvers may be distributed among a plurality of processors. The flag may indicate for example that the sub solvers 1 may always execute in parallel 2 may never execute in parallel or some other indication.

The MultiStart function may be used as a constructor function for a MultiStart object. The MultiStart function may initialize one or more values of one or more data members associated with the MultiStart object.

The run member function may be used to run a MultiStart object. Running the MultiStart object may include invoking calling one or more sub solvers to attempt to find one or more solutions to a problem. The run member function may take various inputs. The inputs may include for example a problem description a value that indicates a number of points in a point set and or the point set. One or more points in the point set may be used by the sub solver as starting points. The run member function may return an output. The output may be represented as an array. An example of an output that may be returned by the run member function will be described below with respect to .

The GlobalSearch class may also be a child class of the MetaSolver class . The GlobalSearch class may define data members and member functions that may be specific to the GlobalSearch class . The data members may include for example a basin radius factor BasinRadiusFactor distance threshold factor DistanceThresholdFactor maximum wait cycle MaxWaitCycle number of stage one points NumStageOnePoints number of trial points NumTrialPoints and a penalty threshold factor PenaltyThresholdFactor . The member functions may include for example a constructor function GlobalSearch and a run function run . Note that the GlobalSearch class may contain other data members and or member functions.

The BasinRadiusFactor data member may hold a value that may indicate an amount that a given basin of attraction radius may be decreased when a certain number of consecutive trial points lie within a basin. The DistanceThresholdFactor data member may hold a value that may be used to tune an effect of a distance filter. During a run of a GlobalSearch object a trial point may have to pass various tests before the GlobalSearch object starts a sub solver from that point. The tests may include a distance test. The DistanceThresholdFactor data member may be used to determine if the trial point passes the the distance test. For example the test may include determining if the following holds given a trial point T and a solution already located L Distance between and 

The MaxWaitCycle data member may hold a value that may be used to determine a maximum number of consecutive trial points for various tests. These tests may include a test that determines whether a threshold value that may be used to determine whether a trial point is rejected is adjusted. For example the trial point may be rejected if a penalty function value at this point is greater than the threshold value. The threshold value may be adjusted if MaxWaitCycle consecutive trial points have been rejected because a penalty function value is greater than a threshold. Another test may include determining whether a radius of a basin of attraction of a located minimum is adjusted. For example if MaxWaitCycle consecutive trial points lie within a basin then the radius of the basin may be adjusted e.g. reduced .

The NumStageOnePoints data member may hold a value that may indicate for example a number of points that may be analyzed during a first stage of running a GlobalSearch object. After analyzing the number of points the GlobalSearch object may choose a best quality point from points that have been analyzed. The best quality point may be passed to a sub solver that may be called by the GlobalSearch object.

The NumTrialPoints data member may be used to hold a value that may represent a number of trial points that are generated from for example a scatter search algorithm. The PenaltyThresholdFactor data member may hold a value that may represent an amount by which the above described threshold value is adjusted.

The GlobalSearch function may be used as a constructor function for a GlobalSearch object. The GlobalSearch function may initialize one or more values of one or more data members associated with the GlobalSearch object.

The run member function may be used to run a GlobalSearch object. Running the GlobalSearch object may include invoking one or more sub solvers associated with the GlobalSearch object. A sub solver may be a gradient based non linear programming NLP solver. The GlobalSearch object may attempt to find a global solution to general smooth NLP problems. The global solution may be found for example using a combination of a domain searching heuristic and the sub solver. The domain searching heuristic may employ for example a scatter search technique that may involve generating candidate points using scatter search. The points may be analyzed and the sub solver may be started from a point if the point meets certain criteria e.g. passes certain tests such as one or more of the tests described above . The run member function may return an output that represents one or more solutions found by the sub solver. The output may be represented as an array. An example of an output that may be returned by the run member function will be described below with respect to .

The problem description may include for example an identifier objective function default start point linear inequality constraint linear inequality constraint bounds linear equality constraint linear equality constraint bounds lower bounds upper bounds constraint function solver options partial differential equations differential equations descriptions of one or more events that may be used for an event based simulation variable types and or other information that may be relevant to the problem. The problem description may be represented in a data structure that may be contained in the information.

The identifier may be used to identify a sub solver that may be called by the meta solver. For example the identifier may be a data string that holds a name associated with the sub solver. Note that the identifier may identify the sub solver in other ways.

The objective function may be a function that may be called by a sub solver. The sub solver may be called by the meta solver. The objective function may be represented in the information as a handle of e.g. pointer to identifier of the function.

The default start point that may be a start point that may be used by a sub solver for example if a start point is not provided to the sub solver.

The linear inequality constraint and linear equality constraint may be constraints that may be applied to the start point used by a sub solver that may be called by the meta solver. The linear inequality constraint and linear equality constraint may be represented in the information as arrays.

The linear inequality constraint bounds and linear equality constraint bounds may be bounds that may be applied to the linear inequality constraint and linear equality constraint respectively. The linear inequality constraint and linear equality constraint may be represented in the structure as arrays. The linear inequality bounds and linear equality bounds may be represented in the structure as vectors.

The lower bounds may include a set of lower bounds on one or more variables X used by a sub solver such that a solution that satisfies X may be greater than or equal to a corresponding lower bound in the set of lower bounds. The sub solver may be called by the meta solver. The upper bounds may be a set of upper bounds on the variables X such that a solution that satisfies X may be less than or equal to a corresponding upper bound in the set of upper bounds. The lower and upper bounds may be represented in the structure as arrays.

The constraint function may be a function that returns one or more values that represent one or more nonlinear inequality and or equality constraints. The function may be represented in the structure as a handle.

The solver options may include one or more options that may be passed to a sub solver that may be called by the meta solver. The options may be used to control certain behaviors of the sub solver. The solver options may be represented in the structure as data that may hold one or more settings of the various options.

At block a sub solver may be identified by the meta solver. The sub solver may be identified for example by analyzing the problem description and identifying the sub solver based on information contained in the problem description. Note that other ways of identifying the sub solver may be used.

At block the identified sub solver may be called by the meta solver in an attempt to find a solution to the problem. The sub solver may be called with a point from a point set that may specify a starting point for the sub solver.

At block an output of the sub solver may be used for example by the meta solver to identify one or more points for the sub solver. The sub solver may be called by the meta solver to perform an attempt at finding a solution to the problem using the identified points.

At block an output of the sub solver may be used for example by the meta solver to alter the problem and or one or more sub solver settings. The sub solver may likewise be called by the meta solver after these alterations. The acts at blocks through may be repeated until 1 one or more solutions are found 2 a certain time has elapsed 3 a number of iterations have been performed or some other condition. At block one or more results e.g. solutions returned by the sub solver may be analyzed for example by the meta solver to identify an optimal solution to the problem. The identified optimal solution may be returned by the meta solver.

At block a sub solver is identified. For example the sub solver may be identified from the acquired problem. Here the acquired problem may contain an identifier that may be used to identify the sub solver. Note that other ways of identifying the sub solver may be used.

At block a point set is acquired. The point set may include one or more points that may be used as starting points by the sub solver to find one or more solutions to the problem. The point set may be acquired from a point framework such as point framework which will be described further below.

At block a point is identified for the identified sub solver. The point may be identified from the acquired point set. The point may be a start point that may be used by the sub solver.

At block the identified sub solver is called. The sub solver may be an object and may be called by invoking a run function associated with the object. The point identified at block may be passed to the sub solver in the call to the sub solver. Moreover some or all of the acquired problem may be passed to the sub solver. The sub solver may return a result to the MultiStart meta solver . The result may include 1 a status which may indicate whether the sub solver was able to find a solution to the problem and 2 one or more solutions to the problem that may have been found by the sub solver.

At block a result returned by the sub solver may be analyzed by for example the meta solver. The MultiStart meta solver may adjust the sub solver e.g. change one or more of the sub solver s options and or the problem based on a result of the analysis. At block a check may be performed to determine whether all of the points in the acquired point set to be used by the sub solver have indeed been used by the sub solver. If not acts at blocks through are repeated in a next attempt to find another solution. At block the result returned by the sub solver may be used in part to identify another point in the point set to be used by the sub solver in the next attempt.

If at block all of the points in the point set to be analyzed have indeed been analyzed at block one or more results returned by the sub solver may be analyzed to identify one or more solutions to the problem. The identified one or more solutions may be returned by the MultiStart meta solver . As will be described below the one or more solutions may be returned in an array of objects.

At block a sub solver is identified. The sub solver may be identified by for example from the acquired problem such as described above. Note that other ways of identifying the sub solver may be used.

At block a point set is acquired for a first stage stage 1 point set of finding one or more solutions to the problem by the GlobalSearch meta solver . The stage 1 point set may include one or more points that may be used as starting points by the sub solver to find one or more solutions to the problem during the first stage. The stage 1 point set may be acquired from a point framework such as point framework .

At block the stage 1 point set may be analyzed to identify a stage 1 point that may have a best objective value. The best objective value may relate to a point in the stage 1 point set that is likely to produce a solution to the problem. Note that other criteria may be used to identify the stage 1 point. The GlobalSearch meta solver may call the identified sub solver and pass the identified stage 1 point to the sub solver.

At block a point set is acquired for a second stage stage 2 point set of finding one or more solutions to the problem by the GlobalSearch meta solver . The stage 2 point set may include one or more points that may be used as starting points by the sub solver to find one or more solutions to the problem during the second stage. The stage 2 point set may be acquired from a point framework such as point framework .

At block a stage 2 point may be identified from the acquired stage 2 point set. Identifying the point may include analyzing the stage 2 point set to identify a point that may have a best objective value. Note that other criteria may be used to identify the stage 2 point. At block the GlobalSearch meta solver may call the identified sub solver and pass the identified stage 2 point to the sub solver.

At block the GlobalSearch meta solver may receive a result from the sub solver and adjust the sub solver e.g. change one or more of the sub solver s options and or the problem based on the result. For example the result may include a solution found by the sub solver and or a status e.g. whether the sub solver found a solution . The GlobalSearch meta solver may adjust the sub solver and or problem based on the solution and or status.

At block a check may be performed to determine whether the sub solver should be called with another stage 2 point in the stage 2 point set. If so acts at blocks through may be repeated in a next attempt to find another solution using a different stage 2 point in the stage 2 point set. At block the result returned by the sub solver may be used for example to identify the other stage 2 point in the stage 2 point set.

If at block it is determined the sub solver should not be called with another stage 2 point at block one or more results returned by the sub solver may be analyzed to identify one or more solutions to the problem. The identified one or more solutions may be returned by the GlobalSearch meta solver . As will be described below the one or more solutions may be returned in an array of objects.

A behavior of a meta solver may be described by one or more member functions associated with the meta solver. One or more settings associated with the meta solver may be used to tune the meta solver and or define the meta solver s interaction with for example a user.

A problem description and a sub solver that may be called by the meta solver may be wrapped in a container. The container may be passed to an instance of the meta solver to attempt to solve a problem defined by the problem description.

A meta solver may attempt to find a solution to a problem in a particular search space defined by the problem. The search space may be defined by information that may be included in a problem description of the problem. For example the problem description may include bounds that may be used to define the search space. The meta solver may pass these bounds to a point framework such as point framework . The point framework may use the bounds to identify one or more points for the meta solver. The meta solver may transfer one or more of the identified points to one or more sub solvers that may be called by the meta solver. The sub solvers may use the transferred points as start points for one or more attempts to find one or more solutions to the problem.

An embodiment of point framework may be implemented using one or more objects that may contain data members and member functions. illustrates a class diagram of example objects that may be included in point framework . Referring to class diagram includes a point set PointSet class a generated point set GeneratedPointSet class a random point set RandomPointSet class and a custom point set CustomPointSet class .

An object of the RandomPointSet class RandomPointSet object or an object of the CustomPointSet class CustomPointSet object may include member functions defined by the PointSet class . The member functions may include a constructor PointSet member function and a list member function list . Note that the PointSet class may define various data members and or other member functions for a RandomPointSet object and or a CustomPointSet object.

The PointSet member function may be a constructor function. The PointSet member function may be called during a construction of a RandomPointSet object or a CustomPointSet object. The PointSet member function may initialize one or more values of one or more data members associated with these objects. The list member function may output one or more points.

A RandomPointSet object may include data members and member functions that may be defined by the GeneratedPointSet class . The data members may include a number of points NumPoints data member and an artificial bound ArtificialBound data member. The member functions may include a constructor GeneratedPointSet member function and a generate generate member function. The NumPoints data member may be used to specify a number of points to be generated for a point set. The points may be generated when the generate member function is called. The ArtificialBound data member may be used to specify for example one or more bounds for the generated points.

The GeneratedPointSet member function may initialize one or more values of one or more data members associated with the RandomPointSet object. The data members may include data members . The generate member function may be called to generate one or more points for point framework such as point framework . Note other data members and or member functions may be defined for class .

A RandomPointSet object may include member functions that may be defined by the RandomPointSet class . The member functions may include a constructor RandomPointSet member function a list list member function and a generate generate member function. The RandomPointSet member function may be called during a construction of the RandomPointSet object. The RandomPointSet member function may initialize one or more values of one or more data members associated with the RandomPointSet object. The generate member function may generate one or more points for a point framework such as point framework . The generated points may be random. The list member function may output one or more generated points.

As indicated in the CustomPointSet class a CustomPointSet object may include various data members and member functions . The data members may include a points Points data member a number of points NumPoints data member and a dimension of points DimPoints data member. The member functions may include a constructor CustomPointSet member function and a list list member function. Note that the CustomPointSet object may include other data members and or member functions.

The Points data member may hold one or more points associated with the CustomPointSet object. The one or more points may be held in an array. The one or more points may be for example specified by a user generated by a function or otherwise defined. The NumPoints data member may hold a value that may represent a number of points held by the Points data member. The DimPoints data member may hold a value that may be associated with a dimensionality of the Points data member. For example the Points data member may be an array and the DimPoints data member may hold a vector that may hold the dimensions of the array.

The CustomPointSet member function may be a constructor function that may be called when the CustomPointSet object is constructed. The CustomPointSet member function may be used to initialize one or more values of one or more data members associated with the CustomPointSet object. The list member function may be used to output one or more points that may be contained in the Points data member.

The point set may include one or more points that may be used by the solver framework . The points may be used as starting points for one or more sub solvers that may be called by meta solvers in the framework . The points may be for example 1 generated using a generator function e.g. a random number generator function 2 specified by a user 3 generated based on previously generated points or otherwise defined. Moreover the points may be generated using various objects such as objects described above with respect to . As will be described further below the point set may be implemented as an object that may include a member function that may output one or more points in the point set .

The point set may have one or more settings. Examples of settings may include but are not limited to a dimension of an array that holds points in the point set a number of points output by the point set a lower and or upper bounds for points generated by the point set a set of one or more generator functions that may be used to generate the points and or other settings. The point set may output one or more of the points to the solver framework . Moreover one or more of the points may be output to the point cache .

The points may be stored by point set in a variety of ways. For example the points may be stored as raw data text files spreadsheet files a database and or some other way. One or more of the points may be output by the point set . For example the point set may be implemented as an object that may include a member function that may be called from outside the object. The member function may output return one or more of the points to the caller.

The point cache may store one or more of points that may be output and or used by the point set . One or more of the points in the cache may be generated by the point set . Moreover one or more of the points in the point cache may be generated specified externally from the point framework . For example one or more of the points in the point cache may be specified by a user via an interface such as interface . Likewise for example one or more points in the point cache may be acquired from a database file a communications network or some other source that may be external from the point framework .

The point cache may be used to store a history of points. For example the point cache may be used to store a history of points that have been output from the point set to solver framework . Moreover the point cache may be used to store a history of points that have been generated by the point set . Note that other histories associated with the points may be stored by the point cache . The point set may utilize this history to for example generate future points that may be output by the point set . For example the point set may utilize this history to generate points that are not duplicates of points that have already been generated and or generate points that may maximize a distance between points.

The solver framework may request points from the point set . In response to the request the point set may output one or more points to the solver framework . The one or more points that may be output may be generated based on for example one or more settings associated with the point set and or information passed to the point set from the solver framework . This information may include for example an optimization problem sub solver meta solver information e.g. settings one or more generator functions a subset of previous points previous solutions from a meta solver and or other information.

Other information may be passed to the point set . This information may include a problem description. The problem description may include for example an upper and or lower bounds an objective function a non linear constraint function a default start point one or more linear constraints one or more bounds an identity of a sub solver one or more options e.g. sub solver options and or other information. This other information that may be passed to the point set may be used by the point set to generate one or more points that may be output by the point set .

In addition one or more domains may be input into the point set . A domain may be a subset of an entire search space in which a meta solver may use in an attempt to find one or more solutions to a problem. The domains may be unrestricted. For example the domains may overlap and or more than one domain may exist. Furthermore a one to one correspondence between a domain and a problem may not necessarily exist. Moreover a domain may or may not include a solution space for a problem. An example of a domain space that includes a solution space will be described further below with respect to .

The plot member function may present a graphical display of one or more points held by the Points data member. The graphical display may include one or more graphical plots of the points. The one or more of the plots may be built into a TCE such as TCE . Likewise one or one more of the plots may be custom plots that may be specified for example by a user. The display member function may present for example a textual display of one or more points held by the Points data member. The one or more points may be displayed in response to a command provided for example by a user. The analyze member function may analyze one or more points held by the Points data member. One or more functions used to analyze the points may be built into the TCE and or externally specified e.g. by a user . The getPoints member function may retrieve one or more points from the Points data member. The points may be output from the PointCache object to a caller. For example the PointSet object may call the getPoints member function to retrieve one or more points from the Points data member in the PointCache object.

The PointCache object may be created by a meta solver such as meta solver . illustrates a class diagram that shows a use dependency between a MetaSolver object and a pointCache object. Referring to the MetaSolver object may include a run member function run which may be used to run the MetaSolver object. When invoked the run member function may create the PointCache object. Note that the MetaSolver object s run member function may also be used to access one or more points in the PointCache object.

The point data source may be a source for point data. The point data may be stored in for example a database a file or some other storage. Moreover the point data may be for example generated on the fly using a point generator function. The point data source may be local in that it may reside in a computing device that runs TCE and or may be remote in that the point data source may reside in one or more remote computing devices. The computing devices may be connected to a communications network such as the Internet. Moreover the computing devices may be part of a network cloud. One or more requests for point data may originate at a computing device and sent to one or more other computing devices which may respond to the requests with some or all of the point data.

The communication layer may contain provisions for gaining access to one or more points contained in the point data source . For example the communication layer may implement an application programming interface API that may be used to acquire one or more points from the point data source . Here the points may be acquired by calling one or more functions provided by the API. In addition to or alternatively the communication layer may incorporate a messaging scheme that may be used to acquire one or more points from the point data source . Moreover the communication layer may utilize one or more communication protocols e.g. the Transmission Control Protocol Internet Protocol TCP IP User Datagram Protocol UDP to transfer requests and or point data between the point data source and one or more point sets .

A point set may include a set of one or more points that may be used by a worker e.g. a sub solver a computing device . The point set may also include logic that may be used to acquire one or more of the points for the points set from the point data source via the communication layer .

Operationally a point set may issue a request to the communication layer for one or more points from the point data source. The request may include a function call e.g. a remote procedure call a local procedure call message or other request. The communication layer may make a request to the point data source to acquire the one or more points. The request may include a function call message or other request. The point data source may respond to the request with one or more data points. The communication layer may respond to the point set s request with one or more of the points returned to the communication layer by response .

One or more points in a point set may be distributed among one or more workers e.g. sub solvers meta solvers . Here a particular worker may be assigned a particular subset of points in the point set. The worker may use the assigned subset of points as start points that may be used in one or more attempts to find one or more solutions to a problem.

Framework may be arranged a number of different ways to solve various problems. illustrate block diagrams of example arrangements of framework that may be used to solve various problems.

The domain space illustrated in is partitioned into four partitions . A partition may be processed by one or more sub solvers. The sub solvers may operate in parallel on a particular partition in an attempt to find one or more solutions to a problem that may lie within the partition .

The solution space may be a region in the domain space where one or more solutions to the problem may lie. The solution space may be said to include a set of feasible points where a feasible point may be a point that may satisfy the problem s constraints. The solution space illustrated in contains four partitions . One or more points in a partition may be found by one or more sub solvers that may operate for example in parallel.

A solver may output progress information that provides an indication of progress towards finding one or more solutions to a problem. For example one or more sub solvers may display information about whether the one or more of the sub solvers have found one or more solutions to a problem and if so how many solutions they have found. Likewise for example one or more sub solvers may display other information such as how many attempts the sub solvers had made towards finding a solution how much time may be left for the sub solvers to find one or more solutions and so on.

A solver may also output other information such as a best solution and or all solutions that have been found. Here for example a meta solver may query one or more sub solvers for one or more solutions that the sub solvers have found and report a best solution and or all of the solutions returned by the sub solvers. illustrates a class diagram of a Solution class . An object of the Solution class Solution object may be used by a meta solver to report one or more solutions that may be found by one or more sub solvers.

Referring to a Solution object may include one or more data members and one or more member functions . The data members may include for example free variable values of local minima X an objective function value at the local minima FVAL a sub solver exit flag Exitflag stores of algorithm state Output and one or more points e.g. start points that may be used by a sub solver to find the same solution defined by X and FVAL to a problem X0 within some specified tolerance. The member functions may include a constructor member function Solution which may initialize one or more data members associated with Solution object. Note that a Solution object may include other data members and other member functions. Also note that a multiplicity of solutions may be realized by a multitude of Solution objects. The multitude of Solution objects may be organized into a collection of Solution objects. For example the multitude of Solution objects may be organized as an array of Solution objects a database of Solution objects or some other structure capable of handling a collection of Solution objects.

The meta solver may call one or more of the sub solvers one or more times to find one or more solutions to the problem. The meta solver may organize the one or more solutions into a collection of Solution objects as described above. The Exitflag data member in a Solution object may include an exit condition that may be returned by a particular sub solver. The exit condition that may indicate whether the sub solver has indeed found a solution to the problem. The Output data member in a Solution object may include one or more algorithmic performance indicators that may be provided by a sub solver. These algorithmic performance indicators may include for example a number of iterations that the sub solver took before exiting a number of function evaluations an algorithm e.g. used by the sub solver performed and or an optimality measure the algorithm achieved. Note that a Solution object is an example of an object that may be output by a solver such as a meta solver.

At block a sub solver may be selected. The sub solver may be selected based on the problem description. For example the problem description may explicitly identify the sub solver. The sub solver may be selected by for example a user a meta solver a TCE or some other entity.

At block a meta solver may be set up. The meta solver may be set up for example by creating an instance of an object that represents the meta solver. Setting up the meta solver may also include for example establishing e.g. specifying setting initializing one or more settings associated with the meta solver. One or more of the settings may be included in one or more data members that may be associated with the meta solver.

At block one or more points and or domains may be described. The points and or domain may be described for example by a user. One or more points may be described by explicitly specifying the points. Alternatively or in addition to one or more points may be described using a function that may be used to generate the points or using a point framework such as point framework . Note that other ways of describing one or more of the points may be used. One or more of the domains may be described by various parameters such as for example bounds that may define the domain a function that may define the domain or other parametric information. Note that other ways of describing one or more of the domains may be used.

At block the meta solver may be run. The meta solver may be run by calling a function e.g. a run function associated with the meta solver. Running the meta solver may involve calling a function e.g. a run function associated with the sub solver and transferring one or more of the points to the sub solver. The points may be transferred to the sub solver as one or more parameters in the call to the sub solver function via a message or via some other mechanism. Moreover the sub solver may be implemented as a function and the points may be transferred to the sub solver on an invocation of the function. The sub solver may attempt to find one or more solutions to the problem based on points transferred to the sub solver.

At block the meta solver may acquire and analyze one or more results from the sub solver. The results may include 1 a status that indicates whether the sub solver has found one or more solutions to the problem and 2 one or more solution that have been found by the sub solver. Based on the analysis the meta solver may return one or more of the solutions. The returned solutions may include an optimal solution that was found by the sub solver. One or more of the returned solutions may be presented for example to a user via an interface such as interface .

At block a determination may be made as to whether the results are satisfactory. The meta solver may determine whether the results are satisfactory. If the results are determined to not be satisfactory the workflow may return to block or and acts from that block through block may be repeated in another attempt to find one or more solutions to the problem. If the results are determined to be satisfactory additional attempts to find one or more solutions to the problem may not be performed.

At block the one or more sub solvers may be identified based on the acquired information. For example the information may include a problem description that includes one or more identifiers that may be used to identify one or more of the sub solvers. Here identification may involve for example determining if the one or more identifiers in the information match one or more identifiers associated with one or more of the sub solvers.

Likewise for example one or more of the sub solvers may be identified based on other acquired information. For example the problem description may include other information about the problem e.g. a formula . One or more of the sub solvers may be identified based on this other information. Moreover one or more of the sub solvers may be identified via a search and or service request. For example a service request may be made to one or more sites e.g. Internet web sites that may provide sub solver services. These services may include use of a sub solver use of resources to execute a sub solver or other services. A site may provide a list of one or more sub solver services provided by that site. The site may also provide various criteria associated with the sub solver services such as cost of using a particular sub solver service in the list. The sub solver may be identified for example based on the criteria.

Note that two or more of the identified sub solvers may be of different types. For example one of the identified sub solvers may be a symbolic sub solver and another identified sub solver may be a numeric sub solver.

At block one or more points for the identified sub solvers may be identified. The one or more points may be starting points for the identified sub solvers. The one or more points may be identified based on the acquired information. For example the acquired information may include one or more of the following that may be used to identify one or more of the points one or more of the points a function that may be used to generate one or more of the points a description of one or more of the points and or domains the points may lie in or other information.

One or more of the points may be identified from a domain space that may be associated with the problem. For example a problem description may contain information that may define a domain space for the problem. One or more of the points may be selected by this domain space.

One or more of the identified points may be acquired. For example one or more of the points may be acquired from an interface such as interface a database a simulation of a model a file a communications network and or a generator function.

One or more of the identified points may be generated based on one or more settings e.g. sub solver settings meta solver settings other settings and or one or more domain definitions of a domain space for the problem. The one or more settings may include a number of points to generate a lower bound for the points and or an upper bound for the points.

A cache such as point cache may be used to identify one or more of the points. For example one or more of the points may be read from the cache. One or more of the points may have already been used by a sub solver in a previous attempt to find one or more solutions to the problem. Likewise for example a point may be identified based on a predefined distance from a point that exists in the cache. The point that exists in the cache may have been used as a starting point by a sub solver in a previous attempt to find one or more solutions to the problem. Moreover the cache may be used to place a limit on a total number of points that may be identified.

At block one or more of the identified points may be transferred to one or more of the identified sub solvers. The points may be transferred for example 1 as one or more arguments in one or more calls to one or more of the identified sub solvers 2 via a message sent to one or more of the identified sub solvers or 3 via some other mechanism for transferring the points to one or more of the identified sub solvers.

At block the identified sub solvers may make a first attempt to find one or more solutions to the problems using one or more of the transferred points.

At block one or more outputs from one or more of the identified sub solvers may be acquired. The one or more outputs may indicate one or more results associated with the first attempt to find at least one solution to the problem by one or more of the identified sub solvers. The one or more outputs may be acquired for example by calling a function from data returned by one or more calls to one or more of the identified sub solvers via messaging etc. The results may include for example one or more solutions to the problem that were found by one or more of the identified sub solvers.

At block a check may be performed to determine if an end condition has occurred. An end condition may be a condition that after it occurs may lead to ending further attempts to find one or more solutions to the problem. An end condition may include though is not limited to one or more of 1 a certain time has elapsed 2 a certain number of attempts have been made 3 a certain number of solutions have been found 4 an optimal solution has been found or 5 a number of starting points have been tried.

If an end condition has not occurred at block one or more sub solvers for use in a next attempt to find at least one solution to the problem may be identified based on for example one or more of the acquired outputs. For example based on one or more of the acquired outputs a meta solver may determine that a sub solver used in the first attempt current sub solver should not be used in the next attempt to find one or more solutions to the problem. Here the meta solver may identify a different sub solver and include the newly identified sub solver in the identified one or more sub solvers for the next attempt instead of the current sub solver.

Likewise for example based on one or more of the acquired outputs a meta solver may determine that the current sub solver should be used in the next attempt to find one or more solutions to the problem. Here the meta solver may include the current sub solver in the identified one or more solvers for use in the next attempt. Note that the current sub solver may be adjusted. The current sub solver may be adjusted based on one or more of the acquired outputs.

One or more of the sub solvers for use in a next attempt to find at least one solution to the problem may be identified based on information acquired at block . For example the information may include one or more identifiers that may identify one or more of the sub solvers for use in the next attempt.

Note that after a sub solver is identified either for the first attempt or the next attempt one or more settings for the identified sub solvers may be established. For example a setting that may be established is an identifier e.g. name handle of a function that the sub solver may call while the sub solver is executing.

If at block an end condition has occurred at block a check may be performed to determine whether one or more solutions have been found by one or more of the sub solvers. If one or more solutions have been found by one or more of the sub solvers at block one or more of the found solutions may be provided. The solutions may be provided by for example displaying the solutions on an output device e.g. output device returning the solutions to a caller or provided in some other manner.

Referring to B suppose for example that a user at computing device wants to find one or more solutions to a problem using TCE . The user may input information into TCE via interface using an input device . The information may include for example 1 a problem description that describes the problem and 2 identity information e.g. names that may be used to identify one or more sub solvers for use in attempting to find one or more solutions to the problem. TCE may acquire the information block via interface and use the identity information to identify one or more sub solvers block .

TCE may determine that one or more of the identified sub solvers are missing from the TCE e.g. the sub solvers are not contained in the solver framework . In this situation the TCE may attempt to locate the missing sub solvers . Here the TCE may query various nodes e.g. computing devices that are attached to a communications network such as the Internet to locate and or acquire the missing sub solvers . As part of the query the TCE may provide the problem description to the other nodes and the other nodes may identify locate and or provide one or more of the missing sub solvers based on the provided problem description.

After one or more sub solvers are identified TCE may create one or more instances of the one or more sub solvers in framework . TCE may also create an instance of a meta solver in framework . The instance of meta solver may be used to call one or more instances of the sub solvers to attempt to find one or more solutions to the problem. Alternatively TCE may create an instance of the meta solver and pass transfer the problem description to meta solver instance. The meta solver instance may identify one or more of the sub solvers based on the problem description and create instances of the identified sub solvers . Note that the instance of the meta solver and or instances of one or more sub solvers may be created on one or more computing devices that are remote from computing device . Further one or more of the created instances may execute on one or more remote computing devices.

The TCE may identify one or more points e.g. starting points for the identified plurality of sub solvers block . The one or more points may be identified by the point framework as described above. After the points are identified the TCE may transfer one or more of the starting points to one or more of the identified sub solvers block . One or more points may be transferred to a particular sub solver for example via a call to a member function associated with an instance of a meta solver . Alternatively various messaging techniques may be used to transfer one or more of the points to one or more of the sub solvers .

The meta solver may direct one or more of the sub solvers to attempt to find one or more solutions to the problem given the transferred points by calling for example run member functions associated with the sub solvers . The sub solvers may attempt to find one or more solutions block . The meta solver may acquire one or more results that may be returned by one or more of the sub solvers block . A result from a particular sub solver may be for example an object that may be returned to the meta solver in response to a call to the sub solver by the meta solver . The object may contain an exit flag data member that may indicate whether the sub solver has found one or more solutions to the problem. If the sub solver has found at least one solution to the problem the solution may be provided in the result returned by the sub solver .

The meta solver may determine if an end condition has occurred block . An end condition may include for example whether a certain time has elapsed a certain number of attempts have been made a certain number of solutions have been found an optimal solution has been found or some other end condition.

If an end condition has not occurred the meta solver may identify one or more sub solvers that may be used in a next attempt to find one or more solutions to the problem block . The sub solvers may be identified using one or more of the acquired results. For example one or more of the results may be used to determine if a different sub solver should be used in place of a current sub solver in the next attempt. The above may be repeated in a next attempt to find one or more solutions to the problem.

If an end condition has occurred the meta solver may check the results to determine if one or more solutions have been found by one or more of the sub solvers . If so the meta solver may identify a global optimal solution from one or more solutions that have been found and provide the global optimal solution to the TCE block via for example an object such as a Solution object.

The TCE may present e.g. display the global optimal solution using interface . The global optimal solution may be presented for example textually graphically or some other way. Moreover intermediate solutions may be presented. illustrates an example textual presentation of one or more intermediate solutions. illustrates an example graphical presentation of one or more global optimal solutions and or intermediate solutions. The example presentations in may be generated by TCE based on information that may be provided by framework . The example presentations may be output on an output device via interface .

One or more embodiments of the invention may be implemented in a distributed environment. illustrates an example of a distributed environment that may implement one or more embodiments of the invention. Referring to environment may contain various components including computing device target environment service provider cluster and communications network . Note that the distributed environment is just one example of a distributed environment that may be used with one or more embodiments of the invention. Other distributed environments that may be used with one or more embodiments of the invention may contain more components or fewer components than illustrated in . Moreover the components in the distributed environments may be arranged differently than the arrangement shown in . In addition the distributed environments may implement various cloud computing frameworks.

Details of computing device were described above with respect to . In distributed environment computing device may among other things exchange information e.g. data with other components in the communications network e.g. target environment service provider and cluster . Computing device may interface with the communications network via a communication interface .

Target environment may be configured to interpret and or execute for example one or more embodiments of the invention which may be generated in or otherwise made available to the distributed environment . The communications network may include digital and or analog aspects. Information exchanged in communications network may include machine readable information having a format that may be adapted for use for example in the communications network and or with one or more components in the communications network .

For example the information may be encapsulated in one or more packets that may be used to transfer the information through the communications network . Information may be exchanged between components in the communications network using various communication protocols such as but not limited to Asynchronous Transfer Mode ATM Synchronous Optical Network SONET UDP IP TCP TCP IP Institute of Electrical and Electronics Engineers IEEE 802.11 or some other communication protocol.

The communications network may comprise various network devices such as gateways routers switches firewalls servers repeaters address translators etc. Some or all of the communications network may be wired e.g. using wired conductors optical fibers and or wireless e.g. using free space optical FSO radio frequency RF acoustic transmission paths . Some or all of the communications network may include a substantially open public network such as the Internet. Some or all of the communications network may include a more restricted network such as a private corporate network or virtual private network VPN . It should be noted that implementations of communications networks and or devices operating on communications networks described herein are not limited with regards to for example information carried by the communications networks protocols used in the communications networks and or the architecture configuration of the communications networks.

Cluster may include a number of units of execution UEs that may execute or interpret one or more embodiments of the invention or portions thereof on behalf of computing device and or another component such as service provider . The UEs may reside on a single device or chip or on multiple devices or chips. For example the UEs may be implemented in a single ASIC or in multiple ASICs. Likewise the UEs may be implemented in a single computer system or multiple computer systems. Other examples of UEs may include for example some combination of FPGAs CPLDs ASIPs processors multiprocessor systems on chip MPSoCs graphic processing units and or microprocessors. The UEs may be configured to perform operations on behalf of another component in the distributed environment . For example in an embodiment the UEs are configured to execute portions of code associated with the programming environment . Here the programming environment may dispatch certain activities pertaining to one or more embodiments of the invention to the UEs for execution. The service provider may configure cluster to provide for example the above described services to computing device on a subscription basis e.g. via a web service .

The foregoing description of embodiments is intended to provide illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from a practice of the invention. For example while a series of acts has been described above with respect to C A B and A B the order of the acts may be modified in other implementations. Further non dependent acts may be performed in parallel. Also the term user as used herein is intended to be broadly interpreted to include for example a computing device e.g. a workstation or a user of a computing device unless otherwise stated.

It will be apparent that one or more embodiments described herein may be implemented in many different forms of software and hardware. Software code and or specialized hardware used to implement embodiments described herein is not limiting of the invention. Thus the operation and behavior of embodiments were described without reference to the specific software code and or specialized hardware it being understood that one would be able to design software and or hardware to implement the embodiments based on the description herein.

Further certain embodiments of the invention may be implemented as logic that performs one or more functions. This logic may be hardware based software based or a combination of hardware based and software based. Some or all of the logic may be stored on one or more tangible computer readable storage media and may include one or more computer executable instructions that may be executed by processing logic such as processing logic . The computer executable instructions may include instructions that implement one or more embodiments of the invention. The tangible computer readable storage media may be volatile or non volatile and may include for example flash memories dynamic memories removable disks and non removable disks.

No element act or instruction used herein should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

It is intended that the invention not be limited to the particular embodiments disclosed above but that the invention will include any and all particular embodiments and equivalents falling within the scope of the following appended claims.

