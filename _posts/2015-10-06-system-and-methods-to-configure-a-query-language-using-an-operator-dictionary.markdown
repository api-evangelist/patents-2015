---

title: System and methods to configure a query language using an operator dictionary
abstract: Systems and methods to configure a query language using an operator dictionary are described. The system receives, from a first user, a search query to search for document information in a database. The system determines that terms of the search query from the first user are in accordance with dictionary information that corresponds to the first user. The dictionary information includes a first list of compatible query operators. The system applies the search query to the index data structure in the database to identify the document information. The system sends an electronic interface to the first user that includes the document information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460151&OS=09460151&RS=09460151
owner: PAYPAL, INC.
number: 09460151
owner_city: San Jose
owner_country: US
publication_date: 20151006
---
This application is a continuation application of U.S. application Ser. No. 13 759 786 filed Feb. 5 2013 which claims the priority benefit of U.S. Provisional Application Ser. No. 61 675 793 filed Jul. 25 2012 all of which are incorporated herein by reference in their entirety.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever.

The present application relates generally to the technical field of data processing and in one specific example to configure a query language based on a set of rules for a user.

A user may form a search query using a query language to search for information stored within a database. The query may comprise of operators and operands and a server may process the query and retrieve information based on the operators and operands. Once information is retrieved it may be presented to the user.

Example methods and systems to configure a query language using an operator dictionary are described. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of example embodiments. It will be evident however to one skilled in the art that the present invention may be practiced without these specific details.

A search query and other forms of input e.g. sets of text strings sequences of expressions collections of verbal and numeric expressions etc. may be received as input. For example a search query may be used to query a database using a query language. In various embodiments terms of the query language comprise of operators and operands. The operands may serve as inputs for the operators. In various embodiments terms of the query language may be defined by information described in an operator dictionary. The operator dictionary may include a list of compatible operators that may be used in a search query. In various embodiments operators not listed in the operator dictionary are incompatible and are not processed by a query processer. The operator dictionary may also describe a list of compatible data types for each operator in the list of compatible operators.

In various embodiments the operator dictionary may correspond to a first user or first group of users. Different customers e.g. users may independently provide rules using their own operator dictionary file. As such rules regarding compatible operators and compatible data types described in the operator dictionary may apply to the first user or first group of users. In various embodiments there may be other users or group of users forming search queries to query the database. To accommodate the other users the configure query language system may have more than one operator dictionary for the other user or groups of users forming search queries. All operator dictionary files are nevertheless processed by a single query engine that enforces the rules defined in the respective operator dictionaries.

Illustrated on the top left is an operation A that describes a first user operating the client machine to interact with an application server to store or update a document in a database illustrated in the middle are operations B C D E that describe retrieving and transforming the contents of the database storing the transformed contents in a database that is time stamped retrieving the contents from the database to generate a full index and a set of mini indexes which are utilized to generate and continually update the index information in the database to be consumed and served by the query node servers and illustrated on the top right is an operation F that describes a second user who operates a client machine to enter a query that is received by one or more query node servers that in turn apply the query to the index information to identify and return search results that reference the document . The above operations to continually rebuild the index information are performed in real time and without interruption to service that is provided to the first and second users who continue to interact with the system .

The index information may include an inverted index and document information . An inverted index e.g. inverted index as is well known in the art is an index data structure storing a mapping from content e.g. content contained by the document such as words or numbers to its locations in a database file or in a document e.g. document or a set of documents. The documents e.g. document data column group data and or information contained by the documents may be stored in the document information .

Merely for example a document X may include the words apple orange and banana a document Y may include the words apple and orange and a document Z may include the word apple. An inverted index for the words in documents X Y and Z may be generated as follows 

The above inverted index may be utilized to identify the word apple as being positioned in the first word of documents X Y and Z the word orange as being positioned in the second word of the documents X and Y and the word banana as being positioned as the third word of the document X. Accordingly the above inverted index may be utilized to map a keyword apple contained in a query that is received from a client computer to the documents X Y and Z that are further referenced in search results that are returned to the client computer. It is appreciated by one skilled in the art that the inverted index corresponds to the underlying database that it describes. Accordingly any update to the underlying database is reflected in a corresponding update to the inverted index . Updates to the database may include the addition and deletion of documents in the document information as well as the update of any of the contents contained by the documents in the document information . In the present embodiment the index information may be updated in real time to respond to a query in real time with accurate search results that include the most recent document information . To this end the operations A F are now further described.

The information storage and retrieval platform includes multiple components including the application servers that may execute on one or more application server machines not shown the database a database an Hadoop distributed file system the database the query node servers that operate on query node server machines not shown an Hbase Hadoop Cluster comprised of one or more Hbase Hadoop machines not shown including an Hbase Hadoop Node e.g Hbase Hadoop machine an index distribution module executing on Hbase Hadoop machine search front end servers that executes on search machines not shown and search back end servers that execute on search machines not shown as being communicatively coupled together. For example the multiple components may be communicatively coupled with any combination of a wide area network local area network wireless network or any other type of network utilizing various networking technologies.

At operation A the document or one or more elements of the document may be communicated from the client machine to the application servers and stored in the database e.g. Oracle database . The document may include multiple elements including elements a b c d e and f that may include strings of text numeric information scores or other discrete quantum of information that are positioned in different sections or fields of the document e.g. item information .

At operation B at the application servers event manager modules may identify updates to the database generate events that correspond to the respective updates prioritize the events according to the quality of the data in the event and communicate the prioritized events into event queues that are consumed by consumer modules that service the respective event queues . According to an embodiment the event manager modules and the consumer modules may utilize three event queues to process and prioritize event types. For example the update of the element a in the document in the database may be a price change to item information describing an item for sale that causes the generation of a corresponding event that is associated with a high priority that in turn is communicated into in a first event queue associated with high priority that in turn is received by a consumer module . Similarly the update of the element b in document in the database may be a change to a title of the item that causes the generation of an event that is associated with a medium priority that in turn is communicated into a second event queue associated with the medium priority that in turn is received by a consumer module . Finally the update of the element c in document in the database may be a change to a description of the item that causes the generation of an event that is communicated into a third event queue associated with a low priority that in turn is received by a consumer module . Accordingly the three event queues may be utilized to communicate events in high medium and low priorities to facilitate a preference for the update of high priority events e.g. price over medium priority events e.g. title over low priority events e.g. description . In some embodiments the priority for the respective event types may be configured. Other embodiments may include fewer or more event queues .

At operation C the consumer modules may transform the data in the events and communicate the transformed data via an HBase application programming interface to an HBase master server in an HBase Hadoop cluster that in turn stores the transformed data in one or more tables including an items table in the database e.g. HBase . The transformed data may be stored according to regions that are managed by region server processes . According to an embodiment the database may be embodied as an open source non relational distributed database e.g. HBase that runs on a Hadoop Distributed Filesystem HDFS . HDFS is an open source software framework that supports data intensive distributed applications known by those skilled in the art. The Hbase Hadoop cluster may further includes the HBase master server that is utilized to manage the HBase HDFS environment a scheduler module and an HBase Hadoop node that includes multiple region server processes and a map reduce job module . Each region server process may further be associated with a column not shown that corresponds to a range of documents e.g. or items corresponding to item information in the items table and may be utilized to manage one or more regions not shown that respectively correspond to a range of the documents . For example the documents may be uniquely identified with document identifiers e.g. item identifiers that are numbered from 0 to X where each column and region are dedicated to respective overlapping predetermined ranges of documents e.g. documents 0 100 and documents 0 50 as described further in this document. According to one embodiment the number of region server processes may be in the hundreds but scaling is not limited to any fixed number. HBase is a technology that provides a fault tolerant way of storing large quantities of sparse data featuring compression in memory operation and a space efficient probabilistic data structure e.g. Bloom filters on a per column basis as outlined in the original BigTable paper as is known by those skilled in the art. A table in the database e.g. HBase may serve as the input and output for one or more map reduce jobs that are scheduled by the map reduce job module . The map reduce jobs may be embodied as a map jobs and reduce jobs that runs in HDFS. The tables in the database may further be accessed through the Java Application Programming Interface API but also through representational state transfer REST architecture and other APIs.

At operation D the scheduler module executing in the HBase Hadoop cluster may schedule two index generating sub operations that process in parallel to generate indexes that are subsequently distributed to the query node servers . The sub operations may execute for the generating of a full index and the generating of the mini indexes . The sub operations may further execute for the distribution of the indexes to the query node servers . The full index may be a snapshot of the contents of items table in the database and the mini indexes may respectively correspond to a series of consecutive snapshots where each snapshot captures one or more updates to the items table in the database that occurred within an associated time period of time. The distribution of the full indexes and the mini indexes to the query node servers may be over a network utilizing an index distribution module which is based on Bit Torrent a peer to peer file sharing protocol. In one embodiment the scheduler module may schedule the generation of the full index twice in a twenty four hour period and the generation of mini indexes every five minutes. The scheduler module may generate a full index that is associated with a start time by scheduling a map reduce job module . The map reduce job module may initiate a map step that divides the job into smaller sub jobs e.g. map tasks and multiple reduce steps that consume the output from the sub jobs and aggregates results to generate the index information . Similarly the scheduler module may generate a mini index by scheduling a map reduce job module for execution on the Hbase Hadoop Node may include a map step but not according to one embodiment a reduce step. Accordingly each mini index may be associated with events that arrive from the event queues during a particular period of time and is associated with one or more full indexes . Each index e.g. full and mini may include a bill of material BOM information which describes the content of the index including the index information . The full index may include full index BOM information and the mini index may include mini index BOM information . The index information may include the inverted index and document information as previously described.

At operation E each of the query node servers may receive the full index and the associated mini indexes . The query node servers may be comprised of a search grid that is arranged in columns of query node servers as described later in this document. Each column of query node serves and may be utilized to manage a range of the documents e.g. column as previously mentioned. The index information may be stored in memory of the query node servers and in the database connected to the query node servers . The index information may be updated with the full index responsive to its arrival at the query node servers . Further the index information may be updated with the mini index responsive to its arrival at the query node servers . The index information is generally updated in sequential order. For example the index information are generally updated at the query node server in the order in which the full index and the mini indexes are generated. To this end the full index may be associated with full index BOM information the mini index may be associated with mini index BOM information that are utilized by the query node server to manage the update of the index information . In one embodiment a map reduce job module may include sub jobs that execute on the Hbase Hadoop node to generate inverted indices in the form of region sub indices not shown for part of the region associated with the region server HBase . The sub jobs may further merge or stitch the multiple region sub indices together for the region.

At operation F a second user who operates the client machine may enter a query that may be communicated over a network e.g. Internet via front end servers and back end servers to be received by the query node servers which may be divided into two layers. The two layers may include an aggregation layer and a query execution layer. The aggregation layer may include a query node server that includes a query engine e.g. query module that receives the query that in turn communicates the query to multiple query engines that respectively execute in the execution layer in multiple query node servers that correspond to the columns. The query engines in the query execution layer may in turn respectively apply the same query in parallel against respective the index information that were generated for a range of document identifiers e.g. column to identify search results e.g. document in parallel. Finally the query engines at each query node servers in the query execution layer may communicate their respective partial search results to the query engine in the aggregation layer which aggregates the multiple sets of partial search results to form a search result for the entire index information and to communicate the search result over the network to the second user.

In various embodiments the dictionary generator module may be configured to generate an operator dictionary corresponding to a user or group of users. The information described in the operator dictionary may describe the terms of a query language that may be used in a search query. For instance the operator dictionary may describe a list of compatible operators. An operator that is listed as a compatible operator may be processed by the query processing module for the user of group of users. In various embodiments if the corresponding user or group of users forms a query using an operator not listed in the operator dictionary then the system may not process the query. Each operator described in the operator dictionary may perform an operation on input data also known as an operand. In various embodiments an operator may operate on at least one operand. Operands may also be of various data types. In some instances an operand may be an integer a string a double and the like. An operator may perform an operation using operands of various data types. For example the operator AND may perform an operation using an operand of the string data type and an operand of the integer data type. Moreover the result of an operation performed by an operator may also be of various data types. The operator dictionary may describe a list of compatible data types to be used in connection with each operator in the operator dictionary. The list of compatible data types may describe compatible input data types for an operator. The list of compatible data types may also describe output data types for an operator.

In various embodiments the query verification module may be configured to determine that the terms of the search query are in accordance with the operator dictionary. The query verification module may determine that an operator in the search query is listed as a compatible operator in the operator dictionary. A compatible operator may be processed by the query processing module . Alternatively the query verification module may determine that an operator in the search query is not listed as a compatible operator in the operator dictionary and not processed by the query processing module . The query verification module may also determine that an input to an operator in the search query is of a compatible data type for the operator as described in the list of compatible data types. The query verification module may also determine that an output from an operator is of a compatible data type for the operator as described in the list of compatible data types. In various embodiments a search query is determined to be in accordance with the operator dictionary if all of its operators are listed as a compatible operator in the operator dictionary and if all of the input data types and output data types for each operator are described as a compatible data type.

In various embodiments the query may be represented as an expression tree of nodes that are connected to one another. Each node in the expression tree may include an operator or an operand. The nodes may also be arranged according to a parent child hierarchy in which parent nodes are represented at a level higher than child nodes. A parent node may be connected with at least one child node. In various embodiments data included in the at least one child node may be an input to the operator included in the parent node. The query verification module may verify a search query represented as an expression tree determining that data included in a child node is listed as a compatible data type for an operator included in the parent of the child. Moreover the query verification module may determine that the operator included in a parent node is listed as a compatible operator the in the operator dictionary. The query verification module may traverse the expression tree until all of the nodes in the expression tree are evaluated. In various embodiments a search query is determined to be in accordance with the operator dictionary if all of its operators are listed as a compatible operator in the operator dictionary and if all of the input data types and output data types for each operator are described as a compatible data type.

In various embodiments more than one user or group of users may submit a query to the system . As such the dictionary generator module may generate an additional operator dictionary. The additional operator dictionary may correspond to the other user or group of users. In some instances the additional operator dictionary may be identical to the first operator dictionary. Alternatively the additional operator dictionary may be different from the first operator dictionary. In various embodiments the list of compatible operators from the first operator dictionary may be different from the list of compatible operators from the additional operator dictionary. In various embodiments the list of compatible data types from the first operator dictionary may be different from the list of compatible data types from the additional operator dictionary. In various embodiments because the operator dictionaries are different terms of a search query that conforms to rules listed in the first operator dictionary may be in violation of rules listed in the additional operator dictionary. Moreover terms of a search query that conforms to the rules listed in the additional operator dictionary may be in violation of the rules listed in the first operator dictionary.

In various embodiments the query verification module may be configured to determine that the terms of the query from a user or group of users are in accordance with the operator dictionary corresponding to the user or group of users. For instance a first user may submit a first query with terms that are in accordance with a first operator dictionary. Additionally a second user may submit a second query with terms that are identical to the first query but the second query may not be in accordance with the second operator dictionary corresponding to the second user even though the first and second queries are identical. In this way the system may define the query language used by the first user to be different from the query language used by the second user based on the operator dictionary generated by the dictionary generator module . Alternatively the system may define the query language used by the first user to be the same as the query language used by the second user based on the operator dictionary generated by the dictionary generator module .

In various embodiments the query receiver module may be configured to receive a query from a user to search for document information in the database s of . The query receiver module may receive queries from a plurality of users and the queries from each user may be different.

In various embodiments as soon as the query is verified by the query verification module the query processing module may send the query to the query node servers of in order to be processed.

In various embodiments the presentation module may be configured to send the retrieved document information of back to the user that submitted the search query.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied 1 on a non transitory machine readable medium or 2 in a transmission signal or hardware implemented modules. A hardware implemented module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more processors may be configured by software e.g. an application or application portion as a hardware implemented module that operates to perform certain operations as described herein.

In various embodiments a hardware implemented module may be implemented mechanically or electronically. For example a hardware implemented module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware implemented module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware implemented module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware implemented module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily or transitorily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware implemented modules are temporarily configured e.g. programmed each of the hardware implemented modules need not be configured or instantiated at any one instance in time. For example where the hardware implemented modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware implemented modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware implemented module at one instance of time and to constitute a different hardware implemented module at a different instance of time.

Hardware implemented modules can provide information to and receive information from other hardware implemented modules. Accordingly the described hardware implemented modules may be regarded as being communicatively coupled. Where multiple of such hardware implemented modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the hardware implemented modules. In embodiments in which multiple hardware implemented modules are configured or instantiated at different times communications between such hardware implemented modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple hardware implemented modules have access. For example one hardware implemented module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware implemented module may then at a later time access the memory device to retrieve and process the stored output. Hardware implemented modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

Similarly the methods described herein may be at least partially processor implemented. For example at least some of the operations of a method may be performed by one or processors or processor implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processor or processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. Application Program Interfaces APIs . 

Example embodiments may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Example embodiments may be implemented using a computer program product e.g. a computer program tangibly embodied in an information carrier e.g. in a machine readable medium for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers.

A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

In example embodiments operations may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method operations can also be performed by and apparatus of example embodiments may be implemented as special purpose logic circuitry e.g. a field programmable gate array FPGA or an application specific integrated circuit ASIC .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In embodiments deploying a programmable computing system it will be appreciated that that both hardware and software architectures require consideration. Specifically it will be appreciated that the choice of whether to implement certain functionality in permanently configured hardware e.g. an ASIC in temporarily configured hardware e.g. a combination of software and a programmable processor or a combination of permanently and temporarily configured hardware may be a design choice. Below are set out hardware e.g. machine and software architectures that may be deployed in various example embodiments.

The example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard or a touch sensitive display screen a user interface UI navigation device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes a machine readable medium on which is stored one or more sets of instructions and data structures e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable media.

While the machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium may include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more instructions or data structures. The term machine readable medium shall also be taken to include any tangible medium that is capable of storing encoding or carrying instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention or that is capable of storing encoding or carrying data structures utilized by or associated with such instructions. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media. Specific examples of machine readable media include non volatile memory including by way of example semiconductor memory devices e.g. Erasable Programmable Read Only Memory EPROM Electrically Erasable Programmable Read Only Memory EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks.

The instructions may further be transmitted or received over a communications network using a transmission medium. The instructions may be transmitted using the network interface device and any one of a number of well known transfer protocols e.g. HTTP . Examples of communication networks include a local area network LAN a wide area network WAN the Internet mobile telephone networks Plain Old Telephone POTS networks and wireless data networks e.g. WiFi and WiMax networks . The term transmission medium shall be taken to include any intangible medium that is capable of storing encoding or carrying instructions for execution by the machine and includes digital or analog communications signals or other intangible media to facilitate communication of such software.

Although an embodiment has been described with reference to specific example embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. The accompanying drawings that form a part hereof show by way of illustration and not of limitation specific embodiments in which the subject matter may be practiced. The embodiments illustrated are described in sufficient detail to enable those skilled in the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. This Detailed Description therefore is not to be taken in a limiting sense and the scope of various embodiments is defined only by the appended claims along with the full range of equivalents to which such claims are entitled.

Such embodiments of the inventive subject matter may be referred to herein individually and or collectively by the term invention merely for convenience and without intending to voluntarily limit the scope of this application to any single invention or inventive concept if more than one is in fact disclosed. Thus although specific embodiments have been illustrated and described herein it should be appreciated that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all adaptations or variations of various embodiments. Combinations of the above embodiments and other embodiments not specifically described herein will be apparent to those of skill in the art upon reviewing the above description.

