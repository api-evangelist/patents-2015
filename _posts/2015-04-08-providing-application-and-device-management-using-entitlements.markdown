---

title: Providing application and device management using entitlements
abstract: An Application Workspace System (AWS) enables users to access remote server-based applications (e.g., thin client applications, terminal server applications, applications on hosted operating systems, etc.) using the same interface that they use to access local applications, without needing to know where the application is being accessed. The AWS automatically determines which applications the user is entitled to use, and then figures out automatically, based upon a variety of parameters, which applications are to be made available to the user (resolved to version, particular package etc.), and whether they are to be installed locally, or accessed remotely. This abstract is provided to comply with rules requiring an abstract, and it is submitted with the intention that it will not be used to interpret or limit the scope or meaning of the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256353&OS=09256353&RS=09256353
owner: VMware, Inc.
number: 09256353
owner_city: Palo Alto
owner_country: US
publication_date: 20150408
---
This application is a continuation of prior U.S. patent application Ser. No. 14 595 194 filed Jan. 12 2015 entitled Providing Application and Device Management Using Entitlements which is a continuation of prior U.S. patent application Ser. No. 13 193 471 filed on Jul. 28 2011 now U.S. Pat. No. 8 935 429 entitled Providing Remote Application Access Using Entitlements which is a continuation of prior U.S. patent application Ser. No. 11 643 020 filed on Dec. 19 2006 now U.S. Pat. No. 8 010 701 entitled Method And System for Providing Virtualized Application Workspaces each of which is incorporated herein by reference in its entirety.

The present invention relates to methods and systems for providing an applications workspace and in particular to methods and systems for automatically providing seamless access to different types of applications and configuring them on a per user basis appropriate for the point of access.

Multiple waves of technology have left most organizations with IT infrastructure that is complex inflexible and expensive to run. People devices and applications are tightly coupled making it difficult to rollout new applications or support new work patterns. IT organizations within corporations have to manage a hundreds if not thousands of applications based on divergent technologies and run thousands of PCs and servers each with its own operating requirements and idiosyncrasies.

Maintaining software on a distributed PC or other access device is expensive and time consuming. As the number of applications and services provided through the PC the complexity of the PC configuration increases.

Historically this problem has been addressed by locking down the PC to limit the changes that can be made to it. Products have also been introduced to push software to physical devices but these approaches depend on there being a small well defined number of access devices as well as a relatively infrequent update cycle. Until a few years ago this was difficult but achievable in a well managed environment. However an explosion in the number and type of access devices which now encompass PCs laptops PDAs and mobile phones combined with a need for frequent real time updates to protect against viruses worms and security loopholes has rendered such an approach unworkable.

In large organizations the problem of access device diversity is compounded by the fact that end users use applications that run on many different platforms. Some run on the user s PC some run centrally as terminal applications thin clients or web services and some run on virtual machine technology. Previously the infrastructure for supporting and managing these applications was entirely separate.

Embodiments of the present description provide enhanced computer and network based methods and systems for determining applications to which a user is entitled and providing seamless and uniform access to these applications regardless of their type and where they are accessed from. Example embodiments provide an Application Workspace System AWS which enables users to access remote server based applications e.g. thin client applications terminal server applications applications on hosted operating systems etc. using the same interface that they use to access local applications without needing to know where the application is being accessed. The AWS includes a set of client and server components that implement the notion of a user s virtual workspace which is presented to the user either seamlessly integrated into the native user interface such as Windows Explorer or via a web portal which presents a virtual desktop.

The AWS automatically determines which applications the user is entitled to use and then figures out automatically based upon a variety of parameters which applications are to be made available to the user resolved to version particular package etc. and whether they are to be installed locally or accessed remotely. Entitled as used herein refers to more than just a concept of access permissions it involves evaluating a series of rules that specify how applications have been administered for what users and to run in what environments. The parameters that influence this decision define for example the user the access point the device from which the workspace is accessed the delivery method remote local etc. the user s entitlements application administration parameters etc. Applications can be associated with users in a generic fashion so that they can be dynamically bound to a user s access at various times. Thus the AWS can separate out the administration of applications to users generically for example assigning a word processing application to a user from the administration of actual application implementations that correspond to different versions packages delivery methods etc. In this manner seamless integration of both local and remote applications is made possible.

In the case of applications that are installed locally the AWS provides for the customization of the configuration and behavior of such applications via scripts that hook system events such as login power down etc. or disconnect or reconnect on terminal servers. In the case of remote applications that are made available for example through a terminal server extensive application behavior modification is supported using a rules based engine.

The AWS also provides a generalized message bus that can be used for load balancing and resource discovery.

In addition the AWS provides a generalized LDAP replication mechanism using XSLT stylesheets that can replicate data between heterogeneous schemas. The use of XSLT for replication is extendible to other directory server mechanisms or other information consuming processes that entail heterogeneous data organizations.

The following description details an example embodiment of an Application Workspace System called Workspace or Propero Workspace. Other implementations of the various principles methods techniques components protocols etc can be incorporated to provide other embodiments of an AWS. Thus the present description means to include all such possible embodiments of an AWS.

The Application Workspace System implements an abstraction referred to as a virtual workspace that integrates seamlessly into whatever device environment a user uses to access applications. On a personal computer running Windows for example once configured applications appear as icons which can be opened to start an application running i.e. to launch an application . The AWS automatically configures the user s environment so that the user need not know the particular application that is being run from a version package perspective or from a location perspective an application may be run locally or remotely.

The AWS abstracts the notion of an application so that the task of associating applications with users is separated from the administrative task of mapping particular implementations of the applications to different access devices from where the application is accessed and how the application is accessed e.g. a portable or desktop . For example the directory services e.g. LDAP setup of application implementation mappings is an administrative task that need not involve lay users.

To accomplish this abstraction applications are modeled as belonging to an application family that represents the application in an abstract sense e.g. Office . Thus for example all kinds of different versions of Microsoft Office may be abstracted as a single family Office. Specific applications that can be thought of as instances of those application families called application objects delivered via specific means e.g. Microsoft Office 2003 Local OpenOffice for Mac Local Microsoft Office 200 Remote . This information is stored in an AWS configuration repository which is typically an LDAP directory although equivalent storage repositories protocols and directory servers may be used.

Stored within the application family object in the configuration repository are a set of rules sometimes referred to as policy that describes how an application family is to be resolved to a specific application instance at the point of use. Point of use also referred to as point of access herein refers to a description of the environment where from the user is attempting to access a particular application. For example a mobile device being used while traveling abroad typically will be characterized as a different point of use than the user s home personal computer. As a result the AWS may desire to give the user access to a different application instance than the user normally uses while at home.

Entitlements comprise the definitions including all the attributes of the set of application family objects application objects including all relevant sub objects such as document types and launch items associated package container objects and package objects along with tuples from all the users user groups that a given user may have available to him or her at any time. A set of entitlements for a user can be derived from the AWS configuration repository. A process referred to as entitlements resolution further refines a set of entitlements to the set of application objects and hence the relevant associated objects from the set listed above that a user actually has available to him or her at a particular point in time.

Assignment of applications in the general sense to users is accomplished by creating links in the AWS data model between users and application families thus allowing for non IT literate administrators to manage which applications their users need to be able to use without having to be cognizant of the various versions and delivery mechanisms that may by appropriate at specific locations or from specific access devices such as via a PC or a PDA .

The abstraction of applications breaks the administration of applications into two areas user administration which describes which users are associated with which applications families and application administration which is typically an IT information technology function that provides the rules indicating under which circumstances an application family resolves to a specific application. Note that user administration may administer to any defined group instead of to an individual user using any type of grouping mechanism. Groups may also substitute for other entities in the AWS data model.

Note that for the purposes of this description the term application is used to mean a set of modules code script text or other represented code and or programs that execute on either hardware machines or higher level virtual machines or are executed by other programs that overall allows a user to achieve some task using the computer i.e. apply the computer to a task . Also a package is a specific set of modules code script text or other represented code and or programs that execute on either hardware machines or higher level virtual machines or are executed by other programs that are delivered together in some manner. Thus an application comprises one or more packages. Within an AWS configuration repository application objects are used to represent applications and package objects are used to represent packages.

Note as well that the term local or remote with reference to applications indicates where relative to the user processing occurs in order for the user to achieve the task using the application. Note that this is distinct from where the user interacts with the application through an input device e.g. screen keyboard mouse etc. as the use of the input device typically will be on the computer the user is physically interacting with.

When a user attempts to login to the user s environment and at other times the AWS attempts to automatically determine the virtual workspace for that user from the point of access. In the case of a computing device such as a desktop computer this determination process results in presenting the user with a set of icons on the desktop that map to particular applications. As an effect of this process local applications are properly configured installed removed customized and possibly updated and remote application access is integrated into the virtual workspace. That way when a user clicks on an icon to invoke the underlying application the right thing just happens be it local or remote. Which applications are installed or configured is determined based upon a process referred to as entitlements resolution. 

Entitlements resolution is the decision process that resolves an application family object to an application object so that the corresponding application instance can be made available to a user. This is performed at the point of use and has various pieces of information made available to it from the environment and from the AWS data model. Such information includes for example location network address access device type pre defined tuples for example name value pairs that may be stored on the access device and tuples that are associated with any application object in the AWS data model.

Entitlements resolution typically takes place at a point of entry to the system in many implementations this can be one of two places 

The entitlements resolution process can result in the AWS needing to transparently install or configure or remove or otherwise manage locally installed applications. It can also result in automatically presenting to the user applications that the user is able to use remotely for example if no local application availability is present or for example to possible override a locally installed application in favor of a remote one . In order to achieve access to remote applications any icon or link representing the application includes an encoding of a primary key of the application object in the configuration repository usually a Distinguished Name a DN to an LDAP object . This identifying key is used to get information from an AWS configuration repository regarding the details needed to run the application.

Note that many different kinds of remotely accessed applications can be integrated into an AWS. For example an AWS can integrate and support terminal server applications which run applications in sessions specific to a client access and which are isolated from other applications Citrix applications which provide an extension to the general case of Terminal Server applications Terminal Emulators for character based protocols virtual machine environments such as hosted operating environments using for example VMWare on demand application streaming and any other form of application delivery. The general distinction that the AWS draws between a local and a remote application is that a local application is some form of code script or otherwise that executes locally on the user s computer in a manner native to the local computer s native operating system to perform the functions of the application whereas a remote application has some form of code script module or otherwise executing on a computer other than that which the user is using and any code in that instance that executes locally on the computer the user is using does so only to provide screen keyboard and mouse functionality for that remote application.

If the entitlements resolution process results in providing a user with access to remote applications then the mechanism by which they are actually launched described in detail below uses web based components and systems that are common to both access from a workstation running components of the AWS e.g. a managed workstation and from a workstation running a browser with a Java Virtual Machine that is used to navigate to a web based portal e.g. an unmanaged workstation . In some embodiments the behavior of remote applications is automatically modified to behave properly when they are launched at their point of use. Behavior modification of applications is also described further below.

Different implementations of an AWS may present different sets of components and services to effectuate the notion of a virtual workspace. In an example AWS the Propero Workspace the Workspace or workSpace includes a set of tools modules data schemas data models etc. which are delivered to customers as a set of integrate able components and or services. A typical AWS includes a manager component a server component and an analyzer component.

The manager component comprises a set of modules downloaded to a client machine to allow a user to install and run applications locally or as a terminal to remote applications which are automatically configured and customized on a per user basis and for the user s environment. A node manager component of the manager component provides a majority of the AWS support for installation and configuration event based script customization of applications and communications with the server component.

The server component comprises the entirety of network e.g. web based components that support access from intelligent workstations and access from browsers via a portal . These components include the ability to perform entitlements resolution user administration application administration application personalization and behavior modification etc. and implement the virtual workspace.

The analyzer component comprise an extensive set of tools which are used to assist administrators in determining mappings for applications to application families exclusions conflicts dependencies which users use which applications etc. A kernel manager component of the analyzer performs application usage based upon detecting a variety of activities at levels of actual use not just invocation on both intelligent workstations and on terminal servers. The detection occurs by hooking various system code to be made aware when certain events are triggered.

Example embodiments described herein provide applications tools data structures and other support to implement a Application Workspace System to be used for automatic and transparent configuration and customization of applications and seamless integration of remote and local applications in a virtual workspace. Other embodiments of the described techniques may be used for other purposes. In the following description numerous specific details are set forth such as data formats and code sequences etc. in order to provide a thorough understanding of the described techniques. The embodiments described also can be practiced without some of the specific details described herein or with other specific details such as changes with respect to the ordering of the code flow different code flows etc. Thus the scope of the techniques and or functions described are not limited by the particular order selection or decomposition of steps described with reference to any particular routine.

Note that the use of the term workstation is a matter of ease of description is not meant to convey a specific arrangement of hardware or software. Essentially any computing device capable of performing the functions indicated can be substituted where this description uses the term workstation. Thus workstations may be mobile or wired device embedded systems PDAs cellular devices etc.

Node Manager comprises a set of services modules and code for supporting the functions of an AWS to implement a virtual workspace. The node manager provides all the necessary functions for packaging installation scripting management diagnostics tracing and any ancillary functions that AWS uses. In particular the Node Manger comprises event runtime and script object support installation scripting monitoring image comparison and custom services security support and support for network communications for example with the AWS web services.

Note that in some embodiments some of the code of the Node Manager because it performs smart configuration can also be used by terminal servers to configure remote applications made available through terminal servers because many of the same functions are needed to configure remote applications. For example the Node Manager code may also be used for Windows Terminal Servers and Citrix Servers as a system service. This shared code is mainly a figment of efficient implementation though and is not a requirement of an AWS.

The user session s instances comprise all of the local support needed to interface to local and remote applications using AWS. It typically includes instances of the Node Manager session support that are specific to the user and the particular session terminal emulation support for interfacing to remote applications a JAVA virtual machine although other languages and virtual machines could be similarly incorporated a web browser and the configured user applications . Other components can of course be present as well.

As mentioned the components of the AWS are used to implement a virtual workspace which transparently delivers access to the right application for the right user for the right point of access at the right time by abstracting out the notion of an application. To support this abstraction the application information mappings to other objects application packages which define how an application is configured installed etc. are set up in the configuration repository typically by an administrator. Application packages are discussed further below with respect to installation of local applications. Application packages can contain scripts that are automatically triggered upon the detection of certain system events such as logon . Users can also be assigned to application families through the entitlements set up procedures. Once entitlements are set up users use the workSpace to launch applications in a manner with which they are familiar and the right thing automatically happens. The node manager on a managed workstation or a browser invokes workSpace server components to automatically configure the virtual workspace process launch requests configure applications etc. In addition a kernel manager component runs in certain scenarios such as on terminal servers to ensure that applications behave properly when they are run remotely. In overview the kernel manager configures remote applications such as terminal server applications to trap certain events such as file access requests to ensure that applications behave properly as they may have been written to operate as single user applications and not share resources appropriately.

More specifically steps present an event handling loop. in step when the code detects a logon event the node manager resolves the entitlements relevant to that user and access point step transparently installs or upgrades as necessary mandatory applications step including rebooting the system if the application install upgrade requires such and then presents a portion of the virtual workspace with information to allow the user to further configure applications step . is an example screen display that results from the processing shown in steps . In step when the code detects a request from the user to install upgrade one or more applications then in step the Node Manager resolves entitlements and proceeds to install or update the indicated applications. In step when the code detects a request from the user to launch run or execute an application the Node Manager proceeds in step to launch a local or remote application as indicated. In step when the code detects a request to manage a for example terminal session the Node Manager presents a user interface in step that allows the user to manage the session.

Details of how an administrative sets up application packages for installation are described further below with respect to and . Details of the entitlements resolution process are described further below with respect to .

Note that once the applications are installed updated the user can launch local applications on the managed computing device using the native operating system mechanism. The AWS does not intervene. However it is possible for someone e.g. an administrator to associate shortcuts with specific AWS events and thus be able to perform custom script actions before applications are launched and at other times in the system.

As mentioned a user can launch a remote application from a managed computing device as well. Each application object when configured by the AWS contains launch item objects and document type objects. For launch item objects these consist of a name e.g. Microsoft Word an icon and a location attribute e.g. Program Files Microsoft Office . The AWS Manager generates a shortcut in the location as specified in the location attribute with the specified icon and name but referencing a identifier which is generated to include the address of a component in the AWS Web Services and encoded with a parameter which is set to the identifying key of this launch item. As a result when a user clicks on one of these shortcuts a web browser is launched which sends a request to the AWS Web Services which launches the remote application.

Typically the access device is only aware of the identification key of the remote application. Note that it is common for these keys to point to sub entities of the remote application cf with an installed application having more than one icon that starts a subcomponent of the application . These identification keys are coded into shortcuts or links on the desktop or if applicable the portion of the access device s UI commonly used for application related links.

In addition the system is configured with document types also known as file extensions or file associations which are similarly linked to an identification key of the remote application that can handle that document type. There may be various implementations of a shortcut link launch item or dock item that represents an identification key that all achieve a common purpose namely that of notifying a component on the access device that the user has selected or click on that shortcut or link.

When a user clicks on one of these links in order to request or launch the associated application or by selecting a document of a type configured to be associated with a remote application the identification key encoded as a URL is sent to the system AWS Web Services.

Note that similar to a managed computing device when a user activates an icon in a web page rendered by the AWS web server on an unmanaged computing device the mechanism for launching the application is similar. Most of the steps of are executed the designation of the user and application however arrive from the AWS web browser interface.

In an AWS such as the workSpace users can view and manage existing sessions with remote applications. In the case of an unmanaged computing device a user can use various user interface UI controls elements provided by the AWS Web Services to view and manage existing sessions such as disconnect them reconnect them and to kill executing processes within them if available . In the case of a managed computing device the AWS Manager interacts with the AWS Web Services to retrieve the session data and then presents this data using its own UI elements usually handled by the Node Manager Session Support in .

To perform session management on the unmanaged device typically a session controller component of the AWS Web Services queries appropriate other components for any current sessions that exist for the calling user. The session controller compiles a session list and encodes each session into a Session ID that is unique across all sessions. This session ID has the form SessionManagerID domain username uid ID serverDN protocol.

The session controller parsers the SessionManagerID to locate a component responsible for the session then the rest of the text is passed to that component. The domain and username identify the user the ID identifies the actual session itself on the backend server the server DN identifies the backend server in LDAP and the protocol is the physical protocol used to connect to that backend server as some components may support more than one protocol .

As mentioned previously the AWS abstracts users from applications using a concept of an Application Family. are example block diagrams of the interrelationships between Application Families Applications Application Folders Users User Groups User Folders Packages and Package containers used to provide the AWS application abstraction model. describes the mapping between users user groups and user folders. Users are individuals are stored as entities in a directory containing standard fields like a user s name and login information. User entities also contain links to the applications that the user is entitled to use.

In order to make the administration of large numbers of users more convenient they can be grouped together and managed as a single unit. There are two ways of performing this grouping user folders and user groups. User folders are structures akin to directory folders within a filing system. Each user is contained in a single user folder that may in turn be nested inside a parent user folder. User folders provide inheritance. In the example shown in if the application Excel were assigned to the user folder United Kingdom and the application PowerPoint were assigned to the folder London the user Joe Bloggs would be entitled to use both Excel and PowerPoint while the user Jane Doe would only be entitled to use Excel .

User groups are looser structures that allow users from anywhere in the user folder structure to be grouped together independent of that folder structure. Like user folders user groups can be used to assign applications to multiple users at one time. User groups cannot be nested inside one another nor is there any inheritance between them.

Applications in the AWS separate the business oriented concept of a particular application like Microsoft Word from the technical details of the package s that are used to deliver it like office2003.msi and office2003sr2.msi . This separation allows changes to be made to the way that an application is delivered without having to change the entitlements of users to that application. As shown in there are three different application entities to allow flexibility in the specificity of application entitlements. These are application families application groups and applications. For example a user can just be assigned Microsoft Word to get the latest version or be assigned a specific version such as Microsoft Word 2003 .

Application families allow entitlement assignments without concern for which version or platform of the application is used. For example the application family Microsoft Word could be linked to separate application instances for the Windows and Macintosh editions. Entitlements processing will ensure that users assigned Microsoft Word would get the appropriate edition for their platform.

Application groups allow a group of applications to be bundled together and assigned as a single unit. With the example shown in users can be assigned the group Front office Applications to get the latest versions of PowerPoint and Excel while stipulating a specific version of Access. 

Application instances describe specific versions of applications they are what is ultimately presented to users on the Start Menu or elsewhere. Generally application instances are only directly assigned to a user if the user requires a specific version of an application.

So while Application Families and Package Containers are the objects that are assigned both in terms of an Application Class to a user and a Package Class to an application instance the AWS then decides based on the runtime environment which application and package if a local application is actually required and installed. This installation information is then stored on the workstation and associated with the users profile to allow for future decisions such as exclusions to be made. Applications as modeled in the data model described by can contain dependencies and exclusions dependencies are applications that must be available locally if this application is to be available locally and exclusions are applications that if already are available locally will prevent this application being made available locally.

The term Application or Package may be used to refer to the configuration item in the configuration repository representing the application or package or it may refer to the application or package itself depending upon context. In most cases this description appends object when meaning the configuration item in the configuration repository.

User objects are stored in hierarchy within the configuration repository. In an embodiment that uses an LDAP implementation the AWS uses standard LDAP schema concepts of Organizational Units OUs to support this abstraction.

User Group objects contain sets of DNs Distinguished Names the LDAP concept of the primary key of an object pointing to the users in the OU hierarchy and DNs to application objects application family objects and application group objects. They exist as LDAP object classes groupOfUniqueNames and pae UserGroup stored under ou Groups and contain for example 

Application groups are groups of DNs pointing to applications in the application Directory Information Tree an LDAP term referring to an area within the LDAP directory and may well point to another application group. They exist as LDAP object classes groupOfUniqueNames and pae ApplicationGroup stored under ou Groups and contain for example 

Application objects are chosen based on the policy as held in the application family object. A policy is a set of rules that describe which application object a particular application family object resolves to at a particular point in time and at a particular point of use. This policy may be partially resolved by the entitlements support of the AWS Web Services as some parts refer to information that is only known at that point such as the method of authentication to the AWS and partially resolved by an AWS Node Manager based on information available locally to the managed workstation such as packages already installed on the computer .

Policy is stored in the application family object as a goal of entitlements resolution is to resolve an application family object to an application object for that user at that time. While it is possible to assign an application object directly to a user object in the configuration store this may not be advisable as it may result in the system attempting to do something inappropriate e.g. installing the wrong application on the wrong operating system or attempting to provide a remote application when there is no network connectivity etc.

The nature of expressing circumstances is through the use of the name value tuples e.g. name value pairs . These name value pairs are available in the query language and can form part of the expressions. In addition the environment and user name value pairs are available to the expression in the form of expansion variables that take the form Variable . Finally some de facto variables are available most notably the key of the application family object in question and environmental information such as whether a network connection is present the IP address and DNS name of the computer etc.

Each rule of the policy exists in an ordered list. This list is then evaluated in order with each successful evaluation i.e. the policy returning a value resulting in that value being pushed onto the back of a vector which represents the result of processing the policy for that application family object.

Example If one is already installed use that. Otherwise application is not available. applicationClass WSID AND installedApplicationInstance IS NOT NULL 

A policy has three flavors LOCAL REMOTE ALL BOTH. The three flavors are because there are two different scenarios when a user can access workSpace 

Once an application family object has been resolved to an application object if the application object represents a local application then package objects must then also be determined and associated with the application because packages are the ultimate item that gets physically installed on the computer to enable the application to function. One reason for the existence of package containers is that when using Windows Installer Packages MSIs it is necessary to remove using the path to the old MSI and install upgrade using the path to the new MSI. As a result the locations of both need to be available at the time of an upgrade so simply modifying an existing package object to point at a new MSI would not be sufficient. The package containers allow administrators to group together the information needed for such removal.

Packages to be installed locally can be vendor supplied installation packages that do not require any further modification or they can be packages generated by the AWS. An example embodiment of the AWS packaging mechanism splits an application package into three separate parts SYSTEM containing shared data that is common across the whole computer system USER containing information that is stored for each user and WSM that contains scripts which can perform configuration tasks when certain events are triggered.

The AWS creates a package using a mechanism of capturing the state of a sample access device similar in nature to the access device that the package will eventually be installed on . This is not a run time task but an administrative task. The application is installed from its source media onto that same access device. The AWS then captures the state of the access device after the install as above has occurred but applies rules to decide which parts of that install can be classified as SYSTEM i.e. applies to all users and does not require access to any user specific configuration areas on the access device and which parts can be classified as USER i.e. are user specific and would need to be added to any user specific configuration areas on an access device before a user was able to properly use that application on that access device . The system contains a default set of rules that may be provided to the Node Manager by the AWS Manager Workbench at the time the package is created but they can be adjusted if required.

This package can then be adjusted using tools available in the system the Workbench and can have scripts added to the package that are triggered by the system when certain events occur see described below . Also this package can be digitally signed by the system to prevent tampering before being delivered to target access devices.

Once adjusted this package can then be placed in the AWS package repository this process also involves configuration data relevant to the package being added to the AWS s configuration database usually a replicated LDAP directory .

As mentioned one of the features offered by the AWS application abstraction mechanism is that associations between the concepts of applications and users are actually between users and application families.

Administrators can associate application family objects with users groups etc. by using direct manipulation techniques such as drag and drop . is an example screen display of a user interface provided by an example AWS Web Services for associating application objects and application families with users in an example configuration repository. In an application object GAIM for Windows is begin assigned associated with user test . Application families can be assigned in a similar manner. One can observe that the user test is a member of a user folder people but is not part of any groups . Hyperlinks provide easy access to other parts of the data model that may be configured.

In one embodiment of the AWS the association between the user and application family is stored in LDAP as a DN link as an attribute of the user object in LDAP pointing to the Application object in LDAP. Where groups are used the groups act as a form of intersection between the two objects that is they contain a list of DNs to the application objects and a list of DNs to the users who are members of the group.

Configuration and personalization of applications either on the managed workstation i.e. local applications or on application servers that are participating in the system e.g. Terminal Servers occurs when specific events are generated on these computers. In one embodiment of the AWS a Node Manager component of the see for example Node Manager in is a daemon process that resides on these computers and that causes the execution of scripts associated with application packages in response to certain defined system events triggers . The Node Manager daemon is an asynchronous message based component that can respond and deliver events that can execute scripts either with elevated privileges root or administrator privileges or in the context of any user currently logged into the computer. In the event runtime and script object support is responsible for the event based script system.

In order for customization to occur an administrator needs to have defined scripts and associated them with the application object of interest. Adding scripts to a package to be triggered upon events can be performed using the AWS Manager Workbench. As described above each package has three parts called features which include the SYSTEM USER and WSM features. WSM stands for workSpace Manager and is the portion into which scripts are stored. In package information contains the three portions . The scripts property is showing one script defined for a CONFIG event .

Table 1 below includes explanations for example events which can trigger the execution of scripts associated with an application package 

Note that scripts have access to all of the tuples e.g. name value pairs configured for that package in the configuration repository as well as tuples for all applications already installed on the local computer so that application level settings can be shared as well as tuples configured for that user and associated groups. There are a number of different precedent orders that can be applied when merging the set of tuples to deal with tuples that have the same name . These tuples typically exist as a multi valued string attribute on each object in the configuration repository.

By nature of being able to manage configure and supply configuration information via these tuples stored in the AWS configuration repository the AWS as a whole is able to deliver manage configure and personalize applications for users. For example a script that responds to changes in the network state could change the default document location of a word processor to the user s home directory on a network server if the network is present and to a local directory on the computer when the network is no longer present.

Of note the scripts execute in an environment that allows full remote debugging of their execution even though they are asynchronously triggered. is an example screen display of a debugger of an example Application Workspace System used to debug a script. In addition the AWS supports an Application Programming Interface API for script object capabilities. An explanation of the API for script objects is included in Appendix D which is hereby incorporated by reference in its entirety.

The AWS Node Manager implements an asynchronous event handler for invoking appropriate application scripts when an event is triggered. Events can be system triggered or defined by the AWS. In one embodiment events are triggered by four distinct mechanisms 

Each time one of these external events occurs an external event handler e.g. a WMI subscriber a SENS subscriber etc. calls the Node Manager daemon process either through an internal API or by invoking WSUTIL with the name of the event see SCRIPT EVENT XXX definitions specifies the target queue service name as the script service ScriptManager with ID E8F61878 8DA6 494c 829D 017773AF1F05 and builds a parameter block if appropriate containing parameters for the event e.g. a network connect event may indicate which interface was connected at which speed .

In particular the script name for a package that is part of an application is stored in the installed database on the managed computing device as it was an attribute of the package object that led to the installation of that package. Each script is stored in a sub directory named according to the external event type. For example if a package had a script name of TEST and defined a script for STARTSCREENSAVER and STOPSCREENSAVER then the actual files on the disk would look like 

By querying the installed database the Node Manager can build a list of script names to execute. By examining the name of the event as passed to it it can identify the directory in which to find the scripts. Thus it is able to execute the correct scripts for the event. If no username is passed in then the Node Manager by default will execute all the scripts for that event.

In step the handler obtains the relevant name value tuples that correspond to the applications and their associated family objects and associates them as appropriate with the scripts. The handler then returns to the beginning of the loop in step . In step when all applications having scripts triggered by the current event have been handled then the handler obtains name value tuples for users and for the user s groups. Finally in step the accumulated script objects are executed.

In order to be able to provide personalized customization for the applications each script needs to have access to the correct tuple set for the user for that application. Therefore for each script that is executed a set of tuples also referred to as NVPs or Name Value Pairs is compiled that the script can access.

The installed database records all the tuples associated with users application objects and the associated application family object that resolved to that application object and package objects that Node Manager has installed. These are stored in the installed database with their owning object allowing the Node Manager to build different sets of tuples at different times. These sets are refreshed every time Node Manager reads an entitlements document thus allowing new configuration values that administrators may set in the configuration repository to be used even if the application package has already been installed. 

Therefore whenever a script needs to be executed NM builds a set of tuples from the installed database that is correct for that package. The precedence order of building this set is as follows 

Appendix C incorporated herein by reference in its entirety provides an example Visual Basic script that configures GAIM Instant Messaging for each user. This is the script used in and A L. The script accesses tuples to write configuration files for GAIM. The per user tuples are jabberid jabberserver jabberalias jabberpassword jabberconfroom jabberconfserver. The application level tuple in this instance is jabberresource Note that for the sake of this example plain credentials have been used. Normally these would be encrypted . These are the same tuples shown in .

Referring back to once all of the various administration of applications and users has taken place and the entitlements have been stored in the configuration repository for one or more users applications application families etc. it is possible for the AWS to perform its automatic configuration and personalization when the relevant events are on a managed computing device. Steps overview what happens when a logon event triggers thereby triggering the WSUTIL script described above. Specifically upon receiving notice that a user has logged on the AWS performs entitlements resolution to figure out which applications to install upgrade automatically installs upgrades certain applications and presents a user interface to the user for further installation and or upgrade.

Entitlements resolution is the overall decision process that takes information stored in the AWS configuration repository and decides which applications a user is allowed to use over which delivery mechanisms and at the point of use. Thus entitlements resolution is central to providing a virtual workspace. The AWS resolves the application families that are assigned to a user into the actual applications that are to be used at the point in time they are being requested whether local or remote.

In one embodiment entitlements resolution is performed by an AWS Node Manager querying the Entitlements Support and Information Services components for entitlement information and then performing a rules based set of actions as described above in the discussion regarding policy.

Entitlements resolution is typically performed whenever a new user logs into the system as described with reference to however refreshing this information can be done at any time. For example an event that refreshes the user s entitlements and associated information can be triggered from scripts the command line or from menu options within the user interface of an AWS Node Manager.

Specifically in step the service determines the designated user either from the request itself via optional parameter or implicitly from an authentication request. In step the service determines which user the user ID corresponds to the designated user and retrieves the groups the user is a member of from the configuration repository. In step the service determines the name value tuples that correspond to the designated user and the user s groups. In step the service determines which application family objects have been associated with the designated user or the designated user s groups. In step the service determines all of the possible application objects that could be available to the designated user by looking at the application object associations of each determined application family object. In step the service determines all of the possible package objects and package object containers that correspond to the determined application objects that are local. In step the service populates an output report here an XML entitlements document with all of the determined and retrieved information from the configuration repository. In step the output report is returned to the request and the processing completes.

Thus after processing in the example embodiment the information stored in the XML entitlements document includes 

Appendix A incorporated herein by reference in its entirety is an example entitlements document stored as an XML document.

Specifically in step the service determines the designated requestor typically a user ID associated with the web browser interface or the AWS Manager . In step the service requires the information services component which interfaces to the configuration repository to retrieve information specific to the requestor. In step the service queries the information services component to retrieve a profile based upon a set of current attributes as described above. In step the service matches the retrieve requestor information to the retrieved profile to make sure the profile is applicable. At this point in step the entitlements support sends a request to the Information Services e.g. the LDAP support to obtain an entitlements document as described with reference to based upon the user ID associated with the designated requestor. When the entitlements document is received then in step the service resolves all of the policy rules for REMOTE and for ALL or BOTH using the retrieved profile. In step it then returns the entitlements document with answers to the rules it resolved to the requestor.

Note that although many of these service routines are shown in the flow diagrams as sequential steps it is to be understood that many of these services are written as asynchronous event handlers that process requests and data as they arrive. Equivalent synchronous flows are correspondingly incorporated.

At this stage the entitlements document retrieved from the AWS Information Services contains a list of application family objects that have been assigned to the user or via group memberships and the partially resolved policy document from the entitlements support contains a partial resolution of the policies contained in the entitlements document. The next step is for the AWS Node Manager to resolve these entitlements into vectors of possible application objects. The reason that vectors are used rather than single items is to provide alternatives if a user does not select the most appropriate application e.g. the one at the beginning of the vector . If another application is available then the Node Manager will use it instead. For example if a local install of an application is not desired and a remote one is available then the Node Manager will make available the remote application.

In summary the routine performs a loop on each application family object found in the entitlements document and evaluates each corresponding policy resolving the results where appropriate with the information returned by the partially resolved policy document. Specifically in step the routine processes each application family object starting with the first. In step the routine determines whether there are more application family objects to process and if so continues in step else continues in step . In step the routine determines whether there are more policy statements to process and if so continues in step else returns to the top of the outer loop to obtain the next application family object to process. In step the routine evaluates the next policy statement in priority order. In step if the policy statement is tagged as LOCAL then the routine continues in step . If in the policy is not tagged as LOCAL then in step then determines whether the policy statement is tagged ALL or BOTH in some versions . If so then the routine continues in step otherwise continues in step . In step the policy statement is tagged REMOTE and the routine looks up the corresponding result in the partially resolved policy document to make sure there is a value pushes an indicator to the resulting application object onto the application object vector and returns to process the next policy statement in step .

In step the routine has determined that the policy statement is tagged ALL or BOTH. It evaluates the policy and then in step compares the resulting value with the value returned by the remote results communicated in the partially resolved policy document. In step if the results match then the routine pushes an indicator to the resulting application object onto the application object vector and returns to process the next policy statement in step .

In step the has determined that the policy statement is tagged LOCAL. It evaluates the policy and then in step determines whether the evaluation resulted in an application object it succeeded . If so in step the routine pushes an indicator of the resulting application object onto the application object vector associated with the current application family object and returns to process the next policy statement in step .

Once all of the entitled application family objects have been processed and all of the respective policies then the routine returns a result vector step with application object vectors for each application family object.

Once the results vector is completed then per step the Node Manager adjusts each application object vector to account for dependencies and exclusions. is an example flow diagram of a routine to adjust an application object vector. It is performed on each of the application object vectors in the result vector not shown . In one example embodiment this routine is also performed by the Node Manager. In step the routine starts a loop on each application object in the vector starting with the first. In step the routine determines whether there are more objects to process and if so continues in step otherwise in step returns the adjusted application object vector and then returns. In step the routine determines whether the current application object being examined is a local application and if so continues in step otherwise skips the object and returns to the beginning of the loop in step . This is because the exclusions and dependencies are applicable for local applications not for remote applications. In step the routine determines whether the application object lists an exclusion on one or more application objects and the excluded object is present in the system registry. If so then in step the routine removes the application object from the result vector because it is incompatible with an already installed application. The routine then continues in step .

To perform this determination the Node Manager maintains what is termed an installed database on the managed computing system commonly stored in the Windows Registry in which it records the keys of all package objects and application objects installed on the computer. This database is partitioned into the SYSTEM part which records which actions occurred system wide on the computing system and the USER part which records which actions occurred for that user. The exclusion check is made against the SYSTEM part of the database. In other words if the computing system has had an application installed on it that a potential application object lists as an exclusion then this potential application object potential in that it exists in the set of vectors above is then removed from that vector. The purpose of this exercise is to prevent incompatible applications being installed on the same workstation which may occur if two or more users share a workstation and different applications are assigned to them in the configuration respository.

In step the routine checks if the current application object being examined has a dependency on one or more additional application objects. If not the routine continues back to the beginning of the loop in step to examine the next object. Otherwise then in step each of the dependent application objects is added to the vector or a new vector added for each and added to the application object vector .

After the results vector is has been adjusted then per step the Node Manager processes each application object to determined whether to queue applications for installation or upgrade. This involves using the installed database on the computing device as mentioned above. are an example flow diagram of processing performed by an example client component of an example Application Workspace System to process application objects in preparation of installation and upgrade. In one example embodiment this processing is also performed by the Node Manager.

In summary the Node Manager iterates through all of the package objects referenced by each application object and checks in the installed database to determine whether some or all parts of packages associated with the possible application objects have already been installed and are correct. The Node Manager then decides whether an application needs to be installed or updated and marks it according.

Specifically in step the routine processes each application object in each application object vector starting with the first. In step the routine determines whether it is done. If there are no more objects to process then the routine continues in step to return the application object result vector and then starts a new loop steps to process any applications that must be installed and will cause a reboot. If there are more objects to process then in step the routine determines whether an Install Always attribute has been set and if so continues in step to require an upgrade and potentially mark as mandatory including identifying packages that are no longer required otherwise continues in step . In step the routine determines whether both the SYSTEM and the USER parts have been installed. This check involves checking that the versions of the package objects match as well as that all of the packages have been installed. This includes identifying packages that are no longer required. If in step everything matches then the application object is considered to have been already installed correctly. Then in step if this application object is at the top of its containing vector the whole vector is removed from the set in step and the routines skips to the next application object vector in step . Otherwise in step the application object is removed from the vector it isn t the top object the remainder of the vector is processed in step .

In step the check for a match could fail either because no corresponding application has been installed or some portion didn t match. Therefore in step the routine checks to determine whether nothing was installed. If true then in step the application object is marked as available for installation which is used for UI hints in the workspace presentation and the remainder of the vector is processed in step . If false the application was previously installed and the packages and values don t match then the routine continues in step to determine whether the parts that are present or the packages require an upgrade. If so the application object is marked for UPGRADE in step and if at the beginning top of the vector it is marked also as MANDATORY. The routine then skips to the next application object.

Note that this process of deciding what needs to be done is primarily performed to filter out which application objects need no action this process is repeated later on when applications and packages are actually installed upgraded removed.

In steps the Node Manager then scans all of the application objects at the top of each vector in the set step to see if any have both the mandatory attribute set and also have a reboot attribute set step . The reboot attribute may be used as a UI indicator to warn the user that this application may require a reboot after installation but if this attribute is present in combination with the mandatory attribute then in step the routines causes these applications to be installed and the system rebooted before anything else happens. If the shell as in the operating system user interface such as Windows Explorer has not been started yet it is not started at all if the Node Manage is configured with the DontShowShellIfRebootRequired flag is set. This prevents user activity as the machine will be rebooted after these mandatory operations have completed. This approach is commonly used for critical application or security fixes. After the machine reboots the whole entitlements resolution process is restarted as the user logs on.

In step by the time the Node Manager arrives at this step again then scans all of the application objects at the top of each vector in the set to see if any have the mandatory attribute set. Those that do are queued for installation processing immediately. Immediate processing can be achieved as the Node Manager is an asynchronous queue based system. In step the Node Manager then scans all of the application objects at the top of each vector in the set to see if any are remote application objects. Any found are queued for remote application processing immediately. In step the resulting application object vectors are returned for further processing.

In step of the remaining application objects at the top of each vector are presented to the user. is an example screen display of a virtual workspace presented to a user after the automated configuration processing performed by an example client component of an example Application Workspace System. In a remote application has been processed successfully with a green tick and two other applications and are available to the user. The attributes available for installation or requiring upgrade are used to change the icons and or text next the items in the dialog box. The user can choose to install the optional applications by selecting link or can skip any further installation by selecting link .

The Node Manager then continues processing the user selections in step of . is an example flow diagram of processing performed by an example client component of an example Application Workspace System to process user selections to install or upgrade optional applications. In step if the Skip option was selected no application objects are marked as requested for install upgrade and the routine returns. If not the Install option was selected then in step any application objects that the user checked are marked as requested this is an attribute of the application object .

The routine then performs a loop to queue for installation upgrade all requested objects or to install upgrade alternatives if they are available applications to which the user is entitled .

Specifically in step the Node Manager searches each application object vector in the set starting with the first. In step if there are no more vectors to process then the routine is done otherwise it continues to examine the vector in step . In step if top application object has been marked as requested then in step this application object is submitted for installation processing and the next vector is processed. On the other hand if the top application object has not been marked as requested then in step the Node Manager moves down the vector to see if any further application objects are available. Note that no further choices are presented to the user this technique is usually used to provide the user with a remote application if the user chooses not to install a local application or to ensure that an existing local application is upgraded if required if the user chooses not to install a different local application. In step If the NM finds an alternate application object in the vector and this application object is a local one marked requiring an upgrade it is submitted for installation processing in step . In step f the application object is remote then it is submitted for remote application object processing in step . The routine then continues back to step to process the next vector.

At this point the Node Manager will have resolved all the contents of the entitlements document and will have submitted the relevant application objects for either installation processing or for remote application object processing note that installation processing performs any steps involved in managing local installs including upgrades or removals . The Node Manager now deletes the set of vectors as important state is now held in three places 

As each application object is processed by installation processing the installed database is updated. Remote application object processing does not update the installed database as nothing is actually installed in the database for remote applications.

The Node Manager then triggers the SCRIPT EVENT CONFIG script for each application that is present in the installed database as installed for that user.

As mentioned applications for install or upgrade are queued because they can be processed asynchronously by a Node Manger of the AWS client side processing. Installation processing is a term used for synchronizing the state of the packages that comprise an application with the desired state as described with the application objects and package objects that exist in the configuration repository. Installation processing can occur at multiple times.

As a result of installation processing the Node Manager may determine whether to install or upgrade an application. are an example flow diagram of the overall processing performed by an example client component of an example Application Workspace System to install or upgrade an application instance. This process typically occurs when a user logs onto a managed workstation for example or through the web portal to a remote application executing on a Terminal Server where it is installed on the Terminal Server . In summary the Node Manager compares the state of the packages installed on the workstation and for the user against the desired state and adds removes packages as appropriate. For an installation the initial state will be that nothing is present for upgrades some existing state will be present.

The first part of the processing involves removing unwanted packages in an orderly fashion. The second part involves then upgrading the packages and causing the appropriate events to occur so that the scripts can be triggered. The third part of the processing involves installing the missing packages for example as occurs with either an install or upgrade.

Specifically in step the routine looks to see if the USER portion of the packages associated with the application instance has been installed. If not it continues in step . Otherwise the routine builds a list of unwanted packages step and removes the installation database information for the unwanted packages step .

In step the routine looks to see if the SYSTEM portion the packages associated with the application instance has been installed. If not it continues in step . Otherwise the routine builds a list of unwanted packages step removes unwanted SYSTEM and USER packages triggering the PRE SYSTEM REMOVAL and POST SYSTEM REMOVAL events step and builds a list of packages to upgrade step . In step the routine upgrades reinstalls the SYSTEM and WSM features and triggers the PRE SYSTEM UPGRADE and POST SYSTEM UPGRADE events.

In step the routine looks to see if the USER portion of the application instance has been installed. If not it continues in step . Otherwise routine builds a list of packages to upgrade step and upgrades reinstalls the USER feature triggering the PRE USER UPGRADE and POST USER UPGRADE events. Note that the USER portion is installed after the SYSTEM and WSM portions.

In step the routines then adds missing not yet installed USER and SYSTEM packages as described below with respect to runs the CONFIG scripts and then completes processing.

More specifically the Node Manager engages in an orderly process to process application objects one at a time. For each object NM first checks to see if any dependent application objects need to be processed and if so recursively processes these step .

After this the NM checks to see if any new packages need to be installed. If they do the packages are installed as follows 

If any of these steps fail not shown portions may be backed out. In particular if the POST USER INSTALL script fails then the Node Manager typically removes the User feature. The User feature usually contains the shortcuts etc. of the local application therefore this implies that if the post install script fails the application is not apparently available to the user.

The result of all of this processing is recorded in the installed database on the computing device where the processing occurred. For removals the relevant package records are removed. For upgrades fresh information is recorded. For installs new records are added.

In addition to resolving entitlements and installing applications and customizing them through the use of scripts the AWS offers tools to remotely monitor data state and status of managed computing devices and terminal servers. For example the AWS Manager Workbench see can also be used to view the configuration data stored by the Node Manager and possibly data from the native operating system as well as monitor accesses to the computing system.

A Node manager can also interact with the native operating system s database of installed applications. is an example screen display of the installed package set in a computing system repository of the same computing device shown in . For packages that resulted in an MSI install it is possible to see the same packages appearing in both the Node Manager s database and the operating system s package database.

A Kernel Manager component briefly described above typically resides on the Terminal Server or on the managed computing device and can trace all the system calls it intercepts in order to achieve behavior modification it runs in kernel mode which is privileged like a device driver . A Node Manager can retrieve this trace information and send it to the AWS Manger Workbench for further analysis. is an example screen display of remote monitoring of a managed computing system in an example Application Workspace System. File and registry accesses can be seen in the trace window.

One or more of the components of an example AWS can be implement on a general purpose computing system. is an example block diagram of a general purpose computer system for practicing embodiments of components of a Application Workspace System. The general purpose computer system may comprise one or more server and or client computing systems and may span distributed locations. In addition each block shown may represent one or more such blocks as appropriate to a specific embodiment or may be combined with other blocks. Moreover the various blocks of the Application Workspace System may physically reside on one or more machines which use standard or proprietary interprocess communication mechanisms to communicate with each other.

In the embodiment shown computer system comprises a computer memory memory optionally a display one or more Central Processing Unit CPU and optionally Input Output devices . The Application Workspace System AWS is shown residing in memory . The components of the Application Workspace System preferably execute on CPU and manage the generation and use of a virtual workspace and configured and personalized applications as described in previous figures. Other downloaded code and potentially other data repositories also reside in the memory and preferably execute on one or more CPU s . In a typical embodiment the AWS includes one or more Node Managers one or more configuration repositories one or more user interfaces and session support .

In an example embodiment components of the AWS are implemented using standard programming techniques. However a range of programming languages known in the art may be employed for implementing such example embodiments including representative implementations of various programming language paradigms including but not limited to object oriented e.g. Java C C Smalltalk functional e.g. ML Lisp Scheme etc. procedural e.g. C Pascal Ada Modula scripting e.g. Perl Ruby Python etc. etc. In addition the various components of the illustrated embodiments may be implemented by way of a single monolithic executable running on a single CPU computer system or alternately decomposed using a variety of structuring techniques known in the art including but not limited to multiprogramming multithreading client server or peer to peer running on one or more computer systems each having one or more CPUs.

In addition programming interfaces to the data stored as part of the AWS process can be available by standard means such as through C C C and Java APIs libraries for accessing files databases or other data repositories through scripting languages such as XML or through Web servers FTP servers or other types of servers providing access to stored data. The configuration repository may be implemented as one or more database systems file systems LDAP servers or any other method known in the art for storing such information or any combination of the above. In addition some operations may be implemented as stored procedures or methods attached to configuration objects although other techniques are equally effective.

Also the example AWS may be implemented in a distributed environment that is comprised of multiple even heterogeneous computer systems and networks. For example in one example embodiment shown below in the Node Manager and the configuration data repository are all located in physically different computer systems. In another embodiment various components of the AWS are hosted each on a separate server machine and may be remotely located from the tables which are stored in the configuration data repository . Different configurations and locations of programs and data are contemplated for use with techniques of described herein. A variety of distributed computing techniques are appropriate for implementing the components of the illustrated embodiments in a distributed manner including but not limited to TCP IP sockets RPC RMI HTTP DHTML Web Services XML RPC JAX RPC SOAP etc. . Other variations are possible.

In example embodiments these components may execute concurrently and asynchronously thus the components may communicate using well known message passing techniques. Equivalent synchronous embodiments are also supported by an AWS implementation. Also other steps could be implemented for each routine and in different orders and in different routines yet still achieve the functions of the AWS.

The Entitlements Portlet communicates with Information Services to obtain information from the configuration repository stored and managed by one or more LDAP Servers . An AWS provided replication mechanism that uses XSLT stylesheets to perform the replication is described further below. This technique is used to replicate the LDAP directories as needed by the system. The Entitlements Portlet performs the entitlement resolution process as described in detail above.

The client computing device uses AWS security services to implement tunneling for secure connections to the applications servers and to perform remote application processing. The tunnel client also known as the CAP can be seen in the workstations on the diagram. The components of the security services also provide Kerberos security services to the system.

The XSLT based LDAP Synchronization technology XLDAPS allows synchronization of LDAP data between directories of different types using a unique approach of a transformed replication changelog. Normally LDAP replication is used to replicate directory data between two identical directory server implementations. In some environments including the AWS described above every data entry added deleted modified in the LDAP is automatically replicated to the other directories. The XLDAPS technology uses XSLT transformation rules to synchronize LDAP changes to different LDAP Directories which may have a different LDAP Schema and a different LDAP Directory Information Tree structure.

A transformation expressed in XSLT describes rules for transforming a standard replication log into a synchronization log. A transformation expressed in XSLT is called a stylesheet. Appendix B is an example XSLT document as used in the AWS to perform LDAP replication.

The XLDAPS technology is implemented as an Directory Server plug in and is used on an LDAP Directory Server e.g. Sun Java Directory Server IBM Tivoli Directory Server Microsoft Active Directory etc. . It allows add modify delete operations performed on one LDAP Directory to be synchronized using corresponding operations on a completely different type of LDAP Directory.

For more information on LDAP Lightweight Directory Access Protocol IETF standard see RFC 3377 http www.ietf.org rfc rfc3377.txt. For more information on XSLT see XSLT Extensible Style Language Transformations W3 standard see http www.w3.org TR xslt.

Multiple instances of the Plugin can run each outputting a different format changelog a changelog contains the datastream to be replicated to the target directory server each described by the XSL XML definition files. More about XSL is found at http www.w3.org Style XSL 

Typical uses of this plugin include the generation of an OpenLDAP style slurpd changelog to replicate LDAP changes to other LDAP servers including Microsoft Active Directory. The XSL stylesheet defines the slurpd replication changelog format and defines the mapping from LDAP attribute types to Active Directory attribute types. This means that the plugin does not need any knowledge of the slurpd changelog format or of the specific details of mapping LDAP attribute types to Active Directory attribute types. Rather the plugin can just invoke an XSLT processor to read and execute the transformations in order to produce the changelog.

This plugin can also be used to output a changelog for use by other replication and synchronization services such as for replicating changes to an RSA Ace SecurID server or for producing an audit log in a specific format.

The plugin is designed to work with Sun ONE Directory Server but could fairly easily be ported to work with IBM Directory Server on Intel or zSeries hardware. Currently it is supported on Intel Red Hat 7.3 Linux working with Sun One Directory Server 5.1.

This plugin is extensible. By using XSL as the changelog format transformation mechanism new replication requirements can be met without the need to make changes to the software. Adding a new replication log or changing the attribute mappings etc. can all be done by modifying or creating a new XSL stylesheet and XML file definition.

In an example embodiment the plugin is called libpaerep plugin.so and is a re entrant shared object library. It is configured in LDAP to automatically start when the LDAP processes ns slapd start.

When the plugin is started it parses the XML and XSL files. If they are not readable or they contain syntax errors the processing aborts and the plugin will not initialize. Otherwise the XSL file is read to determine the list of XSL parameters that are defined.

For efficiency the XML and XSL files are only read and parsed at initialization time. If the contents of the files are changed it is necessary to restart the LDAP processes ns slapd. This is acceptable as the contents of the XML and XSL files should rarely change.

Parameters configured in LDAP are passed to the plugin at startup to determine the format of the changelog. They are defined in order as follows 

The remaining parameters represent a list of LDAP attribute types for which values are always passed as parameters to the XSLT processing after a modify operation. Usually after a modify only the attribute type values that have been modified are passed together with certain fixed ones see below .

The LDAP entry of Table 2 shows an example plugin configuration used for Active Directory Replication.

After an LDAP entry is added each added LDAP attribute type is compared with the parameter list specified in the XSL stylesheet. If there s a match the XSLT Processor is run passing all available parameter values from the new LDAP entry.

In addition to LDAP attribute types the built in parameters changetype dn modifiersname and time are also passed if they are defined in the XSL. See below for a description of these built in parameters.

The XSLT processing for an LDAP Modify is similar to LDAP Add. The difference is that only the attribute types that have actually changed are passed as parameters. This is done for efficiency. If an attribute type value changes that is not defined as a parameter in the XSL stylesheet XSLT processing will not be performed.

In addition to LDAP attribute types the built in parameters changetype dn modifiersname and time are also passed if they are defined in the XSL. See below for a description of these built in parameters.

Additional attribute types can be passed after an LDAP Modify even if those attribute types have not changed. This is sometimes required for LDAP Modify XSLT processing. These additional parameters are specified as plugin startup parameters and beyond. See above.

The XSLT processing for LDAP Delete is very simple as no LDAP attribute type values are available after the entry has been deleted. The only parameters available are the built in parameters changetype dn modifiersname and time. These are passed if they are defined in the XSL. See below for a description of these built in parameters.

Any parameters passed to the XSLT processing are automatically decrypted if they have been encrypted using the encryption routines as supplied with the Propero workSpace software. See the XSL stylesheet example below for details of how these parameters are used.

The plugin uses the C API to the Sablotron library as the XSLT processor. This is maintained by the Ginger Alliance Open Resource Centre. See http www.gingerall.org charlie ga xml p sab.xml Sablotron provides access to a set of standard Document Object Model DOM functions which are used to parse the XSLT stylesheets.

It is linked with the static Sablotron libraries to avoid a library function clash with an LDAP Function. This means that the plugin is not dependent on the Sablotron shared object libraries.

One of the techniques provided by the Application Workspace System is a message bus which it uses for operations such as load balancing among terminal servers and for security related resources. A message bus is a communications abstraction provided by code which allows a requestor or any type of querying agent to send a broadcast message asking for certain information or requesting a particular response Servers that can potentially provide the information or the requested service subscribe to the messaging service and the particular messages that are relevant to the information or services provided by the servers. When the requestor broadcasts a request only those servers that can desire to provide the information or service respond. In that way the requestor knows what servers are available and or appropriate to the desired information or service.

Message based load balancing keeps the application logic of resource selection simple and also inherently provides up to date information that does not include information about resources that are not present or not responding and thus provides a basis upon which to construct highly available systems.

For example the AWS uses message bus based load balancing to determine which servers to use to launch remote application access requests. This allows the AWS to avoid use of central component to respond to load balancing queries to ensure the receipt of updated information regarding available servers and to avoid the complexities of detecting server unavailability timeouts etc. For example the AWS session management server components such as Session Connection Control in can use the message bus to find out what terminal servers e.g. remote applications terminal services in are available and then in the surrounding code determine which one to use based upon any AWS specified load balancing algorithm.

Thereafter servers such as servers and respond to the particular request. The querying agent then receives all the possible responses to the original message within a defined timeout period controlled for example by the code invoked by the querying agent to broadcast the message . This timeout period is relatively short for example 10 seconds and as such serves to filter out possible respondents that are not in a position to respond either due to a failure or due to overloading. In one embodiment this timeout period is defined as the time period for all responses to be received and not as a timeout per possible respondent.

The querying agent then applies an algorithm to the elements of data returned from all the respondents to decide which is the most appropriate respondent. In the case of a query to figure out where to run or access an application or data the algorithm may be a load balancing algorithm.

Note that the message bus mechanism provided by the AWS also can be used for other purposes such as voting and consistency checking.

Example pseudo code of how the message bus is used to perform a load balancing algorithm across Terminal Servers for session management is included as Table 3 below. Note that the parameter serversToQuery is a list of possible servers that has been retrieved from LDAP. The load balancing algorithm employed in this code sorts the responding servers based upon statistical information and then chooses which one to use based upon the sort. For example in the code shown below the statistics include the number of current sessions being serviced the percentage of memory being used and the average processor time being utilized. Other load balancing algorithms can be similarly incorporated.

The above code shows that this is a Session Manager implementation in that it is implementing the interfaces of the session controller for Terminal Servers e.g. PAESessionImp class is an implementation of the PAESession interface . Other algorithms for load balancing can be similarly defined and integrated in an example AWS.

The underlying support for a message bus can be provided by any compliant message bus provider. In the example embodiment used to support the AWS which is JAVA based the message bus is a JMS message bus for example provided by MQSeries. Additional information on JMS message buses can be found in http java.sun.com products jms which is incorporated herein by reference.

In addition to using a message bus for session management the message based load balancing techniques can be used to determine which server to use for implementing secure VPN services such as the tunnel services offered by the Security Authentication and Other Support Services in when a user logs onto a managed workstation running the AWS Manager client code. Session management and the selection of security service resources share some common requirements which can be suitably addressed by the use of the AWS message bus load balancing techniques. For example both scenarios share the following characteristics 

Using message bus load balancing the AWS web services can select an appropriate tunnel server at the moment it is needed to provide the conduit for secure communications between an AWS client and the AWS Web services.

Grid Location Services GLS represent an integration of the multicast DNS mDNS technologies with DNS technology to achieve transparent configurability of servers.

The AWS needs to support the ability to services to be added removed and to fail over without reconfiguring all the entities that use those services. The AWS implements a mechanism referred to as Grid Location Services to provide this capability. In older systems mDNS or other broadcast multicast directory name service systems were used through a network to achieve transparent reconfigurability but the implementations of firewalls in modern networks prevent such service systems from being effective. There are only a few services that all firewalls allow through and DNS Domain Name Service is one of them.

In a DNS system names such the server names contained in urls also known as fully qualified domain names are mapped to network addresses analogous to how a phone book resolves names to phone numbers but with typically multiple steps of translation for all portions of a network address. The directory or portions of it are typically replicated throughout a networked environment but when a change to a mapping of domain name to network address occurs this change needs to be propagated to the DNS servers that implement the directory. Thus when a server address fails or when the network is configured there is a delay to await the change taking effect. In addition many small local networks do not support a DNS server and so use other ways to map the address to a final destination a node on the local network. In addition as DNS does not check the state of any addresses that it provides as downstream or caching servers may be providing the address there is also the possibility that the final hop to a physical machine on a local network will not properly result in a working destination.

mDNS protocols offer a way to provide such mappings without the use of a DNS. Thus smaller or localized networks may implement mDNS to figure out which computing resource is response to a service request. In mDNS a request for a service is reconciled with the provider of a service using an IP multicast protocol without a DNS server being implemented. When devices fail or are reconfigured they simply don t respond or respond as appropriate to the service request.

As mentioned many of today s firewall systems do not allow mDNS messages to pass through the firewall. The AWS Grid Location Services address these problems by allowing remote computers and LANs to use a DNS name and the DNS protocol to resolve a name to an IP address even though the last hop of the DNS resolution process is actually achieved using mDNS. Thus the devices can be reconfigured at will locally or even fail transparent to requesting systems that access them remotely.

Technically Grid Location Services is a combination of DNS and mDNS. mDNS is used to locate services on the same LAN and a DNS to mDNS bridge allows entities not resident on the same LAN to take advantage of the capabilities of mDNS to locate services on that LAN.

Note that this is not an implementation of what is sometimes termed Dynamic DNS in that the DNS servers in this invention are not updated. Rather they always return a 0 time to live for all responses so they are always re queried and each time they will use the state of the MDNS system to resolve the DNS query.

In an example embodiment of the AWS Grid Location Services the GLS subsystem the DNS to mDNS bridge for example bridge server in comprises two server components 

The GLSDNS process is not the same as a standard DNS server standard DNS servers load information from a file but then view that information as static and tend to respond to queries without re querying the file. GLSDNS uses the contents of the file for each and every request it receives and responds to those requests setting the TTL time to live to 0 to ensure that the response is not cached by any downstream components. This ensures that if a name needs to be resolved again it will result in another query being sent to GLSDNS.

The GLSMDNS process registers as an MDNS node with a configurable domain and for a number of different service types see below for example usage and listens for other registrations in that domain. When other registrations are received it updates the registration file this in essence ensures that the registration file contains all of the names and associated IP addresses of nodes registered in a particular domain providing a particular service. In addition when nodes are no longer present their information will be removed from the registrations file by the GLSMDNS process.

GLSMDNS can also be extended with particular plug ins that can check whether a server that is providing a service type is actually providing that service. For example if the GLSMDNS process is monitoring servers that register LDAP directory services then GLSMDNS will have a plug in that will periodically perform LDAP queries against all the servers in the registration file and for those that do not respond correctly not include that node in the list of addresses that correspond to that service type in the registration file. mDNS uses a convention of underscores in service names GLSMDNS strips these off when creating DNS names that map to service names.

As an example of the use of AWS Grid Location Services suppose 4 mDNS nodes exist in the .local. domain as follows 

In this example there are a number of different service types including LDAP services JMS services terminal services and http services. GLSMDNS may have a plug in to monitor each service type but LDAP is the one that is commonly used in an example AWS. GLSMDNS monitors mDNS messages for the .local. domain and having received registrations for the above 4 nodes will write out a registration file that includes the following contents 

In this example GLSDNS is configured to be the authoritative DNS server for the domain WORKSPACE.INT. GLSDNS responds to queries for names in the WORKSPACE.INT domain by using the registration file created from the mDNS information.

As a result a DNS query for pc01.workspace.int would get the response 192.168.100.41 and a DNS query for http.workspace.int would get 192.168.100.43. GLSDNS uses each service address it finds in turn so that a DNS query for ldap.workspace.int may return 192.168.100.41 or 192.168.100.42.

This last example demonstrates how the monitoring plug ins operate if the GLSMDNS monitoring plug in for LDAP failed to retrieve a correct LDAP response to the test query it would remove that node from the LDAP list thus ensuring that clients who are requesting the service LDAP will only receive the IP address of a working LDAP service.

By combining mDNS and DNS a number of features of both are no longer available e.g. mDNS has a facility for providing the port number of a service as well as the address and DNS has a strong focus on caching results to lower network traffic. Neither of which are available using GLS.

However the advantages of using the GLS approach are several. Servers and services can be added to an embodiment of the AWS without the need for the configuration that DNS systems require and the AWS can dynamically address whether those servers and services are present or not. Also service queries can take into account whether the service is actually functioning this is an important part of high availability. Moreover the GLS functionality is available to any client systems that use DNS without the requirement for additional client side software.

Additional information on DNS is provided in the DNS Specification RFC 1035 http www.ietf.org rfc rfc1035.txt. Details on using DNS to locate services is provided in RFC 2782 http rfc.net rfc2782.html. Details on using mDNS are available in the mDNS Specification http files.multicastdns.org draft cheshire dnsext multicastdns.txt.

All of the above U.S. patents U.S. patent application publications U.S. patent applications foreign patents foreign patent applications and non patent publications referred to in this specification and or listed in the Application Data Sheet including but not limited to U.S. Provisional Patent Application No. 60 752 208 entitled VIRTUALIZED APPLICATION WORKSPACES filed on Dec. 19 2005 is incorporated herein by reference in its entirety.

From the foregoing it will be appreciated that although specific embodiments of the description have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention. For example the methods and systems for performing entitlement resolution and packaging discussed herein are applicable to other architectures other than a Windows based architecture and in non online environment. For example the separation of user administration and application administration can be integrated into a group of peer computer systems connected together. The methods and systems discussed herein are applicable to differing protocols communication media optical wireless cable etc. and devices such as wireless handsets electronic organizers personal digital assistants portable email machines game machines pagers navigation devices such as GPS receivers etc. .

