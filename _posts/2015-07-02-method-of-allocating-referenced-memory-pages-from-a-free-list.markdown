---

title: Method of allocating referenced memory pages from a free list
abstract: Memory pages that are allocated to a memory consumer and continue to be accessed by the memory consumer are included in a free list, so that they may be immediately allocated to another memory consumer as needed during the course of normal operation without preserving the original contents of the memory page. When a memory page in the free list is accessed to perform a read, a generation number associated with the memory page is compared with a stored copy. If the two match, the read is performed on the memory page. If the two do not match, the read is not performed on the memory page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09361218&OS=09361218&RS=09361218
owner: VMware, Inc.
number: 09361218
owner_city: Palo Alto
owner_country: US
publication_date: 20150702
---
This application is a divisional of U.S. patent application Ser. No. 13 760 837 filed Feb. 6 2013 which is incorporated by reference herein in its entirety.

Computing systems typically allocate memory using a regime that guarantees the continued availability of the allocated memory. If a memory consumer requests an allocation of memory and there is sufficient free memory to satisfy the request then the request is granted. The memory consumer may subsequently use the allocated memory until the memory consumer process terminates or explicitly releases the allocated memory. If sufficient free memory is not available to accommodate the memory allocation request then the request is denied. Certain memory consumers are tolerant of being denied a memory allocation request but some memory consumers fail catastrophically if they are denied a memory allocation request. Some kernel space memory consumers are intolerant of being denied memory allocation requests as they are critical to the proper operation of their respective systems services. To avoid catastrophic failure of these critical memory consumers many computing systems are configured to operate with a significant reserve of memory that purposefully remains idle.

For example in a conventional virtual machine VM setting proper execution of each VM depends on an associated virtual machine monitor VMM having sufficient memory. The VMM may request a memory allocation during normal operation. If a host system has insufficient memory for the VMM at some point during VM execution then the VMM is forced to kill its VM. If the average amount of idle memory falls below a predetermined threshold then the host system may be reconfigured to reestablish a certain minimum amount of idle memory. Process migration may be used to rebalance VM system loads among host systems thereby increasing idle memory on the host system encountering memory pressure. While maintaining an idle memory reserve serves to avoid catastrophic failures this idle memory represents a potentially expensive unused resource.

One or more embodiments of the present invention provide techniques for managing memory in a way that better utilizes idle memory resources. These techniques allow memory pages that are allocated to a memory consumer and continue to be accessed by the memory consumer to be included in a free list so that they may be immediately allocated to another memory consumer as needed during the course of normal operation without preserving the original contents of the memory page. In one embodiment such techniques allow all memory resources to be used without jeopardizing system stability.

A method of managing memory using a free list of memory pages according to an embodiment of the present invention includes the steps of receiving a memory allocation request from a memory consumer selecting a memory page from the free list and allocating the memory page to the memory consumer. The free list includes the memory page even though the memory page has been allocated to the memory consumer and the memory consumer retains a reference to the allocated memory page. In one embodiment the memory page is removed from the free list upon allocation and then returned to a tail of the free list to be made available for allocation to other memory consumers.

A method of performing a read on a memory page that is in a free list of memory pages according to an embodiment of the present invention includes the steps of performing a read on a memory page that is in the free list and retrieving after the read a current generation number associated with the memory page. If the current generation number retrieved after the read matches the stored copy of the generation number the read data is consiered valid. On the other hand if the current generation number retrieved after the read does not match the stored copy of the generation number then the read data is considered invalid.

Further embodiments of the present invention include without limitation a non transitory computer readable medium that includes instructions that enable a processing unit to implement one or more aspects of the above methods as well as a computer system configured to implement one or more aspects of the above methods.

A virtualization layer is installed on top of hardware platform to support a virtual machine execution space within which at least one virtual machine VM is instantiated for execution. Additional VM instances may coexist under control of the virtualization layer which is configured to map the physical resources of hardware platform e.g. CPU RAM etc. to a set of corresponding virtual emulated resources for each virtual machine . The virtual resources are provided by a corresponding virtual machine monitor residing within the virtualization layer . The virtual resources may function as the equivalent of a standard x86 hardware architecture such that any x86 supported operating system e.g. Microsoft Windows Linux Solaris x86 NetWare FreeBSD etc. may be installed as a guest operating system . The guest operating system facilitates application execution within an application space . In one embodiment the virtualization layer comprises VMkernel which is implemented as a commercial product in VMware s vSphere virtualization product available from VMware Inc. of Palo Alto Calif. In an alternative embodiment a host operating system is installed between the virtualization layer and hardware platform . In such an embodiment the virtualization layer operates above an abstraction level provided by the host operating system. It should be recognized that the various terms layers and categorizations used to describe the components in may be referred to differently without departing from their functionality or the spirit or scope of the invention.

The virtualization layer includes a memory manager configured to allocate pages of memory residing within RAM . The pages of memory are generally organized as allocated pages and free pages . The allocated pages are pages of memory that are reserved for use by a memory consumer . The free pages represent a free page pool comprising pages of memory that are free for allocation to a memory consumer . A memory consumer may reside within a VMM or any other portion of the virtualization layer .

The operating system includes a memory manager configured to allocate pages of memory residing within RAM . The pages of memory are generally organized as a set of allocated pages and a set of free pages . The allocated pages are pages of memory that are reserved for use by a memory consumer . The free pages are pages of memory that are free for allocation to a memory consumer . In one embodiment the memory consumer resides within any technically feasible portion of the operating system such as a kernel space of the operating system . In alternative embodiments the memory consumer resides within a non kernel execution space such as in a user space. In one embodiment the memory manager resides within the kernel of the operating system .

In a conventional memory management regime pages categorized as free pages are not in use by any memory consumer. In such a regime each free page is presumed to not store presently valid data and each allocated page is reserved by a memory consumer regardless of whether the page presently stores valid data. Furthermore in a conventional buffer cache associated pages are allocated exclusively to the buffer cache and only trusted users such as the core of the operating system may access these pages of the buffer cache. By contrast pages of yankable memory are not allocated exclusively to a memory consumer and yankable memory pages may be accessed by any appropriately configured memory consumer even user level applications and third party drivers affording a yankable memory regime greater flexibility and greater usability by more classes of consumers.

In addition the conventional buffer cache maintains its own list of buffered freeable memory pages or has to be at least notified when a memory page is not free anymore. The memory management techniques according to one or more embodiments of the present invention may be implemented without any such overhead.

A memory management regime is disclosed herein whereby a page of memory may be characterized as allocated idle or yankable. Allocated pages are reserved in a conventional manner. However free pages are categorized as being either idle or yankable. Idle pages have been released from an associated memory consumer with no expectation of further use by the memory consumer. Yankable pages have been returned to the set of free pages from an associated memory consumer with an expectation that the yankable pages may be beneficially accessed at a later time. Both idle and yankable pages are available to be allocated and become allocated pages .

A yankable memory consumer may at any time lose access to data stored within one or more pages of yankable memory. Therefore a yankable memory consumer needs to be able to restore or retrieve data associated with lost pages of memory from a reliable source or continue properly without the lost pages. One example of a yankable memory consumer that is able to operate correctly despite potential loss of pages of memory is a read cache. The read cache retrieves data from a backing store that forms a reliable source of data and stores the data in yankable pages. If certain yankable pages remain available then the read cache performance is improved. If certain yankable pages are lost due to reallocation by the memory manager then the read cache performance is diminished. Regardless of whether the yankable pages remain available the read cache can continue to operate correctly.

In one embodiment yankable pages are allocated according to conventional techniques but are returned to the free page pool. In one example a memory consumer requests an allocation of at least one page of memory from the memory manager . The memory manager then grants the allocation request. At this point the memory consumer may fill the page of memory mark the page as read only and subsequently return the page to the memory manager as a yankable page of memory. The memory manager then adds the yankable page of memory back to the free page pool. The memory consumer retains a reference to the yankable page of memory for later access. If the yankable page of memory now among the free pages has not been reallocated then the memory consumer may access the yankable page of memory on a read only basis. In certain embodiments the memory consumer may request that the memory manager reallocate the yankable page of memory to the memory consumer for example if the memory consumer needs to write new data into the yankable page of memory. After the write the memory consumer may release the yankable page of memory back to the free page pool.

In one embodiment a public generation number is applied to each page of memory being managed by the memory manager . Public generation numbers may be initialized to zero during an initial boot process. The public generation number of a page of memory is incremented prior to the page of memory being allocated to a particular memory consumer. If any generation number overflows as a result of being incremented then all memory consumers of yankable memory should be informed that all of their yankable memory pages are invalid and no longer available. Any technically feasible technique may be used to invalidate yankable memory pages. After an overflow event generation numbers may be cleared and new pages of yankable memory may be allocated again. Upon successful allocation the memory consumer retains a private copy of each generation number for each yankable page of memory. The memory manager separately maintains the public generation number for each page of memory regardless of whether a particular memory consumer treats the page of memory as yankable. When a specific memory consumer reads a particular yankable page of memory if the private generation number matches the public generation number associated with the page of memory then it is determined that the page of memory was not allocated to another memory consumer and data stored within the page of memory is valid for the specific memory consumer. However if the private generation number does not match the public generation number then it is determined that the page of memory was allocated to another memory consumer and the data stored within the page of memory is not valid for the specific memory consumer. This embodiment is described in greater detail below in .

Other yankable pages may be added behind page over time thereby increasing the likelihood that the page will be reallocated. However placing yankable pages at the tail of the free list establishes a low priority for reallocation of the yankable pages thereby increasing the likelihood that a given yankable page will be available for use when an associated memory consumer attempts access. Prior to the yankable release of page the memory consumer copies the public generation number for page and stores the copy as a private generation number for page . In future attempts to access page the memory consumer compares the private generation number to a then prevailing public generation number. If the private generation number matches the public generation number then the memory consumer may access data within the page . The memory consumer does not need to store a private generation number for page because page is released according to a traditional non yankable release.

In one embodiment memory consumer is provided with a memory manager application programming interface API comprising at least a yankable memory declaration API call and a yankable memory read API call. The yankable memory declaration API call causes the memory manager to return a declared page to the free list as described previously in . The yankable memory read API call compares public and private generation numbers for a requested page and either returns data if the public and private generation numbers match or returns a read error if the generation numbers do not match. One optional yankable memory API comprises a reallocate request that pulls a requested page from the free list if the public and private generation numbers match and allocates the page to the requesting memory consumer. Persons skilled in the art will understand that any technically feasible technique may be used to uniquely associate a page of memory with a memory consumer and that the regime of generation numbers is one exemplary technique. Another exemplary technique involves using a unique process identification number in place of a generation number and so forth.

In an alternative embodiment a yankable memory API based on a try catch semantic is implemented to provide yankable memory management. The try catch API includes a yankable allocation API call and a yankable declaration API call. The yankable allocation API call allocates a page and maps the page as a read write page in a special section of virtual memory that is accessible to the memory consumer . The memory consumer may then write to the page to fill the page with any appropriate data. The memory consumer then calls the yankable declaration API call with the page causing the page mapping to be switched to read only status. If the page subsequently needs to be yanked away and allocated to a different memory consumer the mapping is cleared. To later access the yankable page a try API call is executed on the page. If the try call passes then the page may be read. Otherwise a catch method is executed by the memory consumer . The try catch semantic avoids a page fault being triggered by the memory consumer . On what would otherwise be a page fault condition the memory consumer is able to execute a catch method instead.

In one embodiment a yankable page declaration operation places an associated yankable page at the tail of the free list . The page remains accessible to an associated memory consumer until page is allocated to a different memory consumer. A yankable page may be read via a read operation . As described previously the read operation may comprise checking a page attribute such as a generation number or mapping disposition. The fact that an associated memory consumer read the yankable page indicates the page is likely of some future value to the memory consumer. To increase the likelihood that the yankable page will be available to the associated memory consumer the yankable page is repositioned at the tail of the free list via a repositioning operation . In one or more embodiments of the invention the process of reading and repositioning yankable pages implements a least recently used LRU allocation policy for pages within the free list . In certain embodiments involving hardware assisted address mapping repositioning of a page to the tail of the free list may be indicated via a page table entry access bit or simply A bit .

Persons skilled in the art will recognize that the techniques disclosed herein for implementing a yankable memory regime are exemplary and that other implementations of a yankable memory regime are within the scope and spirit of the present invention.

The method begins in step where the memory manager such as memory manager of receives an allocation request for a page of memory from a memory consumer such as consumer of . In step the memory manager selects a page from the free list . In one embodiment the memory manager selects a page from the head of the free list . In step the memory manager increments a public generation number associated with the selected page. Any technically feasible technique or data structure may be implemented to store public generation numbers for pages of memory. For example an entry field in a page table entry may be used to store public generation numbers. In step the memory manager returns a reference for the selected page to the memory consumer . The method terminates in step .

The method begins in step where the memory manager receives a yankable declaration designating a page as yankable from a memory consumer. In step the memory manager places the page at the tail of the free list. The method terminates in step .

The method begins in step where the memory manager receives a request for a yankable page number for a specified page from the memory consumer. In step the memory manager returns a public generation number for the requested yankable page to the memory consumer. If in step data associated with the specified page is requested then the method proceeds to step where the memory manager returns requested data from the specified page. In step the memory manager repositions the specified yankable page to the tail of the free list. The method terminates in step .

Returning to step if data associated with the specified page is not requested then the method terminates in step .

In one or more embodiments a usage model for a data object implemented by a memory consumer is evaluated. If the data object is configured to store information that is available from a reliable second source then the data object may be implemented using pages of yankable memory. If the data object is configured to store uniquely available information then the data object should not be implemented using yankable memory.

The method begins in step where the memory consumer requests a new page allocation from the memory manager. In step the memory consumer receives a reference to the new page from the memory manager. In step the memory consumer fills the page with data for subsequent read only access. In step the memory consumer creates a private copy of a generation number associated with the new page. In step the memory consumer declares the page to be yankable to the memory manager which places the page on free list of . The method terminates in step .

The method begins in step where the memory consumer retrieves a public generation number for a page the memory consumer is preparing to read. If in step the public generation number matches a private generation number maintained by the memory consumer then the method proceeds to step where the memory consumer performs a read only request to the page. If the public generation number does not match the private generation number maintained by the memory consumer then the method proceeds to step where the memory consumer retrieves a copy of the data from a reliable source.

After the read is carried out in step the memory consumer retrieves the public generation number once more in step to confirm in step that it has not changed. It should be recognized that the public generation number would have changed if the memory page is allocated to another memory consumer while steps and are being carried out and in such cases the read carried out in step would be invalid and step would be carried out after step . If in step the public generation number still matches the private generation number then the read data is considered valid and the method terminates in step .

Sometimes the memory pages that are marked dirty during a pre copy iteration are not modified at all e.g. rewritten with the same data which means that such memory pages need not be copied to the destination. As a way to determine whether dirty memory pages have indeed been modified during a pre copy iteration memory pages representing the working state of the virtual machine that are copied to the destination during any pre copy iteration are stored in pages of yankable memory. is a flow diagram of a method that is carried out by a live migration module to determine whether a memory page that has been marked dirty during a pre copy iteration has been modified or not.

The method begins in step where the live migration module retrieves a public generation number for the page in yankable memory containing the previously transmitted contents of the dirty memory page. If in step the public generation number matches a private generation number maintained by the live migration module for that page in yankable memory the method proceeds to step where the live migration module performs a read only request to the page. If the public generation number does not match the private generation number the method proceeds to step where the live migration module transmits the current contents of the dirty memory page to the destination.

After the read is carried out in step the live migration module retrieves the public generation number once more in step to confirm in step that it has not changed. It should be recognized that the public generation number would have changed if the page of yankable memory containing the previously transmitted contents of the dirty memory page is allocated to another memory consumer while steps and are being carried out and in such cases the read carried out in step would be invalid and step would be carried out after step . If in step the public generation number still matches the private generation number the read data is considered valid and is compared against the current contents of the dirty memory page in step . If the contents do not match it is determined that the dirty memory page has indeed been modified and step is carried out to transmit the current contents of the dirty memory page to the destination. If the contents match it is determined that the dirty memory page has not been modified and the method ends in step without the contents of the dirty memory page being transmitted to the destination.

In sum a technique is disclosed for managing memory in scenarios where a memory consumer can continue to operate correctly given a loss of a page of allocated memory. Two categories of pages may exist within this memory management regime. One category is identical to traditional pages of memory which are allocated and kept by a memory consumer until released after which no further accesses are permitted. A second category allows pages associated with a memory consumer to be yanked from the memory consumer at any time. This second category of page is applicable to certain common applications including without limitation caching. In one embodiment pages of memory are marked with a public generation number which increments every time the page is allocated. Each memory consumer maintains a private copy of the public generation number for each page. Prior to accessing data within a page of yankable memory the memory consumer compares public and private generation numbers. If the generation numbers match then the page may be accessed if the generation numbers do not match then the memory consumer must either proceed without the requested data or the memory consumer must retrieve a copy of the requested data form a reliable source. In an alternative embodiment yankable pages are mapped via a virtual mapping scheme. A yankable page is mapped during allocation and de mapped if the memory manager yanks the page back. A try catch scheme is implemented to avoid memory faults that may arise when the memory consumer attempts to access a yanked page.

According to another embodiment of the present invention certain contents may be stored in yankable memory and discarded if the public generation number does not match the stored private generation number. These examples include 1 storing a real continuous signal from a signal processing card in yankable memory such that even if some contents are lost as a result of the page being allocated to another memory consumer quantization can continue albeit with a slight loss in accuracy 2 storing a large set of data points e.g. disk latency values in yankable memory to perform data fitting to a curve such that even if some contents are lost as a result of the page being allocated to another memory consumer curve fitting can continue albeit with a slight loss in accuracy 3 storing crypto secure signatures of previously migrated pages in yankable memory using which comparisons can be done with newer version of those pages and differences can be sent in the form of diff compression such that even if some contents are lost this process can still provide better network bandwidth utilization for those pages that still have crypto secure signatures stored in yankable memory and 4 storing a cache of information about pages previously transmitted to a destination in yankable memory and sending unique identifiers of previously transmitted pages are sent to the destination instead of the page data such that even if some contents are lost this process can still prevent repeat data transmissions to the destination for those pages that still have its information stored in yankable memory.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system. Computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

In addition while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned. Furthermore various virtualization operations may be wholly or partially implemented in hardware. For example a hardware implementation may employ a look up table for modification of storage access requests to secure non disk data.

Many variations modifications additions and improvements are possible regardless of the degree of virtualization. The virtualization software can therefore include components of a host console or guest operating system that performs virtualization functions. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

