---

title: Coalition based memory management
abstract: One or more memory coalitions of software processes are created and used to decide whether to perform memory reduction operations on a data processing system. One method in one embodiment includes adding a newly launched second process to an existing memory coalition in response to determining that the second process should be part of a memory coalition that includes a first process. In response to determining that available system memory (e.g. DRAM) is low, the system determines which memory coalition of foreground applications uses the most amount of system memory and then performs one or more memory reduction operations on that memory coalition in order to make more system memory available to other processes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465734&OS=09465734&RS=09465734
owner: Apple Inc.
number: 09465734
owner_city: Cupertino
owner_country: US
publication_date: 20150408
---
This disclosure relates to resource management in data processing systems and more particularly to memory management by an operating system which controls a data processing system.

An operating system OS such as iOS or OS X from Apple Inc. or Microsoft Windows from Microsoft is a collection of software that manages device hardware resources and provides common services for computer programs such as application software. Application software can be considered to be the computer program that causes a computer or other data processing system to perform useful tasks in response to user requests or other requests or other inputs. A specific instance of application software is called a software application application program application or app which are used interchangeably herein. Application programs usually require an operating system to function.

As more and more apps and services are becoming available for small or mobile devices e.g. a smartphone the number of applications running at the same time in a single device has increased significantly. Moreover many of these applications are not terminated or quit by a user after a user finishes using them so they continue to run and therefore continue to use system resources such as memory e.g. volatile memory such as DRAM even when they are no longer being used. Furthermore idle background and foreground applications while they may not use processing or computation resources such as one or more microprocessors they often use memory resources such as RAM while they are idle and not in use. These multiple applications or processes in the same device compete with each other by sharing the same memory resources and computation resources embedded within a device and the operating system performs resource management such as memory management to deal with resource contention in concurrent computing. Memory management to control use of memory by running or idle applications has included techniques to terminate applications based on one or more indications of use of memory e.g. DRAM in a data processing system. U.S. Pat. Nos. 7 827 358 and 8 892 827 and published U.S. patent application numbers 2013 0332936 and 2013 0326166 describe examples of such techniques that also included other techniques such as deleting caches.

In one or more embodiments described herein a coalition of a host process such as a first host application and any helper processes is used to determine a memory usage amount e.g. total memory footprint of the processes in the coalition in order to determine whether or how to perform memory management operations on the coalition or other coalitions of processes. In one embodiment a coalition can be defined as a group of separate processes that consume memory and are considered together when assessing memory usage for the purposes of memory management. In one embodiment a system can determine the total memory usage footprint of each coalition and use these determined footprints to select one or more coalitions for memory usage reduction operations such as terminating one or more helper processes in a selected coalition . In one embodiment a host process is normally the first process launched in its coalition and the host process causes the launching of helper processes that provide services to the host process while the coalition is using memory. When the host process calls e.g. through an application programming interface API for the launching of a helper process the system determines whether the helper process should be added to be part of the host process s coalition. If the helper process should be part of the host process s coalition then that helper process is added to the host process s coalition for the purposes of measuring or otherwise determining the memory usage footprint of that coalition.

A method according to one embodiment includes executing a first process which can be considered a first host application determining in response to a launch of a second process whether the second process is part of a first memory coalition that includes the first host application adding the second process to the first memory coalition in response to determining that the second process is part of the first memory coalition determining that available memory in the data processing system is low determining in response to determining that available memory is low an amount of memory used by each memory coalition in a set of one or more memory coalitions which includes the first memory coalition and performing on the first memory coalition one or more memory usage reduction operations to increase the amount of available memory in response to determining that the first memory coalition uses more memory than any other memory coalition in the set of memory coalitions. In one embodiment the available memory includes volatile dynamic random access memory DRAM and each memory coalition includes a host application and associated one or more processes which are instantiated from software of other host applications or are instantiated from helper software of the host application or from other sources. In one embodiment the second process can be instantiated from software of a second host application and the second process operates in a second sandbox which is separate and different from a first sandbox in which the first process operates. In one embodiment memory usage reduction operations are performed on background host applications and other background processes before performing memory usage reduction operations on memory coalitions of one or more foreground applications.

In one embodiment each memory coalition has a coalition identifier and the second process is determined to be part of the first memory coalition when the second process is launched through a call that specifies the coalition identifier for the first memory coalition. In one embodiment the first host application obtains the coalition identifier for the first memory coalition from an operating system component when the first host application is launched.

In one embodiment the first host application is a foreground application when the memory usage reduction operations are performed on the first memory coalition which includes the first host application. In one embodiment memory reduction operations on background applications are performed without regard to the amount of memory used by the memory coalitions that contain those background applications in other words the memory usage footprints of memory coalitions of background applications are not used to determine whether or how memory reduction operations are performed on background applications or processes associated with those background applications. In one embodiment the first process can be a daemon process. In one embodiment the second process can be instantiated from software from either a software library provided by an operating system or helper software provided with the first host application such as a library of helper processes provided with or in a bundle of the first host application.

In one embodiment each memory coalition in the set of memory coalitions has only one host application and one or more helper processes with the second process being a helper process. Each helper process in one embodiment belongs to only one memory coalition in its entire life cycle and when a host application in a memory coalition terminates then all helper processes in that memory coalition also terminate. In one embodiment when an application is used to instantiate a helper process for more than one memory coalition a unique instance of that helper process is instantiated for each of the one or more memory coalitions.

In one embodiment the processes within a memory coalition are grouped into categories that each have a relative priority which specifies an order of implementing memory reduction operations such that processes in one category within a selected memory coalition are terminated before terminating processes in another category within the same selected memory coalition. In one embodiment the process or main process of the host application in the selected memory coalition is the last process in that memory coalition to be terminated when performing memory reduction operations on that selected memory coalition.

Various data processing systems and methods and non transitory machine readable media such as DRAM or flash memory are described herein as part of the various embodiments described.

The above summary does not include an exhaustive list of all embodiments in this disclosure. All systems and methods can be practiced from all suitable combinations of the various aspects and embodiments summarized above and also those disclosed in the Detailed Description below.

Various embodiments and aspects will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding of various embodiments. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment. The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

One or more memory coalitions of software processes are created and used to decide whether to perform memory reduction operations on a data processing system. One method in one embodiment includes adding a newly launched process referred to as a second process to an existing memory coalition in response to determining that the second process should be part of a memory coalition that includes a first process. In response to determining that available system memory such as DRAM is low the system determines which memory coalition in a set of memory coalitions of foreground applications uses the most amount of system memory and then performs one or more memory reduction operations on that memory coalition in order to make more system memory available to other processes. In one embodiment the newly launched second process can be a helper process such as an extension from another software application or host application or can be instantiated from a system wide library of helper processes or from a library of helper processes provided by the first host application which instantiated the first process. In one embodiment the first host application can be a web browser and the second host application can be a social network application e.g. Facebook and the software from Facebook can include an extension which can be used to create an instance of helper process to allow the web browser to create a post in Facebook or to perform some other Facebook related function while the web browser and the helper process from Facebook remain isolated in their respective sandboxes and communicate with each other through known interprocess communications.

In one embodiment a data processing system such as a tablet computer or smartphone or laptop computer or desktop computer or other type of data processing system can include a plurality of application programs in addition to operating system software and other software associated with the operating system to allow the various applications to function with the hardware of the data processing system.

The data structure shown in is one example of information used to define a memory coalition which can be used to then provide information for processes in the memory management system in order to control the uses by processes of a system s memory. In one embodiment each application coalition can have only one host process in the coalition and this role of a host application or process cannot be transferred or relinquished at any point in an existing coalition. The termination in one embodiment of a host application which has a host role will result in the termination of the coalition and all of its processes within the coalition. In one embodiment the helper processes are non host processes but are launched specifically to provide support for the host application and a process instance can belong to only one coalition in its entire life cycle such that it is launched into that coalition and is part of that coalition until the host application terminates or the helper process instance terminates. In one embodiment if an application program such as an email application program or a web browser program or a social network application program provides functionality that is needed by two or more coalitions then a unique instance of that process will be spawned or instantiated into each requesting coalition such that no instance is shared between the coalitions. In one embodiment an instance is spawned via a posix spawn as is known in the art which can include attributes such as a memory coalition identifier for an existing memory coalition. These calls can include a specification of both a coalition identifier and a coalition role or role identifier such as an identifier indicating whether the helper process is an extension or an XPC service or an unknown process or other types of helper processes. In one embodiment each non host process that is launched into a coalition must provide a coalition ID as an attribute to the posix spawn call that will create it and it can specify its role in the coalition using an attribute in that call that will tell the kernel whether that process with an extension or an XPC service or some other role in a coalition.

Each of the processes within a memory coalition may be sandboxed within its own sandbox which is isolated from the sandboxes of the other processes within the memory coalition to provide enhanced security relative to malware etc. Various different known techniques for sandboxing processes can be used including for example the use of one or more of different container directories specifying permitted and accessible file system storage locations in a non volatile storage system for sandboxed processes such that other storage locations in the non volatile storage are not accessible by the sandboxed process b entitlements specifying what hardware or software resources a sandboxed process is permitted to use and what resources is not permitted to use or c memory space privileges specifying the memory locations the sandboxed process can access such that other memory locations cannot be accessed by the sandboxed process. It will be appreciated that various other additional techniques can be used from the sandboxing art in order to sandbox each process from the other processes and isolate malware in one process from another process.

In one embodiment as each process is launched in a data processing system the operating system determines whether the particular newly launched process should be part of an existing memory coalition or is part of a new memory coalition to be created. This allows newly created processes to be partitioned into new or existing memory coalitions in order for the system to manage memory with respect to the memory coalitions which can exist at runtime in the data processing system.

The operations shown in in one embodiment can be performed on idle or suspended or background applications before operating on foreground applications and the foreground applications are processed according to their memory coalition size. The processing of memory reduction operations can take into account various priority levels such as the hierarchy shown in . In this hierarchy idle applications will be terminated before background applications are terminated and background applications will be terminated before extensions are terminated. Finally extensions will be terminated before foreground applications are terminated and the processing of memory reduction operations for foreground applications is based upon the memory coalitions of the various foreground applications in the manner described herein.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to one or more microprocessor s and a ROM Read Only Memory and volatile RAM and a non volatile memory . The microprocessor is coupled to optional cache . The microprocessor may retrieve the stored instructions from one or more of the memories and and execute the instructions to perform operations described above. These memories represent examples of machine readable non transitory storage media that can store or contain computer program instructions which when executed cause a data processing system to perform the one or more methods described herein. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be one or more of mice touch screens touch pads touch sensitive input devices keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory.

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory system which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that one or more embodiments may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem an Ethernet interface or a wireless network. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

In the foregoing specification specific exemplary embodiments have been described. It will be evident that various modifications may be made to those embodiments without departing from the broader spirit and scope set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

