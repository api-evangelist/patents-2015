---

title: Communication system for transmitting data under a tunnel protocol between at least two data computers via a wide area network and a method for running such a communication system
abstract: A communication system for transmitting data under a tunnel protocol between at least two computers via a wide area network, said system comprises


url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09590821&OS=09590821&RS=09590821
owner: HOB GMBH & CO. KG
number: 09590821
owner_city: Cadolzburg
owner_country: DE
publication_date: 20150116
---
This application claims the priority of Patent Application Serial No. EP 14 154 843.8 filed on 12 Feb. 2014 pursuant to 35 U.S.C. 119 a d the content of which is incorporated herein by reference in its entirety as if fully set forth herein.

The present invention refers to a communication system for transmitting data under a tunnel protocol between at least two computers via a wide area network said system comprising a first computer running a first user application and a virtual private network application which is designed to build up TCP and UDP tunnels with according tunnel endpoints a second computer running a second user application and a virtual private network VPN application which again is designed to build up TCP and UDP tunnels with according tunnel endpoints and a wide area network to which both computers are connected by physical connections wherein both user applications are implemented to communicate for an IP data packet exchange via at least one of the TCP tunnels and the UDP tunnel using the TCP and or UDP transport protocol based on according TCP UDP and IP stacks on both computers and to a method for running such a communication system according to the invention.

Before turning to the invention it is helpful to explain its background for better understanding. The field of the invention refers to the Transmission Control Protocol TCP which is one of the core protocols of the Internet protocol suite TCP IP . TCP provides reliable ordered error checked delivery of a stream of bytes between programs running on computers connected to a local area network intranet or the public Internet. Applications that do not require the reliability of a TCP connection may instead use the connectionless User Datagram Protocol UDP which emphasizes low overhead operation and reduced latency rather than error checking and delivery validation.

TCP is a connection oriented data transport protocol meaning that two applications each running on a computer establish a session connection before data can be exchanged. During session establishment also some protocol parameters may be negotiated. The data transport of a connection oriented protocol like TCP is also reliable meaning that lost data is retransmitted and that at the receiving end the data is delivered in the same order as it was sent by the sending application.

At the end of the data transfer protocol elements are used to finish the session connection in an ordered manner. In contrast to TCP UDP is a so called connection less protocol.

A TCP UDP IP stack is part of a computer s so called networking stack for example part of Windows or Unix operating system such as Linux. The TCP UDP IP stack is the piece of software which mainly handles the TCP UDP IP headers and builds the bridge between the computer s applications and the network interface.

A TCP stack terminates a TCP connection between two computers. In this context termination means that this is the endpoint of the TCP communication protocol. It does not mean close or end of the TCP connection.

An application software running on a computer communicates with the TCP UDP stack using for example the Berkeley Sockets API Application Programming Interface . The TCP UDP IP stack handles all network packets. These network packets can be sent and received over the public Internet and contain an IP header e.g. defining the level version IPv4 or IPv6 a TCP UDP header and the payload data.

The application communicating with the TCP UDP stack through the corresponding APIs does not receive the IP header or TCP UDP header of received packets by the computer but the payload data only. When sending data only that data is given to the corresponding API function while the TCP UDP and IP headers are generated by the TCP UDP IP stack.

In the Berkeley Sockets API used just as an example the application uses initializing functions like socket and bind . The TCP function connect is called to establish a connection to the other computer. To send data the TCP function send is called while the TCP function recv is called to receive data. Depending on the operation system some type of a TCP function call of close is called to shut down a connection.

The TCP stack has the functionality that an application can switch between blocking mode and non blocking mode. When blocking mode is used the called API functions return only at the time when the TCP stack has done the required work. When non blocking mode is used all API function calls return immediately but some mechanism is used so that the application is notified when the socket operation has completed. More sophisticated applications use non blocking mode.

TCP is used widely on the public Internet for example for Web browsing. UDP is the preferred protocol for telephony communication such as Voice over IP VoIP .

On networks like the public Internet when there is too much traffic network packets are silently discarded. This is a very important feature of the Internet Protocol IP as this Internet protocol is not connection oriented. If the Internet would use a connection oriented protocol such as the base application data transport protocol TCP it would not be able to handle all the huge number of data packets sent through today s public Internet.

When on a TCP connection a packet is lost the sending TCP stack does not get the acknowledge it waits for during a certain time so it sends the lost packet again.

Of course when packets are lost and are re sent after a certain time the number of data packets effectively sent over a TCP connection within a given period of time is much less compared to the possible maximum so the connection gets slow and the overall speed suffers.

Further on a TCP stack when sending packets cannot send packets as fast as the speed of the connected communication line would allow. This would result in too much packet losses. Instead a TCP stack starts slowly and monitors the connection to the partner computer. This mechanism is called slow start .

When no packets are lost the speed is increased. When packets are lost the speed is reduced to a starting value. This happens all the time while data is sent over a TCP connection.

TCP stacks also implement the functionality of flow control. Flow control means when the sending application tries to send data faster than the receiving application on the other computer receives and processes the data the sending application is blocked so it needs to wait.

This blocking of the sending application is done by means of the receiving TCP stack on the other computer. It still acknowledges the received data but it sends a TCP status information which is called zero window notifying the sending TCP stack that it cannot receive more data at the moment.

Further on TCP connections are established by a so called three way handshake between the two TCP stacks. This works as follows 

The TCP stack which wants to establish the connection with an application on a remote computer sends a TCP packet with the SYN bit set synchronize sequence numbers in the flags control bits of the TCP header SYN packet . The remote TCP stack answers with SYN and ACK acknowledgment bits set in the flags of the TCP header. Then the first client side TCP stack sends an acknowledge ACK packet to finally establish the TCP connection.

When on the remote side no application is listening for the destination port in the first incoming TCP packet with SYN the TCP stack answers with RST reset the connection so that no connection is established.

It may also happen that a client computer s TCP stack sends a SYN packet to an Internet address where there is no computer or the computer is not online. In this case there is no answer to the SYN packet and there is a timeout since no session can be established.

Fully transparent network access providing Virtual Private Network VPN tunnels can either use TCP or UDP as the transport layer protocol. They can also use other non connection oriented protocols like IPsec Internet Protocol Security which in turn can also use UDP User Datagram Protocol NAT T ESP Encapsulating Security Payload or AH Authentication Header .

When VPN tunnels use TCP as transport layer the security protocol used is usually SSL Secure Sockets Layer or TLS Transport Layer Security . In some implementations SSH Secure Shell is used.

There are advantages and disadvantages when using TCP as connection oriented protocol versus any other of the connection less protocols.

All this results in a significant interruption of the data stream to the receiver leading e.g. to a perceivable disturbance of the audio reproduction on the receiver side.

In this connection US 2012 0005369 A1 discloses a tunneling mechanism used to aggregate payloads from the network protocol at or below the tunneling layer into a single packet. A user space application establishes the TCP tunnel and encapsulates an end to end TCP payload into the TCP segment for transmission over a TCP connection. This enhanced TCP tunnel eliminates TCP meltdown and can be used over any network which supports TCP. The calling application either identifies the parameters of an existing TCP socket or establishes a new TCP socket. A modified transport layer uses the identified TCP connection in forming the enhanced TCP tunnel. The enhanced TCP tunnel manages the data transmission on the TCP stack to eliminate TCP meltdown. Summing up this known concept modifies the original TCP stacks built in on the sending and receiving computers to avoid TCP meltdown.

Another prior art document US 2006 0245414 A1 discloses a system method and computer program product for communicating with a private network. An application of a client is monitored for communications intended for a node coupled to a private network. Such a communication may then be intercepted before the communication can be received by the transport layer of the client the intercepted communication may then be sent with the connection identifier to an interface unit coupled to the private network via an established network connection over a public network. The connection identifier also associated with a communication link that is established over the private network between the interface unit and the node. The interface unit uses the connection identifier that is received with the communication to identify the associated communication link over the private network. The interface unit may then send the communication without the connection identifier to the node via the identified associated communication link. In this prior art reference TCP protocol data are not sent through the tunnel to avoid TCP meltdown but a proprietary protocol is used which thus needs to be implemented on both sides of the tunnel. This significantly limits the range of use of this system and method.

Now as concerns the problems underlying the present invention it is to be emphasized that in general the establishing and selection of TCP and or UDP sessions between the user applications are to be improved especially as concerns a maximum data transmission rate over wide area networks like the Internet and the avoidance of a meltdown of TCP connections.

An object of the invention is to improve the establishing and selection of TCP and or UDP sessions between two user applications avoiding the discussed prior art disadvantages of capacity limitations and meltdown problems.

This object is achieved by a communication system for transmitting data under a tunnel protocol between at least two computers via a wide area network said system comprising a first computer running a first user application and a virtual private network application which is designed to build up TCP and UDP tunnels with according tunnel endpoints a second computer running a second user application and a virtual private network VPN application which again is designed to build up TCP and UDP tunnels with according tunnel endpoints a wide area network to which both computers are connected by physical connections wherein both user applications are implemented to communicate for an IP data packet exchange via at least one of the TCP tunnel and the UDP tunnel using the TCP and or UDP transport protocol based on according TCP UDP and IP stacks on both computers and a splitter implemented in at least one of both computers which splitter analyzes the IP data packets to be sent from one of the computers to the other computer as concerns the type of the IP data packets and directs IP data packets of the TCP type to be transmitted over a TCP tunnel and IP data packets of the UDP type to be transmitted over a UDP tunnel.

Generally this system according to the invention can build two parallel tunnels to encapsulate mainly TCP IP and UDP IP packets for a fully transparent network access the first using TCP as tunnel protocol the second using UDP as tunnel protocol.

Before any IP packet is sent into one of both tunnels it is processed by the splitter which evaluates this packet and on behalf of this decides which of both tunnels is best suited for this packet to send it into the appropriate tunnel. Since both the TCP and the UDP tunnel have different characteristics with regards to encryption compression time delay and reliability the splitter performs optimization for the summary of the communication sessions.

Preferred embodiments of the invention are those according to which the splitter is either implemented as a computer program executable on the at least one computer or in both computers between which data are transmitted under the TCP and or UDP tunnel protocol.

At this point attention is drawn that to the fact that method aspects of the invention as described above are reflected in the corresponding method claims which are discussed further down the description.

According to another aspect the invention defines a communication system wherein both user applications are implemented to communicate for an IP data packet exchange via at least the TCP tunnel connection using the TCP transport protocol based on according TCP stacks and IP stacks on both computers successfully avoiding a TCP meltdown problem in line with the object of the invention mentioned above. In this context it is to be emphasized that the following characterizing features of the invention according to this aspect might also be applied to a TCP tunnel connection independently from the splitter implemented in or associated to at least one of both computers which splitter analyzes the IP data packets to be sent from one of the computers to the other computer as concerns the type of the IP data packets and directs IP data packets of the TCP type to be transmitted over a TCP tunnel and IP data packets of the UDP type to be transmitted over a UDP tunnel from the splitter implemented as a computer program executable on the at least one computer or from the splitter implemented in both computers. The invention according to this aspect thus is defined in that

The system relevant concept of the intermediate TCP stack is the basis for providing for a separate TCP data connection between the TCP stack of the user application and the user application sided TCP stack of the intermediate TCP stack unit which separate TCP data connection may not underlie the usual TCP restrictions of the slow start as discussed in the outset of this description thus avoiding the problem of a meltdown of the TCP tunnel connection.

Data processing relevant aspects of this general concept of the invention according to the above described aspect are reflected by the method for running a communication system in which both user applications are implemented to communicate for an IP data packet exchange via at least the TCP tunnel using the TCP transport protocol based on according TCP stacks and IP stacks on both computers wherein an intermediate TCP stack unit including a tunnel sided TCP stack and a user application sided TCP stack which are internally coupled by an internal communication connection is implemented in at least one of the tunnel endpoints of the TCP tunnel between the TCP tunnel and the TCP stack of the according user application wherein the tunnel sided TCP stack terminates the at least one TCP session encapsulated by the TCP tunnel in the tunnel endpoint and provides for a data volume buffer and wherein a separate TCP data connection is present between the user application sided TCP stack and the TCP stack of the user application which separate TCP data connection is controlled by the user application sided TCP stack depending on the data volume buffer status reported by the tunnel sided TCP stack by the method for running a communication system in which intermediate TCP stack units are implemented at both endpoints of the TCP tunnel connection between both computers and by a method for running a communication system in which the at least one intermediate TCP stack unit is implemented on a separate computer. Said method comprises the following method steps for avoiding meltdown of the TCP tunnel 

The communication system in which both user applications are implemented to communicate for an IP data packet exchange via at least the TCP tunnel using the TCP transport protocol based on according TCP stacks and IP stacks on both computers wherein an intermediate TCP stack unit including a tunnel sided TCP stack and a user application sided TCP stack which are internally coupled by an internal communication connection is implemented in at least one of the tunnel endpoints of the TCP tunnel between the TCP tunnel and the TCP stack of the according user application wherein the tunnel sided TCP stack terminates the at least one TCP session encapsulated by the TCP tunnel in the tunnel endpoint and provides for a data volume buffer and wherein a separate TCP data connection is present between the user application sided TCP stack and the TCP stack of the user application which separate TCP data connection is controlled by the user application sided TCP stack depending on the data volume buffer status reported by the tunnel sided TCP stack and the communication system in which intermediate TCP stack units are implemented at both endpoints of the TCP tunnel connection between both computers are preferred embodiments of the communication system in which both user applications are implemented to communicate for an IP data packet exchange via at least the TCP tunnel using the TCP transport protocol based on according TCP stacks and IP stacks on both computers wherein an intermediate TCP stack unit including a tunnel sided TCP stack and a user application sided TCP stack which are internally coupled by an internal communication connection is implemented in at least one of the tunnel endpoints of the TCP tunnel between the TCP tunnel and the TCP stack of the according user application wherein the tunnel sided TCP stack terminates the at least one TCP session encapsulated by the TCP tunnel in the tunnel endpoint and provides for a data volume buffer and wherein a separate TCP data connection is present between the user application sided TCP stack and the TCP stack of the user application which separate TCP data connection is controlled by the user application sided TCP stack depending on the data volume buffer status reported by the tunnel sided TCP stack inasmuch as on the one hand intermediate TCP stack units can be implemented at both endpoints of the TCP tunnel connection between both computers thus making the TCP tunnel connection bi directionally protected against meltdown problems. On the other hand it is advantageous to implement the at least one intermediate TCP stack unit on a separate computer thus representing a gateway concept between for example private local area network and a global public network like the Internet.

Coming back to the communication system s splitter functionality according to which the splitter is implemented in or associated to at least one of both computers which splitter analyzes the IP data packets to be sent from one of the computers to the other computer as concerns the type of the IP data packets and directs IP data packets of the TCP type to be transmitted over a TCP tunnel and IP data packets of the UDP type to be transmitted over a UDP tunnel according to which the splitter is implemented as a computer program executable on the at least one computer or according to which the splitter is implemented in both computers the invention also refers to method aspects complementing the splitter function by the following method steps for running a communication system according to the invention strictly speaking for establishing a UDP tunnel within the communication system 

Aforesaid process routine helps to figure out whether or not any desired UDP tunnel from a remote place like a WLAN in a hotel via the Internet to a company s LAN is blocked by any firewalls. If this is not the case it is possible to transmit payload data packets which do not underlie serious restrictions as to completeness of the transmission under the UDP protocol which as a rule is better suited for data streaming.

In a preferred embodiment of the invention according to the above described method for running a communication system according to the invention at least one of said computers is periodically sending keep alive packets within defined time periods independently from any IP data packets transmitted via the UDP tunnel. These keep alive packets overcome the problem when there are firewalls in between the UDP tunnel communication which firewalls do some type of network address translation NAT and use internal session tables for the established UDP communications leading to a time out in case the related UDP communication is no longer in use.

According to another preferred embodiment of said method an encryption of the IP data packets of the UDP type transmitted over the established UDP tunnel by means of a Secure Real time Transport Protocol or Datagram Transport Layer Security Protocol is possible.

Again as already mentioned above further data processing aspects in connection with the intermediate TCP stack unit which includes a tunnel sided TCP stack and a user application sided TCP stack which are internally coupled by an internal communication connection the intermediate TCP stack unit being implemented in at least one of the tunnel endpoints of the TCP tunnel between the TCP tunnel and the TCP stack of the according user application are reflected by the method for running a communication system in which both user applications are implemented to communicate for an IP data packet exchange via at least the TCP tunnel using the TCP transport protocol based on according TCP stacks and IP stacks on both computers wherein an intermediate TCP stack unit including a tunnel sided TCP stack and a user application sided TCP stack which are internally coupled by an internal communication connection is implemented in at least one of the tunnel endpoints of the TCP tunnel between the TCP tunnel and the TCP stack of the according user application wherein the tunnel sided TCP stack terminates the at least one TCP session encapsulated by the TCP tunnel in the tunnel endpoint and provides for a data volume buffer and wherein a separate TCP data connection is present between the user application sided TCP stack and the TCP stack of the user application which separate TCP data connection is controlled by the user application sided TCP stack depending on the data volume buffer status reported by the tunnel sided TCP stack a communication system in which intermediate TCP stack units are implemented at both endpoints of the TCP tunnel connection between both computers and a communication system in which the at least one intermediate TCP stack unit is implemented on a separate computer the method being characterized by the following method steps for avoiding a meltdown of the TCP tunnel 

By this method the problem of a slow start of data transmission of the TCP stack of the user application as it underlies the normal TCP tunnel connection is fully avoided preventing any reduction in the data transmission rate and any meltdown problems. This might become clearer with the help of the detailed description of the preferred embodiments of the invention to which attention is drawn to avoid any double explanations. This is also true for the preferred embodiments of the method in which the user application sided TCP stack notifies to the TCP stack of the user application to stop sending payload data by means of a zero window message in which the tunnel sided TCP stack notifies to the user application sided TCP stack when data can be accepted again by means of a end zero window in which the TCP stack of the user application restarts sending the payload data to the user application sided TCP stack without the use of a slow start mechanism in which the mechanism notifying the data volume buffer status and sending of zero window end zero window messages is used to both sides of the intermediate TCP stack unit including the tunnel sided TCP stack and the user application sided TCP stack in which for establishing a data exchange via TCP tunnel only control messages namely SYN SYN ACK and RST are exchanged between the involved TCP stacks of a receiver user application and a sender user application which message exchange takes place such that after having received a SYN request from the receiver user application through the TCP tunnel connection the tunnel sided TCP stack sends to the coupled user application sided TCP stack a SYN request as control message whereupon the user application sided TCP stack sends this SYN request to the TCP stack of the sender user application and the TCP stack of the sender user application sends a SYN ACK response to the user application sided TCP stack what is notified to the tunnel sided TCP stack which in turn sends a SYN ACK message to the TCP stack of the receiver user application and in which the TCP headers used in the communication between the coupled tunnel sided TCP stack and user application sided TCP stack of the intermediate TCP stack unit are modified in particular are optimized as concerns the maximum segment size of payload data 

Further features details and advantages of the invention become apparent from the following detailed description of preferred embodiments in accordance with the accompanying drawings.

Before turning to the invention again it is worthwhile explaining the background and the general field of the invention referring to .

The following predominantly describes a scenario where two applications typically one running on a server computer and the other running on a client computer exchange data over TCP or UDP. These two applications are called user applications in this document. More specifically the application which starts the connection from the user computer is called the user client application. The application which listens on the server computer waiting for incoming connections is called the user server application .

Now turning to a user client application running on computer communicates with a user server application running on computer using the TCP or UDP transport protocol which is part of the well known Internet protocol suite represented by the TCP UDP and IP stacks on the sender side and TCP UDP and IP stacks on the receiver side respectively where both transport layer protocols TCP and UDP are used alternatively depending on the applications . Both computers are connected to a network by the physical connections and respectively. The network may represent the public internet or any other IP network.

An important aspect of the described background of the invention is that the mentioned communication data packets sent and received between both computers do not go directly over the network as it would generally be possible but are encapsulated inside the tunnel . While the tunnel exists only once between both computers this tunnel is able to transport any number of communication sessions inside like sessions and in an encapsulating manner.

Further on it is to explain that the tunnel endpoint mentioned above is a termination of the VPN tunnel which means that the tunnel endpoint is a software program which handles the data transfer between the local area network represented by computer and the VPN tunnel .

Both computers and are running a Virtual Private Network VPN application which may build up two fully transparent tunnels namely TCP tunnel and UDP tunnel . While the connection oriented TCP tunnel is intended to transport any TCP or UDP sessions in an encapsulating manner established between the application running on computer and the application running on computer in either direction represented by the data streams and optionally in an encrypted and secured manner the connection less UDP tunnel is intended to transport some of the UDP data streams in an encapsulating manner established between the application running on computer and the application running on computer in either direction represented by the data streams and .

As TCP is not well suited to transport the data of real time streaming applications such as Voice over IP it may be advantages to use UDP as transport protocol for these real time streaming applications.

When such a said UDP tunnel can be established this works parallel to the TCP tunnel . The TCP tunnel is still used for those types of communication which can be compressed better when TCP is used as tunnel protocol.

The VPN applications running at both sides i.e. at the side of the sender and of the receiver build the TCP tunnel endpoints and the UDP tunnel endpoints . The normal user applications and are alternatively using either the TCP IP protocol stacks and or the UDP IP protocol stacks and respectively.

In order to exchange payload data between the applications and either the TCP half sessions and are being established which are in turn encapsulated by the TCP tunnel or the UDP data streams and are being established which in turn may be encapsulated by the UDP tunnel .

To decide whether the payload data are transmitted over the TCP tunnel or the UDP tunnel on each side of the tunnels there is implemented a special logic the splitters which as part of the VPN application decide about each incoming IP packet from the local network or user application whether this IP packet is to be forwarded through the TCP tunnel or through the UDP tunnel . Thus the splitter on the sender side and splitter on the receiver side distribute all outgoing packets into one of both tunnels or .

The criteria for this decision can simply mean that UDP packets are forwarded through the UDP tunnel while the remaining packets are forwarded through the TCP tunnel. More sophisticated but well known techniques can be used as well for example for VoIP voice over IP SIP examining the SDP Session Description Protocol to evaluate which UDP ports are used for RTP RTP A Transport Protocol for Real Time Applications RFC 3550 and sending especially the data for these ports through the UDP tunnel .

Before any IP packet is sent into one of both tunnels it is processed by the splitter program or which evaluates this packet and on behalf of this decides which of both tunnels is best suited for this packet to send it into the appropriate tunnel . Since both the TCP and the UDP tunnel have different characteristics with regards to encryption compression time delay and reliability the splitters perform optimization for the summary of the communication sessions.

A further preferred embodiment of the invention as concerns the process of establishing a UDP tunnel refers to a check method whether or not from a local area network LAN a UDP tunnel can be established to a remote LAN via the Internet 

Before building up the UDP tunnel test IP data packets of the UDP type so called UDP discovery packets are sent from a VPN application tunnel endpoint of the first computer and to explore the network by a three way exploration. This mostly means to check if any firewalls are blocking UDP traffic.

Thereby first the newly started tunnel endpoint on e.g. the sender side sends a UDP packet to the receiver side. When the tunnel endpoint receives this UDP discovery packet on the UDP port known to both sides it sends an acknowledgement reply. The tunnel endpoint receiving this reply can now be sure that UDP traffic is possible in both directions. The tunnel endpoint then sends another UDP packet as second acknowledgement reply. When this is received at the other side by tunnel endpoint now both sides can be sure that UDP tunnel communication is working in both directions. Then a fully transparent UDP tunnel may be established.

IP packets containing data which are appropriate for compression are preferably sent through the TCP tunnel . IP packets containing voice data are preferably sent through the UDP tunnel because this is expected to have the lowest delays while single packet loss can be accepted.

When encryption is needed for said UDP tunnel SRTP Secure Real time Transport Protocol RFC 3711 or DTLS Datagram Transport Layer Security RFC 6347 is used since both represent a secure transport protocol and have high tolerance to packet loss and re ordering.

When such a UDP tunnel has been established both sides need to periodically send keep alive packets within defined time periods even if there is no payload traffic from applications to be sent through the UDP tunnel . These keep alive packets are necessary if there are firewalls in between the computer s and respectively and the network which do some type of NAT network address translation and have internal tables for the established UDP sessions which generate a time out when no longer in use.

When no UDP tunnel can be established as was found out by not receiving the UDP discovery packets all payload data packets to be transmitted between the applications are forwarded over the TCP tunnel .

The following description relates to the data exchanged between two applications running on the computers and using the TCP transport protocol only. According to the TCP packets of the TCP half sessions and are encapsulated by the TCP tunnel . As explained in the introducing part of the description it is a prior art problem that TCP meltdown may happen within the data transmission over this TCP tunnel because of the TCP over TCP interference.

The solution of this problem is explained referring to which is a block diagram representation of a network scenario alternative to the simple tunnel endpoint of . This can be combined with the splitter functionality what however is left away in for sake of clarity.

Now the embodiment of is related to the sending direction of the TCP stack running on computer which in turn is marked as TCP sender . The tunnel endpoint consists not only of the TCP stack of said TCP tunnel but additionally of an intermediate TCP stack unit including coupled TCP stacks . The TCP stack at the other end of said tunnel is marked by . In other words the TCP tunnel is built by the TCP stacks and which does SSL TLS for security purpose while the coupled TCP stacks are inserted additionally. The intermediate TCP stack unit including the two coupled TCP stacks is implemented in only one tunnel endpoint which may run on an extra computer according to . In another preferred embodiment said coupled TCP stacks may be inserted on both sides of the tunnel .

The coupled TCP stacks of the intermediate TCP stack unit are identified as user application sided TCP stack and tunnel sided TCP stack but in the following only the reference numerals are used to differentiate between these two TCP stacks.

In by inserting the coupled TCP stacks the two TCP half sessions and of are each separated into two new TCP half sessions and respectively. The new half sessions and which are a separate TCP data connection between TCP stack and TCP stack of the user application are terminated by the TCP stack while the new TCP half sessions and are terminated by the TCP stack . Both coupled TCP stacks and are exchanging control information and the payload data of the applications and by means of the internal communication channels and respectively for both directions. The term termination in this context means that the coupled TCP stacks are set in between like proxies. Said coupled TCP stacks are special TCP implementations as described later on in this document as part of the tunnel endpoint . According tunnel endpoints may be implemented inside the communicating computers or in extra gateway computers like computer in at one or both sides of the TCP tunnel.

The two coupled TCP stacks terminate process the TCP protocol going through the TCP tunnel first to the TCP application on the same side of the tunnel user server application second in the direction to the TCP application on the other side of the tunnel user client application . The special TCP stack directed to the user server application on the same side of the tunnel uses normal mechanisms like zero window to control the speed of the data transfer in the TCP half sessions .

The tunnel connection is mostly the slowest part of the network especially when going over the public Internet while the TCP stack of the application is connected via the half sessions to the TCP stack of the tunnel endpoint over a LAN or even the tunnel endpoint is on the same computer as the TCP application where there is a high speed and mostly zero packet loss.

To refresh the meltdown problem reference is made again to or each without the coupled TCP stacks representing a state of the art TCP tunnel . TCP meltdown occurs because the sending TCP stack for example on a computer running a TCP application does not send data as fast as possible but needs to try out the connecting bandwidth through a slow start getting faster and reducing the speed of sending data as soon as an alleged packet loss is detected then again starting to increase the speed through slow start .

Through the TCP tunnel no packets of the application s TCP half sessions are lost because TCP is a connection oriented protocol. When packets of the TCP tunnel itself carrying the TCP packets of the TCP half sessions are lost this is recognized by the TCP stacks of the tunnel endpoints and the lost packets are re sent by this tunnel TCP protocol. The TCP connection inside the tunnel is not directly aware of these packet losses and the re sending done by the tunnel endpoints. Only a certain delay in receiving acknowledgments may be noticed which can be interpreted as packet loss initiating packet re sending and slow start at TCP stack and so can cause TCP meltdown.

Now referring to the coupled TCP stacks being inserted represent the solution for that previously described TCP meltdown problem 

The sending TCP stack of the TCP application is connected to the TCP stack at the tunnel endpoint where the bandwidth is fast. This TCP stack forwards the payload data to the coupled TCP stack through the internal communication as long as payload data can be sent through the tunnel . As data is received faster on connection line by TCP stack as can be sent on connection line by the tunnel TCP payload data needs to be buffered by TCP stack . TCP stack is notified by TCP stack when no more payload data can be sent through the TCP tunnel or when a certain buffer limit is reached then in turn TCP sends zero window to the applications TCP stack which in turn stops sending.

TCP stack directed to the TCP tunnel is also coupled with the TCP stack of the tunnel and so knows when payload data can again be sent through this TCP tunnel or when the buffered data is again below this certain limit. So the TCP stack does not use slow start or the other mechanisms of normal TCP stacks. Instead as notified by the TCP stack of the tunnel that payload data can be sent it always immediately sends the data received from TCP stack into the tunnel .

According to in the sending direction from the sending computer to the receiving computer the two terminating TCP stacks in one TCP tunnel endpoint are coupled as follows 

When the first TCP stack has received payload data it forwards these data to the second TCP stack of the intermediate TCP stack unit which in turn tries to send these data through the tunnel to the receiving TCP stack at the other side of the tunnel which normally has a lower speed compared to the speed on the connection between the sender TCP stack and the first of the coupled TCP stacks . When in this direction a certain buffer limit is exceeded in the second coupled TCP stack for the buffered receive data the first receiving TCP stack is notified and in turn sends zero window to the sending TCP stack of the sending application . Then the sending TCP stack stops sending.

When some of the buffered data in TCP has been sent into the tunnel and less data are buffered than the limit the receiving TCP stack is again notified by TCP stack and TCP stack sends the status information end zero window to the sending TCP which then immediately can send further payload data with high speed sent by the application of that sending computer without the use of the slow start mechanism i.e. without reduced data rate.

Summarizing the aforesaid data transmission concept the tunnel sided TCP stack terminates the at least one TCP tunnel connection in the tunnel endpoint and provides for a data volume buffer whereas a separate TCP data connection is present between the user application sided TCP stack and the TCP stack of the user application which separate TCP data connection is controlled by the user application sided TCP stack depending on the data volume buffer status reported by the tunnel sided TCP stack .

The following special functionality as a further preferred embodiment of the invention is also included in the coupled TCP stacks for the TCP session establishment 

A TCP session starts with the client sending a packet with the SYN flag being set in the TCP header. The receiving TCP stack normally replies with SYN ACK. The receiving TCP stack can also reply with RST when no application is listening on the destination TCP port.

When referring to the tunnel sided TCP stack receives a SYN from the TCP stack of the receiving computer client and replies with SYN ACK then the client TCP application is notified and the session represented by the half sessions is established.

But maybe the coupled TCP stack cannot establish a TCP session with the TCP stack at the destination computer because either there is no reply sent by TCP stack to the SYN packet or there is an RST sent as reply. For that reason the TCP stack does not reply to a SYN request received from TCP through the tunnel directly instead it sends this to the coupled TCP stack as a control message. Now the coupled TCP stack sends a SYN request to the target TCP stack and waits for a SYN ACK reply. When this reply is received the coupled TCP stack is notified and this then sends a SYN ACK to the initiating TCP stack . In case when an RST reply is received from TCP stack then this RST is forwarded to TCP stack .

In general the TCP stacks do not reply to a SYN request directly instead they send this to the coupled TCP stack as a control message. Now the coupled TCP stack sends a SYN request to the destination computer and waits for a reply. When this reply is received the other coupled TCP stack is notified and this then sends this reply SYN ACK or RST to the initiating TCP stack .

In this way SYN SYN ACK and RST are passed as control messages between the coupled TCP stacks. Not the complete received TCP header is exchanged but only the control information like SYN or SYN ACK.

Other fields of the TCP header may differ for the coupled TCP stacks . For example the MSS maximum segment size may be optimized. When the coupled TCP stacks are implemented on both sides of the TCP tunnel the MSS may be enlarged for packets sent through the TCP tunnel. Enlargement of the MSS results in improved performance since less header information needs to be transmitted for the total data being exchanged.

