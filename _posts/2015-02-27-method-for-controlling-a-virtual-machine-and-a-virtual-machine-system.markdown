---

title: Method for controlling a virtual machine and a virtual machine system
abstract: A next-generation OS with a virtualization feature is executed as a user program on a first virtual processor by selecting, in response to a cause of a call for a host VMM, one of a guest status area () for executing a user program on a second virtual processor and a host status area () for executing the guest VMM, and by updating a guest status area () of a shadow VMCS for controlling a physical processor. Accordingly, without a decrease in performance of a virtual computer, the next-generation OS incorporating the virtualization feature is executed on a virtual server, and the next-generation OS and an existing OS are integrated on a single physical computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396013&OS=09396013&RS=09396013
owner: Hitachi, Ltd.
number: 09396013
owner_city: Tokyo
owner_country: JP
publication_date: 20150227
---
This application is a continuation of U.S. patent application Ser. No. 12 213 287 filed Jun. 17 2008 which claims priority from Japanese application P2007 164892 filed on Jun. 22 2007 the content of which is hereby incorporated by reference into this application.

This invention relates to a virtual computer system and more particularly to a virtual computer system using a processor provided with a virtualization support feature.

Recently as open servers have become popular a large number of servers have been introduced to information systems used in enterprises. Especially indiscriminate introduction of Intel Architecture IA 32 servers which have high cost performance has increased the operation management cost of servers including the cost of power consumption and the cost of hardware maintenance and is posing a problem for the enterprises which are operating the servers.

A server integration which in order to reduce the operation management cost of servers unifies a plurality of servers into one physical server is promising. As a method for realizing the server integration a virtualization software program which provides a feature of virtualizing computer resources is attracting attention. The virtualization software program is a control software program which divides computer resources such as the CPU processor and I O s of a single physical server and assigns the divided computer resources to a plurality of virtual servers. On the respective virtual servers one OS guest OS can operate. By employing the virtualization software program it is possible to realize the server integration which assigns OS s and application programs which conventionally run on a plurality of physical servers to respective virtual servers thereby providing a plurality of servers on a single computer.

A description will now be given of a policy of the virtualization software program for assigning computer resources to virtual servers. For the assignment of the CPU as the computer resource virtualization software programs for the IA 32 mainly employ a processor provided with the virtualization support feature such as Virtualization Technology for Xenon VT x or AMD V . The VT x is a feature which assigns different operation privileges to a virtualization software program and a guest OS and is implemented as hardware of a processor as shown in JP 2005 529401 A Intel Corp. Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B retrieved on May 1 from www.intel.com 2007 and Advanced Micro Devices Inc. AMD Virtualization AMD V retrieved on May 1 2007 from www.amd.com for example. A CPU compliant with the VT x feature detects the operation privilege passed between the guest OS s and the virtualization software program and backs up and restores a register status of the CPU thereby providing independent operation environments for respective virtual servers. It should be noted that Intel Itanium Xenon and AMD are registered trademarks.

On the other hand a policy of the assignment of I O s depends on virtualization software programs. The assignments of the I O s by the virtualization software programs are generally classified into 

The 1. Direct I O assignment type has an advantage that for presently operating I Os of a physical server a server integration can be easily realized without rebuilding a file system or the like. On the other hand the 2. Virtual I O assignment type has an advantage that a certain I O configuration can be provided for guest OS s independently of I O types of a physical server.

The following are known examples of the virtualization software programs described above. First as a virtualization software program for an IA 32 server ESX Server of VMware registered trademark is known. The ESX Server can cause a plurality of conventional OS s to operate on a physical server employing an IA 32 CPU providing the above mentioned VT x feature.

As a virtualization software program based on a mainframe computer technology a logical partition operation feature in IBM System 370 for example is known. This feature partitions a single physical computer into a plurality of logical partitions LPAR s and causes a conventional OS and a virtual machine manager VMM to operate on the respective LPAR s. According to the logical partition operation feature the mainframe physical computer uses a feature LPAR mode corresponding to the above mentioned VT x of IA 32 to cause the conventional OS and the VMM to run on the virtual server LPAR .

Moreover SimOS is documented at simos.stanford.edu and is known as a virtualization software program which provides the VT x feature of the IA 32 by means of a simulator. A simulator of this type is a software program which provides functions of an arbitrary server and CPU by interpreting an instruction sequence of a guest OS on a virtual server.

Moreover as a virtualization support feature implemented on an IA 64 processor IPF Itanium Processor Family the VT i feature described parts 3.3.2 Processor Status Register 3.4 Processor Virtualization 11.7 PAL Virtualization Support of Intel Corp. Intel Itanium Architecture Software Developer s Manual vol. 2 is known.

Considering the recent needs for the server integration it has been studied to integrate the virtualization software feature of the 2. Virtual I O assignment type to a next generation server OS such as Windows Server Longhorn and Windows Server 2008.

Though the conventional virtualization software program such as the ESX Server can cause a conventional OS to run on a plurality of virtual servers based on the virtualization support feature VT x of a CPU constituting a physical computer the conventional virtualization software program cannot provide the virtual server with the VT x feature. Therefore the ESX Server has a problem that on the ESX server an OS incorporating a virtualization software program virtualization feature such as the next generation server OS is hard to execute.

Moreover according to the logical partition operation feature an OS or a VMM on an LPAR cannot use the LPAR mode. Therefore there poses a problem that an OS incorporating the virtualization software program is hard to operate on an LPAR.

Further the above mentioned simulator can provide a virtual server with the VT x feature thereby causing the next generation OS incorporating the virtualization software program to operate. However since the simulator interprets an instruction sequence of a virtual server guest OS and converts it into an instruction sequence executable on a CPU of a physical computer carries out a binary translation resulting in a generation of an overhead and a decrease in performance processing performance of the virtual server it is not practical for the simulator to carry out the server integration which requires operation of a plurality of virtual servers.

Moreover though a next generation OS incorporating a virtualization feature of the virtual I O assignment type is suitable for an application for generating a large number of virtual servers having the same I O configuration such as an application for providing a development environment the next generation OS is not suitable for an application for integrating conventional OS s operating on existing servers OS without using the VT x feature such as NT servers . Especially software assets presently operated by enterprises are mostly software programs operating on OS s without a virtualization feature. Therefore in a future server integration process a server integration environment in which existing OS s without a virtualization feature and newly introduced next generation OS s with a virtualization feature coexist is necessary. However as described above there has been the conventional problem that it is difficult to integrate next generation OS s incorporating a virtualization feature on a virtual computer and to integrate next generation OS s and conventional OS s.

In view of the above mentioned problems it is an object of this invention to provide a virtual computer which can run an OS incorporating a virtualization feature on a virtual server without decreasing a performance of the virtual computer and it is another object of this invention to integrate next generation OS s incorporating a virtualization feature and conventional OS s without a virtualization feature on a signal physical computer.

According to one aspect of this invention a recording medium is stored with a virtualization program for providing a plurality of virtual processors which is executed by a physical computer including a physical processor and a memory. The virtualization program causes the physical processor to execute the procedures of generating by the first virtual machine manager a first virtual processor 

generating by a second virtual machine manager executed on the first virtual processor a second virtual processor 

receiving by the first virtual machine manager a call for the first virtual machine manager from the physical processor 

analyzing by the first virtual machine manager a cause of the call for the first virtual machine manager 

determining by the first virtual machine manager based on a result of the analyzing which of the second virtual machine manager and the user program to execute and

instructing by the first virtual machine manager based on a result of the determining the first virtual processor to execute one of the second virtual machine manager and the user program.

According to another aspect of this invention a method of providing a plurality of virtual processors which is carried out by a physical computer including a physical processor and a memory includes the steps of 

generating by a second virtual machine manager executed on the first virtual processor a second virtual processor 

receiving by the first virtual machine manager a call for the first virtual machine manager from the physical processor 

analyzing by the first virtual machine manager a cause of the call for the first virtual machine manager 

determining by the first virtual machine manager based on a result of the analyzing which of the second virtual machine manager and the user program to execute and

instructing by the first virtual machine manager based on a result of the determining the first virtual processor to execute one of the second virtual machine manager and the user program.

Therefore according to this invention in response to the call for the first virtual machine manager by selecting one of the first control information used for executing the user program on the second virtual processor and the second control information used for executing the second virtual machine manager and by updating third control information with the selected control information it is possible to execute a next generation OS with a virtualization feature as a user program on the first virtual processor. Moreover since switching between the user program and the second virtual machine manger can be carried out by updating the third control information with the first or second control information it is possible to operate the next generation OS without a decrease in performance of the virtual computer.

Then a conventional OS without the second virtual machine manager and a next generation OS with the second virtual machine manager can be integrated on a single physical computer.

A description will now be given of embodiments of this invention with reference to accompanying drawings.

On the physical server in order to operate a plurality of virtual servers to a host virtual machine manager VMM is executed for converting physical computer resources of the physical server into virtualized computer resources and assigning the virtualized computer resources to the respective virtual servers to . This host VMM is provided as a program which is read to the memory and then executed by the physical CPU . The host VMM provides the respective virtual servers to with virtual CPU s to and assigns the memory and the I O device to the respective virtual servers to . A well known or publicly known method may be properly used for assigning the computer resources of the physical server to the respective virtual servers to and hence a detailed description thereof is omitted.

The physical server is coupled to a management console providing a user interface and an administrator or the like enters setting such as allocations of the computer resources or the like to the host VMM via the user interface . Moreover the user interface outputs setting statuses received from the host VMM and the like on a display device of the management console .

On the virtual servers to running on the host VMM of the physical server guest OS s to are respectively running as user programs to and on the respective guest OS s to application programs to are respectively executed. The OS s to are respectively executed on the virtual CPU s to provided by the host VMM . It should be noted that the virtual CPU s to allow assignment of a plurality of virtual CPU s to a single virtual server.

Then on the virtual server a next generation OS incorporating a virtualization feature guest VMM as the guest OS is running and on the virtual server a conventional OS such as the NT Server without using a virtualization feature as the guest OS is running.

The host VMM assigns the virtual CPU and computer resources set via the management console to the virtual server executing the conventional OS thereby executing the guest OS and the application program

On the other hand the host VMM provides the virtual CPU to be assigned to the virtual server executing the next generation OS with the virtualization support feature. On the virtual CPU the guest VMM second virtual machine manager is running and this guest VMM provides virtual CPU s to . On the virtual server on which the next generation OS is running on the first virtual CPU the plurality of second virtual CPU s to are provided and on the respective virtual CPU s to the plurality of user programs guest OS and application program to guest OS and application program are executed.

In the following section of this first embodiment a description will be given of an example in which the physical CPU has the VT x feature and the guest OS of the virtual server is the next generation OS incorporating the virtualization feature.

The host VMM using the VT x feature stores host VMM held data for storing statuses of the virtual servers to and control information used for controlling the physical CPU in a predetermined area of the memory . Then in the host VMM held data physical CPU control data used for controlling the physical CPU is stored. The physical CPU control data is a data structure representing statuses of the virtual CPU s to using the virtualization support feature and is referred to as virtual machine control block VMCB or virtual machine control structure VMCS . According to this embodiment as shown in the physical CPU control data in the host VMM held data are shadow VMCS s to n 1 virtual CPU control data handled by the guest VMM are a guest VMCS and the shadow VMCS s and the guest VMCS are distinguished from each other. Moreover the physical CPU has a pointer used to refer to the shadow VMCS s to n 1 in the physical CPU control data .

The host VMM sets an operation mode of the physical CPU to one of an operation mode VMX non root mode for executing the user program or the guest VMM and an operation mode VMX root mode for executing the host VMM by rewriting the shadow VMCS s to n 1 in the physical CPU control data .

On the virtual server the virtualization feature virtualization software program integrated into the guest OS which is the next generation OS runs as the guest VMM on the virtual CPU provided by the host VMM . The guest VMM stores the virtual CPU control data containing the VMCS guest VMCS used for controlling the virtualization support feature of the virtual CPU . The guest VMCS is stored in a predetermined area of the memory assigned by the host VMM .

Moreover the virtual CPU has a pointer used to refer to the virtual CPU control data guest VMCS of the guest VMM . This pointer is a pointer pointing to the control data structure guest VMCS of the virtual CPU corresponding to the VT x feature held by the guest OS and is initialized when a VMPTRLD instruction is issued by the guest OS . It should be noted that the pointer is initialized by the guest VMM .

In the virtual CPU s to of the virtual server on which the next generation OS is running are provided by the guest VMM integrated into the next generation OS and the user programs to can be executed on the respective virtual CPU s to . It should be noted that the guest VMM of the virtual server may serve as an add in software program of the guest OS

The VT x feature for supporting the virtualization controls the operation mode of the physical CPU by using the shadow VMCS s secured by the host VMM on the memory of the physical server . The physical CPU having the VT x feature as the virtualization support feature has the normal operation mode and the virtual machine extensions VMX mode for providing the virtualization support feature and in the VMX mode switches the mode either to the host mode hereinafter VMX root mode in which the host VMM operates or to the guest mode hereinafter VMX non root mode in which the guest VMM or the user program guest OS or the application program operates.

The shadow VMCS of the physical CPU control data has only one type of field guest status area specifying the operation status of the user program on the virtual server which does not make it possible to simply distinguish which of the guest VMM which is the virtualization feature of the next generation OS and the user program guest OS or application program is operating.

This invention focuses on a fact that the single virtual CPU does not execute the guest VMM and the user program at the same time the host VMM monitors the switch between the guest VMM and the user program of the virtual server executing the guest OS incorporating the virtualization function thereby rewriting the guest status area of the shadow VMCS s to n 1 of the host VMM held data in switching the operation mode and causing the virtualization feature to operate on the virtual server

Therefore the host VMM monitors the guest OS which is the next generation OS incorporating the virtualization feature switches the operation mode of the physical CPU between the VMX root mode in which the host VMM operates and the VMX non root mode in which the guest VMM or the user program operates and emulates instructions of the guest VMM or the guest OS under a predetermined condition VM exit in the VMX root mode. As a result for the guest OS it appears that the virtual CPU is providing the virtualization support feature.

The VMM includes in addition to the host VMM held data described above a CPU control module which monitors the virtual servers to and switches the operation mode of the physical CPU to one of the VMX root mode and the VMX non root mode.

Moreover the host VMM includes a control communication interface used by the CPU control module for acquiring the statuses of the virtual servers to and for transmitting an instruction to the respective virtual servers to an instruction issuing interface used by the CPU control module for issuing an instruction to the physical CPU a reference update interface used by the physical CPU for referring to or updating the physical CPU control data and an I O request response interface for receiving an interrupt request from the I O device and responding to the request.

The host VMM held data is constructed by an area for storing flags indicating use or nonuse of the virtualization support feature of the guest OS s to and the statuses of the virtual CPU s to and an area of the physical CPU control data for holding the shadow VMCS s to n 1 storing the statuses and the like of the respective virtual CPU s to

The flags of the host VMM held data indicating the statuses of the guest OS s and the virtual CPU s include for example a virtualization feature enable flag for specifying whether or not each of the guest OS s to can use the virtualization support feature of the physical CPU a VMXON flag for setting whether or not the virtualization support feature is being used by each of the virtual CPU s to and an operation mode flag for indicating whether the virtualization support feature is operating in one of the VMX root mode and the VMX non root mode for each of the virtual CPU s to

The virtualization feature enable flag is set for the respective guest OS s to is 1 when indicating that the corresponding guest OS can use the virtualization support feature and is 0 when indicating that the guest OS does not use the virtualization support feature. This virtualization feature enable flag is set to the respective guest OS s to from the management console or is set according to a file specified in advance.

The VMXON flag indicates whether the operation mode of the respective virtual CPU s to is the VMX mode or not is 1 when indicating that the operation mode of the corresponding virtual CPU s to is the VMX mode and is 0 when indicating that the operation mode of the corresponding virtual CPU s to is the normal operation mode in which the virtualization support feature is not used. The VMXON flag is set to 1 by the host VMM when the guest OS s to issue a VMXON instruction and is reset to 0 by the host VMM when the guest OS s to issue a VMXOFF instruction.

The operation mode flag is used to trace the operation mode of a program running on the virtual CPU s to . This operation mode flag is set to 1 by the host VMM upon a VM entry of the guest OS s to and is reset to 0 by the host VMM upon a VM exit of the guest OS s to . In other words the operation mode flag indicates when the VMXON flag is 1 the type of the VMX mode for the respective virtual CPU s to . When the operation mode flag is 0 the virtual CPU s to are in the status VMX root mode of the virtual CPU s of executing the guest VMM and when the operation mode flag is 1 the virtual CPU s are in the status VMX non root mode of the virtual CPU s to of executing the user program guest OS or application program .

The transition between the VMX root mode and the VMX non root mode in the VMX mode is carried out as described in Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B . Thus only a brief description will now be given thereof. Upon the transition from the normal operation mode to the VMX mode the host VMM issues the VMXON instruction thereby switching the operation mode of the physical CPU to the VMX mode. Then the host VMM in the VMX mode writes information used for executing the user program in the shadow VMCS s to n 1 of the corresponding CPU s to issues the VM entry instruction VMLAUNCH instruction or VMRESUME instruction and transitions from the VMX root mode to the VMX non root mode. This transition from the VMX root mode to the VMX non root mode is referred to as VM entry.

Conversely the transition from the VMX non root mode to the VMX root mode is referred to as the VM exit. Upon the VM exit due to a predetermined reason such as an issue of a privilege instruction of the guest OS s to the physical CPU notifies the host VMM of the VM exit. When the CPU control module of the host VMM detects the VM exit the CPU control module carries out a predetermined emulation thereby completing a process of the guest VMM or the guest OS rewrites the shadow VMCS according to necessity and issues the VM entry instruction first control instruction to switch the VMX non root mode to the VMX root mode.

According to this invention upon the VM entry of the guest OS which is the next generation OS the host VMM reads a guest status area and a host status area of a guest VMCS and sets a content of one of the areas according to an operation of the guest OS to the guest status area of a shadow VMCS thereby realizing the virtualization feature of the guest OS on the virtual server

According to the VT x feature the switching between the host VMM and the guest VMM or the user program is carried out by the transition between the VM entry and the VM exit as described above. Therefore in order to hold the statuses of the physical CPU or the like before and after the VM entry and the VM exit the shadow VMCS s to n 1 which are data structures of the physical CPU control data are used.

In the physical CPU control data the respective shadow VMCS s to n 1 are set for the respective virtual CPU s to and the respective shadow VMCS s to n 1 store the following data.

As shown in the guest status area stores statuses such as a register status of the virtual CPU s to . In other words as described later the statuses of the guest VMM or the statuses of the user program are selectively stored.

As shown in a host status area stores statuses such as the register status of the physical CPU of the host VMM . A VM execution control field stores setting information of the virtual servers to such as an exception bitmap and an I O bitmap. A VM exit control field stores information such as a reason for the VM exit. A VM entry control field stores information used for controlling an operation of the VM entry. A VM exit information field stores a reason instruction or event for generating the VM exit. As the reason for generating the VM exit a reason listed under description shown in and for example is set to the VM exit information field . is a block diagram showing an example of the control data of the shadow VMCS of the host VMM held data. to are diagram showing an example of a list of the reasons of the VM exit.

Using the shadow VMCS s to n 1 as described above the host VMM controls the respective virtual servers to

On the other hand the virtual CPU control data managed by the guest VMM of the virtual server stores the guest VMCS having the same data structure as the shadow VMCS of the above mentioned physical CPU control data .

The guest VMM includes the guest status area for storing statuses such as the register status of the virtual CPU executing the user program guest OS or application program and the like the host status area for storing statuses such as the register status of the virtual CPU executing the guest VMM a VM execution control field for storing setting information of the virtual server a VM exit control field for storing information such as a reason for the VM exit on the virtual server a VM entry control field for storing information used for controlling the operation of the VM entry on the virtual server and a VM exit information area for storing information identifying a reason for the VM exit on the virtual server

Similarly to the guest status area stores the statuses such as the register status of the virtual CPU . In other words as described later the statuses of the guest OS or the statuses of the application program are selectively stored.

In the shadow VMCS of the host VMM for controlling the statuses of the virtual server the guest status area stores the statuses of the VMM or the statuses of the user program guest OS or application program and the host status area stores the statuses of the host VMM .

On the other hand in the guest VMCS of the guest VMM the guest status area stores the statuses of the guest OS or the statuses of the application program and the host status area store the statuses of the guest VMM which is different from the shadow VMCS .

A description will now be given of a configuration of the CPU control module of the host VMM . The CPU control module includes in addition to a resource management module not shown for assigning the computer resources of the physical server to the respective virtual servers to according to the input from the management console or the like a status area selection module for selecting in order to cause the virtualization feature guest VMM of the guest OS to operate a source from which the statuses of the virtual CPU are read an emulator a shadow VMCS referring updating module a VM exit handler a VM entry instruction issuing module and a user interface . To the resource management module as described above a publicly known or well known technology may be applied and hence a detailed description thereof is omitted in this embodiment.

The emulator identifies an instruction or an event causing the VM exit received from the VM exit handler to generate starts as described later a module corresponding to the identified reason for the generation and carries out a process in place of the guest VMM or the user program

When the emulator detects a change of the operation mode switch between the VMX root mode and the VMX non root mode of the virtual CPU the emulator starts a module corresponding to the identified reason VM entry instruction execution module VMCLEAR instruction execution module CPUID instruction execution module or VM exit condition detection module and starts the status area selection module .

As shown in and on this occasion a reason for the generation of the VM exit is one set to Exit reason of the VM exit information field of the shadow VMCS . To the list of the reasons of the VM exit shown in A and reasons caused by the issue of the VM entry instruction reasons caused by the issue of the VMCLEAR instruction fourth control instruction and notice conditions to which an absence presence of a VM exit notice to the guest VMM is set are set in advance.

For example if the VM entry instruction VMLAUNCH instruction or VMRESUME instruction is detected as a reason for the VM exit when the operation mode of the virtual CPU is switched the VM entry corresponds to the reason of A and and thus the host VMM carries out the emulation on the VM entry instruction execution module thereby carrying out a process in place of the guest VMM or the user program

If a reason for the VM exit is a notice condition to the guest VMM corresponding to the notice condition of A and the host VMM starts the VM exit condition detection module and carries out the emulation similarly.

The status area selection module reads the operation mode flag of the virtual CPU CPU in this example which has generated the VM exit from the host VMM held data and determines whether the VMX mode is the VMX root mode or the VMX non root mode. If the operation mode flag is 0 which indicates the VMX root mode the guest VMM is operating and thus the status area selection module reads the host status area from the guest VMCS of the virtual server virtual server in this example which has generated the VM exit.

On the other hand if the operation mode flag is 1 which indicates the VMX non root mode the user program is operating and thus the status area selection module reads the guest status area from the guest VMCS of the corresponding virtual server

When the status area selection module has completed the read from the guest VMCS the CPU control module starts the shadow VMCS referring updating module . The shadow VMCS referring updating module writes the information of the guest VMCS read by the status area selection module in the guest status area of the shadow VMCS corresponding to the virtual CPU which is subject to the process of the VM exit thereby updating the shadow VMCS.

When the guest status area of the shadow VMCS has been completely updated the CPU control module in order to switch the operation mode of the virtual CPU from the VMX root mode to the VMX non root mode updates the operation mode flag to 1 and sets an address of the shadow VMCS of the subject virtual CPU to the pointer of the physical CPU .

Then the CPU control module starts the VM entry instruction issuing module thereby issuing the VM entry instruction VMRESUME instruction to the physical CPU .

When the physical CPU receives the VM entry instruction the physical CPU reads the guest status area of the shadow VMCS pointed by the pointer and executes the guest VMM or the user program of the virtual server selected by the status area selection module .

As described above when the guest OS which is the next generation OS incorporating the virtualization feature is operating on the virtual server and the CPU control module of the host VMM detects the VM exit of the physical CPU the CPU control module refers to the operation mode flag of the shadow VMCS to determine whether a program executed on the virtual CPU is the guest VMM or the user program . Then the CPU control module according to the program which has been executed on the virtual CPU writes a content of the guest status area or the host status area in the guest status area of the shadow VMCS of the host VMM and executes the VM entry instruction.

In this way by updating the guest status area of the shadow VMCS held by the host VMM with the information in the guest VMCS held by the guest VMM of the virtual server it is possible to integrate the virtual server running the guest OS with the virtualization feature and the virtual server executing the conventional OS without the virtualization feature into the single physical server .

A description will now be given of a process carried out by the host VMM with reference to . is a flowchart showing an example of a process carried out by the CPU control module of the host VMM when the CPU control module receives the VM exit from the physical CPU while the virtual servers to are operating. It should be noted that this is an example in which the reason for the VM exit is the VM entry instruction.

First in Step S the CPU control module of the host VMM refers to the virtualization feature enable flag of the host VMM held data corresponding to a subject guest OS of the guest OS s to referred to as guest OS hereinafter which has caused the VM exit thereby determining whether or not the guest OS which has generated the VM exit can use the VT x feature. If the subject guest OS can use the VT x feature the CPU control module proceeds to Step S. On the other hand if the subject guest OS does not use the VT x feature if the subject guest OS is the NT Server or the 2000 Server the CPU control module proceeds to Step S and the host VMM carries out a virtual machine process as described in Publication of Translation of International Application No. 2005 529401 or Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B .

In Step S the host VMM refers to the VMXON flag of the virtual CPU s to referred to as virtual CPU hereinafter which has caused the VM exit thereby determining whether the subject virtual CPU is in the VMX mode or not. If the VMXON flag is 1 the virtual CPU is in the VMX mode and then the CPU control module proceeds to Step S. On the other hand the VMXON flag is 0 the virtual CPU is in the normal operation mode and then the CPU control module proceeds to Step S similarly as described above and the host VMM carries out the conventional virtual machine process.

In Step S the CPU control module of the host VMM refers to the operation mode flag of the subject virtual CPU thereby determining whether the operation mode of the virtual CPU is the VMX root mode or the VMX non root mode. If the operation mode flag is 0 the CPU control module determines that the virtual CPU is in the VMX root mode and proceeds to Step S. On the other hand if the operation mode flag is 1 the CPU control module determines that the virtual CPU is in the VMX non root mode and proceeds to Step S.

In Step S the CPU control module identifies a reason for the generation of the VM exit received from the physical CPU . In this example since the operation mode of the virtual CPU is the VMX root mode the CPU control module refers to the guest status area storing the statuses of the guest VMM thereby identifying that the reason for the VM exit is the VM entry instruction issued by the guest VMM .

Then in Step S the CPU control module executes the VM entry instruction execution module from the emulator thereby emulating a predetermined process such as the startup of the status area selection module required for switching the subject virtual CPU to the VMX non root mode in place of the guest VMM .

Then in Step S since the CPU control module of the host VMM switches the operation mode of the virtual CPU from the VMX root mode to the VMX non root mode the CPU control module updates the operation mode flag of the subject virtual CPU to 1 . Then in Step S the CPU control module reads the statuses of the guest OS or the application program stored in the guest status area from the virtual CPU control data of the subject guest VMM .

Then in Step S the CPU control module issues the VMPTRLD instruction to the physical CPU thereby setting the shadow VMCS corresponding to the subject virtual CPU to be active and sets the address of the activated shadow VMCS to the pointer . As a result of this VMPTRLD instruction second control instruction the host VMM selects the shadow VMCS of the subject virtual CPU virtual server from the plurality of shadow VMCS s to n 1.

In Step S the CPU control module updates the guest status area of the subject shadow VMCS with the information of the guest status area read in Step S. Then in Step S the CPU control module issues the VM entry instruction to the physical CPU .

When the physical CPU receives the VM entry instruction the physical CPU executes the user program guest OS or application program of the subject virtual server based on the content of the guest status area of the shadow VMCS specified by the pointer . When the physical CPU receives the VM entry instruction the physical CPU stores the statuses of the host VMM which the physical CPU has been executing in the host status area of the shadow VMCS thereby preparing for the next call.

On the other hand if the operation mode flag is 1 in Step S since the subject virtual CPU is in the VMX non root mode which indicates that the subject virtual CPU is executing the user program the CPU control module executes a process of Step S.

In Step S the CPU control module refers to the list of reasons for the VM exit shown in A and thereby searching the notice conditions for a VM exit notice condition directed to the guest VMM. In this example since the VM entry instruction VMLAUNCH or VMRESUME instruction has caused the VM exit and thus meets the VM exit notice condition.

Then in Step S the CPU control module executes the VM exit condition detection module of thereby emulating a predetermined process such as the startup of the status area selection module required for switching the subject virtual CPU to the VMX root mode in place of the user program.

Then in Step S since the CPU control module switches the operation mode of the subject virtual CPU from the VMX non root mode to the VMX root mode the CPU control module resets the operation mode flag of the subject virtual CPU to 0 . Then in Step S the CPU control module reads the statuses of the guest VMM stored in the host status area from the virtual CPU control data of the subject guest VMM .

When the process of Step S has been completed the CPU control module executes Steps S to S updates the guest status area of the subject shadow VMCS with the information of the host status area read in Step S thereby setting the statuses of the guest VMM and issues the VM entry instruction to the physical CPU .

As a result when the physical CPU receives the VM entry instruction the physical CPU executes the guest VMM of the subject virtual server based on the content of the guest status area of the shadow VMCS specified by the pointer .

In this way if the guest OS is the next generation OS incorporating the virtualization feature the host VMM selects the statuses to be written to the guest status area of the shadow VMCS from either of the guest VMM and the user program according to the operation mode of the virtual CPU and the reason for the generated VM exit. Then when the host VMM issues the VM entry instruction to the physical CPU first virtual CPU it is possible to switch the execution on the virtual server between the guest VMM and the user program operating on the second virtual CPU provided by the guest VMM and thus the guest VMM can provide a plurality of virtualization environments user programs on the virtual server.

If it is determined that the guest OS does not use the virtualization feature in Step S or it is determined that the virtual CPU does not use the VT x feature of the physical CPU in Step S the virtual machine process according to Publication of Translation of International Application No. 2005 529401 or Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B may be carried out on the host VMM in Step S.

In the virtual machine process of Step S for example the guest OS of the virtual server shown in is a conventional OS and if this guest OS or the application program user program executes a predetermined instruction such as a privilege instruction as described above the physical CPU notifies the host VMM of the generation of the VM exit.

When the host VMM receives the notice of the VM exit from the physical CPU the host VMM stores the statuses of the user program virtual CPU in the guest status area of the shadow VMCS n 1. Then the host VMM sets an address of the pointer to the host status area in which the statuses of the host VMM is stored and carries out a predetermined process.

When the host VMM has completed the predetermined process such as the privilege instruction the host VMM stores the statuses of the host VMM in the host status area sets the address of the pointer to the guest status area then issues the VM entry instruction VMRESUME instruction and passes the control to the virtual CPU thereby resuming the execution of the user program

In this way according to this invention it is possible to integrate a next generation OS incorporating the virtualization feature and a conventional OS into the single physical server thereby reducing the number of physical servers and reducing the operation management cost of the servers.

Further as described above the host VMM can make it appear to the next generation OS that the virtual CPU provides the VT x feature thereby enabling to cause an OS incorporating a virtualization software program to surely operate. Moreover with the host VMM according to this invention there is no overhead caused by the conversion of an instruction sequence as in the conventional simulator and thus there is no decrease in the performance of the virtual computer and an OS incorporating a virtualization feature can be executed on the virtual server.

Moreover according to this invention since there are provided the plurality of shadow VMCS s to n 1 in correspondence to the plurality of virtual CPU s to even when a plurality of guest VMM s are executed on the physical server it is possible to quickly switch a process only by switching the shadow VMCS s to n 1. As a result even if a plurality of next generation OS s are integrated on the physical server it is possible to maintain the performance of the virtual server.

Steps S to S are the same as Steps S to S of the CPU control module of the host VMM determines whether or not the subject guest OS which has caused the VM exit can use the VT x feature and by referring to the VMXON flag of the subject virtual CPU determines whether or not the subject virtual CPU is using the VT x feature. If the subject guest OS does not use the VT x feature or the VMXON flag is 0 which indicates that the virtual CPU is in the normal operation mode the CPU control module proceeds to Step S and the host VMM carries out the conventional virtual machine process.

Moreover the CPU control module refers to the operation mode flag of the subject virtual CPU determines whether the operation mode of the virtual CPU is the VMX root mode or the VMX non root mode proceeds to Step S if the operation mode is the VMX root mode and proceeds to Step S if the operation mode is the VMX non root mode.

In Step S the CPU control module identifies a reason for the generated VM exit received from the physical CPU . In this example the CPU control module refers to the guest status area thereby identifying the VMCLEAR instruction of the guest VMM as a reason for the VM exit.

Then in Step S the CPU control module carries out the emulation by starting the VMCLEAR instruction execution module from the emulator of the CPU control module . In Step S the CPU control module reads the operation status of the physical CPU by means of the emulation and updates the shadow VMCS corresponding to the subject virtual CPU. As a result the statuses of the physical CPU are reflected to the shadow VMCS.

In Step S the CPU control module reads the statuses stored in the guest status area of the shadow VMCS corresponding to the subject virtual CPU.

Then in Step S the CPU control module writes the statuses read from the guest status area of the shadow VMCS in the guest status area of the guest VMM thereby updating the guest status area . As a result the guest status area of the guest VMM is synchronized with the statuses of the physical CPU .

In Step S the CPU control module sets the address of the pointer to the guest status area of the shadow VMCS corresponding to the subject virtual CPU thereby issuing the VM entry instruction to the physical CPU .

When the physical CPU receives the VM entry instruction the physical CPU executes the user program guest OS or application program of the subject virtual server based on the content of the guest status area of the shadow VMCS specified by the pointer .

On the other hand if it is determined that the operation mode flag is 1 in Step S since the subject virtual CPU is in the VMX non root mode the CPU control module executes a process of Step S. In Step S the CPU control module refers to the list of the reasons of the VM exit of and and analyzes the reason for the VM exit. The CPU control module searches the notice conditions for the VM exit notice condition directed to the guest VMM. In this example the VMCLEAR instruction has caused the VM exit and thus meets the VM exit notice condition.

Then in Step S the CPU control module notifies the guest VMM of an undefined instruction error. In other words the CPU control module notifies the guest VMM that the VMCLEAR instruction could not be executed under the privilege of the user program.

Then in Step S since the CPU control module switches the operation mode of the subject virtual CPU from the VMX non root mode to the VMX root mode the CPU control module resets the operation mode flag of the subject virtual CPU to 0 .

In Step S the CPU control module reads the statuses of the guest VMM stored in the host status area from the virtual CPU control data of the subject guest VMM .

In Step S the CPU control module writes the statuses of the host status area read in Step S in the guest status area of the subject shadow VMCS thereby updating the shadow VMCS. Then in Step S the CPU control module sets the address of the pointer to the guest status area and then issues the VM entry instruction to the physical CPU .

As a result when the physical CPU receives the VM entry instruction the physical CPU executes the guest VMM of the subject virtual server based on the content of the guest status area of the shadow VMCS specified by the pointer .

If it is determined that the guest OS does not use the virtualization feature in Step S or it is determined that the virtual CPU does not use the VT x feature of the physical CPU in Step S the virtual machine process according to Publication of Translation of International Application No. 2005 529401 or Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B cited in BACKGROUND OF THE INVENTION may be carried out by the host VMM in Step S as in Step S of .

In this way when the guest VMM issues the VMCLEAR instruction the host VMM acquires the operation status of the physical CPU and updates the guest status area of the shadow VMCS with the acquired operation status. Then the host VMM by reflecting the statuses of the guest status area of the shadow VMCS to the guest status area of the guest VMCS can synchronize the statuses of the physical CPU the guest status area of the host VMM and the guest status area of the guest VMM with each other.

As a result the next generation OS incorporating the virtualization feature can smoothly provide a virtual environment on the virtual server.

First in Step S the CPU control module of the host VMM as in Step S of refers to the operation mode flag of the subject virtual CPU which has caused the VM exit thereby determining whether the operation mode of the virtual CPU is the VMX root mode or the VMX non root mode. If the operation mode flag is 0 the CPU control module determines that the virtual CPU is in the VMX root mode and proceeds to Step S. On the other hand if the operation mode flag is 1 the CPU control module determines that the virtual CPU is in the VMX non root mode and proceeds to Step S.

In Step S as in Step S of the CPU control module identifies the reason for the VM exit received from the physical CPU according to the value of the guest status area . In this example since the operation mode is the VMX root mode the CPU control module identifies the reason for the VM exit as the CPUID instruction of the VMM .

In Step S as in Step S of the CPU control module refers to the virtualization feature enable flag of the host VMM held data corresponding to a subject guest OS which causes the VM exit and determines whether the guest OS which has generated the VM exit can use the VT x feature. If the subject guest OS can use the VT x feature the CPU control module proceeds to Step S. On the other hand if the subject guest OS does not use the VT x feature the CPU control module proceeds to Step S.

In Step S the CPU control module sets a predetermined bit of a return register ECX in the case of the IA 32 indicating a returned value of the CPUID instruction to 1 CPUID.1.ECX 5 1 thereby carrying out the setting indicating that the VT x feature is enabled.

On the other hand in Step S the CPU control module sets the predetermined bit of the return register ECX in the case of IA 32 indicating the returned value of the CPUID instruction to 0 thereby carrying out the setting indicating that the VT x feature is disabled.

Then in Step S the CPU control module starts the CPUID instruction execution module of the emulator carries out a check for faults to be notified to the guest VMM or the user program and stores a result of the check in the guest status area .

In Step S the CPU control module issues the VM entry instruction to the physical CPU thereby passing the control to the virtual server.

On the other hand if it is determined in Step S that the user program is being executed which is indicated by 1 of the operation mode flag VMX non root mode the CPU control module proceeds to Step S and analyzes the reason for the VM exit during the execution of the user program. In Step S the CPU control module identifies the reason for the generated VM exit received from the physical CPU according to the value in the guest status area . In this example since the operation mode is the VMX non root mode the CPU control module identifies the reason for the VM exit as the CPUID instruction of the guest OS or the application program.

In Step S the CPU control module determines whether a notice to the guest VMM is necessary for the VM exit caused by the CPUID instruction during the execution of the user program. This determination is made by the CPU control module by referring to information set in advance in the VM execution control field of the guest VMCS of the virtual CPU control data . If it is necessary to notify the guest VMM of the VM exit caused by the CPUID instruction the CPU control module proceeds to Step S. On the other hand if it is not necessary to notify the guest VMM of the VM exit the CPU control module proceeds to Step S and carries out the above mentioned processes starting from Step S.

In Step S in order to notify the guest VMM of the VM exit the CPU control module executes the VM exit emulator thereby resetting the operation mode flag of the subject virtual CPU to 0 and switching the VMX mode to the VMX root mode in Step S.

Then in Step S the CPU control module reads the statuses of the host status area of the subject guest VMCS . In Step S the CPU control module writes the read statuses to the guest status area of the shadow VMCS of the subject virtual CPU thereby updating the guest status area . Then in Step S the CPU control module issues the VM entry instruction to the physical CPU thereby passing the control to the guest VMM .

As described above when the guest VMM issues the CPUID instruction and when the VM exit caused by the CPUID instruction is not notified to the guest VMM after setting the value of the return register according to the setting of the virtualization feature enable flag the CPU control module can issue the VM entry instruction thereby returning the control to the guest VMM or the user program. Moreover when the user program has issued the CPUID instruction and it is necessary to notify the guest VMM of the VM exit the CPU control module can update the guest status area of the shadow VMCS with the content of the host status area of the guest VMCS thereby passing the control to the guest VMM .

As described above according to the first embodiment since the host VMM monitors the statuses of the guest OS and the application program and the statuses of the virtual CPU thereby rewriting the guest status area of the shadow VMCS it is possible to surely operate the next generation OS incorporating the virtualization feature without decreasing the performance of the virtual server. Then it is possible to make the next generation OS incorporating the virtualization feature and a conventional OS to coexist on the single physical server thereby efficiently carrying out the server integration resulting in a reduction of an operation cost of the server.

The user interface provided by the host VMM to the management console is constructed by a GUI shown in for example. is a screen image showing a user interface used for enabling disabling the virtualization feature for each virtual server. In VM indicates an identifier of the virtual server and Present Setting indicates whether the virtualization feature is enabled or disabled by ON or OFF respectively. Then by setting New Setting to ON or OFF and then clicking OK in a lower left section on the screen it is possible to switch the virtualization feature of a desired virtual server to the enabled or disabled status. In other words the host VMM sets according to a value of the New Setting input from the user interface 1 or 0 to the virtualization feature enable flag of the corresponding virtual server of the host VMM held data . As a result it is possible to set the setting value input from the user interface to an arbitrary virtual server.

It should be noted that the host VMM can be provided as a program stored on a recording medium such as an optical disk and a magnetic disk.

In a physical CPU on which the AMD V feature is implemented includes a pointer pointing to an address of the host status area in addition to the pointer pointing to the address of the shadow VMCB of the host VMM according to the first embodiment.

The physical CPU including the AMD V feature executes the VMRUN instruction instead of the VM entry instruction to switch the operation mode from the host mode for executing the host VMM to the guest mode for executing the guest VMM or the user program. The host VMM according to a specification of the AMD V feature is different from the first embodiment according to the VT x feature in the following points.

Of the host VMM held data the VMXON flag according to the first embodiment is removed and the virtualization feature enable flag for the respective virtual servers and the operation mode flag for the respective virtual CPU s to are provided. Then as shown in the physical CPU control data of the host VMM held data includes the host status area for the respective virtual CPU s to and the guest status area and a control area of the shadow VMCB s to n 1 for the respective CPU s to . It should be noted that the control area of the shadow VMCB s to n 1 stores information corresponding to the VM exit information field according to the first embodiment. shows the second embodiment and is a block diagram showing an example of the control data of the shadow VMCB of the host VMM held data.

In other words as shown in and the control area includes EXITCODE s indicating a code of a reason for generation of VMEXIT corresponding to the VM exit according to the first embodiment set in advance code names determination results indicating that the code is caused by the VMRUN instruction and notice conditions for notifying the guest VMM of the VMEXIT. and are diagrams showing an example of the list of the reasons for the VMEXIT.

The emulator of the CPU control module includes a VMRUN instruction execution module in place of the VM entry instruction execution module and the VMCLEAR instruction execution module is removed. Moreover the CPU control module includes a VMRUN instruction issuing module A for issuing the VMRUN instruction to the physical CPU in place of the VM entry instruction issuing module according to the first embodiment.

The virtual CPU s to with which the host VMM provides the virtual servers to according to the change in the configuration of the physical CPU include in addition to the pointer pointing to the address of the guest status area in the guest VMM a pointer pointing to the address of the host status area . It should be noted that the guest VMM runs on the virtual server when the next generation OS incorporating the virtualization feature is employed as the guest OS as on the virtual server according to the first embodiment.

The virtual CPU control data of the guest VMM is as well as the host VMM held data of the host VMM constructed by the host status area for holding statuses of the guest VMM according to the specification of the AMD V feature and the guest VMCB including the guest status area for storing statuses of the user program and the control area .

With the above mentioned configuration when the host VMM receives the VMEXIT from the physical CPU the host VMM by writing the content of the guest status area or the host status area of the guest VMM to the guest status area of the shadow VMCB s to n 1 can switch between the VMM integrated into the next generation OS running on the virtual server and the user program running on this guest VMM .

A description will now be given of a process carried out by the host VMM with reference to . is a flowchart showing an example of the process carried out by the CPU control module of the host VMM when the CPU control module receives the VMEXIT from the physical CPU while the virtual server is operating. It should be noted that this is an example in which the reason for the VMEXIT is because of the VMRUN instruction.

First in Step S the CPU control module of the host VMM refers to the virtualization feature enable flag of the host VMM held data corresponding to a subject guest OS hereinafter referred to as guest OS which has caused the VMEXIT and determines whether the guest OS which has generated the VMEXIT can use the AMD V feature. If the virtualization feature enable flag is 1 the CPU control module determines that the subject guest OS can use the AMD V feature and proceeds to Step S. On the other hand if the virtualization feature enable flag is 0 the CPU control module determines that the subject guest OS does not use the AMD V feature and proceeds to Step S. In Step S as in Step S shown in according to the first embodiment the host VMM carries out a conventional virtual machine process described in BACKGROUND OF THE INVENTION .

In Step S the CPU control module of the host VMM refers to the operation mode flag of the subject virtual CPU thereby determining whether the operation mode of the virtual CPU is the host mode VMX root mode according to the first embodiment or the guest mode VMX non root mode according to the first embodiment . If the operation mode flag is 0 the CPU control module determines that the virtual CPU is in the host mode and the CPU control module proceeds to Step S. On the other hand if the operation mode flag is 1 the CPU control module determines that the virtual CPU is in the guest mode and the CPU control module proceeds to Step S.

In Step S the CPU control module identifies a reason for the generated VMEXIT received from the physical CPU . In this example since the operation mode of the virtual CPU is the host mode the CPU control module refers to the guest status area storing the statuses of the guest VMM and identifies the VMRUN instruction issued by the guest VMM as the reason for the VMEXIT.

Then in Step S the CPU control module executes the VMRUN instruction execution module from the emulator thereby emulating a predetermined process such as the startup of the status area selection module required for switching the operation mode of the subject virtual CPU to the guest mode in place of the guest VMM .

Then in Step S since the CPU control module of the host VMM switches the operation mode of the virtual CPU from the host mode to the guest mode the CPU control module updates the operation mode flag of the subject virtual CPU to 1 .

Then in Step S the CPU control module reads the statuses of the user program the guest OS or the application program stored in the guest status area from the guest VMCB of the subject guest VMM .

In Step S the CPU control module updates the guest status area of the subject shadow VMCB with the information of the guest status area read in Step S. Then in Step S the CPU control module issues the VMRUN instruction to the physical CPU subject virtual CPU .

When the physical CPU receives the VMRUN instruction the physical CPU executes the user program guest OS or application program of the subject virtual server based on the content of the guest status area of the shadow VMCB specified by the pointer . When the physical CPU receives the VMRUN instruction the physical CPU stores the statuses of the host VMM in the host status area of the host VMM held data in preparation for the next call.

On the other hand if the operation mode flag is 1 in Step S the subject virtual CPU is in the guest mode which indicates that the subject virtual CPU is executing the user program and the CPU control module executes a process in Step S. In Step S the CPU control module acquires the EXITCODE refers to the list of reasons for the VMEXIT shown in and and searches the notice conditions for the VMEXIT notice condition directed to the guest VMM because the user program is being executed on the subject virtual server. In this example the VMRUN instruction has caused the VMEXIT and thus meets the VMEXIT notice condition. Then in Step S the CPU control module executes the VMEXIT condition detection module of from the emulator thereby emulating a predetermined process such as the startup of the status area selection module required for switching the operation mode of the subject virtual CPU to the host mode in place of the user program.

Then in Step S in order to switch the operation mode of the subject virtual CPU from the guest mode to the host mode the CPU control module resets the operation mode flag of the subject virtual CPU to 0 .

Then in Step S the CPU control module reads the statuses of the guest VMM stored in the host status area of the virtual CPU control data of the subject guest VMM .

When the CPU control module has completed the process in Step S the CPU control module executes Steps S and S updates the guest status area of the subject shadow VMCB with the information of the host status area read in Step S and issues the VMRUN instruction to the physical CPU subject virtual CPU . As a result when the physical CPU receives the VMRUN instruction the physical CPU executes the guest VMM of the subject virtual server based on the content of the guest status area of the shadow VMCB specified by the pointer .

In this way when the guest OS running on the virtual server is the next generation OS incorporating the virtualization feature the host VMM selects the statuses to be written to the guest status area of the shadow VMCB from one of the guest VMM and the user program according to the operation mode of the virtual CPU and the reason for a generated VMEXIT. Then when the host VMM issues the VMRUN instruction to the physical CPU it is possible to switch between the executions of the guest VMM running on the first virtual CPU and the user program running on the second virtual CPU provided by the guest VMM on the virtual server and the guest VMM can thus provide virtualization environments on the virtual server.

If it is determined that the guest OS does not use the virtualization feature in Step S the virtual machine process according to Publication of Translation of International Application No. 2005 529401 or Intel 64 and IA 32 Architectures Software Developer s Manual VOL 2B cited in BACKGROUND OF THE INVENTION may be carried out on the host VMM in Step S.

In the virtual machine process in Step S for example the guest OS of the virtual server shown in is a conventional OS and if this guest OS or the application program user program executes a predetermined instruction such as a privilege instruction as described above the physical CPU notifies the host VMM of the generation of the VMEXIT.

When the host VMM receives the notice of the VMEXIT from the physical CPU the host VMM stores the statuses of the user program virtual CPU in the guest status area of the shadow VMCB n 1.

When the host VMM has completed the predetermined process such as the privilege instruction the host VMM stores the statuses of the host VMM to the host status area sets the address of the pointer to the address of the guest status area then issues the VMRUN instruction and passes the control to the virtual CPU thereby resuming the execution of the user program

In this way according to the second embodiment as well as the first embodiment it is possible to run the next generation OS incorporating the virtualization feature on the host VMM . Then it is possible to integrate the next generation OS incorporating the virtualization feature and a conventional OS into the single physical server thereby reducing the number of physical servers and reducing the operation management cost of the servers.

Moreover as described above the host VMM can make it appear to the guest VMM running on the first virtual CPU that the first virtual CPU provides the AMD V feature thereby enabling the OS incorporating the virtualization software program to surely operate. Moreover with the host VMM according to this invention there is no overhead caused by the conversion of an instruction sequence as in the conventional simulator and thus there is no decrease in the performance of the virtual computer and the OS incorporating the virtualization feature can be executed on the virtual server.

In when an instruction or an event set in advance occurs while a physical CPU incorporating the VT i feature is executing a guest guest VMM or user program the physical CPU generates a virtualization fault and passes the control to the host VMM . When the host VMM detects the virtualization fault the host VMM executes emulates a virtualization procedure set in advance such as PAL VPS RESUME procedure updates a shadow virtual processor descriptor shadow VPD used for controlling the virtual CPU s to and issues the virtualization procedure PAL VPS RESUME procedure to the physical CPU thereby passing the control to the guest. It should be noted that the PAL VPS RESUME NORMAL procedure call and the PAL VPS RESUME HANDLER procedure call are generally referred to as PAL VPS RESUME procedure.

In other words the physical CPU has an architecture for switching the control between the host VMM and the guest by generating a virtualization fault in place of the VM exit according to the first embodiment and executing a virtualization procedure in place of the VM entry instruction. Details thereof are described in Intel Itanium Architecture Software Developer s Manual and hence a detailed description of this architecture is omitted.

In the host VMM held data of the host VMM virtual CPU control data B storing in addition to the virtualization feature enable flag and the operation mode flag according to the first embodiment an architecture status for storing statuses of the virtual CPU s to is provided.

The physical CPU control data stores the following data according to the specification of the VT i feature. The physical CPU control data includes shadow VPD s to n 1 including an architecture status for storing statuses of the respective virtual CPU s to virtualization disable control VDC fields to n 1 used for setting restriction on the generation of the virtualization fault for the respective virtual CPU s to and a virtualization fault reason for defining in advance instructions and events which generate a virtualization fault on the physical CPU of instructions or events executed by the virtual CPU s to

Moreover the virtualization fault reason stored in the physical CPU control data of the host VMM held data is set as shown in a virtualization fault reason list of and for example. In and the virtualization fault reason list includes codes indicating reasons for the virtualization fault contents of the virtualization fault corresponding to the respective codes call settings used for calling the PAL VPS RESUME procedure for passing the control to the guest and notice settings used for notifying the guest VMM of the virtualization fault. An instruction including the call setting of .smallcircle. calls the PAL VPS RESUME procedure for passing the control to the guest. Moreover an instruction including the notice setting of .smallcircle. carries out the notice to the guest VMM when the generation of the virtualization fault is not restricted by the VDC field of the guest VMM .

The statuses of the virtual CPU held by the guest VMM is stored in virtual CPU control data A . The virtual CPU control data A includes a guest VPD including an architecture status for storing statuses of the virtual CPU a virtualization fault reason defining an instruction or an event which generates the virtualization fault on the virtual CPU of instructions or events executed by the guest OS or the application program and a VDC field indicating whether or not the virtual CPU executing the guest VMM uses the VT i feature. and show the third embodiment and is an explanatory diagram showing an example of the list of reasons for the virtualization fault.

The CPU control module includes a virtualization fault handler for detecting the virtualization fault from the physical CPU and notifying the emulator of the virtualization fault the emulator causing a process which has become the virtualization fault to be executed on the processor abstraction layer PAL provided by the physical CPU a status area selection module for selecting the architecture status of the guest VPD or the architecture status of the virtual CPU control data B of the host VMM held data based on the operation status of the virtual CPU a shadow VPD referring updating module for updating the architecture status of the shadow VPD with the information selected by the status area selection module and a virtualization procedure instruction module for instructing the physical CPU to execute a predetermined procedure for switching the control from the host VMM to the guest VMM or the user program running on the second virtual CPU on the guest VMM .

A description will now be given of an example of a process carried out by the CPU control module of the host VMM with reference to a flowchart shown in . It should be noted that the following description will be given of an example in which on the virtual server shown in according to the first embodiment the guest OS which is the next generation OS the application program and the guest VMM are running

First in Step S the CPU control module of the host VMM refers to the virtualization feature enable flag of the host VMM held data corresponding to the subject guest OS hereinafter referred to as guest OS which has caused the virtualization fault and determines whether the guest OS which has caused the virtualization fault can use the VT i feature. If the virtualization feature enable flag is 1 the CPU control module determines that the subject guest OS can use the VT i feature and proceeds to Step S. On the other hand if the virtualization feature enable flag is 0 the CPU control module determines that the subject guest OS does not use the VT i feature and proceeds to Step S. In Step S the host VMM carries out a conventional virtual machine process by means of the VT i feature described in Intel Itanium Architecture Software Developer s Manual .

In Step S the CPU control module of the host VMM refers to the operation mode flag of the subject virtual CPU thereby determining whether the operation mode of the virtual CPU is the host mode VMX root mode according to the first embodiment or the guest mode VMX non root mode according to the first embodiment . If the operation mode flag is 0 the CPU control module determines that the virtual CPU is in the host mode for executing the guest VMM and the CPU control module proceeds to Step S. On the other hand if the operation mode flag is 1 the CPU control module determines that the virtual CPU is in the guest mode for executing the user program and the CPU control module proceeds to Step S.

In Step S the CPU control module identifies a reason for the generated virtualization fault received from the physical CPU . In this example since the operation mode of the virtual CPU is the host mode the CPU control module refers to the architecture status of the virtual CPU control data B of the host VMM held data storing the statuses of the guest VMM and identifies the vmsw instruction issued by the guest VMM from the PAL VPS RESUME procedure as the reason for the virtualization fault.

Then in Step S the CPU control module executes the PAL VPS RESUME procedure module which has caused the virtualization fault and executes the predetermined process in place of the guest VMM thereby executing a predetermined process such as the startup of the status area selection module required for switching the operation mode of the subject virtual CPU to the guest mode.

Then in Step S since the CPU control module switches the operation mode of the virtual CPU from the host mode to the guest mode the CPU control module updates the operation mode flag of the subject virtual CPU to 1 .

Then in Step S the CPU control module reads the statuses of the user program guest OS or application program stored in the architecture status from the guest VPD of the virtual CPU control data A of the subject guest VMM .

In Step S the CPU control module issues the PAL VPS SAVE RESTORE procedure to the physical CPU and selects the shadow VPD which has caused the issue of the virtualization fault.

Then in Step S the CPU control module writes the statuses of the architecture status read in Step S to the architecture status of the subject shadow VPD selected in Step S thereby updating the architecture status . Then in Step S the CPU control module issues the PAL VPS RESUME procedure to the physical CPU

When the physical CPU receives the PAL VPS RESUME procedure the physical CPU executes the user program guest OS or application program of the subject virtual server based on the content of the architecture status of the shadow VPD selected in Step S.

On the other hand if the operation mode flag is 1 in Step S the subject virtual CPU is in the guest mode which indicates that the subject virtual CPU is executing the user program and the CPU control module executes a process in Step S. In Step S the CPU control module acquires the reason for the virtualization fault and refers to the list of reasons for the virtualization fault shown in and thereby searching the notice conditions for the virtualization fault notice condition directed to the guest VMM . In this example since the reason for the virtualization fault is the vmsw instruction the virtualization fault notice condition follows the setting in the VDC field of the guest VMM . On this occasion the virtualization fault is notified to the guest VMM . Then in Step S the CPU control module executes the virtualization fault condition detection module of thereby emulating a predetermined process such as the startup of the status area selection module required for switching the operation mode of the subject virtual CPU to the host mode in place of the guest VMM .

Then in Step S in order to switch the operation mode of the subject virtual CPU from the guest mode to the host mode the CPU control module resets the operation mode flag of the subject virtual CPU to 0 .

Then in Step S the CPU control module reads the statuses of the guest VMM stored in the architecture status of the virtual CPU control data B corresponding to the subject virtual CPU in the host VMM held data .

When the CPU control module has completed the process in Step S the CPU control module carries out Steps S to S updates the architecture status of the subject shadow VPD with the information of the architecture status of the virtual CPU control data B of the host VMM held data read in Step S and issues the PAL VPS RESUME procedure to the physical CPU . As a result when the physical CPU receives the PAL VPS RESUME procedure the physical CPU executes the guest VMM of the subject virtual server based on the content of the architecture status of the shadow VPD .

In this way if the guest OS running on the virtual server is the next generation OS incorporating the virtualization feature the host VMM selects the statuses to be written to the architecture status of the shadow VPD from one of the guest VMM and the user program according to the operation mode of the virtual CPU and the reason for a generated virtualization fault. Then when the host VMM issues the PAL VPS RESUME procedure to the physical CPU it is possible to switch between the executions of the guest VMM and the user program running on the second virtual CPU provided by the guest VMM on the virtual server and the guest VMM can thus provide a virtualization environment on the virtual server.

If it is determined that the guest OS does not use the virtualization feature in Step S the virtual machine process according to Publication of Translation of International Application No. 2005 529401 or Intel Itanium Architecture Software Developer s Manual cited in BACKGROUND OF THE INVENTION may be carried out by the host VMM in Step S.

In the virtual machine process in Step S for example the guest OS of the virtual server shown in is a conventional OS and if this guest OS or the application program user program executes an instruction of the reason for the virtualization fault as described above the physical CPU notifies the host VMM of the generation of the virtualization fault.

When the host VMM receives the notice of the virtualization fault from the physical CPU the host VMM stores the statuses of the user program virtual CPU in the architecture status of the virtual CPU control data B .

When the host VMM has emulated the instruction which has caused the virtualization fault the host VMM issues the PAL VPS RESUME procedure passes the control to the virtual CPU and resumes the execution of the user program

In this way according to the third embodiment as well as the first embodiment it is possible to integrate a next generation OS incorporating the virtualization feature and a conventional OS into the single physical server thereby reducing the number of physical servers and reducing the operation management cost of the servers.

Moreover as described above the host VMM can make it appear to the next generation OS that the virtual CPU provides the VT i feature thereby enabling the OS incorporating the virtualization software program to surely operate. Moreover with the host VMM according to this invention there is no overhead caused by the conversion of an instruction sequence as in the conventional simulator and thus there is no decrease in the performance of the virtual computer and the OS incorporating the virtualization feature can be executed on the virtual server.

It should be noted that the processors described as the physical CPU s and according to the respective embodiments may be a configuration of a multi core processor and can employ homogeneous or heterogeneous processors. In other words when as the physical CPU s and a heterogeneous multi core processor including a plurality of general purpose processor cores CPU s and special purpose processor cores is used as long as the general purpose processor core has the virtualization support feature this invention can be applied.

As described above this invention may be applied to a virtual computer system providing a plurality of virtual servers. Moreover this invention may be applied to a virtual machine manager VMM software program providing a plurality of virtual servers on a physical computer.

While the present invention has been described in detail and pictorially in the accompanying drawings the present invention is not limited to such detail but covers various obvious modifications and equivalent arrangements which fall within the purview of the appended claims.

