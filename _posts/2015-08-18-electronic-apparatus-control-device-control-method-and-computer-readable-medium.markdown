---

title: Electronic apparatus, control device, control method, and computer readable medium
abstract: An electronic apparatus includes a first controller, a second controller, and plural devices. The first controller executes a first operating system. The second controller executes a second operating system. The plural devices are controlled by the second controller. The first controller includes a first conversion unit, a command writing unit, a status reading unit, a second conversion unit, a status disposal unit, and a reset unit. The first conversion unit converts a function which is called by a process into a command. The command writing unit writes the command to a storage region of the second controller. The status reading unit reads a status. The second conversion unit converts the read status into a return value, and returns the return value to the process. The status disposal unit disposes of, for each communication channel, the read status. The reset unit resets, for each communication channel, software and a device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507611&OS=09507611&RS=09507611
owner: FUJI XEROX CO., LTD.
number: 09507611
owner_city: Tokyo
owner_country: JP
publication_date: 20150818
---
This application is based on and claims priority under 35 USC 119 from Japanese Patent Application No. 2015 020391 filed Feb. 4 2015.

The present invention relates to an electronic apparatus a control device a control method and a computer readable medium.

According to an aspect of the invention there is provided an electronic apparatus including a first controller a second controller and plural devices. The first controller executes a first operating system. The second controller executes a second operating system. The plural devices are controlled by the second controller. The first controller includes a first conversion unit that converts a function which is called by a process operating on the first operating system into a command which is to be interpreted in common by the first operating system and the second operating system a command writing unit that writes the command obtained by the conversion at the first conversion unit to a storage region of the second controller a status reading unit that reads from the storage region a status which represents a result of execution of a system call of the second operating system by the second controller the system call corresponding to the command which is written by the command writing unit a second conversion unit that converts the status which is read by the status reading unit into a return value which is to be interpreted by the process and returns the return value to the process a status disposal unit that disposes of for each communication channel the status which is read by the status reading unit in a case where the process is restarted after the writing of the command is performed by the command writing unit and a reset unit that resets for each communication channel software which operates at the second controller that is executing the system call and a device which is controlled by a driver that is called by the system call in a case where the process is restarted after the writing of the command is performed by the command writing unit.

In an exemplary embodiment a basic configuration such as a so called multi processor system which includes two central processing units CPUs is provided. Hereinafter however a basic software configuration of a single processor system and a basic software configuration of a multi processor system will be explained. In the explanation provided below for convenience a software component is defined as the subject of an operation.

The intra OS communication driver delivers the received commands to tasks and . Upon receiving the commands the tasks and convert the commands into the system calls which are to be interpreted by the drivers and respectively and call the drivers and by the system calls via the APIs and respectively. The called drivers and execute processing corresponding to the content of the system calls and return via the APIs and the return values which represent corresponding processing execution results to the tasks and .

Upon receiving the return values in order to deliver the content of the return values to the first OS the tasks and convert the return values into statuses which are to be interpreted in common by the first OS and the second OS and deliver the statuses to the intra OS communication driver . The intra OS communication driver transmits the statuses to the intra OS communication driver through intra OS communication. The intra OS communication driver delivers the received statuses to the libraries and . Upon receiving the statuses the libraries and convert the statuses into return values which are to be interpreted by the processes and and return via the APIs and the return values to the processes and respectively. Accordingly the same processing results as those obtained when the processes and directly call the drivers and in the single processor system may be obtained by the multi processor system.

Next a configuration according to an exemplary embodiment will be explained. is a diagram illustrating a hardware configuration according to an exemplary embodiment. is a diagram illustrating a software configuration according to an exemplary embodiment. An image forming apparatus is an example of an electronic apparatus according to an exemplary embodiment of the present invention. Principal components of the image forming apparatus are the first controller the second controller and a device . The first controller controls the second controller . The second controller controls the device .

The first controller includes an arithmetic unit such as a CPU storing units such as a random access memory RAM and a read only memory ROM a communication interface I F an external storing unit such as a hard disk drive HDD and a local area network LAN terminal . These components are connected to a bus . The CPU uses the RAM as a work area and executes a program. A boot loader and the like are stored in the ROM . The communication I F is for example a PCIe slot and is connected to a communication I F which is a PCIe slot provided at the second controller by a signal line. The first OS an application program and the like are stored in the HDD . When the power is supplied to the image forming apparatus the CPU reads the boot loader from the ROM reads the first OS from the HDD and executes the first OS in accordance with a procedure described in the boot loader. The first OS is for example Linux . A signal line is connected to the LAN terminal and the CPU communicates with an external information processing apparatus and the like via a LAN.

The second controller includes an arithmetic unit such as a CPU storing units such as a RAM and a ROM and the communication I F . These components are connected to a bus . The CPU uses the RAM as a work area and executes a program. The second OS is stored in the ROM . The CPU reads the second OS from the ROM and executes the second OS in accordance with an instruction from the first controller . The second OS is for example a real time OS RTOS and has a function of a driver which controls the device .

The image forming apparatus includes one or more devices . The devices are for example an image scanner a printer a user interface UI and the like. The number of devices is not particularly limited. The image scanner includes for example a light source an optical system an imaging element and the like not illustrated in . The light source irradiates an original with light and reflected light which is reflected on the original enters the imaging element through the optical system. Then the imaging element generates a signal which represents an image of the original and outputs the signal. The printer includes for example a print engine which forms a tone image based on image data a housing unit which houses a recording medium such as paper a conveyance mechanism which conveys the recording medium along a transport path and the like not illustrated in . The printer prints an image based on the image data supplied from the first controller via the second controller onto the recording medium in an electrophotographic method. The UI includes for example a touch panel a keypad and the like not illustrated in and receives an operation by a user. On the touch panel a virtual operator to be operated by the user to operate the image forming apparatus information indicating the status of the image forming apparatus and the like are displayed. The keypad includes keys to be used for issuing instructions for starting and stopping the operation of the image forming apparatus ten keys to be used for inputting numbers and the like.

In an exemplary embodiment the intra OS communication driver and the intra OS communication driver exchange the commands and the statuses via a command buffer and a status buffer . A storage region of the RAM may be used as the command buffer and the status buffer . Alternatively by providing a memory which is different from the RAM in the second controller a storage region of the memory may be used as the command buffer and the status buffer . The command buffer and the status buffer are for example buffers of a first in first out FIFO type and have a function for notifying the intra OS communication driver and the intra OS communication driver of FULL NOT FULL EMPTY NOT EMPTY information which indicates the status of each storage region by interrupt .

For example a case in which the process calls the function illustrated below will be explained. In this case the process is configured to directly call the function of the library and error check for the return value of each function is omitted.

Here the third argument of the function do ioctl which is the second called function in the above function call example serves as a pointer which indicates the logical address of a storage region. However in the case where the logical address of the first controller differs from the logical address of the second controller even if the pointer is directly delivered to the second controller the second controller is not able to access the storage region which is indicated by the pointer. Therefore in generation of the command data the processing routine sets as the parameter a storage region 4 bytes 4 16 bytes which is indicated by the pointer instead of the value of the pointer. In the above example the region which is indicated by the pointer is initialized to 0 and the storage region set for the parameter is also initialized to 0.

Upon receiving the command data the intra OS communication driver generates the command header which is information necessary for intra OS communication with the intra OS communication driver . The command header includes a task ID a communication channel ID a command ID and a command size . The intra OS communication driver sets as the task ID an identifier of the task on the side of the second OS which interprets the command data sets as the communication channel ID an identifier of a communication channel for intra OS communication sets as the command ID a set value of the command ID of the command data and sets as the command size the size of the command data . The intra OS communication driver combines the command header generated as described above with the command data to generate the command and writes the generated command into the command buffer through intra OS communication. Then the intra OS communication driver notifies the intra OS communication driver of NOT EMPTY by the interrupt .

Upon receiving the notification of NOT EMPTY the intra OS communication driver reads the command from the command buffer and determines a task for processing the command based on the task ID of the command header . In this example the task is the task for processing the command and therefore the intra OS communication driver delivers the command to the task . The intra OS communication driver repeats delivery of the command to the task until the command buffer becomes empty. When the command buffer becomes empty the intra OS communication driver waits for being notified of NOT EMPTY by the intra OS communication driver .

Upon receiving the command the task converts the command data into the system call to be interpreted by the driver and calls the driver via the API . Here as described above the parameter which corresponds to do ioctl in the above function call example is not a pointer which indicates a logical address but is a storage region 4 bytes 4 16 bytes which is indicated by the pointer. Therefore the task secures the storage region on the memory of the second controller initializes the secured storage region and sets the pointer of the storage region as the third argument of the system call . The driver executes the system call and returns the return value which represents the execution result to the task . The task generates the status based on the return value .

The status header includes a task ID a communication channel ID a status ID and a status size . The task sets as the task ID a set value of the task ID which is set for the command and sets as the communication channel ID a set value of the communication channel ID which is set for the command . The task sets as the status ID a set value of the status ID of the status data and sets as the status size the size of the status data . The task delivers the thus generated status to the intra OS communication driver . Upon receiving the status the intra OS communication driver writes the status into the status buffer . Then the intra OS communication driver notifies the intra OS communication driver of NOT EMPTY by the interrupt .

Upon receiving the notification of NOT EMPTY the intra OS communication driver reads the status from the status buffer through intra OS communication and determines the library which processes the status data based on the communication channel ID of the status header . In this example since the library is the library that processes the status data the intra OS communication driver delivers the status to the library . The intra OS communication driver repeats the delivery of the status to the library until the status buffer becomes empty. When the status buffer becomes empty the intra OS communication driver waits for being notified of NOT EMPTY by the intra OS communication driver .

Upon receiving the status the library converts the status data into the return value to be interpreted by the process and returns the return value to the process . Here data as well as information to be converted into the return value is set for the status data which corresponds to the second function do ioctl in the above function call example. Therefore the library writes the data to the address which is specified by the third argument of do ioctl .

Next a status disposal function will be described. In the case where abnormal termination of any process occurs after the command is written to the command buffer the problem described below may occur. For example a case where abnormal termination of the process occurs will be explained below. The function which is called by the process before the abnormal termination is converted into the command by the library . The command is written to the command buffer and the intra OS communication driver is notified of NOT EMPTY. After that the second controller continues to operate even after the abnormal termination of the process . Therefore the command read from the command buffer is converted into the system call the driver performs processing in accordance with the system call and the status which represents the execution result is generated and written to the status buffer . However processing by the library is also terminated when the abnormal termination of the process occurs. Therefore a read method is not performed for the communication channel and the status is not read from the status buffer .

When the process which has been subjected to abnormal termination is restarted the library corresponding to the process performs an open method for the communication channel . The first command after the restart is generated and the generated command is written to the command buffer . Then the status which represents the execution result of the command is written to the status buffer and the intra OS communication driver is notified of NOT EMPTY. However since the status which represents the execution result of the command which is written to the command buffer before the abnormal termination of the process remains in the status buffer a difference may occur in the correspondence between the command and the status when the status is read by the intra OS communication driver . Therefore the multi processor system may perform false operation. In an exemplary embodiment the status disposal function explained below is provided at the first OS . A status disposal unit which implements the status disposal function is provided at the intra OS communication driver for each communication channel and processing by the status disposal unit is performed for each communication channel.

In step S the status disposal unit initializes the flag which corresponds to the command ID corresponding to the value of the loop counter to OFF and initializes the counter which corresponds to the command ID to 0.

In step S the status disposal unit determines whether or not the loop counter has reached n. When the loop counter has not reached n the process returns to step S. When the loop counter has reached n the process ends.

In step S the process calls the library and the library performs open method processing for the communication channel . Then as a return value of the open method processing a file descriptor which indicates the communication channel is returned to the library . After this the communication channel which is to be processed is identified by the file descriptor.

In step S the status disposal unit turns OFF the flag which corresponds to the command ID corresponding to the value of the loop counter.

In step S the status disposal unit determines whether or not the loop counter has reached n. When the loop counter has not reached n the process returns to step S. When the loop counter has reached n the process ends.

The process illustrated in may be performed subsequent to the initialization process for the status disposal function or may be performed subsequent to the restart of the process after abnormal termination. In the former case the flag is already initialized to OFF in the process illustrated in and therefore the flag remains OFF even after the process illustrated in is performed. In contrast in the latter case a flag which is turned ON before the abnormal termination is rewritten to OFF in the process illustrated in .

In step S the library and the intra OS communication driver generate the command . Specifically a processing routine of the library which corresponds to the function generates the command data and delivers the command data to the intra OS communication driver . Upon receiving the command data the intra OS communication driver generates the command header and combines the generated command header with the command data to generate the command .

In step S the intra OS communication driver writes the generated command to the command buffer through intra OS communication.

In step S the status disposal unit determines whether or not writing of the command in step S is successful. When the writing is successful step S YES the process of the status disposal unit proceeds to step S. When the writing is not successful step S NO the process ends.

In step S the status disposal unit rewrites the flag which corresponds to the command ID included in the command written in the command buffer in step S to ON and adds 1 to the counter which corresponds to the command ID . Then the process ends.

In short when the writing of the command to the command buffer is successful the flag which corresponds to the command ID of the command is rewritten to ON and adds 1 to the counter . In contrast when the writing of the command to the command buffer is not successful the flag which corresponds to the command ID of the command remains OFF and no addition is performed at the counter . Furthermore in the case where after the writing of the command to the command buffer is successfully completed the process is subjected to abnormal termination and is then restarted the flag which is turned ON before the abnormal termination is rewritten to OFF in the process illustrate in .

In step S the status disposal unit reads the status from the status buffer through intra OS communication. Specifically the intra OS communication driver waits for being notified of NOT EMPTY by the intra OS communication driver . Upon receiving the notification of NOT EMPTY the intra OS communication driver reads the status from the status buffer through intra OS communication.

In step S the status disposal unit determines whether or not the reading of the status in step S is successful. When the reading is successful step S YES the process of the status disposal unit proceeds to step S. When the reading is not successful step S NO the status disposal unit ends the process.

In step S the status disposal unit determines whether or not the flag which corresponds to the command ID of the command corresponding to the status read in step S indicates OFF. Here the command ID which corresponds to the status ID is obtained by masking the most significant bit of the status ID included in the status to 1. When the flag which corresponds to the command ID does not indicate OFF step S NO the process of the status disposal unit proceeds to step S. When the flag indicates OFF step S YES the process of the status disposal unit proceeds to step S.

In step S the status disposal unit determines whether or not the counter which corresponds to the command ID of the command corresponding to the status read in step S indicates 0. When the counter does not indicate 0 step S NO the process of the status disposal unit proceeds to step S. When the counter indicates 0 step S YES the process of the status disposal unit proceeds to step S.

In step S the status disposal unit subtracts 1 from the counter which corresponds to the command ID of the command corresponding to the status read in step S.

In step S the status disposal unit determines whether or not the value of the counter obtained by subtraction of 1 in step S is 0. When the value of the counter is not 0 step S NO the process of the status disposal unit proceeds to step S. When the value of the status disposal unit is 0 step S YES the process of the status disposal unit proceeds to step S.

In step S the status disposal unit rewrites the flag which corresponds to the command ID of the command corresponding to the status read in step S to OFF. Then the process ends.

In step S the status disposal unit determines whether or not the counter which corresponds to the command ID of the command corresponding to the status read in step S indicates 0. When the counter does not indicate 0 step S NO the process of the status disposal unit proceeds to step S. When the counter indicates 0 step S YES the process of the status disposal unit proceeds to step S.

In step S the status disposal unit subtracts 1 from the counter of the command ID which corresponds to the status read in step S.

Since the status read from the status buffer corresponds to the processing result of the command which is written to the command buffer the status disposal unit does not dispose of the read status . The status is converted into the return value by the library and is returned to the process . Furthermore since the status is read from the status buffer the status disposal unit subtracts 1 from the counter which corresponds to the command ID of the command corresponding to the status step S . Furthermore since the command which corresponds to the status is already processed the status disposal unit rewrites the flag which corresponds to the command ID to OFF step S .

 2 Case where the Flag Indicates ON and the Counter does not Indicate 0 or 1 Step S N Step S NO Step S NO 

Since the status read from the status buffer does not correspond to the processing result of the command which is written to the command buffer the status disposal unit disposes of the read status step S . Furthermore since the status is read from the status buffer the status disposal unit subtracts 1 from the counter which corresponds to the command ID of the command corresponding to the status step S . Furthermore since the command which corresponds to the status is already processed the status disposal unit rewrites the flag which corresponds to the command ID to OFF step S . The state in which the counter does not indicate 0 or 1 indicates that a failure has occurs in the multi processor system.

Since the status read from the status buffer does not correspond to the processing result of the command written to the command buffer the status disposal unit disposes of the read status step S . Since the counter which corresponds to the command ID of the command corresponding to the status indicates 0 subtraction is not performed at the counter . Furthermore since the command which corresponds to the status is already processed the status disposal unit rewrites the flag which corresponds to the command ID to OFF step S . The state in which the counter indicates 0 indicates that a failure has occurred in the multi processor system.

When the process which has been subjected to abnormal termination is restarted the flags which correspond to all the command IDs are rewritten to OFF in the process illustrated in . That is the state in which the flag indicates OFF in step S indicates that after the command which corresponds to the command ID of the flag is written to the command buffer the process is subjected to abnormal termination and is then restarted. Therefore the status disposal unit subtracts 1 from the counter step S and disposes of the status read from the status buffer step S .

Similar to case 4 since the process is restarted after abnormal termination the status disposal unit disposes of the read status step S . However since the counter indicates 0 subtraction is not performed at the counter . The state in which the counter indicates 0 indicates that a failure has occurred in the multi processor system.

Among cases 1 and 5 described above case 1 represents the case where abnormal termination of the process a failure in the multi processor system or the like does not occur during the period from completion of writing of the command to the command buffer to reading of the status . In contrast in cases 2 and 3 a failure occurs in the multi processor system. In addition in cases 4 and 5 abnormal termination of the process occurs after the command is written to the command buffer and then the process is restarted. In case 1 the status is not disposed of but is converted into the return value and returned to the process . In the other cases the status is disposed of.

In cases 4 and 5 described above the state of the task the driver or the device controlled by the driver and the state of the process may not match. Therefore a reset function which is prepared for each communication channel of the application program of the first controller performs a reset operation illustrated in so that the task the driver and the device controlled by the driver may be restarted. The reset function issues a command for restarting the task the driver the device controlled by the driver .

In step S the reset function determines whether or not the counter which corresponds to the command ID of the command corresponding to the status read by the status disposal unit in step S of indicates 1. When the counter indicates 1 step S YES the command of the corresponding command ID is being processed and the process of the reset function thus proceeds to step S. When the counter does not indicate 1 step S NO the command of the corresponding command ID is not being processed and the process of the reset function thus proceeds to step S without performing the processing of step S.

In step S the reset function issues an Abort command to the command that is identified as being processed.

In step S the reset function determines whether or not the loop counter has reached n. When the loop counter has not reached n the process returns to step S. When the loop counter has reached n the process ends.

The Abort command issued in step S is written to the command buffer through intra OS communication. Then the intra OS communication driver notifies the intra OS communication driver of NOT EMPTY by the interrupt .

Upon receiving the notification of NOT EMPTY the intra OS communication driver reads the command which is an Abort command from the command buffer and delivers the command to the task based on the task ID of the command header .

Upon receiving the command which is an Abort command the task stops the command that is being processed.

Next in step S the second OS resets software application which corresponds to the task for a communication channel which has received the Abort command from among software that is being executed on the second controller .

Next in step S the second OS resets the driver and the device controlled by the driver for a communication channel which has received the Abort command from among the drivers that are being executed on the second controller .

According to this exemplary embodiment in the case where after the command is written to the command buffer the process is subjected to abnormal termination and is then restarted the status which represents the execution result of the command which is written to the command buffer before the abnormal termination is disposed of and the task that is processing the command and the device that is controlled by the driver are reset. Therefore not only the process that has been subjected to abnormal termination but the communication channel including the task and the driver and the device that is controlled by the driver may also be reset. Moreover the other communication channels and the devices that are controlled by the drivers for the other communication channels may be operated without being reset.

In the case where after the command is written to the command buffer the process is subjected to abnormal termination and is then restarted the status representing the execution result of the command which is written to the command buffer before the abnormal termination is disposed of. Therefore no difference occurs in the correspondence between the command and the status after the process which has been subjected to abnormal termination is restarted. Furthermore according to this exemplary embodiment when a failure has occurred in the multi processor the read status is disposed of. Therefore no difference occurs in the correspondence between the command and the status .

Even if abnormal termination of the process does not occur the above mentioned reset function may be applied. For example when a failure occurs in the task the driver or the device that is controlled by the driver the reset function may be executed as described above and the command for which processing is not completed due to the occurrence of the failure may be written again to the command buffer .

That is if the reset function is executed when a failure has occurred in the task the driver or the device that is controlled by the driver allocation of a file descriptor to the communication channel is lost. Therefore when the reset function is executed an open command is required to be executed again. However since the process does not recognize that the allocation of the file descriptor to the communication channel has been lost the process calls the function without executing the open command. Furthermore due to the execution of the reset function the system call that is ready for processing by the driver is also lost. Therefore not only the open command but an ioctl command asynchronous command is also required to be executed again. Thus a command rewriting function is provided at the first OS . A command rewriting unit that implements the command rewriting function is provided at the intra OS communication driver for each communication channel. Processing by the command rewriting unit is performed for each communication channel.

Specifically in the case where the command which is generated and written to the command buffer is an open command the command is held in a written open command holding region. In the case where the command is an asynchronous command the command is held in a written command holding region. In the case where the command is neither an open command nor an asynchronous command the command is held in neither the written open command holding region nor the written command holding region.

A difference between a synchronous command and an asynchronous command will be explained below. In the case of a synchronous command the process does not call the next function until the return value for the called function is returned. Furthermore switching from a normal mode to a power saving mode is not performed until the return value is returned. In contrast in the case of the asynchronous command the process is allowed to call another function before the return value for the called function is returned.

In the case where the reset function is executed after the command is written to the command buffer the command which is held in the written open command holding region is rewritten to the command buffer . Therefore the system call which is lost by the execution of the reset function is executed again after being reset.

In the foregoing exemplary embodiment an example in which the present invention is applied to the image forming apparatus which includes the image scanner the printer and the UI as the device is explained. However the device is not limited to the above. Furthermore the number of devices is not limited.

In the foregoing exemplary embodiment a case where Linux is used as an example of the first OS and an RTOS is used as an example of the second OS is explained. However the first OS and the second OS may be other types of OS.

In the foregoing exemplary embodiment an example in which the image forming apparatus includes the first controller the second controller and the device is explained. However by connecting a control device which has a function of the first controller and an image forming apparatus which has functions of the second controller and the device through a communication unit functions similar to those in the foregoing exemplary embodiment may be implemented. Furthermore a program for implementing the function of the first controller may be recorded on a computer readable recording medium such as an optical recording medium or a semiconductor memory and provided. Furthermore the program may be provided via an electric communication line.

The foregoing description of the exemplary embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously many modifications and variations will be apparent to practitioners skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications thereby enabling others skilled in the art to understand the invention for various embodiments and with the various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.

