---

title: System and method for extending a visualization platform
abstract: Systems and methods for extending a visualization platform are disclosed. A user may create a visualization project created. One or more properties for a non-native widget established by a developer of the non-native widget may be received from the project. Such properties may designate a name or a type of data that the non-native widget is capable of processing. Responsive to an instruction received from the user of the visualization authoring environment, a source of data to be processed by the non-native widget or a destination of data produced by the non-native widget to be processed by other widgets may be established. The appearance or behavior of the non-native widget may be rendered based at least in part on a value available from the source of the data or the appearance or behavior of one or more other widgets may be rendered based at least in part on data produced by the non-native widget.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465527&OS=09465527&RS=09465527
owner: iRise
number: 09465527
owner_city: El Segundo
owner_country: US
publication_date: 20150107
---
This application is a continuation of U.S. application Ser. No. 13 267 650 filed Oct. 6 2011 which claims priority from U.S. Patent Application No. 61 391 300 filed Oct. 8 2010 the contents of which are incorporated herein by reference in their entirety.

A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the reproduction by any one of the patent document or the patent disclosure as it appears in the patent and trademark office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates to software visualization systems and in particular to methods and systems for visualizing software applications and the like.

With the increasing complexity involved in the development of computer programs it has become increasingly expensive time consuming and risky to develop software applications. Often after a given software application has been coded and deployed actual use by the intended users reveals many defects in the application. Correction of such defects after the application is deployed results in customer dissatisfaction and further significant costs.

While software tools have been developed to simulate software applications such tools tend to have limited extensibility. For example it may not be possible to utilize widgets that are not included in the tools to develop visualizations of a proposed software application using conventional methods.

The following presents a simplified summary of one or more aspects in order to provide a basic understanding of such aspects. This summary is not an extensive overview of all contemplated aspects and is intended to neither identify key or critical elements of all aspects nor delineate the scope of any or all aspects. Its sole purpose is to present some concepts of one or more aspects in a simplified form as a prelude to the more detailed description that is presented later.

Described herein are methods and systems for visualizing software applications and the like and for extending environments for creating and rendering such visualizations. For example certain embodiments enable a user to define a visualization for a prospective software application to be simulated using non native and or native widgets.

Further disclosed herein is an example method for extending a visualization platform the method comprising providing a visualization authoring environment configured to enable a developer to define a user interface appearance and behavior of a prospective software application or a prospective modification to an existing software application at least in part by incorporating native widgets storing such definitions on computer readable media in a format that can be utilized by one or more other instances of the visualization authoring environment and or one or more instances of a visualization rendering environment providing in the visualization authoring environment a facility to enable a user to incorporate one or more non native widgets into the visualization authoring environment without requiring acquisition or installation of a new version of the visualization authoring environment providing in the visualization authoring environment a facility to enable the user to incorporate non native widgets into a visualization project encapsulating computer readable instructions for an appearance and or behavior of one or more non native widgets into the visualization project at least partly in response to a user action providing in the visualization authoring environment a facility to enable the user to modify one or more of the following attributes of an instance of a non native widget size position connections between the non native widget and other widgets and providing in a visualization rendering environment a facility to exhibit the desired visual rendering and or interactive behavior during rendering of the visualization project to thereby simulate the proposed software application.

Disclosed herein is an example method for extending a visualization platform the method comprising receiving from a visualization project created by a user one or more properties for a non native widget established by a developer of the non native widget such properties designating one or more of a name and or a type of data that the non native widget is capable of processing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of data to be processed by the non native widget and or a destination of data produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on a value available from the source of the data and or rendering the appearance and or behavior of one or more other widgets based at least in part on data produced by the non native widget.

Disclosed herein is an example method for extending a visualization platform the method comprising receiving from a visualization project created by a user one or more event definitions for a non native widget established by a developer of the non native widget such event definitions designating one or more of the name and or type of event that the non native widget is capable of processing or producing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of the event to be processed by the non native widget and or the destination of events produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on an event received from the source of the event and or rendering the appearance and or behavior of one or more other widgets based at least in part on the event produced by the non native widget.

Disclosed herein is an example system comprising a computing system including one or more processing devices one or more modules stored in non transitory memory configured to cause the computing system to perform operations comprising providing a visualization authoring environment configured to enable a coder to define a user interface appearance and behavior of a prospective software application or a prospective modification to an existing software application at least in part by incorporating native widgets storing such definitions on computer readable media in a format that can be utilized by one or more other instances of the visualization authoring environment and or one or more instances of a visualization rendering environment providing in the visualization authoring environment a facility to enable a user to incorporate one or more non native widgets into the visualization authoring environment without requiring acquisition or installation of a new version of the visualization authoring environment 

providing in the visualization authoring environment a facility to enable the user to incorporate non native widgets into a visualization project encapsulating computer readable instructions for an appearance and or behavior of one or more non native widgets into the visualization project at least partly in response to a user action providing in the visualization authoring environment a facility to enable the user to modify one or more of the following attributes of an instance of a non native widget size position connections between the non native widget and other widgets and providing in a visualization rendering environment a facility to exhibit the desired visual rendering and or interactive behavior during rendering of the visualization project to thereby simulate the proposed software application.

Disclosed herein is at least one module stored in non transitory memory configured to cause a computing system to perform operations comprising providing a visualization authoring environment configured to enable a coder to define a user interface appearance and behavior of a prospective software application or a prospective modification to an existing software application at least in part by incorporating native widgets storing such definitions on computer readable media in a format that can be utilized by one or more other instances of the visualization authoring environment and or one or more instances of a visualization rendering environment providing in the visualization authoring environment a facility to enable a user to incorporate one or more non native widgets into the visualization authoring environment without requiring acquisition or installation of a new version of the visualization authoring environment 

providing in the visualization authoring environment a facility to enable the user to incorporate non native widgets into a visualization project encapsulating computer readable instructions for an appearance and or behavior of one or more non native widgets into the visualization project at least partly in response to a user action providing in the visualization authoring environment a facility to enable the user to modify one or more of the following attributes of an instance of a non native widget size position connections between the non native widget and other widgets and providing in a visualization rendering environment a facility to exhibit the desired visual rendering and or interactive behavior during rendering of the visualization project to thereby simulate the proposed software application.

Disclosed herein is an example system comprising a computing system including one or more processing devices one or more modules stored in non transitory memory configured to cause the computing system to perform operations comprising receiving from a visualization project created by a user one or more properties for a non native widget established by a developer of the non native widget such properties designating one or more of a name and or a type of data that the non native widget is capable of processing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of data to be processed by the non native widget and or a destination of data produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on a value available from the source of the data and or rendering the appearance and or behavior of one or more other widgets based at least in part on data produced by the non native widget.

Disclosed herein is at least one module stored in non transitory memory configured to cause the computing system to perform operations comprising receiving from a visualization project created by a user one or more properties for a non native widget established by a developer of the non native widget such properties designating one or more of a name and or a type of data that the non native widget is capable of processing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of data to be processed by the non native widget and or a destination of data produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on a value available from the source of the data and or rendering the appearance and or behavior of one or more other widgets based at least in part on data produced by the non native widget.

Disclosed herein is an example system comprising a computing system including one or more processing devices one or more modules stored in non transitory memory configured to cause the computing system to perform operations comprising receiving from a visualization project created by a user one or more event definitions for a non native widget established by a developer of the non native widget such event definitions designating one or more of the name and or type of event that the non native widget is capable of processing or producing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of the event to be processed by the non native widget and or the destination of events produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on an event received from the source of the event and or rendering the appearance and or behavior of one or more other widgets based at least in part on the event produced by the non native widget.

Disclosed herein is at least one module stored in non transitory memory configured to cause the computing system to perform operations comprising receiving from a visualization project created by a user one or more event definitions for a non native widget established by a developer of the non native widget such event definitions designating one or more of the name and or type of event that the non native widget is capable of processing or producing at least partly in response to an instruction received from the user of the visualization authoring environment establishing a source of the event to be processed by the non native widget and or the destination of events produced by the non native widget to be processed by other one or more other widgets and rendering the appearance and or behavior of the non native widget based at least in part on an event received from the source of the event and or rendering the appearance and or behavior of one or more other widgets based at least in part on the event produced by the non native widget.

The term Web site or web site as used herein is used to refer to a user accessible network site that may implement the basic World Wide Web standards for the coding and transmission of hypertextual documents. These standards currently include HTML the Hypertext Markup Language and HTTP the Hypertext Transfer Protocol although other standards may be used or the Web site may be implemented without complying with certain World Wide Web standards. It should be understood that the term site is not intended to imply a single geographic location as a Web or other network site can for example include multiple geographically distributed computer systems that are appropriately linked together. Furthermore while the descriptions herein relates to an embodiment utilizing the Internet and related protocols other networks such as networks of interactive televisions or of telephones and other protocols may be used as well.

Similarly while certain examples herein may refer to a personal computer system or terminal other terminals including other computer or electronic systems can be used as well such as without limitation an interactive television a networked enabled personal digital assistant PDA other IP Internet Protocol device a cellular telephone or other wireless terminal a networked game console a networked MP3 or other audio device a networked entertainment. Further the description herein may refer to a user pressing or clicking a key button or mouse to provide a user input or response the user input can also be provided using other apparatus and techniques such as without limitation voice input touch screen input light pen input touch pad input and so on. Similarly while the description herein may refer to certain messages or questions being presented visually to a user via a computer screen or graphical user interface the messages or questions can be provided using other techniques such as via audible or spoken prompts. While the description and example user interfaces may utilize phrases such as requires must and the like it is understood that in certain embodiments such required element may be optional. While certain examples may include text strings in the form of links or file paths it is understood these links and file paths are provided by way of illustration to elucidate certain embodiments and are not intended to limit a particular embodiment to use with the example link or file path.

Further while certain embodiment may enumerate certain elements or features it is understood that embodiments may include fewer or additional elements or features. In one or more example embodiments the functions methods algorithms and techniques described herein may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a non transitory computer readable medium. Tables data structures formulas and so forth may be stored on a non transitory computer readable medium. A storage medium may be any medium that can be accessed by a general purpose or special purpose computer or processing device. By way of example and not limitation such non transitory computer readable media can comprise RAM ROM EEPROM DVD CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to carry or store desired program code means in the form of instructions or data structures and that can be accessed by a general purpose or special purpose computer or a general purpose or special purpose processor.

For a hardware implementation one or more processing units may be implemented within one or more computing devices including but not limited to microprocessors micro controllers application specific integrated circuits ASICs programmable logic devices PLDs field programmable gate arrays FPGAs controllers electronic devices other electronic units designed to perform the functions described herein or a combination thereof. For a software implementation the techniques described herein may be implemented with code segments e.g. modules that perform the functions described herein. The software codes may be stored in memory units and executed by processors. The memory unit may be implemented within the processor or external to the processor in which case it can be communicatively coupled to the processor. A code segment may represent a procedure a function a subprogram a program a routine a subroutine a module a software package a class or any combination of instructions data structures or program statements.

Although certain embodiments and examples are discussed herein it is understood that the inventive subject matter extends beyond the specifically disclosed embodiments and examples to other embodiments and uses and to obvious modifications and equivalents thereof. Thus it is intended that the scope of the disclosure should not be limited by the particular disclosed embodiments and examples. For example in any method or process disclosed herein the acts steps or operations making up the method process may be performed in any suitable sequence and are not necessarily limited to any particular disclosed sequence. Also acts steps or operations may be added removed combined or rearranged in other method process embodiments. In systems and devices disclosed herein components may be added removed combined and or arranged differently than described herein.

Various aspects and advantages or benefits of the embodiments have been described where appropriate. It is to be understood that not necessarily all such aspects advantages or benefits. may be achieved in accordance with any particular embodiment. Thus for example it should be recognized that the various embodiments may be carried out in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other aspects or advantages as may be taught or suggested herein. Further embodiments may include several novel features no single one of which is solely responsible for the embodiment s desirable attributes or which is essential to practicing the systems devices methods and techniques described herein.

Descriptions and examples herein may refer to utilization of certain embodiments with example commercially available products such as iRise Studio or just Studio or client a visualization authoring environment that enables users to create and define e.g. via a drag and drop interface and other interfaces appearance workflow and behavior of proposed applications and which can import simulated data from production systems to make the final result realistic iRise Definition Center or just DC or server a visualization rendering environment and visualization repository and which provides an electronic meeting place where users such as business analysts usability professionals and project managers may collaborate to visually define applications and when used in combination with a visualization authoring environment such as iRise Studio provides a secure shared workspace for members on a project team and iRise Reader or Reader or iDoc Reader a visualization rendering environment which enables a user to access and view interactive visualizations such as those created using iRise Studio that users can use to interact with to experience proposed software before coding of the software and via which users can comment on the interactive visualizations where the comments can then be transmitted to and or accessed by an author of the interactive visualizations and iDoc which refers to a visualization repository and or a visualization project. However it is understood that embodiments described herein may be used with other such tools and applications and are not limited to use with the example products described herein. Unless the context indicates otherwise the phrase visualization corresponds to simulation and vice versa. Either term unless context indicates otherwise may also refer to a visualization project. Similarly unless the context indicates otherwise the phrase simulation platform corresponds to visualization platform and vice versa and the phrase simulator corresponds to visualization rendering environment and vice versa.

As used herein terms that are further qualified with adjectives but also used without qualification are intended to encompass separately and collectively the qualified terms unless the context indicates otherwise. For example the term widget may be further qualified with the adjectives native and custom . The use of the term widget when used without qualification is intended to refer to both native widgets and custom widgets or either native widgets or custom widgets unless the context indicates otherwise.

As used herein you and your are intended to refer to a user of visualization platform unless the context indicates otherwise.

The state of the art of software development has evolved to include processes and systems for visualization sometimes referred to as simulation of such software prior to its assembly testing and deployment using traditional methods. Unlike systems and methods used to assemble actual working software visualization processes and systems produce a facsimile of actual working software with greatly reduced investment of time and resources and these processes and systems can be operated by individuals not skilled in actual software application development.

These visualization processes and systems are typically utilized to provide an interactive representation of a prospective software application and such interactive representation is used to support diverse activities in the software development lifecycle including optionally validation of designs and requirements for the prospective software application testing of design concepts with eventual end users of the prospective software application assessing the feasibility of the prospective software application and communicating the desired behavior and appearance of the prospective application to individuals participating in the software development lifecycle. Such a prospective software application might include a web site a smart phone application a standalone application an application accessible by a browser or one or more of many other types of applications that involve receiving inputs from an individual using the application. In addition these visualization processes and systems may be used to provide an interactive representation of prospective modifications to an existing software application.

These visualization processes and systems typically employ authoring environments for creation of visualizations sometimes referred to as visualization authoring environments in which the users of such systems assemble such visualizations at least in part by adding instances of various user interface elements sometimes referred to as widgets and behavioral elements sometimes referred to as events or actions to a data file that can be transferred to other installations of a visualization authoring environment or visualization rendering environment sometimes referred to as a visualization project or iDoc . These visualization processes and systems may also employ visualization repositories which provide for storage or distribution of visualization projects and other data relevant to the visualization processes and systems in a computer readable medium. These visualization processes and systems may also employ visualization rendering environments which based at least in part on utilizing a visualization authoring environment or a visualization repository produce an interactive representation of a prospective software application. The combination of one or more of a visualization authoring environment visualization repository and visualization rendering environment is sometimes referred to as a visualization platform.

Visualization authoring environments and visualization rendering environments typically contain computer readable instructions that govern the appearance and behavior of a limited set of user interface elements and behavioral elements while the data files contain information that modifies the appearance or behavior of the user interface elements and behavioral elements. For example a visualization rendering environment may contain computer readable instructions on how to play a video file the visualization project would contain the actual video content to be played and specify the size of the window in the user interface in which the video would be played.

Because visualization authoring environments utilize a limited set of user interface elements and behavioral elements encoded into a visualization authoring environment by the developer of such environment the visualizations that can be produced from them are similarly limited. are The user interface elements and behavioral elements available encoded by the developer of a visualization platform into that platform are sometimes referred to as native elements for example native widgets or native actions .

For example a visualization author may be creating a visualization of a prospective software application in which a movie player window is desired to appear. If the visualization authoring environment does not offer a user interface element corresponding to a movie player window as a native widget or does not offer behavioral elements corresponding to those common in the context of a movie player window for example pause play or fast forward as a native action the visualization author may not be able to include these elements in the visualization of a prospective software application.

As software applications become more complex and sophisticated with respect to the variety of user interface elements and behavioral elements requirements for prospective software applications become similarly more complex and sophisticated. Developers of visualization platforms have therefore incorporated new native widgets and actions into their platforms to permit the end users of such applications to simulate an ever growing universe of user interface elements and behaviors further necessitating the end users of visualization platform to acquire and install new versions of these platforms that contain the new native widgets and actions. Because there are significantly more companies and individuals developing new user interface and behavioral elements in software applications and relatively fewer companies and individuals developing analogous native widgets and actions for visualization platforms visualization platforms frequently do not contain the native widgets and actions desired by end users of visualization platforms. Furthermore since some developers of new user interface and behavioral elements for software applications consider such elements to be of a proprietary nature visualization platform developers may not have sufficient information to incorporate analogous native widgets and actions into their visualization platforms.

Systems and methods are described herein that reduce these restrictions by providing a process by which visualization authoring environments can be easily extended to encompass additional user interface elements and behavioral elements sometimes referred to as non native elements widgets or actions. Such additional user interface elements are also referred to herein as custom widgets or simply widgets and such additional behavioral elements are referred to herein as custom actions or simply actions and in some cases custom events or simply events . For convenience custom widgets custom actions and custom events may be referred to simply as custom widgets or iBlocs. In certain embodiments such non native elements or widgets may be non integral to the visualization authoring environment while native widgets may be integral to the visualization authoring environment.

Additionally and optionally the systems and methods described herein provide a process by which altering the appearance and behavior of a visualization platform can be accomplished in addition to the introduction of additional user interface elements and behavioral elements . For example a visualization rendering environment could be altered to provide a palette of annotation tools for collecting feedback on a prospective software application. As another example a visualization platform could be altered to collect and analyze user interactions for example usability metrics based on users interacting with the visualization rendering environment.

A benefit of the systems and methods described herein is that a wide variety of software developers can create new widgets and actions for a visualization platform rather than relying on the developer of the visualization platform. These new widgets and actions can then be used by still wider group of end users of a visualization platform without necessitating acquisition or installation of new versions of such platforms. Furthermore since the systems and methods herein provide for inclusion of all of the necessary information required by a visualization platform utilize new widgets and actions within visualization projects end users of a visualization platform do not need to independently incorporate such elements into their visualization platform or take additional related steps for example validating that their visualization platform has all of the elements necessary to process a particular visualization project.

Another benefit of the systems and methods described herein is that developers of custom widgets do not need to have access to or learn the structure of the source code for a visualization platform. Such source code is typically considered proprietary information of the developer of the visualization platform and not widely distributed and is frequently very complex and difficult for a developer to modify or extend.

With reference to the process begins by creation of a new user interface element or new behavioral element 1 by way of activities that will be described in more detail herein. The new element may then be temporarily stored locally in computer readable media 2 or optionally may be stored in one or more facilities provided by public or private web sites. Optionally since more than one new element may be temporarily stored in such media or facilities these media or facilities may be searched or sorted to further enable selection of an appropriate element 2a . The new element is then added to an instance or several instances of a visualization authoring environment 3 permitting the operator of such an environment to incorporate the new element into a visualization of a prospective software application 4 . Optionally the process may continue with an additional step wherein the operator of the visualization authoring environment may adjust one or more of the placement orientation configuration properties or connections to or from the new element 5 . Further the process may optionally continue with an additional step wherein the visualization of the prospective software application that includes the new element is rendered or interacted with 6 . Further since more than one new element may be created at 1 and incorporated into the visualization authoring environment 3 an additional step may be included in the process by which the operator of the visualization authoring environment selects one or more additional previously added user interface elements or behavioral elements by searching or sorting through the previously added user interface elements and behavioral elements 3a .

Depending on the needs of the person creating such an element the new element may be intended to appear or behave similarly to a known element or behavior present in an existing software program or may be intended to appear or behave in a way not previously realized in an existing software program. In yet another case such an element may be based on a previously created element with one or more modifications or improvements.

One of several embodiments of the process of creating a new user interface element or new behavioral element includes at least a subset of the following activities which are depicted in the 1a define a custom widget 1b define custom widget properties 1c define custom actions 1d define custom widget events 1e define custom widget visual style 1f define custom widget images 1g define use of a javascript library 1h constrain custom widget property values 1i specify custom widget descriptor and 1j define custom widget package specification. Each of these optional activities may occur in a sequence different than discussed herein in a different embodiment.

Each of these optional activities are described by way of illustration below using the example of a new custom widget called colorbox or in some cases mycolorbox however the same activities would generally apply regardless of the name or nature of the new custom widget e.g. a new custom widget corresponding to a movie player window named movieplayer . 

The present embodiment of activities related to the process of creating new user interface element or new behavioral element are described further below. By way of example computer readable declarations and instructions may be presented below utilizing Extensible Markup Language sometimes referred to as XML JavaScript Cascading Style Sheets sometimes referred to as CSS jQuery and JSON. In different embodiments one or more other languages libraries conventions or technologies could be employed to the same effect.

The first step in defining a custom widget is defining an identifier ID that is unique to the widget. In the present embodiment a component of a computer system is employed to acquire this identifier by way of a graphical user interface however different embodiments may utilize other approaches common in the software industry e.g. via a textural command line or not typically used in the software industry. A widget can be uniquely identifiable by a compound ID that consists of three pieces of information group name and version although other optional information may be included. This information may be used by other processes and components of the present embodiment that are described further herein and may or may not be presented in the visualization authoring environment. The group component of the compound ID provides name spacing and as would be understood by an individual skilled in the art name spacing helps avoid naming conflicts e.g. if two companies have a widget with the same name . This is typically a representation of a company name usually proceeded by com. e.g. if your company name is My Company Inc. you might choose com.mycompany . The name component of the compound ID may be a representation for the name of this widget e.g. colorbox movieplayer imagebutton box map etc. . The version component of the compound ID may be a designation used to delineate different variants of the custom widget as would be understood by an individual skilled in the art. In addition other optional data elements may be part of the definition of a custom widget for example display name which may be presented in the context of a graphical user interface to the operator of the visualization authoring environment and the name of the author of the custom widget.

In the present embodiment operation of the graphical user interface elements depicted in and cause a component of a computer system to persist the information to computer readable storage media in this case the file system using common techniques that would be apparent to an individual skilled in the art. Again in this case the stored information is depicted as the file widget extension.xml in .

An optional and optionally repeated step in the activities related to the process of creating new user interface element or new behavioral element is defining custom widget properties. In the present embodiment this is accomplished by editing the aforementioned widget extension.xml file also sometimes referred to as a Descriptor . By way of example the following edits to the file establishes a custom widget property of color .

Editing of the file in the current embodiment may be accomplished using one of many commonly available file editors e.g. Microsoft Notepad but in different embodiments may be accomplished using a computers system component configured to provide a specialized graphical user interface for editing the file.

In the present embodiment the visualization authoring environment which as previously discussed is also utilized to support the process of defining new elements reads the file that was edited previously and presents the information using a graphical user interface depicted in before the addition of the color property and in after the addition of the color Property .

The preceding editing of the file may not yet complete the step referred to as define custom widget properties. Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to vary based on the value in this example yellow optionally set by the operator of the visualization authoring environment. By way of example the following edits establish this behavior 

In addition to or instead and by way of example the instructions above could also be implemented in a more generalized format that accomplishes the same purpose when combined with optional enablement of other behaviors described herein.

Further and by way of example the instructions described above may be contained in the same file as the XML instructions or they may be segregated into a separate file. In different embodiments the flexibility to comingle or segregate different types of instructions may not be included.

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to vary based on the optional execution of a custom action optionally configured by the operator of the visualization authoring environment. By way of example the following edits to the previously presented example of a widget extension.xml file establish this behavior. In this example a setRandomColor custom action is used and a standard Button widget as might be provided by a visualization authoring environment is used to active the custom action.

Similar to defining a custom widget property defining a custom action has two parts exposing it through XML or other technology which was described previously and optionally further defining the behavior using JavaScript or other technology . By way of example the following edits to the previously presented example of a widget extension.xml file further define this behavior.

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to produce a custom event in this example onColorChanged optionally further configured by the operator of the visualization authoring environment. By way of example the following edits to the previously presented example of a widget extension.xml file establish this behavior. In this example a custom event named onColorChanged is defined.

Similar to defining a custom widget property defining a custom action has two parts exposing it through XML or other technology which was described previously and optionally further defining the behavior using JavaScript or other technology . By way of example the following edits to the previously presented example of a widget extension.xml file further define this behavior.

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to take on certain graphical properties or to take on certain graphic properties when optional events are executed in the visualization authoring environment or the visualization produced from it. In this example two behaviors are presented first displaying a red dashed boundary and second displaying an image when the operator of a visualization produced by a visualization authoring environment provides inputs by way of mouse movements. By way of example the following edits to the previously presented example of a widget extension.xml file establish this behavior 

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation of the custom widget in the visualization authoring environment to correspond to one or more images. In this example three image representations are presented each corresponding to a mode of display of widgets they may be available in a visualization authoring environment named in this example small icon icon and preview . By way of example the following edits to the previously presented example of a widget extension.xml file establish this behavior.

In the present embodiment a descriptor is used to specify images used to render custom widgets in a visualization authoring environment as further described in the table below.

In a different embodiment rather than utilizing static images the custom widget s visual appearance may be delegated to computer readable drawing instructions for example utilizing Java2D or SVG which could optionally be configured in this activity or in 1g 

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to be further defined by other sets of computer readable instructions. This feature is particularly useful in the event that such sets of computer readable instructions have been previously created although this feature may also be useful when such instructions have not been previously created. In the example provided below a separate set of computer readable instructions that are part of the jQuery library are at least in part utilized to enable the display of the example custom element with rounded corners.

Advantageously the present embodiment also provides for various methods of referencing external resources to be processed in other activities performed by the visualization platform. Internal and external resources intended to be loaded in the html head section may be defined in the ibloc xml preload section. In the example below Dygraph.js is present in the preload section. The JavaScript file can either be packaged with the ibloc or can be referenced externally e.g. on the web site .

In this example the Dygraph widget is also dependent upon a JavaScript file at http danvk.org dygraphs dygraph combined.js. In the present embodiment there are several means provided to references this script including by way of example downloading the script and package it with the ibloc itself the benefit in this case being the ibloc can work in simulations that do not have an internet connection and referencing it directly on a website the benefit here is the externally available library does not need to be included in the ibloc . This example shows the second approach.

Resources that are not intended to be preloaded in the head can still be referenced and loaded dynamically by calling the rewriteURL e.g. relativePath to resource which returns a URL that can be used to retrieve the resource. This URL can be dereferenced in image src tags Ajax calls etc. rewriteURL e.g. resources myImage.jpg will return a URL that can retrieve a resource located in the ibloc my.widgets Dygraph 1.0 resources myImage.jpg.

An optional Content section is available in the present embodiment for specifying arbitrary html that will be rendered when simulating. In the present embodiment the ibloc itself is rendered as a div but in alternative embodiments other HTML or non html tags may be used. It is often the case that an ibloc will append html elements as children to the parent div. e.g. some third party JavaScript libraries will render by replacing a div on the page . This can easily be done in the ibloc descriptor by adding a content section and placing the html code in a CDATA section so that the XML parser does not attempt to parse validate the html code 

By way of example the content section below will create a div with id myChildDiv that is parented by the ibloc div.

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to be constrained by certain value ranges. This feature is particularly useful in the event that properties included in other steps herein have limited range of valid values although this feature may be useful in other circumstances. In the example provided below the file is further edited to establish a list of possible valid values for the corner effect property referenced in the step defining use of a java script library .

Optionally the individual creating the custom element may further edit the file to incorporate computer readable instructions to add representation or behaviors not previously addressed in one or more of the activities at 1a through 1h or to further modify the representations or behaviors referred to in those activities. This portion of the description of the present embodiment also serves to summarize and the types and formats of the declarations instructions and other information that may form part of the new custom element.

In the present embodiment the widgetDescriptor is the only required element in widget extension.xml but in different embodiments it may not be required.

Optionally the individual creating the custom element may further edit or otherwise manipulate the file or files referred to in activities 1a through 1i to facilitate transfer of new user interface element or new behavioral element between creators of such elements and authors of visualizations as well as optionally consumers of such visualizations . In the present embodiment this activity sets forth the structure and other conventions for organizing and naming directories and files related to a custom element.

In the present embodiment the required directory structure follows this format but other formats could be utilized in different embodiments.

In the present embodiment the widget extension.xml is the only file that is required and it must be placed at the root of the widget directory as follows although these requirements could be eliminated in different embodiments 

In the present embodiment a facility is available to assist in several of the activities described above. This facility referred to as the iBloc creator utility packages a custom widget into a file or series of files as described herein. In the present embodiment the iBloc creator utility takes the form of a computer module configured to take the following user input from the console a location of the source directory where the iBloc data resides and b destination location where the iBloc will be extracted. If the destination is omitted the current directory is used. If the iBloc name is not provided in the destination an iBloc with name .ibloc is used where namespace name and version correspond to the namespace name and version as defined in the iBloc schema. Further the iBloc creator utility functions to validate against the ibloc schema using a standard xml SAX parser that handles schema validation. If the validation fails an informative message is presented to the user including the line number s that are the cause of the error . Further the iBloc creator utility continues processing with one or more of the following activities 

An operator of the iBloc creator utility may interact with it through one or more of the following optional activities 

To use the tool 1. Launch the command prompt. 2. Navigate to the directory where the tool has been extracted e.g. if the extracted folder is in C work irise ibloc generator type cd C work irise ibloc generator . 3. Then type ibloc generator.bat working directory iBloc destination folder file name to generate the iBloc.

By way of example an operator of the iBloc utility may replace working directory with the path of the folder that contains the ibloc.xml file e.g. C myWidgets com.irise ColorBox 1 and replace iBloc destination folder file name with your iBloc folder and file name e.g. C Users username Documents iRise myColorBox.ibloc.

The foregoing examples of activities involved in the creation of a new element could in a different embodiment be partially accomplished with the aid of a computer system component or components in addition to the iBloc creator utility each optionally configured to present the information through a graphical user interface and optionally configured to accept input information through the monitoring of keyboard mouse touch screen or other user interface technology.

It should be reiterated that the foregoing examples pertain to a relatively simple custom widget named Colorbox or myColorBox but the activities described herein can be utilized to create a wide variety of more complicated and practical custom widgets for example calendar pickers that commonly occur on airline reservation web sites contact lists that commonly occur on smartphone applications or credit card information collection forms that commonly appear in ecommerce applications.

In the present embodiment a new element is stored on computer readable media and may be transferred between computer systems using common methods including email File Transfer Protocol sometimes referred to as FTP or other appropriate means. In different embodiments the new element could also be stored in a database including a relational database or RDBMS an object oriented database or other electronic repository. To facilitate transfer of new user interface element or new behavioral element between creators of such elements and authors of visualizations as well as optionally consumers of such visualizations the present embodiment also optionally includes a public or private web site depicted in that stores one or more such elements.

In the present embodiment a custom widget custom action or custom event may also be referred to as an iBloc . In different embodiments the web site or other facility for temporary storage and transfer of new element might include additional capabilities to permit searching and sorting of new elements 2a .

In the present embodiment a custom widget is represented by one or more of a group of files previously discussed in the descriptions of activities 1a through 1j that are used to support the new element being incorporated into a visualization authoring environment. After acquiring the files representing a custom widget the operator of a visualization authoring environment saves the files on their hard drive or other computer readable media. Advantageously in the present embodiment a visualization authoring environment computer software component is configured to monitor the computer readable media for the presence of a new custom widget and perform one or more of several activities when a new custom widget is detected. This monitoring permits the adding of a new custom widget without further user inputs. The activities performed when a new custom widget is detected optionally include the following and may occur in any order.

a Validate that the contents of the files representing the custom widget conform to an iBloc schema. An iBloc schema is a computer readable declaration of the structure and valid contents of the files representing a custom widget. In the present embodiment the iBloc schema is expressed in XML or an XML Schema Document sometimes referred to as an XSD although in different embodiments the an iBloc schema may be expressed using other conventions or standards. The iBloc schema of the present embodiment is reproduced in text form.

b Store the contents of the files representing the custom widget in format more readily accessible by a visualization authoring environment for example in the computer memory allocated to the visualization authoring environment. In the present example this information may be stored in a directory structure in the form of namespace name version and optionally in sub directories relative to the version directory.

c Validate that the visualization authoring environment has a valid license to use the custom widget. As custom widgets may represent something of value to their creators and users the creator of the custom widget may optionally utilize the techniques and facilities described in activities 1a through 1j to cause the representation or behavior of the custom widget in the visualization authoring environment or the visualization produced from it to not operate or to operate in a limited fashion with a reduction in functionality in the absence of a valid license key or other token. In different embodiments this could be accomplished using public or commercially available licensing technology that would be apparent to an individual skilled in the art. Further in a different embodiment the evaluation of the license validity could be performed upon the first attempted use of the custom widget rather than at the time of incorporation into a visualization authoring environment.

d Update repository of incorporated custom widgets. Optionally a visualization authoring environment may maintain a repository or other persisted inventory of custom widgets that have been incorporated and this activity involves updating that persisted inventory for later retrieval.

Advantageously with respect to native widgets the files representing the custom widget remain editable even after the process above permitting them to be further modified without requiring re execution of the this process or other processes described in 1 .

The overall process described herein may optionally include an activity in which an operator of a visualization authoring environment searches or sorts custom widgets 3a added to the visualization authoring environment as described under 2 . An example graphical user interface of a visualization authoring environment is depicted in showing the representation of several custom widgets in this example labeled Google Map Image Flow Slider horizontal and Slider vertical that have been added to a visualization authoring environment as well as graphical user interface controls for sorting and searching custom widgets. In the present embodiment custom widgets and custom actions are segregated but available using the graphical user interface controls labeled Widgets and Actions but in different embodiments custom widgets and actions could be presented in a non segregated fashion. Referring to immediately following the example graphical user interface is a table that further describes optional features available in the present embodiment.

Advantageously the present embodiment permits adding a new custom widget without requiring one or more of the following activities acquiring a new version of the visualization authoring environment installing a new version of the visualization authoring environment stopping the execution of the visualization authoring environment restarting the execution of the visualization authoring environment writing or modifying computer readable instructions for the visualization authoring environment.

Once one or more new elements have been added to a visualization authoring environment or instance of a visualization authoring environment the operator thereof may optionally incorporate one or more of such new elements into a visualization project. A visualization project refers to the information stored in computer readable media or computer memory that contains information specific to the prospective application being visualized using the visualization authoring environment and optionally a corresponding visualization rendering environment as well as optionally additional information. Visualization project also refers to the graphical representation of such prospective application and additional information in a graphical user interface either as part of a visualization authoring environment or a visualization rendering environment. In the present embodiment custom widgets are incorporated into visualization projects using one of several techniques provided by a visualization authoring environment including using a mouse to click on a representation for example the a small icon image described in 1f of the custom widget dragging such representation into the graphical user interface area that represents the visualization project and releasing the mouse button. Advantageously in the present embodiment incorporation of custom widgets into a visualization project does not require the user of the visualization authoring environment to write computer code. In the present embodiment several additional activities take place as result of this action including optionally 

a The visualization authoring environment determines if the custom widget had already been incorporated into the visualization project and if not copy the information in the files that correspond to the custom widget into the project. In the present embodiment determination of if a custom widget has already been incorporated into visualization project is accomplished by searching the visualization project using techniques common in the state of the art for a portion of or all of the ID established as described in 1a above. Optionally the visualization authoring environment may further determine using similar techniques if the version designation optionally included in the compound ID of the previously incorporated custom widget matches the version designation of custom widget being incorporated. If full or partial match for the ID is found optionally the visualization authoring environment may present one or more options using a graphical user interface to allow the operator of the visualization authoring environment to choose optional processing to occur.

b The visualization authoring environment inserts an instance of the custom widget in the visualization project at the location received by the visualization authoring environment from the operator for example based on the location of the cursor upon release of the mouse button. Based on information that may be included in the files described in 1 such instance may be configured with a list of custom widget properties default values and other information specific to the particular instance of the custom widget. In addition to the instance of the custom widget the visualization authoring environment configures such instance and optionally adds additional data to the visualization project based on if the ID was found in the visualization project optionally the operator s choice received by the visualization authoring environment and optionally other factors.

For example if the ID was found in the visualization project and such ID contained a matching version designation no addition processing is performed.

As a further example if the ID was not found the various files described in 1 above are replicated and stored in the visualization project e.g. encapsulated and optionally a reference is created from the newly added instance to the replicated files. In the present embodiment a storage structure is used that contains a header allowing the visualization authoring environment to ensure the data contained in the various files described in 1 above is valid by verifying the header and allows the visualization authoring environment to ensure the data format used in the various files described in 1 is supported by the visualization authoring environment at least in part by evaluating an integer representing the iBloc data version in the storage structure.

As a further example if the ID was found but contained a different version designation based in least at part on the choice received by the visualization authoring environment in b above the various files described in 1 above replicated and stored in the visualization project and optionally a reference is created from the newly added instance to the replicated files.

As a further example if the ID was found but contained a different version designation based in least at part on the choice received by the visualization authoring environment in b above the visualization authoring environment replaces data associated with the existing custom widget with the information in the various files described in 1 .

The forgoing processing facilitates the transfer of visualization projects containing custom widgets among visualization platforms and between the users thereof. Because the information necessary for displaying and defining the behavior of a custom widget can be incorporated into the visualization project it is not necessary for operators of the visualization platform to separately incorporate such information into their instances of the visualization platform by for example installing a new version of a visualization platform component or incorporating the custom widget into their visualization authoring environment as described in 3 .

In the present embodiment the header can be further described as a 15 byte header broken down into a 11 byte file marker other size headers and markers may be used iRise iBloc and a 4 byte integer representing the iBloc data format version. Additional data is stored as a zip stream containing the ibloc.xml and optionally all resources with the entries are stored as namespace name version where represents the relative path to the resource. In the present embodiment iBlocs are stored in DOD at the project level as one Nnde representing the iBloc definition with one Binary Node Blob containing the ibloc.xml and one Binary Node Blob for each resource.

c The display of the graphical user interface of the visualization authoring environment is updated to show the inclusion of the custom widget. In the present embodiment this is accomplished by displaying one or more of the images associated with the custom widget as described in 1f and one or more of the properties of the custom widget. By way of example the depicts a custom action named Slider horizontal in the display of the graphical user interface of a visualization authoring environment.

In a different embodiment corresponding to the different embodiment described in 1f updating the display of the graphical user interface of the visualization authoring environment could be accomplished by executing the instructions stored as for example Java2D or SVG instructions.

Once the information from the files representing the custom widget are incorporated into the visualization project they become part of the visualization project and are therefore transported with it. For example visualization authoring environments which are generally used to create edit and modify visualization projects as well as visualization rendering environments which are generally used to render visualization projects typically have one or more facilities for transfer of visualization projects between environments instances of environments computer hardware systems or individual operators. Including the information needed to define and realize the visual appearance and behavior of the custom widget into the visualization project obviates the need to independently transfer this information between such environments systems or operators. For example one operator of a visualization authoring environment may utilize several custom widgets in a particular visualization project and wish to share his or her work with a college who is operating another instance of a visualization authoring environment. By simply utilizing the typical features of a visualization authoring environment to transfer a visualization project from the first operator to the second operator the second operator s can utilize one or more features of the custom widget without having to separately incorporate the custom widget into their instance of the visualization authoring environment. In a different embodiment the information from the files representing the custom widget may not be incorporated or may only be partially incorporated into the visualization project requiring that the second operator identify the missing information or custom widget and incorporate it into their visualization authoring environment through an activity analogous to 3 Adding a custom widget.

 5 Optionally adjust one or more of the placement orientation configuration properties or connections to or from the new element.

Custom widgets that have been incorporated into a visualization project may optionally be further repeatedly adjusted to change their placement orientation configuration and properties. Further custom widgets that have been incorporated into a visualization project may optionally be connected to or from other widgets actions or events or custom widgets actions and events . These adjustments and connections enable the visual appearance and behavior of the specific instance of the custom widget to be modified. Because they are applied to the specific instance of the custom widget the information discussed in activities 1a through 1j are not changed and the visual appearance and behavior of other instances of the custom widget in the same or different visualization projects are not modified.

In the present embodiment the adjustments and connections are accomplished using various features and functions of a visualization authoring environment also applicable to widgets actions and events that may not be custom widgets custom actions or custom events.

For example in a visualization authoring environment a user may select a widget drag the widget and drop the widget in a different location in the design area which may also be referred to canvas or page of a visualization authoring environment by way of mouse movements or similar gestures in order to accomplish adjustment of the widgets placement.

As an additional example in a visualization authoring environment a user may select a widget drag the widget and drop the widget on top of another widget by way of mouse movements or similar gestures in order to accomplish connecting the widget or from other widgets actions or events.

As an additional example the properties of a widget may be manipulated by providing inputs by way of mouse movement or keyboard inputs to a details panel or other graphical user interface facilities in order to modify the properties or attributes of a widget.

The adjustments and connections described herein and provided in these examples and or the results thereof may be stored by the visualization authoring environment into temporary computer memory or stored in other computer readable media.

It should be noted that in the present embodiment custom widgets can be utilized in visualization projects in the same way that native widgets can be used. For example custom widgets can be connected to custom or native actions in the same manner as native widgets are connected to native actions of a visualization authoring environment and exhibit the same behavior in a visualization rendering environment.

Further in the present embodiment appropriately configured custom widgets may be used in ways advantageous over native widgets. For example in the present embodiment custom widgets can be configured to accept multiple connections corresponding to dataflow into the custom widget and out of the custom widget. In either case the creator of the custom widget or the operator of the visualization authoring environment may specify which properties to flow out of the custom widget as well as which properties to populate with dataflow input values. Further in the case of dataflow connected from a custom widget one or more properties can flow out to one or more dataflow destinations. Thus one property can be flowed out to multiple widgets and multiple properties can be flowed out to multiple widgets. When connecting dataflow in one input value can be flowed in to multiple properties. Multiple input values can also be flowed into multiple properties.

Further in the present embodiment dataflow enables custom widgets to participate in visualization data persistence by storing and retrieving values from a datasheet which may also be may be stored by the visualization authoring environment into temporary computer memory or stored in other computer readable media.

Further the process may optionally continue with an additional step wherein the visualization of the prospective software application that includes the new element is rendered or otherwise interacted with. For example a visualization rendering environment may read visualization repository information containing a custom widget for example a movie player and display on a computer screen an interactive representation of the custom widget in order to solicit feedback from potential users of the prospective application on the placement appearance or behavior of a movie player. Further the potential users may operate through the use of mouse movements or keyboard inputs various custom actions e.g. play stop fast forward associated with the custom widget. As an additional example a visualization platform may be extended to accept feedback on the placement appearance or behavior of other elements utilizing recording of speech and storage of a corresponding sound file to the visualization repository or other method of storing computer files.

In the present embodiment a visualization rendering environment is configured to generate a interactive representation containing custom widgets custom actions or custom events by optionally performing one or more of the following activities 

The root element that defines a custom widget. A widget is uniquely identified by its namespace name and version. The preview image is the image that will represent the widget in studio during modeling.

This element defines a specific layout for properties that can hint UI implementations on ordering and grouping. The list of property names also acts as a filtering mechanism. Omit the property name list to show all properties in alphabetical order.

rewriteURL resourcePath Return the URL for a extension resource file e.g. my.html data my.xml images default my.png. Parameters string resourcePath The name or partial path of the resource e.g. data box.xml.

setProperty key value Set an extension property. Parameters string key The key of the property. string value The value of the property.

irise is the irise global namespace object. If irise is already defined the existing irise object will not be overwritten so that defined namespaces are preserved.

Namespace irise.widget.Widget Provides base functionality for widgets. This constructor is used internally and should not be called.

canRelocate Drag and drop function returns True if the draggable widget can be relocated after being dropped false if not.

getHasRestrictDropTo Drag and drop function returns True if the draggable widget has drop target element to which is restricted drop to.

isDropTarget Returns true if this widget has been instantiated as a drop target for draggable widgets.

setCanRelocate isCanRelocate Drag and drop function used to determine if this widget can be relocated when dragged.

setHasRestrictDropTo isCanRelocate Drag and drop function used to determine if this widget has drop target element to which is restricted drop to.

irise.widget.Widget Provides base functionality for widgets. This constructor is used internally and should not be called.

Parameters object properties A JSON object containing the widget s immutable properties. Required fields element group name properties. Optional fields visible draggable.

canRelocate Drag and drop function returns True if the draggable widget can be relocated after being dropped false if not.

getHasRestrictDropTo Drag and drop function returns True if the draggable widget has drop target element to which is restricted drop to.

ExceptionType attribute is undefined for widget name . ExceptionType Widget name attribute is non numeric. Returns int The x coordinate of this widget.

hasEvent eventType Returns true if an event e.g. click submit drop etc is bound to this widget. Parameters string eventType The name of the event to look up.

isDropTarget Returns true if this widget has been instantiated as a drop target for draggable widgets.

sendEvent eventType data Broadcast an event. Parameters string eventType The event type. object optional data The optional data passed to the listener s .

setCanRelocate isCanRelocate Drag and drop function used to determine if this widget can be relocated when dragged. Parameters boolean isCanRelocate True if the draggable widget can be relocated after being dropped false if not.

setDraggable isDraggable Set the widget draggable attribute. Parameters boolean isDraggable True if the widget should be draggable false if not.

setHasRestrictDropTo isCanRelocate Drag and drop function used to determine if this widget has drop target element to which is restricted drop to. Parameters boolean isCanRelocate True if the draggable widget can be relocated after being dropped false if not.

setLeft left Set the left x coordinate of this widget relative to the simulation panel. Parameters int left The x coordinate of this widget.

setTop top Set the top y coordinate of this widget relative to the simulation panel. Parameters int top The y coordinate of this widget.

setVisible isVisible Set the widget visibility. Parameters boolean isVisible True if the widget should be visible false if not.

subscribeToEvent eventType callback Subscribe to an event. Parameters string eventType The event type. function callback The function that will be called when eventType is fired. This function will receive two parameters the eventType and optionally a data object whose contents is determined by the event sender.

The iBloc schema is a specification and validator for an XML description of a custom widget. It describes the namespace name and version that uniquely identify the widget as well as the makeup of the widget itself. This includes properties and events as well as presentation layer items such as layouts and images. The root element in the iBloc descriptor is the ibloc element. The following attributes are used in the present embodiment to further describe an ibloc element.

The property element describes a property associated with a widget that can be utilized by a visualization authoring environment or a visualization rendering environment. Each property can describe as set of validators that are used in aggregate to validate a particular value associated with a property.

The following table describes additional example elements in the present embodiment that may be associated with and editor element.

In the present embodiment additional information may be provided to locate an editor best suitable to edit the property value. Below is a table of example editors.

The event element describes an event associated with a widget that can be executed by a visualization rendering environment. Events can be further specified in a visualization authoring environment in the same way as standard native events are specified.

The following table describes additional example attributes that may be associated with Event elements.

The following table describes additional example attributes that may be associated with event elements.

In the present embodiment a layout element provides ordering filtering and optionally other information that may be used by components of a visualization authoring environment for example UI property editors when displaying properties. The following table describes additional example attributes that may be associated with layout elements.

The following table describes additional example attributes that may be associated with layout elements.

In the present embodiment Validator elements validate an arbitrary value against some specific criteria. Each validator element can have a description subelement that contains a string description. The following table describes additional example attributes that may be associated with validator elements

The systems will generally receive user inputs and commands as further described herein and processes these inputs and commands to perform the operations further described herein.

In order to provide for the specification of data flow from a non native widget to another widget in the present embodiment the visualization authoring environment monitors the users inputs to determine if a non native widget has been dragged over another widget and presents a pop up menu when this input is received. The pop up menu is configured to allow the user to choose to send data to the second widget. The visualization authoring environment presents a dialog allowing the user to specify a name for the data to be processed by other widgets. The visualization authoring environment presents a user interface element depicted in based at least in part on the definition of the non native widget described in 1 and captures from the user one or more of the properties defined for the non native widget that are associated by the visualization authoring environment to the name for the data to be processed by other widgets.

The following example describes various user inputs to and various processing performed by a visualization authoring environment in the present embodiment. In this example iTravel corresponds to a prospective software application and or a visualization project slider horizontal slider dual slider and price range slider correspond to non native widgets set value action data table clipboard submit form text text widget page set value standard button and button correspond to native actions.

On the Flights page of the iTravel web site two slider controls are desired to enable the user of the iTravel web site to filter the results of their search for flights. The first slider should allow the user of the iTravel web site to specify a price range by selecting a minimum and maximum price the second slider should allow the user of the iTravel web site to set a maximum number of stops with a range from 0 to 3. A button should be provided that the user of the iTravel web site can click to specify non stop flights only. As the values of these three data fields min price max price and stops are changed by the user of the iTravel web site the table that displays matching flights will dynamically change to reflect the new limitations.

As depicted in two iBlocs may used to simulate the requirements for this page a horizontal Slider widget and a Set value action. One of the horizontal Sliders may be defined as a dual slider which enables setting both a minimum and a maximum value for the price range. The Set value action which will receive an event from a Button widget may used to set the value of the Max stops Slider to 0.

The values of the min max and stops data fields may also be used to set where conditions on the data flowing into the data table that displays matching flights from the flights datasheet as is further described herein.

Example user inputs to the visualization authoring environment for adding widgets are described below 

Example user inputs to the visualization authoring environment for capturing price range data are described below 

Example user inputs to the visualization authoring environment for capturing max stops data are described below 

Example user inputs to the visualization authoring environment for sending data to widgets are described below 

Example user inputs to the visualization authoring environment for configuring the Set Value action are described below 

Based on the example inputs above when the visualization rendering environment renders the visualization project for itravel the Price Range Slider will appear with two handles one at the 0 position and the other at the 600 position. The Max Stops Slider will appear with a single handle at the 0 position. In response to the user of the visualization rendering environment dragging any of the handles the values displayed in the Text widgets above the sliders will change and the handles should maintain their positions when they are released. The user of the visualization rendering environment will be constrained to changing the price range values in increments of 25 and the max stops value in increments of 1. If the user of the visualization rendering environment clicks on the non stops only button the value of the max stops slider will be set to 0.

Based on similar inputs from the user of the visualization authoring environment the values for min max and stops may be used to filter the data records flowing from a flights datasheet into a data table on a page. By way of example this could be accomplished with a get record widget that uses where conditions to filter the records flowing into the data table as depicted in .

In this example the slider widgets have pre defined properties called Value and Value2 with Value2 applying only to a dual slider. In order to permit data to be passed from the sliders to the clipboard an association between the data fields and properties for the widgets is created. In this case min is associated with Value and max is associated with Value2 in the price range slider and stops with Value in the max stops slider.

In the example an event called On value change has also been pre defined for the slider widgets. This has been associated with a Submit Form action causing the visualization rendering environment to process the data and refresh the page. The values for min max and stops are also used to populate text widgets as well as setting the values of the sliders after the page refresh.

Thus described herein are systems and methods that enable a visualization authoring environment to be extended to encompass additional user interface elements and behavioral elements beyond those that are integral to the visualization authoring environment.

