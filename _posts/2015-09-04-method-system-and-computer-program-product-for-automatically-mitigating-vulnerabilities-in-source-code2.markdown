---

title: Method, system, and computer program product for automatically mitigating vulnerabilities in source code
abstract: A method for automatically mitigating vulnerabilities in a source code of an application is provided in the present invention. The method includes the following steps. First, the source code is complied, and a path graph is built according to the compiled source code. The path graph includes a plurality of paths traversing from sources to sinks, and each of the paths includes a plurality of nodes. Then, at least one tainted path is identified by enabling a plurality of vulnerability rules. Each of the at least one tainted path corresponds to a vulnerability, and each of the at least one vulnerability corresponds to a sanitization method. Then, the at least one vulnerability is determined if it is mitigable. If the at least one vulnerability is mitigable, the at least one vulnerability is mitigated automatically. Furthermore, the method may be implemented as a system and a computer program product.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639703&OS=09639703&RS=09639703
owner: Lucent Sky Corporation
number: 09639703
owner_city: Pasadena
owner_country: US
publication_date: 20150904
---
This application is a continuation application of and claims the priority benefit of U.S. application Ser. No. 13 905 096 filed on May 29 2013 now allowed. The entirety of the above mentioned patent application is hereby incorporated by reference herein and made a part of this specification.

The present invention relates to software security vulnerabilities. More particularly the present invention relates to comprehensive techniques for automatically mitigating software security vulnerabilities in source code.

Businesses rely more and more on the cloud to keep their applications running and data accessible. However a high percentage of websites have vulnerabilities that may lead to the theft of data such as credit card information and customer lists. Business needs application security solutions to avoid business interruptions and costly lawsuits. The software developers have historically focused on security vulnerabilities and other serious functionality issues in the software that may be exploited by hackers. Despite the efforts the security vulnerabilities remain as serious threats in the application level.

Various methods have been developed to identify security vulnerabilities in applications such as black box testing and static code analysis. Static code analysis is used by the software developers to analyze software for problems and inconsistencies before actually compiling the source code and executing programs built from the code for the software and such technique is aimed at locating and describing areas of security vulnerabilities in the source code. Most high level optimizations performed by a modern compiler involve static analysis such as code path analysis which is used to detect the propagation of an object and further validate the legality along a code execution path. Static code analysis is differentiated from dynamic analysis techniques by analyzing the source code for dependencies without relying on dynamic events in a more complete view of every possible execution path rather than some aspects of a necessarily limited observed behavior.

Several existing static code analysis tools are capable of scanning the source code by leveraging predefined security rules such that potential vulnerabilities are detected and reported to the software developers. The vulnerability report may be accompanied by generic remediation criteria which proposes ways in which the software developers can amend the source code so as to mitigate the reported vulnerabilities. Nonetheless the software developers still need to implement and validate the problematic source code manually which may be labor intensive in consideration of a large amount of existing applications. Due to lack of time or resources many stakeholders are forced to deploy the applications even knowing they have potential security issues.

The present invention provides a method a system and a computer program product which are capable of effectively mitigating vulnerabilities in a source code.

An exemplary embodiment of the present invention provides a method for automatically mitigating vulnerabilities in a source code of an application. The method includes the following steps. First the source code is complied and a path graph is built according to the compiled source code. The path graph includes a plurality of paths traversing from sources to sinks and each of the paths includes a plurality of nodes. Then at least one tainted path is identified by enabling a plurality of vulnerability rules. Each of the at least one tainted path corresponds to a vulnerability and each of the at least one vulnerability corresponds to a sanitization method.

According to one of exemplary embodiments the step of determining if the at least one vulnerability is mitigable is included as follows. A first forward node containing a tainted object is located as a target node along each of the at least one tainted path from the source to the sink.

According to one of exemplary embodiments the step of determining if the at least one vulnerability is mitigable is included as follows. A first backward node containing the tainted object is located as the target node along each of the at least one tainted path from the sink to the source.

According to one of exemplary embodiments the step of determining if the at least one vulnerability is mitigable further includes the following steps. The type of the at least one vulnerability is determined. If the at least one vulnerability is one of a structured query language SQL injection an operating system OS command injection a lightweight directory access protocol LDAP injection an extensible markup language XML injection or an XML path language XPath injection the node containing the tainted object is located as the target node along each of the at least one tainted path from the source to the sink. If the at least one vulnerability is not any of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the node containing the tainted object is located as the target node along each of the at least one tainted path from the sink to the source. Then an actual object variable is determined if it exists in the target node. If the actual object variable exists the at least one vulnerability is determined to be mitigatble. If the actual object variable does not exist a next node is set as the target node.

According to one of exemplary embodiments the step of mitigating the determined at least one vulnerability automatically is included as follows. An instant fix call is applied at the tainted object on the target node.

According to one of exemplary embodiments after the step of applying the instant fix call at the tainted object on the target node the method further includes the following steps. A copy of amended source code is created according to the instant fix call. The copy of amended source code is checked if it is legal. If the copy of amended source code is legal the target node is written into a database. If the copy of amended source code is not legal the next node is set as the target node.

According to one of exemplary embodiments the step of determining if the at least one vulnerability is mitigable is included as follows. At least one other tainted path with the same target node is identified. The same target node is determined if it corresponds to different vulnerabilities. If the same target node does not correspond to different vulnerabilities the at least one other tainted path is removed. If the same target node corresponds to different vulnerabilities a priority order of the vulnerabilities is evaluated.

According to one of exemplary embodiments the step of mitigating the determined at least one vulnerability automatically is included as follows. A plurality of instant fix calls is applied at the tainted object on the target node according to the priority order. A confidence score corresponding to the instant fix call is checked. The target node is written into a database.

According to one of exemplary embodiments the method further includes the following step. The confidence score is lowered if the tainted object includes certain known functions.

According to one of exemplary embodiments the method further includes the following step. The at least one vulnerability is determined if it is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection. If the at least one vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the Path injection the confidence score is lowered if the tainted object includes certain string constants.

According to one of exemplary embodiments after the step of mitigating the determined at least one vulnerability automatically the method further includes the following steps. A copy of amended source code is created according to the instant fix calls. The copy of amended source code is compiled and determined if there exists any compiler error. The actual tainted object on the mitigable node corresponding to each of the compiler errors is located and the corresponding confidence score is set to zero.

An exemplary embodiment of the present invention provides a system for automatically mitigating vulnerabilities in a source code of an application is provided in the present invention. The system includes a memory a database a processor. The processor is coupled to the memory and the database wherein the processor performs an operation for automatically mitigating vulnerabilities in the source code of the application wherein the operation includes the following steps. First the source code is complied and a path graph is built according to the compiled source code. The path graph includes a plurality of paths traversing from sources to sinks and each of the paths includes a plurality of nodes. Then at least one tainted path is identified by enabling a plurality of vulnerability rules. Each of the at least one tainted path corresponds to a vulnerability and each of the at least one vulnerability corresponds to a sanitization method.

According to one of exemplary embodiments the processor locates a node containing a tainted object as a target node along each of the at least one tainted path from the source to the sink.

According to one of exemplary embodiments the processor locates the node containing the tainted object as the target node along each of the at least one tainted path from the sink to the source.

According to one of exemplary embodiments the processor determines the type of the at least one vulnerability. The processor locates a first forward node containing the tainted object as the target node along each of the at least one tainted path from the source to the sink if the at least one vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection. Alternatively the processor locates a first backward node containing the tainted object as the target node along each of the at least one tainted path from the sink to the source if the at least one vulnerability is not any of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection. The processor further determines if an actual object variable exists in the target node. The processor determines the at least one vulnerability is mitigable if the actual object variable exists in the target node. The processor sets a next node as the target node if the object actual variable does not exist in the target node.

According to one of exemplary embodiments the processor applies an instant fix call at the tainted object on the target node.

According to one of exemplary embodiments the processor creates a copy of amended source code according to the instant fix call and checks if the copy of amended source code is legal. The processor writes the target node into the database if the copy of amended source code is legal the processor sets the next node as the target node if the copy of amended source code is not legal.

According to one of exemplary embodiments the processor identifies at least one other tainted path with the same target node and determines if the same target node corresponds to different vulnerabilities. The processor removes the at least one other tainted path if the same target node does not correspond to different vulnerabilities the processor evaluates a priority order of the vulnerabilities if the same target node corresponds to different tainted objects.

According to one of exemplary embodiments the processor applies a plurality of instant fix calls at the tainted object on the target node according to the priority order checks a confidence score corresponding to the instant fix call and writes the target node into the database.

According to one of exemplary embodiments the processor further lowers the confidence score if the tainted object includes certain known functions.

According to one of exemplary embodiments the processor further determines if the at least one vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection. The processor may lower the confidence score if the at least one vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection and if the tainted object includes certain string constants.

According to one of exemplary embodiments the processor further creates a copy of amended source code according to the instant fix calls compiles the copy of amended source code and determines if there exists any compiler error. The processor further locates the actual tainted object on the mitigable node corresponding to each of the compiler errors and sets the corresponding confidence score to zero.

An exemplary embodiment of the present invention provides a computer program product stored in a computer readable storage medium for automatically mitigating vulnerabilities in a source code of an application is provided in the present invention. The computer program including code for searching for at least one vulnerability within the source code determining if the at least one vulnerability is mitigable and mitigating the determined at least one vulnerability automatically.

In order to make the aforementioned features and advantages of the present disclosure comprehensible preferred embodiments accompanied with figures are described in detail below. It is to be understood that both the foregoing general description and the following detailed description are exemplary and are intended to provide further explanation of the disclosure as claimed.

It should be understood however that this summary may not contain all of the aspect and embodiments of the present disclosure and is therefore not meant to be limiting or restrictive in any manner. Also the present disclosure would include improvements and modifications which are obvious to one skilled in the art.

Reference will now be made in detail to the present exemplary embodiments of the disclosure examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers are used in the drawings and the description to refer to the same or like parts.

Referring to a system may be a personal computer an embedded computer a smart phone a laptop computer a tabular computer or other devices capable of performing the functions described in the present invention. The system includes a processor a memory a disk and input output I O facilities . The processor is coupled to the memory the disk and the I O facilities. The processor may be a single chip or a multiple processor unit and may include associated peripheral chips or functional blocks. The primary function of the processor is to execute program instructions by performing operations on data. The memory may be a volatile or non volatile memory known to those skilled in the art including for example a random access memory RAM a static random access memory SRAM or a dynamic random access memory RAM . The disk may be a hard disk drive HDD or a solid state drive SSD and is configured for storing and retrieving files. For example the disk may include computer program products such as in the form of programming code routines or instruction blocks that provide a specific set or sets of ordered operations that control the functionality of the hardware and direct its operation to perform some features or functionality of the system once the instructions are loaded into the memory and executed by the processor . The disk may also include a database which may be implemented as any type of data storage structure capable of providing for the retrieval and storage of a variety of data types. The I O facilities may include an interface for a monitor a keyboard a joystick a mouse a pointing device a speech based interaction device or the like. Additionally in another exemplary embodiment the system may further include other standard peripheral components not shown .

In one of exemplary embodiments the system may be viewed as a client computer and connects to a server via a network . The network may be a computer network such as a local area network LAN wide area network WAN the Internet or a cellular network. The server may represent various forms of servers including but not limited to a web server an application server or a network server. For example the server may be an application server that executes software accessed by the system . A user may invoke applications available on the server in a web browser running on the system .

The application software hosted by the server may exhibit various security vulnerabilities. For example the application software may include vulnerable data and control flow patterns that enable hackers to force the software to perform unintended actions. An example of such problem is called a structured query language SQL injection which occurs when untrusted data makes its way through an application and eventually becomes a part of an SQL query. The hackers may first identify the flow of untrusted data from its entry point referred to as a source to a vulnerable Application Programming Interface API referred to as a sink. For example the source of a security vulnerability may be an injection of untrusted data in the parameter of a HyperText Transfer Protocol HTTP request and the sink of a security vulnerability may be the process of data modification to manipulate the behavior of the application such as a HyperText Markup Language HTML page. The hackers may manipulate the input data to change the meaning of the SQL query and cause significant harm to the repository resources such as a database system by simple assignments method calls or parameters passing. In other words the hackers may inject an SQL statement into an existing SQL statement causing the execution of the SQL statement which is not expected by the application to manipulate the database system in an unauthorized manner. Other known vulnerabilities such as operating system OS command injection lightweight directory access protocol LDAP injection extensible markup language XML injection XML path language XPath injection cross site scripting XSS weak cryptography insecure redirect error triggering sensitive information leak session hijacking security misconfiguration and weak authentication are also often exploited by hackers and would be apparent to one of ordinary skill in the art.

In the present embodiment source code of an application may be any software code written in one or more programming languages including compiled languages such as C C Java Python Perl Ruby PHP Linux UNIX shell script as well as interpreted languages such as assembly code byte code or instructions. Source code may be a fully functional program or a subset of a program such as a command function method class library or any code segment. Source code may also reference outside classes objects files libraries or APIs.

Referring to along with the components in the method for automatically mitigating vulnerabilities in source code including the following steps. First the processor compiles the source code Step S and builds a path graph according to the compiled source code Step S . Next the processor searches for at least one vulnerability within the source code Step S . To be more specific after the processor obtains the source code of an application it may compile the source code and builds a path graph according to the compiled source code. Such path graph includes a plurality of paths traversing from sources to sinks and each of the paths includes a plurality of nodes. The path graph is used to determine those parts of the source code to which a particular value assigned to an object variable might propagate. The processor then identifies at least one tainted paths by enabling a plurality of vulnerability rules. The term tainted used herein refers to data that contains at least some data from an external source that is considered to be untrusted and propagates through for example some object variable assignments to a destination. Therefore each of the at least one tainted path corresponds to a vulnerability and each of the at least one vulnerability corresponds to a sanitization method. The at least one tainted paths may be identified by using an existing automated data flow analysis tool to perform data flow analysis on the path graph. For example theoretically definite assignment analysis is one of data flow analysis used by C C compilers to conservatively ensure that an object variable is always assigned to before it is used. Java and C programming language specifications require their compilers to report a compile time error if the analysis fails. Also the existing automated data flow analysis tool may be some open source or free tools such as RIPS a static source code analyzer for vulnerabilities in PHP web applications Google CodeSearchDiggity a tool to identify SQL injections XSS hard coded passwords etc or RATS a tool for scanning C C perl PHP Python source code for vulnerabilities such as buffer overflows and so on.

Next the processor determines if the at least one vulnerability is mitigable Step S . The at least one vulnerability may be associated with a node on a single tainted path or a node which is an intersection of multiple tainted paths. Therefore the processor may need to locate the exact position where the sanitization method may be placed so that the determined at least one vulnerability may be mitigated automatically in a precise manner Step S .

Referring to along with the components in the processor loads paths and nodes by applying source code analysis techniques such as definite assignment analysis on source code Step S and identifies at least one tainted path by enabling a plurality of vulnerability rules through a complete scan of the source code Step S . Similar to the previous embodiment Step S and S may be done by employing one of the existing automated data flow analysis tools mentioned in the previous embodiment. For each vulnerability the processor needs to find a suitable sanitization method that may be applied for each mitigable node referred to as a target node hereinafter. Based on the type of the vulnerability the processor may conduct a forward traversal or a backward traversal on the at least one tainted path by following the tainted inputs of all computations encountered throughout the at least one tainted path.

To be more specific the processor determines if the vulnerability is one of a SQL injection a OS command injection a LDAP injection an XML injection or an XPath injection Step S . The OS command injection is an escape string or format string attack that occurs when unsanitized user input is passed to a system shell. The LDAP injection is an attack used to exploit web based applications that construct LDAP statements based on user input. The XML injection is a XML tag in a simple object access protocol SOAP message aiming at modifying the XML structure. Typical examples are modification of payment data and unauthorized administration login. The XPath injection is an attack when a website uses user supplied information to construct an XPath query for XML data. Similar to the SQL injection the hackers may exploit such vulnerability with a command sequence appended to the appropriate format or escape string to execute arbitrary commands. When a software application fails to properly sanitize user input it is possible to modify commands or statements using a local proxy. A successful injection may result in the execution of arbitrary commands or restricted operations such as elevating the privileges granting permission to unauthorized queries and content modification. If the vulnerability is determined to be one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the processor locates the first node containing a tainted object referred to as a first forward node as the target node along each of the at least one tainted path from the source to the sink Step S . That is among all the nodes containing the tainted inputs identified by the processor the first forward node is tainted directly from a pure external source injection but not inherited from its parent node. On the other hand if the vulnerability is determined to be other than the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the processor locates the first node containing the tainted object referred to as a first backward node as the target node along each of the at least one tainted path from the sink to the source Step S .

After the target node is located the processor determines if the actual object variable exists in the target node Step S or Step S . If the actual object variable does not exist in the target node the processor sets a next node as the target node Step S or Step S and repeats Step S or Step S respectively. That is if the vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the processor may locate the second node containing the tainted object as a new target node from the source to the sink Step S for ensuring that the tainted object in the target node is not inherited from its parent node otherwise the processor may locate the second node containing the tainted object as a new target node from the sink to the source Step S .

If the actual object variable exists in the target node the processor determines that the current target node is mitigable and applies an instant fix call at the actual tainted object on the target node based on the corresponding vulnerability rule Step S . The instant fix call is configured to amend the injection code based on the provided vulnerability rule by using an existing vulnerability analysis tool in conjunction with the knowledge that the database has accumulated over time in handling specific vulnerabilities in the past. In one of exemplary embodiments the processor may assign a confidence score e.g. 0 3 for each instant fix call as a future reference. Moreover the processor creates a copy of amended source code according to the instant fix call.

Next the processor may compile the copy of amended source code and check if the copy of amended source code is compliable Step S . If the copy of amended source code is compliable the processor determines that the amendment is legal writes the target node and the corresponding amendment into the database for references in the future Step S and ends the algorithm. If the copy of amended source code is not compliable the processor determines that the amendment is illegal and returns to Step S or Step S for another identification of a new target node until the mitigation is completed.

Referring to the processor loads identified tainted paths and target nodes by enabling a plurality of vulnerability rules Step S . It is noted that such process may be done by leveraging the algorithm in which will not be repeated hereinafter. For each of the tainted paths the processor may find the other intersecting tainted paths with the same target node as an intersection Step S . The processor determines if the same target node corresponds to different vulnerability rules or tainted objects Step S . If the same target node corresponds to the same vulnerability rule or the same tainted object the processor may then remove at least one duplicated tainted path Step S . If the same target node corresponds to different vulnerability rules or different tainted objects the processor may skip Step S. For the same target node corresponds to different vulnerability rules or different tainted objects the processor may evaluate the priority order of the vulnerabilities for mitigation by the vulnerability rules Step S which may define actual objects variables on the target node and determine an optimal order to mitigate the vulnerability accordingly. Similar to Step S the processor then may apply multiple instant fix calls at the actual tainted objects variables on the target node based on the corresponding vulnerability rule Step S .

Furthermore the processor may check the confidence score of each of the instant fix calls Step S . In some embodiments the processor may choose not to apply the instant fix calls with low confidence scores. The processor may also adjust the confidence score at this point. First the processor determines if the vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection Step S . If the vulnerability is one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the processor checks if the injection contains certain string constants Step S . If the injection contains certain string constants the processor may lower the confidence score of the corresponding instant fix call Step S . If the vulnerability is not any one of the SQL injection the OS command injection the LDAP injection the XML injection or the XPath injection the processor may skip Step S and directly proceeds to Step S. In Step S the processor checks if the injection contains certain known functions. If the injection contains certain known functions the processor may lower the confidence score of the corresponding instant fix call Step S and save each of the instant fix call and its related information into the database Step S . It is noted that if the injection does not contain certain known functions the processor may skip Step S. Take the SQL injection as an example. The certain string constants may be concatenated with existing SQL commands or the certain known functions may be meaningful SQL commands. As long as injected SQL code is syntactically correct the processor may not easily detect programmatically. Therefore the processor may need to validate the resulting instant fix calls with a more careful review. In other words the resulting instant fix calls may be less reliable and receive lower confidence scores.

Next the processor may compile the copy of amended source code and check if the copy of amended source code is compliable Step S . If the copy of amended source code is compliable the processor determines that the amendment is legal and ends the algorithm. If the copy of amended source code is not compliable the processor locates the instant fix call corresponding to each of the compiler errors which means that the amendment is not reliable sets the confidence score to zero Step S and ends the algorithm. It is noted that before the processor applies the instant fix call it may first check the corresponding confidence score and make an adjustment based on the confidence score. In one of exemplary embodiments such adjustment may be authenticated by the user manually.

By leveraging the algorithms presenting in the embodiments of and the system in the present invention may automatically mitigate security issues in source code. In one of exemplary embodiments when a user attempts to visit a website the processor of the system may be initiated by one of the I O facilities such as a mouse click from the user and first goes through the source code of the website. Then the processor finds the problems hackers may possibly exploit and then rewrite the source code to fix the problems. The user may then either verify and apply the fixes individually or deploy the secured source code for immediate remediation.

In one of exemplary embodiments computer program products including a plurality of program instructions stored in a tangible computer medium implementing the functionality or method of this invention will commonly be non volatile hard coded type media distributed to users on a distribution medium such as floppy disks read only memories ROMs CD ROMs and DVD ROMs or erasable electrically programmable read only memories EEPROMs recordable type media such as floppy disks hard disk drives CD R RWs DVD RAMs DVD R RWs DVD R RWs flash drives and other newer types of memories and transmission type media such as digital and analog communication links or other computer readable medium. The term computer readable medium encompasses distribution media intermediate storage media execution memory of a computer and any other medium or device capable of storing computer program instructions implementing the functionality or methods of embodiments of the present invention for later reading by a computer system. The computer program will often be copied from the computer readable medium to a hard disk or a similar intermediate storage medium. When the programs are to be run they will be loaded either from their distribution medium or their intermediate storage medium into the execution memory of the computer configuring the computer to act in accordance with the algorithm or method of this invention. All such operations are well known to those skilled in the art of computer systems.

In summary by leveraging static code analysis and data flow graphs the present invention provides a method a system and a computer program product for automatically mitigating vulnerabilities in a source code. By going through the source code of applications the vulnerabilities that hackers may exploit are able to be found and then the source code are re written to mitigate the vulnerabilities. The users may then either verify and apply the amendment individually or deploy the secured source code for immediate remediation.

It will be apparent to those skilled in the art that various modifications and variations can be made to the structure of the disclosed embodiments without departing from the scope or spirit of the disclosure. In view of the foregoing it is intended that the disclosure cover modifications and variations of this disclosure provided they fall within the scope of the following claims and their equivalents.

