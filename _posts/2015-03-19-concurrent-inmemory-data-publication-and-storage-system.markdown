---

title: Concurrent in-memory data publication and storage system
abstract: A method includes allocating a first memory location in a non-transitory data store in communication with a computing device and writing data to the first memory location when a first write transaction executes on the non-transitory data store. The method further includes executing one or more read transactions on the first memory location after completion of the first write transaction and incrementing a first pointer counter upon completion of the first write transaction and for each read transaction executing on the first memory location. The method allocates a second memory location in the non-transitory data store and writes updated data to the second memory location when a second write transaction executes on the non-transitory data store to update the data. The first pointer counter decrements and the second pointer counter increments upon completion of the second write transaction. The first memory location de-allocates when the first pointer counter is zero.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477516&OS=09477516&RS=09477516
owner: Google Inc.
number: 09477516
owner_city: Mountain View
owner_country: US
publication_date: 20150319
---
Distributed storage systems store data within a non transitory data store overlaying one or more memory locations. In some examples the non transitory data store includes one or more tables for arranging the data in the form of records and attributes for each record. A data store management system may execute write transactions to put data into the data store and execute read transactions where the data is queried and retrieved from the data store. Here the writer atomically updates the data into the non transitory data store in a single operation and subsequent readers retrieve the atomically updated data. Atomic operations however often prevent readers from getting data from the data store while a writer is concurrently putting data into the data store and vice versa. Thus bottlenecking often results due to freezing one code path s access to the data in the data store while allowing another code path to access the data in the data store. In other examples when write transactions execute during read transactions in progress the data the reader gets is often a copy that is incomplete or inconsistent due to the intervening write transaction.

One aspect of the disclosure provides a computing device in communication with a non transitory data store that allocates a first memory location in the non transitory data store and writes data to the first memory location when a first write transaction executes on the non transitory data store. The computing device executes one or more read transactions on the first memory location after completion of the first write transaction and increments e.g. atomically a first pointer counter associated with the first memory location upon completion of the first write transaction and for each read transaction executing on the first memory location to get the data. The computing device allocates a second memory location in the non transitory data store and writes updated data to the second memory location when a second write transaction executes on the non transitory data store to update the data. Upon or after completion of the second write transaction the computing device decrements the first pointer counter associated with the first memory location and increments a second pointer counter associated with the second memory location. The computing device de allocates the first memory location when the first pointer counter associated with the first memory location decrements to zero.

Implementations of the disclosure may include one or more of the following optional features. In some implementations the computing device blocks read access to a memory location when a pointer counter associated with the memory location is zero wherein the pointer counter is zero when a write transaction executing on the associated memory location is in progress. In other implementations the computing device blocks write access to a memory location upon executing a read transaction on the associated memory location to get data e.g. using reader writer mutual exclusion . The computing device may decrement a pointer counter associated with a memory location after completion of a read transaction on the associated memory location.

In some examples when the second pointer counter associated with the second memory location is zero the computing device executes one or more subsequent read transactions on the first memory location to get the data while the second write transaction concurrently executes on the second memory location. In other examples the computing device executes one or more subsequent read transactions on the second memory location to get the updated data when the second pointer counter associated with the second memory location is greater than zero. The computing device may permit any read transactions executing on the first memory location in progress to complete when the first pointer counter associated with the first memory location is greater than zero after the second pointer counter associated with the second memory location increments. Optionally when a remaining number of memory cycles until completion of the second write transaction is less than a memory cycle threshold the computing device blocks one or more subsequent read transactions from executing on the first memory location to get the data and delays the one or more subsequent read transactions from executing on the second memory location to get the updated data until completion of the second write transaction. Optionally when a third write transaction executes on the non transitory data store to update the data after completion of the second write transaction the computing device allocates a third memory location in the non transitory data store and writes updated data to the third memory location. The computing device may decrement the second pointer counter associated with the second memory location and increment a third pointer counter associated with the third memory location upon completion of the third write transaction. In some examples the computing device de allocates the second memory location when the second pointer counter associated with the second memory location decrements to zero.

In some implementations the computing device initializes a pointer counter associated with memory location upon allocating the associated memory location. The computing device may increment a pointer counter associated with a memory location for each read transaction executing on the associated memory location. Optionally the computing device executes a write transaction on the non transitory data store when the computing device receives a write access request from an application programming interface executing on a user device. Optionally the computing device executes a read transaction on the non transitory data store when the computing device receives a read access request from an application programming interface executing on a user device. In some examples the non transitory data store includes a hierarchal structure for storing the data the data including strongly typed data.

Another aspect of the disclosure provides a remote system that includes a non transitory data store and a data processing device in communication with the non transitory data store that allocates a first memory location in the non transitory data store and writes data to the first memory location. The data processing device executes on or more read transactions on the first memory location after completion of the first write transaction and increments a first pointer counter associated with the first memory location upon completion of the first write transaction and for each read transaction executing on the first memory location to get the data. The data processing device allocates a second memory location in the non transitory data store and writes updated data to the second memory location when a second write transaction executes on the non transitory data store to update the data. The data processing device decrements the first pointer counter associated with the first memory location and increments a second pointer counter associated with the second memory location upon completion of the second write transaction. The data processing device further de allocates the first memory location when the first pointer counter associated with the first memory location decrements to zero.

This aspect may include one or more of the following optional features. In some implementations the data processing device blocks read access to a memory location when a pointer counter associated with the memory location is zero wherein the pointer counter is zero when a write transaction executing on the associated memory location is in progress. In other implementations the data processing device blocks write access to a memory location upon executing a read transaction on the associated memory location to get data. The data processing device may decrement a pointer counter associated with a memory location after completion of a read transaction on the associated memory location.

In some examples when the second pointer counter associated with the second memory location is zero the data processing device executes one or more subsequent read transactions on the first memory location to get the data while the second write transaction concurrently executes on the second memory location. In other examples the data processing device executes one or more subsequent read transactions on the second memory location to get the updated data when the second pointer counter associated with the second memory location is greater than zero. The data processing device may permit any read transactions executing on the first memory location in progress to complete when the first pointer counter associated with the first memory location is greater than zero after the second pointer counter associated with the second memory location increments. Optionally when a remaining number of memory cycles until completion of the second write transaction is less than a memory cycle threshold the data processing device blocks one or more subsequent read transactions from executing on the first memory location to get the data and delays the one or more subsequent read transactions from executing on the second memory location to get the updated data until completion of the second write transaction. Optionally when a third write transaction executes on the non transitory data store to update the data after completion of the second write transaction the data processing device allocates a third memory location in the non transitory data store and writes updated data to the third memory location. The data processing device may decrement the second pointer counter associated with the second memory location and increment a third pointer counter associated with the third memory location upon completion of the third write transaction. In some examples the data processing device de allocates the second memory location when the second pointer counter associated with the second memory location decrements to zero.

In some implementations the data processing device initializes a pointer counter associated with memory location upon allocating the associated memory location. The data processing device may increment a pointer counter associated with a memory location for each read transaction executing on the associated memory location. Optionally the data processing device executes a write transaction on the non transitory data store when the data processing device receives a write access request from an application programming interface executing on a user device. Optionally the data processing device executes a read transaction on the non transitory data store when the data processing device receives a read access request from an application programming interface executing on a user device. In some examples the non transitory data store includes a hierarchal structure for storing the data the data including strongly typed data.

The details of one or more implementations of the disclosure are set forth in the accompanying drawings and the description below. Other aspects features and advantages will be apparent from the description and drawings and from the claims.

Referring to in some implementations a system includes one or more user devices associated with a user . The user devices are in communication via a network with a distributed storage system having a scalable elastic non transitory data store . In some implementations the distributed storage system executes a computing device that manages access to the non transitory data store . User devices may put data into the non transitory data store when the computing device executes write transactions and may get the data from the non transitory data store when the computing device executes read transactions . As used herein putting data into the non transitory data store refers to writing data to the non transitory data store and getting the data from the non transitory data store refers to reading the data stored in the non transitory data store . In some examples the computing device executes write transactions when the computing device receives a write access request from a user device via the network . Likewise the computing device may execute read transactions when the computing device receives a read access request from a user device via the network .

The user devices can be any computing devices that are capable of communicating with the computing device through the network . User devices include but are not limited to desktop computing devices and mobile computing devices such as laptops tablets smart phones and wearable computing devices e.g. headsets and or watches . The user devices may further execute a graphical user interface GUI on a display to write data to the non transitory data store and or and read data from the non transitory data store of the distributed storage system .

In some implementations the user devices execute a transaction application programming interface API that is responsible for accessing the underlying data for example putting data into the non transitory data store and or getting data from the non transitory data store . The transaction API translates commands such as look up or insert data commands into sequences of primitive network interface controller operations. The transaction API interfaces with the user devices and the non transitory data store of the distributed storage system . In some implementations the transaction API enables user devices to use Structured Query Language SQL to query data stored in the non transitory data store and write updated data such as indexes into the non transitory data store for faster querying to increase the efficiency of the non transitory data store even when the amount of stored data increases over time.

The network may include various types of networks such as local area network LAN wide area network WAN and or the Internet. Although the network may represent a long range network e.g. Internet or WAN in some implementations the network includes a shorter range network such as a local area network LAN . In some implementations the network uses standard communications technologies and or protocols. Thus the network can include links using technologies such as Ethernet Wireless Fidelity WiFi e.g. 802.11 worldwide interoperability for microwave access WiMAX 3G Long Term Evolution LTE digital subscriber line DSL asynchronous transfer mode ATM InfiniBand PCI Express Advanced Switching etc. Similarly the networking protocols used on the network can include multiprotocol label switching MPLS the transmission control protocol Internet protocol TCP IP the User Datagram Protocol UDP the hypertext transport protocol HTTP the simple mail transfer protocol SMTP the file transfer protocol FTP etc. The data exchanged over the network can be represented using technologies and or formats including the hypertext markup language HTML the extensible markup language XML etc. In addition all or some of the links can be encrypted using conventional encryption technologies such as secure sockets layer SSL transport layer security TLS virtual private networks VPNs Internet Protocol security IPsec etc. In other examples the network uses custom and or dedicated data communications technologies instead of or in addition to the ones described above.

In some implementations the non transitory data store stores data as a collection of attributes tables each contributing a set of columns and rows. Each column may include pertinent records and each row may include the data . In some examples relationships are added between tables to indicate that two sets of data are inter related. In some implementations the non transitory data store is a relational database. In the example shown the non transitory data store includes a schema defining a supported language and utilized to set integrity constraints such that the data is strongly typed and arranged in a hierarchical structure in a manner similar to a file system. For example attributes of a parent object includes a plurality of child objects each child object having attributes including a plurality of grandchild objects and so on. Requiring the data to be strongly typed enforces strict restrictions on intermixing values with different data types when executing write and read transactions respectively. Values of strongly typed data can include STRING INT VARCHAR CBLOB DECIMAL etc. In one example a type person would include a STRING for the person s name and an INT for the person s age. Using strongly typed data for the data store allows for compound structures beyond primitives and is exposed to the consumer through an application programming interface API in the form of language native types. For example a C implementation of the API accepts as input and returns as output arbitrary C types without knowing what those types are.

Referring to in some implementations the distributed storage system includes loosely coupled memory hosts e.g. computers or servers each having a computing resource e.g. one or more processors or central processing units CPUs in communication with storage resources e.g. memory flash memory dynamic random access memory DRAM phase change memory PCM and or disks that may be used for caching data. The non transitory data store e.g. a storage abstraction overlain on the storage resources allows scalable use of the storage resources by one or more user devices . The user devices may communicate with the memory hosts through the network e.g. via remote procedure calls RPC .

In some implementations the distributed storage system is single sided eliminating the need for any server jobs for responding to RPC from user devices to write data when executing the write transaction or read data when executing the read transaction on their corresponding memory hosts and may rely on specialized hardware to process remote write and read access requests respectively instead. Single sided refers to the method by which most of the request processing on the memory hosts may be done in hardware rather than by software executed on CPUs of the memory hosts . Rather than having a processor of a memory host e.g. a server execute a server process that exports access of the corresponding storage resource e.g. non transitory memory to user processes executing on the user devices the user devices may directly access the storage resource through a network interface controller NIC of the memory host . In other words a user process executing on a user device may directly interface with one or more storage resources without requiring execution of a routine of any server processes executing on the computing resources . This single sided distributed storage architecture offers relatively high throughput and low latency since user devices can access the storage resources of the non transitory data store without interfacing with the computing resources of the memory hosts . This has the effect of decoupling the requirements for storage and CPU cycles that typical two sided distributed storage systems carry. The single sided distributed storage system can utilize remote storage resources regardless of whether there are spare CPU cycles on that memory host furthermore since single sided operations do not contend for server CPU resources a single sided system can serve cache requests with very predictable low latency even when memory hosts are running at high CPU utilization. Thus the single sided distributed storage system allows higher utilization of both cluster storage and CPU resources than traditional two sided systems while delivering predictable low latency.

The distributed storage system may put data in dynamic random access memory DRAM e.g. the non transitory data store and get the data from the remote memory hosts via remote direct memory access RDMA capable network interface controllers NIC . A network interface controller also known as a network interface card network adapter or LAN adapter may be a computer hardware component that connects a computing device resource to the network . Both the memory hosts and the user device may each have a network interface controller for network communications. A host process executing on the computing processor of the memory host may allocate a memory location when executing a write transaction to write updated data furthermore the host process may de allocate a memory location storing data when no read transactions are currently executing on the memory location and the write transaction completes the write of the updated data to the allocated memory location 

The distributed storage system may include a co located software process to register memory for remote access with the network interface controllers and set up connections with user processes . Once the connections are set up user processes can access the registered memory via engines in the hardware of the network interface controllers without any involvement from software on the local CPUs of the corresponding memory hosts .

In some implementations the distributed storage system enables concurrent atomic access to the non transitory data store a read transaction executing on a first memory location to get data without preventing a write transaction from executing on a second memory location to put updated data while the read transaction is executing concurrently. Accordingly concurrent atomic access to the non transitory data store avoids delays since a read transaction will not be blocked from executing on the non transitory data store to get data while a write transaction executes on the non transitory data store to put updated data and vice versa. In some examples the first and second memory locations are isolated from one another such that read access to the first memory location is permitted for getting data while write access to the first memory location for putting updated data is blocked. Similarly write access to the second memory location is permitted for putting the updated data while read access to the second memory location for getting the updated data is blocked until completion of the underlying write transaction . In other words the concurrent atomic access facilitates write transactions to never write data to memory locations once read access is permitted thereto and read transactions will never get updated data from a memory location until completion of a corresponding write transaction executing thereon. Thus read transactions will never get read data that is incomplete while a write transaction executes concurrently.

The computing device holds one or more pointer counters associated with memory locations within the non transitory data store . In some implementations when the computing device allocates a first memory location for putting data when a write transaction executes a first pointer counter associated with the first memory location is initialized by the computing device . The first pointer counter includes a value of zero while the write transaction executing on the first memory location is in progress. In some examples when the first pointer counter associated with the first memory location is zero upon initializing the first memory location the computing device blocks read access to the first memory location . After completion of the write transaction the computing device may increment the first pointer counter associated with the first memory location . Once the first pointer counter associated with the first memory location is incremented i.e. the first pointer counter is greater than zero the computing device may permit read access to the first memory location to get the data. In some implementations the computing device increments the first pointer counter associated with the first memory location for each read transaction executing on the first memory location to get the data .

In some implementations when the computing device executes a second write transaction on the non transitory data store to update the data the computing device allocates a second memory location for putting updated data and initializes a second pointer counter associated with the second memory location . In some examples upon completion of the second write transaction the computing device decrements the first pointer counter associated with the first memory location and increments the second pointer counter associated with the second memory location . In some examples when the first pointer counter associated with the first memory location decrements to zero the computing device de allocates the first memory location . The computing device operates recursively whereat the computing device will accordingly allocate and de allocate third fourth . . . nmemory locations and increment and decrement associated pointer counters as data within the non transitory data store is continuously updated.

Referring to a read transaction executes on the first memory location to get data . The first pointer counter associated with the first memory location is incremented for the executing read transaction . In the example shown the first pointer counter is two. While the read transaction executes on the first memory location the computing device allocates a second memory location Memory Location B when a write transaction executes to write an updated copy of the data Data Copy 2 to the non transitory data store i.e. via the second memory location . Upon or after executing the write transaction on the second memory location the computing device initializes a second pointer counter associated with the second memory location. In the example shown the second pointer counter is zero indicating the write transaction is currently executing on the second memory location and the computing device is blocking read access to the second memory location . Furthermore the status indicator associated with the second memory location indicates only about half the updated data is put into the second memory location . More specifically the status indicator indicates a remaining number of memory cycles until completion of the underlying write transaction executing on the second memory location

Referring to two read transactions execute on the second memory location to get data corresponding to the updated copy of data Data Copy 2 put into the second memory location by the write transaction illustrated in . The second pointer counter associated with the second memory location is incremented for each one of the executing read transactions . In the example shown the second pointer counter is three. While the two read transactions execute on the second memory location the computing device allocates a third memory location Memory Location C when a write transaction executes to write a subsequent updated copy of the data Data Copy 3 to the non transitory data store i.e. via the third memory location whereat the computing device initializes a third pointer counter associated with the third memory location . In the example shown the third pointer counter is zero indicating the write transaction is currently executing on the third memory location and the computing device is blocking read access to the third memory location . Furthermore the status indicator associated with the third memory location indicates only about half the subsequent updated data is put into the third memory location . More specifically the status indicator indicates a remaining number of memory cycles until completion of the underlying write transaction executing on the third memory location

Referring to a subsequent read transaction executes on the third memory location to get the data corresponding to the updated copy of data Data Copy 3 put by the write transaction shown in . The third pointer counter associated with the third memory location is incremented for the subsequent executing read transaction . In the example shown the third pointer counter is two. The second pointer counter associated with the second memory location remains one while the read transaction executing on the second memory location shown in is still in progress.

In some examples when the read access request is received while a write transaction is currently executing on a subsequent memory location to update the data the computing device may block the read transaction from getting data not including the update and require the read transaction to wait before executing on the new memory location to get the updated data until completion of the write transaction if a remaining number of memory cycles e.g. status indicator of until completion of the write transaction is less than a memory cycle threshold. In this example the computing device beneficially gets the updated data while only requiring a short delay time less than the memory cycle threshold before executing the read transaction to get the updated data .

At operation a pointer counter associated with the memory location where the read transaction executes is incremented as illustrated in . In some examples the computing device blocks write access to the associated memory location upon executing the read transaction upon the associated memory location . At operation the computing device decides whether or not the read transaction is complete. If the read transaction is not complete N then the flowchart reverts back to and repeats operation . When the read transaction is completes Y the flowchart proceeds to operation where the pointer counter is decremented as illustrated in .

At operation the computing device decides whether or not the pointer counter associated with the memory location is zero. If the pointer counter is not zero N then the flowchart reverts back to and repeats operation . When the pointer counter is zero Y the flowchart proceeds to operation where the memory location is de allocated by the computing device as illustrated in .

At operation the computing device decides whether or not the write transaction is complete. If the write transaction has not completed then the flowchart reverts back to and repeats operation . The flowchart proceeds to operation after completion of the write transaction where the computing device increments the pointer counter for the associated memory location as illustrated in . In some examples the computing device may simultaneously decrement another pointer counter associated with a memory location permitting read access to a prior copy of the data .

The computing device includes a processor i.e. data processing device memory a storage device a high speed interface controller connecting to the memory and high speed expansion ports and a low speed interface controller connecting to a low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as a display coupled to a high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information non transitorily within the computing device . The memory may be a computer readable medium a volatile memory unit s or non volatile memory unit s . The non transitory memory may be physical devices used to store programs e.g. sequences of instructions or data e.g. program state information on a temporary or permanent basis for use by the computing device . Examples of non volatile memory include but are not limited to flash memory and read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM e.g. typically used for firmware such as boot programs as well as disks or tapes. Examples of volatile memory include but are not limited to random access memory RAM dynamic random access memory DRAM static random access memory SRAM phase change memory PCM .

The storage device is capable of providing mass storage for the computing device . In some implementations the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. In additional implementations a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device or memory on processor .

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of duties is exemplary only. In some implementations the high speed controller is coupled to the memory the display e.g. through a graphics processor or accelerator and to the high speed expansion ports which may accept various expansion cards not shown . In some implementations the low speed controller is coupled to the storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers as a laptop computer or as part of a rack server system

In some implementations the computing device implementing the computing resource s is in communication with data store e.g. in the memory . The computing resource executing on the data processing device executes the write and read transactions respectively allocates memory locations in the non transitory data store increments and decrements pointer counters associated with the memory locations and de allocates memory locations when the associated pointer counters decrement to zero. For example the computing resource may receive a write access request or a read access request from a user device execute a write transaction or a read transaction on the data store allocate a memory location in the data store and write data to the memory location . In some examples the computing resource initializes a pointer counter associated with the memory location when the write transaction executes and increments the pointer counter upon completion of the write transaction . For instance the pointer counter is equal to zero upon initializing and increments to one upon completion of the write transaction executing on the associated memory location . In other examples the computing resource executes one or more read transactions on the memory location after completion of the write transaction and increments the pointer counter for each read transaction executing on the memory location to get the data . In some examples the computing resource decrements the pointer counter after completion of each read transaction executing on the memory location . In some examples when updating the data the computing resource executes a subsequent second write transaction on the data store to update the data allocates a subsequent second memory location in the data store and writes updated data to the subsequent second memory location and initializes a subsequent second pointer counter associated with the subsequent second memory location . While the subsequent second pointer counter is zero the computing resource may execute one or more subsequent read transactions on the memory location to get the data un updated data while the subsequent second write transaction concurrently executes on the subsequent second memory location . Upon completion of the second write transaction the computing resource decrements the pointer counter associated with the memory location that includes the data and increments a subsequent second pointer counter associated with the subsequent second memory location that includes the updated data upon completion of the subsequent second write transaction . Accordingly when the subsequent second pointer counter is greater than zero the computing resource may execute one or more subsequent read transactions on the subsequent second memory location to get the updated data . In some examples the computing resource de allocates the memory location when the pointer counter associated with the memory location decrements to zero.

In some examples the computing resource blocks read access to a memory location when an associated pointer counter is zero wherein the pointer counter is zero when a write transaction executing on the associated memory location is in progress. In other examples the computing resource blocks write access to a memory location upon executing a read transaction upon the associated memory location .

A software application i.e. a software resource may refer to computer software that causes a computing device to perform a task. In some examples a software application may be referred to as an application an app or a program. Example applications include but are not limited to system diagnostic applications system management applications system maintenance applications word processing applications spreadsheet applications messaging applications media streaming applications social networking applications and gaming applications.

The non transitory memory may be physical devices used to store programs e.g. sequences of instructions or data e.g. program state information on a temporary or permanent basis for use by a computing device . The non transitory memory may be volatile and or non volatile addressable semiconductor memory. Examples of non volatile memory include but are not limited to flash memory and read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM e.g. typically used for firmware such as boot programs . Examples of volatile memory include but are not limited to random access memory RAM dynamic random access memory DRAM static random access memory SRAM phase change memory PCM as well as disks or tapes.

At operation the computing device increments the first pointer counter upon completion of the first write transaction and for each read transaction executing on the first memory location as illustrated in . The flowchart proceeds to operation where the computing device s allocates a second memory location in the non transitory data store and writes updated data to the second memory location when a second write transaction executes on the non transitory data store to update the data as illustrated in . In some implementations the computing device initializes a second pointer counter associated with the second memory location and blocks read access to the second memory location when the second pointer counter is zero while the second write transaction executing on the second memory location is in progress. At operation the computing device decrements the first pointer counter associated with the first memory location and increments the second pointer counter associated with the second memory location upon completion of the second write transaction as illustrated in . In some implementations the computing device decrements a pointer counter associated with a memory location for each read transaction on the associated memory location that completes. In some examples when the first pointer counter associated with the first memory location is greater than zero after the second pointer counter increments the computing device permits any read transactions executing on the first memory location already in progress to complete. However any subsequent read transactions will execute on the second memory location to get the updated data as illustrated in . At operation the computing device de allocates the first memory location when the first pointer counter decrements to zero as illustrated in .

In some implementations the computing device recursively performs the operations as the data is continuously updated. For example when a subsequent third write transaction executes on the data store to update the data again the computing resource will allocate a third memory location in the data store initialize a third pointer counter associated with the third memory location and write the updated data to the third memory location . Similar to operation discussed above with respect to the second write transaction the computing device increments the third pointer counter and decrements the second pointer counter associated with the second memory location upon completion of the third write transaction . Thereafter the computing resource de allocates the second memory location when the second pointer counter associated with the second memory location decrements to zero.

Various implementations of the systems and techniques described here can be realized in digital electronic and or optical circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product non transitory computer readable medium apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Moreover subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The terms data processing apparatus computing device and computing processor encompass all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as an application program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user one or more aspects of the disclosure can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display monitor or touch screen for displaying information to the user and optionally a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

One or more aspects of the disclosure can be implemented in a computing system that includes a backend component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a frontend component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such backend middleware or frontend components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In some implementations a server transmits data e.g. an HTML page to a client device e.g. for purposes of displaying data to and receiving user input from a user interacting with the client device . Data generated at the client device e.g. a result of the user interaction can be received from the client device at the server.

While this specification contains many specifics these should not be construed as limitations on the scope of the disclosure or of what may be claimed but rather as descriptions of features specific to particular implementations of the disclosure. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multi tasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other implementations are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

