---

title: Systems and methods for persistent atomic storage operations
abstract: A storage layer presents logical address space of a non-volatile storage device. The storage layer maintains logical interfaces to the non-volatile storage device, which may include arbitrary, any-to-any mappings between logical identifiers and storage resources. Data may be stored on the non-volatile storage device in a contextual format, which includes persistent metadata that defines the logical interface of the data. The storage layer may modify the logical interface of data that is stored in the contextual format. The modified logical interface may be inconsistent with the existing contextual format of the data on the non-volatile storage media. The storage layer may provide access to the data in the inconsistent contextual format through the modified logical interface. The contextual format of the data may be updated to be consistent with the modified logical interface in a write out-of-place storage operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323465&OS=09323465&RS=09323465
owner: SANDISK TECHNOLOGIES, INC.
number: 09323465
owner_city: Plano
owner_country: US
publication_date: 20150220
---
This disclosure relates to management of a logical interface to data stored in a contextual format on non volatile storage media.

According to various embodiments a storage controller manages one or more storage devices. The storage device s may comprise non volatile storage devices such as solid state storage device s that are arranged and or partitioned into a plurality of addressable media storage locations. As used herein a media storage location refers to any physical unit of storage e.g. any physical storage media quantity on a storage device . Media storage units may include but are not limited to pages storage divisions erase blocks sectors blocks collections or sets of physical storage locations e.g. logical pages logical erase blocks etc. described below or the like.

The storage controller may comprise a storage layer which may present a logical address space to one or more storage clients. As used herein a logical address space refers to a logical representation of storage resources. The logical address space may comprise a plurality e.g. range of logical identifiers. As used herein a logical identifier refers to any identifier for referencing a storage resource e.g. data including but not limited to a logical block address LBA cylinder head sector CHS address a file name an object identifier an inode a Universally Unique Identifier UUID a Globally Unique Identifier GUID a hash code a signature an index entry a range an extent or the like. The logical address space logical identifiers and relationships between logical identifiers and storage resources define a logical interface through which storage clients access storage resources. As used herein a logical interface refers to handle identifier path process or other mechanism for referencing and or interfacing with a storage resource. A logical interface may include but is not limited to a logical identifier a range or extent of logical identifiers a reference to a logical identifier e.g. a link between logical identifiers a pointer to a logical identifier etc. a reference to a virtual storage unit or the like. A logical interface may be used to reference data through a storage interface and or application programming interface API such as the storage layer interface described below but may not comprise an API per se.

The storage layer may maintain storage metadata such as a forward index to map logical identifiers of the logical address space to media storage locations on the storage device s . The storage layer may provide for arbitrary any to any mappings to physical storage resources. Accordingly there may be no pre defined and or pre set mappings between logical identifiers and particular media storage locations and or media addresses. As used herein a media address refers to an address of a storage resource that uniquely identifies one storage resource from another to a controller that manages a plurality of storage resources by way of example a media address includes but is not limited to the address of a media storage location a physical storage unit a collection of physical storage units e.g. a logical storage unit a portion of a media storage unit e.g. a logical storage unit address and offset range and or extent or the like. Accordingly the storage layer may map logical identifiers to physical data resources of any size and or granularity which may or may not correspond to the underlying data partitioning scheme of the storage device s . For example in some embodiments the storage controller is configured to store data within logical storage units that are formed by logically combining a plurality of physical storage units which may allow the storage controller to support many different virtual storage unit sizes and or granularities.

As used herein a logical storage element refers to a set of two or more non volatile storage elements that are or are capable of being managed in parallel e.g. via an I O and or control bus . A logical storage element may comprise a plurality of logical storage units such as logical pages logical storage divisions e.g. logical erase blocks and so on. Each logical storage unit may be comprised of storage units on the non volatile storage elements in the respective logical storage element. As used herein a logical storage unit refers to logical construct combining two or more physical storage units each physical storage unit on a respective solid state storage element in the respective logical storage element each solid state storage element being accessible in parallel . As used herein a logical storage division refers to a set of two or more physical storage divisions each physical storage division on a respective solid state storage element in the respective logical storage element.

The logical address space presented by the storage layer may have a logical capacity which may comprise a finite set or range of logical identifiers. The logical capacity of the logical address space may correspond to the number of available logical identifiers in the logical address space and or the size and or granularity of the data referenced by the logical identifiers. For example the logical capacity of a logical address space comprising 2 32 unique logical identifiers each referencing 2048 bytes 2 kb of data may be 2 43 bytes. In some embodiments the logical address space may be thinly provisioned. As used herein a thinly provisioned logical address space refers to a logical address space having a logical capacity that exceeds the physical storage capacity of the underlying storage device s . For example the storage layer may present a 64 bit logical address space to the storage clients e.g. a logical address space referenced by 64 bit logical identifiers which exceeds the physical storage capacity of the underlying storage devices. The large logical address space may allow storage clients to allocate and or reference contiguous ranges of logical identifiers while reducing the chance of naming conflicts. The storage layer may leverage the any to any mappings between logical identifiers and physical storage resources to manage the logical address space independently of the underlying physical storage devices. For example the storage layer may add and or remove physical storage resources seamlessly as needed and without changing the logical interfaces used by the storage clients.

The storage controller may be configured to store data in a contextual format. As used herein a contextual format refers to a self describing data format in which persistent contextual metadata is stored with the data on the physical storage media. The persistent contextual metadata provides context for the data it is stored with. In certain embodiments the persistent contextual metadata uniquely identifies the data that with which the persistent contextual metadata is stored. For example the persistent contextual metadata may uniquely identify a sector of data owned by a storage client from other sectors of data owned by the storage client. In a further embodiment the persistent contextual metadata identifies an operation that is performed on the data. In a further embodiment the persistent contextual metadata identifies an order of a sequence of operations performed on the data. In a further embodiment the persistent contextual metadata identifies security controls a data type or other attributes of the data. In certain embodiment the persistent contextual metadata identifies at least one of a plurality of aspects including data type a unique data identifier an operation and an order of a sequence of operations performed on the data. The persistent contextual metadata may include but is not limited to a logical interface of the data an identifier of the data e.g. a logical identifier file name object id label unique identifier or the like reference s to other data e.g. an indicator that the data is associated with other data a relative position or offset of the data with respect to other data e.g. file offset etc. data size and or range and the like. The contextual format data format may comprise a packet format comprising a data segment and one or more headers. Alternatively a contextual data format may associate data with context information in other ways e.g. in a dedicated index on the non volatile storage media a storage division index or the like . Accordingly a contextual data format refers to a data format that associates the data with a logical interface of the data e.g. the context of the data . A contextual data format is self describing in that the contextual data format includes the logical interface of the data.

In some embodiments the contextual data format may allow data context to be determined and or reconstructed based upon the contents of the non volatile storage media and independently of other storage metadata such as the arbitrary any to any mappings discussed above. Since the media storage location of data is independent of the logical interface of the data it may be inefficient or impossible to determine the context of data based solely upon the media storage location or media address of the data. Storing data in a contextual format on the non volatile storage media may allow data context to be determined without reference to other storage metadata. For example the contextual data format may allow the logical interface of data to be reconstructed based only upon the contents of the non volatile storage media e.g. reconstruct the any to any mappings between logical identifier and media storage location .

In some embodiments the storage controller may be configured to store data on an asymmetric write once storage media such as solid state storage media. As used herein a write once storage media refers to a storage media that is reinitialized e.g. erased each time new data is written or programmed thereon. As used herein asymmetric storage media refers to storage media having different latencies for different storage operations. Many types of solid state storage media are asymmetric for example a read operation may be much faster than a write program operation and a write program operation may be much faster than an erase operation e.g. reading the media may be hundreds of times faster than erasing and tens of times faster than programming the media . The storage media may be partitioned into storage divisions that can be erased as a group e.g. erase blocks in order to inter alia account for the asymmetric properties of the media. As such modifying a single data segment in place may require erasing the entire erase block comprising the data and rewriting the modified data to the erase block along with the original unchanged data. This may result in inefficient write amplification which may excessively wear the media. Therefore in some embodiments the storage controller may be configured to write data out of place. As used herein writing data out of place refers to writing data to different media storage location s rather than overwriting the data in place e.g. overwriting the original physical location of the data . Modifying data out of place may avoid write amplification since existing valid data on the erase block with the data to be modified need not be erased and recopied. Moreover writing data out of place may remove erasure from the latency path of many storage operations the erasure latency is no longer part of the critical path of a write operation .

The storage controller may comprise one or more processes that operate outside of the regular path for servicing of storage operations the path for performing a storage operation and or servicing a storage request . As used herein the regular path for servicing a storage request or path for servicing a storage operation also referred to as a critical path refers to a series of processing operations needed to service the storage operation or request such as a read write modify or the like. The path for servicing a storage request may comprise receiving the request from a storage client identifying the logical interface of the request e.g. logical identifiers pertaining to the request performing one or more storage operations on a non volatile storage media and returning a result such as acknowledgement or data. Processes that occur outside of the path for servicing storage requests may include but are not limited to a groomer deduplication and so on. These processes may be implemented autonomously and in the background from servicing storage requests such that they do not interfere with or impact the performance of other storage operations and or requests. Accordingly these processes may operate independent of servicing storage requests.

In some embodiments the storage controller comprises a groomer which is configured to reclaim storage divisions erase blocks for reuse. The write out of place write paradigm implemented by the storage controller may result in obsolete or invalid data remaining on the non volatile storage media. For example overwriting data X with data Y may result in storing Y on a new storage division rather than overwriting X in place and updating the any to any mappings of the storage metadata to identify Y as the valid up to date version of the data. The obsolete version of the data X may be marked as invalid but may not be immediately removed e.g. erased since as discussed above erasing X may involve erasing an entire storage division which is a time consuming operation and may result in write amplification. Similarly data that is no longer is use e.g. deleted or trimmed data may not be immediately removed. The non volatile storage media may accumulate a significant amount of invalid data. A groomer process may operate outside of the critical path for servicing storage operations. The groomer process may reclaim storage divisions so that they can be reused for other storage operations. As used herein reclaiming a storage division refers to erasing the storage division so that new data may be stored programmed thereon. Reclaiming a storage division may comprise relocating valid data on the storage division to a new storage location. The groomer may identify storage divisions for reclamation based upon one or more factors which may include but are not limited to the amount of invalid data in the storage division the amount of valid data in the storage division wear on the storage division e.g. number of erase cycles time since the storage division was programmed or refreshed and so on.

The storage controller may be further configured to store data in a log format. As described above a log format refers to a data format that defines an ordered sequence of storage operations performed on a non volatile storage media. In some embodiments the log format comprises storing data in a pre determined sequence within the media address space of the non volatile storage media e.g. sequentially within pages and or erase blocks of the media . The log format may further comprise associating data e.g. each packet or data segment with respective sequence indicators. The sequence indicators may be applied to data individually e.g. applied to each data packet and or to data groupings e.g. packets stored sequentially on a storage division such as an erase block . In some embodiments sequence indicators may be applied to storage divisions when the storage divisions are reclaimed e.g. erased as described above and or when the storage divisions are first used to store data.

In some embodiments the log format may comprise storing data in an append only paradigm. The storage controller may maintain a current append point within a media address space of the storage device. The append point may be a current storage division and or offset within a storage division. Data may then be sequentially appended from the append point. The sequential ordering of the data therefore may be determined based upon the sequence indicator of the storage division of the data in combination with the sequence of the data within the storage division. Upon reaching the end of a storage division the storage controller may identify the next available storage division the next storage division that is initialized and ready to store data . The groomer may reclaim storage divisions comprising invalid stale and or deleted data to ensure that data may continue to be appended to the media log.

The log format described herein may allow valid data to be distinguished from invalid data based upon the contents of the non volatile storage media and independently of the storage metadata. As discussed above invalid data may not be removed from the storage media until the storage division comprising the data is reclaimed. Therefore multiple versions of data having the same context may exist on the non volatile storage media e.g. multiple versions of data having the same logical interface and or same logical identifier . The sequence indicators associated with the data may be used to distinguish invalid versions of data from the current up to date version of the data the data that is the most recent in the log is the current version and all previous versions may be identified as invalid.

According to various embodiments a logical interface of data stored in a contextual format is modified. The contextual format of the data may be inconsistent with the modified logical interface. As used herein an inconsistent contextual data format refers to a contextual data format that defines a logical interface to data on storage media that is inconsistent with the a logical interface of the data. The logical interface of the data may be maintained by a storage layer storage controller or other module. The inconsistency may include but is not limited to the contextual data format associating the data with a different logical identifier than the logical interface the contextual data format associating the data with a different set of logical identifiers than the logical interface the contextual data format associating the data with a different logical identifier reference than the logical interface or the like. The storage controller may provide access to the data in the inconsistent contextual format and may update the contextual format of the data of the non volatile storage media to be consistent with the modified logical interface. The update may require re writing the data out of place and as such may be deferred. As used herein a consistent contextual data format refers to a contextual data format that defines the same or an equivalent logical interface as the logical interface of the data which may include but is not limited to the contextual data format associating the data with the same logical identifier s or equivalent logical identifier s as the logical interface the contextual data format associating the logical identifier with the same set of logical identifiers as the logical interface the contextual data format associating the data with the same reference logical identifier as the logical interface or the like.

According to various embodiments a storage controller and or storage layer performs a method for managing a logical address space comprising modifying a logical interface of data stored in a contextual format on a non volatile storage media wherein the contextual format of the data on the non volatile storage media is inconsistent with the modified logical interface of the data accessing the data in the inconsistent contextual format through the modified logical interface and updating the contextual format of the data on the non volatile storage media to be consistent with the modified logical interface. The logical interface of the data may be modified in response to a request e.g. a request from a storage client . The request may comprise a move clone e.g. copy deduplication or the like. The request may return e.g. be acknowledged by the storage layer before the contextual format of the data is updated on the non volatile storage media. Modifying the logical interface may further comprise storing a persistent note on the non volatile storage media indicative of the modification to the logical interface e.g. associate the data with the modified logical interface . The contextual format of the data may be updated out of place at other media storage locations on the non volatile storage media. Updates to the contextual format may be deferred and or made outside of the path of other storage operations e.g. independent of servicing other storage operations and or requests . For example the contextual format of the data may be updated as part of a grooming process. When reclaiming a storage division data that is in an inconsistent contextual format may be identified and updated as the data is relocated to new media storage locations. Providing access to the data through the modified logical interface may comprise referencing the data in the inconsistent contextual format through one or more reference entry and or indirect entries in an index.

In the following detailed description reference is made to the accompanying drawings which form a part thereof. The foregoing summary is illustrative only and is not intended to be in any way limiting. In addition to the illustrative aspects embodiments and features described above further aspects embodiments and features will become apparent by reference to the drawings and the following detailed description.

The storage layer may be configured to provide storage services to one or more storage clients . The storage clients may include local storage clients operating on the computing device and or remote storage clients accessible via the network and network interface . The storage clients may include but are not limited to operating systems file systems database applications server applications kernel level processes user level processes applications and the like.

The storage layer comprises and or is communicatively coupled to one or more storage devices A N. The storage devices A N may include different types of storage devices including but not limited to solid state storage devices hard drives SAN storage resources or the like. The storage devices A N may comprise respective controllers A N and non volatile storage media A N. As illustrated in The storage layer may provide access to the non volatile storage devices A N via a traditional block I O interface . Additionally the storage layer may provide access to enhanced functionality large virtual address space through the storage layer interface . The storage metadata may be used to manage and or track storage operations performed any of the Block I O interface storage layer interface cache interface or other related interfaces.

The cache interface may expose cache specific features accessible via the storage layer . Examples of such cache specific features are disclosed U.S. patent application Ser. No. 12 877 971 filed Sep. 8 2010 and entitled Apparatus System and Method for an Improved Nonvolatile Caching Device U.S. Provisional Patent Application Ser. No. 61 438 182 filed Jan. 31 2011 and entitled Apparatus System and Method for Managing Eviction of Data U.S. Provisional Patent Application Ser. No. 61 438 194 filed Jan. 31 2011 and entitled Apparatus System and Method for Managing Eviction of Data U.S. Provisional Patent Application Ser. No. 61 435 192 filed Jan. 21 2011 and entitled Apparatus System and Method for Destaging Cached Data and U.S. Provisional Patent Application Ser. No. 61 446 889 filed Feb. 25 2011 and entitled Apparatus System and Method for Managing Contents of a Cache each of which is hereby incorporated by reference in its entirety.

In some embodiments the storage layer interface presented to the storage clients provides access to data transformations implemented by the non volatile storage device and or the non volatile storage media controller . Examples of such transformations are disclosed in U.S. Provisional Patent Application Ser. No. 61 387 082 filed on Sep. 28 2010 and entitled Apparatus System and Method for Data Transformations within a Data Storage Device which is hereby incorporated by reference in its entirety.

The storage layer may provide storage services through one or more interfaces which may include but are not limited to a block I O interface an extended storage layer interface a cache interface and the like. The storage layer may present a logical address space to the storage clients through one or more interfaces. As discussed above the logical address space may comprise a plurality of logical identifiers each corresponding to respective media storage locations on one or more of the storage devices A N. The storage layer may maintain storage metadata comprising any to any mappings between logical identifiers and media storage locations as described above. The logical address space and storage metadata may therefore define a logical interface of data stored on the storage devices A N.

The storage layer may further comprise a log storage module that is configured to store data in a contextual log format. The contextual log data format may comprise associating data with persistent contextual metadata such as the logical interface of the data e.g. logical identifier or the like. The contextual log format may further comprise associating data with respective sequence identifiers on the non volatile storage media which define an ordered sequence of storage operations performed on the storage devices A N as described above.

The storage layer may further comprise a storage device interface configured to transfer data commands and or queries to the storage devices A N over a bus which may include but is not limited to a peripheral component interconnect express PCI Express or PCIe bus a serial Advanced Technology Attachment ATA bus a parallel ATA bus a small computer system interface SCSI FireWire Fibre Channel a Universal Serial Bus USB a PCIe Advanced Switching PCIe AS bus a network Infiniband SCSI RDMA or the like. The storage device interface may communicate with the storage devices A N using input output control IO CTL command s IO CTL command extension s remote direct memory access or the like.

The computing device may comprise a storage controller that is configured to provide storage services to the storage clients . The storage clients may include local storage clients operating on the computing device and or remote storage clients accessible via the network and network interface . The storage controller comprises one or more storage devices . Although depicts a single storage device the disclosure is not limited in this regard and could be adapted to incorporate any number of storage devices .

The non volatile storage device may comprise non volatile storage media which may include but is not limited to NAND flash memory NOR flash memory nano random access memory nano RAM or NRAM magneto resistive RAM MRAM dynamic RAM DRAM phase change RAM PRAM magnetic storage media e.g. hard disk tape optical storage media or the like. The non volatile storage media may be comprised of one or more storage elements which may include but are not limited to chips packages planes die and the like. A storage media controller may be configured to manage storage operations on the storage media and may comprise one or more processors programmable processors e.g. field programmable gate arrays or the like. In some embodiments the storage media controller is configured to store data on and read data from the storage media in the contextual log format described above and to transfer data to from the non volatile storage device and so on.

The storage media controller may be communicatively coupled to the non volatile storage media by way of a bus . The bus may comprise a storage I O bus for communicating data to from the non volatile storage elements . The bus may further comprise a control I O bus for communicating addressing and other command and control information to the non volatile storage elements . In some embodiments the bus may communicatively couple the non volatile storage elements to the storage media controller in parallel. This parallel access may allow the elements to be managed as a group forming a logical storage element . As discussed above the logical storage element may be partitioned into respective logical storage units e.g. logical pages and or logical storage divisions e.g. logical erase blocks . The logical storage units may be formed by logically combining physical storage units of each of the non volatile storage elements. For example if the solid state storage media comprises twenty five 25 non volatile storage elements each logical storage unit may comprise twenty five 25 pages a page of each of element .

The storage controller may comprise a storage layer and the storage media controller . The storage layer may provide storage services to the storage clients via one or more interfaces and or . The storage controller and or storage layer may comprise one or more drivers kernel level applications user level applications or the like. The storage controller and or storage layer may operate within an operating system a virtual operating system or the like. In some embodiments the storage layer provides a block device I O interface through which storage clients perform block level I O operations. Alternatively or in addition the storage layer may provide a storage layer storage layer interface which may provide other storage services to the storage clients . In some embodiments the storage layer interface may comprise extensions to the block device interface e.g. storage clients may access the storage layer interface through extensions to the block device interface . Alternatively or in addition the storage layer interface may be provided as a separate API service and or library. The storage layer may be further configured to provide a cache interface for caching data using the non volatile storage system .

As described above the storage layer may present a logical address space to the storage clients through the interfaces and or . The storage layer may maintain storage metadata comprising any to any mappings between logical identifiers in the logical address space and media storage locations on the non volatile storage device . The storage system may further comprise a log storage module which as described above may be configured to store data on the storage device in a contextual log format. The contextual log data format may comprise associating data with a logical interface e.g. logical identifier on the non volatile storage media . The contextual log format may further comprise associating data with respective sequence identifiers on the non volatile storage media which define an ordered sequence of storage operations performed on the non volatile storage media as described above. The storage controller may further comprise a storage device interface that is configured to transfer data commands and or queries to the storage media controller over a bus as described above.

The storage media controller may comprise a request module that is configured to receive storage requests from the storage layer via a bus . The request module may be further configured to transfer data to from the storage layer and or storage clients via the bus . Accordingly the request module may comprise one or more direct memory access DMA modules remote DMA modules bus controllers bridges buffers and so on.

The storage media controller may comprise a write pipeline that is configured to store data on the non volatile storage media in a contextual format in response to requests received via the request module . The requests may include and or reference data to be stored on the non volatile storage media may include logical interface of the data e.g. logical identifier s of the data and so on. The write pipeline may comprise a contextual write module and a write buffer . As described above the contextual format may comprise storing a logical interface of the data e.g. logical identifier of the data in association with the data on the non volatile storage media . For example the contextual write module may be configured to format data into packets and may include the logical interface of the data in a packet header or other packet field . The write buffer may be configured to buffer data for storage on the non volatile storage media . In some embodiments the write buffer may comprise one or more synchronization buffers to synchronize a clock domain of the storage media controller with a clock domain of the non volatile storage media and or bus .

The log storage module may be configured to select media storage location s for the data and may provide addressing and or control information to the non volatile storage elements via the bus . In some embodiments the log storage module is configured to store data sequentially in a log format within the media address space of the non volatile storage media. The log storage module may be further configured to groom the non volatile storage media as described above.

Upon writing data to the non volatile storage media the storage media controller may be configured to update storage metadata e.g. a forward index to associate the logical interface of the data e.g. the logical identifiers of the data with the media address es of the data on the non volatile storage media . In some embodiments the storage metadata may be maintained on the storage media controller for example the storage metadata may be stored on the non volatile storage media on a volatile memory not shown or the like. Alternatively or in addition the storage metadata may be maintained within the storage layer e.g. on a volatile memory of the computing device of . In some embodiments the storage metadata may be maintained in a volatile memory by the storage layer and may be periodically stored on the non volatile storage media .

The storage media controller may further comprise a read pipeline that is configured to read contextual data from the non volatile storage media in response to requests received via the request module . The requests may comprise a logical identifier of the requested data a media address of the requested data and so on. The contextual read module may be configured to read data stored in a contextual format from the non volatile storage media and to provide the data to the storage layer and or a storage client . The contextual read module may be configured to determine the media address of the data using a logical interface of the data and the storage metadata . Alternatively or in addition the storage layer may determine the media address of the data and may include the media address in the request. The log storage module may provide the media address to the non volatile storage elements and the data may stream into the read pipeline via the read buffer . The read buffer may comprise one or more read synchronization buffers for clock domain synchronization as described above.

The storage media controller may further comprise a multiplexer that is configured to selectively route data and or commands to from the write pipeline and the read pipeline . In some embodiments storage media controller may be configured to read data while filling the write buffer and or may interleave one or more storage operations on one or more banks of non volatile storage elements not shown .

The storage media controller may manage the non volatile storage elements as a logical storage element . The logical storage element may be formed by coupling the non volatile storage elements in parallel using the bus . Accordingly storage operations may be performed on the non volatile storage elements concurrently and in parallel e.g. data may be written to and or read from the non volatile storage elements in parallel . The logical storage element may comprise a plurality of logical storage divisions e.g. logical erase blocks each comprising a respective storage division of the non volatile storage elements . The logical storage divisions may comprise a plurality of logical storage units e.g. logical pages each comprising a respective physical storage unit of the non volatile storage elements . The storage capacity of a logical storage unit may be a multiple of the number of parallel non volatile storage elements comprising the logical storage unit for example the capacity of a logical storage element comprised of 2 kb pages on twenty five 25 non volatile storage elements is 50 kb.

Although depicts one example of a logical storage element the disclosure is not limited in this regard and could be adapted to differently sized logical storage elements comprising any number of non volatile storage elements . The size and number of erase blocks pages planes or other logical and physical divisions within the non volatile storage elements are expected to change over time with advancements in technology it is to be expected that many embodiments consistent with new configurations are possible and are consistent with the embodiments disclosed herein.

As described above the contextual write module may be configured to store data in a contextual format. In some embodiments the contextual format comprises a packet format. depicts one example of a contextual data format packet format . A packet includes data e.g. a data segment that is associated with one or more logical identifiers. In some embodiments the data segment comprises compressed encrypted and or whitened data. The data segment may be a predetermined size e.g. a fixed data block or segment size or a variable size. The packet may comprise persistent contextual metadata that is stored on the non volatile storage media with the data segment . e.g. in a header of the packet format as depicted in . The persistent contextual metadata may include logical interface metadata that defines the logical interface of the data segment . The logical interface metadata may associate the data segment with one or more logical identifiers a logical identifier references e.g. reference entries a range a size and so on. The logical interface metadata may be used to determine the context of the data independently of the storage metadata and or may be used to reconstruct the storage metadata e.g. reconstruct the any to any mappings described above . The persistent contextual metadata may comprise other metadata which may include but are not limited to data attributes e.g. an access control list data segment delimiters signatures links and or metadata flags described below and the like.

In some embodiments the packet may be associated with log sequence indicator . The log sequence indicator may be persisted on the non volatile storage media e.g. page with the data packet and or on the storage division e.g. erase block of the data packet . Alternatively the sequence indicator may be persisted in a separate storage division. In some embodiments a sequence indicator is applied when a storage division reclaimed e.g. erased when the first or last storage unit is programmed etc. . The log sequence indicator may be used to determine an order of the packet in a sequence of storage operations performed on the non volatile storage media as described above.

Referring back to the contextual write module may be configured to generate data packets of any suitable size. Data packets may be of a fixed size or a variable size. Due to the independence between the logical interface of data and the underlying media storage location of the data the size of the packets generated by the contextual write module may be independent of the underling structure and or partitioning of the non volatile storage media .

The write pipeline may further comprise an ECC write module which may be configured to encode the contextual data e.g. data packets into respective error correcting code ECC words or chunks. The ECC encoding may be configured to detect and or correct errors introduced through transmission and storage of data on the non volatile storage media . In some embodiments data packets stream to the ECC write module as un encoded blocks of length N ECC blocks . An ECC block may comprise a single packet multiple packets or a portion of one or more packets. The ECC write module may calculate a syndrome of length S for the ECC block which may be appended and streamed as an ECC chunk of length N S. The values of N and S may be selected according to testing and experience and may be based upon the characteristics of the non volatile storage media e.g. error rate of the media and or performance efficiency and robustness constraints. The relative size of N and S may determine the number of bit errors that can be detected and or corrected in an ECC chunk.

In some embodiments there is no fixed relationship between the ECC input blocks and the packets a packet may comprise more than one ECC block the ECC block may comprise more than one packet a first packet may end anywhere within the ECC block and a second packet may begin after the end of the first packet within the same ECC block. The ECC algorithm implemented by the ECC write module and or ECC read module may be dynamically modified and or may be selected according to a preference e.g. communicated via the bus in a firmware update a configuration setting or the like.

The ECC read module may be configured to decode ECC chunks read from the non volatile storage medium . Decoding an ECC chunk may comprise detecting and or correcting errors therein. The contextual read module may be configured to depacketize data packets read from the non volatile storage media . Depacketizing may comprise removing and or validating contextual metadata of the packet such as the logical interface metadata described above. In some embodiments the contextual read module may be configured to verify that the logical interface information in the packet matches a logical identifier in the storage request.

In some embodiments the log storage module is configured to store contextual formatted data sequentially in a log format. As described above log storage refers to storing data in a format that defines an ordered sequence of storage operation which may comprise storing data at sequential media addresses within the media address space of the non volatile storage media e.g. sequentially within one logical storage units . Alternatively or in addition sequential storage may refer to storing data in association with a sequence indicator such as a sequence number timestamp or the like such as the sequence indicator described above.

The log storage module may store data sequentially at an append point. An append point may be located where data from the write buffer will next be written. Once data is written at an append point the append point moves to the end of the data. This process typically continues until a logical erase block is full. The append point is then moved to next available logical erase block . The sequence of writing to logical erase blocks is maintained e.g. using sequence indicators so that if the storage metadata is corrupted or lost the log sequence of storage operations data be replayed to rebuild the storage metadata e.g. rebuild the any to any mappings of the storage metadata .

The logical storage units may be assigned respective media addresses in the example the media addresses range from zero 0 to N. The log storage module may store data sequentially at the append point data may be stored sequentially within the logical page and when the logical page is full the append point advances to the next available logical page in the logical erase block where the sequential storage continues. Each logical erase block A N may comprise a respective sequence indicator. Accordingly the sequential storage operations may be determined based upon the sequence indicators of the logical erase blocks A N and the sequential order of data within each logical erase block A N.

As used herein an available logical page refers to a logical page that has been initialized e.g. erased and has not yet been programmed. Some non volatile storage media can only be reliably programmed once after erasure. Accordingly an available logical erase block may refer to a logical erase block that is in an initialized or erased state. The logical erase blocks A N may be reclaimed by a groomer or other process which may comprise erasing the logical erase block A N and moving valid data thereon if any to other storage locations. Reclaiming logical erase block A N may further comprise marking the logical erase block A N with a sequence indicator as described above.

The logical erase block B may be unavailable for storage due to inter alia not being in an erased state e.g. comprising valid data being out of service due to high error rates or the like and so on. In the example after storing data on the physical storage unit the append point may skip the unavailable logical erase block B and continue at the next available logical erase block C. The log storage module may store data sequentially starting at logical page and continuing through logical page at which point the append point continues at a next available logical erase block as described above.

After storing data on the last storage unit e.g. storage unit N of storage division N the append point wraps back to the first division A or the next available storage division if storage division A is unavailable . Accordingly the append point may treat the media address space as a loop or cycle.

Referring back to the storage controller may comprise a groomer module that is configured reclaim logical erase blocks as described above. The groomer module may monitor the non volatile storage media and or storage metadata to identify logical erase blocks for reclamation. The groomer module may reclaim logical erase blocks in response to detecting one or more conditions which may include but are not limited to a lack of available storage capacity detecting a percentage of data marked as invalid within a particular logical erase block reaching a threshold a consolidation of valid data an error detection rate reaching a threshold improving data distribution data refresh or the like.

The groomer module may operate outside of the path for servicing storage operations and or requests. Therefore the groomer module may operate as an autonomous background process which may be suspended and or deferred while other storage operations are in process. The groomer may manage the non volatile storage media so that data is systematically spread throughout the logical erase blocks which may improve performance data reliability and to avoid overuse and underuse of any particular storage locations thereby lengthening the useful life of the solid state storage media e.g. wear leveling etc. . Although the groomer module is depicted in the storage layer the disclosure is not limited in this regard. In some embodiments the groomer module may operate on the storage media controller may comprise a separate hardware component or the like.

In some embodiments the groomer may interleave grooming operations with other storage operations and or requests. For example reclaiming a logical erase block may comprise relocating valid data thereon to another storage location. The groomer read and groomer write bypass modules and may be configured to allow data packets to be read into the read pipeline and then be transferred directly to the write pipeline without being routed out of the storage media controller .

The groomer read bypass module may coordinate reading data to be relocated from a reclaimed logical erase block . The groomer module may be configured to interleave relocation data with other data being written to the non volatile storage media via the groomer write bypass . Accordingly data may be relocated without leaving the storage media controller . In some embodiments the groomer module may be configured to fill the remainder of a logical page or other data storage primitive with relocation data which may improve groomer efficiency while minimizing the performance impact of grooming operations.

The storage controller may further comprise a deduplication module which may be configured to identify duplicated data on the storage device . The deduplication module may be configured to identify duplicated data and to modify a logical interface of the data such that one or more logical identifiers reference the same set of data on the storage device as opposed to referencing separate copies of the data. The deduplication module may operate outside of the path for servicing storage operations and or requests as described above.

As described above the storage controller may maintain an index corresponding to the logical address space . depicts one example of such an index . The index may comprise a one or more entries A N. Each entry A may correspond to a LID or LID range or extent in the logical address space . The entries A N may represent LIDs that have been allocated by use by one or more storage clients . The index may comprise any to any mappings between logical identifiers and media storage locations on one or more storage devices . For example the entry B binds logical identifiers to media storage locations . An entry D may represent a LID that has been allocated but has not yet been used to store data and as such the LIDs may not be bound to any particular media storage locations e.g. the LIDs are unbound . As described above deferring the allocation of physical storage resources may allow the storage controller to more efficiently manage storage resources e.g. prevent premature reservation of physical storage resources so that the storage resources are available to other storage clients . One or more of the entries A N may comprise additional metadata which may include but is not limited to access control metadata e.g. identify the storage client s authorized to access the entry reference metadata logical interface metadata and so on. The index may be maintained by the storage controller and or storage layer and may be embodied as storage metadata on a volatile memory and or a non transitory machine readable storage media and or .

The index may be configured to provide for fast and efficient entry lookup. The index may be implemented using one or more datastructures including but not limited to a B tree a content addressable memory CAM a binary tree a hash table or other datastructure that facilitates quickly searching a sparsely populated logical address space. The datastructure may be indexed by LID such that given a LID the entry A N corresponding to the LID if any can be identified in a computationally efficient manner.

In some embodiments the index comprise one or more entries not shown to represent unallocated LIDs e.g. LIDs that are available for allocation by one or more storage clients . The unallocated logical identifiers may be maintained in the index and or in a separate index as depicted in . In some embodiments the index may comprise one or more sub indexes such as a reference index. As described below the reference index may comprise data that is being referenced by one or more other entries A N in the index e.g. indirect references . Although particular examples and datastructures of storage metadata are described herein the disclosure is not limited in this regard the storage controller may be configured to incorporate any type of storage metadata embodied using any suitable datastructure.

The apparatus includes an allocation request module that receives from a requesting device an allocation request to allocate logical capacity. The requesting device may be storage client or any other device or component capable of sending an allocation request. The storage controller may comprise and or be communicatively coupled to one or more storage devices as depicted in . The logical capacity associated with the allocation request may refer to storing data on a particular storage device or on any of a plurality of storage devices A N.

The allocation request may include a logical allocation request or may include a request to store data. In the case of a logical allocation request the request is typically a request for LIDs to be allocated to a client . In the case of a request to store data one or more LIDs are allocated to the storage client which are then bound to media storage locations. As described above binding the LIDs may comprise associating the LIDs with media storage locations comprising the data in an index maintained in the storage metadata e.g. the index . The LIDs may be bound to media storage locations at the time of allocation e.g. the allocation request may comprise a request to store data . Alternatively where the allocation request is separate from a request to store data allocating LIDs to the data may be in a separate step from binding the LIDs to the media storage locations. In some embodiments the request comes from a plurality of storage clients consequently a client identifier may be associated with the request the apparatus may use the client identifier to implement an access control with respect to allocations for that storage client and or with respect to the LIDS available to allocate to the storage client . In addition the client identifier may be used to manage how much physical capacity is allocated to a particular storage client or set of storage clients .

The apparatus includes a logical capacity module that determines if a logical address space of the data storage device includes sufficient unallocated logical capacity to satisfy the allocation request. The logical capacity module may determine if the logical address space has sufficient unbound and or unallocated logical capacity using an index or other datastructure maintaining LID bindings and or LID allocations. In some embodiments the logical capacity module may search a logical to physical map or index maintained in the storage metadata and or an unallocated index described below.

As described above unbound LIDs may refer to LIDs that do not correspond to valid data stored on a media storage location. An unbound LID may be allocated to a client or may be unallocated. In some embodiments the logical to physical map is configured such that there are no other logical to logical mappings between the LIDs in the map and media addresses associated with the LIDs.

In some embodiments the logical capacity module searches the logical to physical index or other datastructure to identify unbound LIDs and identifies unallocated logical space therein. For example if a logical address space includes a range of logical addresses from 0000 to FFFF and logical to physical map indicates that the logical addresses 0000 to F000 are allocated and bound the logical capacity module may determine that logical identifiers F001 to FFFF are not allocated. If the logical identifiers F001 to FFFF are not allocated to another storage client they may be available for allocation to satisfy the allocation request.

In some embodiments the storage controller may maintain a separate logical address space each storage client . Accordingly each storage client may operate in its own separate logical storage space . The storage controller may therefore maintain separate storage metadata e.g. indexes capacity indicators and so on for each storage client or group of storage clients . Storage clients may be distinguished an identifier which may include but is not limited to an address e.g. network address a credential name context or other identifier. The identifiers may be provided in storage requests and or may be associated with a communication channel or protocol used by the storage client to access the storage controller .

In some embodiments the index or other datastructure may comprise an allocation index or allocation entries configured to track logical capacity allocations that have not yet been bound to media storage locations. For example a LID or other portion of logical capacity may be allocated to a client but may not be associated with data stored on a storage device . Accordingly although the logical capacity maybe allocated it may be unbound and as such may not be included in the logical to physical index. Accordingly when determining the unallocated logical address space the logical capacity module may consult additional datastructures e.g. allocation index allocation entries and or an unallocated index . Alternatively the allocation entry may be included in the logical to physical index e.g. entry D and may comprise an indicator showing that the entry is not bound to any particular media storage locations.

An allocation request may include a request for a certain number of LIDs. The logical capacity module may determine if the available logical capacity e.g. unbound and or unallocated logical capacity is sufficient to meet or exceed the requested amount of logical addresses. In another example if the allocation request specifies a list or range of LIDs to allocate the logical capacity module can determine if the LIDs for all or a portion of the LIDs requested are unallocated or unbound.

The apparatus may further comprise an allocation reply module that communicates a reply to the requesting device indicating whether the request can be satisfied. For example if the logical capacity module determines that the unallocated logical space is insufficient to satisfy the allocation request the allocation reply module may include in the reply that the allocation request failed and if the logical capacity module determines that the unallocated logical space is sufficient to satisfy the allocation request and or the specified LIDs are unallocated the allocation reply module may include in the reply an affirmative response. An affirmative response may comprise a list of allocated LIDs a range of LIDs or the like.

In some embodiments the allocation request is for a specific group of LIDs and the allocation reply module may reply with the requested LIDs. In another embodiment the allocation request is part of a write request. In one case the write request includes specific LIDs and the allocation reply module may reply with the requested LIDs. In another case the write request only includes data or an indication of an amount of data and the allocation reply module may reply by allocating LIDS sufficient for the write request and returning the allocated LIDS. Alternatively if an indication of an amount of data is provided the reply may include LIDs that are unallocated. The allocation reply module may reply before or after the data is written. If the allocation reply module sends a reply after the data is written the reply may be part of a confirmation of writing the data. One of skill in the art will recognize other ways that the allocation reply module may reply in response to the logical capacity module determining if the logical space of the data storage device has sufficient unallocated logical space to satisfy an allocation request.

The storage controller may expose the logical address space and or index directly to storage clients via the storage layer interface or other interface . The storage clients may use the storage layer interface to perform various functions including but not limited to identifying available logical capacity e.g. particular LIDs or general LID ranges determine available physical capacity query the health of the storage media identify allocated LIDs identify LIDs that are bound to media storage locations etc. In summary the interface can expose all or a subset of the features and functionality of the apparatus directly to clients which may leverage the storage layer interface to delegate management of the logical address space and or LIDs to the storage layer .

The apparatus includes in one embodiment a physical capacity request module a physical capacity allocation module and a physical capacity reply module . The physical capacity request module receives from a requesting device a physical capacity request. The physical capacity request is received at the data storage device and includes a request of an amount of available physical storage capacity in the data storage device and or physical storage capacity allocated to the requesting device . The physical capacity request may include a quantity of physical capacity or may indirectly request physical storage capacity for example by indicating a size of a data unit to be stored. Another indirect physical storage capacity request may include logical addresses of data to be stored which may correlate to a data size. One of skill in the art will recognize other forms of a physical capacity request.

The physical capacity allocation module determines the amount of available physical storage capacity on one or more storage devices and or A N. The amount of available physical storage capacity includes a physical storage capacity of unbound media storage locations. In some embodiments amount of available physical storage capacity may be budgeted for example only a portion of the physical storage capacity of a storage device may be available to the requesting device. In some embodiments amount of available physical storage capacity may be budgeted based on a quota associated with each storage client or group of storage clients . The apparatus may enforce these quotas. The allocation of available physical storage device may be determined by configuration parameter s may be dynamically adjusted according to performance and or quality of service policies or the like.

The physical capacity allocation module may determine the amount of available physical storage capacity using an index or other datastructure such as the index described above. Index may identify the media storage locations that comprise valid data e.g. entries A N that comprise bound media storage locations . The available storage capacity may be a total or budgeted physical capacity minus the capacity of the bound media storage locations. Alternatively or in addition an allocation index or other datastructure may maintain an indicator of the available physical storage capacity. The indicator may be updated responsive to storage operations performed on the storage device including but not limited to grooming operations deallocations e.g. TRIM writing additional data physical storage capacity reservations physical storage capacity reservation cancellations and so on. Accordingly the module may maintain a running total of available physical storage capacity that is available on request.

The physical capacity reply module that communicates a reply to the requesting device in response to the physical capacity allocation module determining the amount of available physical storage capacity on the data storage device.

The physical capacity allocation module in one embodiment tracks bound media storage locations unbound media storage locations reserved physical storage capacity unreserved physical storage capacity and the like. The physical capacity allocation module may track these parameters using a logical to physical map a validity map a free media address pool used media address pool a physical to logical map or other means known to one of skill in the art.

The reply may take many forms. In one embodiment where the physical capacity request includes a request for available physical capacity the reply may include an amount of available physical storage capacity. In another embodiment where the physical capacity request includes a specific amount of physical capacity the reply may include an acknowledgement that the data storage device has the requested available physical storage capacity. One of skill in the art will recognize other forms of a reply in response to a physical capacity request.

The apparatus with a physical capacity request module a physical capacity allocation module and a physical capacity reply module is advantageous for storage devices where a logical to physical mapping is not a one to one mapping. In a typical random access device where read and write requests include one or more LBAs a file server storage client may track physical storage capacity of a storage device by tracking the LBAs that are bound to media storage locations.

For a log storage system where multiple media storage locations can be mapped to a single logical identifier i.e. multiple versions of data mapped to a logical identifier or vice versa e.g. multiple logical identifiers to a the same media storage locations tracking logical identifiers may not provide any indication of physical storage capacity. These many to one relationships may be used to support snap shots cloning e.g. logical copies deduplication and or backup. Examples of systems and methods for managing many to one LID to media storage location logical interfaces as described below in conjunction with . The apparatus may track available physical storage space and may communicate the amount of available physical storage space to storage clients which may allow the storage clients offload allocation management and physical capacity management to the storage controller .

In some embodiments media storage locations are bound to corresponding LIDs. When data is stored in response to a write request LIDs associated with the data are bound to the media storage location where the data is stored. For a log structured file system where data is stored sequentially the location where the data is stored is not apparent from the logical identifier even if the logical identifier is an LBA. Instead the data is stored at an append point and the address where the data is stored is mapped to the logical identifier. If the data is a modification of data stored previously the LID may be mapped to the current data as well as to a location where the old data is stored. There may be several versions of the data mapped to the same LID.

The apparatus in one embodiment includes an allocation module that allocates the unallocated logical space sufficient to satisfy the allocation request of the requesting device. The allocation module may allocate the unallocated logical space in response to the logical capacity module determining that the logical space has sufficient unallocated logical space to satisfy the allocation request.

In one embodiment the allocation request is part of a pre allocation where logical space is not associated with a specific request to store data. For example a storage client may request using an allocation request logical space and then may proceed to store data over time to the allocated logical space. The allocation module allocates LIDs to the storage client in response to an allocation request and to the logical capacity module determining that the logical space has sufficient unallocated logical space to satisfy the allocation request.

The allocation module may also allocate LIDs based on an allocation request associated with a specific storage request. For example if a storage request includes specific LIDs and the logical capacity module determines that the LIDs are available the allocation module may allocate the LIDs in conjunction with storing the data of the storage request. In another example if the storage request does not include LIDs and the logical capacity module determines that there are sufficient LIDs to for the storage request the allocation module may select and allocate LIDs for the data and the allocation reply module may communicate the allocated LIDs.

The allocation module may be configured to locates unallocated LIDs to satisfy an allocation request. In some embodiments the allocation module may identify unallocated LIDs by receiving a list of requested LIDs to allocate from the storage client and verify that these LIDs are available for allocation. In another example the allocation module may identify unallocated LIDs by searching for unallocated LIDs that meet criteria received in conjunction with the request. The criteria may be LIDs that are associated with a particular storage device A N that are available in a RAID that have some assigned metadata characteristic etc.

In another example the allocation module may identify unallocated LIDs by creating a subset of LIDs that meet criteria received in conjunction with the request identified in a pool of available LIDs. In one instance the LIDs may be a subset of LIDs that have already been allocated to the client . For example if a set or group of LIDs is allocated to a particular user group employer etc. a subset of the LIDs may be allocated. A specific example is if a set of LIDs is allocated to an organization and then a subset of the allocated LIDs is further allocated to a particular user in the organization. One of skill in the art will recognize other ways that the allocation module can identify one or more unallocated LIDs.

The allocation module in one embodiment can expand the LIDs allocated to a storage client by allocating LIDs in addition to LIDs already allocated to the storage client . In addition LIDs allocated to a storage client may be decreased by deallocating certain LIDs so that they return to a pool of unallocated LIDs. In other embodiments subsets of allocated LIDs may be allocated deallocated increased decreased etc. For example LIDs allocated to a user in an organization may be deallocated so that the LIDs allocate to the user are still allocated to the organization but not to the user.

The apparatus in one embodiment includes an allocation query request module an allocation query determination module an allocation query reply module . The allocation query request module receives an allocation query the data storage device. The allocation query request module receives an allocation query from some requesting device such as a storage client etc. An allocation query may include a request for information about allocating logical space or associated management of the allocated logical space. For example an allocation query may be a request to identify allocated LIDs identify bound LIDs identify allocated LIDs that are not bound to media storage locations unallocated LIDs or a range of LIDs and the like.

The allocation query may include information about logical allocation logical capacity physical capacity or other information meeting criteria in the allocation query. The information may include metadata status logical associations historical usage flags control etc. One of skill in the art will recognize other allocation queries and the type of information returned in response to the allocation query.

The allocation query includes some type of criteria that allows the allocation query determination module to service the allocation request. The allocation query determination module in one embodiment identifies one or more LIDs that meet the criteria specified in the allocation query. The identified LIDs include allocated LIDs that are bound to media storage locations allocated LIDs that are unbound unallocated LIDs and the like.

The allocation query reply module communicates to the client the results of the query to the requesting device or to another device as directed in the allocation query. The results of the allocation query may include a list of the identified LIDs an acknowledgement that LIDs meeting the criteria were found an acknowledgement that LIDs meeting the criteria in the allocation query were not found bound unbound status of LIDs logical storage capacity or the like. Typically the allocation query reply module returns status information and the information returned may include any information related to managing and allocating LIDs known to those of skill in the art.

The apparatus in another embodiment includes a logical space management module that manages the logical space of the data storage device from within the data storage device. For example the logical space management module may manage the logical space from a storage controller or driver associated with a storage device of the data storage device. The logical space management module may track unbound LIDs and bound LIDs for example in the logical to physical map in an index or other datastructure. As described above a bound LID refers to a LID corresponding to data a bound LID is a LID associated with valid data stored on a media storage location of the storage device .

The logical space management module in various embodiments may service allocation requests and allocation queries as described above and other functions related to allocation. The logical space management module can also include receiving a deallocation request from a requesting device. The deallocation request typically includes a request to return one or more allocated LIDs to an unallocated state and then communicating to the requesting device or other designated device the successful deallocation. The deallocation request may include a request to return one or more storage locations which keeping the associated LIDS allocated then communicating to the requesting device or other designated device the successful deallocation. This might be transparent or require that the deallocation request be extended to include an indication that a logical physical deallocation should accompany the request. Note that deallocation request may be asynchronous and tied to the groomer. Thus the deallocation request may is virtual in time until completed. The management of the allocations logical and physical may diverge from the actual available space at any point in time. The management module is configured deal with these differences.

The logical space management module may also receive a LID group command request from a requesting device and may communicate to the requesting device a reply indicating a response to the LID group command request. The LID group command request may include an action to take on for example two or more LIDs LID group metadata associated with the LID group the data associated with the LID group and the like. For example if several users are each allocated LIDs and the users are part of a group a LID group command may be to deallocate the LIDs for several of the users allocate additional LIDs to each user return usage information for each user etc. The action taken in response to the LID group command may also include modifying the metadata backing up the data backing up the metadata changing control parameters changing access parameters deleting data copying the data encrypting the data deduplicating the data compressing the data decompressing the data etc. One of skill in the art will recognize other logical space management functions that the logical space management module may also perform.

The apparatus in one embodiment includes a mapping module that binds in a logical to physical map e.g. the index bound LIDs to media storage locations. The logical capacity module determines if the logical space has sufficient unallocated logical space using the logical to physical map mapped by the mapping module . The index may be used to track allocation of the bound LIDs the unbound LIDs the allocated LIDs the unallocated LIDs the allocated LID capacity the unallocated LID capacity and the like. In one embodiment the mapping module binds LIDs to corresponding media storage locations addresses in multiple indexes and or maps.

In addition a reverse map may be used to quickly access information related to a media address and to link to a logical identifier associated with the media address. The reverse map may be used to identify a LID from a media address. A reverse map may be used to map addresses in a data storage device into erase regions such as erase blocks such that a portion of the reverse map spans an erase region of the storage device erased together during a storage space recovery operation. Organizing a reverse map by erase regions facilitates tracking information useful during a grooming operations. For example the reverse map may include which media addresses in an erase region have valid data and which have invalid data. When valid data is copied from an erase region and the erase region erased the reverse map can easily be changed to indicate that the erase region does not include data and is ready for sequential storage of data.

A more detailed discussion of forward and reverse mapping is included in U.S. patent application Ser. No. 12 098 434 titled Apparatus System and Method for Efficient Mapping of Virtual and Media addresses Non Volatile Storage to David Flynn et al. and filed Apr. 8 2008 which is incorporated herein by reference. By including powerful mapping of LIDs and corresponding media addresses in the storage controller the mapping efficiently consolidates functions such as thin provisioning allocation functions etc. that have traditionally been done at higher levels. The mapping module provides an efficient way to eliminate layers of mapping used in traditional systems.

In a thinly provisioned storage system one potential problem is that a storage client may attempt to write data to a storage device only to have the write request fail because the storage device is out of available physical storage capacity. For random access devices where the file server file system tracks available physical storage capacity relying on the one to one mapping of LBAs to PBAs the likelihood of a storage device running out of storage space is very low. The storage client may however think that the storage device is a random access if the storage device is in fact a thinly provisioned system a log structured file system etc. For such a situation it is desirable to reserve physical space prior to or in conjunction with a write request so that the write request does not fail. There are other situations as well where a storage client may wish to reserve physical storage space.

The apparatus includes a physical space reservation request module located in the storage controller that receives a request from a storage client to reserve available physical storage capacity on the data storage device i.e. the storage device that is part of the data storage device hereinafter a physical space reservation request . In one embodiment the physical space reservation request includes an indication of an amount of physical storage capacity requested by the storage client .

The indication of an amount of physical storage capacity requested may be expressed in terms of physical capacity. The request to reserve physical storage capacity may also include a request to allocate the reserved physical storage capacity to a logical entity. The indication of an amount of physical storage capacity may be expressed indirectly as well. For example a storage client may indicate a number of logical blocks and the data storage device may determine a particular fixed size for each logical block and then translate the number of logical blocks to a physical storage capacity. One of skill in the art will recognize other indicators of an amount of physical storage capacity in a physical space reservation request.

The physical space reservation request in one embodiment is associated with a write request. In one embodiment the write request is a two step process and the physical space reservation request and the write request are separate. In another embodiment the physical space reservation request is part of the write request or the write request is recognized as having an implicit physical space reservation request. In another embodiment the physical space reservation request is not associated with a specific write request but may instead be associated with planned storage reserving storage space for a critical operation etc. where mere allocation of storage space is insufficient.

In certain embodiments the data may be organized into atomic data units. For example the atomic data unit may be a packet a page a logical page a logical packet a block a logical block a set of data associated with one or more logical block addresses the logical block addresses may be contiguous or noncontiguous a file a document or other grouping of related data.

In one embodiment an atomic data unit is associated with a plurality of noncontiguous and or out of order logical block addresses or other identifiers that the write data pipeline handles as a single atomic data unit. As used herein writing noncontiguous and or out of order logical blocks in a single write operation is referred to as an atomic write. In one embodiment a hardware controller processes operations in the order received and a software driver of the client sends the operations to the hardware controller for a single atomic write together so that the write data pipeline can process the atomic write operation as normal. Because the hardware processes operations in order this guarantees that the different logical block addresses or other identifiers for a given atomic write travel through the write data pipeline together to the nonvolatile memory. The client in one embodiment can back out reprocess or otherwise handle failed atomic writes and or other failed or terminated operations upon recovery once power has been restored.

In one embodiment apparatus may mark blocks of an atomic write with a metadata flag indicating whether a particular block is part of an atomic write. One example metadata marking is to rely on the log write append only protocol of the nonvolatile memory together with a metadata flag or the like. The use of an append only log for storing data and prevention of any interleaving blocks enables the atomic write membership metadata to be a single bit. In one embodiment the flag bit may be a 0 unless the block is a member of an atomic write and then the bit may be a 1 or vice versa. If the block is a member of an atomic write and is the last block of the atomic write in one embodiment the metadata flag may be a 0 to indicate that the block is the last block of the atomic write. In another embodiment different hardware commands may be sent to mark different headers for an atomic write such as first block in an atomic write middle member blocks of an atomic write tail of an atomic write or the like.

On recovery from a power loss or other failure of the client or of the storage device in one embodiment the apparatus scans the log on the nonvolatile storage in a deterministic direction for example in one embodiment the start of the log is the tail and the end of the log is the head and data is always added at the head . In one embodiment the power management apparatus scans from the head of the log toward the tail of the log. For atomic write recovery in one embodiment when scanning head to tail if the metadata flag bit is a 0 then the block is either a single block atomic write or a non atomic write block. In one embodiment once the metadata flag bit changes from 0 to 1 the previous block scanned and potentially the current block scanned are members of an atomic write. The power management apparatus in one embodiment continues scanning the log until the metadata flag changes back to a 0 at that point in the log the previous block scanned is the last member of the atomic write and the first block stored for the atomic write.

In one embodiment the nonvolatile memory uses a sequential append only write structured writing system where new writes are appended on the front of the log i.e. at the head of the log . In a further embodiment the storage controller reclaims deleted stale and or invalid blocks of the log using a garbage collection system a groomer a cleaner agent or the like. The storage controller in a further embodiment uses a forward map to map logical block addresses to media addresses to facilitate use of the append only write structure and garbage collection.

The apparatus in one embodiment includes a physical space reservation module that determines if the data storage device i.e. storage device has an amount of available physical storage capacity to satisfy the physical storage space request. If the physical space reservation module determines that the amount of available physical storage capacity is adequate to satisfy the physical space reservation request the physical space reservation module reserves an amount of available physical storage capacity on the storage device to satisfy the physical storage space request. The amount of available physical storage capacity reserved to satisfy the physical storage space request is the reserved physical capacity.

The amount of reserved physical capacity may or may not be equal to the amount of storage space requested in the physical space reservation request. For example the storage controller may need to store additional information with data written to a storage device such as metadata index information error correcting code etc. In addition the storage controller may encrypt data which may affect storage size. The storage controller may also compress data which may reduce the amount of physical storage capacity required to satisfy the requested amount in the physical space reservation request.

In one embodiment the physical space reservation request includes an amount of logical space and the indication of an amount of physical storage capacity requested is derived from the requested logical space. In another embodiment the physical space reservation request includes one or more LIDs and the indication of an amount of physical storage capacity requested is derived from an amount of data associated with the LIDs. In one example the data associated with the LIDs is data that has been bound to the LIDs such as in a write request. In another example the data associated with the LIDs is a data capacity allocated to each LID such as would be the case if a LID is an LBA and a logical block size could be used to derive the amount of requested physical storage capacity.

In another embodiment the physical space reservation request is a request to store data. In this embodiment the physical space reservation request may be implied and the indication of an amount of physical storage capacity requested may be derived from the data and or metadata associated with the data. In another embodiment the physical space reservation request is associated with a request to store data. In this embodiment the indication of an amount of physical storage capacity requested is indicated in the physical space reservation request and may be correlated to the data of the request to store data.

The physical space reservation module may also then factor metadata compression encryption etc. to determine an amount of required physical capacity to satisfy the physical space reservation request. The amount of physical capacity required to satisfy the physical space reservation request may be equal to larger or smaller than an amount indicated in the physical space reservation request.

Once the physical space reservation module determines an amount of physical capacity required to satisfy the physical space reservation request the physical space reservation module determines if one or more storage devices A N of the storage controller either individually or combined have enough available physical storage capacity to satisfy the physical space reservation request. The request may be for space on a particular storage device e.g. A a combination of storage devices A N such as would be the case if some of the storage devices A N are in a RAID configuration or for available space generally in the storage controller . The physical space reservation module may tailor a determination of available capacity to specifics of the physical space reservation request.

Where the physical space reservation request is for space on more than one storage device the physical space reservation module will typically retrieve available physical storage capacity information from each logical to physical map of each storage device or a combined logical to physical map of a group of storage devices A N. The physical space reservation module typically surveys bound media addresses. Note that the physical space reservation module may not have enough information to determine available physical capacity by looking at bound LIDs because there is typically not a one to one relationship between LIDs and media storage locations.

The physical space reservation module reserves physical storage capacity in one embodiment by maintaining enough available storage capacity to satisfy the amount of requested capacity in the physical space reservation request. Typically in a log structured file system or other sequential storage device the physical space reservation module would not reserve a specific media region or media address range in the storage device but would instead reserve physical storage capacity.

For example a storage device may have 500 gigabytes GB of available physical storage capacity. The storage device may be receiving data and storing the data at one or more append points thus reducing the storage capacity. Meanwhile a garbage collection or storage space recovery operation may be running in the background that would return recovered erase blocks to storage pool thus increasing storage space. The locations where data is stored and freed are constantly changing so the physical space reservation module in one embodiment monitors storage capacity without reserving fixed media storage locations.

The physical space reservation module may reserve storage space in a number of ways. For example the physical space reservation module may halt storage of new data if the available physical storage capacity on the storage device decreased to the reserved storage capacity may send an alert if the physical storage capacity on the storage device was reduced to some level above the reserved physical storage capacity or some other action or combination of actions that would preserve an available storage capacity above the reserved physical storage capacity.

In another embodiment the physical space reservation module reserves a media region range of media addresses etc. on the data storage device. For example if the physical space reservation module reserved a certain quantity of erase blocks data associated with the physical space reservation request may be stored in the reserved region or address range. The data may be stored sequentially in the reserved storage region or range. For example it may be desirable to store certain data at a particular location. One of skill in the art will recognize reasons to reserve a particular region address range etc. in response to a physical space reservation request.

In one embodiment the apparatus includes a physical space reservation return module that transmits to the storage client an indication of availability or unavailability of the requested amount of physical storage capacity in response to the physical space reservation module determining if the data storage device has an amount of available physical storage space that satisfies the physical space reservation request. For example if the physical space reservation module determines that the available storage space is adequate to satisfy the physical space reservation request the physical space reservation return module may transmit a notice that the physical space reservation module has reserved the requested storage capacity or other appropriate notice.

If on the other hand the physical space reservation module determines that the storage device or storage controller does not have enough available physical storage capacity to satisfy the physical space reservation request the physical space reservation return module may transmit a failure notification or other indicator that the requested physical storage space was not reserved. The indication of availability or unavailability of the requested storage space for example may be used prior to writing data to reduce a likelihood of failure of a write operation.

The apparatus in another embodiment includes a physical space reservation cancellation module that cancels all or a portion of reserved physical storage space in response to a cancellation triggering event. The cancellation triggering event may come in many different forms. For example the cancellation triggering event may include determining that data to be written to the storage device or storage controller and associated with available space reserved by the physical space reservation module has been previously stored in the storage controller .

For example if a deduplication process deduplication module determines that the data already exists in the storage controller the data may not need to be stored again since the previously stored data could be mapped to two or more LIDs. In a more basic example if reserved physical storage space is associated with a write request and the write request is executed the cancellation triggering event could be completion of storing data of the write request. In this example the physical space reservation cancellation module may reduce or cancel the reserved physical storage capacity.

If the data written is less than the reserved space the physical space reservation cancellation module may merely reduce the reserved amount or may completely cancel the reserved physical storage capacity associated with the write request. Writing to less than the reserved physical space may be due to writing a portion of a data unit where the data unit is the basis of the request where data associated with a physical space reservation request is written incrementally etc. In one embodiment physical storage space is reserved by the physical storage space reservation module to match a request and then due to compression or similar procedure the storage space of the data stored is less than the associated reserved physical storage capacity.

In another embodiment the cancellation triggering event is a timeout. For example if a physical space reservation request is associated with a write request and the physical space reservation module reserves physical storage capacity if the data associated with the write request is not written before the expiration of a certain amount of time the physical space reservation cancellation module may cancel the reservation of physical storage space. One of skill in the art will recognize other reasons to cancel all or a portion of reserved physical capacity.

The physical space reservation module in one embodiment may increase or otherwise change the amount of reserved physical storage capacity. For example the physical space reservation request module may receive another physical space reservation request which may or may not be associated with another physical space reservation request. Where the physical space reservation request is associated with previously reserved physical storage capacity the physical space reservation module may increase the reserved physical storage capacity. Where the physical space reservation request is not associated with previously reserved physical storage capacity the physical space reservation module may separately reserve physical storage capacity and track the additional storage capacity separately. One of skill in the art will recognize other ways to request and reserve available physical storage capacity and to change or cancel reserved capacity. Standard management should include some kind of thresholds triggers alarms and the like for managing the physical storage capacity providing indicators to the user that action needs to be taken. Typically this would be done in the management system. But either the management system would have to pool the devices under management or said devices would have to be configured programmed to interrupt the manger when a criteria was met preferred .

The apparatus in another embodiment includes a LID binding module that in response to a request from a storage client to write data binds one or more unbound LIDs to media storage locations comprising the data and transmits the LIDs to the storage client . The LID assignment module in one embodiment allows on the fly allocation and binding of LIDs. The request to write data in another embodiment may be a two step process. The LID binding module may allocate LIDs in a first step for data to be written and then in a second step the data may be written along with the allocated LIDs.

In one embodiment the LID allocation module allocates LIDs in a contiguous range. The LID binding module may also allocate LIDs in a consecutive range. Where a logical space is large the LID allocation module may not need to fragment allocated LIDs but may be able to choose a range of LIDs that are consecutive. In another embodiment the LID allocation module binds LIDs that may not be contiguous and may use logical spaces that are interspersed with other allocated logical spaces.

The apparatus in another embodiment includes a DMA module that pulls data from a client in a direct memory access DMA and or a remote DMA RDMA operation. The data is first identified in a request to store data such as a write request and then the storage controller executes a DMA and or RDMA to pull data from the storage client to a storage device . In another embodiment the write request does not use a DMA or RDMA but instead the write request includes the data. Again the media storage locations of the data are bound to the corresponding LIDs.

In one embodiment the apparatus includes a deletion module . In response to a request to delete data from the data storage device in one embodiment the deletion module removes the mapping between storage space where the deleted data was stored and the corresponding LID. The deletion module may also unbind the one or more media storage locations of the deleted data and also may deallocate the one or more logical addresses associated with the deleted data.

The logical capacity module determines if a logical address space includes sufficient unallocated logical capacity to satisfy the allocation request where the determination includes a search of a logical to physical map e.g. index or other datastructure . The logical to physical map includes bindings between LIDs of the logical space and corresponding media storage locations comprising data of the bound LIDs wherein a bound LID differs from the one or more media storage locations addresses bound to the LID. The allocation reply module communicates a reply to the requesting device and the method ends.

The physical capacity allocation module determines the amount of available physical storage capacity on the data storage device where the amount of available physical storage capacity includes a physical storage capacity of unbound storage locations in the data storage device. The physical capacity reply module communicates a reply to the requesting device in response to the physical capacity allocation module determining the amount of available physical storage capacity on the data storage device and the method ends.

The physical space reservation module determines if the data storage device has available physical storage capacity to satisfy the physical storage space request. If the physical space reservation module determines that the data storage device has available physical storage capacity to satisfy the physical storage space request the physical space reservation module reserves physical storage capacity adequate to service the physical space reservation request and the physical space reservation return module transmits to the requesting storage client an indication that the requested physical storage space is reserved.

The physical allocation module maintains enough available physical storage capacity to maintain the reservation of physical storage capacity until the reservation is used by storing data associated with the reservation or until the reservation is cancelled and the method ends. If the physical space reservation module determines that the data storage device does not have available physical storage capacity to satisfy the physical storage space request the physical space reservation return module transmits to the requesting storage client an indication that the requested physical storage space is not reserved or an indication of insufficient capacity and the method ends.

The LID binding module binds one or more unbound LIDs to the data. The storage controller stores the data on the storage device and the mapping module maps one or more media storage locations addresses where the data was stored to the corresponding LIDs e.g. binds the LIDs to the media storage locations in one or more entries A N in the index . Where data is stored sequentially on the storage device media storage locations where the data is stored may not be known prior to the write request but are determined after or just prior to storing the data. The LID binding module communicates the bound LIDs to the storage client and the method ends. The communication could be part of a confirmation that the data is stored successfully.

The storage controller receives a write request to write data to a storage device in the storage controller where the data is already associated with bound LIDs. In other embodiments the write request is to store the data on more than one storage device in the storage system such as would be the case if the storage devices are RAIDed or if the data is written to a primary storage device and to a mirror storage device . The storage controller stores the data on the storage device and the mapping module maps one or more media storage locations where the data is stored to the bound LIDs e.g. updates the binding between the LIDs and media storage locations in the index . The storage controller or other component in the storage controller communicates a write confirmation to the storage client and the method ends.

The storage entries may further comprise and or reference metadata which may comprise metadata pertaining to the LIDs such as age size LID attributes e.g. client identifier data identifier file name group identifier and so on. Since the metadata is associated with the storage entries which are indexed by LID e.g. address the metadata may remain associated with the storage entry regardless of changes to the location of the underlying storage locations on the non volatile storage device e.g. changes to the storage locations .

The index may be used to efficiently determine whether the non volatile storage device comprises a storage entry referenced in a client request and or to identify a storage location of data on the device . For example the non volatile storage device may receive a client request to allocate a particular LID. The request may specify a particular LID a LID and a length or offset e.g. request 3 units of data starting from LID a set of LIDs or the like. Alternatively or in addition the client request may comprise a set of LIDs LID ranges continuous or discontinuous or the like.

The non volatile storage device may determine whether a storage entry corresponding to the requested LIDs is in the index using a search operation. If a storage entry comprising the requested LIDs is found in the index the LID s associated with the request may be identified as being allocated and bound. Accordingly data corresponding to the LID s may be stored on the non volatile storage device . If the LID s are not found in the index the LID s may be identified as unbound but may be allocated . Since the storage entries may represent sets of LIDS and or LID ranges a client request may result in partial allocation. For example a request to allocate may successfully allocate LIDs to but may fail to allocate and since these are included in the storage entry . In the event of a partial allocation the entire allocation request may fail the available LIDs may be allocated and other LIDs may be substituted for the failed LIDs or the like.

In the example depicted in the storage entry corresponding to the storage request is in the index storage entry and as such the LIDs associated with the request are identified as allocated and bound. Therefore if the client request is to read data at the specified LIDs data may be read from the storage locations identified in the storage entry and returned to the originator or the request. If the client request is to allocate the identified LIDs the allocation request may fail and or substitute LIDs may be allocated as described above .

When new storage entries are added to the index a merge operation may occur. In a merge operation an existing storage entry may be merged with one or more other storage entries. For instance a new storage entry for LIDs may be merged with entry . The merge may comprise modifying the LID of the storage entry to include the new addresses e.g. and or to reference the storage locations to include the storage location on which the data was stored.

Although the storage entries in the index are shown as comprising references to storage locations e.g. addresses the disclosure is not limited in this regard. In other embodiments the storage entries comprise reference or indirect links to the storage locations. For example the storage entries may include a storage location identifier or reference to the reverse map .

As discussed above the reverse map may comprise metadata which may include metadata pertaining to sequential storage operations performed on the storage locations such as sequence indicators e.g. timestamp to indicate a ordered sequence of storage operations performed on the storage device e.g. as well as an age of the storage locations and so on . The metadata may further include metadata pertaining to the storage media such as wear level reliability error rate disturb status and so on. The metadata may be used to identify unreliable and or unusable storage locations which may reduce the physical storage capacity of the non volatile storage device .

The reverse map may be organized according to storage divisions e.g. erase blocks of the non volatile storage device . In this example the entry that corresponds to storage entry is located in erase block n . Erase block n is preceded by erase block n 1 and followed by erase block n 1 the contents of erase blocks n 1 and n 1 are not shown . An erase block may comprise a predetermined number of storage locations. An erase block may refer to an area in the non volatile storage device that is erased together in a storage recovery operation.

The validity indicator may be used to selectively invalidate data. Data marked as invalid in the reverse index may correspond to obsolete versions of data e.g. data that has been overwritten and or modified in a subsequent storage operation . Similarly data that does not have a corresponding entry in the index may be marked as invalid e.g. data that is no longer being referenced by a storage client . Therefore as used herein invalidating data may comprise marking the data as invalid in the storage metadata which may include removing a reference to the media storage location in the index and or marking a validity indicator of the data in the reverse map.

In some embodiments the groomer module described above uses the validity indicators to identify storage divisions e.g. erase blocks for recovery. When recovering or reclaiming an erase block the erase block may be erased and valid data thereon if any may be relocated to new storage locations on the non volatile storage media. The groomer module may identify the data to relocate using the validity indicator s . That is invalid may not be relocated may be deleted whereas data that is still valid e.g. still being referenced within the index may be relocated. After the relocation the groomer module or other process may update the index to reference the new media storage location s of the valid data. Accordingly marking data as invalid in the storage metadata may cause data to be removed from the non volatile storage media . The removal of the data however may not occur immediately when the data is marked invalid but may occur in response to a grooming operation or other processes that is outside of the path for servicing storage operations and or requests. Moreover when relocating data the groomer module may be configured to determine whether the contextual format of the data should be updated by referencing the storage metadata e.g. the reverse map and or index .

The validity metadata may be used to determine an available physical storage capacity of the non volatile storage device e.g. a difference between physical capacity or budgeted capacity and the storage locations comprising valid data . The reverse map may be arranged by storage division e.g. erase blocks or erase region to enable efficient traversal of the physical storage space e.g. to perform grooming operations determine physical storage capacity and so on . Accordingly in some embodiments the available physical capacity may be determined by traversing the storage locations and or erase blocks in the reverse map to identify the available physical storage capacity and or is being used to store valid data .

Alternatively or in addition the reverse map or other datastructure may comprise an indicator to track the available physical capacity of the non volatile storage device . The available physical capacity indicator may be initialized to the physical storage capacity or budgeted capacity of the non volatile storage device and may be updated as storage operations are performed. The storage operations resulting in an update to the available physical storage capacity indicator may include but are not limited to storing data on the storage device reserving physical capacity on the storage device canceling a physical capacity reservation storing data associated with a reservation where the size of the stored data differs from the reservation detecting unreliable and or unusable storage locations and or storage division e.g. taking storage locations out of service and so on.

In some embodiments the metadata and or may be configured to reflect reservations of physical storage capacity. As described above in conjunction with a storage client may reserve physical storage capacity for an operation that is to take place over time. Without a reservation the storage client may begin the operation but other clients may exhaust the physical capacity before the operation is complete. In some embodiments the storage client issues a request to reserve physical capacity before beginning the storage operation. The storage controller updates storage metadata e.g. the indexes and or the indicate that the requested portion has been reserved. The reserved portion may not be associated with any particular media storage locations rather the reservation may indicate that the storage controller is to maintain at least enough physical storage capacity to satisfy the reservation. For example the indicator of remaining physical storage capacity may be reduced by the amount of reserved physical storage capacity. Requests subsequent to the reservation may be denied if satisfying the requests would exhaust the remaining physical storage capacity in the updated indicator . In some embodiments a reservation of physical storage capacity may be valid for a pre determined time until released by the storage client until another higher priority request is received or the like. The reservation may expire once the storage client that reserved the physical capacity users the reserved physical storage capacity in subsequent storage operations. If the storage operations occur over a series of storage operations as opposed to a single operation the reservation may be incrementally reduced accordingly.

The index may be used to determine an available logical capacity of the logical address space e.g. by traversing the index . The available logical capacity may consider LIDs that are bound using the storage entries as well as LIDs that are allocated but not yet bound using the allocation entries such as .

As shown in in some embodiments the allocation entries may be maintained in the index with the storage entries. Alternatively allocation entries may be maintained in a separate index or other datastructure . When an allocation entry becomes associated with data on the non volatile storage device e.g. as associated with storage locations the allocation entry may be modified and or replaced by a storage entry.

In some embodiments the index or index may comprise an indicator to track the available logical capacity of the logical address space . The available logical capacity may be initialized according to the logical address space presented by the storage device . Changes to the index may cause the available logical capacity indicator to be updated. The changes may include but are not limited to addition of new allocation entries removal of allocation entries addition of storage entries removal of allocation entries or the like.

At step a non volatile storage device may be initialized for use. The initialization may comprise allocating resources for the non volatile storage device e.g. solid state storage device such as communications interfaces e.g. bus network and so on allocating volatile memory accessing solid state storage media and so on. The initialization may further comprise presenting a logical address space to storage clients initializing one or more indexes e.g. the indexes described above in conjunction with and so on.

At step the non volatile storage device may present a logical space to one or more clients. Step may comprise implementing and or providing an interface e.g. API accessible to one or more clients or the like.

At step the non volatile storage device may maintain metadata pertaining to logical allocation operations performed by the method . The logical allocation operations may pertain to operations in the logical address space presented at step and may include but are not limited to allocating logical capacity binding logical capacity to media storage locations and so on. The metadata may include but is not limited to indexes associating LIDs in the logical address space with media storage locations on the non volatile storage device indexes associating storage locations with LIDs e.g. index of allocation entries indicating allocated LIDs having no associated storage location e.g. index of an unallocated index e.g. index of maintaining an indicator of unallocated logical capacity e.g. indicator of and so on.

At step a client request pertaining to a LID in the logical address space may be received. The client request may comprise a query to determine if a particular LID and or logical capacity can be allocated a request to allocate a LID and or logical capacity a request to store data on the non volatile storage device or the like.

At step the metadata maintained at step may be referenced to determine whether the client request can be satisfied. Step may comprise referencing the metadata e.g. indexes and or indicators maintained at step to determine an available logical capacity of the logical address space and or to identify available LIDs or LID range as described above.

At step the method may provide a response to the client request which if the request cannot be satisfied may comprise providing a response to indicate such. If the client request can be satisfied the providing the response may comprise one or more of an indicator that the allocation can be satisfied allocating LIDs satisfying the request providing allocated LIDs satisfying the request providing one or more requested LIDs and or one or more additional LIDs e.g. if a portion of a requested set of LIDs can be allocated or the like.

Following step the flow may return to step where the method may update the metadata e.g. indexes indicators and so on according to the allocation operation if any performed at step .

At steps and the method may be initialized present a logical storage space to one or more clients and or maintain metadata pertaining to logical operations performed by the method .

At step the method may maintain metadata pertaining to physical storage operations performed by the method . The storage operations may include but are not limited to reserving physical storage capacity canceling physical storage capacity reservations storing data on the non volatile storage device deallocating physical storage capacity grooming operations e.g. garbage collection error handling and so on physical storage space budgeting and so on. As discussed above metadata maintained at step may include but is not limited to indexes associating LIDs in the logical address space with storage locations on the non volatile storage device indexes associating storage locations with LIDs e.g. index of allocation entries indicating allocated LIDs having no associated storage location e.g. index of an unallocated index e.g. index of maintaining an indicator of unallocated logical address space e.g. indicator of and so on.

At step a client request pertaining to physical storage capacity of the non volatile storage device may be received. The client request may comprise a query to determine of a physical storage capacity is available a request to reserve physical storage capacity a request to store data a request to deallocate data e.g. TRIM or the like.

At step the metadata maintained at steps and or may be referenced to determine whether the client request can be satisfied. Step may comprise referencing the metadata at steps and or to determine an available physical storage capacity of the non volatile storage device and or to identify storage locations associated with particular LIDs e.g. in a deallocation request or TRIM as described above.

At step the method may provide a response to the client request which if the request cannot be satisfied may comprise providing a response to indicate such. If the client request can be satisfied the providing the response may comprise one or more of indicating that the client request can and or was satisfied reserving physical storage capacity for the client cancelling a physical storage capacity reservation storing data on the non volatile storage device deallocating physical storage capacity or the like.

Referring back to the storage controller and or storage layer may simplify data storage operations for storage clients . As described above the storage controller may be configured to maintain allocations of the logical address space and or bindings between LIDs and media storage locations using inter alia the storage metadata . The storage controller may be further configured to store data in contextual format which describes the context e.g. logical interface of the data independent of the storage metadata . Moreover the storage controller may store data in a sequential log such that a sequence of storage operations performed on the non volatile storage device can be replayed and or the storage metadata may be reconstructed based upon the contents of the non volatile storage media . In some embodiments the storage controller may maintain a large thinly provisioned logical address space which may simplify LID management for the storage clients e.g. allow the storage clients to operate within large contiguous LID ranges with low probability of LID collisions . The storage controller may be further configured to deter the reservation of media storage locations until needed to prevent premature exhaustion or over reservation of physical storage resources.

The storage controller may expose access to the logical address space and or storage metadata to the storage clients through the storage layer interface or other interface . The storage clients may leverage the storage layer interface to delegate certain functions to the storage controller . Storage clients may leverage the storage layer interface to perform various operations including but not limited to logical address space management media storage location management e.g. mappings between logical identifiers and media storage locations such as thin provisioning deferred physical resource reservation crash recovery logging backup e.g. snap shots crash recovery data integrity transactions data move operations cloning deduplication and so on.

In some embodiments storage clients may leverage the contextual log format to delegate crash recovery and or data integrity functionality to the storage controller through the storage layer and or storage layer interface . For example after an invalid shutdown and reconstruction operation the storage controller may expose the reconstructed storage metadata to storage clients via the storage layer interface or other interface . The storage clients may therefore delegate crash recovery and or data integrity to the storage controller . For instance a file system storage client may require crash recovery and or data integrity services for some of its metadata such as I node tables file allocation tables and so on. The storage client may have to implement these services itself which may impose significant overhead and or complexity on the storage client . The storage client may be relieved from this overhead by delegating crash recovery and or data integrity to the storage controller as described above.

In some embodiments storage clients may also delegate allocations in the logical address space and or physical storage reservations to the storage layer . For example a storage client such as a file system may maintain its own metadata to track logical and physical allocations for files the storage client may maintain a set of logical addresses that mirrors the media storage locations of the non volatile storage device . If the underlying storage device provides a one to one mapping between logical block address and media storage locations as with conventional storage devices the block storage layer performs appropriate LBA to media address translations and implements the requested storage operations. If however the underlying non volatile storage device does not support one to one mappings e.g. the underlying storage device is a sequential or write out of place device such as a solid state storage device another redundant set of translations are needed e.g. a Flash Translation Layer or other mapping . The redundant set of translations and the requirement that the storage client maintain logical address allocations may represent a significant overhead and may make allocating contiguous LBA ranges difficult or impossible without time consuming defragmentation operations. The storage client delegate allocation functionality to the storage controller via the storage layer interface . The storage client may access the storage layer interface to request logical ranges in the logical address space . The storage controller manages the allocation logical capacity and or physical storage resources as described above. The storage controller may leverage a thinly provisioned logical address space to enable large contiguous LID ranges for the storage client without the need for redundant translations address layers. Moreover the storage client may identify unallocated LIDs through the storage layer interface which frees the storage client from this overhead.

The entries in the index may include LIDs that are allocated but that are not associated with media storage locations on a non volatile storage device. Like the index described above inclusion in the index may indicate that a LID is both allocated and associated with valid data on the non volatile storage device . Alternatively the index may be implemented similarly to the index of . In this case the index may comprise entries that are associated with valid data on the non volatile storage device along with entries that are allocated but are not associated with stored data. The entries that are associated with valid data may identify the media storage location of the data as described above. Entries that are not associated with valid stored data e.g. allocation entries such as the entry of may have a NULL media storage location indicator or some other suitable indicator.

In some embodiments the index may comprise security related metadata such as access control metadata or the like. The security related metadata may be associated with each respective entry e.g. entry in the index . When storage requests pertaining to a particular LID are received by the storage layer the storage layer may access and or enforce the security related metadata if any in the corresponding entry. In some embodiments the storage layer delegates enforcement of security related policy enforcement to another device or service such as an operating system access control system or the like. Accordingly when implementing storage operations the storage layer may access security related metadata and verify that the requester is authorized to perform the operating using a delegate. If the delegate indicates that the requester is authorized the storage layer implements the requested storage operations if not the storage layer returns a failure condition.

The storage layer may access the storage metadata such as the index to allocate LIDs in the logical address space to determine a remaining logical capacity of the logical address space to determine the remaining physical storage capacity of the non volatile storage device s and so on. The storage layer may respond to queries for the remaining logical capacity remaining physical storage capacity and the like via the storage layer interface . Similarly the storage layer may service requests to reserve physical storage capacity on the non volatile storage device . As described above a storage client may wish to perform a sequence of storage operations that occur over time e.g. receive a data stream perform a DMA transfer or the like . The storage client may reserve sufficient logical and or physical storage capacity to perform the sequence of storage operations up front to ensure that the operations can be completed. Reserving logical capacity may comprise allocating LIDs through the storage layer using the storage layer interface . Physical capacity may be similarly allocated. The storage client may request to reserve physical capacity through the storage layer interface . If a sufficient amount of physical capacity is available the storage layer acknowledges the request and updates the storage metadata accordingly and as described above in conjunction with .

The storage layer and or storage metadata is not limited to the particular exemplary datastructures described above. The storage metadata may comprise any suitable datastructure or datastructure combination for efficiently tracking logical address space allocations and or associations between LIDs and media storage locations. For example the index may be adapted such that entries in the index comprise and or are linked to respective physical binding metadata. The physical binding metadata may comprise a sub index of associations between LIDs in a particular allocated range and corresponding media storage locations on the non volatile storage medium. Each sub range within the allocated LID comprises an entry associating the sub range with a corresponding media storage location if any .

In some embodiments the storage layer is configured to segment the LIDs in the logical address space into two or more portions. As shown in a LID is segmented into a first portion and a second portion . In some embodiments the first portion comprises high order bits of the LID and the second portion comprises low order bits. However the disclosure is not limited in this regard and could segment LIDs using any suitable segmentation scheme.

The first portion may serve as a reference or identifier for a storage entity. The second portion may represent an offset into the storage entity. For example the storage layer may reference the logical address space comprising 64 bit LIDs the logical address space may comprise 2 64 unique LIDs . The storage layer may partition the LIDs into a first portion comprising the high order 32 bits of the 64 bit LID and a second portion comprising the low order 32 bits of the LID. The resulting logical address space may be capable of representing 2 32 1 unique storage entities e.g. using the first portion of the LIDs each having a maximum size or offset of 2 32 virtual storage locations e.g. 2 TB for a virtual storage location size of 512 bytes . The disclosure is not limited in this regard however and could be adapted to use any suitable segmentation scheme. For example in implementations that require a large number of small storage entities e.g. database applications messaging applications or the like the first portion may comprise a larger proportion of the LID. For instance the first portion may comprise 42 bits providing 2 42 1 unique identifiers and the second portion may comprise 22 bits providing a maximum offset of 4 GB . Alternatively where larger files are required the segmentation scheme may be similarly modified. Furthermore the storage layer may present larger logical address spaces e.g. 128 bits and so on in accordance with the requirements of the storage clients configuration of the computing device and or configuration of the non volatile storage device . In some embodiments the storage layer segments the logical address space in response to a request from a storage client or other entity.

The storage layer may allocate LIDs based on the first portion . For example in a 64 bit address space when the storage layer allocates a LID comprising a first portion 0000 0000 0000 0000 0000 0000 0000 0100 e.g. first portion logical address 4 the storage layer is effectively allocating a logical address range comprising 2 32 unique LIDs 4 294 967 296 unique LIDS ranging from 0000 0000 0000 0000 0000 0000 0000 0100 0000 0000 0000 0000 0000 0000 0000 0000 to 0000 0000 0000 0000 0000 0000 0000 0100 1111 1111 1111 1111 1111 1111 1111 1111 

In some embodiments the storage layer uses the segmentation of the LIDs to simplify the storage metadata . In one example the number of bits in the first portion is X and the number of bits in the second portion is Y. The storage layer may determine that the maximum number of uniquely LID that can be uniquely allocated is 2 X and that the allocated LIDs can be referenced using only the first portion of the LID e.g. the set of X bits . Therefore the storage layer may simplify the storage metadata index to use entries comprising only the first portion of a LID. Moreover the storage layer may determine that the LIDs are allocated in fixed sized ranges of 2 Y. Accordingly each entry in the storage metadata e.g. index may be of the same extent. Therefore the range portion of the metadata entries may be omitted.

Each entry in the index may be uniquely identified using the first portion eight bits of a LID. Accordingly the entries may be indexed using only the first portion e.g. 8 bits . This simplification may reduce the amount of data required to identify an entry from 64 bits to 8 bits assuming a 64 bit LID with an 8 bit first portion . Moreover the LIDs may be allocated in fixed sized logical ranges e.g. in accordance with the second portion . Therefore each entry may represent the same range of allocated LIDs. As such the entries may omit explicit range identifiers which may save an additional 64 bits per entry .

The storage layer may use the simplified index to maintain LID allocations in the logical address space and or identify LIDs to allocate in response to requests from storage clients . In some embodiments the storage layer maintains a listing of first portions that are unallocated. Since in some embodiments allocations occur in a pre determined way e.g. using only the first portion and within a fixed range the unallocated LIDs may be expressed in a simple list or map as opposed to an index or other datastructure. As LIDs are allocated they are removed from the datastructure and are replaced when they are deallocated.

Associations between portions of the entry and valid data on the non volatile storage device may be maintained in the index using physical binding metadata as described above . depicts an example of physical binding metadata for use in a segmented logical addressing scheme. For clarity in the example LIDs are segmented such that the first portion comprises 56 bits and the second portion comprises 8 bits the reverse of . The entry is identified using the first portion 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0111 1010. The entries of the index may be simplified to reference only offsets within the entry e.g. within the second portion which comprises 8 bits in the example . Moreover the head entry may omit the top end of the second portion e.g. may omit 1111 1111 since it can be determined that the top most entry will necessarily include the maximal extent of the range defined by the second portion . Similarly the tail entry may omit the bottom end of the second portion e.g. may omit 0000 000 since it can be determined that the bottom most entry will necessarily include the beginning of the range defined by the second portion . Each entry associates a range within the second portion with valid data on the non volatile storage device if any as described above.

As described above storage clients may delegate LID allocation to the storage layer using the storage layer interface . The delegation may occur in a number of different ways. For example a storage client may query the storage layer via the storage layer interface for any available LID. If a LID is available the storage layer returns an allocated LID to the storage client . Alternatively the storage client may request a particular LID for allocation. The request may comprise the first portion of the LID or an entire LID with an offset . The storage layer may determine if the LID is unallocated and if so may allocate the LID for the client and return an acknowledgement. If the LID is allocated or the LID falls within an allocated range the storage layer may allocate an alternative LID and or may return an error condition. The storage layer may indicate whether particular LIDs are allocated and or whether particular LIDs are bound to media storage locations on the non volatile storage device . The queries may be serviced via the storage layer interface .

In embodiments in which the storage layer implements segmented LIDs the storage layer may expose the segmentation scheme to the storage clients . For example storage clients may query the storage layer to determine the segmentation scheme currently in use. The storage clients may also configure the storage layer to use a particular LID segmentation scheme adapted to the needs of the storage client .

The storage layer may allocate LIDs using only the first portion of a LID. If the LID is unallocated the storage layer acknowledges the request and the storage client is allocated a range of LIDs in the logical address space corresponding to the first portion and comprising the range defined by the second portion . Similarly when allocating a nameless LID e.g. any available LID selected by the storage layer the storage layer may return only the first portion of the allocated LID. In some embodiments when a client requests a LID using the first portion and the second portion the storage layer extracts the first portion from the requested LID and allocates a LID corresponding to the first portion to the client if possible . Advantageously the disclosed embodiments support such a large number of addresses for the second portion over such a high number of contiguous addresses that storage requests that cross a LID boundary are anticipated to be very rare. In certain embodiments the storage layer may even prevent allocations that cross LID boundaries as used herein a LID boundary is between two contiguous LIDs the first being the last addressable LID in a second portion of a LID and the second being the first addressable LID in a next successive first portion of a LID . If the request crosses a boundary between pre determined LID ranges the storage layer may return an alternative LID range that is properly aligned to the LID segmentation scheme return an error or the like. In other embodiments if the request crosses a boundary between pre determined LID ranges the storage layer may allocate both LIDs if available .

As described above the storage layer may be leveraged by the storage clients for logical allocations physical storage bindings physical storage reservations crash recovery data integrity and the like. is a block diagram depicting a file system storage client leveraging the storage layer to perform file system operations.

The file system storage client application accesses the storage layer via the storage layer interface to allocate LIDs for storage entities such as file system objects e.g. files . In some embodiments when a new file is created the file system storage client queries the storage layer for a LID. The allocation request may be implemented as described above. If the requested LIDs can be allocated the storage layer returns an allocated LID to the file system storage client . The LID may be returned as a LID and an offset indicating an initial size for the file a LID range a first portion of a LID or the like. The example shows the storage layer implementing a segmented LID range and as such the storage layer may return the first portion of a LID in response to an allocation request.

In some embodiments the storage client may implement a fast and efficient mapping between LIDs and storage entities. For example when the first portion of the LID is sufficiently large the file system storage client may hash file names into LID identifiers into hash codes of the same length as the first portion of the LID . When a new file is created the file system storage client hashes the file name to generate the first portion of the LID and issues a request to the storage layer to allocate the LID. If the LID is unallocated e.g. no hash collisions have occurred the storage layer may grant the request. The file system storage client may not need to maintain an entry in the file system table for the new file or may only be required to maintain an abbreviated version of a table entry since the LID can be derived from the file name. If a name collision occurs the storage layer may return an alternative LID which may be derived from the hash code or file name which may obviate the need for the file system table to maintain the entire identifier.

The file system storage client may maintain a file system table to associate file system objects e.g. files with corresponding LIDs in the logical address space of the storage layer . In some embodiments the file system table is persisted on the non volatile storage device at a pre determined LID. Accordingly the file system storage client may delegate crash recovery and or data integrity for the file system table as well as the file system objects themselves to the storage layer .

The file system storage client may reference files using the file system table . To perform storage operations on a particular file the file system storage application may access a file system entry corresponding to the file e.g. using a file name lookup or another identifier such as an I node or the like . The entry comprises a LID of the file which in the example is a first portion of a LID . The file system storage client performs storage operations using the first portion of the LID along with an offset the second portion . The file system storage client may combine the file identifier first portion with an offset to generate a full LID . The LID may be sent to the storage layer in connection with requests to perform storage operations within the logical address space .

The storage layer performs storage operations using the storage metadata . Storage requests to persist data in the logical address space comprise the storage layer causing the data to be stored on the non volatile storage device in a contextual log based format log based format as described above. The storage layer updates the storage metadata to associate LIDs in the logical address space with media storage locations on the non volatile storage comprising data stored in the storage operation.

Storage operations to access persisted data on the non volatile storage device may comprise the storage client such as the file system storage client requesting the data associated with one or more LIDs in the logical address space. The file system storage client may identify the LIDs using the file system table or another datastructure. In response to the request the storage layer determines the media storage location of the LIDs on the non volatile storage device using the storage metadata which is used to access the data.

In some embodiments storage clients such as the file system storage client may deallocate a storage entity. Deallocating a storage entity may comprise issuing a deallocation request to the storage layer via the storage layer interface . In response to a deallocation request the storage layer removes the deallocated LIDs from the storage metadata and or may mark the deallocated LIDs as unallocated. The storage layer may also invalidate the media storage locations corresponding to the deallocated LIDs in the storage metadata and or the non volatile storage device e.g. using a reverse map as described above . A deallocation may be a hint to a groomer of the non volatile storage device that the media storage locations associated with the deallocated LIDs are available for recovery.

The groomer however may not actually remove the data for some time after the deallocation request issued. Accordingly in some embodiments the storage layer interface may provide an interface through which storage clients may issue a deallocation directive as opposed to a hint . The deallocation directive may configure the storage layer to return a pre determined value e.g. 0 or NULL for subsequent accesses to the deallocated LIDs or the media storage locations associated therewith even if the data is still available on the non volatile storage device . The pre determined value may continue to be returned until the LIDs are reallocated for another purpose.

In some embodiments the storage layer implements a deallocation directive by removing the deallocated LIDs from the storage metadata and returning a pre determined value in response to requests for LIDs that are not allocated in the storage metadata and or are not bound e.g. are not associated with valid data on the non volatile storage device . Alternatively or in addition in response to a deallocation directive the storage layer may cause the corresponding media storage locations on the non volatile storage device to be erased. The storage layer may provide the storage client with an acknowledgement when the erasure is complete. Since erasures make take a significant amount of time to complete relative to other storage operations the acknowledgement may be issued asynchronously.

In some embodiments the name to LID metadata may be included with the storage metadata . For example entries in the index of may be indexed by name in addition to or in place of a logical identifier. The storage layer may persist the name to LID metadata on the non volatile storage device such that the integrity of the metadata is maintained despite invalid shutdown conditions. Alternatively or in addition the name to LID metadata may be reconstructed using the contextual log based data format on the non volatile storage device .

At step the method presents a logical address space for the non volatile device to storage clients. The logical address space may be defined independently of the non volatile storage device. Accordingly the logical capacity of the logical address space e.g. the size of the logical address space and or the size of the virtual storage blocks thereof may exceed the physical storage capacity of the non volatile storage device. In some embodiments the logical address space is presented via an application programming interface API that is accessible to storage clients such as operating systems file systems database applications and the like.

At step storage metadata is maintained. The storage metadata may track allocations of LIDs within the logical address space as well as bindings between LIDs and media storage locations of the non volatile storage device. The metadata may further comprise indications of the remaining logical capacity of the logical address space the remaining physical storage capacity of the non volatile storage device the status of particular LIDs and so on.

In some embodiments the metadata is maintained in response to storage operations performed within the logical address space. The storage metadata is updated to reflect allocations of LIDs by storage clients. When storage clients persist data to allocated LIDs bindings between the LIDs and the media storage locations comprising the data are updated.

At step storage operations are performed using an log based sequence. As described above the storage layer and non volatile storage device may be configured to store data in a log based format such that an ordered sequence of storage operations performed on the storage device can be reconstructed in the event of an invalid shutdown or other loss of storage metadata . The ordered sequence of storage operations allows storage clients to delegate crash recovery data integrity and other functionality to the storage layer .

At step the method terminates until additional storage operations are performed at which point the flow continues at step .

At step the method segments logical identifiers of a logical address space into at least a first portion and a second portion. The segmentation of step may be performed as part of a configuration process of the storage layer and or non volatile storage device e.g. when the device is initialized . Alternatively or in addition the segmentation of step may be performed in response to a request from a storage client. The storage client may request a particular type of LID segmentation according to the storage requirements thereof. For example if the storage client has a need to store a large number of relatively small storage entities the storage client may configure the LID segmentation to dedicate a larger proportion of the LID to identification bits and a smaller proportion to offset bits. Alternatively a storage client who requires a relatively small number of very large storage entities may configure the method to implement a different type of segmentation that uses a larger proportion of the LID for offset bits allowing for larger storage entities .

At step the storage layer uses the first portion of the LID to reference storage client allocations e.g. as a reference for storage entities . Step may comprise reconfiguring the storage metadata to allocate LIDs using only the first portion of the LID e.g. the upper X bits of a LID . The size of the first portion may determine the number of unique storage entities that can be expressed in the storage metadata e.g. as 2 X 1 where X is the number of bits in the first portion . Accordingly a first portion comprising 32 bits may support approximately 2 32 unique storage entities. The reconfiguration may simplify the storage metadata since each entry may be identified using a smaller amount of data only the first portion of the LID as opposed to the entire LID .

At step the storage layer uses the second portion of the LID as an offset into a storage entity. The size of the second portion may define the maximum size of a storage entity under the current segmentation scheme . The size of a LID may be defined as the virtual block size times 2 Y where Y is the number of bits in the second portion. As discussed above a virtual block size of 512 and second portion comprise thirty two 32 bits results in a maximum storage entity size of 2 TB. Step may comprise reconfiguring the storage metadata to reference LID to media storage location bindings using only the second portion of the LID. This may allow the storage metadata entries e.g. entries in physical binding metadata to be simplified since the bindings can be expressed using a smaller number of bits.

At step the storage layer uses the LID segmentation of step to allocate LIDs comprising contiguous logical address ranges in the logical address space. Step may comprise the storage layer allocating LIDs using only the first portion of the LID e.g. the upper X bits . The allocated LID may comprise a contiguous logical address range corresponding to the number of bits in the second portion as described above.

In some embodiments allocating a LID at step does not cause corresponding logical storage locations to be reserved of bound thereto. The bindings between allocated LIDs and media storage locations may not occur until the storage client actually performs storage operations on the LIDs e.g. stores data in the LIDs . The delayed binding prevents the large contiguous LID allocations from exhausting the physical storage capacity of the non volatile storage device.

At step the flow ends until a next storage operation is requested at which point the flow continues at step .

At step the storage layer presents a logical address space and at step metadata is maintained to associate LIDs in the logical address space with media storage locations on the non volatile storage device.

At step the storage layer causes data to be stored on the non volatile storage device in a contextual log based format. As described above the contextual log based formatting of the data is configured such that in the event of an invalid shutdown the data and metadata pertaining thereto can be reconstructed.

At step the storage layer reconstructs data stored on the non volatile storage device using the data formatted in the contextual log based format. As described above the log based format may comprise storing LID identifiers with data on the non volatile storage device. The LID identifiers may be used to associate the data with LIDs in the logical address space e.g. reconstruct the storage metadata . Sequence indicators stored with the data on the non volatile storage device are used to determine the most current version of data associated with the same LID since data is written out of place updated data may be stored on the non volatile storage device along with previous obsolete versions. The sequence indicators allow the storage layer to distinguish older versions from the current version. The reconstruction of step may comprise reconstructing the storage metadata determining the most current version of data for a particular LID e.g. identifying the media storage location that comprises the current version of the data and so on.

At step the storage layer provides access to the reconstructed data to storage clients. Accordingly the storage clients may delegate crash recovery and or data integrity functionality to the storage layer which relieves the storage clients from implementing these features themselves. Accordingly the storage clients can be simpler and more efficient.

At step the flow ends until subsequent storage operations are performed at which point the flow continues at step .

At step the storage layer receives a request pertaining to the status of a particular LID in the logical address space presented by the storage layer . Alternatively the query may pertain to the logical address space as a whole e.g. a query for the remaining logical capacity of the logical address space or the like . Similarly the query may pertain to the physical storage capacity of the non volatile storage device such as a query regarding the physical storage capacity that is bound to LIDs in the logical address space e.g. currently occupied available physical storage capacity and so on.

At step the storage layer accesses storage metadata to determine the status of the requested LID logical capacity physical storage capacity or the like. The access may comprise identifying an entry for the LID in a logical to physical map in an allocation index or the like. If the particular LID falls within an entry in an allocation index and or logical to physical index the storage layer may determine that the LID is allocated and or may determine whether the LID is bound to a media storage location. The access may further comprise traversing a metadata index to identify unallocated LIDs unused media storage locations and so on. The traversal may further comprise identifying allocated or unallocated LIDs to determine current LID allocation or unallocated LID capacity to determine bound physical storage capacity determine remaining physical storage capacity or the like.

At step the storage layer returns the status determined at step to the storage client and the flow end at step until a next query is received at which point the flow continues at step .

At step the storage layer receives a request pertaining to the status of a particular media storage location on a non volatile storage device. The media storage location may be associated with a LID in the logical address space presented by the storage layer . Alternatively the query may be iterative and may pertain to all media storage locations on the non volatile storage device e.g. a query regarding the status of all media storage locations on the device . Similarly the query may pertain to the physical storage capacity of the non volatile storage device such as a query regarding the physical storage capacity that is bound to LIDs in the logical address space e.g. currently occupied available physical storage capacity and so on.

The query of step may be useful in various different contexts. For example in a RAID rebuild operation a second non volatile storage device may be configured to mirror the contents of a first non volatile storage device. The data stored on the first logical storage device may be stored sequentially e.g. in a contextual log based format . As such the first non volatile storage device may comprise invalid data e.g. data was deleted was made obsolete by a sequent storage operation etc. . The query of step may be issued by the second non volatile storage device to determine which media storage locations on the first non volatile storage device exist e.g. are valid and should be mirrored on the second non volatile storage device. Accordingly the query of step may be issued in the form of an iterator configured to iterate over e.g. discover all media storage locations that comprise valid data and the extent of the valid data.

Step comprises accessing storage metadata such as the index or reverse map described above in conjunction with to determine whether the specified media storage location comprises valid data and or to determine the extent or range of valid data in the specified media storage location.

At step the storage layer returns the status determined at step to the requester and the flow end at step until a next query is received at which point the flow continues at step .

In some embodiments methods and are used to implement conditional storage operations. As used herein a conditional storage operation refers to a storage operation that is to occur if one or more conditions are met. A conditional write may comprise a storage client requesting that data be written to a particular set of LIDs. The storage layer may implement the conditional write if the specified LIDs do not exist e.g. are not already allocated to another storage client and the non volatile storage comprises sufficient physical storage capacity to satisfy the request. Similarly a conditional read may comprise a storage client requesting data from a particular set of LIDs. The storage layer may implement the conditional read if the specified LIDs exist and are bound to valid data e.g. are in storage metadata maintained by the storage layer and are bound to media storage locations . In other examples the storage layer provides for nameless reads and writes in which a storage client presents identifier and the storage layer determines the LIDs associated with the identifier and services the storage request accordingly e.g. nameless writes as described above . In this case the storage layer offloads management of identifier to LID mappings for the storage client.

In some embodiments the storage metadata maintained by the storage layer may provide for designating certain portions of the logical address space as being temporary or ephemeral. As used herein an ephemeral address range is an address range that is set to be automatically deleted under certain conditions. The conditions may include but are not limited to a restart operation a shutdown event planned or unplanned expiration of a pre determined time resource exhaustion etc.

Data may be identified as ephemeral in storage metadata maintained by the storage layer in metadata persisted to the solid state storage media or the like. Referring back to an entry in the index forward map may be identified as ephemeral in the metadata thereof. When the storage layer persists the index as part of a shutdown restart or other operation entries that include an ephemeral indicator may be omitted effectively invalidating the corresponding data. Alternatively or in addition the storage layer may designate an a portion of the large logical address space as comprising ephemeral data. Any entries in the ephemeral address range may be designated as ephemeral in the index without additional modifications to entry metadata.

In some embodiments an ephemeral indicator may be included in a media storage location on the non volatile storage media. depicts one example of a contextual data format e.g. packet format which may be used to store a data segment on a non volatile storage media. As described above in some embodiments packets may be subject to further processing before being persisted on a media storage location e.g. packets may be encoded into ECC codewords by an ECC generator as described above .

The packet format may comprise persistent contextual metadata which may include logical interface metadata as described above. The packet format may comprise and or be associated with a sequence indicator which may include but is not limited to a sequence number timestamp or other suitable sequence indicator. The sequence indicator may be included in the persistent contextual metadata e.g. as another field not shown . Alternatively or in addition a sequence indicator may be stored elsewhere on the non volatile storage media . For example a sequence indicator may be stored on a page or virtual page basis on an erase block basis or the like. As described above each logical erase block may be marked with a respective marking and packets may be stored sequentially therein. Accordingly the sequential order of packets may be determined by a combination of the logical erase block sequence indicators e.g. indicators and the sequence of packets within each logical erase block.

The storage layer may be configured to reconstruct the storage metadata e.g. index etc. using the contextual log based formatted data stored on the non volatile storage media . Reconstruction may comprise the storage layer or another process reading packets formatted in the contextual log based format from media storage locations of the solid state storage media . As each packet is read a corresponding entry in the storage metadata e.g. the indexes described above may be created. The LID range associated with the entry is derived from the LID in the header of the packet. The sequence indicator associated with the data packet may be used to determine the most up to date version of data for a particular LID. As described above the storage layer may write data out of place due to inter alia wear leveling write amplification and other considerations. Accordingly data intended to overwrite an existing LID may be written to a different media storage location than the original data. The overwritten data is invalidated as described above this data however remains on the solid state storage media until the erase block comprising the data is groomed e.g. reclaimed and erased . The sequence identifier may be used to determine which of two or more contextual log based packets corresponding to the same LID comprises the current valid version of the data.

In some embodiments and as illustrated in the header includes an ephemeral indicator . When reconstructing the storage metadata the ephemeral indicator may be used to identify data that should be invalidated e.g. deleted . Invalidating ephemeral data may comprise omitting the LIDs referenced in the logical interface of the packet marking the data segment as invalid in a reverse index and so on. Similarly if data marked as ephemeral is more up to date than other data per the sequence indicator the original older data may be retained and the ephemeral data may be ignored.

The storage layer may provide an API through which storage clients may designate certain LID ranges or other identifiers as being ephemeral. Alternatively or in addition the storage layer may implement higher level interfaces using ephemeral data. For example a multi step atomic write e.g. multi block atomic write may be implemented by issuing multiple write requests each of which designates the data as being ephemeral. When all of the writes are completed the ephemeral designation may be removed. If a failure occurs during the multi step atomic write data that was previously written can be ignored no roll back is necessary since the data will be removed the next time the device is restarted. A similar approach may be used to provide support for transactions. As used herein a transaction refers to a plurality of operations that are completed as a group. If any one of the transaction operations is not completed the other transaction operations are rolled back. As a transaction are implemented the constituent storage operations may be marked as ephemeral. Successful completion of the transaction comprises removing the ephemeral designation from the storage operations. If the transaction fails the ephemeral data may be ignored.

In some embodiments ephemeral data may be associated with a time out indicator. The time out indicator may be associated with the operation of a storage reclamation process such as a groomer. When the groomer evaluates a storage division e.g. erase block page etc. for reclamation ephemeral data therein may be treated as invalid data. As such the ephemeral data may be omitted during reclamation processing e.g. not considered for storage division selection and or not stored in another media storage location during reclamation . In some embodiments ephemeral data may not be treated as invalid until its age exceeds a threshold. The age of ephemeral data may be determined by the sequence indicator associated therewith. When the age of ephemeral data exceeds a pre determined threshold it may be considered to be part of a failed transaction and may be invalidated as described above. The threshold may be set on a per packet basis e.g. in the header may be set globally through an API or setting of the storage layer or the like.

As described above removing an ephemeral designation may comprise updating storage metadata e.g. index to indicate that a particular entry is no longer to be considered to be ephemeral. In addition the storage layer may update the ephemeral indicator stored on the solid state storage media e.g. in persistent contextual metadata of a packet . However if the solid state storage media is write out of place it may not be practical to overwrite or rewrite these indicators. Therefore in some embodiments the storage layer persists a note on the solid state storage media e.g. writes a persistent note to a media storage location of the solid state storage media . As used herein a persistent note refers to a metadata note that is persistently stored on the solid state storage media. Removing the ephemeral designation may comprise persisting a metadata note indicating the removal to the solid state storage media. As depicted in a persistent note may comprise a reference that identifies one or more packets on a media storage location. The reference may comprise any suitable identifying information including but not limited to a logical interface a LID a range a media storage location identifier a sequence indicator or the like. The persistent note may also include a directive which in the example may be a directive to remove an ephemeral designation from the identified packets. Additional details regarding persistent notes are disclosed in U.S. patent application Ser. No. 13 330 554 entitled Apparatus System and Method for Persistent Metadata filed Dec. 19 2011 and which is hereby incorporated by reference.

In some embodiments the logical address space presented by the storage layer may include an ephemeral LID range. As used herein an ephemeral LID range comprises references to ephemeral data e.g. LIDs that are to be auto deleted on restart or another condition . This segmentation may be possible due to the storage layer maintaining a large e.g. sparse logical address space as described above. The storage layer maintains ephemeral data in the ephemeral logical address range as such each entry therein is considered to be ephemeral. An ephemeral indicator may also be included in contextual log based formatted data bound to the LIDs within the ephemeral range.

At step the requested LIDs are allocated as described above unless not already allocated by another storage client . Step may further comprise updating storage metadata to indicate that the LIDs ephemeral which may include but is not limited to setting an indicator in an entry for the LIDs in the storage metadata e.g. index allocating the LIDs in an ephemeral range of the index.

At step the storage client may request one or more persistent storage operations on the ephemeral LIDs of step . The storage operations may comprise a multi block atomic write operations pertaining to a transaction a snapshot operation a clone described in additional detail below or the like. Step may comprise marking contextual log based data associated with the persistent storage operations as ephemeral as described above e.g. in a header of a packet comprising the data .

At step if the method receives a request to remove the ephemeral designation the flow continues to step otherwise the flow continues to step . The request of step may be issued by a storage client and or the request may be part of a higher level API as described above. For example the request may be issued when the constituent operations a transaction or atomic operation are complete.

At step the ephemeral designation applied at steps and are removed. Step may comprise removing metadata indicators from storage metadata folding the ephemeral range into a non ephemeral range of the storage metadata index or the like folding is described in additional detail below . Step may further comprising storing one or more persistent notes on the non volatile storage media that remove the ephemeral designation from data corresponding to the formerly ephemeral data as described above.

At step the method may determine whether the ephemeral data should be removed. If not the flow continues back to step otherwise the flow continues to step . At step the ephemeral data is removed or omitted when the storage metadata is persisted as part of a shutdown or reboot operation . Alternatively or in addition data that is designated as ephemeral on the non volatile storage media may be ignored during a reconstruction process.

At step the method receives a request to reconstruct storage metadata from the contents of a non volatile storage medium or device. The request may be received in response to storage metadata maintained by the storage layer or another entity being lost or out of sync with the contents of the physical storage media. For example portions of the storage metadata described herein e.g. the index and or reverse map may be maintained in volatile memory. In an invalid shutdown the contents of the volatile memory may be lost before the storage metadata can be stored in non volatile storage. In another example a second storage device may be configured to mirror the contents of a first storage device accordingly the second storage device may maintain storage metadata describing the contents of the first storage device. The second storage device may lose communication with the first storage device and or may need to be rebuilt e.g. initialized . The initialization may comprise reconstructing storage metadata from the contents of the first storage device e.g. through queries to the first storage device as described above in conjunction with .

At step the method iterates over media storage locations of the storage device. The iteration may comprise accessing a sequence of media storage locations on the non volatile storage medium as described above in conjunction with .

At step for each media storage location the method access data formatted in the contextual log based format described above. The method may reconstruct the storage metadata using information determined from the contextual log based data format on the non volatile storage media . Using the contextual log based data format the method may determine the LIDs associated with the data may determine whether the data is valid e.g. using persistent notes and or sequence indicators as described above and so on. Alternatively step may comprise issuing queries to another storage device to iteratively determine which media storage locations comprise valid data. The iterative query approach described above in conjunction with may be used to mirror a storage device.

In addition at step the method determines whether a particular data packet is designated as being ephemeral. The determination may be based on an ephemeral indicator in a header of the packet. The determination may also comprise determining whether a persistent note that removes the ephemeral designation exists e.g. a persistent note as described above in conjunction with . Accordingly step may comprise the method maintaining the metadata for the packet in a temporary e.g. ephemeral location until the iteration of step completes and the method can determine whether a persistent note removing the ephemeral designation exists.

If step determines that the data is ephemeral the flow continues to step otherwise the flow continues to step . At step the method removes the ephemeral data. Removing the data may comprise omitting LIDs associated with the data from storage metadata e.g. the index described above marking the media storage location as invalid and available to be reclaimed e.g. in the reverse map or the like.

At step the method reconstructs the storage metadata as described above. In some embodiments step may further comprise determining whether the data is valid as described above in conjunction with . If the data is valid the method may be configured to perform further processing. For example if the method is being used to construct a mirror of another storage device step may comprise transferring the valid data to the mirror device. At step the flow ends.

In some embodiments the storage layer may provide an API to order storage operations performed thereon. For example the storage layer may provide a barrier API to determine the order of operations. As used herein a barrier refers to a primitive that enforces an order of storage operations. A barrier may specify that all storage operations that were issued before the barrier are completed before the barrier and that all operations that were issued after the barrier complete after the barrier. A barrier may mark a point in time in the sequence of operations implemented on the non volatile storage device.

In some embodiments a barrier is persisted to the non volatile storage media as a persistent note. A barrier may be stored on the non volatile storage media and may therefore act as a persistent record of the state of the non volatile storage media at a particular time e.g. a particular time within the sequence of operations performed on the non volatile storage media . The storage layer may issue an acknowledgement when all operations issued previous to the barrier are complete. The acknowledgement may include an identifier that specifies the time e.g. sequence pointer corresponding to the barrier. In some embodiments the storage layer may maintain a record of the barrier in the storage metadata maintained thereby.

Barriers may be used to guarantee the ordering of storage operations. For example a sequence of write requests may be interleaved with barriers. Enforcement of the barriers may be used to guarantee the ordering of the write requests. Similarly interleaving barriers between write and read requests may be used to remove read before write hazards.

Barriers may be used to enable atomic operations similarly to the ephemeral designation described above . For example the storage layer may issue a first barrier as a transaction is started and then issue a second barrier when complete. If the transaction fails the storage layer may roll back the sequence of storage operations between the first and second barriers to effectively undo the partial transaction. Similarly a barrier may be used to obtain a snapshot of the state of the non volatile storage device at a particular time. For instance the storage layer may provide an API to discover changes to the storage media that occurred between two barriers.

In another example barriers may be used to synchronize distributed storage systems. As described above a second storage device may be used to mirror the contents of a first storage device. The first storage device may be configured to issue barriers periodically e.g. every N storage operations . The second storage device may lose communication with the first storage device for a certain period of time. To get back in sync the second storage device may transmit its last barrier to the first storage device and then may mirror only those changes that occurred since the last barrier.

Distributed barriers may also be used to control access to and or synchronize shared storage devices. For example storage clients may be issued a credential that allows access to a particular range of logical identifiers read only access read write delete etc. . The credentials may be tied to a particular point or range in time e.g. as defined by a barrier . As the storage client interacts with the distributed storage device the credential may be updated. However if a storage client loses contact with the distributed storage device the credential may expire. Before being allowed access to the distributed storage device the client may first be required to access a new set of credentials and or ensure that local data e.g. cached data etc. is updated accordingly.

At step the method enforces the ordering constraints of the barrier. Accordingly step may comprise causing all previously issued storage requests to complete. Step may further comprise queuing all subsequent requests until the previously issued requests complete and the barrier is acknowledged at step .

At step the method determines if the ordering constraints are met and if so the flow continues to step otherwise the flow continues at step .

At step the barrier is acknowledged which may comprise returning a current time e.g. sequence indicator at which the operations issued before the barrier were completed. Step may further comprise storing a persistent note of the barrier on the non volatile storage. At step the method resumes operation on storage requests issued subsequent to the barrier at step . At step the flow ends until a next request for a barrier is received.

In some embodiments the storage layer leverages the logical address space to manage logical copies of data e.g. clones . As used herein a copy or clone refers to replicating a range or set of ranges within the logical address space . The clone may be assigned different logical identifiers but may be bound to the same media storage locations allowing two or more LIDs to reference the same data. Logical copies may be useful for deduplication snapshots atomic operations e.g. atomic writes transactions etc. and the like.

Creating a clone may comprise updating the logical interface of data stored on the non volatile storage media the modification may comprise referencing the data by two or more LIDs or LID ranges as opposed to a single LID or LID range . As such creating a clone of a LID or set of LIDs may comprise allocating new LIDs in the logical address space or dedicated portion thereof and binding the new LIDs to the same media storage locations as the original LIDs.

Creating a clone of the entry may comprise allocating one or more LIDs in the logical address space and binding the new LIDs to the same data segment as the entry e.g. the data segment at media storage location . The clone may therefore modify the logical interface of the data segment . As depicted in the logical interface of the data B associates the data segment with multiple different LIDs and rather than only a single range of LIDs . depicts the index comprising the modified logical interface of the data segment .

In the example the index comprises a new entry to represent the clone. The clone may be assigned LIDs . The new entry may be bound to the same media storage location as entry media storage locations . The clone results in modifying the logical interface B of the data segment the logical interface of the data segment includes and entries and . The modified logical interface provides for accessing the data segment through either LIDs or as opposed to only LIDs .

The modified logical interface B of the clone is inconsistent with the contextual format of the data segment on the non volatile storage media . As described above the persistent contextual metadata of the data segment comprises logical interface metadata that associates the data segment with only LIDs of the logical interface A and not LIDs and of the modified logical interface B. The contextual format of the data may need to be updated to be consistent with the modified logical interface B e.g. updated to associate the data with LIDs X and Y as opposed to only X .

Updating the contextual format of the data may comprise updating the persistent contextual metadata of the contextual data format on the non volatile storage media . Due to the append only write out of place properties of a log maintained by the storage layer updating the contextual format of the data segment may comprise relocating the data segment to a new storage location on the non volatile storage media which may be a time consuming processes this may be particularly inefficient if the data segment is large and or the clone comprises a large number and or range of LIDs.

Therefore in some embodiments the storage layer may defer updating the contextual format of the data . The storage layer may be configured to provide access to the data in the inconsistent contextual format . The storage layer may return from and or acknowledge the clone operation before the data is relocated in the updated contextual format. The data may be subsequently rewritten e.g. relocated in the updated contextual format on the non volatile storage media using another process which may be outside of the critical path of the clone operation and or other storage operations. In some embodiments the data segment is relocated using the groomer or the like. Accordingly storage clients may be able to access the data segment through the modified logical interface B both and without waiting for the contextual format of the data segment to be updated to be consistent with the modified logical interface B.

In some embodiments a clone operation may further comprise storing a persistent note on the non volatile storage media to make a clone operation persistent and or crash safe. The persistent note may an indicator of the modified logical interface B e.g. associate the data with logical identifiers of the modified logical interface . Until the contextual format of the data segment is updated on the non volatile storage media the modified logical interface B of the data segment may exist only in the index . Therefore if the index is lost due to inter alia power failure or data corruption the clone operation may not be reflected in the reconstructed storage metadata the clone operation may not be persistent and or crash safe . When the contextual format of the data at is accessed the logical interface metadata of the persistent contextual metadata indicates that the data is associated only with LIDs not and . Therefore only entry will be reconstructed as in and will be omitted moreover subsequent attempts to access the data segment through the modified logical interface B e.g. through may fail. A clone may be made persistent and crash safe by storing a persistent note on the non volatile storage media when the clone is created. The persistent note may comprise an indicator that data segment is associated with both LID and e.g. the persistent note may comprise the modified logical interface B of the data segment . During reconstruction of the index the persistent note may allow the node to be created. In some embodiments the storage layer may acknowledge completion of a clone operation when the persistent note is written to the non volatile storage media and or when the storage layer can reasonably guarantee that the persistent note will be written to the non volatile storage media .

The storage layer may be configured to store the data segment in an updated contextual format that is consistent with the modified logical interface B. In some embodiments the updated contextual format may comprise associating the data segment with LIDs of both logical copies e.g. both LIDs and . depicts one example of an updated contextual format for the data segment . As shown in in one embodiment the logical interface metadata indicates that the data segment is associated with LIDs and as opposed to only . The updated contextual format of the data was stored on a new storage location which is reflected in the entries and in the index . In response to updating the contextual format of the data the persistent note may be invalidated removed or marked for subsequent removal from the non volatile storage media .

Alternatively or in addition the index may be stored in a persistent crash safe storage location e.g. non transitory storage media and or non volatile storage device . In response the persistent note corresponding to the clone may be removed even if the contextual format of the data has not yet been updated on the non volatile storage media .

Storage operations that occur after creating a clone may cause the copy to diverge from the original e.g. the entries and may diverge . For example when data is written to LIDs of the clone entry the media storage locations to which the LIDs are bound may change due to write out of place storage operations . Other storage operations may cause changes to the logical identifier range of the entries and or . For instance appending data to a LID range may cause one of the logical address ranges or to be expanded deleting data may remove portions of a logical address ranges or and so on.

The size of the persistent contextual metadata may be limited and as such separately listing each logical identifier within the logical interface metadata may be limiting e.g. may limit the number of clones that can reference a particular data segment .

In some embodiments the storage layer may maintain reference entries to facilitate efficient cloning operations as well as other operations described below . As used herein a reference entry refers to an entry that only exists while it is being referenced by one or more entries in the logical address space . Accordingly a reference entry does not exist in its own right but only exists as long as it is being referenced. In some embodiments reference entries may be immutable. The storage layer may monitor the reference entries and may remove reference entries that are no longer being referenced by any other entries in the index. In some embodiments reference entries may be maintained in a separate portion of the storage metadata reference entries may be maintained in a separate index and or namespace than other entries in the index . Accordingly reference entries may be indexed by and or identified using identifiers that are distinguishable from the logical identifiers of the logical address space . Alternatively reference entries may be assigned logical identifiers selected from a pre determined range and or portion of the logical address space . The reference entries may not be directly accessible by storage clients via the storage layer . Instead storage clients may reference the data of a reference entry through other entries within the logical address space .

Reference entries may be referenced by e.g. linked to indirect entries. Accordingly as used herein an indirect entry refers an entry in the logical address space that references and or is linked to a reference entry. Indirect entries may be assigned a logical identifier within the logical address space and may be accessible to the storage clients . Indirect entries may reference and or link to one or more reference entries. Indirect entries may also comprise local LIDs like any other entry in the logical address space . To access data associated with an indirect entry the local LIDs of the indirect entry may be searched first and if the LID is not found locally the search may continue at the reference entries to which the indirect entry is linked. Accordingly an indirect entry may implement a cascade lookup comprising a local lookup within local LIDs of the indirect entry if any and one or more indirect lookups at one or more reference entries linked to the indirect entry.

In some embodiments reference entries may be used to represent cloned or duplicate data. A single reference entry may represent the cloned data segment and a plurality of entries may reference the data segment through respective indirect entries. depicts one embodiment of an index comprising a reference entry . In the example the reference entry represents the clone of the data segment of LIDs to LIDs as described above.

In response to a request to create a clone of the data segment e.g. to clone LIDs the storage layer may be configured to create a new reference entry in a designated portion of the index e.g. the reference index or in a separate datastructure or index. The reference entry may represent the cloned data segment and may be referenced by any number of entries in the index . As depicted in the reference entry may be bound to the media storage locations of the cloned data segment media storage locations . The reference entry may be assigned an identifier e.g. Z Z . The identifier in the indirect entry linking to the reference entry may be in a separate namespace than the logical address space of the index e.g. selected from a separate set of identifiers . Alternatively in some embodiments the reference entry may be assigned LIDs within a designated portion or range of logical address space . The reference entry may not be directly accessible by storage clients via the storage layer interface . As described below the reference entry may be referenced through one or more indirect entries and or .

The clone may further comprise modifying the logical interface D of the data segment in accordance with the clone operation the modified logical interface D may allow the data segment to be referenced through the LIDs of the indirect entry and the LIDs of the indirect entry . The indirect entries and may link to e.g. reference the reference entry as opposed to directly referencing the media storage locations of the data segment . Although the reference entry may not be used by storage clients to reference the clone the reference entry may be included in the modified logical interface D since the reference entry is used to reference the data by other layers of the storage system e.g. the storage controller storage layer and so on .

Creating the clone may further comprise storing a persistent note on the non volatile storage media as described above. The persistent note may identify the reference entry as well as the entries and that reference or are linked to the reference entry . The persistent note may make the clone operation persistent and crash safe and may be retained on the non volatile storage media until the data segment is relocated in an updated contextual format and or the index and or reference index are persisted as described above.

As described above the modified logical interface D of the data segment is inconsistent with the contextual format of the data . As depicted in the contextual format of the data indicates that the logical interface D to the data segment includes LIDs and does not identify the reference entry identifiers Z Z and or the identifiers of the clone . As such the data segment may be relocated e.g. rewritten in an updated contextual format . The contextual format may comprise persistent contextual metadata as described above. The logical interface indicator may associate the data segment with the reference entry e.g. Z Z as opposed to separately identifying the LIDs that reference the data segment . Accordingly the use of the indirect entry allows the logical interface D of the data segment to comprise any number of LIDs independent of size limitations of the contextual data format e.g. independent of the number of LIDs that can be included in the logical interface metadata . Moreover additional logical copies of the reference entries may be made without updating the contextual format of the data on the non volatile storage media .

In some embodiments each time a LIDs is allocated the LID may be linked to a corresponding reference entry in the reference index e.g. a clone with a single copy . The approach may result in an additional layer of mapping for the new LIDs however the use of reference entries may facilitate the creation of clones and or deduplication . Creating a clone may comprise linking new LIDs to the reference entries as discussed above without updating the contextual format of the data. An update to the contextual format of the data may not be required because the existing contextual format already associates the data with reference entries in the logical interface metadata as described above. The new LIDs may be associated with the reference entries via a persistent note or other persistent indicator as described above without rewriting and or relocating the data.

Storage clients may reference the data segment through the modified logical interface D while or before the contextual format of the data is stored on the non volatile storage media . In response to storing the data in the updated contextual format or persisting the storage metadata the persistent note may be invalidated and or removed from the non volatile storage media .

As described above the indirect references and or may comprise one or more local LIDs. Local LIDs may be used to reflect differences between the logical copies. For example after the clone operation a storage client may modify data at one of the clones e.g. modify data at . The modification may comprise writing the data out of place on the non volatile storage media in a contextual format and updating the index to reference the updated data stored on media storage locations . Updating the index may comprise adding a new local entry under the indirect entry as illustrated in . The local entry directly references the media storage locations of the modified data as opposed to a link to the reference entry .

In response to a request pertaining to data or sub set thereof the storage layer may search the indirect entry and may identify the local entry . The local entry may then be used to satisfy the request e.g. read data from media storage locations rather than per the reference entry . However requests for LIDs that are not found in the local entries e.g. LIDs may continue to be serviced using the reference entry . Accordingly the storage layer may use the indirect entry and reference entry to implement a cascade lookup for logical identifiers pertaining to the clone. The logical interface E of the data may therefore comprise one or more local entries and or one or more indirect and or reference entries.

In a further example illustrated in a storage client may modify data of the clone through another one of the LIDs of the logical interface E e.g. LIDs the logical interface delimiters are not shown in to avoid obscuring the details of the embodiment. The modified data may be referenced using a local entry of the indirect entry as described above. Since each of the clones now has its own respective copy of Z Z that portion of the reference entry is no longer being referenced and may be removed as depicted in . The clones may continue to diverge until neither nor references any portion of the reference entry at which point the reference entry may be removed.

The storage layer may be configured to groom the reference index . In some embodiments each reference index entry comprises metadata that includes a reference count not shown . The reference count may be incremented as new references or links to the reference entry are added and may be decremented in response to removing a reference to the entry . In some embodiments reference counts may be maintained for each identifier of the reference entry and or within sub ranges thereof. Alternatively reference counts may be maintained for the reference entries as a whole. When a reference count reaches 0 the reference entry or a portion thereof may be removed from the reference index . Removing a reference entry or portion of a reference entry may further comprise invalidating the corresponding data on the non volatile storage media as described above.

In another example the storage layer may remove reference entries using a mark and sweep approach. The storage layer or other process may periodically check references to entries in the reference index by inter alia following links to the reference entries from indirect entries or other types of entries in the index . Entries that are not referenced by any entries during the mark and sweep may be removed as described above. The mark and sweep may operate as a background process and may periodically perform a mark and sweep operation to garbage collect reference entries that are no longer in use.

The storage layer may leverage the storage metadata to perform other processes such as deduplication. Referring to a deduplication module may be configured to identify duplicated data on the non volatile storage media . Duplicated data may be identified using any suitable mechanism. In some embodiments duplicated data is identified using a data signature which may comprise a signature hash code cyclic code or the like. The signature may be stored within the index e.g. in metadata associated with the entries and or may be maintained and or indexed separate datastructure not shown . The deduplication module may compare data signatures and upon detecting a signature match may deduplicate the data. Deduplicating data may comprise verifying the signature match e.g. performing a byte to byte comparison creating a reference entry to represent the duplicated data and or linking one or more indirect entries to the reference entry.

In response to identifying and or verifying that entries and reference duplicate data the storage layer may be configured to deduplicate the data which may comprise modifying the logical interface G of the duplicated data to associate a single version of the data segment with both sets of LIDs and as in the clone examples above.

One of the clones of the data may be invalidated and or removed from the non volatile storage media and a reference entry may represent a single copy of the data segment indirect entries and may be linked to the reference entry as described above resulting in the logical interface G of the data segment being referenced by both sets of LIDs and . Deduplicating the data may further comprise storing a persistent note on the non volatile storage media to associate the data segment with the updated logical interface G thereof e.g. associate the data segment with the reference entry and or the linked indirect entries and as described above.

The modified logical interface G of the data may be inconsistent with the contextual format of the data on the non volatile storage media e.g. the contextual format may associate the data with only one of the set of LIDs or . The contextual format of the data may be updated to be consistent with the modified logical interface G as described above. Updating the contextual format may comprise relocating e.g. rewriting the data segment in an updated contextual format to new media storage locations e.g. media storage locations . The updated contextual format may comprise persistent contextual metadata that includes logical interface metadata to associates the data segment with the reference entry e.g. identifiers Z Z as described above. The updated contextual format may be written out of place to other media storage location of the non volatile storage media and or on another non volatile device A N.

Although depict cloning and or deduplicating a single entry or range of LIDs the disclosure is not limited in this regard. In some embodiments a plurality of LID ranges may be cloned in a single clone operation. For example referring back to a cloning operation may clone the entry along with all of its child entries. In another example a clone operation may comprise copying the entire contents of the index e.g. all of the entries in the index . This type of clone operation may be used to create a snapshot of a logical address space or a particular LID range . As used herein a snapshot refers to the state of a storage device or set of LIDs at a particular point in time. The snapshot may persist the state of the copied logical address range despite changes to the original.

The storage layer may provide other functionality involving the modification of the logical interface of data providing access to the data in a contextual format that is inconsistent with the modified logical interface and updating the contextual format of the data to be consistent with the modified logical interface. For example in some embodiments the storage layer provides an move operation. As used herein a move operation comprises modifying the logical interface of a data segment e.g. changing the LID of a data segment .

The entries define a logical interface A of the data stored at media storage locations and . As described above data of the entries may be stored on the non volatile storage media in a contextual format that associates the data with the LIDs and .

A move operation may modify the logical interface to the data B. A move operation may comprise removing the association between the LIDs and and the data at the respective media storage locations and and create a new logical interface B for the data that includes a new set of LIDs e.g. and . The move operation may be requested by a storage client e.g. a request to rename a file may be requested by the storage layer to balance and or defragment the index may flow from a request to relocate the entry entries to another portion of the index or the like.

In some embodiments a move operation may comprise the storage layer creating reference entries in a reference index to represent the move. The reference entries may comprise the pre move LIDs and and media storage locations and . The new logical interface of the data may be linked to the reference entries via indirect entries . The indirect entries may include links to the reference entries in the reference index as described above.

The move operation may further comprise storing a persistent note on the non volatile storage media to ensure that the move operation is persistent and crash safe. As discussed above the contextual format of the data on the media storage locations and of the non volatile storage media may be inconsistent with the updated logical interface the contextual format of the data may associate the respective data segments with LIDs and as opposed to and . The persistent note may indicate the updated logical interface for the data so that the storage metadata e.g. index can be correctly reconstructed from the contents of the non volatile storage media if necessary .

The storage layer may provide access to the data in the inconsistent contextual format through the modified logical interface B LIDs and the media storage locations and . The data may be rewritten and or relocated in a contextual format that is consistent with the modified logical interface B subsequent to the move operation and or outside of the path of the move operation and or other storage operations . For example the data at and or may be rewritten by a groomer process as described above. Therefore the clone operation may complete and or return an acknowledgement when the index is updated the corresponding persistent note is stored on the non volatile storage media and or there is a reasonable guarantee that the persistent note will be stored on the non volatile storage media e.g. the persistent note is inserted into the write pipeline write buffer or the like .

The index may be updated in response to storing data in the consistent contextual format. As illustrated in the data segment at media storage location may be relocated in a grooming operation and during grooming may be stored in a contextual format that is consistent with the modified logical interface B of the data and the data segment with the logical identifier e.g. the persistent contextual metadata comprises logical interface metadata that associates the data segment with LID . As illustrated in the index may be updated to reference the data in the updated contextual format which may comprise modifying the entry for such that it no longer is linked to the reference entry for . Since no entry references it may be removed and the data at may be invalidated and or removed from the non volatile storage media as described above.

The entries may implement the cascade lookup described above. For example a storage request pertaining to LID may resolve to the local entry in e.g. entry whereas a request pertaining to a LID that does not have a local entry e.g. LID or results in linking to the reference entries .

Referring to in another example a storage client may modify data at LID . The result of the modification may comprise storing the modified data out of place and in a contextual format that is consistent with the modified logical interface B e.g. associates the data with LID . In response the index may be updated to associate with the media storage location of the modified data e.g. media storage location and to remove the reference entry for LID as described above.

As discussed above in some embodiments the reference index may be maintained separately from other entries in the index such that the entries therein e.g. entries cannot be directly referenced by storage clients . This segregation of the logical address space may allow storage clients to operate more efficiently. For example rather than stalling operations until data is rewritten and or relocated in the updated contextual format on the non volatile storage media data operations may proceed while the data is rewritten in one or more processes outside of the path for servicing storage operations and or requests. Referring to following the move operation described above a storage client may store data in connection with the LID . As illustrated in the LID may be included in the reference index due to inter alia the data at not yet being rewritten in the updated contextual format. However since the reference index is maintained separately from the index a name collision may not occur and the storage operation may complete. The index may include the entry comprising the logical interface for the data stored at media storage location while continuing to provide access to the data formerly bound to through the reference index through the logical interface B.

When the entries are no longer linked any entries in the reference index due to inter alia rewriting relocating modifying deleting and or overwriting the data the last of the reference entries may be removed and the entries may no longer be linked to reference entries in the reference index . In addition the persistent note associated with the move operation may be invalidated and or removed from the non volatile storage media as described above.

Step may comprise modifying a logical interface of data stored in a contextual format on a non volatile storage media. The logical interface may be modified at step in response to performing an operation on the data which may include but is not limited to a clone operation a deduplication operation a move operation or the like. The request may originate from a storage client the storage layer e.g. deduplication module or the like.

Modifying the logical interface may comprise modifying the logical identifier s associated with the data which may include but is not limited to referencing the data using one or more additional logical identifiers e.g. clone deduplication etc. changing the logical identifier s associated with the data e.g. a move or the like. The modified logical interface may be inconsistent with the contextual format of the data on the non volatile storage media as described above.

Step may further comprise storing a persistent note on the non volatile storage media that identifies the modification to the logical interface. The persistent note may be used to make the logical operation persistent and crash safe such that the modified logical interface e.g. storage metadata of the data may be reconstructed from the contents of the non volatile storage media if necessary . Step may further comprise acknowledging that the logical interface has been modified e.g. returning from an API call returning an explicit acknowledgement or the like . The acknowledgement occur and access through the modified logical interface at step before the contextual format of the data is updated on the non volatile storage media . Accordingly the logical operation may not wait until the data is rewritten and or relocated as discussed below updating contextual format of the data may be deferred and or implemented in a processes that is outside of the critical path of the method and or the path for servicing other storage operations and or requests.

Step may comprise providing access to the data in the inconsistent contextual format through the modified logical interface of step . As described above updating the contextual format of the data to be consistent with the modified contextual interface may comprise rewriting and or relocating the data on the non volatile storage media which may impose additional latency on the operation of step and or other storage operations pertaining to the modified logical interface. Therefore the storage layer may be configured to provide access to the data in the inconsistent contextual format while or before the contextual format of the data is updated. Providing access to the data at step may comprise referencing and or linking to one or more reference entries corresponding to the data via one or more indirect entries as described above.

Step may comprise updating the contextual format of the data on the non volatile storage media to be consistent with the modified logical interface of step . Step may comprise rewriting and or relocating the data to another media storage location on the non volatile storage media and or on another non volatile storage device A N. As described above step may be implemented using a process that is outside of the critical path of step and or other storage requests performed by the storage layer step may be implemented by another autonomous module such as groomer module deduplication module or the like. Accordingly the contextual format of the data may be updated independent of servicing other storage operations and or requests. As such step may comprise deferring an immediate update of the contextual format of the data and updating the contextual format of the data in one or more background processes such as a groomer process. Alternatively or in addition updating the contextual format of the data may occur in response to e.g. along with other storage operations. For example a subsequent request to modify the data may cause the data to be rewritten out of place and in the updated contextual format e.g. as described above in connection with .

Step may further comprise updating storage metadata as the contextual format of the data is updated. As data is rewritten and or relocated in the updated contextual format the storage layer may update the storage metadata e.g. index accordingly. The updates may comprise removing one or more links to reference entries in a reference index and or replacing indirect entries with local entries as described above. Step may further comprise invalidating and or removing a persistent note from the non volatile storage media in response to updating the contextual format of the data and or persisting the storage metadata as described above.

Step comprises selecting a storage division for recovery such as an erase block or logical erase block. As described above the selection of step may be based upon a number of different factors such as a lack of available storage capacity detecting a percentage of data marked as invalid within a particular logical erase block reaching a threshold a consolidation of valid data an error detection rate reaching a threshold improving data distribution data refresh or the like. Alternatively or in addition the selection criteria of step may include whether the storage division comprises data in a contextual format that is inconsistent with a corresponding logical interface thereof as described above.

As discussed above recovering or reclaiming a storage division may comprise erasing the storage division and relocating valid data thereon if any to other storage locations on the non volatile storage media. Step may comprise determining whether the contextual format of data to be relocated in a grooming operation should be updated e.g. is inconsistent with the logical interface of the data . Step may comprise accessing storage metadata such as the indexes described above to determine whether the persistent contextual metadata e.g. logical interface metadata of the data is consistent with the storage metadata of the data. If the persistent contextual metadata is not consistent with the storage metadata e.g. associates the data with different logical identifiers as described above the flow continues at step otherwise the flow continues at step .

Step may comprise updating the contextual format of the data to be consistent with the logical interface of the data. Step may comprise modifying the logical interface metadata to reference a different set of logical identifiers and or reference entries as described above.

Step comprises relocating the data to a different storage location in a log format that as described above preserves an ordered sequence of storage operations performed on the non volatile storage media. Accordingly the relocated data in the updated contextual format may be identified as the valid and up to date version of the data when reconstructing the storage metadata if necessary . Step may further comprise updating the storage metadata to bind the logical interface of the data to the new media storage locations of the data remove indirect and or reference entries to the data in the inconsistent contextual format and so on as described above.

Step comprises identifying duplicated data. Step may be performed by a deduplication module operating within the storage layer . Alternatively step may be performed by the storage layer as storage operations are performed.

Step may comprise determining and or verifying that the non volatile storage media comprises duplicate data or already comprises data of a write and or modify request . Accordingly step may occur within the path of a storage operation e.g. as or before duplicate data is written to the non volatile storage media and or may occur outside of the path of servicing storage operations e.g. identify duplicate data already stored on the non volatile storage media . Step may comprise generating and or maintaining data signatures in storage metadata and using the signature to identify duplicate data.

In response to identifying the duplicate data at step the storage layer or other module such as the deduplication module may modify a logical interface of a copy of the data such that a single copy may be referenced by two or more sets of LIDs. The modification to the logical interface at step may comprise updating storage metadata and or storing a persistent note on the non volatile storage media as described above. Step may further comprise invalidating and or removing other copies of the data on the non volatile storage media as described above.

The contextual format of the data on the non volatile storage media may be inconsistent with the modified logical interface. Therefore steps and may comprise providing access to the data in the inconsistent contextual format through the modified logical interface and updating the contextual format of the data on the non volatile storage media as described above. At step the method ends.

Referring back to the cloning examples of in other examples clone operations may be used to perform atomic operations such as multi step writes or transactions. An atomic operation to modify a data in a particular logical address range may comprise creating a clone of the logical address range implementing storage operations within the clone and when the operations complete folding the clone back into the logical address space e.g. overlaying the original logical address range with the clone . As used herein folding a logical address range refers to combining two or more address ranges together e.g. folding a logical address range with a clone thereof . The folding may occur according to one of a plurality of operational modes which may include but are not limited to an overwrite mode in which the contents of one of one logical address range overwrites the contents of another logical address range a merge mode in which the contents of the logical address ranges are merged together e.g. in a logical OR operation or the like.

In another example in which the LID range of the clone was modified e.g. data was appended or deleted from the clone the LID would be modified in a corresponding way. Accordingly a folding operation may comprise allocation of additional LIDs in the logical address space . Therefore in some embodiments clones may be tied to one another e.g. using entry metadata and or . An extension to a clone such as entry may be predicated on the logical address range being available to the original entry . The link between the entries may be predicated on the mode of the clone as described above. For example if the entries are not to be folded at a later time the clones may not be linked.

As described above clones may be tied together according to an operational mode of the clones. For example changes to a clone may be automatically mirrored in the other clone. This mirroring may be uni directional bi direction or the like. The nature of the tie between clones may be maintained in storage metadata e.g. metadata entries and and or in reference entries . The storage layer may access the metadata entries and or when storage operations are performed within the LID ranges and or to determine what if any synchronization operations are to be performed.

In some embodiments data of a clone may be designated as ephemeral as described above. Accordingly if upon reboot or another condition the ephemeral designation is not removed the clone may be deleted e.g. invalidated as described above . is a flow diagram of another embodiment of a method for cloning ranges of a logical address space .

At step the method starts and is initialized as described above. At step a request to create a clone is received. The request may be received from a storage client and or may be part of a higher level API provided by the storage layer . The request may include an operational mode of the clone which may include but is not limited to how the clones are to be synchronized if at all how folding is to occur whether the copy is to be designated as ephemeral and so on.

Step may comprise allowing LIDs in the logical address space to service the request. The allocation of step may further comprise reserving physical storage space to accommodate changes to the clone. The reservation of physical storage space may be predicated on the operational mode of the clone. For instance if all changes are to be synchronized between the clone and the original address range a small portion if any physical storage space may be reserved. Step may further comprise allocating the clone within a designated portion or segment of the logical address space e.g. a range dedicated for use with clones .

Step may comprise updating the logical interface of data of the clone as described above. Step may further comprise storing a persistent note on the non volatile storage media to make the clone persistent and crash safe as described above.

Step may comprise receiving a storage request and determining if a storage request pertains to the original LID range and or the clone of the LID range. If so the flow continues to step otherwise the flow remains on step .

Step may comprise determining what if any operations are to be taken on the other associated LID ranges e.g. synchronize changes allocate logical and or physical storage resources or the like . The determination of step may comprise accessing storage metadata describing the operational mode of the clone and or the nature of the tie if any between the original LIDs and the clone thereof.

Step may comprise performing the operations if any determined at step along with the requested storage operation. If one or more of the synchronization operations cannot be performed e.g. additional logical address space cannot be allocated the underlying storage operation may fail. At step the flow ends until another request is received at which point the flow continues at step .

At step a request to fold the clone is received. The request may specify an operational mode of the fold and or the operational mode may have been specified when the clone was created at step .

Step comprises folding the clone back into the logical address space of the original logical range. Step may comprise overwriting the contents of the original logical address range with the contents of the clone merging the logical address ranges e.g. in an OR operation or the like. In some embodiments the merging comprises deleting e.g. invalidating the clone which may comprise removing entries of the clone from the storage metadata index removing shared references to media storage locations from a reference count datastructure and the like. Step may further comprise modifying a logical interface of the merged data as described above. The modified logical interface may change the LIDs used to reference the data. The modified logical interface may be inconsistent with the contextual format of the data on the non volatile storage media . Therefore step may further comprise providing access to the data in the inconsistent contextual format and or updating the contextual format of the data as described above. At step the flow ends until a next clone is created.

This disclosure has been made with reference to various exemplary embodiments. However those skilled in the art will recognize that changes and modifications may be made to the exemplary embodiments without departing from the scope of the present disclosure. For example various operational steps as well as components for carrying out operational steps may be implemented in alternate ways depending upon the particular application or in consideration of any number of cost functions associated with the operation of the system e.g. one or more of the steps may be deleted modified or combined with other steps . Therefore this disclosure is to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope thereof. Likewise benefits other advantages and solutions to problems have been described above with regard to various embodiments. However benefits advantages solutions to problems and any element s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as a critical a required or an essential feature or element. As used herein the terms comprises comprising and any other variation thereof are intended to cover a non exclusive inclusion such that a process a method an article or an apparatus that comprises a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process method system article or apparatus. Also as used herein the terms coupled coupling and any other variation thereof are intended to cover a physical connection an electrical connection a magnetic connection an optical connection a communicative connection a functional connection and or any other connection.

Additionally as will be appreciated by one of ordinary skill in the art principles of the present disclosure may be reflected in a computer program product on a machine readable storage medium having machine readable program code means embodied in the storage medium. Any tangible non transitory machine readable storage medium may be utilized including magnetic storage devices hard disks floppy disks and the like optical storage devices CD ROMs DVDs Blu Ray discs and the like flash memory and or the like. These computer program instructions may be loaded onto a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions that execute on the computer or other programmable data processing apparatus create means for implementing the functions specified. These computer program instructions may also be stored in a machine readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the machine readable memory produce an article of manufacture including implementing means that implement the function specified. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide steps for implementing the functions specified.

While the principles of this disclosure have been shown in various embodiments many modifications of structure arrangements proportions elements materials and components that are particularly adapted for a specific environment and operating requirements may be used without departing from the principles and scope of this disclosure. These and other changes or modifications are intended to be included within the scope of the present disclosure.

