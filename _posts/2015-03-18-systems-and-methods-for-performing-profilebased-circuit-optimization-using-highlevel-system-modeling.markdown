---

title: Systems and methods for performing profile-based circuit optimization using high-level system modeling
abstract: Integrated circuits may be programmed using configuration data to implement desired custom logic circuits. The configuration data may be generated using a logic design system. The logic design system may include first and second compilers and an emulation engine. The first compiler may compile a computer program language description of the logic circuit to generate a hardware description language (HDL) description. The emulation engine may emulate performance of the logic circuit when loaded on a target device and may monitor the emulated performance to generate emulated profile data characterizing the emulated performance of the logic circuit. The first compiler may process the emulated profile data to identify optimizations to perform on the logic circuit and may compile an optimized HDL description. The second compiler may compile optimized configuration data using the optimized HDL. The design system may generate the optimized configuration data without performing multiple, time-consuming, HDL compilations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529950&OS=09529950&RS=09529950
owner: Altera Corporation
number: 09529950
owner_city: San Jose
owner_country: US
publication_date: 20150318
---
This relates to integrated circuits and more particularly to systems for designing logic circuitry on integrated circuit devices such as programmable integrated circuits.

Programmable integrated circuits are a type of integrated circuit that can be programmed by a user to implement a desired custom logic function. In a typical scenario a logic designer uses computer aided design tools to design a custom logic circuit that performs custom logic functions. When the design process is complete the computer aided design tools generate configuration data. The configuration data is loaded into memory elements to configure the devices to perform the functions of the custom logic circuit. Memory elements are often formed using random access memory RAM cells. Because the RAM cells are loaded with configuration data during device programming the RAM cells are sometimes referred to as configuration memory or configuration random access memory cells CRAM .

Integrated circuits such as programmable integrated circuits often include millions of gates and megabits of embedded memory. The complexity of a large system often requires the use of electronic design automation EDA tools to create and optimize a design for the system onto an integrated circuit target device . Among the procedures performed by EDA tools in a computer aided design CAD compilation flow are high level compilation and hardware description language HDL compilation. High level compilation or high level synthesis involves generating an HDL file of a system from a computer language description of the system. The computer language description of the system may be for example in Open Computing Language OpenCL format or another computer language description format. OpenCL is a framework for writing programs that execute across heterogeneous platforms. OpenCL includes a language for writing kernels and application programming interfaces APIs that are used to define and control platforms. HDL compilation involves performing synthesis placement routing and timing analysis of the system on the target device and providing final configuration data for the target device to implement the desired system.

Traditionally synthesis is performed independently of information from other compilations. As a result the HDL compiler must compile the HDL file without any knowledge of whether the final configuration data performs efficiently or satisfactorily when loaded onto the target device. As a result the target device may have unoptimized and inefficient performance when loaded with the configuration data.

An integrated circuit may include memory elements arranged in rows and columns. The integrated circuit may be a programmable integrated circuit that can be programmed e.g. using configuration data by a user to implement desired custom logic functions logic designs or systems . The configuration data may be generated using a logic design system e.g. logic design equipment .

The logic design system may include logic design computing equipment and may be used to design a logic circuit e.g. a logical system incorporating a desired logic design for a target device e.g. a programmable integrated circuit . The logic design system may include a first high level compiler that compiles a computer program language description of the logic circuit to generate a hardware description language HDL description file of the logic circuit.

The system may include an emulation engine that models emulates performance of the logic circuit identified in the computer program language description e.g. that models the performance of the target device when the target device is loaded with configuration data specifying the logic design . The emulation engine may receive user input data representative of input data that would be received by the target device when loaded with the logic circuit and may emulate performance of the logic circuit in response to the user input data e.g. may emulate the performance of the target device when the target device is loaded with configuration data specifying the logic design and when the target device is provided with the user input data .

The emulation engine may monitor the emulated performance of the logic circuit to generate emulated profile data that characterizes the emulated performance of the logic circuit. For example the emulation engine may include at least one of a loop trip counter a variable latency instruction monitoring engine a load store monitoring engine a block execution monitoring engine a thread execution monitoring engine and a barrier monitoring engine that generate the emulated profile data by monitoring the emulated performance of the logic circuit.

The high level compiler may identify optimizations to the logic design based on the emulated profile data and may generate an optimized HDL description of the logic design incorporating the identified optimizations. The optimized HDL description may be passed to a second compiler.

The second compiler e.g. an HDL compiler on the logic design system may generate optimized configuration data for the target device based on the optimized HDL description. For example the HDL compiler may perform synthesis of the logic circuit. The second compiler may perform placement and route operations and may assemble optimized configuration data that incorporates the optimized logic design identified by the optimized HDL. The optimized configuration data may be provided to a configuration device that programs the target device to implement the optimized logic design described in the optimized configuration data.

The logic design system may be formed on a computer system having memory and a processor that is separate from the target device. The first compiler the emulation engine and the second compiler may be stored on the memory e.g. a non transitory computer readable medium and controlled using the processor. In this way the performance of the target device in implementing desired logic designs may be improved relative to scenarios where no profile data is used to characterize the performance of the logic designs and the logic design system may generate optimized configuration data for the target device without performing multiple time consuming HDL compilation operations.

Further features of the present invention its nature and various advantages will be more apparent from the accompanying drawings and the following detailed description.

The present invention relates to improving logic circuit compilation and design efficiency when generating efficient logic designs systems for a target device using high level system modeling and emulation. Logic circuit designs that are compiled using the high level system modeling and emulation may be part of any suitable integrated circuits. Embodiments of the present invention relate to designing and compiling synthesizing logic circuitry for integrated circuits and more particularly integrated circuits with memory elements. Integrated circuits that contain memory elements may include memory chips digital signal processing circuits microprocessors application specific integrated circuits ASICs application specific standard products ASSPs programmable integrated circuits such as programmable array logic PAL programmable logic arrays PLAs field programmable logic arrays FPGAs electrically programmable logic devices EPLDs electrically erasable programmable logic devices EEPLDs logic cell arrays LCAs field programmable gate arrays FPGAs or other suitable integrated circuits.

Integrated circuits such as programmable integrated circuits use programmable memory elements to store configuration data. During programming of a programmable integrated circuit configuration data is loaded into the memory elements. During normal operation of the programmable integrated circuit each memory element provides a static output signal. The static output signals that are supplied by the memory elements serve as control signals. These control signals are applied to programmable logic on the integrated circuit to customize the programmable logic to perform a desired logic function.

Memory elements may be organized in arrays having numerous rows and columns. For example memory array circuitry may be formed in hundreds or thousands of rows and columns on a programmable logic device integrated circuit. Programmable integrated circuit of is an example of an illustrative integrated circuit on which memory array circuitry may be formed.

As shown in programmable integrated circuit may have input output circuitry for driving signals off of device and for receiving signals from other devices via input output pins . Interconnection resources such as global and local vertical and horizontal conductive lines and buses may be used to route signals on device . Interconnection resources include fixed interconnects conductive lines and programmable interconnects i.e. programmable connections between respective fixed interconnects . Programmable logic may include combinational and sequential logic circuitry. The programmable logic may be configured to perform a custom logic function.

Programmable integrated circuit contains memory elements that can be loaded with configuration data also called programming data using pins and input output circuitry . Once loaded the memory elements each provide a corresponding static control output signal that controls the state of an associated logic component in programmable logic . Typically the memory element output signals are used to control the gates of metal oxide semiconductor MOS transistors. Some of the transistors may be p channel metal oxide semiconductor PMOS transistors. Many of these transistors may be n channel metal oxide semiconductor NMOS pass transistors in programmable components such as multiplexers. When a memory element output is high an NMOS pass transistor controlled by that memory element will be turned on to pass logic signals from its input to its output. When the memory element output is low the pass transistor is turned off and does not pass logic signals.

A typical memory element is formed from a number of transistors configured to form cross coupled inverters. Other arrangements e.g. cells with more distributed inverter like circuits may also be used. With one suitable approach complementary metal oxide semiconductor CMOS integrated circuit technology is used to form the memory elements so CMOS based memory element implementations are described herein as an example. In the context of programmable integrated circuits the memory elements store configuration data and are therefore sometimes referred to as configuration random access memory CRAM cells.

An illustrative system environment for device is shown in . Device may for example be mounted on a board in a system . In general programmable logic device may receive configuration data from programming equipment or from other suitable equipment or device. In the example of programmable logic device is the type of programmable logic device that receives configuration data from an associated integrated circuit . With this type of arrangement circuit may if desired be mounted on the same board as programmable logic device . Circuit may be an erasable programmable read only memory EPROM chip a programmable logic device configuration data loading chip with built in memory sometimes referred to as a configuration device or other suitable device. When system boots up or at another suitable time the configuration data for configuring the programmable logic device may be supplied to the programmable logic device from device as shown schematically by path . The configuration data that is supplied to the programmable logic device may be stored in the programmable logic device in its configuration random access memory elements .

System may include processing circuits storage and other system components that communicate with device . The components of system may be located on one or more boards such as board or other suitable mounting structures or housings and may be interconnected by buses and other electrical paths . If desired programmable device may be loaded with configuration data without mounting device and or configuration device to board e.g. using any desired configuration data loading equipment .

Configuration device may be supplied with the configuration data for device sometimes referred to herein as target circuit or target device over a path such as path . Configuration device may for example receive the configuration data from configuration data loading equipment or other suitable equipment that stores this data in configuration device . Device may be loaded with data before or after installation on board .

It can be a significant undertaking to design and implement a desired custom logic circuit in a programmable logic device. Logic designers therefore generally use logic design systems based on computer aided design CAD tools to assist them in designing circuits. A logic design system can help a logic designer design and test complex circuits for a system. When a design is complete the logic design system may be used to generate configuration data for electrically programming the appropriate programmable logic device.

As shown in the configuration data produced by a logic design system sometimes referred to herein as logic design equipment may be provided to equipment over a path such as path . The equipment provides the configuration data to device so that device can later provide this configuration data to the programmable logic device over path . System may be based on one or more computers and one or more software programs. System may sometimes be referred to herein as logic design circuitry or data stream generation circuitry. In general software and data may be stored on any computer readable medium storage in system and is shown schematically as storage in . System may include processing circuitry in the form of one or more processors such as central processing unit CPU . In general any desired processing circuitry may be formed on system .

In a typical scenario logic design system is used by a logic designer to create a custom circuit logic design. For example the logic designer may provide input commands to logic design system e.g. by selecting on screen commands displayed on a display screen by entering commands using a user input device such as a keyboard etc. . The system produces corresponding configuration data which is provided to configuration device . Upon power up configuration device and data loading circuitry on programmable logic device are used to load the configuration data into CRAM cells of device . Device may then be used in normal operation of system .

As shown in logic design system may include multiple logic compiling engines for performing compilation and synthesis of logic circuit designs for integrated circuit such as high level compilation engine and Hardware Design Language HDL compilation engine . High level compilation or high level synthesis involves generating an HDL file of a system from a computer language description of the system. The computer language description of the system may be for example in Open Computing Language OpenCL format or another computer language description format. OpenCL is a framework for writing programs that execute across heterogeneous platforms. OpenCL includes a language for writing kernels and application programming interfaces APIs that are used to define and control platforms.

High level compilation engine sometimes referred to herein as high level compiling engine or high level compiler may receive a high level kernel description for a desired logic design to be implemented on device such as high level kernel description e.g. an OpenCL description . High level kernel description may for example be specified by a logic designer e.g. a user of logic design system . High level kernel description may for example be a computer program language high level description of the logic design system to implement on device such as an OpenCL description e.g. OpenCL code or any other desired program language description.

High level compilation engine may compile high level kernel description to generate a hardware description language description of the logic circuit design e.g. an HDL file HDL code or any other desired HDL data structure . This example is merely illustrative and in general any desired hardware description may be output by compiler . When using a compiler such as compiler to perform high level compiling of kernel descriptions specifying logic designs for device it may be desirable to gather information about the performance of device when implementing the particular logic design specified by the description . Such performance information may include performance metric data that characterizes the performance of device when configured based on description and may sometimes be referred to herein as profile data.

In some scenarios dedicated hardware may be specified in the HDL file e.g. by engine for inclusion in the configuration data provided to device that controls device to generate profile data characterizing the performance of device when implementing a particular logic design. The profile data may be generated in response to real user input provided to device e.g. may characterize the performance of the hardware implemented on device when provided with real user input data . In this scenario the profile data generated at device may be provided to high level compilation engine which processes the profile data to determine whether any adjustments to the logic design need to be made to improve performance of device when implementing the desired logic design.

In order to make adjustments to the logic design in response to performance metric information identified by the profile data in this scenario HDL compilation engine will need to perform an additional HDL compile operation to implement the adjustments before the adjusted configuration data is provided to device . However HDL compilation engine may require an excessive amount of time to perform HDL compilation operations thereby negatively impacting the efficiency with which device is loaded with optimized configuration data. In other words at least two time consuming HDL compile operations need to be computed before adjusted optimized configuration data is loaded onto the device in this scenario. It may therefore be desirable to provide improved systems and methods for synthesizing and optimizing the logic design to be implemented on device .

In order to characterize the performance of device when implementing a desired logic design e.g. for generating optimized configuration data logic design system may include a high level system modeling engine such as profile data emulation engine . Emulation engine may receive a user input e.g. user input corresponding to real user input data that would be provided to device during normal operation of device after configuring device with the configuration data to implement the desired logic design and may receive high level kernel description via compiler or other desired paths. Profile data emulation engine may emulate model the performance that device would exhibit while implementing the logic design specified by kernel and while provided with a user input such as user input . Engine may monitor the performance of the emulated device to generate corresponding emulated profile data . In other words emulation engine may model emulate the performance that device would have were device to be configured using the description and provided with a particular user input and emulation engine may generate profile data that would have been generated by device while characterizing the performance of the logic function implemented on device .

Profile data emulation engine may pass emulated profile data back to high level compilation engine as shown over path . High level compilation engine may compile the logic design identified by description incorporating any desired optimizations as specified by emulated profile data to generate optimized HDL file . For example compilation engine may process emulated profile data to determine how the design for the logic circuitry to implement on device can be adjusted to improve optimize the performance of the logic circuitry. Compilation engine may implement the adjustments identified in response to processing emulated profile data when generating optimized HDL data e.g. engine may optimize the design based on the emulated profile data when generating the optimized HDL data . Engine may pass optimized HDL to HDL compilation engine over path .

HDL compilation engine may receive optimized HDL from high level compilation engine over path . HDL compilation engine may compile optimized HDL received from high level compilation engine to generate optimized configuration data e.g. an optimized program file . HDL compilation engine may for example perform synthesis placement routing and timing analysis of the system for implementation on target device .

HDL compilation engine may provide optimized configuration data to configuration device as shown by path . If desired HDL compilation engine may optionally provide performance report files associated with the performance of optimized configuration data to high level compilation engine and high level compilation engine may receive hardware profile data generated by device . By emulating the performance of device and generating corresponding emulated profile data using profile data emulation engine system may characterize the performance of device without a need to form any dedicated logic or hardware on device that generates the profile data on device thereby allowing for optimized configuration data to be efficiently loaded onto device without the need to iteratively re compile adjusted HDL files using compilation engine .

The example of is merely illustrative. If desired high level compilation engine profile data emulation engine and or HDL compilation engine may be formed on common circuitry e.g. on common processing circuitry or a common integrated circuit or may be formed on dedicated circuits e.g. engines and may be formed on a common integrated circuits on separate integrated circuits etc. . If desired system may emulate the performance of a host on device in addition to kernels on device e.g. profile data emulation engine may emulate the performance of description in addition to the performance of a host running on device .

In general kernels may be data processing functions on device e.g. a data processing function on which a majority of the compute time on device is consumed whereas hosts may be formed on device to perform one or more control operations. Hosts on device may be implemented on processing circuitry e.g. one or more CPUs or more generally as one or more state machines. Hosts on device may for example pre process or otherwise convey data to kernels on device for processing may allocate memory on device provide data from device to external circuitry synchronize computations by multiple kernels on device or by multiple different devices process or receive user input data etc. System may emulate the performance of one or more hosts on device and or kernels on device .

At step high level compilation engine may receive kernel description of a desired logic design e.g. from a logic designer or user of system . The kernel description may for example include OpenCL description of the desired logic design for circuitry to be implemented on target device . Kernel description may be passed to emulation engine .

At step compilation engine may perform high level compilation on the received high level kernel description to generate a corresponding HDL file. The HDL file may include hardware description language for the desired logic design identified by kernel description . If desired step may be omitted to perform emulation without additionally performing a high level compiling operation on description without incorporating any logic optimizations

At step profile data emulation engine may receive user input data . User input data may for example be received by a logic designer or user of system . User input data may correspond to real input data e.g. an input data vector that would be provided to device when implementing the desired logic design. By obtaining user data emulation engine may dynamically emulate the behavior of device in real world conditions e.g. in conditions when user data is to be input to device to provide a more robust characterization of device than in scenarios where no user data is provided e.g. static scenarios .

At step emulation engine may emulate the operation of the logic design in received high level kernel description when provided with user input data e.g. the performance of device loaded with the logic design when device receives an input corresponding to input data . Engine may monitor the emulated performance of the logic design and may generate emulated profile data that includes performance metric data characterizing the performance behavior of the emulated logic design. The emulated profile data may represent the behavior that device would exhibit when loaded with the logic design e.g. configuration data that includes the logic design for example. Emulation engine may provide emulated profile data to high level compilation engine over path .

At step high level compilation engine may compile an optimized HDL based on emulated profile data and kernel description . For example compilation engine may identify adjustments to be made to the logic design identified by high level description based on emulated profile data and may compile the logic design of description to include the identified adjustments while generating optimized HDL . Optimized HDL may include the identified adjustments. HDL may be passed to HDL compilation engine over path .

At step HDL compilation engine may generate optimized configuration data by performing HDL compilation operations on optimized HDL . Optimized configuration data may include the identified adjustments to the logic design incorporated in optimized HDL . If desired HDL compilation engine may perform synthesis placement routing and timing analysis when generating optimized configuration data .

At step engine may provide optimized configuration data to configuration device . Configuration device may subsequently load optimized configuration data so that device implements the desired logic design including any adjustments as identified in emulated profile data . In this way the performance of device in implementing desired logic functions may be improved relative to scenarios where no profile data is used to compile the logic designs for use on device and system may generate optimized configuration data based on the profile data without performing multiple time consuming HDL compilation operations. By emulating a user input in addition to the performance of the logic design in description optimized data may more accurately reflect real world operation of device and may include a dynamic characterization of device relative to scenarios in which user input is not emulated.

The example of is merely illustrative. In general profile data emulation engine may emulate the performance of kernel description and or one or more hosts e.g. host designs for device . For example emulation engine may receive information about a host on device for emulating performance of the host in addition to or instead of receiving the output of engine for emulating.

At step high level compiler may translate kernel code into a compiler intermediate representation of kernel description . The compiler intermediate representation of kernel description may for example include a sequence of functions and named data storage. Each function in the compiler intermediate representation may include a sequence of instructions grouped into basic blocks where each basic block is a contiguous sequence of instructions having a single entry point and a single exit point. An instruction in the middle of a given basic block may be a function call but may not count as an exit point from the basic block. Each basic block may terminate with either a branch e.g. a conditional branch or a return from the function. A barrier synchronization primitive may be expressed as a function call to a special barrier function. The kernel code may include a system description of the eventual hardware target logic system implemented on device . If desired the translation of step may be performed by a compiler front end associated with compiler .

At step engine may transform and optimize the compiler intermediate representation generated at step by mapping the intermediate representation to hardware constructs. For example a Static Single Assignment SSA may be used to further restrict the compiler intermediate representation. In SSA computed values are given a name and the instruction that computes the value is referred to as the value s definition site. A value is computed so that the value can be used by instructions that execute later in the program code and each of those later instructions is known as a use of the value.

If desired compiler may identify optimizations to perform on the logic design in kernel code based on emulated profile data received from emulation engine . For example compiler may process emulated profile data to determine one or more optimizations to perform on the logic design and or code description of the logic design.

At step an HDL file such as optimized HDL may be generated for the logic design to be implemented on device e.g. the logic design identified by kernel and the corresponding intermediate representation . HDL may describe the operation of the system logic design to be programmed on target device . HDL provides high level representations of a circuit in terms of the flow of signals or transfer of data between hardware registers and the logic operations performed on those signals. When generating optimized HDL HDL may provide high level representations of a circuit for the logic design incorporating the optimizations as identified by emulated profile data .

Engines may be formed from shared circuitry on emulation engine or from discrete portions e.g. circuits of emulation engine . The example of is merely illustrative. In general one or more of profile tracking engines may be omitted and any other desired profile tracking circuitry may be formed on emulation engine . Profile tracking engines may be specified by a user of design system for monitoring desired emulated operations.

In the example of loop trip counters on engine may count a number of times a given code loop in the logic design specified by kernel iterates e.g. may count a number of times counter iterates prior to the loop ending . Counters may maintain count values that are included as a portion of emulated profile data .

Load store monitoring engine may monitor activities of one or more load store units LSU emulated using emulation engine e.g. one or more LSUs identified by kernel that are emulated at engine while modeling how device would perform when implementing the logic design specified by kernel . An LSU is an instruction or corresponding hardware implementing an instruction that reads or writes a single value from a specified address in memory. For example for every emulated LSU a first counter and a second counter on engine may maintain respective count values reflecting a maximum and a minimum address value accessed by the emulated LSU. A third counter on engine may maintain a count value that reflects a number of cycles the emulated LSU is stalled. A fourth counter on engine may maintain a count value that reflects a number of cycles the emulated LSU is active. A fifth counter on engine may maintain a count value that reflects a number of cycles the emulated LSU is idle. A sixth counter and a seventh counter on engine may maintain respective count values reflective of cache hits and cache misses to the emulated LSUs that access caches.

Counter values generated by each of the counters on engine may be included as a portion of emulated profile data . Counter values generated by engine may for example be used for cache suitability and size analyses access pattern analyses and prefetching analyses when determining whether to adjust the logic design for device e.g. at HDL compiler . If desired engine may perform range analysis operations on the emulated device to perform aggressive memory dependence removal e.g. removal of assumed conservative code dependencies .

Block execution monitoring engine may monitor block execution in the emulated device. A block may for example include a set of instructions or hardware implementing the set of instructions with no branching between the set of instructions hardware. As an example a counter on engine may generate a count value that reflects how many threads execute a given block or how many times the block is executed. The counter count values maintained by block execution monitoring engine may form a portion of emulated profile data .

If desired block execution monitoring engine may monitor branch probabilities basic block criticalities and relative instruction criticality. Monitoring of relative instruction criticality may allow for a finer grained decision on which instructions within blocks to execute than only monitoring block criticality e.g. than only making decisions about which blocks to execute . Information about branch probabilities block criticalities and relative instruction criticality monitored using engine may form a portion of emulated profile data .

Thread execution monitoring engine may monitor a number of threads executed by the emulated device. A thread is a set of inputs to a kernel. Monitoring engine may for example include a counter that generates a counter value that reflects a number of threads executed. The counter value generated by monitoring engine may form a portion of emulated profile data . If desired thread execution monitoring engine may identify possible thread and iteration divergence points in the emulated device code and may include information about the divergence points as a portion of emulated profile data .

If desired emulation engine may include barrier monitoring engine . A barrier is a construct that requires all threads to enter the barrier before any thread can exit the barrier. A simple barrier is used when threads do not use thread identifiers to make control flow decisions. A re ordering barrier is used when threads do use their identifiers for control flow decisions allowing threads to enter the barrier out of order. For every re ordering barrier a bit may be stored as logic 1 if all instructions enter the re ordering barrier in order and may be stored as logic 0 if not all instructions enter the re ordering barrier in order. The bit and or other desired barrier information may form a portion of emulated profile data .

If desired emulation engine may include a variable latency instruction monitoring engine . A variable latency instruction is an instruction that may take a variable time to complete depending on its inputs and the overall state of the system. The monitoring engine may for example include counters that track the latency of one or more variable latency instructions. For example a first counter may generate a counter value reflecting the maximum latency of a variable latency instruction and a second counter may generate a counter value that reflects a minimum latency of the variable latency instruction. The counter values generated by the variable latency instruction monitoring circuitry may form a portion of emulated profile data .

The example of is merely illustrative. In general any desired profile generating tracking engines may be formed on emulator for monitoring the emulated performance of the system to be implemented on device . For example emulation engine may generate statistics and timing analysis identifying critical paths and information such as information about the compiled design such as size and location of components that are included as a portion of emulated profile data . Emulation engine may if desired generate emulated area values reflecting an area required to implement the system for device and emulated slack values that identify for each hardware block that corresponds to a single high level instruction a worst slack value of a path that goes through the hardware block.

At step compiler may synthesize the logic system identified by optimized code e.g. the HDL file incorporating the identified optimizations as generated while processing step of . Synthesis may include for example generating a particular logic design to be implemented by device based on code . For example synthesis may generate a logical representation of the system from the HDL design definition. Synthesis may include mapping the optimized logic design. Mapping may include determining how to implement logic gates and logic elements in the optimized logic representation with specific resources on target device . As an example a netlist may be generated from the mapping. The netlist may be a technology mapped netlist generated from HDL .

At step compiler may perform placement and routing operations on the synthesized logic design. Placement may include placing the mapped and optimized logical system design on target device . For example placement may work on the technology mapped netlist to produce a placement for each of the functional blocks of the netlist. If desired placement may include fitting the logical system on target device by determining which resources on logic device are to be used for specific logic elements and other function blocks identified for implementing the system during synthesis. Placement may include clustering which involves grouping logic elements together to form the logic clusters present on target device .

Routing may include allocating routing resources on target device to provide interconnections between logic gates logic elements and other components on target device . Routability optimization may be performed on the placed logic design if desired. Routability optimization may reduce the amount of wiring used to connect components in the placed logic design. Routability optimization may include performing fanout splitting logic duplication logical rewiring or other procedures.

At step compiler may perform timing analysis on the placed and routed optimized logic design. Timing analysis may determine whether timing constraints of the system are satisfied.

At step compiler may modify the design for the system in response to the timing analysis. For example compiler may modify the design for the system in response to determining that the timing constraints have not been satisfied by re performing placement and routing operations resynthesizing the logic design or by performing any other desired modifications.

At step compiler may perform assembly operations to assemble optimized configuration data e.g. including the logic design identified by HDL . The assembly operations may include for example generating a program file that includes the information determined at steps . The program file sometimes referred to herein as an optimized program file may include optimized configuration data that includes a bit stream used to program target device e.g. using configuration device of .

In the example of steps may be performed by circuit design tools on logic design system . For example the circuit design tools may be implemented on a first computer system. The optimized data file e.g. optimized configuration data may be transmitted to configuration device implemented on the first computer system or on a second computer system that is separate from the first computer system. Configuration device may load target device with optimized configuration data . By programming device with optimized configuration data components on target device are physically transformed to implement the optimized logic system without needing to generate profile data at device e.g. using components on device to drive the optimizations to the logic design generated at logic design system .

Emulated profile data generated by emulator may identify blocks of the logic design in code that were not executed during emulation of the device e.g. emulator may identify blocks that go unexecuted during the emulation of the device and may indicate those blocks in emulated profile data . For example counter values generated by block execution monitoring engine in emulated profile data may identify blocks of code that were not executed during emulation.

At step engine may modify the blocks in code that are not executed during the emulation for generating optimized HDL . For example engine may implement the unexecuted blocks in an area efficient manner disregarding any throughput requirements or optimizations. In another suitable arrangement hardware associated with the unexecuted blocks may be completely removed when generating optimized HDL . In a scenario where the unexecuted block represents an entire kernel all sub blocks within that kernel may be removed for example.

Emulated profile data may identify loops that are infrequently executed and loops that are frequently executed during emulation of the device. For example counter values generated by loop trip counters in emulated profile data may identify infrequently executed loops and frequently executed loops. A loop may be identified as being infrequently executed if a counter value for a first block inside the loop body divided by a number of threads executed by the emulated system is less than a predetermined threshold value. A loop may be identified as being frequently executed if a counter value of a first block in the loop body divided by the number of threads executed by the system over a given time is greater than the threshold value.

At step compiler may re roll the code loops identified by emulated profile data as being infrequently executed. Loop re rolling transforms two or more consecutive blocks with the same functionality into a loop containing a single block with the same functionality. The resulting loop with the single block will produce the same result as the original two or more blocks that were re rolled. Re rolling may also be applied to an existing loop having two or more consecutive blocks with the same functionality. In this scenario the re rolling transforms the existing loop by replacing the two consecutive blocks with a single block and increasing the iteration count of the loop to produce the same result.

At step compiling engine may unroll code loops identified in emulated profile data as being frequently executed. Loop unrolling involves fully or partially replacing a loop body with a repeating sequence of blocks that include the original loop body without changing the functionality of the overall program.

Emulated profile data may identify blocks that are infrequently executed during emulation of the device.

For example counter values maintained by block execution engine may identify which blocks are frequently or infrequently executed during emulation of the device.

At step compiler may implement infrequently executed blocks in an area efficient manner. For example compiler may pre compute the beginning of a kernel of an infrequently executed block and may store the pre computed value in memory. This may remove the area required for the block on the target device and adds an LSU to re populate the data inside registers on device . In another suitable arrangement a lower area higher latency implementation for the infrequently executed block may be selected.

At step a pipeline implementation is selected in response to the worst emulated slack value associated with a section of the system. For example for instructions associated with a section of the system having a relatively small emulated slack value as identified by emulated profile data a higher pipelined implementation is selected for that section. For instructions associated with a section of the system having a relatively large emulated slack value a lower pipelined implementation may be selected for that section. Pipelining may involve breaking up a hardware implementation of the logic design into multiple stages each separated by registers. Each stage may execute a computation for a different thread. An instruction implemented with two sets of pipelining registers can process three threads at the same time for example whereas an instruction implemented without pipelining can process only a single thread at a time. Determining whether the emulated slack value is small or large may be achieved by comparing the emulated slack value with a predetermined threshold value.

At step compiler may modify the design of the system in response to emulated profile data associated with emulated LSUs. For example a cache size in optimized HDL may be selected or adjusted in response to emulated profile data on its corresponding LSU. As another example global and or local memory architectures may be adjusted in response to the emulated profile data on a corresponding emulated LSU. In this scenario counter values generated at load store monitoring engine may be used to determine which global and local memory banks an emulated LSU is accessing. This information may be used to arbitrate networks for the local and global memory and identify a number of banks and ports to allocate for the local memory. In other examples compiler may determine which LSUs to alias and may determine which LSUs are used to allocate device memory based on the emulated profile data.

At step compiler may remove control logic associated with a variable latency in a basic block having a fixed latency as identified by emulated profile data . For example a variable latency instruction having a minimum latency equal to a maximum latency may be a fixed latency instruction. The removal of control logic associated with the variable latency allows the system to conserve area and may increase the maximum frequency of the block which leads to improved throughput.

At step compiler may transform a reorder barrier identified by emulated profile data to a simple barrier when instructions enter the reordering barrier in order. By transforming the reordering barrier to a simple barrier the area for implementing the barrier on target device is reduced.

At step compiler may process emulated profile data to identify instructions in code that are not enabled all of the time and may adjust the code to be implemented in optimized HDL so that the code shares instances of hardware for such instructions. If some instructions are not enabled most of the time the instructions may share a single hardware instance among multiple calls. Hardware sharing may be achieved by having multiple call sites make request to the hardware instance to perform the computation. The requests are arbitrated to ensure that they are serviced at a rate supported by the hardware instance.

At step compiler may identify sections of logic for replication. Replicating a section of logic is advantageous only if the performance of the section is not limited by access to global memory. The number of copies to replicate the section of logic may be guided by the maximum stall ratio of the emulated LSUs within the section and the hardware area used by the section.

The example of is merely illustrative. In general any desired optimizations may be performed by compiler on code for generating optimized HDL based on emulated profile data . If desired one or more of the steps of may be omitted. The steps of may be performed in any desired order and or two or more of the steps may be performed concurrently.

Examples of other optimizations that may be performed at compiler may include for example providing an overall throughput report e.g. as performance report file or other report files to a user of design system . Such reports may guide the user to future code changes that could be made by the user when generating high level description . If desired compiler may provide the user of design system with an estimate of how code would behave after the optimizations and while implemented on target device e.g. an estimate of how optimized data would perform when implemented on device . If desired compiler may convert Initiation Interval II values in the report to useful feedback for the user of system . The performance reports generated by compiler may provide faithful performance information about the logic design for target device after a set of optimizations without the need for time expensive HDL compiling iterations and extraction of profile data generated at device itself.

If desired compiler may perform automatic design space exploration for throughput area power and or latency e.g. engine may autonomously determine what to optimize in code based on emulated profile data without additional user input . In another suitable arrangement a user of system may control compiler to perform desired optimizations some or all of the optimizations shown in or other optimizations .

If desired compiler may use emulated profile data to drive automatic partitioning of work across multiple devices e.g. two or more devices in a multi device heterogeneous system . For example compiler may perform optimizations based on emulated profile data by optimizing allocations of kernels onto each of the devices in the multi device system.

Computer system may include memory e.g. memory as shown in . Memory may store instructions and code represented by data signals that are executed by processor . Data storage device may be coupled to bus . Data storage device and memory may include for example non volatile memory and or volatile memory. High level compiling engine profile data emulation engine and HDL compiling engine of may reside on memory and or data storage and may be executed by processor for example.

Computer system may include a network control interface such as network controller coupled to bus . Network controller may link computer system to a network of computers not shown and may support communication between computers on the network. System may include display circuitry such as display device controller coupled to bus . Display controller may allow coupling of a display device not shown to computing equipment and may act as an interface between the display device and computing equipment . A user input interface such as input interface may be coupled to computer system and may transmit signals e.g. user input signals or commands from an input device not shown to computer system .

The foregoing is merely illustrative of the principles of this invention and various modifications can be made by those skilled in the art without departing from the scope and spirit of the invention. The foregoing embodiments may be implemented individually or in any combination.

