---

title: Systems and methods for performing hooking in a jitted environment
abstract: A computing device configured for replacing a target method in intermediate language code is described. The computing device includes a processor. The computing device also includes memory in electronic communication with the processor. The computing device further includes instructions stored in the memory. The instructions are executable to import a hook method and hook type into a caller method module. The instructions are also executable to replace, in intermediate language code, any call to the target method in a caller method body with a call to the hook method. The instructions are further executable to compile the intermediate language code to assembly language code. The instructions are additionally executable to call the hook method in place of the target method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09298432&OS=09298432&RS=09298432
owner: STEALTHbits Technologies, Inc.
number: 09298432
owner_city: Hawthorne
owner_country: US
publication_date: 20150312
---
The present disclosure relates generally to computers and computer related technology. More specifically the present disclosure relates to systems and methods for performing hooking in a JITTED environment.

The use of electronic devices has become an everyday use in modern society. The use of electronic devices has increased as the cost of electronic devices has declined. The capabilities of electronic devices have also increased and allow people to use electronic devices in many different industries and for many different purposes. For example electronic devices may be used to perform tasks at home work or school. One type of an electronic device is a computer.

The technology being used in computers has been improving rapidly. Computers may range from small hand held computing devices to desktop computer systems to large multi processor computer systems. In order to use a computer software is designed and saved in a computer s memory. The software may be used to access applications stored on the computer or may include the applications themselves. These pieces of software allow the computer to become a tool capable of performing tasks requested of a user. For example a computer may include an application that allows users to communicate via e mail or perform other tasks for users.

In some instances a user may want more features and or functions than an application provides. Without access to the source code however a user may be unable to add more features and or functionality to an application. As can be observed from this discussion systems and methods that improve application modifiability may be beneficial.

A computing device configured for replacing a target method in intermediate language code is described. The computing device includes a processor. The computing device also includes memory in electronic communication with the processor. The computing device further includes instructions stored in the memory. The instructions are executable to import a hook method and hook type into a caller method module. The instructions are also executable to replace in intermediate language code any call to the target method in a caller method body with a call to the hook method. The instructions are further executable to compile the intermediate language code to assembly language code. The instructions are additionally executable to call the hook method in place of the target method.

The hook method may call the target method. The instructions may be executable to obtain a caller method module token a target method module token and a hook method module token. The instructions may be executable to obtain a caller method type token a target method type token and a hook method type token. Compiling the intermediate language code may include recompiling the intermediate language code by a just in time JIT compiler. The intermediate language code may originate from a Microsoft .NET managed environment. The target method may be a Microsoft Exchange method.

A method for replacing a target method in intermediate language code is also described. A hook method and a hook type are imported into a caller method module. Any call to the target method in a caller method body is replaced in intermediate language code with a call to the hook method. The intermediate language code is compiled to assembly language code. The hook method is called in place of the target method.

A non transitory tangible computer readable medium for replacing a target method in intermediate language code is also described. The computer readable medium includes executable instructions. The instructions are executable to import a hook method and hook type into a caller method module. The instructions are also executable to replace in intermediate language code any call to the target method in a caller method body with a call to the hook method. The instructions are further executable to compile the intermediate language code to assembly language code. The instructions are additionally executable to call the hook method in place of the target method.

The hook method may be a method that replaces a target method . For example a hook method may replace the functionality of a target method with the functionality of the hook method . For instance the hook method may be called by the application instead of the target method . In some configurations the hook method may collect or manipulate data within the application . In one specific example the application may be an email application that allows multiple users to utilize email for on a single account. However the email application may not provide for tracking of certain user activity. In this example a hook method may be injected into the application to allow for tracking user activity. For instance the hook method may perform a security verification to ensure a user has proper security credentials to access certain data or to perform certain operations with the application .

In a known approach hooks are injected into computer code e.g. source code for an application in an unmanaged environment. In an unmanaged environment source code e.g. computer code that has not been compiled may be accessible. This approach injects hooks directly into source code and then the computer code is compiled into assembly language. The application is accessed and the hook method is performed instead of the target method . In another known approach hooks are injected into compiled assembly language code.

Recently a managed environment has been introduced for computer coding. A managed environment is an environment where the source code of an application is compiled into intermediate language code. In a managed environment the original source code may not be accessible to the injection module for example .

The systems and methods disclosed herein allow the hook method to be injected into intermediate language code e.g. managed code that is created in a managed environment e.g. a managed development environment . The intermediate language code may be partially compiled in that the source code has been compiled and may not be accessible. Furthermore intermediate language code is not yet compiled into assembly language code. In some configurations the intermediate language code may be a platform independent language.

In accordance with the systems and methods disclosed herein the computing device may inject the hook method into the target method module of the application in intermediate language. The intermediate language including the injected hook method may be compiled into assembly language code which may be executed by the computing device . Accordingly after injection the assembly language code related to the application may include the hook method . The computing device may also replace in the intermediate language code calls to the target method made by the caller method . The hook method may be called by the application instead of the target method . For example the functions within the hook method may be performed by the application . In some configurations the target method may be called by the hook method or application as well. For example the target method may be called after the hook method is complete based on a value returned by the hook method . Another situation where the target method may be called after completing the functions included within the hook method may be where the function in the hook method outputs information intended to be used by the target method . It should be noted that while functions are described in terms of particular modules herein additional or alternative modules and or a combination of modules or a sub part of a module may perform one or more of the functions described herein.

The computing device may replace in intermediate language code any call to the target method in a caller method body with a call to the hook method . For example the computing device may overwrite in memory for example any call to the target method in a caller method body with a call to the hook method .

With the hook method properly injected into the intermediate language code the computing device may compile the intermediate language code to assembly language code. For example the computing device may just in time JIT compile the intermediate language code into assembly language code.

The computing device e.g. application may call the hook method in place of the target method . For example the computing device may execute the assembly language code which includes the injected hook method . For instance because any call to the target method from the caller method has been replaced with a call to the hook method the hook method may be called in place of the target method .

Once function pointers are initialized a CLR compiling method e.g. compileMethod may be hooked using a native hook mechanism. For example the compiling method e.g. compileMethod may be triggered when intermediate language code is translated e.g. compiled into native code. For example the compiling method may be utilized in two cases to compile the intermediate language code. For instance the compiling method e.g. compileMethod may be triggered when a managed function was never called e.g. the first time that a managed function is called and or when recompiling with a JIT compiler ReJIT for a method is requested. It should be noted that ReJIT was added in .NET 4.5 and was primarily targeted to be used in profilers. A profiler may be a tool that measures one or more metrics of a target application e.g. central processing unit CPU usage of one or more e.g. all methods memory usage application performance etc. .

If the initialization is completed successfully a domain monitoring function may be started in timer callback. A timer may be utilized since there may not be a way to retrieve notifications about the creation of new application domains in the application. Accordingly timer callback may periodically request a list of all application domains in the application. For new application domains a computing device e.g. timer may perform a function e.g. CreateInstanceFromAndUnwrap that forces creation of an instance of an injector installation type e.g. InjectorInstall in a specified domain.

The start domain monitoring method may subscribe a current domain on assembly load e.g. AssemblyLoad and assembly resolve e.g. AssemblyResolve events. Because applications may load dependencies as needed a target method that is desired to be hooked may be absent at a time when initialization is performed. Subscription on an assembly load e.g. AssemblyLoad event may be utilized to manage the issue. On an assembly load event a search for the function of interest e.g. the target method may be performed in the loading assembly. If the function of interest e.g. the target method and its scope e.g. the caller method is found an injection is triggered.

Subscription on the assembly resolve e.g. AssemblyResolve event may be beneficial particularly if the hook code e.g. hook method references code e.g. assembly code that is not part of the original application . Attempting to call a hook method may cause a dynamic link library DLL dependency to be resolved. In this handler the CLR may be provided with all needed dependencies.

Managed hooks may be represented by a hook class . The hook class may include caller binding properties hook method properties caller method properties target binding properties caller method name properties target method properties caller parameter properties target method name properties caller type properties target parameters properties caller type name properties target type properties hooked properties target type name properties an inject method and a remove method .

The hook class may contain information that identifies where the hooks are to be installed. In known approaches two methods are generally used to install a hook these methods are a target method and a hook method . Once a hook class is installed a call to the target hook may be redirected to the hook method .

The injection module may determine if a target method is already hooked. If the target method is already hooked the method may end . For example the injection module may determine if a hook method is already injected by checking an indicator or flag corresponding to the target method . For instance when a target method is hooked the computing device may mark e.g. set an indicator or flag corresponding to the target method as hooked. The target method may be unmarked when the hook method is uninstalled in some configurations.

If the target method is not already hooked the injection module may determine if a caller type is null. If the caller type is not null the injection module may determine if a target type is null. If the caller type is null the injection module may obtain the caller type from a current assembly using reflection. Reflection may be a procedure e.g. a feature of the framework that allows retrieving information about the type e.g. caller type target type etc. of any instance at runtime. Reflection may also allow retrieving information about one or more loaded assemblies one or more types e.g. target type caller type etc. in the assemblies one or more methods e.g. target method caller method hook method etc. and or attributes in the types one or more parameters and or one or more return types in the method s . In some configurations reflection may be provided by the .NET framework. Accordingly any instance at runtime may have a reference to its original type.

The injection module may determine if a target type is null. If the target type is not null the injection module may determine if a caller type is not null and caller method is null. If the target type is null the injection module may obtain the target type from the current assembly using reflection.

The injection module may determine if the caller type is not null and caller method is null. If the caller type is null or the caller method is not null the injection module may determine if the target type is not null and the target method is null. If the caller type is not null and caller method is null the injection module may obtain the caller method using reflection.

The injection module may determine if the target type is not null and target method is null. If the target type is null or the target method is not null the injection module may determine if the target method is not null the caller method is not null and the hook method is not null. If the target type is not null and the target method is null the injection module may obtain the target method using reflection.

The injection module may determine if the target method is not null the caller method is not null and the hook method is not null. If the target method is null the caller method is null or the hook method is null the injection module may end the method .

If the target method is not null the caller method is not null and the hook method is not null the injection module may perform the substitute method. One example of the substitute method is discussed in relation to below. The injection module may determine if the substitute method was successful. If the substitute method was successful the injection module may mark the target method as hooked and the method may end . If the substitute method was not successful the method may end .

The target method and hook method may be compatible if the values returned by these various checks and input parameters type are the same or if either the return value or input parameters type is not void and the other method has an object type.

In some configurations the substitute method may be performed by an injection module located within a computing device . The injection module may determine if target method and hook method return types are compatible. For example the target method and the hook method may be compatible if the target method return type is void e.g. the target method returns void and the hook method return type is also void e.g. the hook method returns void . In another example assume that the target method return type is not void and the hook method return type is also not void. In this case if the hook method returns the same type as that of the target method or if the hook method returns an object type then the return types may be compatible. Otherwise the return types may not be compatible. If the target method and a hook method return types are not compatible the hook method cannot be installed and the substitute method ends .

If the target method and a hook method return types are compatible the injection module may determine if the target method is static. If the target method is static the injection module may determine if the target method and hook method parameters are compatible. Since the target method is static the parameter count in the hook method and target method should be the same. For example if the number of parameters in the target method is equal to the number of parameters in the hook method then the target method and the hook method may be compatible. Otherwise the target method and the hook method may be incompatible. If the target method and hook method parameters are not compatible the hook method cannot be installed and the substitute method ends .

If the target method is not static the injection module may determine parameter compatibility of the target method and the hook method . For example the computing device e.g. injection module may determine a number of parameters e.g. parameter count of the target method and a number of parameters e.g. parameter count of the hook method . Since the target method is not static in this case the parameter count in the hook method and the target method should be different by one. For instance the parameter count of the target method should be one less than the parameter count of the hook method due to the automatic this parameter of the non static target method . In one specific example void TargetMethod int p1 should be one less than static void HookMethod object self int p1 . In other words the parameter count of the hook method should be one more than the parameter count of the target method due to the automatic this parameter of the non static target method . Accordingly the parameter compatibility determinations for the static and non static cases may be different. In particular in the case of a static target method the comparison is more direct because there is no automatic this in the static target method and the number of parameters in hook method and the target method should be equal and types compatible. In the case of the non static target method the automatic this may be taken into account. If the target method parameters and the hook method parameters are not compatible the hook method cannot be installed and the substitute method ends .

If the target method parameters and the hook method parameters are compatible the injection module may obtain a method handle e.g. caller.MethodHandle.Value for the caller method target method and hook method . The injection module may obtain caller module e.g. MethodInfo.Module.MetadataToken target module and hook module tokens. A token may be a four byte integer number that describes a function s managed function managed property or managed instance. In one example tokens may be utilized in .NET .. A token corresponding to an original method may be replaced by a token corresponding to a hook method

The injection module may obtain caller type e.g. Methodlnfor.ReflectedType.MetadataToken target type and hook type tokens. The injection module may call a native substitute hook installer e.g. Substitute Method and install the hooks in an application . The substitute method may end .

The injection module may determine if the caller module is equal to the target module. If the caller module and target module are not equal the injection module may perform a pseudo import of target method to the caller module to define appropriate method token and type token of target method in the caller module. An example of importing is given in connection with . A token corresponding to an original method may be replaced by a token corresponding with a hook method .

The injection module may complete the initialization of the substitution hook. If the injection module determines that the caller module and the target module are equal e.g. are the same module the injection module may store input parameters in the target type and target method tokens. For example the target type and target method tokens may be stored in the caller module. The injection module may complete the initialization of the substitution hook.

The method may be performed by an injection module located within a computing device . The injection module may obtain source method descriptor destination method descriptor and source type token. The injection module may determine if the .NET version is 4.5. If the .NET version is not 4.5 the import failed and the initialization process is complete . It should be noted that the systems and methods disclosed herein may be applied to other versions of .NET.

If the .NET version is 4.5 the injection module may obtain method descriptor using an undocumented method e.g. GetLoaderModule to allow access to the module of the source method. The injection module may retrieve metadata of the source module. In some configurations this may be accomplished using an undocumented method e.g. GetReadablePublicMetaDatalnterface of the Module class . The metadata retrieved may include the IMetaDataAssemblyImport and IMetaDataImport interface of the source module for example. The injection module may obtain a method descriptor. In some configurations the method descriptor may be obtained using an undocumented method e.g. GetLoaderModule to allow access to the module of the destination method. The injection module may retrieve metadata of the destination module. In some configurations this may be accomplished by using an undocumented method e.g. GetReadablePublicMetaDataInterface . The metadata retrieved may include the IMetaDataAssemblyEmit and IMetaDataEmit interface of the destination module for example. The injection module may create a reference using an import type e.g. DefineImportType to the type that holds the source member and define a type token in the destination e.g. caller method module for that reference. The injection module may create a reference using an import member e.g. DefineImportMember to the source member and define a method token in the destination e.g. caller method module for that reference. The source type imported token and source method imported token may be returned by the injection module and the initialization process may be complete .

The injection module may determine if hooks are required to set for a specified caller method . If it is determined that hooks are required the injection module may substitute a hook through a pre compiler. Substituting the hook through the pre compiler may substitute a hook prior to compiling an intermediate language into assembly language. One example of substituting a hook through the pre compiler is discussed in . When the hook pre compile is complete the injection module may call an original CLR compile method. The injection module may call the original CLR compile method if the injection module determines hooks are not required for a specified caller method .

The injection module may determine if a hook is found in the compiled code. If a hook is found the injection module may restore the caller method to its original state before hooking for instance . For example in post compile the caller method intermediate language body may be restored to its original state. For instance the injection module may replace one or more calls to the hook method with one or more calls to the target method. In some configurations the injection module may substitute a hook through a post compiler. The post compiler may be used to remove hook methods from target methods . The hook may be destroyed by removing any token or call to the hook method in the caller method . The method may end once any hook methods are destroyed. The method may end if the injection module determines a hook was not found.

The injection module may save previous call instruction code that was used to call the target method . The injection module may restore memory permission rights on the caller method intermediate language code.

After a hook e.g. hook method is imported native DLL B may include a NativePart.dll in addition to the libraries of computer code e.g. A.dll B.dll . . . Z.dll that may be used by one or more application domains B . The computer code located within native DLL B may also be used by one or more application domains at the same time. One or more application domains B may include managed code e.g. A.net.dll B.net.dll C.net.dll etc. . After a hook is imported one or more application domains B may also include a ManagedPart.dll and a HooksDependencies.dll.

NativePart.dll may be a native dynamic link library that includes native methods that may be used during a hooking process. The native methods may include initialization of undocumented CLR method pointers a hook function for the CLR CompileMethod a set of functions for creating a substitute hook requesting reJIT compiling and or managing metadata. ManagedPart.dll may be a managed dynamic link library that includes methods that are also used during a hooking process. The managed part methods may include initialization of an application domain resolving loading assemblies searching for a target method in loaded assemblies creating a managed part of hooks and or monitoring application domains. HooksDependencies.dll may be a set of managed dynamic link libraries that may be utilized e.g. required when a hook method is compiled. For example HooksDependencies.dll may include logic that extends the functionality of the target application.

The email server may include a permission management module a shared folder and or a rights ID . The email server may run an email system e.g. Microsoft Exchange to store the information to be accessed by email clients A C . One example of information stored within the email server may be the shared folder . The shared folder may include files to be attached to emails or other information to be used e.g. accessed attached to emails modified etc. by user computer A and or user computer B . The permission management module may include a permission managed method . The permission management method may manage user permission e.g. authorization authentication access etc. . For example the permission management method may verify permission of a user that is attempting to access the information located within the email server e.g. the shared folder . The permission management method may determine a user has the proper rights to access particular information located within the email server by utilizing the rights ID . The rights ID may include the status of each end users current permission rights.

The permission management method may have limited functionality. The hooked permission management method may be injected as described above in connection with one or more of . For example the hooked permission management method may be imported e.g. injected to provide additional and or different functionality.

In some configurations the hooked permission management method may include functions to improve security or tracking features of the email server . For example a first user may desire to authorize a second user to access the first user s email information and or functionality. For instance user computer A may provide e.g. license delegate etc. permission to user computer B e.g. a particular user on computer B to access account information stored for user computer A . It should be noted that the following examples may be described in terms of user computer A and user computer B . However one or more of the following examples may be applicable to any computer on the computer network that is being utilized by one or more particular users e.g. users with particular identification logins and or credentials . Accordingly for example user computer A may be any computer on the computer network that is being utilized by a first user and user computer B may be any computer on the computer network that is being utilized by a second user.

In some configurations the hooked permission management method may add a function that tracks when user computer B logs in and logs out of the email account for user computer A . Additionally or alternatively the hooked permission management method may add a function that tracks what files and other information user computer B accessed while logged in.

Additionally or alternatively the hooked permission management method may create a blacklist or whitelist of email accounts user computer B may send emails to while logged into the account for user computer A . Another additional or alternative tracking function that may be added by the hooked permission management method is tracking what computer physical location and or network user computer B has logged into the email account from.

In some configurations the hooked permission management method may add security features to increase the control a first user of user computer A for example has over the actions of a second user of user computer B for example while using the account of the first user. For example the hooked permission management method may add a function to limit what information can and cannot be deleted by user computer B . Additionally or alternatively the hooked permission management method may block user computer B from moving information or may only allow information to be moved to particular locations. The ability to limit or block entirely the option to attach files to emails by user computer B may also be a feature added by the hooked permission management method . Another example of a security feature that may be added by the hooked permission management method is automatically courtesy copying a first user or user computer A on any emails sent by user computer B while accessing the account for the first user.

In some configurations the hooked permission management method may restrict access for a user from a particular computer e.g. user computer B network or physical location. For example the hooked permission management method may not allow user computer B to log in to the account for user computer A if user computer B is a public or unknown computer. Additionally or alternatively the hooked permission management method may provide an ability to block access to user computer B outside of a particular time frame. For example user computer B may be able to access the account for user computer A only during regular business hours only and may be blocked from accessing the account outside of that window of time. Additionally or alternatively the hooked permission management method may add or restrict access to information located within the shared folder .

It should be noted that additional or alternative methods besides the hooked permission management method for example may be hooked. For example one or more other methods may be hooked that may enable sending emails filtering recipient lists blocking sending and or adding one or more other accounts to the recipient list etc. It should also be noted that while the systems and methods disclosed herein may be applied to Microsoft Exchange as an example the systems and methods disclosed herein may be applicable to a wide variety of applications using .NET for instance .

The computing device may communicate with other electronic devices through one or more communication interfaces . Communication through the communication interface may be achieved through different methods such as wired communication wireless communication or both wired and wireless communication. For example the communication interface may be a serial port a parallel port a Universal Serial Bus USB an Ethernet adapter an IEEE bus interface a small computer system interface SCSI bus interface an infrared IR communication port a Bluetooth wireless communication adapter and so forth.

The computing device may receive and transmit information through one or more input devices and one or more output devices . The input devices may be a keyboard mouse microphone remote control device button joystick trackball touchpad lightpen etc. The output devices may be a speaker printer etc. A display device is an output device that may be included in a computer system. Display devices may project information through different technologies such as liquid crystal display LCD light emitting diode LED gas plasma electroluminescence a cathode ray tube CRT or the like.

A processor controls the operation of the computing device and may be a microprocessor a microcontroller a digital signal processor DSP or other device known in the art. A memory may be included in the computing device and includes instructions and data to assist the processor in operating the computing device . The memory may send program instructions and or data to the processor in order for the processor to perform logical and arithmetic operations according to methods disclosed herein. The processor may execute one or more of the instructions stored in the memory to implement one or more of the systems and methods disclosed herein.

Data stored in the memory may be converted to text graphics and or moving images as appropriate by a display controller . Of course illustrates only one possible configuration of a computing device . Various other architectures and components may be utilized.

In this application various terms have been connected to reference numbers. The reference numbers are for an element in the one or more Figures. If a term is not connected to a reference number the term is meant more generally and without limitation to any particular Figure.

In this application the term determining has been used. The term determining is meant to cover several different actions and therefore some examples of determining are computing calculating processing investigating looking up e.g. looking up in a table a database or another data structure ascertaining and the like. The term determining also covers resolving selecting choosing establishing and the like. The term determining can also cover receiving information or accessing information.

In this application the term based on means more than based only on except where expressly stated. The term based on describes both based only on and based at least on. 

In this application the term processor is meant to be broadly interpreted and covers a general purpose processor a central processing unit CPU a microprocessor a digital signal processor DSP a controller a microcontroller a state machine and so forth. Under some circumstances a processor may refer to an application specific integrated circuit ASIC a programmable logic device PLD a field programmable gate array FPGA etc. The term processor may also be a combination of several processing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

In this application the term memory is meant to be broadly interpreted and covers electronic storage devices capable of storing information electronically. The term memory covers various types of memory technology such as programmable read only memory PROM random access memory RAM read only memory ROM erasable programmable read only memory EPROM non volatile random access memory NVRAM electrically erasable PROM EEPROM flash memory magnetic or optical data storage registers etc. A processor and memory are in electronic communication where the processor can read or write information located within the memory. Memory that is integral to a processor is in electronic communication with the processor.

In this application the terms instructions and code are meant to be broadly interpreted and cover code or statements that are computer readable. For example the terms instructions and code may cover programs routines sub routines functions procedures etc. of assembly language code or intermediate language code.

In this application the term computer readable medium covers any available medium that a computer or processor can access. For example a computer readable medium may comprise optical disk storage such as RAM ROM EEPROM CD ROM any magnetic disk storage devices or any other medium for carrying or storing instructions and code that can be accessed by a computer or processor. A computer readable medium may be non transitory and tangible. The terms disk and disc cover compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc disks typically are used for data magnetically accessible and discs typically are used for data optically accessible through lasers.

Instructions and code may be transmitted over a transmission medium. Instructions and code may also be called software. For example software may be transmitted from a website server or other remote source. The transmission medium may be a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave.

In this application the methods comprise steps or actions for achieving the functions and processes described above. The method steps are to be understood as interchangeable with one another. The interchanging of a step is not to be understood as departing from the scope of the claims. In this application the order of steps and actions may be modified and not depart from the scope of the claims unless a specific order is stated for the steps or actions being described.

The claims are to be understood to not be limited to the exact configuration and components discussed above. The claims are to be understood to cover any reasonable modifications changes and variations of the arrangement operation and details of the systems methods and apparatus described herein.

