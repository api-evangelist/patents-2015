---

title: Apparatus and methods for organizing data items by directed graph
abstract: A data structure for storing items of information having a time of validity includes a validity interval for each item of information, and methods for making and using the same. The items of information are organized in a data structure having nodes and edges connecting the nodes. This data structure is preferably a directed graph structure that may include cyclical nodes. The data structure includes parent nodes and child nodes. The validity interval specified for any child node generally is contained within the validity interval specified for that child node's parent node, such that the data structure includes no child nodes with a validity interval that falls outside of the validity interval of its parent node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262552&OS=09262552&RS=09262552
owner: Barr Rosenberg
number: 09262552
owner_city: The Sea Ranch
owner_country: US
publication_date: 20150107
---
This application is a continuation in part application of U.S. Nonprovisional application Ser. No. 14 183 112 filed on Feb. 18 2014now U.S. Pat. No. 8 959 096 which is a continuation in part application of U.S. Nonprovisional application Ser. No. 13 681 137 filed on Nov. 19 2012now U.S. Pat. No. 8 655 896 which is a continuation application of U.S. Nonprovisional application Ser. No. 12 713 131 filed on Feb. 25 2010 now U.S. Pat. No. 8 341 164. Priority to the prior applications is expressly claimed and the disclosure of the applications is hereby incorporated herein by reference in its entirety and for all purposes.

Most computer systems store and process information. This information is a model of objects in the real world including physical objects with all of their complexity and details. Sometimes it is possible to define ahead of time a clear data structure for a particular application or use of this real world data with the right level of accuracy. However much of the real world data stored and processed by modern computer systems cannot have a clear data structure imposed on it before it is understood what uses this data will be put to.

For example a system that captures information about companies and company relations to help decision making and risk analysis needs the flexibility to constantly re think or modify what information is stored. Adding new fields to a traditional database requires a global change to the whole schema. For example even if a given field of information is only relevant for a specific company the field is added to every company in the database. The only way to reliably and permanently remove information from a traditional database is to delete it. Any other mechanism such as marking the information as deleted exposes a risk of creating an inconsistent database because the related information remains in the database even though its underlying database entry is not valid anymore. Thus it is possible that this non valid data could be accessed by a user of the database creating unintended consequences or errors.

Thus there is a need for an apparatus and methods that permit data items which reflect facts about real world objects to be stored organized and manipulated using a structure that does not impose rigid structure to the data and that allows a set of stored data to be easily stored accessed updated and manipulated for a variety of purposes.

In an aspect of an embodiment disclosed herein a data item stored in the apparatus is represented as an entry comprising an item of information and a time of life interval for that item of information.

In another aspect of an embodiment of the invention the data items are stored in a directed acyclic graph having parent and child nodes.

In another aspect of an embodiment of the invention the time of life interval of a child node is always within the time of life interval of that child s parent node.

In another aspect of an embodiment of the invention the directed acyclic graph is updated with changed values by splitting a node containing the old value into a new node containing the changed value and a new time of life interval which begins as of the time of the change in value and retaining the old node with the old value and an updated time of life interval that is terminated as of the time of the change in value.

In another aspect of an embodiment of the invention relations between data items are represented by edge types within the directed acyclic graph.

In another aspect of an embodiment of the invention the directed acyclic graph is indexed using an index table.

In another aspect of an embodiment of the invention access to each data item is controlled by a permission list for that data item.

In another aspect of an embodiment of the invention the data items are accessed using a query language.

In another aspect of an embodiment of the invention the results of a query on the data items are expressed as a directed acyclic graph that is a subset of the queried data items.

In another aspect of an embodiment of the invention updates to the directed acyclic graph are made by merging a new directed acyclic graph with the existing directed acyclic graph.

In another aspect of an embodiment of the invention changed data in the directed acyclic graph is preserved using versioning to retain prior versions of the directed acyclic graph.

In another aspect of an embodiment of the invention legacy databases are transformed into directed acyclic graph data structures having parent and child nodes storing data items comprising an item of information and a time of life interval for that item of information such that the time of life interval of a child node is always within the time of life interval of that child s parent node.

In another aspect of an embodiment of the invention these legacy databases are merged into a larger directed acyclic graph data structure containing data from a plurality of legacy databases.

In another aspect of an embodiment of the invention this merged database is further transformed into a plurality of subset databases each subset database comprising data items from a plurality of the legacy databases.

In another aspect of an embodiment of the invention data items are stored as a directed graph including one or more cyclical nodes.

In a computer system used to store and process information this information can be stored as data in a variety of data structures. Some data is stored as tightly structured data typically when it is known ahead of time e.g. when the data is first captured what uses that data will be put to. However it is frequently difficult to anticipate all of the uses to which data will be put and thus tightly structured data can be inflexible. In such situations the data is structured instead using a more loose data structure that captures a minimal amount of useful structure without further constraining the data.

In an embodiment of the invention one particularly useful way of organizing data is to record the data in a data structure as shown in . This data structure is a directed acyclic graph DAG that structures information using parent child relationships. A directed acyclic graph is a directed graph with no directed cycles. That is it is formed by a collection of nodes and directed edges each edge connecting one node to another such that there is no way to start at a given node such as node and follow a sequence of directed edges that loops back to that same node again. A directed edge is an edge that is used to traverse the graph from one node to another node but only in one direction. For example the directed edge between nodes and permits traversal of the graph from node to but not from node to node

Nodes in the data structure can be related to other nodes through a child parent relationship. That is one node can be the child of another node . A node is a child of another node if the child node has a directed edge connecting from the child node in the direction of traversal to a parent node . For example node is a child of node in . Similarly a node is a parent of another node if the parent node has a directed edge connecting from the parent node against the direction of traversal of the directed edge to a child node . For example node is a parent of node in . Nodes may have multiple children or multiple parents. For example nodes and are both children of node . Similarly nodes and are both parents of node

The directed edges can be annotated with an edge type . Use of edge types permits the data structure to model certain types of parent child relationships. For example the node represents that there is an employment relationship between the person of node and the university of node . However the node standing alone does not indicate whether it is the person that is employed by the university or the university that is employed by the person. Both scenarios are possible in the real world. For example the person may be a scientist who works for the university. On the other hand the person may have hired the university to conduct some research. To distinguish between these two possibilities the directed edges and are annotated to indicate how the two nodes and are related to the node . In this example the edge type who indicates that the person is the who i.e. the employee whereas the edge type by indicates that the university is the by i.e. the employer . Similarly if the two parent nodes were each companies one of which owned the other then a common child node would be created to contain the fact ownership status and an edge of edge type owns would be connected to the owning company and a second edge of edge type owned would be connected to the subsidiary owned company.

In the embodiment of node represents a person. This node is a parent of nodes and and it is not a child of any other node. Node represents a university. This node is a parent of nodes and and it is not a child of any other node. Node is a child of node and represents the name of the person of node . Node is also a child of node and represents the employment status of the person of node . Node is also a child of node and represents that the university of node has an employee. Node is a child of node and represents the name of the university of node . Node is another child of node and also represents the name of the university of node but over a different time interval. Thus the data structure of represents the following information expressed in the English language Mary Smith is the name of a Person existing since i.e. born on Apr. 5 1974 and presently still alive. This person was employed by a university between Apr. 1 2002 and May 31 2008. The name of the university was State Polytechnic School between the years 1855 through 1910. Beginning in 1911 to the present day the university has the name State Technical University. 

Turning to in an embodiment of the invention each node in the data structure contains an information field which holds one item of information. Each item of information is one fact about a real world object. These real world objects can be physical objects such as a person or a school or a company or they can be intangible objects such as a share of stock in a company access permissions or budget positions. The item of information can be a simple numeric identifier used to distinguish one instance of the object from another. For example if the object is a person then the numeric identifier could simply signify that this object was person number that was stored in the data structure. Additionally the item of information can be a subsidiary fact or detail about a real world object. For example the item of information could be the name of a person the employment status of a person the name of a school the price of a particular company s stock or any other fact about a real world object. These subsidiary facts are generated as child nodes preferably at the same time as the parent node representing the real world object to the extent that the subsidiary facts are known at that point. The information field is assigned a data type such as Integer Double a field capable of holding an integer twice as large as the integer type String a series of text characters Date a point in time or Any a type which uses serialized storable space to represent an arbitrarily large piece of data .

Each node further contains a time of life field which contains a time interval which represents the period of time that the information in the information field is valid over. This time interval includes a beginning value and an ending value. If the time of life field is capturing information relating to the present state of a real world object then the time of life field can be set to a value which represents the current date and time and is constantly updated as time passes. In the example of the value MAX reflects that this node captures the present state of the fact about the real world object contained in information field . Alternatively the ending value could be left blank.

For example if an information field in a node contained a person item of information then the time of life field for that node would contain a time interval representing when that person was alive. Thus such a time interval would comprise the person s birth date and death date or an indication such as MAX or a blank field if the person was still alive. Similarly if an information field in a node contained a company stock value item of information then the time of life field for that node would contain a time interval representing the period of time for which that stock price value was valid. Thus the time of life field might indicate that the stock value for this particular company was valid beginning at 10 51 am on Jun. 4 2010 and ending at 10 52 am on Jun. 4 2010 i.e. the price was valid for one minute . Lastly each node contains a type field which records the type of information that is stored in the node. For example the nodes of include node types of Person Name Employed and University.

The ability to represent and capture the time of life for any given real world object is a useful part of modeling objects in the real world. The real world is constantly evolving over time and information about real world objects must be regarded relative to the time this information is valid. New real world objects can come into existence at any moment and others can be destroyed or lost forever. This includes both physical objects as well as the information connected to these physical objects. For example names and other attributes value temperature constantly change over time. Additionally real world objects can be related to each other for specific time intervals e.g. ownership marriage dependencies and then those relationships can change e.g. change in ownership divorce children growing up and moving out of the family home .

In a preferred embodiment of the invention the time of life of a child node must always fall within the time of life of the child node s parent node . The time of life of the child thus must be entirely contained by the time of life of the parent. Thus for example if the parent node contains a time of life field which provides that the time of life of the information in the information field of the parent node is from Jun. 4 2010 through Jul. 4 2010 then any child node to this parent node must have a time of life which begins no earlier than Jun. 4 2010 and ends no later than Jul. 4 2010. If the child node has a time of life which extends to for example Jul. 5 2010 then this child node would be improper and invalid. Similarly if this child node has a time of life which began for example on Jul. 3 2019 this child node would be improper and invalid. Should such nodes be found in the data structure they are preferably removed. Alternatively such nodes could be identified as invalid and left in the data structure. Being identified as invalid such nodes would not be searched represented to the user as valid nodes or be otherwise accessible.

Once the data structure has been created it may be updated as additional information about the real world objects being modeled becomes known. Since the data structure models real world objects which exist over the course of various time intervals and which change over time the information stored about these objects must be updated to reflect these time driven changes. In an embodiment when the value of a particular fact or information item changes a node of the data structure containing that fact is updated. Turning to the data structure is updated by locating the node who s value has changed for example the node containing the name of the person of node . The time of life interval for the information item stored in the node is updated by recording the end date time for the interval which indicates the last moment in time that this value was still valid in place of the MAX or blank entry or other indication that this node contained live as opposed to historical data. A new node is then split off from the updated node which contains the new value for the fact and a new time interval which begins at the same date time that the prior time interval ended and has MAX or blank entry or other indication that this node now contains the live value for this fact. For example the new node contains the changed value Mary Jones and a beginning date of Jun. 26 2006 to reflect the fact that Mary Smith changed her name to Mary Jones on that date.

Preferably information is never deleted from the data structure . Instead when the values for facts recorded in the nodes of the data structure change new nodes are split off from existing nodes as discussed above. If a previously unknown fact about a real world object is discovered then a new child node is created to reflect that fact and the current value for that fact. If available the prior values for that fact may also be provided as additional new child nodes to the parent node reflecting the real world object. Alternatively however information may be removed from the data structure entirely for example to conserve space in the storage medium containing data structure or to delete inaccurate information that should never have been recorded in data structure in the first place.

Note also that child nodes may themselves have children. For example the node of could itself have two child nodes and as shown in . The child node contains the first name of the person whose name is recorded in node . The child node contains the last name of the person whose name is recorded in node . If this person s name changes at some point in time that change can be captured in detail by the data structure . For example if the person gets married on Jun. 26 2006 and her last name changes from Smith to Jones this change is captured by splitting off a new child node containing the new last name. The end of the time interval recorded in node is then updated to Jun. 26 2006 and the beginning of the time interval in the new node is similarly updated to Jun. 26 2006 .

The data structure shown in may be generated using computer language instructions recorded on a computer readable medium. Further details about computer readable media used in embodiments of the invention are discussed below. In an embodiment the computer language instructions set forth in Table 1 are used to construct the data structure of . The instructions between the local instruction and the do instruction define the values I interval the time of life interval I journal the abstract interface to the journal structure I person I university I person name I university name I employed the various nodes of the data structure . The computer instruction at point 2 in Table 1 creates an empty journal data structure.

In this example the data structure is created in the memory of a computer. Alternatively the data structure may be created on a long term storage medium such as a hard drive floppy disk solid state memory device or similar devices. Where the data structure is created on a long term storage device it is preferable to store the data structure in a database. One example of such a database is the Microsoft SQL Server database available from Microsoft Corporation Redmond Wash. Another example is the Oracle DBMS system available from Oracle Corporation Redwood Shores Calif. Where the data structure is created in the computer memory it may be persisted i.e. a copy stored out to a database for long term retention. Additionally a hybrid implementation may be created where the data structure is stored in a database on a long term storage device and a portion of the data structure is cached in the computer memory. This hybrid permits the use of a data structure that is too large to place entirely in the computer memory while still realizing the performance benefits of in memory operations. Any of a variety of known algorithms may be used to determine which portions of the data structure will be placed in the computer memory. One example is to use a Least Recently Used caching algorithm wherein the node that has been accessed least recently is removed from the computer memory each time that a new node needs to be loaded in from the long term storage.

The computer instructions subsequent to 3 in Table 1 declare the types for each of the nodes in the data structure. Thus these instructions create empty nodes for the Person Name Employed and University nodes shown in . The computer instructions subsequent to 4 in Table 1 declare the types for any edges which require type information. Thus these instructions create edge types who and by which will be used for edges and in .

The computer instructions subsequent to 5 in Table 1 create the Person node of . The first instruction creates the start date for the time of life interval for the Person node with a start date of Apr. 5 1974 19740405 . The second instruction sets the end date to the MAX date. In this way the time of life interval reflects that the interval is still open because the person defined in the Person node is still alive. Once the person defined in the Person node passes away then the end date will be updated to reflect this fact. The third instruction creates the actual node labels it as a Person node and associates the interval created above to the node

The computer instructions subsequent to 6 in Table 1 create the Name node as a child of the Person node . Since the Name node is a child of the Person node it must in a preferred embodiment have a time of life interval that falls entirely within the time of life interval of the parent node . Thus the Name node is created to have the same time of life interval as the parent node . Alternatively if it is known at creation time that the name of the person is no longer valid i.e. the name is a prior name for the person that has subsequently changed then the time of life interval can be created with a different end date. Similarly the time of life interval can be created with a different start date as well to accurately reflect the historical state of when the person s name changed. The first instruction subsequent to 6 creates the Name node and also the directed edge which points to the parent node . The second instruction sets the value of the Name node to Mary Smith .

The computer instructions subsequent to 7 in Table 1 performs similarly as those discussed above but creates the University node and the Name node reflecting the original name of the university State Polytechnic School. The computer instructions subsequent to 8 in Table 1 create the Employed node . The first three instructions create the node setting the start and end dates for the interval and creating the empty node. The fourth and fifth instructions create the two directed edge types and respectively. These directed edge types and reflect that the Employed node has two parents nodes and each of which has a respective type of who and by to show the employed relationship as discussed above.

Finally the computer instructions subsequent to 9 in Table 1 create the new changed Name node for the University node . This new node is created by splitting the original Name node into two nodes. The original Name node is modified by the first instruction subsequent to 9 such that the end date for the time of life interval in the original Name node now reads Jan. 1 1911 . This end date is also used as the start date for the time of life interval in the new Name node which is also created by the first instruction subsequent to 9 . The end date for the new Name node retains the value MAX from the original Name node that it was split off from. The second instruction sets the value for the new Name node to State Technical University to reflect this change in the value of this real world fact about the university of node

To improve performance particularly when searching for a particular node in the data structure indexes can be created on the data structure . For example an index can be created for all of the Name nodes in the data structure . The index is preferably stored in memory and comprises a list of all of the Name nodes in the data structure along with a value that identifies the parent node for the Name node. Thus the index entry for the Name node would contain the value Mary Smith and a value that identifies i.e. points to the Person node . This allows a user to rapidly search the index of Names for the name Mary Smith and be directed to the node which represents that person. The index may be configured such that an index entry is automatically added to the index each time a Name node is added to the data structure . Similarly the index entry for a Name node may be automatically removed when the corresponding Name node is removed from the data structure . Alternatively these indexes may be configured such that some or all index updates must be performed explicitly on the index.

For an in memory implementation of the data structure a hash table may be used to store and access the index entries. To remove entries from an in memory index it is preferable to use a deletion counter in the data structure . The deletion counter allows other implementations that are storing data related to the journal data structure to detect when they are required to re visit the data structure. For example an external index needs to detect when the target of the index has been removed from the journal. The external index can detect when this index target has been removed by inspecting the deletion counter for the data structure to see that something has been deleted. The data structure is then visited to determine what has been deleted and whether that deletion requires a change to be made to the external index. Alternatively the data structure could send a notification to the index whenever a node is removed from the data structure .

For an implementation of the data structure using a database an additional table in the database is created which holds the index. This index table is preferably configured in the database such that when a node is removed from the database the corresponding index entry in the index table is automatically also removed. This feature is known in the database art as a cascading delete .

To improve security of the data structure a permissions manager is preferably provided which restricts the ability of users to access read or write information in the data structure . Preferably the permissions manager stores for each node an associated list of users or groups of users who are allowed to read the information in the node and a list of users or groups of users who are allowed to write modify the information in the node . In this way a subset of the data structure may be easily created for any given user which contains only those nodes that the user is permitted to read or write to . Preferably no modifications need to be done to the data structure itself to support permissions. The permissions manager works as an add on to provide this functionality. Similar to the data structure the permissions manager can be implemented as an in memory module which maintains the access lists in the computer memory and optionally transmits those lists off to a storage medium. Alternatively the permissions manger can maintain the access lists in a database and access those lists as needed during operations. The hybrid form of the data structure as discussed above can also be extended to the permissions manger such that the portions of the permissions manager that relate to nodes which are brought into the computer memory are themselves brought into memory while the rest of the permissions manager resides in the database. The permissions manager information can be replaced using the same cache replacement algorithms discussed above.

The architecture of a system of an embodiment which uses the data structure is shown in . The data structure Journal data structure sits above a data storage layer of the system architecture and below an application programming interface API layer and an access layer . The data storage layer of an example system comprises a variety of different data storage systems . Data storage system is a Microsoft SQL Server database available from Microsoft Corporation Redmond Wash. Data storage system is a Berkeley DB database available from Oracle Corporation Redwood Shores Calif. Data storage system is the memory of the computer on which the systems is running i.e. an in memory storage system . Data storage system is some other data storage system such as Postgres SQL available from Postgres SQL at www.postgresgl.org or any of a wide variety of known database platforms. In this example the data structure can use any or all of these different data storage systems to store the information recorded in the data structure . The particular data storage system chosen for use is a design choice for those of skill in the art dependent on the particular implementation that is desired and on the nature of the information that is being manipulated and is not critical to the disclosed embodiments of the invention. For example where the information being manipulated has already been collected and is being maintained in a variety of different data storage systems the computer on which the data structure resides can simply read the information from each of those systems present it in the data structure and then write the information back into each of the respective systems from whence it came. Alternatively the computer can read the data from the plurality of databases transform the data into the data structure and then store the entire data structure into a single data storage system for further use. Other variations are also possible.

In an embodiment the data structure is accessed according to a variety of APIs . The data structure may be access using the API which is an object oriented API that permits a programmer or other person with some technical skill to navigate through the nodes and edges of the data structure . The API may be used directly by the programmer to traverse the data structure in real time or alternatively may be used by other computer programs which are written to perform specialized actions on the data structure such as reading certain specific desired information or writing certain specific information into the data structure . The details of these actions and computer programs are design choices for those of skill in the art depending on the precise actions that are desired for particular circumstances e.g. types of information needs of the user community etc. and are not critical to the invention.

The data structure may also be accessed by the query language API . Further details about the query language API will be discussed below. Finally the data structure may also be accessed using an internal API not shown in which permits the user to modify the data structure directly. This API is intended for use by developers or system administrators or others who require low level access to the data structure typically for purposes of testing debugging or other administrative tasks.

The uppermost layer of the architecture of is the access layer . The data structure may be accessed in a variety of manners. Local access represents computers or other data access points terminals touch screens etc. which are local to the computer system on which the data structure is maintained. Persistent server interface access implements access to the server using a client server architecture and a dedicated network connection. In addition to permitting local access to the data structure the architecture of also permits remote access to this data structure. Preferably remote access is performed using the query language API as opposed to the direct API or other APIs. Using the query language API permits the remote user to use a query that retrieves all of the desired information at once and transmits that information to the remote user s computer. This reduces inefficiencies both in data transmission i.e. less traffic on the network connecting the remote user to the data structure as well as in interactions with the data structure which might be negatively impacted by the inefficiencies inherent in remote access such as network delay dropped signals etc. to cause undesired effects on other users of the data structure . In the example of the remote access to the data structure is provided by the Aranea message passing framework available from Aranea at http aranea.origo.ethz.ch built on top of the Apache Active MQ framework available from the Apache Software Foundation at http www.apache.org . Other remote access solutions are also possible.

In an embodiment when storing the information in the data structure as well as when transmitting the information to remote users a compact language independent packet for storing the data is used as shown in . The format for this packet is space efficient and contains version information versioning will be discussed in additional detail below . The data packet comprises for each node or edge that is being stored a first block which comprises a 64 bit integer that stores a universal value to allow programs to identify the file as a file containing stored journal data. The second block comprises a 32 bit integer value containing the version information for the node or edge . The third block comprises a sequence of a 64 bit integer and two String values which store type ids names and descriptions of the entry types contained in the journal. This information is used to relate types and names. The description string contains useful information about the type and serves self documenting purposes. The fourth block comprises a block for each entry in the journal containing the id type value timestamp and a list of all children and parent ids including the edge types. For example for node the fourth block would contain an entry with the value Mary Smith the type id for name as found in block and the corresponding relations for that type.

In order to reduce the space consumed by the data structure when it is stored or transmitted the data packet uses compressed integers whenever possible. Furthermore the nodes of the data structure are preferably stored in topological order with parents always appearing before children in the sequence of entries so that the information about the parent child relationships i.e. the edges only has to be stored once rather than twice once for each end of the edge . The data packet does not use termination characters as these characters consume space. Instead the data format uses the pattern where references the size assigned to each block in the data storage packet and is the actual information stored immediately subsequent to the size information.

As discussed above the data structure is preferably accessed through use of a query language. Use of a query language means that the user need not write separate computer language code each time the user wishes to perform search and retrieval tasks. Instead the user merely expresses the information the user wishes to retrieve using a statement known as a query in the specialized query language and provides that query to the data structure via the query language API of .

In an embodiment the query language is based on set theory and projection. This means that one starts from a set of nodes in the data structure and then uses projections of those nodes to retrieve parents or children of the starting set of nodes . Finally one applies filters to derive the desired set of nodes from the projection set forth in the query. Queries may be written directly in code or alternatively the queries may be expressed in an independent textual representation which facilitates communication modeling and debugging of the queries. A grammar for a query language of an embodiment of the invention is set forth in Table 2 

An example of a query with reference to the data structure shown in will now be discussed. If the user wishes to retrieve a time series of all of the bid prices for a particular company s stock where the desired company had an identifier of 8 the user would craft the following query using the query language 

In actual practice the above query preferably would be optimized before it is executed such that it does not actually retrieve the entire data structure as the first step. The above query will first be translated into a format recognized by each data storage system on which desired information is stored. For example the query will be translated into a SQL statement for execution on the MS SQL DB or the Berkeley DB or will be translated into other types of statements for other storage system types. Each data storage system will typically have its own mechanisms for optimizing queries on the database. These optimizers will receive the SQL statement or other similar statement and will compute an optimized data retrieval statement specific to the particular data storage system being accessed.

Similarly again with reference to the data structure of a query that seeks a cross section of bid prices for all listings on a particular day would be expressed as follows 

The result of a query to the data structures of an embodiment of the invention is always a set of nodes from those data structures. Thus if the edges in the data structures also convey useful information to the user then the query results can be presented to the user as a subset of the data structure that was queried. For example turning to the original data structure is queried. The query results are returned to the user. These query results are then expressed as a subset or slice of the original data structure .

The query language may also be used to make changes to the data structures of an embodiment of the invention. This is particularly useful where the user making changes is a remote user as discussed above and does not have access to the direct API to directly access the data structure. With reference to the user first submits a query to the server hosting the data structure at step . This query specifies the portion of the data structure that the user wishes to modify. At step the server executes the query and identifies the slice requested by the user. At step the server returns to the user the desired slice of the data structure. For example the data structure on the server comprises nodes A B C and D related as shown in step . The slice returned to the client however is just the nodes A B and D and the relations between those nodes as shown in step . At step the user modifies the slice by adding an entry E to the slice. At step the user transmits the slice back to the server and tells the server that this slice has been changed. At step the server merges the client s changes into the data structure by inserting any new nodes or edges into the appropriate location within the data structure by removing any nodes or edges deleted by the client from the data structure and by updating the information in the nodes or edges as changed by the client.

Before permitting the changes to be merged into the data structure the server checks to confirm that the merged structure does not violate the fundamental rules for the data structure. Thus the server confirms that 1 the user did not add an edge to a node that had been removed by another user 2 the user did not add an edge that creates a cycle in the data structure recall that the data structure is a DAG which is not permitted to have cycles in it as discussed above 3 the user did not change a node either by altering the information stored in the node or altering the time of life interval for the node where another user had already made a change to this information or interval or removed the node entirely or 4 the user did not remove a node where another user had made a change to the node either information or interval values .

The server can similarly test for other conflicts as desired by the designer of the system using the data structure. For example the server can test for inconsistent or conflicting data within the implantation specific rules for a particular database. Thus if a particular database has a rule that each Person object can only have one Name object valid at any given time a Person object having two Name objects that are valid at the same time i.e. a person with two names would be reported as a conflict. Similarly if a particular database has a rule that a Company can only have a single Closing Stock Price for any given date a Company object having two Closing Stock Price objects that are valid on the same dates would be reported as a conflict. These types of conflicts are implementation dependent and will vary depending on the specific database created by the designer of the system using the data structure.

An additional feature implemented in an embodiment of the invention is to keep track of multiple versions of the data structure. Versioning is implemented by associating a version number interval with each node or edge of the data structure. This version number interval specifies the range of versions of the data structure over which this version of the node or edge is valid. Whenever a change is made to a node or an edge of the data structure the old version of that node or edge is not deleted. Instead is it marked with the last version for which that node is valid and a new version of that node or edge is created with the changed data and an indication of the earliest version for which the new node is valid. This is conceptually distinct from splitting a node at a time of life point when the information in the node changes. While the time information in an entry indicates the time period over which the value of an entry was valid the version information is used to identify what information was available in the data structure at a given point in time. When considering the data structure as a model of the real world the version thus expresses a belief as to what was real at a given point in time recognizing of course that the data is frequently incomplete and inaccurate for models that are complex enough to be useful .

After the change the prior version of the node will have an indication of which version or versions of the data structure that node is valid for and the current version of the node will have an indication of the earliest version that the current version of the node is valid for. When it is desired to see what the data structure looked like as of any given prior version a query is simply run on the data structure using the version number of the desired version. This query will return all nodes and edges that were valid for the requested version number. When it is desired to run any query on the current version of the data structure then the current version number would be either implicitly or explicitly provided as an additional query parameter.

Preferably versioning is linear. When an old version of the data structure is accessed that data is only readable not writeable. This avoids the undesired creation of branches of the data structure. If however it is desired to create a branch then the old version of the data structure can be copied into a new data structure which would be modifiable.

A particular use of the data structure of an embodiment of the invention to transform legacy databases into a more useful format will now be discussed with reference to . In the example of a user has a collection of legacy databases each of which contain some information of value to the user but each of which stores this data in different incompatible formats. For example the databases may each contain worldwide stock market data from different providers of such information. Database may be a database of information from Reuters . Database may be a database of information from Bloomberg . Database may be a database of information from the Wall Street Journal . Databases may be information from other financial information providers.

The user wants to conduct research on a particular segment of the worldwide financial market for example by examining stock prices on the various Asian stock exchanges Tokyo Taiwan Singapore etc. . The databases contain all of the information the user desires but this information is difficult to access and difficult to compile because it is stored in different databases each with its own formats. Furthermore each database has a mass of information relating to non Asian markets that the user does not wish to examine. In an embodiment of the invention the user uses the data structure of an embodiment to transform these legacy databases into a database containing the information the user wishes to examine.

Beginning at step the user collects the legacy databases . At step the user migrates each of these databases into a data structure of an embodiment of the invention. Each item of information stored in each of the legacy databases is migrated into a node of a data structure of an embodiment of the invention and assigned an appropriate time of life interval. For example the data stored in a record as shown in would be migrated into the data structure as shown in . The company information from Reuters describes a company ABC Corp. and the current number of shares in the market 2 000 000 . This information is migrated into a parent node for the company with a child node describing the company name and a child node describing the number of shares to model this relationship. The time of life interval for each of the nodes and is set to reflect a beginning point of the earliest date the information is known to be valid. For example if the record in the legacy database has an explicit date such as a date created or date modified value that value is used. Alternatively the date that the database was created can be used if it is accurate as to the records in the database. The ending point for the time of life interval is set to the latest date the information is known to be valid. If the information is current then an identifier such as MAX as discussed above can be used or the field can be left blank. If the legacy data contains an explicit expiration date then this date can be used. A similar process is performed on each of the other databases . This process can be an on going real time migration. For example referring to the example of in a Reuters update shown in a 2 for 1 split of the company shares is announced such that there are now 4 000 000 shares in the market. This update is migrated into the data structure of an embodiment of the invention as shown in and leads to creation of a child node to the parent company node having the new amount of shares in the market. The old child node has its time of life interval adjusted to be limited to the point when the split was announced.

Then at step each of the data structures created from each of the legacy databases at step is merged into a single data structure according to an embodiment of the invention using the merging process discussed above. This single larger data structure now contains all of the information from each of the legacy databases represented as one large data structure having time of life intervals as discussed above. The real time migration discussed with reference to may also be performed on the larger data structure if desired. Finally at step a query is executed on the data structure to extract out the desired information into a slice data structure . Thus in the example above where the user wishes to examine Asian stock market information the user would run a query on the data structure specifying that the user wanted all information for the desired Asian stock exchanges e.g. Tokyo Taipei Singapore etc. . This data would be returned as a slice which the user could then further examine. Similarly other users could construct other slices of this data such as data on the NASDAQ market or the various European markets. This information is amalgamated from a wide variety of proprietary formatted legacy databases using the data structure of an embodiment of the invention in a manner that permits easy access to the entire universe of desired data.

In an embodiment the components of the apparatus discussed in the embodiments above reside in a computer system which has been configured using the above described components to create a special purpose apparatus for storing and processing data having specified time of life intervals using the data structure as discussed above. Referring to in an embodiment a computer system includes a host computer connected to a plurality of individual user stations . In an embodiment the user stations each comprise suitable data terminals for example but not limited to e.g. personal computers portable laptop computers or personal data assistants PDAs which can store and independently run one or more applications i.e. programs. For purposes of illustration some of the user stations are connected to the host computer via a local area network LAN . Other user stations are remotely connected to the host computer via a public telephone switched network PSTN and or a wireless network .

In an embodiment the host computer operates in conjunction with a data storage system wherein the data storage system contains a database that is readily accessible by the host computer . The database in an embodiment contains the data structure as discussed above and permits access to it. In an alternative embodiment the data structure is stored in a computer memory while in operation and is then persisted to the database .

In alternative embodiments the data storage system and or database may be resident on the host computer stored e.g. in the host computer s ROM PROM EPROM or any other memory chip and or its hard disk. In yet alternative embodiments the database may be read by the host computer from one or more floppy disks flexible disks magnetic tapes any other magnetic medium CD ROMs any other optical medium punchcards papertape or any other physical medium with patterns of holes or any other medium from which a computer can read.

In an alternative embodiment the host computer can access two or more databases stored in a variety of mediums as previously discussed.

Referring to in an embodiment each user station and the host computer each referred to generally as a processing unit embodies a general architecture . A processing unit includes a bus or other communication mechanism for communicating instructions messages and data collectively information and one or more processors coupled with the bus for processing information. A processing unit also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to the bus for storing dynamic data and instructions to be executed by the processor s . The main memory also may be used for storing temporary data i.e. variables or other intermediate information during execution of instructions by the processor s . In an embodiment the main memory contains the data structure and permits users to access this data structure as discussed herein.

A processing unit may further include a read only memory ROM or other static storage device coupled to the bus for storing static data and instructions for the processor s . A storage device such as a magnetic disk or optical disk may also be provided and coupled to the bus for storing data and instructions for the processor s .

A processing unit may be coupled via the bus to a display device such as but not limited to a cathode ray tube CRT for displaying information to a user. An input device including alphanumeric and other keys is coupled to the bus for communicating information and command selections to the processor s . Another type of user input device may include a cursor control such as but not limited to a mouse a trackball a fingerpad or cursor direction keys for communicating direction information and command selections to the processor s and for controlling cursor movement on the display .

According to one embodiment of the invention the individual processing units perform specific operations by their respective processor s executing one or more sequences of one or more instructions contained in the main memory . Such instructions may be read into the main memory from another computer usable medium such as the ROM or the storage device . Execution of the sequences of instructions contained in the main memory causes the processor s to perform the processes described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and or software.

The term computer usable medium as used herein refers to any medium that provides information or is usable by the processor s . Such a medium may take many forms including but not limited to non volatile volatile and transmission media. Non volatile media i.e. media that can retain information in the absence of power includes the ROM . Volatile media i.e. media that cannot retain information in the absence of power includes the main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise the bus .

Common forms of computer usable media include for example a floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes RAM ROM PROM i.e. programmable read only memory EPROM i.e. erasable programmable read only memory including FLASH EPROM any other memory chip or cartridge or any other physical medium from which a processor can retrieve information.

Various forms of computer usable media may be involved in providing one or more sequences of one or more instructions to the processor s for execution. For example the instructions may initially be provided on a magnetic disk of a remote computer not shown . The remote computer may load the instructions into its dynamic memory and then transit them over a telephone line using a modem. A modem local to the processing unit may receive the instructions on a telephone line and use an infrared transmitter to convert the instruction signals transmitted over the telephone line to corresponding infrared signals. An infrared detector not shown coupled to the bus may receive the infrared signals and place the instructions therein on the bus . The bus may carry the instructions to the main memory from which the processor s thereafter retrieves and executes the instructions. The instructions received by the main memory may optionally be stored on the storage device either before or after their execution by the processor s .

Each processing unit may also include a communication interface coupled to the bus . The communication interface provides two way communication between the respective user stations and the host computer . The communication interface of a respective processing unit transmits and receives electrical electromagnetic or optical signals that include data streams representing various types of information including instructions messages and data.

A communication link links a respective user station and a host computer . The communication link may be a LAN in which case the communication interface may be a LAN card. Alternatively the communication link may be a PSTN in which case the communication interface may be an integrated services digital network ISDN card or a modem. Also as a further alternative the communication link may be a wireless network .

A processing unit may transmit and receive messages data and instructions including program i.e. application code through its respective communication link and communication interface . Received program code may be executed by the respective processor s as it is received and or stored in the storage device or other associated non volatile media for later execution.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example the reader is to understand that the specific ordering and combination of elements in the data structure and process actions shown in the process flow diagrams described herein is merely illustrative and the invention can be performed using different or additional data structure elements process actions or a different combination or ordering of process actions. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

Additionally and or alternatively a secondary directed acyclic graph may indicate a range or interval a node is associated with. Data within a selected node is valid over an interval of the secondary directed acyclic graph. The selected node may indicate the lower endpoint and upper endpoint of that secondary directed acyclic graph interval. In this way the validity of the selected node may be measured by time or any other criteria capable of being represented in a directed acyclic graph. The properties of directed acyclic graphs are well known in the art.

As shown in and by using secondary directed acyclic graphs the validity of a node may be measured against any criteria capable of being represented by a directed acyclic graph. In the criterion is position within a company. Many other criteria are possible. For example the secondary directed acyclic graph could indicate the order in which a set of tasks must be performed. This is useful when the user knows the order in which the steps of a routine are to be performed.

The secondary directed acyclic graph in an alternative embodiment could refer to sets of priority as illustrated in and . This embodiment is useful in systems in which multiple workers may wish to use the same non shareable resource. In such systems a company may want to assign priorities to different workers so that workers with higher priorities may use the resource first. illustrates several exemplary levels of priority. Each level of priority is actually a set of priorities containing the level of priority as well as every level of priority underneath that level. For example those workers with Ultimate Priority have priority over anyone else not having Ultimate Priority. That is Ultimate Priority is a actually a set of priorities consisting of Ultimate Priority High Priority Medium Priority Employees Medium Priority Contractors and Low Priority. Those workers having High Priority have priority over those workers having only Medium Priority Employee Medium Priority Contractor or Low Priority . In other words High Priorty is a set containing High Priority Medium Priority Employees Medium Priority Contractors and Low Priority. Those workers with Medium Priority Employee or Medium Priority Contractor have priority over those workers with Low Priority . So Medium Priority Employee is a set containing Medium Priority Employee and Low Priority. Similarly Medium Priority Contractor is a set containing Medium Priority Contractor and Low Priority. And those workers having only Low Priority do not have priority over any other worker. So the set of Low Priority consists of only Low Priority. As shown in the secondary directed acyclic graph need not comprise a total order. The secondary directed acyclic graph need only be equivalent to a partial order. The properties of total and partial orders and the differences between them are well known in the art.

Although shown and described in terms of priority that a selected worker may have over another worker in a company with reference to and for purposes of illustration only the invention also applies to any other system involving priority. For example in computer science multiple elements may have access to the same memory. Where those elements can read from and write to that same memory priority must be carefully assigned to avoid errors such as reading stale data in the process of being updated. Computer interrupt signals are another example. Interrupt signals are typically assigned priority levels to ensure the computer services the most important interrupt signals first.

The examples of priority order and job hierarchy are merely exemplary. The secondary directed acyclic graph can represent any criteria capable of being represented in a directed acyclic graph. A further example is geography. A secondary directed acyclic graph could represent a series of geographic locations that a person has lived in. A secondary directed acyclic graph could alternatively represent a series of geographical regions located within each other. For example a four node secondary directed acyclic graph could comprise Manhattan New York City N.Y. State and then the United States. Manhattan is located within New York City which is located within New York State which is in turn located within the United States. Child nodes located within the boundary of a parent node may be added. For example a node corresponding to The Bronx could be a child node of the parent node New York City. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

An alternative embodiment of the data structure is illustrated in . As shown in the data structure is represented as a directed graph having one or more cyclical nodes. Nodes and for example are cyclical nodes because they form a cycle along directed edges and . In the manner discussed in more detail above a directed edge can be described as having a particular edge type. Here the directed edges and can be described as having the edge type cyclical. Cyclic nodes are nodes connected by cyclical directed edges. In this embodiment cyclical nodes advantageously can share the same time of life interval. In other words each cyclical node can be considered to be a parent of the other nodes in the cycle. In for example node can be deemed a parent node of node and node can be deemed a parent node of node .

In one embodiment the data structure of can correspond to the components present in a hypothetical field programmable gate array FPGA device. Node can represent the FPGA chassis named Alpha. A time of life interval of node spans from Jan. 1 2009 to the present indicating that the Alpha chassis has been in use since Jan. 1 2009.

The FPGA chassis can contain one or more FPGA boards. Nodes and thereby can represent respective FPGA boards within the Alpha chassis. As shown in nodes and are cyclical nodes connected by directed edges and . Being cyclical nodes nodes and have precisely the same time of life interval Jan. 1 2010 to the present. The real world consequence of the nodes and being cyclical in this example is that FPGA board and FPGA board preferably are replaced at the same time. Please note that the FPGA chassis may contain one or more other FPGA boards not shown . As shown in this example Nodes and do not need to share the same time of life interval as node which corresponds to the Alpha chassis. But because node is a parent node of both nodes and the time of life intervals of nodes and are preferably the same as or bounded by the time of life interval for parent node .

Nodes and illustrate an exemplary manner by which FPGA boards can be replaced at the same time. Node represents the original FPGA board and carries the board ID number A63271. Board ID A63271 was used from Jan. 1 2010 to Jan. 1 2013 and was replaced by the new FPGA board carrying the board ID number B52461. Node represents the board carrying the board ID number B52461. In this example Board ID number B52461 was placed into service on Jan. 1 2013 and continues to be in use.

Node represents the original FPGA board and carries the board ID number A63272. Board ID A63272 was used from Jan. 1 2010 to Jan. 1 2013 and was replaced by the new FPGA board carrying the board ID number B52462. Node represents the board carrying the board ID number B52462. In this example Board ID number B52462 was placed into service on Jan. 1 2013 and in this example continues to be in use.

Dots and represent that FPGA boards each have multiple components and that one or more individual components of the FPGA boards can be replaced without replacing the entire FPGA board . For example the FPGA board can have a selected component such as an inductance coil not shown . The inductance coil of the FPGA board may be replaced without replacing the entire FPGA board . When one or more selected components of the FPGA board are replaced without replacing the entire FPGA board no need exists to replace the FPGA board either in part or in whole. In other words the FPGA board does not need to be replaced or provided with replacement components if the FPGA board is provided with one or more replacement components. Nevertheless if the entire PFGA board is replaced board preferably is also replaced because nodes and are cyclical nodes in the manner discussed above.

Although shown and described with reference to as using dates as the time of life intervals for purposes of illustration any type of time of life intervals and or cyclical nodes can be used. For example cyclical nodes can comprise any type of cyclical nodes described herein that employ upper and lower endpoints of arbitrary criteria. Exemplary cyclical nodes include the cyclical nodes shown and described above with reference to B A and B. In other words the use of cyclical nodes with date and or time based time of life intervals with reference to is intended for purposes of illustration and not for purposes of limitation.

The described embodiments are susceptible to various modifications and alternative forms and specific examples thereof have been shown by way of example in the drawings and are herein described in detail. It should be understood however that the described embodiments are not to be limited to the particular forms or methods disclosed but to the contrary the present disclosure is to cover all modifications equivalents and alternatives.

