---

title: Communicating through physical vibration
abstract: A data transmitter includes a vibration motor and a switch to regulate voltage from a direct-current (DC) power supply to the vibration motor. A microcontroller generates a pulse width modulation signal with which to drive the switch and regulate the voltage to the vibration motor in a sinusoidal manner, to generate data as symbols from vibrations that form a series of bits from the vibration motor. The microcontroller may also cancel and jam a sound of vibration (SoV) created by the vibration motor. A data receiver includes a vibration sensor to sample data from vibrations in an incoming signal at a predetermined sampling rate, and a microcontroller, coupled to the vibration sensor, to control the sampling rate through an inter-integrated circuit (I2C) protocol or the like. A memory card, coupled to the microcontroller, stores the data with a serial peripheral interface (SPI) protocol or the like.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09608848&OS=09608848&RS=09608848
owner: The Board of Trustees of the University of Illinois
number: 09608848
owner_city: Urbana
owner_country: US
publication_date: 20151022
---
This application claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Patent Application No. 62 067 176 filed Oct. 22 2014 which is incorporated herein in its entirety by this reference.

Various near field communication technologies exist today some of which employ radio frequency RF modalities including near field communication NFC infrared Bluetooth of Bluetooth Sig Inc. and WiFi of the WiFi Alliance. These technologies however are known to suffer from security concerns in being susceptible to interception out of the air if within signal range.

By way of introduction the present disclosure relates to communicating through vibration between for example two electronic devices. In one embodiment a data transmitter includes a vibration motor and a switch to regulate voltage from a direct current DC power supply to the vibration motor. A microcontroller generates a pulse width modulation PWM signal with which to drive the switch and regulate the voltage to the vibration motor in a sinusoidal manner to generate data as symbols from vibrations that form a series of bits from the vibration motor.

In one embodiment a data receiver includes a vibration sensor that samples data from vibrations in an incoming signal at a predetermined sampling rate. The incoming signal may be received from direct physical contact with a data transmitter or through physical contact with a physical channel such as a table top with which the data transmitter also has physical contact. A microcontroller coupled to the vibration sensor controls the sampling rate through an inter integrated circuit I2C protocol. A memory card coupled to the microcontroller stores the data with a serial peripheral interface SPI protocol. By using a vibration motor to transmit data through symbols and a vibration sensor such as an accelerometer or a gyroscope to capture the transmitted data security can be greatly enhanced.

In another embodiment a data transmitter includes a vibration motor and a switch to regulate voltage from a DC power supply to the vibration motor. A microcontroller generates a PWM signal with which to drive the switch and regulate the voltage to the vibration motor in a sinusoidal manner to generate data as symbols from vibrations that form a series of bits from the vibration motor. The symbols cause the vibration motor to emanate a sound of vibration SoV that includes data leakage and wherein the microcontroller is further to generate an anti noise signal to at least partially cancel the SoV when the SoV emanates. A microphone detects the SoVs and a speaker outputs the anti noise signal.

Data communication has been studied over a wide range of modalities including radio frequency RF acoustic visible light and the like. The present application envisions vibration as a new mode of communication. We explore the using vibration motors present in all cell phones today as a transmitter while accelerometers also popular in mobile devices as a receiver. By carefully regulating the vibrations at the transmitter and sensing them through accelerometers two mobile devices may communicate via physical touch or through vibrations through a physical media.

The benefits of using vibration motors and accelerometers in mobile phones as an opportunity to exchange information includes security and zero configuration meaning that the two devices need not discover each other s addresses to communicate. The act of physical contact serves as the implicit address. However some have identified the drawbacks of such a system to be low bit rates about 5 bits s based on the Morse code style of ON OFF communication with vibrations. Still researchers conceived creative applications including secure smartphone pairing and keyless access control.

The present disclosure is aimed at improving the data rates of vibratory communication as well as its security features. A system disclosed herein breaks away from the intuitive Morse code style ON OFF pulses and engages techniques such as orthogonal multi carrier modulation gray coding adaptive calibration vibration braking side channel suppression and the like. Unique challenges and opportunities emerge from the vibration motor and vibration sensor platform as well as from solid materials on which they rest. For example the motor and the materials exhibit resonant frequencies that need to be adaptively suppressed. Vibration sensors such as accelerometers or gyroscopes sense vibration along three orthogonal axes offering the opportunity to use them as parallel channels with some degree of leakage. In addition to such techniques the inventors have also designed a receiver cradle or a wooden cantilever structure that amplifies or dampens the vibrations in a desired way. A vibration based product in the future say a point of sale equipment for credit card transactions may benefit from such a design.

From a security perspective the present system recognizes the threat of acoustic leakage due to vibration e.g. an eavesdropper listening to the sound of vibration and decoding the transmitted bits. To thwart such side channel attacks the present design adapts the receiver to detect the sounds and adaptively generate a synchronized acoustic signal that cancels the sound. The receiver may also superimpose a jamming sequence ultimately offering an information theoretic protection from acoustic eavesdroppers. We observe that application layer securities may not apply in all such scenarios. For example public and symmetric key based encryption infrastructure may not scale to billions of phones and other use cases such as internet of things IoT . Blocking access to the signal at the physical layer itself is desirable in these spontaneous peer to peer and perhaps disconnected situations.

It is natural to wonder what kind of applications will use vibratory communication especially in light of NFC. Bringing the vibratory bit rates to a respectable level say credit card transactions in a second may trigger many new use cases. In particular strict security sensitive applications or applications in the developing world may be candidates. This is because vibration may be inherently more secure than RF broadcast in NFC or Bluetooth . Despite the very short communication range in NFC recent results confirm that security threats are real. Some have decoded NFC transmissions from one meter away and conjecture that high gain beamforming antennas can further increase the separation. The level of security has been increased with the disclosed acoustic cancellation and jamming.

Moreover the ubiquity of vibration motors in every cell phone even in developing regions presents an immediate market for vibratory communication. Peer to peer money exchange with recorded logs is a global problem recently recognized by the Gates Foundation and hidden camera attacks on Automated Teller Machine ATM kiosks have been rampant in many parts of India and south Asia. Paying local cab drivers with phone vibrations or using phones as ATM cards can perhaps be of interest in developing countries. Finally if link capacity proves to be the only bottleneck perhaps improved vibration motors can be included to mitigate the bottleneck in the next phone models.

The inventors therefore have harnessed the vibration motor hardware and its functionalities from a communications perspective. The inventors have developed an orthogonal multi carrier communication stack using vibration motor and accelerometer chips and repeat the same for Samsung smart phones. Design decisions for the latter are different due to software and application programming interface API limitations on smartphones where vibration motors are mainly integrated for simple alerts and notifications. The inventors further have identified acoustic side channel attacks and using signal cancellation and jamming offer physical layer protection to eavesdropping.

A vibration motor also called vibra motor is an electro mechanical device that moves a metallic mass around a neutral position to generate vibrations. The motion is typically periodic and causes the center of mass CoM of the system to shift rhythmically. There are mainly two types of vibra motors depending on their working principle 

This type of vibration generators use a direct current DC motor to rotate an eccentric mass around an axis as depicted in . As the mass is not symmetric with respect to its axis of rotation the mass causes the device to vibrate during the motion. Both the amplitude and frequency of vibration depends on the rotational speed of the motor which can in turn be controlled through an input DC voltage. With increasing input voltages both amplitude and frequency increase almost linearly and can be measured by an accelerometer.

This type of vibration motors generate vibration by linear movement of a magnetic mass shown in as opposed to rotation in ERM. With LRA the mass is attached to a permanent magnet which is suspended near a coil called a voice coil. Upon applying alternating current AC to the motor the coil also behaves like a magnet due to the generated electromagnetic field and causes the mass to be attracted or repelled depending on the direction of the current. This generates vibration at the same frequency as the input AC signal while the amplitude of vibration is determined by the signal s peak to peak voltage. Accordingly LRAs allow for regulating both the magnitude and frequency of vibration separately. Fortunately most mobile phones today use LRA based vibra motors.

Ideally a controller should be able to regulate the vibra motor at fine granularities using any analog waveform. Unfortunately micro controllers produce digital voltage values limited to a few discrete levels. A popular technique to approximate analog signals with binary voltage levels is called Pulse Width Modulation PWM . This technique is useful to drive analog devices with digital data without requiring a digital to analog converter DAC .

The core idea in PWM is to approximate any given voltage V by rapidly generating square pulses and configuring the pulse s duty cycle appropriately. For example to create a 1V signal with binary voltage levels of 5V and 0V the duty cycle needs to be 20 . Now if the period of the square pulse is made very small i.e. high frequency the effective output voltage will appear as 1V. Towards this goal the PWM frequency is typically set much higher than the response time of the target device so that the device experiences a continuous average voltage. Importantly it is also possible to generate varying voltages with PWM say a sine wave by gradually changing the duty cycles in a sinusoidal fashion as shown in .

Different vibration sensors exist that can detect vibrations. One of the more popular vibration sensors found in many electronic devices is the accelerometer although inertial sensors such as gyroscopes may also be used to pick up on vibrations. In various embodiments a vibration sensor may be a gyroscope or may include both an accelerometer and a gyroscope to detect vibrations. The accelerometer is a micro electro mechanical MEMS device that measures acceleration caused by motion. While the inner workings of accelerometers can vary the core working principle pertains to a movable seismic mass that responds to the vibration of the object to which the accelerometer is attached. Capacitive accelerometers such as shown in are perhaps most popular in smartphones today. When vibrated the seismic mass moves between fixed electrodes causing differences in the capacitance cand c ultimately producing a voltage proportional to the experienced vibration.

Modern accelerometers and gyroscopes sense the movement of the seismic mass along three orthogonal axes and report them as a tuple. The gravitational acceleration appears as a constant offset along the axis pointed towards the floor. The newest accelerometer chips support a wide range of adjustable sampling rates typically from 100 mHz to 3.2 KHz. For this disclose we choose the ADXL345 capacitive MEMS accelerometer not only because it is used in most smartphones but also because of programmability and frequency range.

The present inventors have designed a custom hardware prototype using the same chips that smartphones use and characterize and evaluate the system. Remember that communication via vibrations may be by way of direct physical contact or through contact with a physical channel of communication such as a physical object like a table cantilever or other physical object.

The vibration frequency and amplitude may be finely controlled through a time varying sequence of voltage levels fed to the vibra motor . The microcontroller s output current fluctuates leading to errors in the transmitted vibratory signals. Therefore we power the vibra motor with a stand alone 6V DC power supply and use the microcontroller signal to operate a switch that regulates the voltage to the motor . The NPN transistor may be an NPN Darlington transistor TIP122 that serves as a switch to control whether to drive the motor . The microcontroller signal from the microcontroller may be connected to a base of the NPN transistor .

Assume regulation of the vibra motor in a sinusoidal fashion. Digital samples of the sine waveform may be pre loaded into memory of the microcontroller and PWM uses them to determine the width of the square waves. When the sine wave frequency is to be increased the same digital samples are drawn at a faster rate and at precise timings. The switch Part A uses the PWM output to regulate the 6V DC signal resulting in a signal similar to . We mitigate a number of engineering problems to run the set up correctly including harmonic distortions due to the square pulses spikes due to back EMF and the like. The data transmitter may move the PWM frequency to a high 32 KHz and use an RC filter Part B to remove the distortions. The data transmitter may further use a fly back diode such as a 1N4001 fly back diode to smooth out the spikes.

The data transmitter may perform amplitude modulation on 10 different carrier signals uniformly spaced from 300 Hz to 800 Hz where each carrier is modulated with a bandwidth of 40 Hz. Furthermore the vibrations may also be parallelized on orthogonal motion dimensions X and Z with appropriate signal cancellation as will be discussed in more detail.

The vibration sensor may detect vibrations and send detected signals over a serial data SDA or one bit data bus and a serial clock SCL to the microcontroller board using a inter integrated circuit I2C protocol or similar type of communication protocol. This data may then be stored in the SD memory card by the microcontroller using the displayed connections clock CLK master out slave in MOSI master in slave out MISO and slave select pin. The data may be stored to the SD memory card using a serial peripheral interface SPI protocol connection or bus.

The data receiver may be controlled through the microcontroller board which may in one embodiment be an Arduino board via the I2C protocol at 115200 baud rate for example. In one embodiment the accelerometer s sampling rate may be set to 160011z and 10 bit output resolution. While higher sampling rates are possible we refrain from doing so as the microcontroller records the vibration data at a slower rate. In particular the microcontroller produces a sample each 0.625 ms but the microcontroller takes around 8 to 12 ms to periodically read and write to memory. This may be handled with a first in first out FIFO mode of the vibration sensor such that queued up data is read in as a burst. We also mount an on board SD card to store data via the SPI protocol.

To reason about how data bits should be transmitted we first carry out an analysis of the available spectrum. This available spectrum is actually bottlenecked by the maximum sampling rate of the vibration sensor of the data receiver because this rate is 1600 Hz the highest frequency the transmitter can use is naturally 800 Hz. Now to test the system s frequency response in the 0 800 band we perform a sine sweep test. The data transmitter with the help of a waveform generator may produce continuously increasing frequencies from 1 Hz to 800 Hz with constant amplitude the frequency increments are at 1 Hz . shows the corresponding vibration magnitudes recorded by the vibration sensor. The response appears weak up to 60 Hz called the inert band followed by improvements up until around 200 Hz followed by a large spike at around 231 Hz. This spike is near the resonant frequency of the vibra motor confirmed in the data sheet .

Frequencies near the resonant band may serve as good carriers for amplitude modulated data because of a larger vibration range. However when we plot the frequency versus time spectrogram of the sine sweep test we find that the vigorous vibration around the resonant frequency spills energy in almost the entire spectrum. Therefore transmitting on the resonant band can be effective for a single carrier system but the interference ruins the opportunity to transmit data in parallel carriers. In light of this we define a resonant band of 100 Hz around the peak and move the carrier signals outside this band. We select 10 orthogonal carriers separated by 40 Hz from the non resonant frequencies between 300 Hz and 800 Hz. The 40 Hz separation ensures the non overlapping sidebands for the carriers allowing reliable symbol recovery with software demodulation.

Microcontrollers such as microcontroller and microcontroller may inject timing errors at various stages variable delay in fetching digital samples from memory during time stamping the received samples and due to oscillator crystal frequency shifts with temperature. The timing errors manifest as fluctuations in vibration frequency causing error in demodulation. To synchronize time between data transmission by the data transmitter and data reception by the data receiver the data transmitter may generate a pilot vibration frequency at 70 Hz and transmit it in parallel to data bits. We choose 70 Hz to be above the inert band and lower than the resonant band. During reception the microcontroller detects the pilot frequency measures the offset in sampling rate and interpolates the received signal by adjusting for this offset. This operation may also correct all other frequencies in the spectrum needed for demodulation.

The carrier frequencies are modulated with Amplitude Shift Keying ASK in light of bandwidth efficiency and simplicity in contrast to Frequency Shift Keying FSK . The modulator may modulate each of the 10 carriers with binary data at a symbol rate of 20 Hz. To prevent inter carrier interference the modulator may shape the pulses with the raised cosine filter for each carrier individually the modulated carriers are then combined and fed to the vibration motor to be transmitted. The data receiver senses the energy in the pilot carrier calibrates and synchronizes appropriately to identify the beginning of transmission. The microcontroller again filters the received spectrum with a raised cosine filter which may be the same raised cosine filter used by the microcontroller during modulation to isolate each carrier. The demodulator may then proceed to demodulate individual carriers separately. show a part of the spectrum before and after filtering for an example carrier frequency at 405 Hz. The demodulator may perform the demodulation with envelop detection and precise sampling at bit intervals. We will evaluate this custom designed system below and show 200 bits second data rates through vibration.

The above schemes although adapted for vibra motors are grounded in the fundamentals of radio design. In an attempt to augment the bit rate we observed that a unique property of accelerometers and gyroscopes is an ability to detect vibration on three orthogonal dimensions X Y and Z . Although vibra motors only produce signals on a single dimension multiple vibra motors may be used in parallel to produce vibrations along any or a combination of the X Y and Z axes. As just one example we have included an example in which the data transmitter includes two vibra motors oriented in the Y and Z dimensions respectively and execute the exact multi carrier amplitude modulated transmissions discussed above.

Measurements show that vibration from one dimension spills into the other. However this spilled interference exhibits a 180 phase lag with respect to the original signal as well as an attenuation in the amplitude. shows an example in which the Z axis signal solid black has a spill on the Y axis with a reversed phase and halved amplitude. The vice versa also occurs. Now to remove Z s spilled interference and decode the Y signal we scale the Y signal so that the interference matches Z s actual amplitude and then add it to the Z signal. The Z signal is removed quite precisely leaving an amplified version of Y which is then decoded through the envelope detector. The reverse is performed with Z s signal resulting in a double improvement in data rate evaluated later.

The above explained custom design was extended to application on existing smartphones such as for example Android smartphones. Android is of interest because Android offers APIs to a kernel level PWM driver for controlling the ON OFF timings A user space module added to the Android may leverage third party kernel space APIs to control the vibration amplitudes as well. However this use space module still may not match the custom set up explained previously. The PWM driver in Samsung smartphones is set to operate on the resonant band of the LRA vibra motor and the vibration frequency may not be changed. This is understandable from the manufacturer s viewpoint since vibra motors are embedded to serve as a 1 bit alert to the user. However for data communication the non linear response at the resonant frequencies presents challenges. Nonetheless the present design may operate under these constraints but may be limited to a single carrier frequency modulated via amplitude modulation.

One advantage of the resonant frequency is that it offers a larger amplitude range permitting n ary symbols as opposed to being binary e.g. the amplitude range divided into n levels . To further amplify this range we add a custom smartphone cradle a cantilever based wooden bridge like framework that in contact with the phone amplifies specific vibration frequencies. While we will evaluate performance without this cradle we researched whether auxiliary objects bring benefits to vibratory communication. shows one such a design which includes a cantilever of a certain length supported at one end and connected to a vibration sensor on the other. When the transmitter phone is placed on a specific location on the bridge and a vibration sensor connected to the other end we indeed observe improved sign to noise ratio SNR . By making the cantilever channel resonate along with the smartphone we saw improved transmission capacity. We elaborate on the cantilever based design next followed by the communication techniques.

Observe that every object has a natural frequency at which it vibrates. If an object is struck by a rod say the rod will vibrate at its natural frequency no matter how hard it is struck. The magnitude of the strike will increase the amplitude of vibration but not its frequency. However if a periodic force is applied at the same natural frequency of the object the object exhibits amplified vibration resonance. In our set up we use a one foot long wooden beam supported at one end called a cantilever . The smartphone transmitter placed near the supported end of the cantilever impinges a periodic force on the cantilever calculated precisely based on the cantilever s resonant frequency inversely proportional to the square root of its weight . We adjust the weight of the cantilever so that its natural frequency matches that of the phone s vibra motor which lies between 190 Hz to 250 Hz . This creates the desired resonance.

The vibration sensor is attached at the unsupported end of the cantilever to the right of the cantilever in . plots the measured amplitude variation on three axes of the vibration sensor as the smartphone is placed on different positions along the cantilever. We choose the position located six inches from the supported end as it induces maximal amplification on all three axes of the vibration sensor.

The microcontroller communicates through amplitude modulation pulses of n ary amplitudes or symbols are modulated on the carrier frequency for a symbol duration. Preferably the effect of a vibration should be completely limited within this symbol duration to avoid interference with the subsequent symbol called inter symbol interference . In practice however the vibration remains in the medium even after the driver stops the vibrator known as the ringing effect. This is an outcome of inertia where the vibra motor mass continues oscillating or rotating for some period after the driving voltage is turned off. Until this extended vibration dampens down substantially the next symbol may get incorrectly demodulated due to this heightened noise floor . Moreover the free oscillation of the medium also contributes to ringing. shows a vibratory pulse of the smartphone where the vibra motor is activated from 20 to 50 ms. The vibration motor may consume 30 ms to overcome static inertia of the movable mass and reach its maximum vibration level. Once the voltage is turned off at 50 ms the vibration dampens slowly and consumes another 70 ms to become negligible. This dictates the symbol duration to be around 30 70 100 ms to avoid inter symbol interference.

To push for greater capacity we reduce the symbol duration by dampening the ringing vibration. The ringing duration is a function of the amplitude of the signal a higher amplitude signal rings for a longer duration. If however the amplitude can be deliberately curbed ringing may still occur but will decay faster. Based on this observation the microcontroller applies a small braking voltage to the vibra motor right after the signal has been sampled by the demodulator 30 ms . This voltage is deliberately small so that it does not manifest into large vibrations and is applied for 10 ms. Once braking is turned off the microcontroller allows another 10 ms for the tail of the ringing to die down and then transmit the next symbol as shown in . Thus the symbol duration is 50 ms now half of the original and there is still some vibration when microcontroller triggers the next symbol. While this adds slightly to the noise floor of the system the benefits of a shorter symbol duration out weighs the losses. Moreover an advantage arises in energy consumption triggering the vibra motor from a cold start requires higher power. As we see later activating it during the vibration tail saves energy.

The de modulation technique is mostly similar to a single carrier of the custom hardware design. One difference is that the de modulation technique with a smartphone uses multiple levels of vibration amplitudes up to 16 unlike the binary levels used in the custom design. shows how microcontroller can vary the voltage levels as a percentage of maximum input voltage to achieve different vibration amplitudes. If adequately stable the amplitude at each voltage level can serve as separate symbols. Given the linear amplitude slope from voltage levels 15 to 90 the microcontroller may divide this range into n ary equispaced amplitude levels each corresponding to a symbol. However due to various placements and or orientations of the phone this slope can vary to some degree. While this does not affect up to 8 ary communication 16 symbols are susceptible to this because of inadequate gaps between adjacent amplitude levels. To cope the microcontroller may use a preamble of two symbols. At the beginning of each packet the data transmitter may send two symbols with the highest and lowest amplitudes 15 and 90 . The receiver computes the slope from these two symbols and calibrates all the other intermediate amplitude levels from these slopes. The data receiver may then decode the bits with a maximum likelihood based symbol detector.

Vibrations from vibration motors produce sound and can leak information about the transmitted bits to an acoustic eavesdropper. This section is aimed at designing techniques that thwart such side channel attacks. We design this as a real time operation on the smartphone

The source of noise that actually leaks information is the rattling of the loosely attached parts of the vibration motor e.g. the unbalanced mass and metals supporting the vibration motor. Our experiments show that this sound of vibration SoV exhibits correlations of 0.7 with the modulated frequency of the data transmission. Although SoV decays quickly with distance microphone arrays and other techniques can be employed to still extract information. The disclosed system and methods work to prevent such attacks.

One way to defend against eavesdropping is to jam the acoustic channel with a pseudorandom noise PN sequence thus decreasing the SNR of the SoV. Since this jamming signal will not interfere with physical vibrations it does not affect throughput. Upon implementation we realized that the jamming signal was audible and annoying to the ears. The more effective approach may be to cancel or suppress the SoV from the source and then jam faintly to camouflage the residue.

The microcontroller may though the vibration motor produce an anti noise signal that cancels out the SoV to ultimately create silence. The data transmitter should generate this anti noise as it knows the exact bit sequence that is the source of the SoV. The challenge is in detecting the ambient sound in real time and producing the precise negative phase shifted signals at all locations around the data transmitter .

The data transmitter may know the precise bit sequence that is causing the SoV. This can help in modeling the sound waveform ahead in time and be synchronized as close as possible to the SoV. The issue however is that the SoV varies based on the material medium on which the phone is placed furthermore the SoV needs to be cancelled at all locations in the surrounding area. Further the phase of the SoV remains unpredictable as it depends on the starting position of the mass in the vibra motor and the delay to attain the full swing. Finally Android offers little support for real time audio processing posing a challenge in developing SoV cancellation on off the shelf smartphones.

The overall technique for cancellation and jamming is composed of three general sub tasks anti noise modeling phase alignment and jamming.

The goal is to model the analog SoV waveform corresponding to the data bits that will be transmitted through vibration. Since the vibration amplitude and frequency of the vibration motor are known e.g. the carrier frequency the first approximation of this model is relatively straight forward. However as mentioned earlier the difficulty arises in not knowing how the unknown material on which the phone is placed will impact the SoV. Apart from the fundamental vibration frequency the precise SoV signal depends also on the strength and count of the overtones produced by the material. To estimate this the data transmitter first transmits a short preamble listens to detect its Fast Fourier Transform FFT through the microphone and picks the top K strongest overtones. These overtones are combined in the revised signal model. Finally the actual data bits are modeled in the time domain reversed in sign and added to create the final anti noise signal. The anti noise signal is ready to be played on the speaker except that the phase of anti noise needs to match the SoV.

Unfortunately Android introduces a variable latency of up to 10 ms to dispatch the audio data to the hardware. This is excessive since a 2.5 ms lag can cause constructive interference between the anti noise and the SoV. Fortunately two observations help in this setting 1 the audio continues playing at the specified sample rate without any significant fluctuation and 2 the sample rate of the active audio stream can be changed in real time. The data transmitter can now control the frequency of the online audio by changing the playback sample rate.

We leverage this frequency control to make the microcontroller match the phase of the anti noise signal with the SoV. The microcontroller may start the anti noise signal as close as possible to the SoV but increase the sampling frequency such that the fundamental frequency of the anti noise signal increases by f. When this anti noise signal combines in the air with the SoV the anti noise signal causes the amplitude of the sound to vary because of the small difference in the fundamental frequencies. The maximum suppression of the SoV occurs when the amplitude of this combined signal is at its minimum. The phase difference between the SoV and the anti noise signal is almost matched at this point which we can refer to as phase lock time. At exactly this phase lock time microcontroller may switch the fundamental frequency of the anti noise signal to its original value i.e. lower by f . The microcontroller recognizes this time instant by tracking the envelope of the combined signal and switching frequencies at the minimum point on the envelope.

The cancellation is not perfect because the timing of the operations are not instantaneous microphone and speaker noise also pollute the anti noise waveforms leaving a small residue. To prevent attacks on this residue the microcontroller may superimpose a jamming signal with the goal of camouflaging the sound residue. A PN sequence may be added to the anti noise waveform once it has phase locked with the vibration sound. Unfortunately Android does not allow loading a second signal on top of a signal that is already playing. Note that if we load the jamming signal upfront along with the modeled anti noise signal the precise phase estimation fails. We develop an engineering work around. When modeling the anti noise waveform the microcontroller may also add the jamming noise sequence but pre pad the latter with a few zeros. Thus when the SoV and anti noise signal combine the zeros still offer opportunities for detecting the time when the signals precisely cancel. The microcontroller may phase lock at these times and the outcome is the residual signal from imperfect cancellation plus the jamming sequence. We will show in the evaluation how the SoV s SNR degrades due to such cancellation and jamming offering good protection to eavesdropping. The tradeoff is that we need a longer preamble now for this phase alignment process. However this is only an issue arising from current Android APIs.

We evaluate the proposed data transmitter and data receiver designs in three phases the custom hard ware the smartphone prototype and security.

Recall that the custom hardware is composed of the vibra motor and a vibration sensor such as an accelerometer or gyroscope chip controlled by the microcontroller which is located on for example an Arduino board . We bring the data transmitter and the data receiver into physical contact which may include some medium on which they are placed and initiate packet transmission of various lengths consuming between 1 second to 10 seconds . Each packet contains pseudo random binary bits at 20 Hz symbol rate on 10 parallel carriers. The bits are demodulated at the data receiver and compared against the ground truth. We repeat the experiment for increasing signal energy e.g. by varying the peak to peak signal voltage V from 1V to 5V . plots the bit error rate BER as a function of peak to peak input voltage V to the vibra motor and demonstrates how it diminishes with higher SNR. At the highest SNR and aggregated over all carrier frequencies the present design achieves the 80th percentile BER of 0.017 translating to an average bit rate of 196.6 bits s.

In evaluating BERs across different carrier frequencies we observe that not all carriers behave similarly. illustrates that carrier frequencies near the center of the spectrum perform consistently better than those near the edges. One of the reasons is aliasing noise. Ideally the vibration sensor should low pass filter the signal before sampling to remove signal components higher than the Nyquist frequency. However inexpensive vibration sensors do not employ anti aliasing filters causing such undesirable effects. Carriers near the resonant band also experience higher noise due to the spilled over energy.

Increasing the number of carriers enables greater parallelism bit rate at the expense of higher BER per carrier. To characterize this tradeoff we transmit data on an increasing number of carriers starting from the middle of our spectrum and activating carriers on both sides one at a time. illustrates BER variations with increasing number of carriers for varying signal energy peak to peak voltage V . As each carrier operates at fixed 20 Hz symbol rate this also shows the bit rate versus BER characteristics of our system. zooms in on the BERs of the best four carriers.

Given that vibra motors and vibration sensors are essentially mechanical systems we intend to evaluate their properties when they are made to operate continuously for long durations. Given the low bit rates this might be the case when relatively longer packets need to be transmitted. Towards this end we continuously transmit data for 50 sessions of 300 seconds each. plots the per carrier BER computed in the granularity of 10 second periods of a randomly selected session. The Y axis shows each of the carriers and the X axis is time. The BERs vary between 0.02 near the center to 0.2 near the edge. Overall results show no visible degradation in BER even after running for 300 seconds.

Recall that the data transmitter may use two vibra motors in parallel to exploit the orthogonality of vibrations along the Y axis and the Z axis of the vibration sensor and theoretically could use three vibra motors for all three axes. illustrate the distribution of BER achieved across carrier frequencies on the Y axis and the Z axis respectively. We also attempt to push the limits by modulating greater than 20 bits s however the BER begins to degrade. In light of this the disclosed design achieves median capacity of around 400 bits s e.g. 20 bits s per carrier 10 carriers 2 dimensions . While the tail of the BER distribution still needs improvement we believe coding can be employed to mitigate some of it.

Vibrations will vary across transactions due to phone orientation humans holding it different vibration medium and other factors. As discussed earlier a demodulator may calibrate for these factors but may pay a penalty whenever the calibration is imperfect. We evaluate accuracy of calibration using the error between the estimated amplitude for a symbol and the mean amplitude computed across all received symbols. plots the normalized error for various n ary modulations the normalization denominator is used as the difference between adjacent amplitudes.

The LRA vibra motor inside the Galaxy S4 generates linear vibration along one dimension the teardown of the phone shows the vibra motor s axis aligned with the Z axis of the phone. Thus an accelerometer should mostly witness vibration along the Z axis. The other two axes do not exhibit sufficient vibration at higher bit rates. This is verified in Table 1 where the first four data points are from when the phone is laid flat on top of the cantilever. However once the phones are made to stand vertically or on the sides the X axis and Y axis align with the accelerometer s Z axis causing an increase in errors. This suggests that the best contact points for the phones are their XY planes mainly due to the orientation the vibration motor.

We experiment with a scenario in which the accelerometer based receiver is on the table and the hand held phone is made to touch the top of the receiver. The alignment is crudely along the Z axis. This setup adversely affects the system by 1 eliminating the amplitude gain due to the cantilever and 2 dampens vibration due to the hand s absorption. illustrates the results where the total vibration range is now smaller pushing adjacent symbol levels to be closer to each other resulting in higher BER.

To characterize the maximum acoustic leakage from vibrations we run the vibra motor at its highest intensity and record the SoV at various distances using smart phone microphones sampled at 16 KHz. This leakage is naturally far higher than a typical vibratory transmission composed of various intensity levels so mitigating the most severe leakage is stronger security. We also realize that the material on which the smartphone is placed matters. We therefore repeated the same experiment by placing the phone on a glass plate b metal plate aluminum c on the top of another smartphone and d our custom wooden cantilever setup. illustrates the contour plots for each scenario respectively. It appears that glass causes the strongest side channel leak and wood exhibits the least minimum of the tested materials. The following experiments were therefore performed on glass.

Recall that the data receiver records the SoV produces a synchronized phase shifted signal to cancel the SoV and superimposes a jamming sequence to further camouflage the leakage. shows the impact of cancellation using a ratio of the power of the residual signal to the original signal measured at different distances. As shown the cancellation is better with increasing distance. This is because the generated anti noise signal approximates the first few strong harmonics of the sound. However the SoV also contains some other low energy components that fade with distance making the anti noise signal more similar to the vibration s sounds. Hence the cancellation is better at a distance until around four feet after which the residual signal drops below the noise floor and our calculated power becomes constant. The original signal also decreases but is still above the noise floor past 4 feet and therefore the ratio increases.

The data transmitter may apply jamming to further camouflage any acoustic residue after cancellation. To evaluate the lower bound of jamming efficiency we make the experiment more favorable to the attacker. We transmit only two amplitude levels binary data bits at 10 bits per second.

We place the phone on glass the scenario that creates loudest sound. The eavesdropper microphone is placed as close as possible to the transmitter without touching it. To quantify the efficacy of the jamming we correlate the actual transmitted signal with the received jammed signal and plot the correlation coefficient in the Table 2 which includes the mean and standard deviation of the correlation coefficient for increasing jamming to signal power ratio. A high correlation coefficient indicates high probability of correctly decoding the message by the adversary and the vice versa. The table shows the correlation values for various ratios of the jamming to signal power. Evident from the table the correlation coefficient sharply decreases when Ripple increases the jamming power.

If the transmission has not ended the method may analyze the SoV waveform and determine whether the SoV is above a threshold level of noise . If the SoV is below the threshold the method may then jam any residual SoV based on the analysis and continue to analyze the SoV waveform . If the SoV is above the threshold level of noise then the method may increase the frequency of the anti noise signal by f . The method may continue with filtering the SoV waveform as discussed previously and tracking or detecting an envelope of the SoV waveform . The method may continue to determine whether the SoV waveform has reached a local minima . If it has not then the method may continue to filter the SoV waveform and track the envelope of the SoV waveform . When the local minima is reached the method may continue to decrease the anti noise signal frequency by f . The method may then continue to determine whether the SoV is above the threshold level of noise as before .

In a networked deployment the computer system may operate in the capacity of a server or as a client user computer in a server client user network environment or as a peer computer system in a peer to peer or distributed network environment. The computer system may also be implemented as or incorporated into various devices such as a personal computer or a mobile computing device capable of executing a set of instructions that specify actions to be taken by that machine including and not limited to accessing the internet or web through any form of browser. Further each of the systems described may include any collection of sub systems that individually or jointly execute a set or multiple sets of instructions to perform one or more computer functions.

The computer system may include a memory on a bus for communicating information. Code operable to cause the computer system to perform any of the acts or operations described herein may be stored in the memory . The memory may be a random access memory read only memory programmable memory hard disk drive or any other type of volatile or non volatile memory or storage device.

The computer system may include a processor such as a central processing unit CPU and or a graphics processing unit GPU . The processor may include one or more general processors digital signal processors application specific integrated circuits field programmable gate arrays digital circuits optical circuits analog circuits combinations thereof or other now known or later developed devices for analyzing and processing data. The processor may implement the set of instructions or other software program such as manually programmed or computer generated code for implementing logical functions. The logical function or any system element described may among other functions process and or convert an analog data source such as an analog electrical audio or video signal or a combination thereof to a digital data source for audio visual purposes or other digital processing purposes such as for compatibility for computer processing.

The processor may include a transform modeler or contain instructions for execution by a transform modeler provided a part from the processor . The transform modeler may include logic for executing the instructions to perform the transform modeling and image reconstruction as discussed in the present disclosure.

The computer system may also include a disk or optical drive unit . The disk drive unit may include a non transitory computer readable medium in which one or more sets of instructions e.g. software can be embedded. Further the instructions may perform one or more of the operations as described herein. The instructions may reside completely or at least partially within the memory and or within the processor during execution by the computer system .

The memory and the processor also may include non transitory computer readable media as discussed above. A computer readable medium computer readable storage medium machine readable medium propagated signal medium and or signal bearing medium may include any device that includes stores communicates propagates or transports software for use by or in connection with an instruction executable system apparatus or device. The machine readable medium may selectively be but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium.

Additionally the computer system may include an input device such as a keyboard or mouse configured for a user to interact with any of the components of the computer system . It may further include a display such as a liquid crystal display LCD a cathode ray tube CRT or any other display suitable for conveying information. The display may act as an interface for the user to see the functioning of the processor or specifically as an interface with the software stored in the memory or the drive unit .

The computer system may include a communication interface that enables communications via the communications network . The network may include wired networks wireless networks or combinations thereof. The communication interface network may enable communications via any number of communication standards such as 802.11 802.17 802.20 WiMax cellular telephone standards or other communication standards.

Accordingly the method and system may be realized in hardware software or a combination of hardware and software. The method and system may be realized in a centralized fashion in at least one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software may be a general purpose computer system with a computer program that when being loaded and executed controls the computer system such that it carries out the methods described herein. Such a programmed computer may be considered a special purpose computer.

The method and system may also be embedded in a computer program product which includes all the features enabling the implementation of the operations described herein and which when loaded in a computer system is able to carry out these operations. Computer program in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

The above disclosed subject matter is to be considered illustrative and not restrictive and the appended claims are intended to cover all such modifications enhancements and other embodiments which fall within the true spirit and scope of the present disclosure. Thus to the maximum extent allowed by law the scope of the present embodiments are to be determined by the broadest permissible interpretation of the following claims and their equivalents and shall not be restricted or limited by the foregoing detailed description. While various embodiments have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the above detailed description. Accordingly the embodiments are not to be restricted except in light of the attached claims and their equivalents now presented or presented in a subsequent application claiming priority to this application.

