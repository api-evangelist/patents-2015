---

title: Categorizing and modeling integration adapters
abstract: The disclosure generally describes computer-implemented methods, software, and systems, including a method for generating and storing adapter characterization information. Adapter-related information associated with an adapter is received. Communication patterns associated with the adapter are determined. Quality-of-service patterns are applied to the communication patterns. An adapter flow is configured for the adapter. A visualization of the adapter flow for the adapter is provided. Characterization information determined for the adapter is stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483329&OS=09483329&RS=09483329
owner: SAP SE
number: 09483329
owner_city: Walldorf
owner_country: DE
publication_date: 20150209
---
Integration adapters are a fundamental part of an integration system since they provide applications e.g. business applications with access to a messaging channel. For example messages can be sent and received during an integration process. There can be many different types of integration adapters some of which may share common characteristics. For example similar integration adapters can be characterized and or categorized in the same way.

The disclosure generally describes computer implemented methods software and systems for generating and storing adapter characterization information. For example adapter related information associated with an adapter is received. Communication patterns associated with the adapter are determined. Quality of service patterns are applied to the communication patterns. An adapter flow is configured for the adapter. A visualization of the adapter flow for the adapter is provided. Characterization information determined for the adapter is stored. One computer implemented method includes receiving adapter related information associated with an adapter determining communication patterns associated with the adapter applying quality of service patterns to the communication patterns configuring an adapter flow for the adapter providing a visualization of the adapter flow for the adapter and storing characterization information determined for the adapter.

Integration adapters can be an important part of common integration systems such as enterprise application integration EAI systems enterprise service bus ESB systems and partially manufacturing operations management MOM systems. The adapters can take over crucial tasks such as physical connection handling format conversions scheduling and quality of service QoS support. The adapters can manifest scenario specific pre processing and or post processing capabilities in integration scenarios. Uses and configurations can be related by the conditions under which integration occurs during message processing and the associated processing and communication styles can be grouped into classes.

Current integration system vendors and modeling approaches do not cover systematic classification of adapter types and tasks within an integration system. Further default adapter processing in the integration systems can typically be hidden in various runtime implementations. Also modification of default adapter processing is typically nonexistent.

Being able to systematically describe adapter processing in integration systems visualize the default behavior and modify default behavior can allow for a better understanding of integration semantics. This can also provide a higher level of control over a system s behavior and consequently a more configurable modular and or adaptable system.

Some implementations can use integration flows to specify messaging channels with their control flow and data flow. The adapter processing may be hidden e.g. behind property sheets. Without an explicit adapter flow for example information regarding the adapter s behavior may not be provided during the reception sending and or processing of messages. Consequently a developer who maintains the adapter may need to delve into the source code of the configuration to be able to judge the corresponding behavior of the associated adapter processing. As such partners and customers may not be able to create scenario specific variations of adapters or model common aspects of adapter processing. Common aspects can include for example QoS synch asynch and asynch synch bridges and or other aspects.

Other implementations of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software firmware hardware or a combination of software firmware or hardware installed on the system that in operation causes or causes the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

The foregoing and other implementations can each optionally include one or more of the following features alone or in combination. In particular one implementation can include all the following features 

In a first aspect combinable with any of the previous aspects the adapter is an integration adapter and receiving adapter related information associated with an adapter includes identifying an adapter type for the adapter determining a modeling complexity for the adapter determining an integration style for the adapter identifying a quality of service level for the adapter and capturing adapter tasks and an architecture associated with the adapter.

In a second aspect combinable with any of the previous aspects determining an integration style for the adapter includes identifying message exchange patterns that identify whether a message is in only or in out.

In a third aspect combinable with any of the previous aspects determining communication patterns associated with the adapter includes identifying communication styles and bridges for the adapter and determining one or more processing patterns for the adapter.

In a fourth aspect combinable with any of the previous aspects applying quality of service patterns to the communication patterns includes checking reliability messaging for the adapter checking idempotency requirements for the adapter and checking messaging re sequencing for the adapter.

In a fifth aspect combinable with any of the previous aspects adapter types are selected from the group comprising consumer only adapters producer only adapters consumer producer adapters polling adapters and event based adapters.

In a sixth aspect combinable with any of the previous aspects applying quality of service patterns to the communication patterns includes identifying message delivery types selected from the group comprising best effort BE at least once ALO exactly once EO and exactly once in order EOIO .

In a seventh aspect combinable with any of the previous aspects each adapter is associated with a template.

In an eighth aspect combinable with any of the previous aspects the stored characterization information is used in a separation of an integration process and an adapter flow for modularity deployment options and potentially heterogeneous system setups along same semantics.

The subject matter described in this specification can be implemented in particular implementations so as to realize one or more of the following advantages. Extract transform load vendors can specify adapter like processing that is similar to adapter flows. Data integration modeling applications can include graphic representations associated with adapters. Adapter categorization and presentation tools can provide a systematic approach to identifying documenting and presenting common adapter characteristics e.g. including adapter classifications e.g. for synch asynch bridges QoS levels . Adapter categorization and presentation tools can use standard or proprietary syntax notations e.g. well known and widely used standards such as Business Process Model and Notation BPMN . Adapter categorization and presentation tools can provide wider applicability thus reducing learning curves for developers. Adapter flows allow a user to define not only the processing of messages but also the behavior in case of exceptional situations during the processing i.e. exception handling . Separate adapter definitions allow for modular system setups in which adapter runtime systems can be exchanged by equivalent ones with respect to the adapter flow execution i.e. adapter virtualization . Adapter runtime systems can be distributed e.g. running different organizational networks while guaranteeing the specified integration semantics.

The details of one or more implementations of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

This disclosure generally describes computer implemented methods software and systems for characterizing adapters. For example adapters such as integration adapters are a fundamental part of an integration system since they can provide business applications or other applications with access to their messaging channel. However in conventional systems their modeling and configuration remain under represented. For example while integration control and data flow syntax and semantics may be expressed in the Business Process Model and Notation BPMN as a semantic model for message based integration adapter and the related quality of service modeling are limited.

In this disclosure common adapter capabilities are specified and general modeling patterns are derived for which a compliant representation is defined in BPMN. The patterns discussed can extend previous work by the adapter flow AF e.g. adapters are evaluated syntactically and semantically for common adapter characteristics.

Adapter Classification can provide a solid basis for a systematic categorization of adapters in integration systems e.g. by providing a sound and comprehensive classification of adapter processing within integration systems. For example adapter classification can apply to different adapter types e.g. quality of service QoS adapter tasks and can include all known adapter characteristics.

In some implementations visualization of default and custom processing can be provided. For example based on an adapter s classification an AF syntax for the processing of the different adapter types can be defined. In addition common processing can be grouped to adapter processing strategies e.g. message redelivery skip failed activity continue and use original message . These constructs can be further analyzed and combined to adapter patterns e.g. synch asynch bridge AF quality of service levels that allow for modular adapter modeling.

QoS e.g. best effort exactly once and transactional processing can be considered with the adapter processing. For example QoS and transaction scoping patterns and a syntax can be identified that fits to the AFs.

Along with the syntax a mapping can be defined for a cloud integration runtime system e.g. a service platform and a compiler syntax can be provided to a runtime system. The mapping can be reversible and existing configurations can be visualized. Modification of default and custom processing can occur. For example a defined syntax can allow for the introduction of specific adapter flows AFs while leveraging processing strategies and patterns on the identified scopes.

Enterprise application integration can be used by organizations as means of integrating their conventional business applications with each other e.g. with the growing amount of cloud applications and integration with partners systems. In many cases the integration middleware systems can serve as the enabling technology for distributed mission critical business processes. For that to occur these systems can offer well defined modeling capabilities to describe integration semantics e.g. message creation transformation routing as well as runtime systems that interpret the definitions for efficient message processing.

At a high level the server comprises an electronic computing device operable to collect store and provide access to information for use by the client device . A data store of adapter information for example can include information received from the plural client devices . For example users can provide specific information for an adapter that the server can use to characterize the adapter. The adapter information can also include information maintained by the server for use in characterizing adapters using information received from user inputs. Characterization information that is determined by the application server can be stored in a data store of characterization information . For example the characterization information that is stored can characterize an adapter to one or more of the adapters described below with reference to .

As used in the present disclosure the term computer is intended to encompass any suitable processing device. For example although illustrates a single server the environment can be implemented using two or more servers as well as computers other than servers including a server pool. Indeed the server may be any computer or processing device such as for example a blade server general purpose personal computer PC Macintosh workstation UNIX based workstation or any other suitable device. In other words the present disclosure contemplates computers other than general purpose computers as well as computers without conventional operating systems. Further illustrated server may be adapted to execute any operating system including Linux UNIX Windows Mac OS Java Android iOS or any other suitable operating system. According to some implementations the server may also include or be communicably coupled with an e mail server a web server a caching server a streaming data server and or other suitable server s . In some implementations components of the server may be distributed in different locations and coupled using the network .

In some implementations the server includes an application server that performs processing at the server that is needed to support requests for data and analysis of information received from the client device . For example the application server can receive adapter related information and inputs from the client device . Further the application server can use the received information to characterize an adapter as having characteristics as described below with reference to .

The application server includes a user request module for example that can receive from the client device adapter related information associated with an adapter. For example the information received can be information provided by the user in a client application such as a front end for inputting adapter related information used to characterize a specific adapters. The user request module can also prepare data that is to be presented by a presentation module at the client device . For example the user request module can prepare data for presentation based on user inputs received by a communication module . The inputs for example can include user inputs for specifying particular information associated with an adapter. The user request module can also be used by the server for communicating with other systems in a distributed environment connected to the network e.g. the client device as well as other systems not illustrated communicably coupled to the network . Generally the user request module comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the user request module may comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated environment .

The application server further includes a communication pattern module for determining communication patterns associated with an adapter. For example determining communication patterns can include identifying communication styles and bridges for a given adapter and determining one or more processing patterns for the adapter as described below with reference to .

The application server further includes a quality of service module that can be used to apply quality of service patterns to the communication patterns. For example applying quality of service patterns can include checking reliability messaging for the adapter checking idempotency requirements for the adapter and checking messaging re sequencing for the adapter. Information used for applying quality of service patterns to the communication patterns can be accessed from the adapter information .

The application server further includes an adapter flow module . For example the adapter flow module can configure an adapter flow for the adapter based on adapter flow information that is stored in the adapter information .

The application server further includes a visualization module . As an example the visualization module can generate instructions so that a visualization for an adapter can be displayed on the client device . For example the visualization can match one of the visualizations shown in .

The server further includes a processor and memory . Although illustrated as the single processor in two or more processors may be used according to particular needs desires or particular implementations of the environment . Each processor may be a central processing unit CPU an application specific integrated circuit ASIC a field programmable gate array FPGA or another suitable component. Generally the processor executes instructions and manipulates data to perform the operations of the client device . Specifically the processor executes the functionality required to receive and process requests from the client device and analyze information received from the client device .

The memory or multiple memories may include any type of memory or database module and may take the form of volatile and or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. The memory may store various objects or data including caches classes frameworks applications backup data business objects jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto associated with the purposes of the server . In some implementations memory includes one or more of the adapter information and the data store of characterization information . Other components within the memory are possible.

Each client device of the environment may be any computing device operable to connect to or communicate with at least the server via the network using a wire line or wireless connection. In general the client device comprises an electronic computer device operable to receive transmit process and store any appropriate data associated with the environment of .

A request handler e.g. included in the application server can receive inputs and handle requests received from the client device . Specifically the request handler can receive user inputs including adapter related information entered by the user on the client application . In some implementations the request handler can also process requests received from other sources in addition to client devices e.g. requests received from external systems .

The illustrated client device further includes a processor a memory and an interface . The interface is used by the client device for communicating with other systems in a distributed environment including within the environment connected to the network e.g. the server as well as other systems communicably coupled to the network not illustrated . Generally the interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the interface may comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated environment .

Regardless of the particular implementation software may include computer readable instructions firmware wired and or programmed hardware or any combination thereof on a tangible medium transitory or non transitory as appropriate operable when executed to perform at least the processes and operations described herein. Indeed each software component may be fully or partially written or described in any appropriate computer language including C C Java Visual Basic assembler Perl any suitable version of 4GL as well as others. While portions of the software illustrated in are shown as individual modules that implement the various features and functionality through various objects methods or other processes the software may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

As illustrated in the client device includes the processor . Although illustrated as the single processor in two or more processors may be used according to particular needs desires or particular implementations of the environment . Each processor may be a central processing unit CPU an application specific integrated circuit ASIC a field programmable gate array FPGA or another suitable component. Generally the processor executes instructions and manipulates data to perform the operations of the client device . Specifically the processor executes the functionality required to send requests to the server and to receive and process responses from the server .

The illustrated client device also includes a memory or multiple memories . The memory may include any memory or database module and may take the form of volatile or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. The memory may store various objects or data including caches classes frameworks applications backup data business objects jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto associated with the purposes of the client device .

The illustrated client device is intended to encompass any computing device such as a smart phone tablet computing device PDA desktop computer laptop notebook computer wireless data port one or more processors within these devices or any other suitable processing device. For example the client device may comprise a computer that includes an input device such as a keypad touch screen or other device that can accept user information and an output device that conveys information associated with the operation of the server or the client device itself including digital data visual information or a graphical user interface GUI as shown with respect to and included by the client device . The GUI interfaces with at least a portion of the environment for any suitable purpose including generating user interface screens that support user input of adapter related information and display visualizations of adapters using information received from the server .

In some implementations the AF compiler toolchain includes various steps for classifying and modeling adapters. For example a step can parse and obtain adapter information. A step for example can apply rules and or other transformations to the parsed obtained adapter information. A step for example can generate runtime code associated with the adapter. A step for example can package and deploy the adapter. The AF compiler toolchain can use adapter information in an AF registry e.g. that includes information associated with patterns and characteristics in different adapter types. The AF compiler toolchain includes processing for example that supports steps in the method process described below with respect to .

Processing among the adapters and and an integration process can include information sent by an application system e.g. a sender a sender side adapter a receiver side adapter and a receiver application system . Other processing is possible. The processing can make use of information stores in data stores used by the adapters.

Integration semantics can be described based on a comprehensive often graphically depicted syntax and execution semantics e.g. process model . Some implementations can collect a widely used and accepted collection of integration patterns that are typical concepts used when implementing a messaging system and have proven to be useful in practice. However the implementations may not specify a semantic model for the formalization of the integration syntax and semantics. Most noticeable the integration adapter modeling with its manifold characteristics can be reduced to a channel adapter icon in the figure.

In some implementations a domain specific language DSL can be studied and provided with well defined building blocks for modeling enterprise integration patterns EIPs in the Business Process Model and Notation BPMN which is typically considered a de facto standard for modeling business process semantics and their runtime behavior. EIPs can be mapped to BPMN compatible syntax and defined execution semantics adapted to message processing. The use of EIPs can be extended to end to end flows of messages called integration flows IFlows . An IFlow can be considered as message based integration from a sending application e.g. sender BPMN participant to one or many receiving applications e.g. receiver s BPMN participants . The message based integration can use BPMN message flow configurations e.g. denoting the inbound and outbound adapters and dedicated participant s that specify an integration process composition of EIPs . In some implementations BPMN can be used for defining a message based integration DSL due to its sufficient coverage of control flow data exception flow process modeling capabilities and execution semantics. Current work in the area of data in business processes for example includes configuration based release processes COREPRO which mainly deals with data driven process modeling business object status management and UML activity diagrams. However BPMN can achieve higher coverage in the categories relevant for the approach. As will be appreciated by those of ordinary skill in the art other design artifacts and modeling methodologies instead of or in addition to EIPs and BPMN can be used.

This disclosure describes a comprehensive investigation of the range of characteristics of adapters during the integration flow processing and the various ways in which they can be addressed. This provides the foundation for a classification of the adapter modeling which can be subsequently defined in the form of an AF and patterns. The pattern based approach to adapter classification can be an extension and improvement over existing EIPs and the IFlow. For example the adapter processing patterns have proven to be intuitive to both practitioners and researchers alike and have been widely utilized for a variety of purposes including customer and partner content development. The adapter processing patterns provide the conceptual foundations for a cloud integration system which can be an integration as a service implementation based on an open source integration system. The motivation for this disclosure is to provide a conceptual framework for classifying the adapter processing capabilities of middleware systems more generally based on the IFlow modeling approach while being independent of the specific runtime platforms. Major components of this work are 1 a comprehensive classification of common adapter characteristics in integration systems and beyond 2 an extension of the BPMN based IFlow model for adapter flows AFs that make default processing visible to the user for all identified categories from and allows for change of the default behavior 3 the derivation of common adapter processing patterns and their representation in BPMN and 4 the application to an existing open source middleware system. This disclosure proposes to answer to the underlying questions such as which QoS does the IFlow in have and how can the default handling be adapted to custom requirements 

Regarding adapter modeling characteristics the following section introduces a generalized integration system architecture describes classifying adapter characteristics into classifications and describes formulating the classifications as modeling requirements. The adapter type classification can be supported by an analysis of some number of message endpoints e.g. using experience and knowledge provided by experienced integration experts.

Adapters can be canonically differentiated by their type e.g. consumer or producer. A consumer adapter for example can allow the message sender applications to connect to the integration system. Message consumers can be further sub divided by their behavior into polling and event based adapters. The polling adapter e.g. S FTP can be configured to actively check for messages to read and process the messages e.g. a model polling consumer . As such settings like the polling interval location initial delay and format can be specified. In contrast an event based consumer can specify an endpoint configuration e.g. a servlet URI on which the configuration can register a passive listener that waits for events or callbacks from the sender e.g. a model event based consumer . A producer adapter can forward the messages to their receivers e.g. a model producer . As a result adapters can be consumer only adapters producer only adapters or consumer producer adapters. Despite the difficult task of determining active adapters a significant percentage of sender adapters can be classified as polling. 

Configuration complexity is another way of classifying adapters. For example an analysis of 119 component bundles can result in identifying 151 single components or adapters. Components such as mail for example can encapsulate multiple endpoints represented by protocols such as SMTP POP3 IMAP and or other protocols. Another outcome of the analysis may show a percentage of components that require more complex configurations e.g. for the parameterization of connection and credential details e.g. key trust store references as shown in . In some implementations scenario specific adaptations can be identified for an adapter s behavior. For example the adapter can provide extension points to hook in one or more custom processors which can be modeled similar to an IFlow. Evidence for such a requirement can also be found in concepts such as channel modules e.g. in process integration middleware systems. This can serve as an extension to adapters which can be combined to the notion of message channel modeling similar to the integration process. As such a message channel can consist of consumer producer adapters and arbitrarily many ordered processors.

Integration Styles are another way of classifying adapters. For example a message exchange pattern MEP can define whether a message is sent inOnly i.e. one way or inOut i.e. two way . A two way message for example can require a synchronously sent response while a one way message will never result to a response. A synchronous message exchange can require an immediate response during the initiated communication i.e. mostly by event based adapters while an asynchronous exchange can allow for an early close of the initiated communication and the response can be sent using mechanisms such as function method callback . An example adapter in this context is a persistent adapter such as a web service reliable message adapter. This adapter for example can receive and store the message send an immediate response and then start a transactional redelivery. This type of adapter includes synch asynch bridge adapters e.g. in model message synch asynch or asynch synch communication. These adapters are necessary to bridge asynch communication to synch endpoints and vice versa.

QoS is another way of classifying adapters. For example service qualities of an integration system can be induced or supported by adapters such as listed here in increasing quality level best effort BE at least once ALO exactly once EO and exactly once in order EOIO . BE messaging for example can be summarized as fire and forget which means that no guarantee for the delivery of a message is given. If a message is to be delivered at least once ALO for example then the message has to be persistently stored and redelivered from an adapter or the integration process. In case the message is to be delivered exactly once EO for example then ALO has to be enhanced e.g. by an idempotent receiver which stores the primary identifier of a message and filters out known messages. In idempotent transactions for example data retrieval operations and messaging can be performed reliably without changing or otherwise affecting the data. Although a receiver itself may behave idempotent producer adapters or the integration process can try to act in the receiver s place. For some integration cases for example the strict adherence to a message sequence is important e.g. when creating a business object or before an update . As such messages in this case are to be sent exactly once in order EOIO . Therefore EO can be extended by a resequencer pattern which collects messages to emit them in the correct order.

In some implementations following an IFlow modeling approach adapters can be represented as message flows in BPMN as shown in . This approach can sufficient to model integration processes with a simple adapter configuration although the approach can over define BPMN message flows. The approach can also make the characteristics of an adapter implicit and not allow for modeling of complex logic other than on second level property sheets. For more complex adapter processing an explicitly modeled AF can be defined that is similar to integration processes and uses basic processing capabilities. More complex patterns are then derived from the requirements to model capabilities such as secure communication patterns e.g. request response and bridging and QoS patterns e.g. reliable messaging with transactional redelivery idempotent receiver message resequencer .

An AF can replace the currently used BPMN message flow by an additional BPMN pool outside the integration process for more complex adapters that specify an own control data and exception flow. Thus messaging capabilities as described in the EIPs can be expressed within AFs. However the physical connections to the sender receiver can be represented by message flows.

The AF of adapters with several selectable transport protocols e.g. represented by connector and protocol handler e.g. see can remain stable while the entering message flow of consumer and the leaving message flow of producer adapters can change based on selections. also shows an operation module a secure key store a communication component adapter instances a sender receiver system adapter properties a communication pool and a physical message channel .

Adapter communication patterns can specify several more complex interactions of adapters and integration processes within and outside an organization. For example different adapter communication patterns can have different communication styles and bridge patterns. Common business applications for example can support interfaces for synchronous synch and or asynchronous asynch communication styles. Synch communication for example means applications respond to requests e.g. with error codes or resulting data while the requesting application is blocking in order to get the response e.g. RPC style . In asynch communication for example the sending application sends requests without waiting for responses from other applications and immediately continues with its processing after sending a message e.g. in a non blocking scenario . In some implementations some the sending applications may offer callback interfaces for getting responses back for their previously and asynchronously sent requests. Integrating applications that do not share the same communication style can require an adapter for example for bridging translating between both communication styles.

Following the same pattern shows a model for an asynch to synch bridge adapter and includes the handling of responses and forwarding them to callback interfaces. For example the asynch to synch bridge adapter includes an asynch call a synch call and an external participant . Both bridge adapter modeling patterns can be reused applied and adjusted in other IFlows or inlined to the integration process of an IFlow. also shows start events end events calls and messages responses .

In some implementations of processing patterns AFs can be modeled to adapt between two integration processes across tenant or network boundaries e.g. application to application A2A and business to business B2B for which an integration process is associated to one tenant or network. In the case of cross tenant integration for example the IFlow of tenant Tcan adapt to an IFlow in another tenant Tby representing the IFlow of Tas an delegate in the IFlow of Tand vice versa. As such IFlows are either local to one tenant e.g. meaning that they are locally visible and modifiable or IFlows are remote e.g. meaning that they can only be connected from local IFlows but not made visible or modified . As such for synch communication the remote IFlow can be represented as a collapsed BPMN pool e.g. cannot be expanded and connected to the local integration process with request response BPMN message flows. For reliable asynchronous communication for example a shared data store can be used to make the necessary queuing step explicit. As a representative pattern this remote IFlow delegate can also be used to model across networks or IFlows such as by changing its type.

Different quality of service patterns can exist e.g. with higher QoS levels denoting more complex configuration building blocks. Subsequently the necessary patterns can be defined and mapped to BPMN.

Reliable Messaging is another important aspect associated with adapters and communication. For example to guarantee that a message is not lost in asynchronous scenarios the message can be stored into a message store e.g. database or enqueued to a messaging system e.g. JMS brokers before the reception is explicitly or implicitly acknowledged using an acknowledgement e.g. ACK to the sender. As such an integration system can aim to store the message in the consumer adapter sending the acknowledgement messages to unblock the sender waiting for a response and to minimize the possibilities for errors before a persistency step. Similarly some adapters can access a data store queue for cross applications and software systems e.g. JDBC JMS . AFs can also connect to a BPMN data store e.g. to model key and trust stores.

In some implementations an idempotency repository described below with reference to can be used to support at most once AMO and exactly once EO e.g. in combination with reliable messaging . In this way the integration system needs to take care that messages are not sent twice to a receiver . This can be modeled by a flow step the integration process or AF that filters already sent messages which is preferably executed just before the message is sent to the receiving application in a producer AF. described below show the filter processing as part of a producer AF by accessing the idempotency repository which is represented as a BPMN data store storing the identifiers of already processed messages against which the current message identifier can be checked.

In an example of message re sequencing a resequencer can be used for in order IO scenarios for which the messages are ordered according to a sequence number. Alternatively order preserving queues e.g. specified in JMS are used to keep messages in sequence. EOIO processing can additionally require the combination of reliable messaging with redelivery semantics and a filter step using the idempotency repository to guarantee that the messages are sent exactly once and in order.

In some implementations abstract definitions of BPMN AFs and integration patterns can be applied to the motivating Internet of Things examples e.g. as described above . For example the AFs and integration patterns can provide secure reliable messaging through the case of EOIO integration which represents a complex configuration from the important area of QoS. Further the abstract definitions of BPMN AFs and integration patterns support the visualization and re configuration of the expected default exception handling and compensation in a reliable time series normalization scenario.

The QoS support is crucial for integration systems. When sending a message synchronously to a receiver for example BE can be applied e.g. delivery will be attempted otherwise the sender will receive an exception message. In case of asynchronous reliable in order messaging this approach is not sufficient. The message has to be persistently stored and a retry has to be started to guarantee its delivery e.g. in a message queue since the sender cannot be notified. In addition the order of the messages according to a message sequence has to be guaranteed using a resequencer pattern.

The producer adapter checks whether a message has already been processed and synchronously sends it to a receiver . The receiver s response e.g. acknowledgement or exception is passed to the integration process which triggers a message redelivery on exception. also show a sender other tasks messages start events and end events .

In some implementations information associated with qualitative analysis and experiences can be collected. For example collection of information can include practical experiences with the defined adapter modeling based on an evaluation by experienced integration experts. The evaluation of the approach can be summarized to various topics which are discussed in detail below. Information that is collected can be used to determine for example that in general the integration models with an explicit AF are experienced as more complex. This determination may for example contradict the intended predicted usage of BPMN by business experts. However the visibility of the default adapter characteristics can allow for better insights into the integration flow modeling ease of use and a more intuitive and faster modeling through the identified patterns.

In some implementations tool support explicitly modeled AFs can lead to more complex IFlows that require adequate tool support as users do not want to model them piece by piece. For example using a collapsed read only visualization of the AF the insights can be available on expansion of the pool. Adapters without complex flow logic can remain as message flows. One example technical challenge involved in modeling is the resolution of AFs that become a first level syntax construct when represented as collapsed expanded pool. The AF could be edited in an external view which would reduce the complexity on a view. However the view can hide information through out of context placement. In some implementations an in context editing view can be embedded into the IFlow however the tool can make it more difficult to distinguish between integration processes and AF. In some implementations an editor can also function purely on a pattern level thus making the EIPs and the AF patterns first class entities. As a result a user would not model an IFlow such as the EOIO scenario piece by piece but could select from a list of QoS patterns. According to the feedback e.g. received from modeling experts the pattern based approach can help to deal with the complex syntax and can allow for more modular modeling.

Modeling complexity is another factor to consider regarding modeling. For example some BPMN syntax elements are not applicable to the integration environment in a useful way. For example the lane element has no semantic meaning and can only be used to structure certain aspects of the integration systems such as distinguishing normal logic from AF logic. One possible result is an increase in the size of a diagram leading to a confusing model. Additionally as described with respect to for queuing with a message broker the data association to the message broker is denoted with the queue name to from messages that should be enqueued dequeued. The modeling complexity in may be rated as complex e.g. the adapter communicates with the adapter while the adapter seems more related to the adapter . However the use of this model was determined to be favored over the BPMN signal approach proposed for . In case of many connections to the message broker a partitioning of the IFlow into several smaller diagrams can help to make the single parts more understandable e.g. in context editing . At the same time tool support can be needed to show the complete IFlow on demand. The alternative of modeling several instances of one broker in one IFlow which are then connected to related adapters only is not seen as a desirable solution.

In some implementations modeling preferences made by experts can be used. For example while the modeling of AFs may be very well received the participants who are evaluating models may differentiate between producer and consumer adapter modeling. Producer adapter modeling for example can allow for adding scenario specific pre processing capabilities to the system e.g. before entering the integration process e.g. especially for bridges . Consumer AFs can be determined to be limited to the QoS support while potential post processing logic can be executed in the integration process. However from a modularity and resource consumption point of view a clear separation of adapter and integration process logic can be useful. The explicit modeling of security related topics such as key stores can also be evaluated. For example while participants with a more technical background may prefer the proposed approach e.g. helping them to be precise in the security aspect modeling more business related participants may complain about the additional complexity. However both groups may agree that a more explicit modeling of the inner workings of a message broker is not necessary and the transactional de queuing with the BPMN Transactional Sub Process is rated intuitive.

In some implementations model driven adapter development and re configuration can be used. For example some approaches for automatic adapter generation and dynamic re configuration can be based on a start of authority SOA domain or other approach that does not define a conceptual modeling approach for integration adapters. In another example other approaches can be based on model driven development of web services e.g. while highlighting the importance of a QoS support. Other approaches can target self adapting adapters in terms of signature protocol level and quality related re configurations and planning.

Other approaches can be based on data intensive adapter modeling. For example through data warehouse connectivity scenarios an extract transform load ETL domain can be used for conceptual modeling of more data intensive adapters. Although characteristics such as QoS may not be relevant for data warehouse connectivity these modeling approaches can be seen as domain specific complementary work. For instance ETL processes can be mapped to BPMN and a maintenance framework can be provided. In some implementations UML based approaches can be used e.g. for modeling data mining with time series data or ETL data flows. The approaches can define new icon notations e.g. that are similar to EIP notations. These approaches can focus on the data flow limits the modeling to data transformation.

In some implementations other adapter types can be used in addition to the common adapter types used for integration systems as described above. For example adapter types that are used can extend the BPMN based definition of IFlows by AF constructs and patterns e.g. to make the default adapter behavior visible. Adapter types can also provide a basis for different scenario specific adapter configurations. Definitions for adapters can start for example with a systematical analysis of common adapter characteristics e.g. spanning to edge cases such as QoS modeling.

The mapping of these adapter characteristics to BPMN described above can allow the adapters to be linked to integration flows and can support definitions of common integration adapter processing capabilities and patterns. The approach can be applied to real world Internet of Things integration scenarios such as using the exactly once in order EOIO QoS case. While there is a syntactical feasibility and applicability of the approach any shortcomings due to BPMN s focus on control over data flow can be solved by explicit modeling of AFs as separate BPMN pools.

The approaches described above show the value of a modular pattern based and explicit modeling approach. However other implementations permit modification of pre existing elements and the syntax of BPMN models such as that use of conditional data flows.

At adapter related information associated with an adapter is received. For example the server can receive user inputs including adapter related information from the client device .

In some implementations the adapter is an integration adapter and receiving adapter related information associated with an adapter includes the following. An adapter type is identified for the adapter. A modeling complexity is determined for the adapter. An integration style is determined for the adapter. A quality of service level is identified for the adapter. Adapter tasks and an architecture are captured associated with the adapter. These features for example are represented in .

In some implementations determining an integration style for the adapter includes identifying message exchange patterns that identify whether a message is in only or in out. For example some of the adapters depicted in are shown as in only or in out.

In some implementations adapter types include consumer only adapters producer only adapters consumer producer adapters polling adapters and event based adapters. Examples of adapter types are described above with reference to .

In some implementations applying quality of service patterns to the communication patterns includes identifying message delivery types such as best effort BE at least once ALO exactly once EO and exactly once in order EOIO . For example various message delivery types are described above with reference to .

In some implementations each adapter is associated with a template. For example various templates are described above with reference to . In some implementations when creating a new adapter a user can review existing templates and select one of the templates as a starting point for modeling the new adapter. Selection of the template can be facilitated based on user inputs associated with the new adapter.

At communication patterns associated with the adapter are determined. For example the communication pattern module can determine communication patterns associated with an adapter. Determining communication patterns can include identifying communication styles and bridges for a given adapter and determining one or more processing patterns for the adapter as described above with reference to .

At quality of service patterns are applied to the communication patterns. As an example the quality of service module can apply quality of service patterns to the communication patterns. Applying quality of service patterns can include checking reliability messaging for the adapter checking idempotency requirements for the adapter and checking messaging re sequencing for the adapter. Information used for applying quality of service patterns to the communication patterns can be accessed from the adapter information .

At an adapter flow is configured for the adapter. For example the adapter flow module can configure an adapter flow for the adapter based on adapter flow information that is stored in the adapter information . The adapter flows can match for example flows described above with reference to .

At a visualization of the adapter flow for the adapter is provided. The visualization module for example can generate instructions so that a visualization for an adapter can be displayed on the client device . For example the visualization can match one of the visualizations shown in .

At characterization information determined for the adapter is stored. For example the server can store the characterization information for the adapter in the characterization data .

In some implementations the stored characterization information can be used for a separation of an integration process and an adapter flow for modularity deployment options and potentially heterogeneous system setups e.g. along the same semantics . For example event stream processing or ETL system can be used at adapter runtime while guaranteeing the adapter integration semantics.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry in tangibly embodied computer software or firmware in computer hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on a tangible non transitory computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine readable storage device a machine readable storage substrate a random or serial access memory device or a combination of one or more of them.

The terms data processing apparatus computer or electronic computer device or equivalent as understood by one of ordinary skill in the art refer to data processing hardware and encompass all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can also be or further include special purpose logic circuitry e.g. a central processing unit CPU an FPGA field programmable gate array or an ASIC application specific integrated circuit . In some implementations the data processing apparatus and or special purpose logic circuitry may be hardware based and or software based. The apparatus can optionally include code that creates an execution environment for computer programs e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. The present disclosure contemplates the use of data processing apparatuses with or without conventional operating systems for example LINUX UNIX WINDOWS MAC OS ANDROID IOS or any other suitable conventional operating system.

A computer program which may also be referred to or described as a program software a software application a module a software module a script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network. While portions of the programs illustrated in the various figures are shown as individual modules that implement the various features and functionality through various objects methods or other processes the programs may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. a CPU an FPGA or an ASIC.

Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors both or any other kind of CPU. Generally a CPU will receive instructions and data from a read only memory ROM or a random access memory RAM or both. The essential elements of a computer are a CPU for performing or executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic disks magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a global positioning system GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few.

Computer readable media transitory or non transitory as appropriate suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM DVD R DVD RAM and DVD ROM disks. The memory may store various objects or data including caches classes frameworks applications backup data jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto. Additionally the memory may include any other appropriate data such as logs policies security or access data reporting files as well as others. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display LED Light Emitting Diode or plasma monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse trackball or trackpad by which the user can provide input to the computer. Input may also be provided to the computer using a touchscreen such as a tablet computer surface with pressure sensitivity a multi touch screen using capacitive or electric sensing or other type of touchscreen. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

The term graphical user interface or GUI may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore a GUI may represent any graphical user interface including but not limited to a web browser a touch screen or a command line interface CLI that processes information and efficiently presents the information results to the user. In general a GUI may include a plurality of user interface UI elements some or all associated with a web browser such as interactive fields pull down lists and buttons operable by the business suite user. These and other UI elements may be related to or represent the functions of the web browser.

Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of wireline and or wireless digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN a radio access network RAN a metropolitan area network MAN a wide area network WAN Worldwide Interoperability for Microwave Access WIMAX a wireless local area network WLAN using for example 802.11 a b g n and or 802.20 all or a portion of the Internet and or any other communication system or systems at one or more locations. The network may communicate with for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and or other suitable information between network addresses.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In some implementations any or all of the components of the computing system both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer. The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the computing system. The functionality of the various components of the computing system may be accessible for all service consumers using this service layer. Software services provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in Extensible Markup Language XML format or other suitable format. The API and or service layer may be an integral and or a stand alone component in relation to other components of the computing system. Moreover any or all parts of the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module without departing from the scope of this disclosure.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed but rather as descriptions of features that may be specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation and or integration of various system modules and components in the implementations described above should not be understood as requiring such separation and or integration in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products. Furthermore while the operations depicted in the drawings may indicate start and or end points for the operations implementations of the methods described in the disclosure are not restricted to the particular start and or end point as illustrated. Other implementations may start and or end at different points of the operations.

Particular implementations of the subject matter have been described. Other implementations alterations and permutations of the described implementations are within the scope of the following claims as will be apparent to those skilled in the art. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

Accordingly the above description of example implementations does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

