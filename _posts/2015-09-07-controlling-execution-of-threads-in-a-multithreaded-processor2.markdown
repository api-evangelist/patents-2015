---

title: Controlling execution of threads in a multi-threaded processor
abstract: Execution of threads in a processor core is controlled. The processor core supports simultaneous multi-threading (SMT) such that there can be effectively multiple logical central processing units (CPUs) operating simultaneously on the same physical processor hardware. Each of these logical CPUs is considered a thread. In such a multi-threading environment, it may be desirous for one thread to stop other threads on the processor core from executing. This may be in response to running a critical sequence or other sequence that needs the processor core resources or is manipulating processor core resources in a way that other threads would interfere with its execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582324&OS=09582324&RS=09582324
owner: International Business Machines Corporation
number: 09582324
owner_city: Armonk
owner_country: US
publication_date: 20150907
---
This application is a continuation of co pending U.S. Ser. No. 14 525 800 entitled CONTROLLING EXECUTION OF THREADS IN A MULTI THREADED PROCESSOR filed Oct. 28 2014 which is hereby incorporated herein by reference in its entirety.

One or more aspects relate in general to multi threaded processors and in particular to controlling execution of threads in such processors.

A processor may include multiple hardware threads that have instructions executing simultaneously. Such a processor is said to implement simultaneous multi threading SMT which is a technique used to improve overall efficiency of a processor by permitting multiple independent threads of execution to better utilize resources provided by modern processor architectures.

By controlling execution of the threads of a multi threaded processor further efficiencies may be gained.

Shortcomings of the prior art are overcome and advantages are provided through the provision of a computer implemented method of controlling execution of threads within a computing environment. The computer implemented method includes for instance stopping by a thread running in the processor of the computing environment execution of another thread executing within the processor the stopping using one or more controls in one or more shared registers of the processor the one or more shared registers being shared by the thread and the other thread and performing by the thread based on stopping execution of the other thread one or more operations.

Computer systems and computer program products relating to one or more embodiments are also described and may be claimed herein.

Additional features and advantages are realized. Other embodiments and aspects are described in detail herein and are considered a part of the claimed invention.

In accordance with one or more aspects a capability is provided for controlling execution of threads e.g. hardware threads in a core e.g. a physical hardware processor also referred to herein as a processor or processor core operating within a computing environment. The core supports for instance multi threading such as simultaneous multi threading SMT which means there can be effectively multiple logical central processing units CPUs operating simultaneously on the same physical processor hardware. Each of these logical CPUs is considered a thread.

In such a multi threading environment it may be desirous for one thread to stop other threads on the processor core from executing. This may be in response to running a critical sequence or other sequence that needs the processor core resources or is manipulating processor core resources in a way that other threads would interfere with its execution. In one example as part of the capability it may be desirable to wait until some condition has been satisfied for all the threads on the processor core. For example assume software or firmware running on a particular hardware thread wants to perform a system action that first requires no stores are in progress from the entire processor core that is no stores are in progress on all the threads on the processor core. To determine if the other threads are stopped an instruction referred to herein as a Drain instruction is provided in accordance with one aspect that monitors the status of the threads on the processor core.

Further in accordance with one or more aspects in controlling execution of the threads various atomic instructions may be used. These instructions operate on registers accessible to and shared by the threads of the SMT processor rather than storage or memory. Memory and storage are used interchangeably herein unless otherwise noted implicitly or explicitly. This allows multiple threads to communicate and share information using the shared registers rather than storage. These instructions referred to herein as Compare And Swap R Unit Register or Compare and Swap Register instruction Load and OR R Unit Register or Load and OR Register instruction and Load and AND R Unit Register or Load and AND Register instruction control access to the shared registers using interlocking as described herein.

One example of a computing environment to incorporate and use one or more aspects of controlling execution of threads is described with reference to . Referring to in one example a computing environment is based on the z Architecture offered by International Business Machines IBM Corporation Armonk N.Y. The z Architecture is described in an IBM Publication entitled z Architecture Principles of Operation Publication No. SA22 7832 09 10Edition September 2012 which is hereby incorporated by reference herein in its entirety.

Z ARCHITECTURE IBM and Z VM Z OS POWER and POWERPC referenced herein are registered trademarks of International Business Machines Corporation Armonk N.Y. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

As one example computing environment includes a central processor complex CPC coupled to one or more input output I O devices via one or more control units . Central processor complex includes for instance a processor memory a.k.a. main memory main storage central storage coupled to one or more processor cores and an input output subsystem each of which is described below.

Processor memory includes for example one or more partitions e.g. logical partitions and processor firmware which includes e.g. a logical partition hypervisor and other processor firmware . One example of logical partition hypervisor is the Processor Resource System Manager PR SM offered by International Business Machines Corporation Armonk N.Y.

A logical partition functions as a separate system and has one or more applications and optionally a resident operating system therein which may differ for each logical partition. In one embodiment the operating system is the z OS operating system the z VM operating system the z Linux operating system or the TPF operating system offered by International Business Machines Corporation Armonk N.Y.

Logical partitions are managed by logical partition hypervisor which is implemented by firmware running on cores . As used herein firmware includes e.g. the microcode and or millicode of the processor core. It includes for instance the hardware level instructions and or data structures used in implementation of higher level machine code. In one embodiment it includes for instance proprietary code that is typically delivered as microcode that includes trusted software or microcode specific to the underlying hardware and controls operating system access to the system hardware.

Processor cores are physical processor resources allocated to the logical partitions. In particular each logical partition has one or more logical processors each of which represents all or a share of a core allocated to the partition. The logical processors of a particular partition may be either dedicated to the partition so that the underlying core resource is reserved for that partition or shared with another partition so that the underlying core resource is potentially available to another partition.

In one example at least one of the cores is a multi threading processor such as a simultaneous multi threading processor that includes multiple threads i.e. multiple logical CPUs operating simultaneously . In one example the core includes two threads but in other embodiments there may be more than two threads. Two threads referred to herein as T and T are only one example.

In support of simultaneous multi threading the processor core hardware contains the full architected state e.g. z Architecture and micro architected state for each thread. Thus processor wide registers which are common to all threads referred to herein as common registers as well as thread specific registers which are unique to a thread referred to herein as unique registers are provided. Use of these registers is described further below.

To control execution of the multiple threads core includes hardware and or logic to provide such control as described herein. This hardware and or logic is referred to herein as a thread control facility for convenience.

Input output subsystem directs the flow of information between input output devices and main storage . It is coupled to the central processing complex in that it can be a part of the central processing complex or separate therefrom. The I O subsystem relieves the processor cores of the task of communicating directly with the input output devices and permits data processing to proceed concurrently with input output processing. To provide communications the I O subsystem employs I O communications adapters. There are various types of communications adapters including for instance channels I O adapters PCI cards Ethernet cards Small Computer Storage Interface SCSI cards etc. In the particular example described herein the I O communications adapters are channels and therefore the I O subsystem is referred to herein as a channel subsystem. However this is only one example. Other types of I O subsystems can be used.

The I O subsystem uses one or more input output paths as communication links in managing the flow of information to or from input output devices . In this particular example these paths are called channel paths since the communication adapters are channels.

Another example of a computing environment to incorporate and use one or more aspects of controlling execution of threads is described with reference to . In this example a computing environment includes a non partitioned environment implemented based on the z Architecture or another architecture in another embodiment . It includes a core that includes for instance one or more caches at least two threads T T a common set of registers for the threads and a unique set of registers for each thread as well as a thread control facility .

Core is communicatively coupled to a memory having one or more caches and at least one control utility such as an operating system and to an input output I O subsystem . I O subsystem is communicatively coupled to external I O devices that may include for example data input devices sensors and or output devices such as displays.

Another embodiment of a computing environment to incorporate and use one or more aspects of controlling execution of threads is described with reference to . In this example a computing environment includes for instance a native core a memory and one or more input output devices and or interfaces coupled to one another via for example one or more buses and or other connections. As examples computing environment may include a PowerPC processor or a Power Systems server offered by International Business Machines Corporation Armonk N.Y. an HP Superdome with Intel Itanium II processors offered by Hewlett Packard Co. Palo Alto Calif. and or other machines based on architectures offered by International Business Machines Corporation Hewlett Packard Intel Oracle or others.

Native core includes one or more native registers such as one or more general purpose registers and or one or more special purpose registers used during processing within the environment that include information that represents the state of the environment at any particular point in time. Further native core may include for instance at least two threads T T a set of common registers for the threads a set of thread specific registers for each thread and a thread control facility .

Moreover native core executes instructions and code that are stored in memory . In one particular example the processor core executes emulator code stored in memory . This code enables the computing environment configured in one architecture to emulate one or more other architectures. For instance emulator code allows machines based on architectures other than the z Architecture such as PowerPC processors Power Systems servers HP Superdome servers or others to emulate the z Architecture and to execute software and instructions developed based on the z Architecture.

In a further embodiment as shown in core is a single threaded core but a multi threaded core is being emulated and included within emulator code . For instance emulator code includes an emulated thread control facility emulated threads emulated common registers and emulated unique registers each of which is based on an architecture different from the architecture of native core such as the z Architecture.

Further details relating to emulator code are described with reference to . Guest instructions stored in memory comprise software instructions e.g. correlating to machine instructions that were developed to be executed in an architecture other than that of native core . For example guest instructions may have been designed to execute on a z Architecture core but instead are being emulated on native core which may be for example an Intel Itanium II processor. In one example emulator code includes an instruction fetching routine to obtain one or more guest instructions from memory and to optionally provide local buffering for the instructions obtained. It also includes an instruction translation routine to determine the type of guest instruction that has been obtained and to translate the guest instruction into one or more corresponding native instructions . This translation includes for instance identifying the function to be performed by the guest instruction and choosing the native instruction s to perform that function.

Further emulator code includes an emulation control routine to cause the native instructions to be executed. Emulation control routine may cause native core to execute a routine of native instructions that emulate one or more previously obtained guest instructions and at the conclusion of such execution return control to the instruction fetch routine to emulate the obtaining of the next guest instruction or a group of guest instructions. The guest instructions may be instructions of the thread control facility described herein. Execution of the native instructions may include loading data into a register from memory storing data back to memory from a register or performing some type of arithmetic or logic operation as determined by the translation routine.

Each routine is for instance implemented in software which is stored in memory and executed by native core . In other examples one or more of the routines or operations are implemented in firmware hardware software or some combination thereof. The registers of the emulated processor may be emulated using registers of the native core or by using locations in memory . In embodiments guest instructions native instructions and emulator code may reside in the same memory or may be disbursed among different memory devices.

The computing environments described above are only examples of computing environments that can be used. Other environments including but not limited to other non partitioned environments other partitioned environments and or other emulated environments may be used embodiments are not limited to any one environment.

As indicated above associated with each thread is a plurality of registers. One shared register common to the threads is a control register such as a millicode control register MCR MCR002 an example of which is depicted in . MCR002 includes various controls for SMT that determines how the threads behave. In one embodiment MCR002 includes a plurality of fields and those fields used in accordance with one or more aspects include for instance 

Another register used is an instruction address register which is unique for each thread. This register referred to as IAREGFA includes information about a program interruption detected by hardware. An example of IAREGFA is depicted in . As shown IAREGFA includes a plurality of fields . One field used in accordance with one or more aspects is field that indicates the thread is in process of taking an exception.

Each of the above registers may include additional less and or different fields. Further there may be other registers that are used. The registers and fields described herein are examples of registers and or fields that may be used. Further MCR and IAREGFA are just examples of names of the registers. Many variations are possible.

To increase instruction throughput each thread uses an instruction pipeline for processing allowing multiple operations to be performed at the same time. An instruction pipeline includes a plurality of stages and one example of such a pipeline is described with reference to . Referring to a pipeline which supports out of order processing includes for instance an instruction fetch stage in which instructions are fetched from memory an instruction decode dispatch stage which forms dispatch completion groups and puts instructions into the issue queue an issue stage in which the instructions are issued out of order an execute stage in which the instructions are executed out of order a finish stage in which instructions are finished out of order a completion stage which refers to an architectural checkpoint and a recovery checkpoint stage . Other pipelines may include additional less and or different stages. The stages described herein are only examples.

In one example up to three instructions in particular micro operations can be placed into a group. However certain instructions such as branch instructions end a group even if it is not full. A full group of instructions is steered to the same issue queue and then the next group goes into another issue queue.

In accordance with an aspect of the present invention a capability is provided for one thread running in a core to stop one or more other threads executing within the core in order to perform one or more operations. In the examples described herein the core is an SMT 2 design indicating that there are two threads. However in other embodiments there may be more than two threads.

One embodiment of the logic used to control execution of one or more threads is described with reference to . In this example Thread T executing on a core is attempting to stop Thread T executing on the core and therefore the description refers to T and T however in other embodiments T may be attempting to stop T and or there may be more than one thread executing on the core being stopped. For instance T may be stopping T T T etc. Further in the examples described herein the logic is performed by firmware of the core however in one or more other embodiments it may be performed by general purpose software. Many other variations are possible.

As described with reference to in one embodiment one thread stops execution of another thread and the stopping uses one or more controls e.g. indicators bits etc. in one or more registers e.g. hardware registers shared by the threads.

Referring to in one embodiment Thread checks whether T or in other embodiments one or more threads of the core is prohibiting being stopped STEP . In one example this is determined by checking a selected bit e.g. bit of MCR002 as well as a selected bit e.g. bit of IAREGFA. This is accomplished in one example by T testing a branchpoint referred to a STPIFALW. STPIFALW tests the selected bits of MCR002 and IAREGFA. For instance if MCR0002.25 i.e. bit of MCR002 is set to zero and IAREGIFA.4 i.e. bit of IAREGIFA is set to zero then the stopping of I fetching of T is allowed.

If STPIFALW indicates that T is prohibiting being stopped INQUIRY then processing continues to STEP . However if T is not prohibiting being stopped as indicated by STPIFALW and in particular MCR002.25 0 and IAREGFA.4 0 then processing continues by T stopping instruction fetching and execution on T STEP . In one example this includes T setting the transient stop I fetch bit for T e.g. MCR002.9 which stops instruction fetching and execution on T. This bit is set using for instance a Compare and Swap R Unit Register CSGRU instruction or a Load and OR R Unit register instruction each of which is described below.

Thereafter T performs a drain operation for all the threads DRAIN ALLTIDS STEP which holds instruction dispatch for T until all instructions on T are drained or flushed from the pipeline and queries T for status. In one example a Drain instruction is used to perform the drain operation an example of which is described below.

While the pipeline is being drained of the instructions on the other threads INQUIRY processing continues with STEP . However responsive to the instructions on T being drained T continues instruction dispatch and execution for T STEP .

Thereafter T checks again whether T and other threads if any is prohibiting being stopped to ensure T did not change its status after being tested but before being stopped STEP . This check is performed as described above using STPIFALW. If T is now prohibiting being stopped INQUIRY then T allows T to continue to execute by turning off bit of MCR002 i.e. set it to zero STEP . Processing proceeds to STEP .

Otherwise if T is not prohibiting being stopped INQUIRY then T performs the instruction sequence e.g. one or more operations that caused the stopping of T STEP . After that instruction sequence is complete T is allowed to continue STEP . Thus T resets bit in MCR002 by using for instance a Load and AND R Unit LNRU instruction or CSGRU as described below. Thereafter both threads execute normally STEP .

As described above a number of instructions are used to control execution of one or more threads of a multi threading processor. Each of these instructions is described below.

Referring to one embodiment of a Drain instruction is described. In particular depicts one embodiment of a format of the Drain instruction and depicts one embodiment of the logic associated with the Drain instruction.

With reference to a Drain instruction includes an opcode field that includes an operation code identifying a drain operation a mask M field that includes a value indicating a stall count which specifies how many cycles processing is stalled and an instruction field I that indicates the type of drain which in this example is a drain all TIDS Thread IDs specifying that all threads are to be drained.

In operation and with reference to thread T halts instruction processing for T at the instruction decode or dispatch stage of the pipeline until specified conditions are met STEP . Specified bits of the I field of the instruction e.g. bits 0 31 of I which are e.g. bits 16 47 of the I text field which includes all of the fields of the instruction specify which one or more hardware conditions are to be met prior to continuing instruction processing. In one embodiment the specified conditions include a cross thread control e.g. bit of the I field bit of the I text field which checks the status of T or other threads to determine whether processing has been halted on T. When bit of the I field is 1 b it specifies that all the other drain conditions are to be met on both threads in order to continue processing on this thread the other thread s are not blocked by a DRAIN on this thread . When using this function care is to be taken to avoid hangs.

In one or more embodiments other conditions may be specified in the I field. A one in a given bit position indicates that condition is to be met prior to resuming instruction processing if more than one bit is on all selected conditions are to be met. In implementation in one embodiment when I text bit i.e. bit of the I field is 1 the logical OR of both or all hardware threads status functions are performed on a bit by bit basis before ORing together all functions that are selected to determine the final value of whether the DRAIN conditions are satisfied.

A determination is made as to whether the specified conditions have been met INQUIRY . If not then the halting continues STEP . Otherwise if the conditions have been met processing is stalled an additional number of cycles STEP . This additional number may be zero or more and is specified in the M field of the Drain instruction. For instance the M field specifies an additional number of cycles between 0 and 15 as examples to stall after the conditions specified in the I field are satisfied. Subsequent to stalling the additional number of cycles instruction processing resumes STEP .

In one embodiment if a prior instruction and the drain are being dispatched simultaneously the prior instruction is allowed to complete dispatch and continue through the pipeline normally but the Drain instruction and all subsequent instructions will be blocked at dispatch until the conditions are satisfied. Note that the Drain instruction only operates on this thread in delaying processing. To stop another thread the technique described herein is used. However a specified bit e.g. bit of I when indicates that all specified conditions on all threads are to be met in order to continue processing after the drain instruction on this thread.

As indicated the M field of the instruction specifies the number of additional cycles to stall at the pipeline. This may be used in conjunction with any of the allowed conditions in the I field. It may also be specified with the I field all zeros which gives an immediate cycle count delay at dispatch. There is a stall of one cycle in dispatching of the Drain instruction even when the M field is zero. Therefore this count specifies the number of cycles to delay plus one cycle. The hardware can issue the Drain along with other instructions and it can issue out of order since it only affects the front end stages of the pipeline.

This instruction is intended for use where the necessary interlocks to guarantee correct operation are not built into the hardware. In most cases the hardware automatically covers windows from prior instructions in the pipeline.

Another instruction used is the Compare and Swap R Unit Register instruction which is described with reference to . In particular depicts one embodiment of a format of the Compare and Swap R Unit Register instruction and depicts one embodiment of the logic associated with the Compare and Swap R Unit Register instruction. It should be noted that R Unit in the instructions discussed herein refers to a particular unit within the core that performs the instruction. However the use of a particular unit is not necessary. It may be performed by other units or simply by the core.

With reference to a CSGRU instruction includes at least one opcode field including an operation code specifying a compare and swap register operation a first register field R a second register field R and an instruction field I each of which is described below.

In operation and with reference to the contents of the R Unit register referred to herein as MCR specified by the 10 bit absolute register number indicated in selected bits e.g. bits 22 31 of the I text e.g. bits 6 15 of the I field are compared with the contents of a general register GR specified in R STEP . If they are equal INQUIRY then the contents of MCR is written to the general register specified in R STEP and the contents of the general register specified in R is written to MCR STEP . Additionally the condition code is set to zero STEP and processing of CSGRU is complete.

Returning to INQUIRY if the contents of MCR and the register specified in R are not equal then the contents of MCR are written to the register specified in R STEP and the condition code is set to one STEP . This concludes processing of CSGRU.

The read compare replace function of CSGRU is an atomic operation as observed by this thread T and the other threads of this processor e.g. T . In one embodiment CSGRU is executed with the SLOW option on in order to avoid cross thread hangs. The SLOW option is indicated by setting a selected bit e.g. bit of I to one and is used to request slow mode which means there is only one instruction in the entire pipeline at a time. Further interlocking is performed with this instruction as described below and therefore a selected bit e.g. bit of I referred to herein as ILOCK is set to one.

In one embodiment this instruction is rejected and reissued if another selected instruction such as RSR Read Special Register WSR Write Special Register NSR AND Special Register OSR OR Special Register XSR Exclusive OR Special Register TRBIT Test Register Bit RASR Read Absolute Special Register WASR Write Absolute Special Register TARBIT Test Absolute Register Bit NASR AND Absolute Special Register OASR OR Absolute Special Register XASR Exclusive OR Absolute Special Register LORU Load and OR R Unit Register LNRU Load and AND R Unit Register or CSGRU Compare and Swap R Unit Register is in the pipeline for this thread T or any other thread and the ILOCK bit e.g. I bit is on for the other instruction. This instruction is issued for instance only after all prior instructions from this thread have issued and also forces all future instructions from this thread to be dependent on it.

The condition code settings include for instance CC0 comparison equal R unit register replaced by GR R CC1 comparison unequal R unit register is unchanged.

Another instruction used is the Load and OR R Unit Register LORU instruction which is described with reference to . In particular depicts one embodiment of a format of the Load and OR R Unit Register instruction and depicts one embodiment of the logic associated with the Load and OR R Unit Register instruction.

With reference to a LORU instruction includes at least one opcode field including an operation code specifying a load and OR register operation a first register field R a second register field R and an instruction field I each of which is described below.

In operation and with reference to the contents of the R Unit register referred to herein as MCR specified by the 10 bit absolute register number indicated in selected bits e.g. bits 22 31 of the I text e.g. bits 6 15 of the I field are loaded into the general register specified in R STEP . Further the contents of the general register specified in R are logically ORed with the contents of MCR STEP and the result is written into MCR STEP .

The read OR replace function of LORU is an atomic operation as observed by this thread T and the other threads of this processor e.g. T . In one embodiment LORU is executed with the SLOW option on in order to avoid cross thread hangs. The SLOW option is indicated by setting a selected bit e.g. bit of I to one. Further interlocking is performed with this instruction as described below and therefore a selected bit e.g. bit of I referred to herein as ILOCK is set to one.

In one embodiment this instruction is rejected and reissued if another selected instruction such as RSR Read Special Register WSR Write Special Register NSR AND Special Register OSR OR Special Register XSR Exclusive OR Special Register TRBIT Test Register Bit RASR Read Absolute Special Register WASR Write Absolute Special Register TARBIT Test Absolute Register Bit NASR AND Absolute Special Register OASR OR Absolute Special Register XASR Exclusive OR Absolute Special Register LORU Load and OR R Unit Register LNRU Load and AND R Unit Register or CSGRU Compare and Swap R Unit Register is in the pipeline for this thread T or any other thread and the ILOCK bit I bit is on for the other instruction. This instruction is issued for instance only after all prior instructions from this thread have issued and also forces all future instructions from this thread to be dependent on it.

Another instruction used is the Load and AND R Unit Register LNRU instruction which is described with reference to . In particular depicts one embodiment of a format of the Load and AND R Unit Register instruction and depicts one embodiment of the logic associated with the Load and AND R Unit Register instruction.

With reference to a LNRU instruction includes at least one opcode field including an operation code specifying a load and AND register operation a first register field R a second register field R and an instruction field I each of which is described below.

In operation and with reference to the contents of the R Unit register referred to herein as MCR specified by its 10 bit absolute register number indicated in selected bits e.g. bits 22 31 of the I text e.g. bits 6 15 of the I field are loaded into the general register specified in R STEP . Further the contents of the general register specified in R are logically ANDed with the contents of MCR STEP and the result is written into MCR STEP .

The read AND replace function of LNRU is an atomic operation as observed by this thread T and the other threads of this processor e.g. T . In one embodiment LNRU is executed with the SLOW option on in order to avoid cross thread hangs. The SLOW option is indicated by setting a selected bit e.g. bit of I to one. Further interlocking is performed with this instruction as described below and therefore a selected bit e.g. bit of I referred to herein as ILOCK is set to one.

In one embodiment this instruction is rejected and reissued if another selected instruction such as RSR Read Special Register WSR Write Special Register NSR AND Special Register OSR OR Special Register XSR Exclusive OR Special Register TRBIT Test Register Bit RASR Read Absolute Special Register WASR Write Absolute Special Register TARBIT Test Absolute Register Bit NASR AND Absolute Special Register OASR OR Absolute Special Register XASR Exclusive OR Absolute Special Register LORU Load and OR R Unit Register LNRU Load and AND R Unit Register or CSGRU Compare and Swap R Unit Register is in the pipeline for this thread T or any other thread and the ILOCK bit e.g. I bit is on for the other instruction. This instruction is issued for instance only after all prior instructions from this thread have issued and also forces all future instructions from this thread to be dependent on it.

LNRU as well as LORU and CSGRU use registers that are accessible to all threads in the SMT core rather than storage as a means of shared communication. These registers are for instance hardware registers separate from memory or storage of the processor. For example in one core design there are approximately 64 registers that are shared common to all threads on the core threads can freely read and write these shared registers. In some cases of control registers if both threads would attempt to write them without special interlocks an update by one of the threads could be lost. In other cases only one of the threads is permitted to own a resource controlled by bits in the register. Therefore these atomic instructions that operate on shared registers are used to control and order access to these shared registers.

LNRU LORU and CSGRU each allows an atomic operation between general registers and MCR across threads by using interlocking to control inter thread operations and execution. As indicated each of the instructions has an ILOCK bit and when that bit is on for an instruction executing in the pipeline if a second instruction enters the pipeline with its ILOCK bit also set the second instruction is rejected and re executed later when the first instruction completes . This guarantees atomicity with accesses to these registers between threads.

There are for instance two types of interlocking instructions a single micro operation op instruction such as LNRU and LORU and a two op instruction such as CSGRU. With a single op instruction the interlock is set at the op issue RSR and WSR type instruction and cleared at the op completion for an RSR type and on checkpoint for a WSR type. In a two op instruction the interlock is set at the first op RSR type issue and is cleared at checkpoint of the second op WSR type .

Further details regarding using interlocking and interlocking are described with reference to . This logic is performed by the core and in particular by a pipe on which the instruction is issued.

Referring initially to an instruction to be executed e.g. LNRU LORU CSGRU is obtained by a multi threaded processor STEP . Execution of the instruction is initiated by the multi threaded processor to perform an operation STEP . The operation includes multiple sub operations to be performed atomically. A determination is made as to whether the instruction is to continue to execute INQUIRY . The determining uses for instance interlocking to determine whether the instruction has atomic access to one or more registers shared by the thread and one or more other threads.

If the instruction is to continue to execute execution continues which includes performing the operation using at least one shared register STEP . Otherwise if the instruction is not to continue it is rejected STEP .

Further details relating to the interlocking are described with reference to . Initially when an instruction enters the R unit in one example a check is made as to whether a lock indicator such as the ILOCK bit e.g. bit of I text a.k.a. bit of I of the incoming instruction is set e.g. set to 1 INQUIRY . If the ILOCK bit is not set then interlocking processing is complete however if the ILOCK bit in the incoming instruction is set then a further determination is made as to whether a lock referred to as an interlock is set INQUIRY . The interlock is placed in a hardware register accessible to multiple threads.

If the interlock is set e.g. a bit is set to one indicating that another instruction is processing that has its ILOCK bit set then the incoming instruction is rejected STEP .

However if the interlock is not set then it is set STEP and processing of the instruction proceeds e.g. in the pipe STEP . When the instruction completes or is checkpointed the interlock is reset e.g. set to zero STEP .

In one example the interlock is a vector having a bit for each possible instruction in a dispatch group. For instance in one example there may be up to three instructions in a dispatch group and therefore the interlock includes three bits one for each instruction. When a bit is set e.g. to 1 this indicates that the instruction associated with that bit has the interlock.

The interlock can also be set by pipe as described above however pipe is replaced with pipe and pipe with pipe.

In one embodiment reset of an interlock is performed on group completion if there is no write type micro operation op in the group that grabbed the lock. If there is a write type op in the group but it did not grab the lock then the lock is released also on that completion did not grab the lock ILOCK bit is 0 this is why the ILOCK bit for CSGRU is also set in the WSR part so it is not released on the completion of the RSR . If the write type instruction also grabbed the lock then the lock will be released only on checkpoint. In that way atomicity will be seen. An exception is for CSGRU where the WSR is in the second group hence the RSR of the first group sets the lock and the WSR in the second group releases the lock. In that case the first group is to come before the second group which has a GTAG that is greater by 1 from the GTAG of the first group .

A reject of a op in the group might not reset the lock if that op does not hold it. The reject will release the lock only in one example if there are no other ops in the group which also holds the lock.

A rescind of a op in the group might not reset the lock if that op does not hold it. The rescind will release the lock only in one example if there are no other ops in the group which also holds the lock.

When xcond is coming a check is made as to whether the interlock can be released. The problem is that the xcond should release the lock only if the instruction that grabbed it was not completed yet. If the instruction that grabbed the lock is already completed then the xcond should have no affect on the lock this is true for the write type instruction which grabbed the lock since that instruction will release it on checkpoint. For a read type instruction the release was already done on completion . One exception is CSGRU which its read type part can already be completed but if there would be an xcond before the write type completes the lock is to be released if the write type completes then xcond which will come later should have no effect on the interlock .

A reset in case the instruction which set the lock needs to be flushed the actual reset will be done only e.g. if the lock is not held any more by any instructions of that group. For example if the flush hits the first op in the group and this op holds the lock then the lock is free of course the two other ops can hold it too but they are flushed . If the flush is coming on the second op in the group and this op holds the lock then the lock is free only e.g. if the first op does not hold it too the third will be flushed anyway so no need to check it .

For a CSGRU opcode this eliminates the reject of the WSR op when the interlock was locked by the RSR op they have the same GTAG and same thread ID .

It is also true for groups like RSR x WSR where the issue is in order but the RSR for some reason gets rejected and hence the WSR locks the lock. In such case if the reject will be on an individual instruction id basis the RSR would not be able to enter since the lock is locked and the whole group would not be able to complete a deadlock since the WSR cannot release the lock. The solution is to use the GTAG so the RSR will be able to enter and when it completes the WSR would be able to complete too and would release the lock.

In case the interlock is turned on the older should be rejected too by the 1 condition unless this is the WSR of the CSGRU instruction .

In case the interlock is turned on both should be rejected by the 1 condition unless one of them is the WSR of the CSGRU instruction .

Described herein is one embodiment of a technique for one thread to stop execution of one or more other threads of a multi threaded processor. The technique is implemented to avoid hangs and to ensure all instructions associated with the other threads are completed before they are stopped. This technique includes in one aspect a pipeline DRAIN instruction that looks at status information from all hardware threads of the processor or selected threads in another embodiment to see if the conditions are satisfied before continuing operation at this thread.

Further one embodiment of this technique uses atomic instructions such as CSGRU LORU and LNRU to operate on shared registers. For instance when two or more threads share a common core in a multi threaded core design e.g. SMT they often need to communicate and share information this could include semaphores locks etc. This could involve firmware millicode or it could involve software. The threads could use existing ISA instructions that communicate through storage. However these may be slow and involve store hit load or load hit store conflicts commonly known as Operand Store Compare OSC . In addition if the communication is done by firmware it may be undesirable or impossible to communicate via storage a firmware routine could be in the middle of a critical sequence where operand loads and stores are prohibited. Thus these instructions operate on registers instead of storage.

Although the atomic instructions are described in relation to controlling execution of threads they may be used for other purposes. Each instruction stands apart from the use described herein and may be utilized in other situations.

Referring to in one example a computer program product includes for instance one or more non transitory computer readable storage media to store computer readable program code means logic and or instructions thereon to provide and facilitate one or more embodiments.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

Although various embodiments are described above these are only examples. For example computing environments of other architectures can be used to incorporate and use one or more embodiments. Further one or more aspects of the invention are applicable to forms of multi threading other than SMT. Yet further different instructions instruction formats instruction fields and or instruction values may be used. Many variations are possible.

Further other types of computing environments can benefit and be used. As an example a data processing system suitable for storing and or executing program code is usable that includes at least two processors coupled directly or indirectly to memory elements through a system bus. The memory elements include for instance local memory employed during actual execution of the program code bulk storage and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input Output or I O devices including but not limited to keyboards displays pointing devices DASD tape CDs DVDs thumb drives and other memory media etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the available types of network adapters.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below if any are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of one or more embodiments has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain various aspects and the practical application and to enable others of ordinary skill in the art to understand various embodiments with various modifications as are suited to the particular use contemplated.

