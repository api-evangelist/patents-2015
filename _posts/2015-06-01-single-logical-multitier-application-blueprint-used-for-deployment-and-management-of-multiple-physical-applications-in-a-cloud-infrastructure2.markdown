---

title: Single, logical, multi-tier application blueprint used for deployment and management of multiple physical applications in a cloud infrastructure
abstract: A deployment system enables a developer to define a logical, multi-tier application blueprint that can be used to create and manage (e.g., redeploy, upgrade, backup, patch) multiple applications in a cloud infrastructure. In the application blueprint, the developer models an overall application architecture, or topology, that includes individual and clustered nodes (e.g., VMs), logical templates, cloud providers, deployment environments, software services, application-specific code, properties, and dependencies between top-tier and second-tier components. The application can be deployed according to the application blueprint, which means any needed VMs are provisioned from the cloud infrastructure, and application components and software services are installed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09645858&OS=09645858&RS=09645858
owner: VMware, Inc.
number: 09645858
owner_city: Palo Alto
owner_country: US
publication_date: 20150601
---
This application is a continuation of U.S. application Ser. No. 13 411 364 filed Mar. 2 2012 the entirety of which is hereby incorporated by reference herein. This application is also related to the patent application entitled System and Method for Customizing a Deployment Plan for a Multi Tier Application in a Cloud Infrastructure the patent application entitled Execution of a Distributed Deployment Plan for a Multi Tier Application in a Cloud Infrastructure and the patent application entitled System to Generate a Deployment Plan for a Cloud Infrastructure According to Logical Multi Tier Application Blueprint which are assigned to the assignee of this application and were filed on the same day as this above referenced parent application.

 Infrastructure as a Service also commonly referred to as IaaS generally describes a suite of technologies provided by a service provider as an integrated solution to allow for elastic creation of a fully virtualized network and pooled computing platform sometimes referred to as cloud computing platform . Enterprises may use IaaS as a business internal organizational cloud computing platform sometimes referred to as a private cloud that gives an application developer access to infrastructure resources such as virtualized servers storage and networking resources. By providing ready access to the hardware resources required to run an application the cloud computing platform enables developers to build deploy and manage the lifecycle of a web application or any other type of networked application at a greater scale and at a faster pace than ever before.

However deployment tools currently in use are usually a homegrown patchwork of various software products from different vendors. Such tools are generally process driven with heavy reliance on custom scripts and property files. Additionally these tools often utilize too much network bandwidth through continuous polling for readiness of execution or rely on a centralized mechanism that causes a central point of resource contention. Traditional deployment tools are also not configured for automation with cloud computing platforms that dynamically provision virtual computing resources.

Further applications are typically developed with a multi tier architecture in which functions such as presentation application processing and data management are logically separate components. For example an enterprise s custom banking application that has a multi tier architecture may use a cluster of application servers e.g. JBoss Application Servers to execute in a scalable runtime environment a relational database management system e.g. MySQL to store account data and a load balancer to distribute network traffic for robustness. To deploy such a multi tier application a developer who understands the architecture of the application must coordinate with a system administrator who controls access to computing resources to determine which computing resources e.g. computing networking and storage and software services e.g. software packages should be provisioned to support execution of the application. However developers and system administrators typically view an application differently. Developers see an application as a group of components with interdependencies while system administrators view an application as a series of runbook steps to be followed for deployment. As such there are challenges for developers and system administrators to collaborate on determining deployment requirements for an application.

One or more embodiments of the present invention provide a deployment system for deploying a multi tier application to a cloud computing environment. This deployment system enables a developer or application architect to create application blueprints. The application blueprints define the structure of the application enable the use of standardized application infrastructure components and specify installation dependencies and default configurations. The application blueprints define the topology for deployment in an infrastructure agnostic manner to be portable across different cloud computing environments.

According to embodiments a deployment plan for an application is generated using one such application blueprint described above. The deployment plan is separated and distributed as local deployment plans having a series of tasks to be executed by virtual machines provisioned from a cloud computing environment. Each virtual machine coordinates execution of each task with a centralized deployment module to ensure that tasks are executed in an order that complies with dependencies specified in the application blueprint.

A method of deploying an application having multiple application components according to an embodiment includes generating a topology of virtual computing resources and application components executing thereon for supporting execution of the application. The method further includes defining one or more dependencies between the application components and deploying the application in a cloud environment by provisioning cloud computing resources and installing the application components in the cloud computing resources according to the topology.

A non transitory computer readable storage medium includes instructions that when executed in a computing device deploy an application having multiple application components by performing the steps of in an embodiment generating a topology of virtual computing resources and application components executing thereon for supporting execution of the application and defining one or more dependencies between the application components in the topology. The non transitory computer readable storage medium further includes instructions for deploying the application in a cloud environment by provisioning cloud computing resources and installing the application components in the cloud computing resources according to the topology.

A computer system for deploying an application having multiple application components includes a system memory and a processor programmed to carry out the steps of in an embodiment generating a topology of virtual computing resources and application components executing thereon for supporting execution of the application and defining one or more dependencies between the application components in the topology. The system memory and processor are further programmed to carry out the step of deploying the application in a cloud environment by provisioning cloud computing resources and installing the application components in the cloud computing resources according to the topology.

A developer of enterprise uses an application director which may be running in one or more VMs to orchestrate deployment of a multi tier application onto one of deployment environments provided by a cloud computing platform provider . As illustrated application director includes the following software modules a topology generator a deployment plan generator and a deployment director . Topology generator generates a blueprint that specifies a logical topology of the application to be deployed. Blueprint generally captures the structure of an application as a collection of application components executing on virtual computing resources. For example blueprint generated by application director for an online store application may specify a web application e.g. in the form of a Java web application archive or WAR file comprising dynamic web pages static web pages Java servlets Java classes and other property configuration and resources files that make up a Java web application executing on an application server e.g. Apache Tomcat application server and that uses as a database e.g. MongoDB as a data store. It is noted that the term application is used herein to generally refer to a logical deployment unit comprised of application packages and their dependent middleware and operating systems. As such in the example described above the term application refers to the entire online store application including application server and database components rather than just the web application itself.

Blueprint may be assembled out of items from a catalog which is a listing of available virtual computing resources e.g. VMs networking storage that may be provisioned from cloud computing platform provider and available application components e.g. software services scripts code components application specific packages that may be installed on the provisioned virtual computing resources. Catalog may be pre populated and customized by an administrator e.g. IT or system administrator that enters in specifications configurations properties and other details about each item in catalog . Blueprint may define one or more dependencies between application components to indicate an installation order of the application components during deployment. For example since a load balancer usually cannot be configured until a web application is up and running developer may specify a dependency from an Apache service to an application code package.

Deployment plan generator of application director generates a deployment plan based on blueprint that includes deployment settings for blueprint e.g. virtual computing resources cluster size CPU memory networks and an execution plan of tasks having a specified order in which virtual computing resources are provisioned and application components are installed configured and started. Deployment plan provides an IT administrator with a process oriented view of blueprint that indicates discrete steps to be performed to deploy application . Different deployment plans may be generated from a single blueprint to test prototypes e.g. new application versions to scale up and scale down deployments or deploy application to different deployment environments e.g. testing staging production .

Deployment director of application director executes deployment plan by communicating with cloud computing platform provider via a cloud interface to provision and configure VMs in a deployment environment as specified by deployment plan . Cloud interface provides a communication abstraction layer by which application director may communicate with a heterogeneous mixture of cloud provider and deployment environments . Deployment director provides each VM with a series of tasks specific to the receiving VM herein referred to as a local deployment plan . The tasks may be scripts that are executed by VMs to install configure and or start one or more application components. For example a task may be a script that when executed by a VM causes VM to retrieve and install particular software packages from a central package repository . Deployment director coordinates with VMs to execute the tasks in an order that observes installation dependencies between VMs according to deployment plan . After application has been deployed application director may be utilized to monitor and modify e.g. scale the deployment.

In step in response to user inputs e.g. from developer application director generates a blueprint for an application to be deployed that includes a logical topology of virtual computing resources and application components for supporting the application. In one implementation developer may utilize a graphical user interface provided by application director to assemble and arrange items from catalog into a topology that represents virtual computing resources and application components for supporting execution of application .

In step application director generates a deployment plan based on blueprint to deploy application in a specific cloud environment e.g. deployment environments . Step may be carried out in response to user inputs e.g. from developer that initiate a deployment process for application on a specified deployment environment. In step responsive to user inputs e.g. from developer application director may optionally modify deployment plan to insert one or more custom tasks to be executed between tasks of deployment plan . In step in response to user inputs e.g. from developer application director executes deployment plan by providing deployment agents executing within deployment environment e.g. on VMs with local deployment plans based on deployment plan . Application director separates deployment plan into local deployment plans that include a series of tasks to be executed by a VM .

The operations of step are described in further detail in . is a flow diagram that illustrates steps for configuring application director to generate an application blueprint e.g. blueprint for an application e.g. application . In step an administrator or other trusted party having administrative access to IT infrastructure logs in and provides application director with details and credentials for cloud provider . For example administrator may provide information such as an IP address or hostname at which cloud provider is accessible and credentials e.g. a username and password for an account authorized to make provisioning requests for computing resources. In step application director receives the credentials and attempts to validate a connection to cloud provider using the received credential. In step cloud provider authenticates application director s access to computing resources using the provided credentials.

In step responsive to a successful authentication cloud provider provides application director with a listing of available virtual machine templates and deployment environments . Virtual machine templates are metadata that describes the configuration of a virtual machine including CPU memory network storage guest operating system and other supporting libraries pre installed and used to repeatedly create a VM having the specified settings. Virtual machine templates that are made available by cloud provider are referred to herein as cloud templates. In step application director registers cloud provider and stores information about associated cloud templates and deployment environments .

In step administrator specifies one or more logical templates that may be mapped to actual virtual machine templates e.g. cloud templates provided by cloud providers . Logical templates enable application director to define an application topology in a cloud agnostic manner. As with cloud templates a logical template may specify virtual computing resources for a virtual machine such as CPU memory networking storage guest operating system pre installed installed runtime environments e.g. Java Runtime Environment and application services and commands e.g. ssh wget . For example one logical template may specify a virtual machine having a guest operating system CentOS version 5.6 supporting 32 bit architecture while another logical template may specify a virtual machine having Red Hat Enterprise Linux 6.1 supporting 64 bit architecture. In one embodiment administrator specifies a name description and descriptive metadata for each logical template. Descriptive metadata for example such as non hierarchical keywords or tags are used to organize listings of logical templates and enhance readability of logical templates during blueprint creation. For example administrator may tag a logical template as a Database Servers tag and or an OS Templates tag. Because some application components may not run on all operating systems administrator may use descriptive metadata to label operating systems installed and supported by the logical templates. Such operating system tags provide system compatibility metadata that may be used to later limit which application components can be added to a logical template. For example if an administrator specifies a logical template having Ubuntu OS installed application director may prevent a developer from later attempting to add a software service that does not run on Ubuntu onto this logical template.

As part of the logical template definition administrator may specify one or more software services that are preinstalled on the logical template along with the guest operating system. For example in some cases a performance monitoring agent or virus scanner is preinstalled on a logical template. In another example an application server e.g. Apache Tomcat application server may be preinstalled on a logical template to speed up deployment of web applications.

In step application director inserts the specified logical templates into catalog of blueprint items. As a result of their inclusion in catalog logical templates are available to users e.g. developer when creating blueprints that define application topologies having one or more virtual machines where each virtual machine is represented by each instance of a logical template. For example the inserted logical template may now appear in a listing of logical templates shown during creation of application blueprints.

In step administrator associates each logical template with one or more cloud templates that have been published by cloud provider as available for provision. In step application director generates a mapping between the selected logical templates and one or more cloud templates. Administrator may map multiple cloud templates to one logical template to allow for selection of different cloud templates from different cloud providers at deployment time. Even when using the same cloud provider mapping multiple cloud templates to one logical template enables selection from different cloud templates at deployment time to allow for different template configurations. For example with multiple cloud templates mapped to the same logical template a user deploying to a production environment may select a cloud template specifying a large amount of disk space whereas a deployment to a test or staging environment may call for selection of a cloud template with a small amount of disk space.

In step administrator specifies one or more application components such as services and code components which may be installed on a virtual machine for supporting execution of an application. Code components are application specific binaries scripts or processes for example written by developer and packaged into one or more files to provide logic for the application. In catalog code components are represented as types or formats of scripting and application code. Examples of types of code components include Java Archive JAR files Java Enterprise Archive EAR files Java web application archive WAR files Ruby Gems packages SQL scripts and other suitable modules of scripting logic.

Services are scripted software that provide a software infrastructure for an application and are generally reused in multiple applications. Examples of services include application servers e.g. Rails Apache Tomcat JBoss database servers e.g. GemFire MySQL SQLFire MongoDB Postgres monitoring services e.g. Hyperic SpringInsight web servers e.g. Apache VMware vFabric Enterprise Ready Server messaging services e.g. RabbitMQ and other middleware services.

Administrator may specify a name version e.g. major minor and micro releases and a textual description for a service. As with logical templates a definition of a service may include descriptive metadata such as tags and information about supported operating systems and components. Tags for a service e.g. database web servers are used to organize listing of services during blueprint creation. Information about supported operating systems specifies if a service can only run on a particular operating system. For example during blueprint creation application director prevents a service from being added to a logical template unless the logical template contains one of the supported operating systems. For information about supported components administrator selects what code components can be added to a service during creation of an application blueprint. As such information about supported components indicates if only a certain type of code component may run on this service. For example only WAR and JAR components may run in a Java application server or Apache tomcat server instance only SQL scripts can run in a database server. Administrator may further specify whether a service is or may be pre installed on a logical template. Services specified as pre installed on a template are available for inclusion in a logical template definition as described above.

Administrator may specify one or more properties of an application component e.g. services code components . Properties for application components are configuration name value pairs that are exposed for configuration and manipulation by application director . In one embodiment properties of an application component define variables used in installation configuration and execution scripts for an application component. For each property administrator may specify a name e.g. port num repos url type e.g. string array content and a value that represents a variable value to be substituted for this property when a script referencing the property is executed. The value of a property may be a literal or static value e.g. an http port property having a value of 80 or may reference other properties within the blueprint or referenced components in the blueprint. Properties may also be mapped to dynamic values such as a database s IP address which can be then be used by an application to connect to it. For example a pkg path property may have a value of http director.server.ip services hyperic installer 4.5 x86 64 linux.tar.gz which includes a reference e.g. director.server.ip to an IP address for a server executing application director . As such during deployment the value of the pkg path property is dynamically generated to be the IP address of application director at time of deployment. Property values may be specified as secured for passwords and other properties that administrator may wish to obscure from users without administrative privileges e.g. developer .

Administrator may further specify whether a property of an application component is overridable in a blueprint such that other users may redefine this property for a particular application blueprint i.e. at blueprint creation time or for a particular deployment i.e. at deployment time . For example administrator might configure a Java application server e.g. Apache tomcat server service to have a default Java Virtual Machine JVM heap size of 512 MB. However a user e.g. developer might change this property to 1024 MB to suit for a particularly memory intensive application or suit a particularly large deployment in a production environment.

Administrator may create installation configuration and start scripts for an application component referred herein as actions. Actions generally include a script comprised of one or more lines of scripting logic that when executed by a virtual machine on which the application component is hosted perform operations for an application lifecycle stage e.g. install configure start stop upgrade migrate etc. . Operations performed by an action may include requesting installation via a package manager e.g. yum apt dpkg setting environmental variables launching runtimes checking configurations and other commands. For example an action for a database service may include an installation script that fetches an application package from a package repository unpacks the application package and executes an installer using particular installation settings and variables. Action scripts may be executable by a command line shell such as a UNIX shell e.g. bash or Windows PowerShell though other suitable scripting environments are within the scope of the present disclosure.

Administrator specifies a name of the lifecycle stage e.g. install configure and start for the action and the content of the action script. In one embodiment application director provides a script editor having a user interface that lists the properties of the application component which are available for configuration setting and or manipulation by the script. Action scripts may reference properties of an application component e.g. global conf http port to install configure or start an application component with settings from catalog defined by administrator . An example script for an INSTALL action of an application component e.g. Apache web server is shown below in Table 1.

Referring again to in step application director inserts the specified application components into catalog of blueprint items. Accordingly a catalog is generated by administrator that provides standardized virtual machine templates and application infrastructure components having predetermined installation and configuration scripts such that a user e.g. developer may quickly create a blueprint of a multi tier application and avoid having to define each application component from scratch. While administrator may specify any number of logical templates and application components for use by users it should be recognized that catalog may already include a library of standardized and commonly used application components. It should further be recognized that administrator may edit and customize any predefined application component in the library of standardized and commonly used application components.

Operations of continue to step shown in . is a flow diagram that illustrates steps for generating an application blueprint for an application utilizing catalog as generated in . As described above a blueprint is an abstract representation of the structure of application as comprised of virtual machines and their corresponding application components operating systems dependencies and configurations. Blueprint standardizes the structure of an application for repeated deployments in multiple and possibly diverse deployment environments.

In step a user e.g. developer or administrator selects one or more logical templates from catalog of items. In step responsive to user input application director generates blueprint comprised of the logical templates selected by the user. In one embodiment upon receiving a selection of logical templates application director generates a set of nodes which each represent a virtual machine or a cluster of virtual machines configured according to the selected logical templates. For example to create a blueprint that models a three tiered application a user may select three items from a catalog list of logical templates to create three nodes representing each tier of the application. Application components may be later added to each node to specify which application components are executing on the node. In one implementation a graphical user interface is provided for modeling a blueprint for the application an example of which is depicted in .

User interface includes one or more palettes that display items from catalog that are available for use in creating a blueprint. As shown user interface includes a first palette that lists all logical templates defined in and available from catalog a second palette that lists software services defined in and available from catalog and a third palette that lists types of code components that may be inserted into a blueprint. Canvas provides drag and drop functionality that enables the user to select and drag an item from palettes and drop the selected item within the boundaries of canvas to insert the selected item into blueprint as illustrated by arrow . In the example shown each node has been created from a logical template identified as CentOS32 5.6 having CentOS 5.6 32 bit operating system installed.

Referring back to in step the user selects one or more application components from catalog of application components and selects a node on which the application component may execute. In step responsive to user input application director inserts the selected application components into blueprint as executing a selected node. In the example three tiered application in a user selects a MySQL database item a JBoss application server and an Apache web server from palette of services and insert selected item onto a separate node . Each node may host multiple application components. Some application components such as services may host execute and or deploy certain application components themselves such as code components. In the three tiered application example above the user specifies an application component packaged as an EAR file identified as bank app as being deployed in the JBoss application server. In another example the user may specify an SQL script identified as init db script that is executed by MySQL database to initialize the database.

In step the user customizes one or more nodes and application components of blueprint by editing details e.g. labels descriptions properties and actions of the nodes and applications components. The customizations made by the user to the nodes and application components represent application specific configurations that override or replace default configurations provided by catalog .

To allow for scaling deployments the user may specify a node as a cluster of virtual machines rather than a single virtual machine to enable multiple virtual machines to be deployed for that particular node. In the three tiered application example above the app server node has been specified as a cluster and hence multiple virtual machines of this type can be deployed and managed by the Apache load balancer. As shown the clustered node is graphically represented as a stack of nodes to distinguish from a singular node. The user specifies a number of virtual machines in the cluster e.g. 10 VMs . Further nodes specified as clusters are given special properties that enable action scripts for an application component running on the cluster to be cluster aware. For example a special property node array index may be used by an action script to identify which virtual machine the action script is executing on.

In some deployments some servers are deployed into an external facing network or DMZ and some servers are deployed to a separate network protected by a firewall. To model this structure the user may customize a node by defining multiple network interfaces sometimes referred to as NICs to separate data communication with the node into separated sub networks. For a given node the user may specify more than one NIC each NIC having a logical network name e.g. MgmtNetwork ServiceNetwork . At deployment time the named logical network is mapped to an actual cloud network provided by cloud provider . In the example three tiered application example above the load balancer node is planned to be the only node that may be accessed from a public network e.g. Internet the database and app server nodes are deployed in a private network. The load balancer node should be able to access the database and app server nodes. As such the load balancer node is specified with two NICs a first NIC pointing to a service network and a second NIC pointing to a management network. The database and app server nodes each have one NIC pointing to the service network. At deployment time the service network can be mapped to a cloud network protected by firewall and the management network can be mapped to a public cloud network.

The user may provide a new application specific property value that overrides or replaces a default property value defined in catalog . For example the user may edit the value of an http port property to configure a customized port number for a given blueprint. The user may only modify properties that have been designated as overridable by a definition for the application component in catalog . However the user may designate at the blueprint level whether an application specific property for an application component and or node is overridable at deployment to allow that property to be further customizable at deployment time.

Similarly the user may modify an action for an application component by customizing a default script e.g. install configure start corresponding to the action as defined in catalog . In step responsive to user input application director modifies details properties and actions for nodes and application components of blueprint .

The user may specify one or more dependencies between application components to declare a relationship between the application components that defines an interconnected structure of distributed portions of the application e.g. multiple tiers of the application . Dependencies may be used to plan deployment of the application by defining a deployment order for application components e.g. that indicates whether deployment tasks for one item will wait to run until the tasks for the other item has finished . In the three tiered application example because a load balancer usually cannot be configured until the web application is up and running the user has created a dependency from a load balancer e.g. Apache to a web application package e.g. EAR component to indicate that the load balancer should be deployed after the deployment of the web application is completed.

As such in step the user may select at least two application components and or nodes for example by using a pointer cursor in user interface to select one or more nodes and or application components within canvas and creating a dependency between the application components via a link button . It is appreciated that the user may later use a pointer cursor to select an existing dependency and delete and or modify the selected dependency for example by pressing a delete button . In step responsive to user input application director inserts a dependency between the selected application components and or nodes into blueprint . In the three tiered application example shown in a dependency from the Apache load balancer to code component e.g. bank app is depicted by dashed arrow and represents that the Apache load balancer should be deployed after the installation of the code component e.g. bank app is completed. Similarly a second dependency depicted by dashed arrows from the code component e.g. bank app to the database initialization script e.g. init db script is created to represent that the code component e.g. bank app should wait until the database node the database service and the SQL script initializing the database have all been run before continuing.

In step application director checks the application topology defined by blueprint for errors. For example application director may verify whether properties have been correctly specified that application components are not missing from any required actions or that invalid or circular dependencies have not been created. In step responsive to not detecting any errors within blueprint application director transmits a successful blueprint generation message to the user and in turn in step the user receives a status indication regarding generation of blueprint . Alternatively in step responsive to detecting an error within blueprint application director transmits an error message to the user. Application director may provide the user with opportunities to perform one or more remedial actions to correct any detected errors.

From an application blueprint a user may generate multiple deployment plans having configurations customized for a variety of deployment environments and or cloud providers for example for testing prototypes deploying to staging environments or upgrading existing deployments. While blueprints provide a component oriented view of the application topology deployment plans provide a step oriented view of the application topology defined in blueprint that depicts time dependencies between tasks to deploy the application components in a particular order. Deployment plans provide settings such as cloud templates networks and application component properties allowed for use in specific deployment environments.

In step a user e.g. developer or administrator selects a deployment environment in which to deploy the application. The deployment environment may be selected from a listing of deployment environments available from by cloud providers for example as registered in step above. In step application director determines which logical templates are used in the blueprint e.g. to create nodes and retrieves cloud templates mapped to the logical templates for example as mapped in step above for the selected deployment environment.

Additionally the user selects a cloud network available from cloud provider for each logical network defined in the blueprint. For example when deploying a load balancer node to a test environment the user may select an internal network for both sub networks e.g. NICs . When deploying a load balancer node to a production environment the user may select an internal network for one load balancer NIC and an external network for the other load balancer NIC. Cloud provider provides a listing of available network types that may be mapped to logical networks of the blueprint for example including dynamically allocated networks e.g. DHCP statically allocated networks e.g. static IP pool direct connected e.g. external networks routed networks and isolated e.g. private internal networks.

In step the user customizes blueprint by specifying deployment specific configurations of the nodes and application components. The user may provide a new property value for a node or application component that overrides or replaces a default value specified by a definition for the property in catalog or an application specific value specified by blueprint . For example a blueprint having an Apache Tomcat application component might specify a JVM heap size of 512 MB. However a user may want to override that application specific setting to change the heap size to 1024 MB to suit a particularly large deployment in a production environment. In another example a user may override node properties such as memory allocation or number of CPUs which have been defined by catalog to make a more robust deployment. Similar to application specific customizations the user may only customize node or application component properties that have been designated as overridable at deployment within the blueprint. The customized deployment specific property values are utilized during execution and or determination of deployment tasks described below.

In step application director determines a plurality of tasks to be executed to deploy each node of blueprint and each application component executing thereon. For each node in blueprint application director determines a task that includes a provisioning request to cloud provider to create a corresponding virtual machines or cluster of virtual machines according to the mapped cloud template and property values e.g. number of CPUs memory allocation specified by catalog blueprint and or deployment plan in ascending order of priority. In the three tiered application example above application director determines a task to provision two virtual machines having CentOS 32 bit 5.6 installed e.g. for database and load balancer nodes and a cluster of virtual machines having CentOS 32 bit 5.6 installed e.g. for app server node .

For each application component in blueprint application director determines one or more tasks that include execution of action scripts corresponding to each application lifecycle stage defined for the application component. For example for a load balancer application component application director determines tasks corresponding to execution of an installation script e.g. INSTALL a configuration script e.g. CONFIGURE and a launch script e.g. START . In another example for an SQL script that initializes a database e.g. init db script application director determines a single task corresponding to execution of the script e.g. INSTALL .

In step application director determines one or more deployment time dependences between the tasks according to the application topology defined in blueprint . Dependencies between application components and or nodes defined in blueprint may be used to determine an order in which the application components should be deployed. A dependency defined as from a first application component to a second application component represents a requirement that tasks for the first application component cannot be performed until the tasks for the second application component have been completed.

Dependencies between application components and or nodes can explicitly defined in blueprint via insertion by the user in steps and of e.g. between the application component and load balancer in . A dependency between application components may be defined between application components in the same node e.g. intra node dependency to represent that at that node tasks for one application component are performed after tasks for the other application component. Alternatively dependencies between application components may be defined between application components in different nodes e.g. inter node dependencies such that tasks for an application component at a first node are performed after tasks of an application component at a second node have been completed. It is appreciated that this may result in a pause in operations at the first node until the tasks at the second node have been performed.

Additionally dependencies between application components and or nodes can be implicitly defined in blueprint via a nested or layered relationship between application components. Tasks for an application component that is a container for another application component are ordered within deployment plan to be performed before the tasks for the other application component. For example for a blueprint having a code component e.g. JAR web application executing on an application server e.g. JBoss a nested relationship between the code component and application server implicitly defines a dependency from the code component to the application server. As such tasks for the code component may not be performed until tasks for the application server have been completed. In the three tiered application example above the database initialization script e.g. init db script is implicitly dependent on the database e.g. MySQL database and may not be executed until tasks associated with the database have been performed.

In step application director generates a deployment plan for executing the tasks according to the dependencies determined in step and in turn in step the user may review the generated deployment plan . Deployment plan is generated as a step wise execution plan having tasks for deploying the application on a plurality of virtual machines provided by cloud provider . The step wise execution plan may be organized by virtual machine according to which virtual machine each task is to be performed on. In one particular implementation deployment plan may be graphically illustrated to the user in a workflow view for example as shown in .

Deployment time dependencies that represent an order of execution are depicted by solid directional lines and dashed directional lines . Accordingly deployment plan specifies that a task does not begin execution until a preceding task as indicated by directional lines has been completed. For example a virtual machine labeled as database executes action scripts for installing configuring and starting a MySQL database service scripts identified as MySQL INSTALL MySQL CONFIGURE MySQL START respectively . Because of the dependency implied by the container relationship between the MySQL database and SQL script the task for executing the init db script SQL script e.g. init db script INSTALL is placed after the last task for deploying the MySQL database e.g. MySQL START has been completed. Similarly the tasks for deploying the bank application e.g. Bank App INSTALL are placed after the last task for deploying the JBoss application server.

Deployment plans further specify that a task may wait for completion of a task in another virtual machine e.g. inter node dependency as indicated by a dashed directional line . In the three tiered application example deployment plan specifies that tasks for deploying the web application e.g. bank app INSTALL does not begin execution until the task for executing the database initialization script e.g. init db script INSTALL has been completed.

Additionally user interface depicts nodes that represent a cluster of virtual machines in aggregate as a single node or alternatively in an expanded view shown in renders each virtual machine in the cluster as separate sub nodes having an own set of tasks to be performed. In the three tiered application example the clustered application server node e.g. app server is depicted as having sub nodes e.g. identified as app server and app server . Each sub node includes an additional set of deployment time dependencies depicted with directional dashed lines from all tasks in a clustered node to tasks in another node to represent that a task in all sub nodes must be completed before the task in the other node may begin. For example in the three tiered application example deployment plan indicates that the bank app INSTALL tasks in app server and app server nodes must both be completed before INSTALL task for the load balancer may begin.

In an alternative embodiment shown in user interface depicts tasks for requesting provision of a virtual machine for each node specified in blueprint and as according to a cloud template mapped to logical templates specified in blueprint . For example deployment plan includes tasks e.g. load balancer PROVISION to provision virtual computing resources according to a cloud template e.g. CentOS32 5.6 . As shown in deployment plan specifies that provisioning tasks for virtual machines are performed before deployment tasks for application components e.g. MySQL JBoss Application server etc. .

Having generated a deployment plan deployment director of application director communicates with cloud provider to execute deployment plan within a deployment environment .

Cloud provider utilizes an infrastructure platform upon which a cloud computing environment may be executed. In the particular embodiment of infrastructure platform comprises hardware resources such as servers to and one or more storage array networks SAN such as SAN which are configured in a manner to provide a virtualization environment that supports the execution of a plurality of virtual machines across servers to . As further detailed below these virtual machines provide the virtual computing resources e.g. compute networking and storage resources that make up cloud computing environment .

Virtualization environment of includes an orchestration component e.g. implemented as a process running in a virtual machine in one embodiment that provides infrastructure resources to cloud computing environment responsive to provisioning requests. For example if deployment director required a specified number of virtual machines to deploy a web applications or to modify e.g. scale a currently running web application to support peak demands responsive to a request from deployment director orchestration component can initiate and manage the instantiation of virtual machines e.g. VMs to on servers to to support such requests. In one embodiment orchestration component instantiates virtual machines according to a requested cloud template that defines a virtual machine having specified virtual computing resources e.g. compute networking storage resources . Further orchestration component monitors the infrastructure resource consumption levels and requirements of cloud computing environment e.g. by monitoring communications routed through addressing and discovery layer as further detailed below and provides additional infrastructure resources to cloud computing environment as needed or desired. In one example virtualization environment may be implemented by running VMware ESX based hypervisor technologies on servers to provided by VMware Inc. of Palo Alto Calif. although it should be recognized that any other virtualization technologies including Xen and Microsoft Hyper V virtualization technologies may be utilized consistent with the teachings herein .

Cloud computing environment includes a cloud director e.g. run in one or more virtual machines that manages allocation of virtual computing resources to application director for deploying applications. Cloud director authenticates connection attempts from application director using received cloud provider credentials for example as described above. Cloud director maintains and publishes a catalog of available cloud templates that represent virtual machines that may be provisioned from cloud computing environment . Cloud director receives provisioning requests submitted to cloud provider and may propagates such requests to orchestration component to instantiate the requested virtual machines e.g. VMs to . In one embodiment cloud director receives provisioning requests for cloud templates that have been mapped to a logical template in application blueprints .

In the embodiment of cloud computing environment supports a deployment environment having a plurality of virtual machines identified as VMs to instantiated to host deployed web applications. For example the deployment by enterprise of a web application having application components results in the hosting of application components in VMs to of deployment environment at cloud computing platform provider . A VM e.g. VM may include a pre installed bootstrap script that upon first boot retrieves a deployment agent e.g. packaged as a JAR file from deployment director . Alternatively deployment agent may be pre installed on VM via inclusion in a cloud template defined by cloud director . Deployment agent running on each VM receives a local deployment plan from deployment server and executes local deployment plan in coordination with deployment director .

Addressing and discovery layer provides a common interface through which components of cloud computing environment e.g. cloud director and VMs to in deployment environment can communicate and receive notifications. For example deployment director of application director may communicate through addressing and discovery layer to broadcast local provisioning plans during deployment of web applications in cloud computing environment . Similarly VM may broadcast a notification through addressing and discovery layer to poll for permission to execute of a task from a local provisioning plan and to indicate successful execution of a task from a local provisioning plan. In one embodiment addressing and discovery layer is implemented as a message brokering service e.g. running in one or more virtual machines that defines a common protocol and message format through which components of cloud computing environment can exchange messages and broadcast notifications and other information. In such an embodiment the components of cloud computing environment establish a connection with the message brokering service e.g. also sometimes referred to as subscribing to the message brokering service for example through known authentication techniques e.g. passwords etc. and once connected to the message brokering service can provide receive and request messages notifications and other similar information to and from other components that have also subscribed to the message brokering system. One example of a message brokering service that may be used in an embodiment is RabbitMQ which is based upon the AMPQ Advanced Message Queuing Protocol open protocol standard. It should be recognized however that alternative interfaces and communication schemes may be implemented for addressing and discovery layer other than such a message brokering service.

Deployment director e.g. run in one or more virtual machines orchestrates execution of a deployment plan for an application in coordination with virtual machines e.g. VMs to participating in the deployment. Deployment director separates deployment plan into local deployment plans for each node that are executed by deployment agent on each node. Deployment director maintains a central state of the deployment process that understands the deployment time dependencies between tasks to be performed across nodes e.g. VMs to in a specific order. Deployment director broadcasts transmits notification to deployment agent on each node to indicate resolution of deployment time dependencies between tasks in local deployment plans . Additionally deployment director monitors the status of deployment agents and may perform a heartbeat procedure when a deployment agent becomes unresponsive.

Once deployment director of application director successfully orchestrates the deployment of web application in VMs to an end user can access the deployed application for example through a web browser or any other appropriate client application residing on a computer laptop or other computer terminal Router e.g. run in one or more virtual machines receives the web browser s access request e.g. a uniform resource locator or URL and routes the request to deployment environment which hosts the deployed application. More generally router maintains mappings in internal routing tables between URLs and deployed applications in order to properly route URL requests from customers to the appropriate deployment environments hosting the requested web applications as well as maintain load balancing among web application instances etc. . These mappings are received by router through address and discovery layer when a cloud director successfully provisions virtual computing resources for hosting an application and broadcasts routing information e.g. hostname network address information port number etc. for the provisioned VMs through addressing and discovery layer .

In step deployment director requests cloud director for provision of virtual computing resources based on deployment plan . The provisioning request allows for creation of virtual machines according to one or more cloud templates published as available by cloud provider . In step cloud director receives the request and creates one or more VMs e.g. VMs to according to a cloud template requested by deployment director .

VM proceeds to establish communication with deployment director for coordinating deployment in the cloud computing environment. In one embodiment in step VM boots and launches a bootstrap script that initializes VM to support communication with deployment director . The bootstrap script provides information for an initial communication with deployment director for example a resource location e.g. URL for retrieving deployment agent from deployment director . In step VM requests an application package containing deployment agent from deployment director . In an alternative embodiment deployment agent may be pre installed on VM via a customized cloud template.

In step responsive to the request from VM deployment director transmits the requested package that includes deployment agent e.g. a JAR file containing deployment agent in addition to deployment agent configurations to VM . The deployment agent configurations are specific to VM and specify how deployment agent executing on VM may communicate with deployment director through a messaging system such as addressing and discovery layer . In one example deployment agent configurations may include network address for addressing and discovery layer and a unique address e.g. queue name that uniquely identifies communications intended for deployment agent . Deployment agent configurations may include a one time password e.g. temporary key generated by deployment director and associated with the specific VM e.g. via unique address to enable a secure method by which deployment agent can initially authenticate itself to deployment director .

In step VM receives the deployment agent package and verifies the integrity and or authenticity of the deployment package for example using a fingerprint or checksum value e.g. MD5 hash value that is provided with deployment agent configurations in step . VM executes the deployment agent package to launch deployment agent utilizing received deployment agent configurations. Deployment agent proceeds to authenticate itself with deployment director to establish a secure method of communication for example by requesting a digital certificate that allows encrypted communications. In step deployment agent executing on VM transmits an initial authentication request to deployment director using the unique address e.g. queue name and one time password provided from the deployment agent configurations received in step .

In step deployment director authenticates VM based on the received the unique address e.g. queue name and one time password. Responsive to authenticating deployment agent executing on VM in step deployment director generates a digital certificate or any suitable cryptographic key mechanism specific to the requesting deployment agent that is used for authorization and authentication of future communications with deployment agent . For example deployment director may generate a digital certificate that incorporates the unique address into the digital certificate such as part of the common name CN of the digital certificate. Deployment director provides the certificate to deployment agent which in turn receives and imports the digital certificate into a keystore in step . It is understood that foregoing communications with deployment director may utilize the digital certificate for encrypted and secure communications. Having authenticated itself with deployment director deployment agent executing on VM is deemed boot strapped and is now ready for use in a deployment process for an application. In step deployment agent broadcasts its available status via secure communication with addressing and discovery layer . In step deployment director receives status messages from VMs e.g. VM to via addressing and discovery layer that indicate that provisioned VMs are ready to host application components of the application being deployed. Operations of continue to step shown in .

In step deployment agent processes local deployment plan to determine a first task to be performed according to an execution order specified by local deployment plan . Deployment agent transmits a task execution request to deployment director via addressing and discovery layer to determine whether deployment agent can proceed with execution of the first task. Deployment agent proceeds to wait in step until receipt of authorization to proceed with execution of the first task in local deployment plan .

In step deployment director receives an execution request for a task to be executed by a deployment agent hosted on a VM e.g. VMs to . In step deployment director determines if there any uncompleted tasks that the requested task depends on according to deployment plan . As described above deployment director maintains a centralized state of the deployment process that includes a status e.g. incomplete complete in progress for all tasks to be executed on all VMs during deployment. Further deployment director tracks an execution order provided by deployment plan comprised of deployment time dependencies between tasks within the same node and or between different nodes. Accordingly deployment director utilizes deployment plan to determine whether there are any tasks upon which the task requesting execution depends and if so whether these tasks have been completed yet. The existence of any uncompleted tasks from which the requested task depends blocks execution of the requested tasks.

As such in step responsive to determining that there are indeed uncompleted tasks upon which the requested task depends deployment director may return to step to repeatedly check for completion of the tasks upon which the requested task depends. Deployment director may determine that the dependent tasks have been completed using a variety of communication messaging and notification mechanisms such as a polling mechanism to periodically check for completion of the dependent tasks. In another example deployment director may register the requested task with a callback mechanism that maintains a list of which tasks are currently being blocked by which tasks and triggers notification when tasks have been completed.

Responsive to determining that there are no uncompleted tasks upon which the requested task depends in step deployment director evaluates current values of properties specified for the VM according to blueprint . As described above particular properties may be specified for application components to provide configuration values during execution of tasks for the application components e.g. installation configuration start up . Some property values may be utilized across multiple application components in the deployed application. For example a web application may be configured to access a database server using database user credentials e.g. username password specified by a property value e.g. database.username defined in blueprint . However certain property values are determined dynamically during deployment and cannot be made available initially for example in step when local deployment plans are transmitted. For example a database password may be randomly generated and is not determined until the database server has been initialized. As such deployment director centrally manages property values for all application components and all nodes and distributes property values to deployment agents throughout the deployment stage. For example the database password that is dynamically generated at the database server may be transmitted to deployment director that in turn provides the database password to the web application as needed. In one embodiment deployment director generates a set of property values specific to properties specified for a given node.

In step deployment director transmits authorization to execute the requested task as well as a set of property values for the VM via addressing and discovery layer . In step deployment agent receives the execution authorization and property values. While embodiments of the invention describe the authorization to execute the requested task as an express message passed to deployment agents it should be recognized that a variety of communication messaging and notification mechanisms including implied notifications may be utilized. One example of an implied notification is the establishment of a communication channel e.g. socket with deployment director . To implicitly notify that deployment agent may proceed with executing a task deployment director may close or shutdown the communication channel to signal authorization to execute. In step deployment agent executes the task for an application component utilizing the received property values. In one embodiment the received property values are embodied in a script that when executed sets values for environmental variables in an execution environment that executes the task.

In step deployment agent transmits a task status that indicates successful or unsuccessful completion of the task via addressing and discovery layer . In one embodiment deployment agent provides status output log records and other output e.g. verbose text output from a UNIX shell resultant from execution of the task. Deployment agent further transmits an updated set of property values post execution of the task to propagate any updated property values to other deployment agents hosted on VMs. In step deployment director receives task status and updated property values and updates the central state of the deployment process to indicate the completion of a task by deployment agent and to reflect the updated property values. In one embodiment deployment director generates deployment metadata to provide status of deployment for example by recording task start and end times for each task executed. Task start time may be tolled upon transmission of authorization to execute a requested tasks e.g. at step task end times may be tolled upon receipt of a task status from deployment agent e.g. at step .

In step deployment agent determines whether the executed task is the last task in local deployment plan and if so terminates execution. Responsive to determining that there are additional tasks to be performed in local deployment plan deployment agent returns to step and determines a next task in local deployment plan to be performed.

Meanwhile as discussed above deployment agent hosted on VM receives authorization to execute a requested task in step and proceeds to do so in step . It is appreciated that a significant amount of time that may exceed the timeout period of the node task timer may be needed to complete execution of a task. In step during execution of a task deployment agent may receive a heartbeat message from deployment director that requests deployment agent to report status within a specified response period. In step deployment agent transmits a heartbeat response to deployment director to indicate deployment agent is alive and active and that the task is still being executed.

In step deployment director determines whether a heartbeat response has been received within the specified response period. Responsive to determining that no heartbeat response has been received within the specified response period in step deployment director deems deployment agent to be dead and updates the central state of the deployment as having failed. In step responsive to determining that a heartbeat response has been received within the specified response period deployment director restarts the node task timer or alternatively modifies the node task timer to extend the timeout period and returns to step . It is noted that deployment director may interrupt any of the steps discussed above in upon receipt of a completed task status and updated property values e.g. in step in from deployment agent .

A virtualization software layer also referred to hereinafter as hypervisor is installed on top of hardware platform . Hypervisor supports virtual machine execution space within which multiple container VMs for hosting application components of an application may be concurrently instantiated and executed. As shown virtual machine execution space supports VMs to . For each of provisioned VMs to hypervisor manages a corresponding virtual hardware platform i.e. virtual hardware platforms that includes emulated hardware such as virtual hard drive virtual NIC virtual CPU and virtual RAM for VM . For example virtual hardware platform may function as an equivalent of a standard x86 hardware architecture such that any x86 supported operating system e.g. Microsoft Windows Linux Solaris x86 NetWare FreeBSD etc. may be installed as guest operating system to execute application component for VM although it should be recognized that in alternative embodiments each of container VMs to may support the execution of multiple application components rather than a single application component. Hypervisor is responsible for transforming I O requests from guest operating system to virtual hardware platform into corresponding requests to hardware platform . In the embodiment of guest operating system of container VM supports the execution of a deployment agent which is a process or daemon that communicates e.g. via addressing and discovery layer with deployment director to receive local deployment plan and execute scripts representing tasks of local deployment plan . Execution of the script may include retrieving unpacking installing and configuring application component packages. In one embodiment the application component package comprises a plurality of files similar to those in a WAR file organized into a tape archive file or a tar file also referred to as a tarball and that may be retrieved via download from a Git repository package manager or other similar application component resource. Deployment agent is configured to communicate with deployment director to provide execution status for tasks that have been successfully executed on VM or upon receipt of a heartbeat message. Deployment agent is automatically launched upon the instantiation of a VM in certain embodiments.

It should be recognized that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit or scope of the invention. For example virtual hardware platforms may be considered to be part of virtual machine monitors VMM which implement the virtual system support needed to coordinate operations between hypervisor and their respective container VMs. Alternatively virtual hardware platforms may also be considered to be separate from VMMs and VMMs may be considered to be separate from hypervisor . One example of hypervisor that may be used is included as a component of VMware s ESX product which is commercially available from VMware Inc. It should further be recognized that other virtualized computer system architectures may be used consistent with the teachings herein such as hosted virtual machine systems where the hypervisor is designed to run on top of a host operating system. It should further be recognized as previously discussed in the context of that virtualization environment which provides VMs such as those in may be supported by hardware resources that comprise any number of physical computers and data storage systems in one or more data centers connected by networking with each of the physical computers hosting one or more of VMs to and possibly other VMs that run one or more processes carrying out the functions of other components of cloud computing environment such as router cloud director address and discovery layer and the like. As discussed in the context of with respect to container VMs each VM supporting such other components is a virtual computer system that may have a guest operating system and one or more guest applications that can include any of the above processes.

While embodiments disclosed herein are discussed with regards to a deployment operation operations for managing existing deployments may be performed utilizing techniques described herein. For example an embodiment may be used to redeploy an already deployed application by updating application specific code e.g. going from version 1.0 to version 1.1 upgrade an already deployed application to upgrade the software services e.g. middleware of the application such as updating to the latest version of Apache backup a deployed application based on knowledge of an application s data storage e.g. database storage repositories etc. from the blueprint and patch a deployed application to allow for smaller binary updates to libraries services or configurations for security and other reasons.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. For example while embodiments herein have referred to certain methods for establishing communication between deployment director and a VM such as via bootstrap script it should be recognized that any authentication mechanism may be utilized in alternative embodiments such as pre shared keys encrypted key exchange digest access authentication etc. In addition while embodiments herein have referred to certain mechanisms for communication such as via addressing and discovery layer between components of the described system e.g. deployment director VMs it should be recognized that any system for messaging notification and other communications such as polling callbacks pull requests e.g. POST requests REST APIs message brokering etc. may be utilized in alternative embodiments. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

