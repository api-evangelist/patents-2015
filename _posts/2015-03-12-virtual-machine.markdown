---

title: Virtual machine
abstract: A distributed system including one or more data processing devices executing instructions configuring the one or more data processing device to execute a virtual machine including a software application and an agent. The agent is configured to receive a first health status of the software application, determine a second health status of the software application, compare the first health status and the second health status, and restart the software application based on the comparison. The one or more data processing device also execute an application server configured to remotely determine the first health status of the software application and send the first health status of the software application to the virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09524214&OS=09524214&RS=09524214
owner: Google Inc.
number: 09524214
owner_city: Mountain View
owner_country: US
publication_date: 20150312
---
This U.S. patent application claims priority under 35 U.S.C. 119 e to U.S. Provisional Application 61 969 369 filed on Mar. 24 2014 which is hereby incorporated by reference in its entirety.

In a distributed system a data processing device can execute instructions configuring the data processing device to instantiate an instance of a virtual machine. A virtual machine can emulate a computer and an operating system running on the computer. A virtual machine can be used to execute a software application.

One aspect of the disclosure provides a distributed system for a virtual machine. The distributed system includes one or more data processing devices executing instructions configuring the one or more data processing devices to execute a virtual machine and an application server. The virtual machine includes a software application and an agent. The agent is configured to receive a first health status of the software application determine a second health status of the software application compare the first health status and the second health status and restart the software application based on the comparison. The application server is configured to remotely determine the first health status of the software application and send the first health status of the software application to the virtual machine.

Implementations of the disclosure may include one or more of the following optional features. In some implementations the agent is configured to restart the software application in response to the first health status being different from the second health status. The agent may further be configured to receive the first health status periodically and to restart the software application in response to not receiving the first health status within a threshold period of time.

In some examples the application server is further configured to receive a health check configuration and determine the first health status of the software application based on the health check configuration. The agent may be configured to receive a health check configuration and determine the second health status based on the health check configuration. The health check configuration may be provided by a user.

The virtual machine may further include a health check handler interfaced with the software application and the application server may determine the first health status via the health check handler. The second health status may include a previous health status determined by the application server. The agent may be configured to restart the virtual machine based on the comparison. The agent may further be configured to restart the virtual machine in response to a subsequent mismatch between the first health status and the second health status after the application is restarted.

Another aspect of the disclosure provides a computer implemented method for an operating a virtual machine. This aspect may include one or more of the following optional features. The computer implemented method includes executing a software application in a virtual machine executing on a data processing device and receiving at the virtual machine a first health status of the software application from an application server executing on a data processing device. The method further includes determining at the virtual machine a second health status of the software application comparing the first health status and the second health status and restarting the software application based on the comparison.

In some implementations restarting the virtual machine includes restarting in response to the first health status being different from the second health status. Receiving a first health status of the software application may include receiving the first health status periodically. Restarting the virtual machine may further include restarting the software application in response to not receiving the first health status within a threshold period of time.

In some examples the method further includes receiving a health check configuration wherein the first health status and the second health status of the software are determined based on the health check configuration. The health check configuration may be provided by a user.

The method may include determining the first health status of the software application via a health check handler interfaced with the software application. The second health status may include a previous health status determined by the application server. The method may include restarting the virtual machine based on the comparison. The method may further include restarting the virtual machine in response to a subsequent mismatch between the first health status and the second health status after the software application is restarted.

Yet another aspect of the disclosure provides a virtual machine executable on a data processing device. This aspect may include one or more of the following optional features. The virtual machine includes a software application and an agent. The agent is configured to receive a first health status of the software application executing in a virtual machine determine a second health status of the software application compare the first health status and the second health status and restart the software application based on the comparison.

In some examples the agent is configured to restart the software application in response to the first health status being different from the second health status and to receive the first health status periodically. The agent may be configured to restart the software application when the agent does not receive the first health status during a predetermined time duration. The agent may further be configured to receive a health check configuration and determine the second health status based on the health check configuration.

The virtual machine may include a health check handler interfaced with the software application wherein the agent is configured to receive the first health status and determine the second health status via the health check handler. The second health status may be based on a first health status determined at a previous time. The agent may be configured to restart the virtual machine based on the comparison or to restart the virtual machine in response to a subsequent mismatch between the first health status and the second health status after the software application is restarted.

Yet another aspect of the disclosure provides a distributed system for deploying a software application. The distributed system includes one or more data processing devices and a non transitory computer readable medium. The data processing devices execute instructions configuring the one or more data processing devices to execute a virtual machine and an application server. The virtual machine includes an image of an operating system and a software application. The non transitory computer readable medium is in communication with the one or more data processing devices. The non transitory computer readable medium stores an image repository that stores one or more images. The application server is configured to receive a selection of a policy from a plurality of policies and associate the selected policy with the software application. In response to the selected policy being a first policy when the software application is first deployed the application server is configured to archive the image mounted on the virtual machine in the image repository and associate the mounted image with the software application. In response to receiving a command to redeploy the software application if the policy associated with the software application is the first policy the application server is configured to retrieve the image associated with the software application from the image repository. If the policy associated with the software application is a second policy the application server is configured to retrieve the most recent image in the image repository mount the retrieved image on the virtual machine and redeploy the software application.

The computer readable medium may further store a security repository storing a security patch. The application sever may be further configured to in response to receiving the command to redeploy the software application install the security patch on the virtual machine if the policy associated with the software application is the second policy and not install the security patch on the virtual machine if the policy associated with the software application is the first policy. The application server may be further configured to in response to the selected policy being a third policy and when the software application is first deployed archive the image mounted on the virtual machine in the image repository and associate the mounted image with the software application. In response to receiving the command to redeploy the software application the application server is configured to retrieve the image associated with the software application from the image repository and install the security patch on the virtual machine.

In some examples the non transitory computer readable medium stores a software package repository and the virtual machine includes a software package. The application server may be further configured to in response to the selected policy being a first policy when the software application is first deployed archive the software package installed on the virtual machine in the non transitory software package repository and associate the installed software package with the software application. In response to receiving a command to redeploy the software application if the policy is associated with the software application is the first policy the application server is configured to retrieve the software package associated with the software application from the non transitory software package repository. If the policy associated with the software application is a second policy the application server is configured to retrieve the most recent software package stored in the non transitory software package repository and install the retrieved software package on the virtual machine.

Yet another aspect of the disclosure provides a method for deploying a software application. The method includes at an application server receiving a selection of a policy from a plurality of policies and associating the selected policy with the software application. In response to the selected policy being a first policy when the software application is first deployed the method includes archiving the image mounted on the virtual machine in a non transitory image repository and associating the mounted image with the software application. In response to receiving a command to redeploy the software application if the policy associated with the software application is the first policy the method includes retrieving the image associated with the software application from the non transitory image repository. If the policy associated with the software application is a second policy the method includes retrieving the most recent image stored in the non transitory image repository mounting the retrieved image on a virtual machine and redeploying the software application.

In some examples the method includes in response to retrieving the command to redeploy the software application installing a security patch on the virtual machine if the policy associated with the software application is the second policy and not installing the security patch on the virtual machine if the policy associated with the software application is the first policy. The method may further include in response to the selected policy being a third policy and when the software application is first deployed archiving the image mounted on the virtual machine in the non transitory image and associating the mounted image with the software application. In response to receiving the command to redeploy the software application the method includes retrieving the image associated with the software application from the non transitory image repository and installing the security patch on the virtual machine.

The method may further include in response to the selected policy being a first policy and when the software application is first deployed archiving the software package installed on the virtual machine in the non transitory software package repository and associating the installed software package with the software application. In response to receiving a command to redeploy the software application if the policy associated with the software application is the first policy the method includes retrieving the software package associated with the software application from the non transitory software package repository. If the policy associated with the software application is a second policy the method includes retrieving the most recent software package stored in the non transitory software package repository and installing the retrieved software package on the virtual machine.

Yet another aspect of the disclosure provides a distributed system for deploying a software application. The distributed system includes one or more data processing devices a non transitory computer readable medium and an application server. The one or more data processing devices execute instructions configuring the one or more data processing devices to execute a virtual machine including an image of an operating system mountable on the virtual machine a software package executable on the virtual machine and a software application executable on the virtual machine. The non transitory computer readable medium stores an image repository a software package repository and a security repository. The application server is in electronic communication with the computer readable medium and is configured to receive a command to redeploy the software application. In response to one ofa first policy and a second policy being associated with the software application the application server mounts a previously mounted image on the virtual machine and installs a previously installed software package on the virtual machine. In response to the second policy being associated with the software application the application server installs a security patch from the security repository. In response to the third policy being associated with the software application the application server mounts a new image on the virtual machine installs a new software package on the virtual machine installs the security patch from the security repository and redeploys the software application.

Another aspect of the disclosure provides a computer implemented method for deploying a software application on a virtual machine executing on a data processing device. The method includes receiving a command to redeploy the software application. In response to one of a first policy and a second policy being associated with the software application the method includes mounting a previously mounted image on the virtual machine and installing a previously installed software package on the virtual machine. In response to the second policy being associated with the software application the method includes installing a security patch from the non transitory security repository. In response to the third policy being associated with the software application the method includes mounting a new image on the virtual machine installing a new software package on the virtual machine and installing the security patch from the non transitory security repository and redeploying the software application.

Another aspect of the disclosure provides a virtual machine executable on a data processing device. The virtual machine includes an image of an operating system executable on the virtual machine. The operating system includes a file system and a plurality of application programming interface libraries. The application container includes a file system mount interfaced with the file system residing outside the application container a software application including a reference to an application programming interface and the application programming interface referenced by the software application. The application container does not include application programming references that are not referenced by the software application.

In some examples the file system includes an application specific logging folder and the file system mount in the application container is interfaced with the application specific logging folder. The software application may include a reference to a portion of the operating system the application container may include only the portion of the operating system referenced by the software application and the unreferenced portion of the operation system may be outside the application container. The application container may be configured to prevent the software application from accessing a resource located outside the application container. The application container may be further configured to generate a warning in response to the software application attempting to access a resource outside the application container.

In some implementations the virtual machine includes an agent configured to terminate the software application in response to the software application attempting to access a resource outside the application container. The agent may further be configured to terminate the virtual machine in response to the software application attempting to access a resource outside the application container.

Yet another aspect of the disclosure provides a computer implemented method for executing a software application in a virtual machine executing on a data processing device. The method includes receiving software code for a software application determining application programming interfaces referenced by the software code determining portions of an operating system accessed by the software code and creating an application container in the virtual machine. The method also includes application programming interfaces referenced by the software code inside the application container portions of the operating system accessed by the software code inside the application container and executing the software application inside the application container on the virtual machine.

In some examples the method includes halting execution of the software application in response to the software application attempting to access an application programming interface outside the application container. The method may further include halting the virtual machine in response to the software application accessing an unauthorized application programming interface outside the application container.

The details of one or more implementations of the disclosure are set forth in the accompanying drawings and the description below. Other aspects features and advantages will be apparent from the description and drawings and from the claims.

In some implementations the distributed computing system connects to a public network for example the Internet. Moreover the network may include a firewall to prevent unauthorized access to the distributed computing system . Users can access the distributed computing system through user computers . A software developer of the software applications may access the distributed computing system through a developer computer . Finally an end user can access the software applications through an end user computer

The virtual machine is a software based emulation of a computer. The virtual machine operates based on the computer architecture and functions of a real or hypothetical computer. The software application executed by the virtual machine may have a health status which may include a healthy status H or an unhealthy status U. In some implementations the virtual machine and or the application server determines the health status of the software application . Moreover the user may specify the manner in which the virtual machine and or the application server determine the health status of the software application .

In some implementations the application server manages the software application . In some scenarios several virtual machines execute a single software application . The application server may manage the network traffic being sent to each virtual machine executing the software application . For example if the application server determines that a particular virtual machine executing the software application is slow then the application server can send network traffic to another virtual machine . The software application can use a datastore as operating memory or to store data generated by the software application .

The health check handlers may determine the health status of the software application in any suitable manner. In some implementations the health check handlers determine the health status of the software application by assessing the responsiveness of the software application . The health check handlers may determine the responsiveness of the software application by measuring an amount of time the software application takes to complete a particular task. For example the health check handlers may request the software application to provide information regarding an amount of memory the software application is currently using. If the software application provides the requested information within a predetermined amount of time e.g. 5 ms then the health check handlers may determine that the health status of the software application is healthy H. On the other hand if the software application does not respond to the request or takes too long to respond to the request e.g. more than 10 s then the health check handlers may determine that the software application is unhealthy U.

In some implementations the health check handlers determine the health status of the software application by determining a number of memory leaks in the software application . The virtual machine may have allocated a block of memory for the software application to use. If the software application uses a memory block that is not within the allocated block then the health check handlers may determine that the software application is unhealthy U.

In other implementations the health check handlers may determine the health status of the software application by determining whether the software application is attempting to access an unauthorized or restricted application programming interface API . The virtual machine may restrict access to certain APIs to prevent a corrupt or malicious software application from causing damage to the virtual machine . If the software application is attempting to access a restricted API then the health check handlers may determine that the software application is unhealthy U.

In yet other implementations the health check handlers may determine the health status of the software application based on user feedback. An end user may rate the software application . For example the end user may provide a rating that ranges from one star to five stars where one star corresponds with a poor software application and five stars correspond with an outstanding software application. The health check handlers may determine that a software application is unhealthy U if the number of one star ratings that a software application receives exceeds a threshold e.g. 1000 . The health check handlers may use other methods for determining the health status of the software application .

The agent determines a local health status L of the software application . Although the agent determines the local health status L of the software application the local health status L may not be representative of the true health status of the software application . Since the agent resides inside the virtual machine it is difficult for the agent to determine the true health status of the software application i.e. the health of the software application as determined by the application server from outside the virtual machine .

The health check handlers may determine the health status of the software application in accordance with health check configurations . In some implementations user application files that can reside in the user computer specify the health check configurations . Additionally or alternatively both the software developer and the end user may specify the health check configurations . In yet additional implementations only the software developer or only the end user may specify the health check configurations . The health check configurations can specify how and or when the application server and or the virtual machine determine the health status of the software application . For example the health check configurations may specify that if a software application does not respond to a request within five milliseconds then the health status of the software application is unhealthy U.

In some examples the health check configurations specify that the health status of the software application is to be determined periodically e.g. every five seconds. The health check configurations may specify an amount of memory or the number of virtual machines that the software application is permitted to use and if the software application exceeds the usage limits then the health status of the software application is unhealthy U. Moreover the health check configurations may specify a list of resources that the software application uses during execution. If during execution the software application uses resources other than the user specified resources then the health status of the software application is unhealthy U. For example the health check configurations may specify the software application is not permitted to use a camera API. If the software application attempts to use the camera API then the health check handlers determine that the software application is unhealthy U.

In some scenarios the software application can become corrupt and can start behaving in an unpredictable manner. In such scenarios the health check parameters and or can determine that the software application is unhealthy U. For example the health check configurations may specify the expected behavior of the software application . If the software application deviates from the expected behavior specified in the health check configurations then the health check handlers can determine that the software application is unhealthy U. In the above example the software developer or the end user may specify the expected behavior of the software application in the health check configurations .

In some implementations the application server includes an administration console . The administration console may provide a graphical user interface GUI to the user computer . The user can use the GUI to provide the health check configurations to the administration console . After the administration console receives the health check configurations the administration console sends the health check configurations to a data handler . The data handler can convert the health check configurations into a format that can be stored in a datastore . For example the data handler may validate input provided by the user to make sure the input is valid. The data handler may also verify whether the health check handlers are configured to determine the health status of the software application in accordance with the health check configurations provided by the user . In some instances the health check handlers may not be configured to determine the health status of the software application in accordance with the health check configurations provided by the user . For example the user may have specified in the health check configurations for the health check handlers to determine the health status every microsecond. But the health check handlers may be configured to determine the health status at intervals of milliseconds. The data handler may ignore the portion of the health check configurations that directs the health check handlers to determine the health status at every millisecond. Similarly the data handler may ignore other portions of the health check configurations with which the health check handlers are not able to comply.

The administration console sends the health check configurations to an application master . While the application master is shown separate from the application server the application master can be a part of the application server . The application master manages all configuration data for the software application . The application master receives the health check configurations from the administration console and stores the health check configuration in the application configuration datastore . Similar to the data handler the application master may validate the health check configuration to make sure the health check configuration is valid. The application master may ignore certain health check configurations that are infeasible e.g. not possible to check . The application configuration datastore stores the health check configurations in a suitable format.

An application health monitor determines a remote health status R of the software application in accordance with the health check configurations . Unlike the agent the application health monitor is able to determine the health status of the software application from outside the virtual machine . Therefore the remote health status R determined by the application health monitor may be more accurate than the local health status L determined by the agent .

The application health monitor determines the remote health status R of the software application by interacting with the special health check handler which in turn interacts with the application health check handler inside the software application . After determining the remote health status R the application health monitor sends the remote health status R to the special health check handler . The special health check handler saves the remote health status R for later use.

The agent can receive the remote health status R determined by the application health monitor from the special health check handler . In this manner the agent is aware of the local health status L and also the remote health status R. The agent compares the local health status L with the remote health status R. If there is a mismatch between the local health status L and the remote health status R then the agent restarts the software application . If after restarting the software application there is still a mismatch between a subsequent local health status L and a subsequent remote health status R then the agent restarts the virtual machine .

Unlike other virtual machines that may not be aware of the remote health status R the virtual machine and the agent are aware of the remote health status R. In some scenarios the remote health status R is unhealthy U but the local health status L is healthy H. Other virtual machines that are not aware of an unhealthy remote health status R may continue to execute the software application as long as the local health status L is healthy H. Unaware virtual machines are at a disadvantage because the application server may not direct network traffic to the unaware virtual machines. By contrast the virtual machines in the examples shown are aware of the remote health status R. In response to the remote health status R becoming unhealthy U the virtual machines may restart the software application and or the virtual machine thereby restoring the flow of network traffic into the virtual machines .

At the application health monitor determines a remote health status R of the software application . As discussed above the application health monitor may determine the remote health status R of the software application via the special health check handler . The special health check handler in turn may determine the health status of the software application by interacting with the application health check handler residing inside the software application .

At the application health monitor sends the remote health status R to the virtual machine . The application health monitor may send the remote health status R to the special health check handler . Alternatively the application health monitor may send the remote health status R directly to the agent .

At the virtual machine determines a local health status L of the software application . In this implementation the agent determines the local health status L of the software application . The agent may determine the local health status L of the software application via the special health check handler . In some implementations the agent and or the special health check handler may determine the local health status L based on a previous remote health status R. For example if the agent and or the special health check handler determine that the last remote health status R is unhealthy U then the agent and or the special health check handler determine that the local health status L is unhealthy U. In some implementations if the agent and or the special health check handler determine that the last remote health status R is too old then the agent or the special health check handler determine that the local health status L is unhealthy U. The last remote health status R may be too old if a difference between a current time and a time at which the agent or the special health check handler received the last remote health status R is greater than a threshold for example one two or five minutes.

At the agent compares the local health status L and the remote health status R. If the local health status L matches the remote health status R then the method ends at . If however the local health status L and the remote health status R do not match then the method proceeds to . As discussed above in some cases the local health status L may be healthy H but the remote health status R may be unhealthy U. This can happen because the agent is inside the virtual machine and it is difficult for the agent to correctly determine the health status of the software application .

If the local health status L and the remote health status R do not match then the agent first attempts to rectify the mismatch by restarting the software application at . If after restarting the software application subsequent determinations of the local health status L and the remote health status R match then the agent does not restart the virtual machine . If however after restarting the software application subsequent determinations of the local health status L and the remote health status R still do not match then the agent restarts the virtual machine at .

Each software application has an associated policy . The policy specifies how the virtual machine is instantiated when a software application is redeployed subsequent to an initial deployment of the software application . If a software application is redeployed subsequent to the initial deployment of the software application the policy specifies which image is mounted on the virtual machine prior to the redeployment of the software application . The policy may further specify which software package is installed on the virtual machine prior to the redeployment of the software application . The policy may also specify whether a security patch is installed on the virtual machine prior to the redeployment of the software application . In the example of there are three policies a fixed policy a security policy and an automatic update policy . In other examples there may be more or less than three policies .

The fixed policy specifies that when a software application associated with the fixed policy is redeployed subsequent to an initial deployment the virtual machine mounts the same image that was mounted when the software application was initially deployed. The fixed policy further specifies that virtual machine install the same software package that was installed on the virtual machine when the software application was initially deployed. The fixed policy further specifies that the virtual machine not install the security patch unless the security patch was installed on the virtual machine when the software application was initially deployed. In some implementations initial deployment of the software application refers to a time when the software application was deployed for the very first time in a production environment.

The security policy specifies that when a software application associated with the security policy is redeployed subsequent to an initial deployment the virtual machine mount the same image that was mounted when the software application was initially deployed. The security policy further specifies that virtual machine install the same software package that was installed on the virtual machine when the software application was initially deployed. The security policy further specifies that the virtual machine install the security patch . The security policy differs from the fixed policy in that the security policy requires the virtual machine to install the security patch whereas the fixed policy does not require the virtual machine to install the security patch .

The automatic update policy specifies that when a software application associated with the automatic update policy is redeployed subsequent to an initial deployment the virtual machine mount the latest image that is stored in the remote image repository . The automatic update policy further specifies that virtual machine install the latest software package that is stored in the remote software package repository . The automatic update policy further specifies that the virtual machine install the security patch . The automatic update policy differs from the fixed policy and the security policy in that the automatic update policy requires the virtual machine to install the latest image and the latest software package instead of the image and the software package that were installed during the initial deployment of the software application .

Once a virtual machine deploys a software application there may be some circumstances in which the virtual machine has to redeploy the software application . For example the virtual machine may need to restart the software application andLor the virtual machine if the health status of the software application is unhealthy U as discussed above. In some scenarios the virtual machine may have to redeploy the software application by reinstalling the software application the software package and the image in order to restore the health status of the software application .

In some implementations when the application server and or the virtual machine redeploy the software application that is associated with the fixed policy the application server and or the virtual machine select the same image and the same software package that were used to initially deploy the software application . Advantageously by selecting the same image and the same software package that were used at the initial deployment the application server and or the virtual machine help ensure predictable behavior for the software application upon redeployment. The application server and the virtual machine do not install the security patch on the virtual machine in order to ensure predictable execution of the software application upon redeployment. However if the security patch was installed on the virtual machine at the initial deployment of the software application then the application server or the virtual machine may install the security patch on the virtual machine

In the example of when the application server and or the virtual machine redeploy the software application that is associated with the security policy the application server and or the virtual machine select the same image and the same software package that were used to initially deploy the software application . Advantageously by selecting the same image and the same software package that were used at the initial deployment the application server and or the virtual machine help ensure predictable behavior for the software application upon redeployment. The application server and the virtual machine install the security patch on the virtual machine because the software application is associated with the security policy that specifies that the security patch be installed prior to redeployment. While installing the security patch may change the behavior of the software application upon redeployment the change in behavior is minimized by maintaining the same image and the same software package

With continued reference to when the application server and or the virtual machine redeploy the software application that is associated with the automatic update policy the application server and or the virtual machine select the latest image and the latest software package . The application server and or the virtual machine install the security patch on the virtual machine because the software application is associated with the automatic update policy that specifies that the security patch be installed prior to redeployment. Unlike the software application the behavior of the software application may change upon redeployment.

At the application server initially deploys the software application . At the application server takes a snapshot of the remote software repository when the software application is initially deployed. The application server may take the snapshot of the remote software repository by archiving the software package that was initially installed on the virtual machine . By taking a snapshot of the remote software repository the application server ensures that the software package installed on the virtual machine at initial deployment may be available for use during a redeployment at a later time. At the application server stores a version identifier ID of the software package in association with the software application . When the application server and or the virtual machine redeploy the software application at a later time the application server can use the version ID to retrieve the software package that was initially installed on the virtual machine .

At the application server takes a snapshot of the remote image repository when the software application is initially deployed. The application server may take the snapshot of the remote image repository by archiving the image that was initially mounted on the virtual machine . By taking a snapshot of the remote image repository the application server ensures that the image mounted on the virtual machine at initial deployment may be available for use during a redeployment at a later time. At the application server stores the version ID of the image in association with the software application . When the application server and or the virtual machine redeploy the software application at a later time the application server can use the version ID to retrieve the image that was initially mounted on the virtual machine .

At the application server and or the virtual machine detect a trigger to restart the software application and or the virtual machine . For example the agent may have determined a mismatch between the local health status L and the remote health status R and the agent may decide to restart the software application or to the restart the virtual machine as discussed above. Upon a trigger to redeploy the software application the application server and or the virtual machine determine which policy is associated with the software application .

At the application server determines whether the fixed policy is associated with the software application . If the fixed policy is associated with the software application then the application server retrieves the software package from the remote software repository using the software version ID stored in association with the software application at . At the application server retrieves the image from the image repository using the image version ID stored in association with the software application . Upon retrieving the image and the software package the application server and or the virtual machine mount the image onto the virtual machine install the software package on the virtual machine and redeploy the software application . In this scenario due to the fixed policy when the application server and or the virtual machine redeploy the software application the software application executes on the same image and the same software package as the software application was executing on when the application server and or the virtual machine initially deployed the software application . As a result the software application is more likely to behave in a predictable manner.

If the policy associated with the software application is not the fixed policy then the application server determines whether the policy associated with the software application is the security policy at . If the policy is the security policy then at the application server retrieves the software package from the remote software repository using the software version ID stored in association with the software application . At the application server retrieves the image from the image repository using the image version ID stored in association with the software application . At the application server retrieves the latest security patch from the security repository . The security patch is installed on the virtual machine

If at the application server determines that the security policy does not apply then at the application server determines whether the automatic update policy applies. If the automatic update policy applies then at the application server retrieves the latest software package from the remote software repository at . At the application server retrieves the latest image from the remote image repository . At the application server retrieves the security patch and installs the security patch on the virtual machine

The application container includes a file system mount on an application specific logging folder of the file system . The code can interact with the file system of the operating system via the file system mount . The application container may only contain those portions of the file system that are necessary for the code to function as intended. By excluding all other portions of the file system and the operating system from the application container the virtual machine is relatively safer from unforeseen bugs in the code . For example the code may have certain malicious functions that attempt to derail the stability of the virtual machine . Any malicious functions in the code can only access the resources provided in the application container and not the resources located outside the application container . For example the code cannot access the entire file system therefore the amount of damage that the code can do to the file system and other portions of the operating system is limited.

The agent can monitor the resources that the code and the web process attempt to access. If the software application attempts to access APIs or other resources that are outside the application container then the agent can halt execution of the software application . Alternatively the agent can terminate the execution of the software application . Further the agent can detect breaches in the boundary of the application container . For example if the code is successful in accessing a restricted or an unauthorized resource of the file system that is outside the application container then the agent can halt operation of the virtual machine or terminate the virtual machine altogether thereby preventing excessive damage to the virtual machine .

The agent may be configured to detect attempts from the code to access resources outside the application container and generate a warning that may be provided to the application server . The application server may provide the warning to a user . The user may override the boundaries of the application container thereby allowing the software application to access portions of the file system that are located outside the container .

At the application server instructs the virtual machine to create an application container . The virtual machine contains the software code of the software application inside the application container at . At the virtual machine imports the API libraries referenced by the software application into the application container . The virtual machine imports portions of the operating system accessed by the software code into the application container at .

At the virtual machine executes the software application inside the application container . At the agent determines whether the software application is attempting to use an API library or resource that is outside the application container . At the agent generates a warning that the software application is attempting to access an API or other resource that is outside the application container . The warning may be sent to the application server . The application server may send the warning to the user that the software application is trying to access a resource outside the application container .

Alternatively at the agent can request the application server for permission to expand the boundaries of the application container . If the application server grants permission to expand the boundaries of the application container the virtual machine modifies the boundaries of the application container by including additional resources inside the application container that the software application requests during execution. In another example implementation the agent halts execution of the software application when the software application attempts to access an API or other resource that is outside the application container . The method ends at .

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Moreover subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter affecting a machine readable propagated signal or a combination of one or more of them. The terms data processing apparatus computing device and computing processor encompass all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as an application program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor may receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer may also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user one or more aspects of the disclosure can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display monitor or touch screen for displaying information to the user and optionally a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

One or more aspects of the disclosure can be implemented in a computing system that includes a backend component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a frontend component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such backend middleware or frontend components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In some implementations a server transmits data e.g. an HTML page to a client device e.g. for purposes of displaying data to and receiving user input from a user interacting with the client device . Data generated at the client device e.g. a result of the user interaction can be received from the client device at the server.

While this specification contains many specifics these should not be construed as limitations on the scope of the disclosure or of what may be claimed but rather as descriptions of features specific to particular implementations of the disclosure. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multi tasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other implementations are within the scope of the following claims.

