---

title: Systems and methods for a multiple value packing scheme for homomorphic encryption
abstract: Systems and methods for a multiple value packing scheme for homomorphic encryption are described, including at a server, generating a plurality of encrypted payloads, each having a plurality of data values; and at a client, receiving each of the encrypted payloads having the plurality of data values; and multiplying one or more of the data values of one of the encrypted payloads by one or more other data values in one or more of the other encrypted payloads, to generate a product that represents the summation of data values corresponding to the multiplied one or more data values of the encrypted payloads and the one or more of the other data values in the one or more other encrypted payloads.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09641318&OS=09641318&RS=09641318
owner: GOOGLE INC.
number: 09641318
owner_city: Mountain View
owner_country: US
publication_date: 20150106
---
The subject matter discussed herein relates generally to data processing and more particularly to systems and methods for homomorphic encryption using a multiple value packing scheme.

In the related art a database database as a service or cloud database operation may be performed. More specifically the database server may holds the data of the user e.g. user transport data and the user may perform an operation on the data e.g. a query . The user may have data which is sensitive which he or she does not want the server e.g. cloud owner to know.

Homomorphic cryptography such as Paillier cryptography includes many properties. For example given two values V and V referred to as plaintexts E V C i.e. encrypting V resulting the ciphertext C and E V C. One of the properties of homomorphic cryptography is that the product of two ciphertexts C and C will decrypt to the sum of their corresponding plaintexts V and V.

With an increasing volume of data and number of transactions being handled on the server side there is a need to reduce a number of bytes that must be transferred to implement homomorphic cryptography.

The subject matter includes computer implemented methods for performing homomorphic encryption to generate a summation including at a client receiving a plurality of encrypted payloads and of the encrypted payloads having a plurality of data values and multiplying one or more of the data values of one of the encrypted payloads by one or more other data values in one or more of the other encrypted payloads to generate a product that represents the summation of data values corresponding to the multiplied one or more data values of the one of the encrypted payloads and the one or more other data values in the one or more other of the encrypted payloads.

The subject matter also includes a computer implemented method of performing homomorphic encryption to generate a summation including at a server at a server generating a plurality of encrypted payloads each having a plurality of data values wherein the data values of each of the encrypted payloads are positioned at a lower half of each of the encrypted payloads and an upper half of each of the encrypted payloads is empty.

Further the subject matter includes a computer implemented method of performing homomorphic encryption to generate a summation the method including at a server generating a plurality of encrypted payloads each having a plurality of data values and at a client receiving each of the encrypted payloads having the plurality of data values and multiplying one or more of the data values of one of the encrypted payloads by one or more other data values in one or more of the other encrypted payloads to generate a product that represents the summation of data values corresponding to the multiplied one or more data values of the encrypted payloads and the one or more of the other data values in the one or more other encrypted payloads.

The methods are implemented using one or more computing devices and or systems. The methods may be stored in computer readable media.

The subject matter described herein is taught by way of example implementations. Various details have been omitted for the sake of clarity and to avoid obscuring the subject matter. The examples shown below are directed to structures and functions for implementing systems and methods associated with a multiple value packing scheme for homomorphic encryption.

At the server receives the encrypted IDs f X . . . f Xn . . . from the client and performs an encryption operation with key g and sends g X . . . g Xn to the client . Further the server encrypts server IDs Y . . . Ym with key g and sends g Y . . . g Ym to the client along with the value e.g. spend Si encrypted with Paillier homomorphic encryption E. The encrypted values of the numbers are provided to the client as individual separate payloads for each of the numbers e.g. spend values .

At at the client the server IDs g X . . . g Xn are further encrypted with key f to generate fg Y . . . fg Ym . At the client performs a checking operation to determine if there is a match or intersection between gf Xi and fg Yj . Such a match or intersection would indicate that Xi equals Yj.

At for the intersections the client multiplies all of the values of E Sj which are the encrypted values of Sj to generate a product which will be the same as the encryption of the sum of the clear values of Sj. The client may request the server to decrypt the product and return the sum. To avoid revealing the sum during the return process the client may perform a blinding operation i.e. multiply the product by E r to return a random number r.

At the server Paillier decrypts and returns the result to the client . To obtain the clear sum the client subtracts random number r from the result sent by the server to the client .

The server packing tool includes a packing tool operator which controls the server packing tool . For example multiple data values may be packed into a single payload at the command of the packing tool operator such that the server packing tool provides a plurality of such encrypted payloads to the server side module . The server side module provides the encrypted payloads to the client side module . Further details of the encrypted payloads are discussed below with respect to .

The client unpacking tool receives the encrypted single payloads. More specifically an unpacking tool operator performs a series of left shifting operations on each of the single payloads from the client side module which were in turn received from the server side module . The left shifting operations use exponentiation to shift the values within the single payloads such that the desired value is in a prescribed position. When the left shifting operation has been completed a product of the encrypted data values is obtained at the client unpacking tool which is associated with a sum of the plaintext values. Optionally the client side module may blind the product and request for the server side module to decrypt and return a blinded sum to the client side module which unblinds the blinded sum to obtain the plaintext sum that represents the value e.g. spend value .

At the server in the server receives the encrypted IDs f X . . . f Xn . . . from the client and performs an encryption operation with key g and optionally sends g X . . . g Xn to the client . Further at the server sends to the server the value e.g. spend Si encrypted with Paillier homomorphic encryption E. Optionally the server encrypts server IDs Y . . . Ym with key g and sends g Y . . . g Ym to the client .

According to the example implementation at the server includes e.g. packs multiple values e.g. four spend values S . . . S into a single Paillier payload which are then encrypted and sent to the client . Within each of the plurality of single payloads each of the values is separated from other values by a 32 bit guard. In other words 32 bits of space is provided between S and S for example. The purpose of the spacing is to allow carryover to not intrude onto neighboring numbers. Thus for example but not by way of limitation 128 bits may be used to represent each number assuming that the numbers are 64 bit integers e.g. int64 having 96 bits of representation and 32 bits of zeroes as a guard or separator between neighboring numbers. As a result up to 2 32 possible values may be used without a carryover problem.

While int64 is used in the example implementation the present inventive concept is not limited thereto and other sizes of integer payload and spacing may be used as would be understood by those skilled in the art without departing from the scope of the inventive concept. For example but not by way of limitation these values may be determined based on the application.

Further the values only cover the lower half of each of the encrypted payloads. The most significant e.g. upper half is kept empty. As explained below with respect to the upper half may be employed during the unpacking operation for a shifting process.

Accordingly multiple spend values are packed into each of the single payloads by the server and are encrypted and sent to the client . Accordingly the number of bytes that need to be transferred may be reduced by 1 N where N is the number of values on each of the single payloads. In the present example the number of bytes that need to be transferred would be reduced by i.e. one fourth .

At at the client the server IDs g X . . . g Xn are further encrypted with key f to generate fg Y . . . fg Ym . At the client performs a checking operation to determine if there is a match or intersection between gf Xi and fg Yj . Such a match or intersection would indicate that Xi equals Yj. As explained in greater detail below with respect to an unpacking operation is performed that involves a shifting operation.

At for the intersections the client multiplies all of the values of E Sj which are the encrypted values of Sj to generate a product which will be the same as the encryption of the sum of the clear values of Sj. The client may request the server to decrypt the product and return the sum. To avoid revealing the sum during the return process the client may perform a blinding operation i.e. multiply the product by E r to return a random number r.

At the server Paillier decrypts and returns the result to the client . To obtain the clear sum the client subtracts random number r from the result sent by the server to the client .

In the example implementation of the client needs to multiply the encrypted values of E S E S E S and E S . Accordingly these encrypted values must be positioned at a prescribed position in the payload. For example the encrypted values of E S E S E S and E S are positioned in the fourth position in . Accordingly the encrypted values in all other positions will be ignored.

Accordingly the encrypted values of E S E S E S and E S must be shifted to the fourth position to perform the multiplication of these encrypted values. To accomplish the shifting the Paillier encrypted ciphertext is exponentiated by 2 which moves the corresponding plaintext value one bit to the left.

For example to move E S to the fourth position and shift the plaintext S by 128 bits it is necessary to exponentiate the ciphertext by 128 1 value. In the second payload to shift E S three positions to the left thus placing E S in the fourth position on the payload the ciphertext is exponentiated to 128 3 to shift it to the left by 3 positions. With respect to E S this is already in the fourth position and does not need to be shifted. Next with respect to E S this is in the second position and needs to be moved to the fourth position and thus needs to be exponentiated with 128 2 in order to shift to the fourth position in the plaintext.

Accordingly the ciphertext product of the encrypted data values that is produced represents a sum of the plaintext associated with a sum of the data values of the ciphertext. As a result in the foregoing example implementation the shifted ciphertext is multiplied to produce a ciphertext for which the underlying plaintext is the sum of S S S S.

At the client the server IDs g X . . . g Xn are further encrypted with key f to generate fg Y . . . fg Ym . The client thus performs a checking operation to determine if there is a match or intersection between gf Xi and fg Yj . Such a match or intersection would indicate that Xi equals Yj.

For the intersections the client multiplies all of the values of E Sj associated with the each of the plurality of single payloads which are the encrypted values of Sj to generate a product which will be the same as the encryption of the sum of the clear values of Sj. The client may request the server to decrypt the product and return the sum. To avoid revealing the sum during the return process the client may perform a blinding operation i.e. multiply the product by E r to return a random number r.

The server then Paillier decrypts and returns the result to the client . To obtain the clear sum the client subtracts random number r from the result sent by the server to the client .

In the foregoing example implementation when the client receives the decryption from the server the client may ignore numbers in the position other than the prescribed position . Thus the client only needs to extract the value of the prescribed position e.g. fourth position in element of . Further because of the 32 guard bits adjacent to each encrypted data value adding to the neighboring encrypted data values does not carry over into other positions.

While the foregoing example implementations refer to packing with 64 bit integers other values may be substituted therefor. For example but not by way of limitation ten 10 numbers could be packed into each of the encrypted payloads which would reduce the bandwidth needed by 1 10. Such an approach may be adopted for example when the largest value is not greater than 1 000 000 e.g. a spend value not greater than one million dollars .

As an alternative to the foregoing example implementation a Damgard version of Paillier encryption may be employed. For example but not by way of limitation ciphertexts that are s 1 s times larger than the payload may be employed. In the case of direct Paillier encryption s has a value of 1 and there is an expansion of 1 1 1 2. On the other hand if s having a value of 3 is used then a 3 1 2 4 3 expansion would result. Thus a 4096 bit e.g. 512 byte ciphertext and a 3072 bit payload results such that 30 numbers can be fit into the payload. Accordingly each encryption has a greater associated cost but fewer encryptions are required due to the larger numbers.

At a server receives the encrypted values f X . . . f Xn and performs an encryption operation on these values. The resulting values encrypted by the server e.g. Paillier encryption are provided to the client as gf X . . . gf Xn . Also at the server encrypts e.g. Paillier encryption and sends g Y . . . g Ym to the client. Further at a plurality of single payloads E S . . . Sn each including a plurality of the values e.g. spend values are generated. The single payloads E S . . . Sn each maintain the most significant bits e.g. upper half as empty and provide the encrypted data values in the lower half. As explained above the encrypted data values are spaced apart by guard bits in each of the payloads E S . . . Sn .

As explained below in greater detail optionally at an operation may be performed at the server on the encrypted data values wherein the encrypted data values E S . . . Sn represent a vector of one or more of the data values at a plurality of positions. According to the operation at least one of multiplying the encrypted payloads E S . . . Sn by an encryption of constant values and multiplying the encrypted payloads E S . . . Sn to shift the positions of the data values that are associated with the vector in the payload may be performed.

At and operations are performed to determine an intersection based on matching between the IDs provided by the client and the server. At the client encrypts g Y . . . g Ym to obtain fg Y . . . fg Ym . Then the client checks for a match between fg Yj and the above explained gf Xi at . Based on operations and an intersection is determined.

At a shifting operation is performed as explained above with respect to . For example but not by way of limitation for the values of E Sj with respect to the above derived intersection the shifting and exponentiation process as described above is performed. Accordingly the encrypted data values as represented by E Sj at the appropriate left shifted position are multiplied for each of the encrypted payloads E S . . . Sn . Thus a product of the encrypted data values in each of the single payloads E S . . . Sn that is associated with a sum of the plaintext values is generated.

Optionally as a part of the multiplying operation of at the client and as noted above the one or more data values of the one of the encrypted payloads E S . . . Sn may be at a first position i in the vector and may be multiplied by the one or more other data values in the one or more of the other encrypted payloads E R . . . Rn that may be at a second position j in the second vector to generate the above noted product that represents the summation of the data values corresponding to the multiplied one or more data values of the one of the encrypted payloads being the encrypted value of Si Rj in the resulted encrypted vector E U . . . Un . Namely a third position k is such that Uk Si Rj in the resulting encrypted vector.

Optionally operations and may be performed. For example but not by way of limitation at operation the client performs an encryption operation on the product by encrypting a random number r to generate an encrypted value of the random number r as E r which is multiplied by the product. A request is sent to the server to decrypt the blinded product. The server thus decrypts the blinded product and returns the blinded sum to the client. At operation the client receives the blind sum and subtracts r to generate the plaintext sum.

Optionally at operation a server receives f X . . . f Xn from for example a client which are encrypted values of client IDs X . . . Xn. The server performs an encryption of f X . . . f Xn to generate and send gf X . . . gf Xn to the client. Further the server generates and encrypts IDs Y . . . Ym and thus sends g Y . . . g Ym to the client.

At operation data values S . . . Sn are placed in a single payload E S . . . Sn and an encryption operation is performed on the data values to generate encrypted data values E S . . . E Sn which are spaced apart by guard bits as explained above. As also explained above the encrypted data values E S . . . E Sn are positioned in the lower half of each of the payloads such that the upper half of the payloads e.g. most significant bits is left empty.

As explained below in greater detail optionally at an operation may be performed at the server on the encrypted data values wherein the encrypted data values E S . . . Sn represent a vector of one or more of the data values at a plurality of positions. According to the operation at least one of multiplying the encrypted payloads E S . . . Sn by an encryption of constant values and multiplying the encrypted payloads E S . . . Sn to shift the positions of the data values that are associated with the vector in the payload may be performed.

At operation the server optionally receives a request to decrypt a blinded product for E Sj . For example the server may receive the blinded request as explained above in . At operation the blinded product is decrypted and provided to the client.

At the client encrypts IDs X . . . Xn as f X . . . f Xn and sends the encrypted values to the server. At the client receives server encrypted values of the client IDs X . . . Xn as gf X . . . gf Xn and encrypted IDs of the server IDs Y . . . Ym as g Y . . . g Ym . Further the client receives a plurality of packed payloads each including E S . . . Sn as a single payload with upper half empty and lower occupied with the data values as explained above with respect to .

At and operations are performed to determine an intersection based on matching between the IDs provided by the client and the server. At the client encrypts g Y . . . g Ym to obtain fg Y . . . fg Ym . Then the client checks for a match between fg Yj and the above explained gf Xi at . Based on operations and an intersection is determined.

At a shifting operation is performed as explained above with respect to . For example but not by way of limitation for the values of E Sj for the plurality of single payloads E S . . . Sn with respect to the above derived intersection the shifting and exponentiation process as described above is performed. Accordingly the encrypted data values as represented by E Sj at the appropriate left shifted position are multiplied. Thus a product of the encrypted data values that is associated with a sum of the plaintext values is generated.

Optionally as a part of the multiplying operation of at the client and as noted above the one or more data values of the one of the encrypted payloads E S . . . Sn may be at a first position i in the vector and may be multiplied by the one or more other data values in the one or more of the other encrypted payloads E R . . . Rn that may be at a second position j in the second vector to generate the above noted product that represents the summation of the data values corresponding to the multiplied one or more data values of the one of the encrypted payloads being the encrypted value of Si Rj in the resulted encrypted vector E U . . . Un . Namely a third position k is such that Uk Si Rj in the resulting encrypted vector.

Optionally operations and may be performed. For example but not by way of limitation at operation the client performs an encryption operation on the product by encrypting a random number r to generate an encrypted value of the random number r as E r which is multiplied by the product. A request is sent to the server to decrypt the blinded product. The server thus decrypts the blinded product and returns the blinded sum to the client. At operation the client receives the blind sum and subtracts r to generate the plaintext sum.

In addition to the foregoing example implementation other example implementations may be provided. For example but not by way of limitation the plurality of the elements in the payload may be a vector as explained below.

Ciphertexts of public key encryption may be large with respect to the plaintext data element which is substantially shorter than the ciphertexts. Further the sum of the plaintexts is substantially shorter than the size of a ciphertext. Accordingly in this alternative example implementation the encryption payload may represent a plurality or a positioned plurality e.g. a vector of element values and may thus save significant space.

According to this alternative example implementation multiplying the encrypted payload adds the payload element in the vector per position and may simplify the adding of a position i at a first vector encryption with position j element where j is different from i at a second vector encryption.

Thus the present example implementation provides a method that allows the homomorphic operation to be performed across the positions. Accordingly the resulting encrypted vector will have at some position k the result e.g. sum of the elements in the original vector position i element of the first encrypted payload ciphertext and the position j element of the second encrypted vector payload.

Accordingly extended flexibility of homomorphic operation may be provided on elements that are encrypted in the same payload so that regardless of positions the operation can be performed on data elements under encryption e.g. ciphertext payload without the need to decrypt the payload and perform such operations on the plaintext elements. The example implementation always maintains the elements as encrypted while allowing flexible operation on the elements e.g. adding vector elements regardless of their position inside the vector .

An example of one or more devices may be computing device described below in . Devices may include but are not limited to a computer e.g. a laptop computing device a mobile device e.g. smartphone or tablet a television a device associated with a vehicle a server computer computing devices storage devices and .

In some implementations devices may be considered user devices e.g. devices used by users to access services and or issue requests such as on a social network . Devices may be devices associated with service providers e.g. used by service providers to provide services and or store data such as webpages text text portions images image portions audios audio segments videos video segments and or information thereabout .

For example a client may perform operations associated with the foregoing example implementations such as above including the unpacking operations of the example implementation using device or on a network supported by one or more devices . A server may perform operations associated with the foregoing example implementations such as above using including the packing operations of the example implementation using device via network .

Computing device in computing environment can include one or more processing units cores or processors memory e.g. RAM ROM and or the like internal storage e.g. magnetic optical solid state storage and or organic and or I O interface any of which can be coupled on a communication mechanism or bus for communicating information or embedded in the computing device .

Computing device can be communicatively coupled to input user interface and output device interface . Either one or both of input user interface and output device interface can be a wired or wireless interface and can be detachable. Input user interface may include any device component sensor or interface physical or virtual that can be used to provide input e.g. buttons touch screen interface keyboard a pointing cursor control microphone camera braille motion sensor optical reader and or the like . Output device interface may include a display television monitor printer speaker braille or the like. In some example implementations input user interface and output device interface can be embedded with or physically coupled to the computing device . In other example implementations other computing devices may function as or provide the functions of input user interface and output device interface for a computing device .

Examples of computing device may include but are not limited to highly mobile devices e.g. smartphones devices in vehicles and other machines devices carried by humans and animals and the like mobile devices e.g. tablets notebooks laptops personal computers portable televisions radios and the like and devices not designed for mobility e.g. desktop computers other computers information kiosks televisions with one or more processors embedded therein and or coupled thereto radios and the like .

Computing device can be communicatively coupled e.g. via I O interface to external storage and network for communicating with any number of networked components devices and systems including one or more computing devices of the same or different configuration. Computing device or any connected computing device can be functioning as providing services of or referred to as a server client thin server general machine special purpose machine or another label.

The I O interface may include wireless communication components not shown that facilitate wireless communication over a voice and or over a data network. The wireless communication components may include an antenna system with one or more antennae a radio system a baseband system or any combination thereof. Radio frequency RF signals may be transmitted and received over the air by the antenna system under the management of the radio system.

I O interface can include but is not limited to wired and or wireless interfaces using any communication or I O protocols or standards e.g. Ethernet 802.11x Universal System Bus WiMax modem a cellular network protocol and the like for communicating information to and or from at least all the connected components devices and network in computing environment . Network can be any network or combination of networks e.g. the Internet local area network wide area network a telephonic network a cellular network satellite network and the like .

Computing device can use and or communicate using computer usable or computer readable media including transitory media and non transitory media. Transitory media include transmission media e.g. metal cables fiber optics signals carrier waves and the like. Non transitory media include magnetic media e.g. disks and tapes optical media e.g. CD ROM digital video disks Blu ray disks solid state media e.g. RAM ROM flash memory solid state storage and other non volatile storage or memory.

Computing device can be used to implement techniques methods applications processes or computer executable instructions in some example computing environments. Computer executable instructions can be retrieved from transitory media and stored on and retrieved from non transitory media. The executable instructions can originate from one or more of any programming scripting and machine languages e.g. C C C Java Visual Basic Python Perl JavaScript and others .

As shown in processor s can execute under any operating system OS not shown in a native or virtual environment. One or more applications can be deployed that include logic unit application programming interface API unit input unit output unit multiple value unpacking engine cryptographic engine third party interface and inter unit communication mechanism for the different units to communicate with each other with the OS and with other applications not shown . For example multiple value unpacking engine cryptographic engine and third party interface may implement one or more processes shown in . The described units and elements can be varied in design function configuration or implementation and are not limited to the descriptions provided.

In some example implementations when information or an execution instruction is received by API unit it may be communicated to one or more other units e.g. logic unit input unit output unit multiple value unpacking engine cryptographic engine and third party interface . For example the multiple value unpacking engine may perform the left shifting e.g. unpacking and multiplication as described above with respect to . The cryptographic engine may encrypt IDs of the client or other values as necessary to perform the operations explained above with respect to . The third party interface may permit a third party such as a user operator or administrator to interface with the computing environment. After input unit has detected a request input unit may use API unit to communicate the request to multiple value unpacking engine . Multiple value unpacking engine may via API unit interact with the cryptographic engine to detect and process the request. Using API unit multiple value unpacking engine may interact with third party interface to permit a third party to view or manage the operations at the client side.

In some instances logic unit may be configured to control the information flow among the units and direct the services provided by API unit input unit output unit multiple value unpacking engine cryptographic engine and third party interface in some example implementations described above. For example the flow of one or more processes or implementations may be controlled by logic unit alone or in conjunction with API unit .

As shown in processor s can execute under any operating system OS not shown in a native or virtual environment. One or more applications can be deployed that include logic unit application programming interface API unit input unit output unit multiple value packing engine server side encryption unit third party interface and inter unit communication mechanism for the different units to communicate with each other with the OS and with other applications not shown . For example multiple value packing engine server side encryption unit and third party interface may implement one or more processes shown in . The described units and elements can be varied in design function configuration or implementation and are not limited to the descriptions provided.

In some example implementations when information or an execution instruction is received by API unit it may be communicated to one or more other units e.g. logic unit input unit output unit multiple value packing engine server side encryption unit and third party interface . For example the multiple value packing engine may perform the generating of each the single payloads and the encrypting of the data values in each of the single payloads e.g. packing as described above with respect to . The server side encryption unit may encrypt IDs of the server or other values as necessary to perform the operations explained above with respect to . The third party interface may permit a third party such as a user operator or administrator to interface with the computing environment from the server side. After input unit has detected a request input unit may use API unit to communicate the request to multiple value packing engine . Multiple value packing engine may via API unit interact with the server side encryption unit to detect and process the request. Using API unit multiple value packing engine may interact with third party interface to permit a third party to view or manage the operations at the server side.

In some instances logic unit may be configured to control the information flow among the units and direct the services provided by API unit input unit output unit multiple value packing engine server side encryption unit and third party interface in some example implementations described above. For example the flow of one or more processes or implementations may be controlled by logic unit alone or in conjunction with API unit .

Any of the software components described herein may take a variety of forms. For example a component may be a stand alone software package or it may be a software package incorporated as a tool in a larger software product. It may be downloadable from a network for example a website as a stand alone product or as an add in package for installation in an existing software application. It may also be available as a client server software application as a web enabled software application and or as a mobile application.

In situations or examples in which the implementations discussed herein collect personal information about users or may make use of personal information the users may be provided with an opportunity to control whether programs or features collect user information e.g. information about a user s social network social actions or activities profession a user s preferences or a user s current location or to control whether and or how to receive content from the content server that may be more relevant to the user. In addition certain data may be treated in one or more ways before it is stored or used so that personally identifiable information is removed.

Although a few example implementations have been shown and described these example implementations are provided to convey the subject matter described herein to people who are familiar with this field. It should be understood that the subject matter described herein may be implemented in various forms without being limited to the described example implementations. The subject matter described herein can be practiced without those specifically defined or described matters or with other or different elements or matters not described. It will be appreciated by those familiar with this field that changes may be made in these example implementations without departing from the subject matter described herein as defined in the appended claims and their equivalents.

