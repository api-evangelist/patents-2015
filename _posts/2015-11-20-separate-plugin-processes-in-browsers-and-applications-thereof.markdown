---

title: Separate plug-in processes in browsers and applications thereof
abstract: Embodiments of the present invention relate to browser plug-ins. In one embodiment, a system browses web content using a plug-in. The system includes at least one renderer process that detects plug-in content in the web content. Separate from the at least one tenderer process, the system also includes a plug-in process that includes the plug-in and communicates with the at least one renderer process to interpret the plug-in content using an inter-process communication channel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507648&OS=09507648&RS=09507648
owner: Google Inc.
number: 09507648
owner_city: Mountain View
owner_country: US
publication_date: 20151120
---
This application is a continuation of U.S. patent application Ser. No. 12 464 203 filed May 12 2009 entitled SEPARATE PLUG IN PROCESSES IN BROWSERS AND APPLICATIONS THEREOF which claims the benefit of U.S. Provisional Application No. 61 052 899 filed May 13 2008 and U.S. Provisional Application No. 61 093 440 filed Sep. 1 2008 the entire contents of each of which are incorporated by reference herein for all purposes.

A browser is a software application that retrieves content and enables a user to interact with that content. In an example a browser may retrieve content across one or more networks such as the Internet. Types of browsers include the INTERNET EXPLORER SAFARI OPERA and FIREFOX browsers. The content may include for example a web page application document text video multimedia content or any combination thereof. While the browser itself may be able to interpret some types of content other types may require use of a specialized plug in.

An application may access a plug in to add features not built into the application itself. As mentioned earlier a browser may access a plug in to interpret content that it could not interpret on its own. For a browser to access the plug in the plug in may implement a specified interface understood by the browser. Examples of plug in interfaces include ActiveX used by the INTERNET EXPLORER browser and Netscape Plug in Application Programming Interface NPAPI used by the SAFARI OPERA and FIREFOX browsers.

While using plug ins can add functionality to a browser using plug ins can also cause stability and security issues. Plug ins are often developed by third parties and may not be subject to the same quality standards as a browser. For this reason a plug in may be more likely to crash than the browser. Yet a crash in plug in may bring down the entire browser. Further plug ins may be delivered in a machine code form that has direct access to system resources. If a plug in includes malicious code using the plug in may cause damage to a computer system.

Systems and methods are needed that enable browsers to access plug ins with increased security and stability.

Embodiments of the present invention relate to browser plug ins. In one embodiment a system browses web content using a plug in. The system includes at least one tenderer process that detects plug in content in the web content. Separate from the at least one renderer process the system also includes a plug in process that includes the plug in and communicates with the at least one renderer process to interpret the plug in content using an inter process communication channel.

In another embodiment a method browses web content on a computing device. The method includes the steps of instantiating on the computing device at least one renderer process that detects plug in content in the web content instantiating on the computing device a plug in process separate from the at least one renderer process that includes the plug in and sending data on an inter process communication channel from the at least one renderer process to the plug in process.

In a third embodiment a computer program product has control logic stored therein and the control logic causes a computer to browse web content using a plug in. The control logic causes the computer to instantiate at least one renderer process that detects plug in content in the web content. The control logic also causes the computer to instantiate a plug in process separate from the at least one renderer process that includes the plug in. Finally the control logic causes the computer to send data on an inter process communication channel from the at least one renderer process to the plug in process.

Further embodiments features and advantages as well as the structure and operation of the various embodiments are described in detail below with reference to accompanying drawings.

The drawing in which an element first appears is typically indicated by the leftmost digit or digits in the corresponding reference number. In the drawings like reference numbers may indicate identical or functionally similar elements.

Embodiments of the present invention relate to a browser with a separate process for plug ins. In the detailed description of embodiments that follows references to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to affect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

The term web content as used herein refers to data that may be interpreted by a browser and plug ins to perform a function. Examples of web content include a web page e.g. HTML application document such as an ADOBE document video multimedia content. Flash file or any combination thereof. Often web content causes a browser to output information to a user. For example a browser may display data or video or make sounds according to the web content. Some web content such as an HTML form accepts input from a user.

The term plug in content as used herein refers to web content that requires a plug in to interpret. For example Flash files commonly require a Flash plug in to interpret and ADOBE documents commonly require an ADOBH READER plug in to interpret.

The term process as used herein includes both a thread and an instance of a program having multiple threads of execution.

Browser process can communicate with one or more web servers not shown over one or more networks such as the Internet to retrieve web content. Browser process can communicate with an input not shown to allow a user to input data to input commands or to provide other control information to browser process .

When browser process retrieves web content browser process may request that renderer process render the web content. Renderer process includes a renderer and a plug in . Renderer and plug in are software modules running in the same renderer process . Some of the web content such as an HTML page may be rendered by renderer . Interpreting other web content referred to herein as plug in content may require plug in . Plug in may be any type of browser plug in including but not limited to a Flash plug in.

As shown in browser system renderer is coupled to plug in via an interface . Since plug ins and browsers frequently have different developers plug in may implement a standardized interface to communicate with renderer . As mentioned earlier plug in may implement a variety of standardized interfaces such as NPAPI or ActiveX.

While running plug ins in the same process as the renderer has benefits this architecture can be unstable. If plug in crashes renderer process including renderer may crash. Effectively at least an entire page may fail to render. In an alternative configuration where all the components of browser system are consolidated into a single process the entire browser system may crash. This issue is compounded by the fact that plug ins are often provided by third parties. Third party plug ins may not have the same quality standards as the rest of the browser and thus may be more likely to crash than the other browser components.

To deal with this instability embodiments split the rendering implementation into two processes. A renderer process includes code for the rendering operations not requiring a plug in and a plug in process includes a plug in and code in support of the plug in. When the plug in process needs to communicate with the renderer process or vice versa function calls may be marshaled and sent over a communication channel between the two processes. This architecture is depicted in .

If the web content includes plug in content renderer process communicates with separate plug in process to interpret the plug in content using plug in . In this architecture plug in crashing may bring down plug in process but renderer process would continue operation. In an example if a Flash plug in fails a Flash file may not render but the remainder of the HTML page may render and operate fine. Thus browser system has greater stability in the face of potentially unstable plug ins. Further browser system may have improved security because any malicious code in plug in is isolated in plug in process .

The processes in browser system communicate with each other using interprocess communication IPC channels. Browser process communicates with renderer process using an IPC channel browser process communicates with plug in process using an IPC channel and renderer process communicates with plug in process using an IPC channel . Each of IPC channels and may be implemented using any type of interprocess communication such as a shared memory socket or named pipe. A named pipe is a form of infer process communication known to those of skill in the art. A named pipe may allow two processes to communicate with each other without introducing additional threads. Furthermore users or other software components may be able to configure a named pipe including imposing security restrictions and controlling overall performance.

Browser system may be implemented on any computing device that can support browsing. Such a computing device may include but is not limited to a computing device having a processor and memory for executing and storing instructions. Such a device may include software firmware and hardware. Software may include one or more applications and an operating system. Hardware can include but is not limited to a processor memory and user interface display. Optional input devices such as a mouse a touch sensitive screen or any future developed interaction method may be used. Example computing devices that can support web browsing include but are not limited to a computer workstation mobile device set top box or cluster of computers.

As mentioned earlier browser process retrieves web content and communicates with renderer process to render the web content. Browser process may maintain browser state information such as session history and cookies. Further browser process also may help control coordination of the other processes and IPC communication channels. Browser process may include a plug in process host that creates a plug in process and manages IPC channels. In an embodiment plug in process host may instantiate renderer process as well for example when a new page is retrieved. Alternatively renderer process and plug in process may be instantiated by other process host modules as would be apparent to those of skill in the art.

For example if renderer process needs to access plug in renderer process sends a request for a handle to an IPC channel to browser process . If plug in process has not been instantiated plug in process host instantiates it. Then plug in process host sends a request to plug in process to open IPC channel . Plug in process sends a handle to IPC channel to plug in process host . Finally plug in process host sends the handle to IPC channel to renderer process via IPC channel . Renderer process may then use the handle to IPC channel to communicate with plug in process which accesses plug in . Establishing a connection to plug in process is described in more detail below with respect to .

As mentioned earlier renderer process renders some types of web content. For example renderer process may render HTML. Renderer process may also execute some types of scripts embedded in the web content. For example renderer process may be able to execute JavaScript and VBScript embedded in the web content. shows multiple instances of renderer process one for each page. Having multiple instances of renderer process is optional however multiple instances may provide additional stability and increase an amount of processing work that can be carried out. With multiple instances if one instance of renderer process fails the other instances may continue operation unaffected. In this way if one page fails to render other pages may continue unaffected.

Renderer process may includes a webpage rendering module a web plug in a web plug in delegate proxy and a web plug in stub . Webpage rendering module may be an application framework that provides some of core functions of browser system . For example webpage rendering module may maintain a data structure representing all or part of the web content displayed to a user on a page. Webpage rendering module may also interpret and render some of the web content. For example webpage rendering module may parse and render HTML and XML. Webpage rendering module also may execute some scripts embedded in the web content such as JavaScript. When webpage rendering module encounters plug in content in the web content webpage rendering module may call web plug in to interpret the plug in. Webpage rendering module can include but is not limited to WebKit available at http webkit.org .

Web plug in may implement an interface known to webpage rendering module . In an example web plug in may inherit from a C object. In another example web plug in may implement a Java interface. Web plug in may abstract access to plug in for webpage rendering module . While access to plug in requires communication to another process web plug in abstracts the inter process communication so that webpage rendering module does not have to be aware of where plug in is located. To communicate with plug in process web plug in accesses web plug in delegate proxy and web plug in stub .

Web plug in stub assists in abstracting plug in . Web plug in stub is used when the plug in process needs to communicate with webpage rendering module . Plug in process in particular a web plug in proxy sends a function call to web plug in stub via IPC channel . Then web plug in stub makes the call to webpage rendering module .

Web plug in delegate proxy is used to communicate with plug in process via IPC channel . If web plug in delegate proxy does not have a handle to IPC channel web plug in delegate proxy may request the handle. As mentioned earlier web plug in delegate proxy may request the handle from plug in process host in browser process via IPC channel . Using the handle web plug in delegate proxy may transform function calls made to web plug in and web plug in stub to an IPC message. Web plug in delegate proxy sends the IPC message over IPC channel to plug in process .

IPC channel may transmit data as a contiguous array of bytes. Each IPC message sent across IPC channel may be set apart with an IPC header. The IPC header may define a message type length of data contained in the message and a routing identifier. The routing identifier may be used to specify a destination for a message within plug in process .

When plug in process receives the IPC message from renderer process plug in process uses data in the IPC message to make a function call to plug in . As shown in there may be multiple plug in processes . Each plug in process executes a different plug in. In an example a renderer process may access a different plug in process to access different FLASH and ADOBE READER plug ins. This configuration may increase stability because a first plug in can continue operation in event of a crash in a second plug in. In the example the ADOBE READER plug in may continue operation even after the FLASH plug in crashes.

In addition to plug in each plug in process includes a plug in instance . In an embodiment plug in process may have multiple plug in instances . If multiple pages and hence multiple renderer processes use the same plug in e.g. YouTube and Google Finance both using Flash then plug in process hosts two plug in instances . Similarly if one page uses a plug in multiple times e.g. two Flash files on the same page multiple plug in instances are used in the same plug in process . This configuration decreases memory consumption. When plug in process receives an IPC message plug in process may use a routing identifier in the IPC message to determine which plug in instance of multiple plug in instances to route the message to.

When plug in instance receives an IPC message plug in instance uses data in the IPC message to make a function call. Each plug in instance includes a web plug in proxy web plug in delegate and web plug in delegate stub . Web plug in delegate stub receives the IPC message and unpacks the data. The web plug in delegate stub identifies a function to call and the function parameters. Then web plug in delegate stub calls web plug in delegate with the function parameters.

Web plug in delegate makes the function call to plug in . When plug in has completed the function call plug in may return a value. The return value may be send back through web plug in delegate stub IPC channel web plug in delegate proxy and web plug in to webpage rendering module .

Plug in may also make a function call to access webpage rendering module . In that case plug in calls web plug in proxy . Web plug in proxy sends the function call to web plug in stub via IPC channel . Web plug in stub calls web plug in . Finally web plug in makes the function call to webpage rendering module . The operation of browser system is described in more detail with examples with respect to .

As mentioned earlier there may be multiple plug in processes one for each plug in. In another embodiment a single plug in process may execute multiple different plug ins. For example a single plug in process may execute both a FLASH and ADOBE READER plug ins. This embodiment may be less stable but it also may be less taxing on system resources as fewer processes need be instantiated.

In the embodiment shown in each plug in process has multiple plug in instances . In an alternative embodiment each plug in instance may be in a separate plug in process. This embodiment may require more system resources as more processes would have to be instantiated.

Also in the embodiment shown in plug in instance is coupled with plug in . While plug in implements a standard plug in interface there may be multiple standards that plug in could implement. For example plug in could implement NPAPI or ActiveX. But plug in instance must be able to understand the interface. For example if plug in instance is developed to understand NPAPI plug ins it may not be able to access plug ins implementing ActiveX. In an embodiment a wrapper object may act as an intermediary between plug in instance and plug in . The wrapper object translates function calls in one standard to another standard. In this way a plug in instance is developed to understand one standard such as NPAPI may be able to access plug ins implementing another standard such as ActiveX .

Each of browser process renderer process and plug in process may be implemented as a software process. As mentioned earlier a process may be either a single sequential thread of execution or an instance of a program having multiple threads of execution.

Each of plug in process host webpage rendering module web plug in web plug in delegate proxy web plug in stub plug in instance web plug in proxy web plug in delegate and web plug in delegate stub may be implemented as a software module.

Method begins when tenderer process detects plug in content in the web content received from browser process . The web content may be entirely plug in content. For example browsers frequently require a plug in to interpret an ADOBE PDF file. An HTTP response received by browser process includes a content type indicating that the web content is an ADOBE PDF file. The content type may be a Multipurpose Internet Mail Extensions MIME type. For an ADOBE PDF file the content type may be application pdf .

In other examples the web content may include plug in content along with content such as an HTML page that can be interpreted and rendered without a plug in. In an example tenderer process may detect plug in content when interpreting and rendering an HTML page. The HTML page may have a tag such as an object or embed tag. The tag may have a value that indicates a content type such as application x shockwave flash . The plug in content may occupy a portion of the HTML page as is commonly the case with a Flash file. Alternatively the plug in content may not occupy any portion of the page as may be the case with an audio file.

Using the content type in an HTTP response or in a value an HTML tag renderer process may recognize that it cannot interpret the file on its own thus detecting plug in content at step . At step renderer process sends an IPC message to browser process requesting an IPC handle for the plug in. An IPC handle may be necessary to communicate with plug in process . As discussed earlier the IPC message may include a header and data. The data in the IPC message requesting the handle may include the content type.

When browser process receives the IPC message requesting the handle browser process may first try to find the plug in at step . At step browser process may determine what plug in is required for a particular content type such as application x shockwave flash . One possibility is that browser process does not have an installed plug in able to interpret the content type. In that event browser process may return an error message to renderer process . Another possibility is that a plug in process for the required plug in has already been instantiated browser process may proceed to step . A final possibility is that the browser has a plug in installed that is able to interpret the content type but a plug in process to execute the plug in has not yet been instantiated. In that case browser process may proceed to step . At step browser process instantiates plug in process .

With plug in process instantiated browser process sends a request to plug in process to open an IPC channel to renderer process at step . The request may be sent in an IPC message. Browser process may send the IPC message across an IPC channel connecting browser process and plug in process such as IPC channel in . A handle to IPC channel may have been determined when plug in process was instantiated at step or when the plug in was found at step . A body of the IPC message may include the request.

In response to the request plug in process may open an IPC channel to connect plug in process and renderer process such as IPC channel in at step . Plug in process sends a handle to IPC channel back to browser process at step . Plug in process may send the handle to browser process in an IPC message across an IPC channel connecting browser process and plug in process .

Browser process receives the handle to IPC channel and sends the handle to renderer process at step . With the IPC handle renderer process creates web plug in delegate proxy at step . Web plug in delegate proxy uses the handle to IPC channel to communicate with plug in process . Then renderer process coordinates with plug in process to create plug in instance at step . Step may include using web plug in delegate proxy to send an IPC message to plug in process .

Finally plug in process creates plug in instance at step . Creating plug in instance may include creating web plug in proxy web plug in delegate and web plug in delegate stub in .

In this way renderer process coordinates with browser process to establish a connection with plug in process . Once the connection is established renderer process communicates with plug in process to execute any functions.

Method may be used for example to execute a function call from webpage rendering module to access a plug in. In examples function calls may be made to repaint a portion of the browser window to scroll in response to user input events such as keyboard and mouse inputs and in response to a resize of a browser window.

Method starts with webpage rendering module in calling web plug in at step . As mentioned earlier web plug in may implement a specified plug in interface so webpage rendering module is unaware of the underlying processing required to access the plug in in a different process. Web plug in calls web plug in delegate proxy at step . At step web plug in delegate proxy sends data to plug in process .

The data may be packaged in an IPC message sent over an IPC channel connecting renderer process and plug in process such as IPC channel in . The IPC message may include an IPC header with a routing identifier.

When plug in process receives the IPC message from renderer process plug in process parses the message to determine the routing identifier. Based on the routing identifier plug in process determines which plug in instance to deliver the message to. In the plug in instance web plug in delegate stub receives and unpacks data from the IPC message at step . From the IPC message the web plug in delegate stub determines which function call was made and any parameters for the function call. At step web plug in delegate makes a function call to plug in .

In response to the function call plug in may return a value. At step web plug in delegate stub may send the return value back to renderer process via an IPC channel such as IPC channel in . In renderer process web plug in delegate proxy receives the return value and possibly forwards it to webpage rendering module at step .

By separating the plug in from other browser operations embodiments improve stability and security of a browser. Stability is improved because a crash in the plug in does not spread to other portions of the browser. Further security is improved because any potential malicious code is isolated from the remainder of the browser.

The Summary and Abstract sections may set forth one or more but not all exemplary embodiments as contemplated by the inventor s and thus are not intended to limit the present invention and the appended claims in any way.

Embodiments of the present invention have been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

