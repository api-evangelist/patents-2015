---

title: Access control framework for information centric networking
abstract: One embodiment provides an access-control framework for publishing and obtaining a collection of encrypted data in encrypted form. During operation, a content consumer can obtain a Manifest object for a data collection, such that the Manifest includes references to a set of encrypted Content Objects of the data collection, and includes one or more Access Control Specifications (ACS) that each specifies a decryption protocol for decrypting one or more Content Objects of the data collection. The consumer can disseminate Interest messages to receive encrypted Content Objects listed in the Manifest over an Information Centric Network (ICN). The client can also obtain, from the Manifest, an ACS associated with a respective encrypted Content Object, and decrypts the respective encrypted Content Object using the decryption protocol specified in the ACS.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09552493&OS=09552493&RS=09552493
owner: PALO ALTO RESEARCH CENTER INCORPORATED
number: 09552493
owner_city: Palo Alto
owner_country: US
publication_date: 20150203
---
This disclosure is generally related to Information Centric Networks. More specifically this disclosure is related to an access control framework for publishing and accessing encrypted data.

Information centric networking architectures ICNs are quickly becoming an attracting alternative to the current host to host design Internet design in both research and industrial communities. Several novel networking architectures have been recently proposed as instances of the ICN. The most common and fundamental features of these ICN architectures include interest based content retrieval content oriented routing and in network caching. Interest based content retrieval and content oriented routing allow users to acquire content from the network via explicit queries for uniquely named content rather than by establishing point to point connection with a target computer that can serve the content. In network caching permits a router to cache content for predetermined lengths of time such that subsequent requests for content of the same name can be satisfied via the cache rather than by forwarding the request upstream to a network endpoint identified by the request.

Due to in network caching ICN content objects may not always arrive from their original producer. However if the cached content was encrypted for a given consumer it is not possible for other consumers to decrypt the content even though they re authorized to access the content. Therefore ICN architectures typically require requests for encrypted content to be forwarded directly to the content producer so that each consumer can receive a copy of the content which has been encrypted using the consumer s public key. Unfortunately requiring ICN nodes to forward requests to the content producer does not allow the consumer and publisher to benefit from in network caching which can result in slow response times for the consumer and undesirably large request loads for the content producer.

One embodiment provides a client of an access control framework that can receive and decrypt a collection of encrypted data based on a publisher s access control specification ACS . During operation the client can obtain a Manifest object for a data collection such that the Manifest includes references to a set of encrypted Content Objects of the data collection and includes one or more Access Control Specifications ACS that each specifies a decryption protocol for decrypting one or more Content Objects of the data collection. The client obtains a respective encrypted Content Object listed in the Manifest over an Information Centric Network ICN . The client also obtains from the Manifest an ACS associated with the respective encrypted Content Object and decrypts the respective encrypted Content Object using the decryption protocol specified in the ACS.

In information centric networks ICN each piece of content is individually named and each piece of data is bound to a unique name that distinguishes the data from any other piece of data such as other versions of the same data or data from other sources. This unique name allows a network device to request the data by disseminating a request or an Interest that indicates the unique name and can obtain the data independent from the data s storage location network location application and means of transportation. Named data network NDN or a content centric network CCN are examples of ICN architecture the following terms describe elements of an NDN or CCN architecture 

A single piece of named data which is bound to a unique name. Content Objects are persistent which means that a Content Object can move around within a computing device or across different computing devices but does not change. If any component of the Content Object changes the entity that made the change creates a new Content Object that includes the updated content and binds the new Content Object to a new unique name.

A name in a CCN is typically location independent and uniquely identifies a Content Object. A data forwarding device can use the name or name prefix to forward a packet toward a network node that generates or stores the Content Object regardless of a network address or physical location for the Content Object. In some embodiments the name may be a hierarchically structured variable length identifier HSVLI . The HSVLI can be divided into several hierarchical components which can be structured in various ways. For example the individual name components parc home ndn and test.txt can be structured in a left oriented prefix major fashion to form the name parc home ndn test.txt. Thus the name parc home ndn can be a parent or prefix of parc home ndn test.txt. Additional components can be used to distinguish between different versions of the content item such as a collaborative document.

In some embodiments the name can include an identifier such as a hash value that is derived from the Content Object s data e.g. a checksum value and or from elements of the Content Object s name. A description of a hash based name is described in U.S. patent application Ser. No. 13 847 814 entitled ORDERED ELEMENT NAMING FOR NAME BASED PACKET FORWARDING by inventor Ignacio Solis filed 20 Mar. 2013 which is hereby incorporated by reference. A name can also be a flat label. Hereinafter name is used to refer to any name for a piece of data in a name data network such as a hierarchical name or name prefix a flat name a fixed length name an arbitrary length name or a label e.g. a Multiprotocol Label Switching MPLS label .

A packet that indicates a request for a piece of data and includes a name or a name prefix for the piece of data. A data consumer can disseminate a request or Interest across an information centric network which CCN NDN routers can propagate toward a storage device e.g. a cache server or a data producer that can provide the requested data to satisfy the request or Interest.

In some embodiments the ICN system can include a content centric networking CCN architecture. However the methods disclosed herein are also applicable to other ICN architectures as well. A description of a CCN architecture is described in U.S. patent application Ser. No. 12 338 175 entitled CONTROLLING THE SPREAD OF INTERESTS AND CONTENT IN A CONTENT CENTRIC NETWORK by inventors Van L. Jacobson and Diana K. Smetters filed 18 Dec. 2008 which is hereby incorporated by reference.

In some embodiments the client can disseminate an Interest for the data collection over ICN and responsive to disseminating the Interest receives the Manifest object over ICN.

In some embodiments the Manifest includes a respective ACS by reference. Also while obtaining the ACS the client can obtain from the Manifest a name prefix associated with the ACS and disseminates over the ICN an Interest whose name includes the name prefix. Then responsive to disseminating the Interest the client receives a Content Object that includes the ACS.

In some embodiments while decrypting the encrypted Content Object the client obtains an encrypted key that corresponds to the encrypted Content Object and obtains a decapsulation key by performing the decryption protocol specified in the ACS. The client then decrypts the encrypted key using the decapsulation key to obtain a decryption key and decrypts the encrypted Content Object using the decryption key.

In some embodiments while obtaining the decapsulation key the client obtains a decapsulation key name which identifies the decapsulation key and follows a keychain until a key node identified by the decapsulation key name is reached. A respective key node of the keychain includes a decryption key in encrypted form and the decryption key is capable of decrypting a decryption key of a next key node of the keychain. The client then obtains the decapsulation key from the identified key node.

In some embodiments the decryption keys are encrypted using a group based encryption scheme and or a broadcast encryption scheme.

One embodiment provides a client device that uses an Access Control Specification ACS to establish a secure end to end communication channel with a publisher. During operation the client can obtain an initiation Manifest object for a data collection. The initiation Manifest includes the ACS that specifies an end to end access control scheme for obtaining and decrypting one or more Content Objects of the data collection. The client obtains a public key of a publisher from the ACS in the initiation Manifest and determines from the ACS an encryption algorithm for a session with the publisher.

The client then disseminates a setup Interest message for the publisher such that the setup Interest message includes a temporary key encrypted using the determined encryption algorithm and the publisher s public key. In response to disseminating the setup Interest message the client receives a setup Content Object that satisfies the setup Interest message such that the setup Content Object includes a session key and a session identifier. The client then disseminates a finish Interest message that includes the session identifier for the publisher and in response receives an in session Manifest that satisfies the finish Interest message. The in session Manifest includes references to one or more Content Objects of the data collection that are encrypted using the session key.

In some embodiments the client obtains verification data from the setup Content Object and verifies the session key using the verification data. Then in response to determining that the session key is valid the client proceeds to disseminate the finish Interest message to establish the secure communication channel.

In some embodiments while verifying the session key the client computes a hash from one or more of the session key a key identifier and an identifier for the determined encryption algorithm. The client than compares the computed hash to the verification data to determine whether the session key is valid.

In some embodiments the client can obtain a respective Content Object listed in the in session Manifest over an Information Centric Network ICN and decrypting the respective Content Object using the session key.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Embodiments of the present invention provide an access control framework that solve the problem of publishing a collection of data over an Information Centric Network ICN or a Content Centric Network CCN in encrypted form. Specifically the access control framework allows publishers to use Manifests to publish their content using encrypted Content Objects and to specify which access control scheme can be used to decrypt and access the content.

For example in some embodiments the Manifest can specify a name to an encrypted decryption key for the content and can specify an access control scheme for obtaining a decapsulation key for the decryption key. Only clients that are allowed access to the content are allowed to obtain the decapsulation key. Alternatively the Manifest can specify an access control scheme that allows the client to obtain the encrypted content and a decryption key directly from the publisher or from a content producer on the publisher s behalf.

Hence the access control framework can be used to publish content of any type using any access control scheme. Rather than requiring each publisher to implement their own form of application specific access control specification and enforcement mechanisms a publisher can use the access control framework to publish encrypted content using their access control scheme of choice.

In the access control framework Manifests include access control specifications and key chains that decouple encrypted content from the access control and decryption information. Moreover key chains can themselves be realized using manifests that contain a list of decryption keys necessary to access content protected under arbitrary group based hierarchies. The keys themselves are based on principals in order to realize fine grained access control schemes where a principal is an individual user or a group of principals. A description of Manifests is described in U.S. patent application Ser. No. 14 337 026 entitled System for Distributing Nameless Objects using Self Certifying Names by inventor Marc E. Mosko filed 21 Jul. 2014 which is hereby incorporated by reference.

In some embodiments the access control framework can realize at least three types of access control schemes over ICN a group based access control scheme a broadcast access control scheme and an end to end secure communication that provides an ICN variation to TLS. Embodiments of the present invention also provide an ICN application programming interface API that producers can use to publish encrypted content and that consumers can use to access the encrypted content.

For example a video streaming service can deploy a content producer that is accessible via CCN . Content producer can include a server computer or a computer cluster that interfaces with edge node . of network . Content producer can generate arbitrary content such as a photo a video sensor collected data etc. Content producer may or may not host content locally but can partner with content publisher to publish its content on behalf of content producer .

Publisher can convert data from content producer to a collection of Content Objects or any form of Named Data object or NDO that carry chunks of the data which are named objects with an associated cryptographic signature. Publisher can publish these NDOs via their name over CCN and forwarders and of CCN can forward NDO requests through network from client to publisher .

Forwarders include at least two primary elements a forwarding information base FIB and a pending interest table PIT . The forwarder can use the FIB to route an incoming Interest message via an output interface toward a content producer or publisher that can satisfy the Interest. In some embodiments the forwarder can populate the FIB using standard routing protocols or static routes and matches an Interest name to a FIB entry using longest prefix match. A routing protocol can asynchronously populate the FIB based on the location of published NDOs.

The forwarder can use the PIT to cache a state of pending Interest messages and an interface from which each Interest message was received. When the forwarder receives a Content Object the forwarder can perform a longest prefix matching lookup operation on the PIT to identify a matching PIT entry and uses the matching PIT entry s interface to return the Content Object along a reverse Interest path back to the client that disseminated the corresponding Interest.

In some embodiments some forwarders can also include a Content Store CS that caches Content Objects. For example forwarder nodes may correspond to edge nodes that provide other computers or networks access to CCN . Hence forwarder nodes may receive Interest messages from client devices and can cache Content Objects on behalf of content producer and or content publisher . When edge nodes receive an Interest they may perform an initial longest matching prefix lookup operation on the CS to search for a matching cached Content Object that can satisfy the Interest. If a matching cached Content Object is not found edge nodes may proceed to forward the Interest over CCN e.g. based on a matching FIB entry . Hence the distributed Content Stores over CCN can reduce Content Object retrieval latency over CCN .

For example content producer can include a media streaming service e.g. the Netflix media streaming service from Netflix Inc. of Los Gatos Calif. that partners with content publisher to disseminate protected content over CCN in encrypted form and allows Content Stores across CCN edge nodes . to cache the encrypted content. Content producer can use the access control framework to retain control over which entities can consume the content by only allowing paid subscribers to decrypt the content. Hence content producer can allow the subscribers of the media streaming service to be able to access the content but does not require them to obtain the content directly from content producer or content publisher .

However content producer may want to prevent unsubscribed users or a malicious entity to gain access to its cached content. In some embodiments content producer can encrypt the content e.g. media stream segments and the content s encryption key prior to returning the content to a client that requested the content. This content and its decryption key can then be cached at Content Stores along a return path to client . Then if another client requests the content this other client can obtain the encrypted content from the Content Store and only subscribed users are able to decrypt the decryption key and the content.

To achieve this content producer provides a Manifest that includes a link to the content s segments and the decryption key to users that are paid subscribers. The Manifest also includes an Access Control Specification ACS that specifies which access control scheme is being used to protect the content such as a variation of a broadcast based encryption a session based encryption a group based encryption or any other encryption protocol now known or later developed. This ACS can specify the encryption decryption algorithm for the collection how to obtain the decryption key for the collection etc. Hence content producer does not need to disseminate an access control scheme for each Content Object in the collection. Rather the Manifest for the collection can specify the necessary information for controlling access to each Content Object or stream segment in the collection.

In a session based encryption scheme for example client can decrypt the content using a personal decryption key for as long as the current session is active with publisher or in some variations for as long as the client device s user is a valid subscriber of content producer . The session based encryption protocol can encrypt content or its decryption key using a symmetric key specific to the user session. When client establishes a session with content publisher e.g. when issuing a request for a piece of content content publisher can return a Manifest that includes a list of media stream segments that are encrypted using the session key or includes a decryption key encrypted using the session key that client can use to decrypt cached media stream segments. Then after using the content s decryption key client can obtain and decrypt the media stream segments of the requested content from any Content Store or server of CCN that hosts the content segments.

In some embodiments the access control framework can support arbitrary types of encryption that are appropriate for different access control policies and retains the efficiency of CCN content retrieval by using in network caches for caching and retrieving encrypted content. For example a key manager not shown can issue a symmetric key for content encryption and can issue a public private key pair for encrypting the symmetric key. When content producer generates content e.g. either on demand or by reading data from persistent storage content producer sends the content to content publisher that encrypts the content chunks using the symmetric key and publishes the encrypted Content Objects over CCN . An access policy manager of content producer can encrypt the symmetric key under a given user s public key and publishes the encrypted symmetric key over the network as well. Any Content Store along CCN can cache the encrypted content or encrypted symmetric key once they are published over CCN .

In some embodiments a user s client device can obtain his public private key pair through a secure channel with content producer . Also client can obtain the encrypted content and symmetric key over CCN e.g. from publisher or a Content Store at a CCN forwarder node by disseminating an Interest over CCN and decrypts the symmetric key if it has a valid key from producer . After decrypting the symmetric key client can use the symmetric key to decrypt the content. While this example consists of multiple entities working in a decentralized manner in some embodiments two or more of these entities could be collocated on a single machine or distributed across different network nodes across CCN .

The access control framework implements cryptographic access control using hybrid encryption to secure data. Specifically Content Objects are encrypted under a cryptographically random symmetric key called the nonce key. The nonce key is then encrypted under another encryption algorithm that is appropriate for the content producer s desired form of access control e.g. broadcast encryption attribute based encryption RSA identity based proxy re encryption etc. . Nonce keys are encrypted for principals which can be individual consumers or groups of individuals.

The individual Content Objects that are listed in the Manifest are encrypted under a nonce key by a predetermined encryption algorithm such as AES 256 CTR. The Manifest comprises a ListOfNames field that includes the names of the encrypted Content Objects and comprises a ListOfHashes field that includes hash values of the encrypted Content Objects. Hence a client that obtains the Manifest can disseminate Interests for groups of encrypted Content Objects sequentially or simultaneously. The ACS field of the Manifest provides the required information to decrypt the encrypted Content Objects such as the name of the encrypted nonce key parameters of encryption algorithms etc.

The access control framework encrypts the nonce key by another predetermined encryption algorithm that is appropriate to realize the content producer s desired access control structure. The key that can decrypt the encrypted nonce key is hereinafter referred to as the decapsulation key. The decapsulation key is itself encrypted such that only authorized principals e.g. principals in possession of or having access to the appropriate private decryption key can decrypt the decapsulation key.

For example the content producer can assign to each principal i a public private key pair PK SK such that individual clients initially have their own principal key pairs. The encryption of SKby a public key cryptographic algorithm under PKis denoted by EncPKC SK PK . Hence when the principal group X is authorized the decapsulation key DKX to X is encrypted as EncX DK PK . A User A can then obtain the decapsulation key DKby retrieving the cyphertexts Enc SK PK and Enc DK PK using only their own private key SK.

In some embodiments the set of principal keys may be part of the private key set or keychain. For example a principal keychain hierarchy may be rooted at a main private key which is used to decrypt the decapsulation key with a path to a qualified leaf principal i. If a principal j is a member of the principal group i then the encrypted private key of principal i may be included in the set of private keys. This enables principal j to use its private key to obtain the private key of principal i which is then used to sequentially decrypt other private keys in the hierarchy all the way to the main private key root. Again this root private key is then used to decrypt the decapsulation key. This separation between the decapsulation and principal keys allows principal keys to be distributed offline or obtained out of band. Furthermore the private key set is flexible enough to enable sophisticated access control group hierarchies for any principal.

CCN Message can include a message header validation data and a CCNMessage field . The message header can include a FixedHeader field and an OptionalHeader field each of which can provide information about the message structures and forwarding information. CCNMessage field provides the message body which includes a name metadata and a payload for both Interest and Content Object messages . Moreover the validation data can include a ValidationAlgorithm field and a ValidationPayload field . ValidationAlgorithm field can include a digital signature validation information e.g. the signature algorithm a validation algorithm CRC32C an RSA signature etc. . ValidationPayload field can include the signature data itself.

CCN Interests and Content Objects are two types of CCN Messages but they are processed in different ways by CCN network nodes. A Content Object is a Named Data Object NDO whose payload field includes published content which can be located and authenticated by its location independent CCN name. An Interest on the other hand is a message issued by a content consumer e.g. a client to request an NDO Content Object. An Interest s name field can include the name of the desired content and payload field can include any additional information relevant to the request. Moreover metadata field of Interest and Content Object messages can contain different data that guides how the Interest or Content Object is processed.

KeyId field and ContentobjectHashRestriction field allow an Interest message to specify restrictions that control how a Content Object is matched to the Interest. For example the KeyId limits the match to a specific publisher by checking the key ID used to sign the Content Object where the KeyID value is stored in the ValidationPayload field of the Content Object. Also the ContentObjectHashRestriction field restricts the valid matching Content Objects to those whose self certified name matches the value of ContentObjectHashRestriction field . In some embodiments the self certified name can include an SHA 256 hash of the CCNMessage field ValidationAlgorithm field and ValidationPayload field.

Additional Metadata fields can include additional information that content producers can use to generate dynamic content. In some embodiments forwarders across CCN do not store data in additional Metadata fields within their local PIT.

A Manifest can include an ACS that specifies the encryption algorithm used to encrypt a piece of content. For example the piece of content can be encrypted using an AES key which can include a nonce key that is randomly generated. The encrypted content can then be distributed over the network and authorized clients can access the encrypted nonce key by using a decryption algorithm specified in the ACS to decrypt the nonce key. Once a client decrypts the nonce key the client can use the nonce key to decrypt the encrypted content.

In some embodiments a Manifest can list a set of Content Objects that are encrypted using a non homogenous set of encryption schemes. The Manifest can include multiple ACS objects such that each ACS can be used to decrypt a different subset of the Manifest s Content Objects. In some embodiments each Content Object entry in the Manifest can specify a reference to an ACS in the Manifest. Alternatively each ACS can identify which Content Objects can be decrypted via the decryption scheme specified in the ACS. For example each ACS can map to a group of Content Objects e.g. identified by a name prefix of the Content Object . As another example each ACS and Content Object entry can include a scheme identifier that binds an ACS decryption scheme and one or more Content Objects together.

As previously mentioned Manifest is defined as a type of Content Object. Hence Metadata of Manifest can include a ContentType field with the value Manifest. Metadata can also include other Content Object metadata fields such as a publish time field a creation time field an expiration time field and an additional metadata section .

Payload of Manifest includes information for a logical collection of Content Objects. In some embodiments payload describes the logical collection by including metadata information on the Content Objects of the collection and including an ordered list for the hash based names of the constituent Content Objects of the collection. This format enables clients to issue Interests with self certifying names for the individual Content Objects listed in payload .

For example payload can include one or more payload sections and each payload section can include a ListOfNames field and a ListOfHashes field that together provide the ordered names of the Content Objects in the collection. ListOfNames field can include CCN names for one or more Content Objects and ListOfHashes field can include Content Object Hash values e.g. self certifying names for the one or more Content Objects.

Payload section can also include an ACS field . If an ACS field exists in ACS field the ACS provides access control information to at least a subset of the Content Objects listed in the same section . The ACS can include information necessary to obtain and decrypt a nonce key and to obtain access to encrypted Content Objects. In some embodiments Payload section can include an ACS object or a reference to the ACS object. For example payload can include an ACS link such as a CCN name to a Content Object that includes the actual ACS object. This allows Manifest to include multiple complex ACS objects without consuming a significant amount of data in payload .

Moreover Manifest can include or reference multiple ACS objects such that each ACS can correspond to a subset of Content Objects listed in Manifest . For example Manifest Payload can include multiple Payload sections e.g. the illustrated asterisk designates that zero or more instances may exist such that each Payload section includes or references an ACS and its corresponding subset of Content Objects. Hence Manifest Metadata can include multiple ListOfNames and multiple ListOfHashes fields one list per ACS.

As an alternative implementation Manifest Metadata can include one ListOfNames section one ListOfHashes section and one ACS section that includes multiple ACS entries. Each ACS in section can have an associated ACS identifier and each name or hash entry of section or section has an associated ACS identifier which specifies which ACS corresponds to the name or hash entry. Thus when fetching a Content Object referenced in ListOfNames the client can use the corresponding ACS identifier to obtain the corresponding ACS listed ACS section .

For example consider a ListOfNames whose first NameEntry section identified by the NameIndex identifier 1 includes 

Hence Manifests can reduce the overhead involved in retrieving fragmented data and can allow a content producer or content consumer to avoid having to individually sign or verify each individual Content Object in a collection. For example a client can use the ListOfNames and ListOfHashes entries to obtain each individual Content Object via an Interest with a self certifying name and can verify the Content Objects it receives by performing a binary equality check between the hash digests computed from the received Content Objects and their corresponding HashEntry sections. The client only needs to perform one cryptographic verification operation for each Manifest to verify the collection of Content Objects listed in the Manifest.

In some embodiments a set of Manifests can be organized into a Manifest tree where the name of a component Content Object within one Manifest is itself the name of another Manifest e.g. a child Manifest . If the content consumer can verify the signature of the root Manifest is and trusts the associated key then the content consumer can also trust other Content Objects and Manifests that are included directly or indirectly in the root Manifest and that are trusted by the nature of their self certifying names e.g. COH values . This lets the content consumer to avoid having to perform cryptographic validation on these referenced Content Objects and Manifests that can be validated by their self certifying names.

AccessControlConfiguration field describes the information necessary to execute the decryption algorithm specified in EncryptionAlgorithm field . Specifically AccessControlConfiguration includes an Access Control field that specifies the type of access control scheme that handles the symmetric key used in EncryptionAlgorithm field . For example when encoded using JSON AccessControl field can include 

Note that if the encapsulationAlgorithm is specified in the AccessControlConfiguration field then the algorithm applies to all nodes in the principal key chain hierarchy. Also if the access control policy does not include performing encapsulation of the nonce key the type can specify another method for performing access control. When the client initiates a decryption operation to decrypt Content Objects the client read AccessControl field to determine which types of cryptographic primitives are required.

AccessControlConfiguration field can also include a NonceKeyName field and a NonceKeyID field that a client can use to generate an Interest for obtaining an encrypted nonce key. NonceKeyName field specifies a CCN name of the encapsulated nonce key. The client can use this CCN name to generate and disseminate an Interest for the decapsulation key s . In some embodiments NonceKeyName field can include aliases which are variables of name components used to represent state dependent names in NonceKeyName field . For example consider the CCN name 

NonceKeyId field specifies the hash value of the non encrypted nonce key. This enables one to easily verify the integrity of the decrypted nonce key. In some embodiments using a proper collision resistant hash function e.g. SHA 256 preserves the integrity and security of the nonce key with collisions occurring with only negligible probability since the digest is included in the Manifest digital signature input that is verified before NonceKeyId field is checked.

Also once the client obtains the encrypted nonce key e.g. using NonceKeyName field the client can read KeychainLink field and DecapsulationKeyLink field which can store a name or hash value for the keychain and for a decapsulation key to follow a chain of encrypted key nodes until the desired nonce key is obtained. KeychainLink field can specify a link to another Manifest or Manifest hierarchy called a key chain. The link can include a Name field that specifies the Manifest s name and can include a KeyIdRestriction field that includes at least the Manifest signer s key identifier e.g. a KeyId to the Content Object of key chain .

The keychain can correspond to an ordered list of principal private keys e.g. encrypted keys necessary to decrypt the decapsulation key for a piece of content. When the keychain is encapsulated in a Manifest hereinafter referred to as a keychain Manifest the client can retrieve the keys of the keychain e.g. in parallel that necessary to decrypt the decapsulation key by parsing the keychain Manifest s name hash lists. The KeychainLink fields in the keychain Manifest can also have aliases to provide a keychain personalized to a given user.

Note that the ACS field of the keychain Manifest can specify the EncryptionAlgorithm field for each of the principal key chain hierarchy nodes when the keychain Manifest does not specify the encapsulationAlgorithm field of the primary Manifest. For example if a keychain contains three keys then the ACS of the keychain has three ordered encapsulationAlgorithm fields in the EncryptionAlgorithm field of the ACS. Alternatively the type of algorithm may be included in the key Content Objects that are returned from the keychain.

DecapsulationKeyLink field can specify a link to the encrypted decapsulation key. For example the link can include a Name field that specifies the encrypted decapsulation key s name and a KeyIdRestriction field that specifies the signer s key ID e.g. a KeyId to the Content Object of the decapsulation key . The encrypted decapsulation key s name can include aliases to assign a decapsulation key personalized to each qualified principal. Note the client may avoid retrieving and traversing the key chain when the client already stores the decapsulation key and successfully validates the decapsulation key.

In some embodiments the client can obtain the first key node in the chain using KeychainLink of ACS and decrypts the first key node using a local decryption key to obtain another KeychainLink and decryption key to a second key node in the chain. The client eventually reaches an encrypted key node identified by DecapsulationKeyLink . This encrypted key node identified by DecapsulationKeyLink is the last node in the keychain and includes a decapsulation key that can be used to decrypt the target nonce key. The client decrypts this last key node in the keychain to obtain the decapsulation key and uses the decapsulation key to decrypt the encrypted nonce key that the client has obtained. Once the client obtains the decrypted nonce key the client can use this nonce key to decrypt all or a subset of the Content Objects listed in the Manifest.

In some embodiments Access Control Configuration can include a set of one or more additional subfields that describe other attributes of any other access control scheme now known or later developed. For example subfields can include additional parameters that can be used to implement a one to one access control scheme similar to TLS e.g. by including a publisher s public key or to implement any other access control scheme now known or later developed.

When the client receives a Content Object that satisfies the Interest the client proceeds to determine whether the Content Object is a Manifest operation . If not the client can store or otherwise use the Content Object operation . However if the Content Object is a Manifest the client analyzes the Manifest to obtain an access control specification ACS from the Manifest operation and obtains secured Content Objects of the data collection according to the ACS operation . The client then decrypts the Content Objects according to the ACS operation and proceeds to store or otherwise use the Content Objects operation .

The client then determines an ACS associated with the Content Object operation and decrypts the Content Object using a decryption protocol specified in the ACS operation . The client then stores or otherwise uses the decrypted Content Object operation . The client then determines whether it needs to obtain another Content Object listed in the Manifest operation and if so returns to operation to select another Content Object name from the Manifest.

The client then obtains a decapsulation key for decrypting the encrypted key by following a keychain specified by the KeychainLink field of the ACS operation . The client then decrypts the encrypted key using the decapsulation key to obtain a decryption key for the Content Object operation and decrypts the encrypted Content Object using the decryption key operation .

Recall that the keychain is a Manifest that provides an ordered list of the private keys required for a user principal . In some embodiments the keychain Manifest has the following values in the fields of its ACS 

For example consider a group Z that is qualified to access Content Objects listed in a Manifest. A user B can gain access the Content Objects by retrieving all the keys leading to group Z. For example user B needs to retrieve the encrypted private keys decryption keys of his keychain ancestors EncPKC SK PK and EncPKC SK PK . User B also needs the encrypted decapsulation key assigned to the principal Z EncPKC DK PK . To retrieve these keys user B first issues Interests for the keychain personalized to his private key SKby using KeychainLink of the ACS AccessControlConfiguration field to generate the Interests. In some embodiments the KeychainLink can include aliases of a user specific authenticator such as a CCN name 

Then after disseminating the Interest user B obtains a ListOfNames field and a List of Hashes field. The ListOfNames field includes the keychain with the ordered key list 

The integrity and secure nature of the listed keys in a keychain can be verified and guaranteed as long as the keychain has a valid signature. Also since a client can obtain the set of decryption keys necessary to decrypt the nonce key based on a ListOfNames filed in the keychain Manifest the client can issue an Interest for multiple keys in parallel which allows the client to maximize its usage of the available network bandwidth.

Recall that there are at least two access control schemes that can be implemented on top of the keychain infrastructure a group based access control scheme and a broadcast access control scheme. In a group based access control scheme where a principal hierarchy exists the encapsulation algorithm of any decapsulation key is not necessarily coupled to the algorithms used to encrypt other keys in the keychain. For example RSA may be used to encrypt all non root nodes in the keychain and a different algorithm may be used to decrypt the root key. This allows different encryption algorithms to be applied at each level in the root to leaf path given in the keychain. The ACS specifies which algorithm applies to each level in the tree so that consumers may apply the appropriate decryption algorithm when traversing the hierarchy path. This decoupling allows any group based access control policy to be imposed over a group based principal hierarchy.

Also note that in some access control schemes without a principal hierarchy such as in flat broadcast based access control a principal s public private key pair is specific to the broadcast encryption algorithm. Hence the nonce key is encrypted under the group public broadcast key and the private key of each qualified principal in the group may be used to decrypt this decapsulation key.

A content publisher can encrypt and publish named Content Objects over the CCN network and can also encrypt encapsulate random nonce keys that are used to encrypt each nonce key. In the group based access control scheme the content publisher allows certain groups of users e.g. principals to access the content simply by generating multiple different cyphertexts of the nonce key encrypted for different principal groups. Then an authorized client in each group can decrypt a cyphertext by traversing a keychain. This means that the qualified principals public keys are directly used to encrypt the nonce key and hence the decapsulation keys are qualified principals private keys.

The published content flows across the CCN network topology from the content publisher to individual consumers by traversing core network and Internet service provider nodes CCN routers and any CCN node may cache content as it flows from the producer to the consumer. The authorized clients are already assigned their public private key pair to be used when traversing the principal hierarchy for key chains. These keys may be distributed offline or over a secure session with the content publisher.

A client can obtain a piece of content by issuing an Interest for a Manifest with the name associated with the content. The Manifest can include a group based ACS that instructs the client on how to obtain the Content Objects that make up the content as well as the nonce key for decrypting the Content Objects. As an example the name of the data collection has the CCN prefix lci parc GE and the encapsulation algorithm of keys is implemented using the RSA encryption algorithm with a 1024 bit key as the encryption. The group based ACS can have the following configuration 

In some embodiments because qualified principals private keys may be the decapsulation keys the DecapsulationKeyLink field can be filled with the names of their cyphertexts by using some appropriate aliases of values that are specific for qualified principals and their members.

Also the EncryptionAlgorithm field of ACS can describe the encryption algorithm used to encrypt the content objects listed in the manifest 

In the broadcast access control the content publisher can qualify a certain set of principals content consumers or clients to access a collection of Content Objects by encrypting the Content Objects under a random nonce key. The content publisher encapsulates the nonce key with a group specific principal specific key using broadcast encryption. Each private key qualified to decrypt the decapsulation key is associated with a qualified principal.

Similar to group based encryption a client can obtain a piece of content by issuing an Interest for a Manifest with the name associated with the content. As an example the Content Objects generated by the content publisher have a name with the CCN prefix lci parc BE and the encapsulation algorithm of the nonce key is implemented using the Naor Pinkas broadcast encryption algorithm. The broadcast based ACS can have the following configuration.

The EncryptionAlgorithm field of ACS can include the description of the encryption algorithm used to encrypt the content objects listed in the Manifest. The AccessControlConfiguration ACC field of the ACS can have the settings 

Recall that in the group based or broadcast access control schemes the publisher encrypts content using a unique and random nonce key. However in these schemes it is assumed that each client has a public private key pair as an individual principal. However if a central key manager is to issue or certify client public private key pairs over the network the central key manager would need to securely send each key pair to each client principal . In some embodiments a client can establish a secure end to end communication session with a target entity e.g. the central key manager or a publisher over CCN similar to a TLS session. This secure end to end session is hereinafter referred to as SecureSession or a SecureSession instance.

During a setup phase that initiates the session the client generates a temporary key for the publisher operation and encrypts the temporary key using the publisher s public key operation . The client then disseminates a setup Interest message for the publisher operation such that the setup Interest message includes the encrypted temporary key that is to be used to share the random session key between the user and publisher.

In response to the setup Interest the publisher generates and returns a Content Object called the setup Content Object that includes a fresh random symmetric session key and session identifier both of which are encrypted by the temporary key provided in the setup Interest. The setup Content Object also includes data the client can use to verify whether the session key is correctly shared between the user and publisher. For example the verification data can include a signature computed over the concatenation of the temporary key and the session key.

The client then receives the setup Content Object operation and obtains the session key and a session identifier for a session with the publisher. The setup phase completes when the client uses the verification data in the Content Object to verify the session key.

After the setup phase the client generates and disseminates a finish Interest message for the publisher operation . The finish Interest message s name includes the CCN name prefix for the publisher and the finish Interest message includes the session identifier appended to the Interest s name or in the Interest s payload section. The publisher responds by returning a finish Content Object to finish establishing the session. The finish Content Object can include a Manifest that is called the in session Manifest which is personalized to the user. The in session Manifest includes an ACS and lists of Content Objects encrypted under the session key. The client receives the finish Content Object that includes the in session Manifest operation . The client can decrypt the encrypted Content Objects using the client s session key similar to a TLS like secure channel that is protected via a symmetric key.

In some embodiments if the publisher requires client authentication after the initial setup phase the client can proceed to a resume phase with the publisher. The client disseminates a resume Interest for the publisher over CCN such that the resume Interest includes the client s public key certificate. Then in response to disseminating the resume Interest the client receives a resume Content Object that includes the authentication response of the client s authentication by the publisher. For example the authentication response can include an ACK message indicating that publisher successfully verified the client s identity or can include a NACK message indicating that the publisher was not successful in verifying the client s identity. The publisher can also use the resume phase to refresh a timed out session by re using the same session identifier and session key.

In some embodiments the client or publisher can use the SecureSession instance to bootstrap other access control schemes such as the group based access control scheme or the broadcast access control scheme.

The following data objects provide examples for the detailed configuration of the Interests and Content Objects used during the instantiation of a SecureSession.

The initiation manifest of SecureSession contains an ACS with information needed to initiate the retrieval of access controlled content as in other the access control instances. Subfields of the AccessControlConfiguration field in the ACS can have the following values 

The EncryptionAlgorithm of the ACS specifies one or more encryption algorithms with parameters that are available at the content publisher unlike nonce key based schemes over the CCN access control framework. The field can be encoded in JSON such as 

After retrieving the initiation Manifest of the SecureSession the client starts the setup phase by issuing the setup Interest over the CCN. The setup Interest has the following values in the response Content Object. In the following examples the notation A.B represents the subfield B of the field A.

The publisher can use the random nonce in the name to distinguish Interests issued from different users and different sessions initiation instances . In response to receiving the setup Interest the publisher issues the setup Content Object that has the following values 

In order to finalize the initiation flow the client first verifies the VerifyData value by calculating the hash 

As the first step of the finish phase the client disseminates the finish Interest that notifies the publisher that the client successfully verified the VerifyData value and requests the finish Content Object e.g. the in session Manifest . The Name field corresponds to 

In the response to receiving the finish Interest the publisher returns the in session Manifest as the finish content object. The in session manifests of SecureSession are the standard manifest that list the names and hash values of Content Objects encrypted under the shared session key. By referring to the in session Manifest the client can securely retrieve content from the publisher through the secure channel protected by the session key.

Here we give a detailed description of the resume Interest and resume Content Object used for user authentication in SecureSession instances. If the HandshakeMessage field of the setup Content Object has the AuthenticationRequest value the client disseminates a resume Interest for the publisher that has the following values 

If the resume Interest does not have a signature we can check the integrity and unforgeability of the client s public key certificate by encrypting it using the session key securely shared with the publisher.

As the response to the resume Interest the publisher issues the resume Content Object that has the HandshakeMessage subfield in the Payload. The HandshakeMessage subfield can include the Completed value or the Rejected value.

In some embodiments a CCN network node can include a CCN network stack that manages the Interest and Content Object messages that flow in and out of the network node. Local applications can create a stack that processes CCN messages in a desired way such as to perform encryption flow control or any other message processing operations on the CCN messages.

In some embodiments transport framework can include a set of stack configuring agents that can dynamically configure a stack on demand. For example transport framework can include a set of transport API components that implement functions accessible via a library and or an API. An application can access an API implemented by transport framework by issuing a call to transport framework . Transport framework then maps the API call to a corresponding API component of components that implements this specific function and forwards the API call to this API component.

If a stack doesn t exist for processing the API call the API component can configure or instantiates a custom stack that can perform the application s API call. For example the API component can issue a request to transport framework with a request describing the functionality of the custom stack. This functionality description can be high level such as to specify a pre defined behavior or operation that is to be performed on data packets. Transport framework then realizes this behavior or operation by organizing the necessary components into a custom stack e.g. in custom stack components in an order that achieves the desired behavior or operation.

Alternatively the functionality description can be low level such as to specify the specific stack components that are to be used and can specify an order in which the stack components are to be arranged. Moreover the functionality description can also be specific or generic with respect to the individual components for example to request a specific security component e.g. a PKI verification component or to request any verification component. 

In some embodiments transport API components can include a Portal API which provides a set of functions for writing and reading both Interests and Content Objects to and from a stack. Structurally Interest messages e.g. CCNxInterest and Content Object messages e.g. CCNxContentObject have a similar data structure. Hence in some embodiments the Portal API wraps CCNxInterest and CCNxContentObject instances in CCNxMessage containers which are then used in various Portal API functions such as ccnxPortal Read CCNxMessage msg and ccnxPortal Write CCNxMessage msg to read or write messages from and to the transport stack respectively. Along with the ability to listen for Interests with a particular name prefix these functions provide the functionality for publishing and retrieving Content Objects via Interest messages.

In some embodiments transport API components also include an Access Control API built on top of the Portal API and includes a ProtectedPortal API. The Access Control API allows consumers to access protected content and allows publishers to publish and control access to specific content. Consumers and publishers interface directly with the ProtectedPortal API to create a protected transport stack e.g. stack that transparently handles all access control related functionality.

The ProtectedPortal API is instantiated by both consumer and publisher applications with a given set of identities. For a consumer an identity may wrap a PKCS 12 certificate and private key bundle so as to be able to decrypt Content Object payloads if necessary. Similarly a publisher can use a PKCS 12 bundle to sign an egress Content Object generated in response to receiving an Interest message. Other cryptographic keys such as those used in broadcast access control or proxy re encryption schemes may be contained within PKCS 12 files as well. Since a user may manage these keys via separate files the ProtectedPortal accepts sets of identities at instantiation and at runtime.

The consumer portion of the ProtectedPortal API extends the underlying Portal API with the functions listed in Table 1. The ProtectedPortal uses information returned in a Content Object Manifest to obtain the appropriate decryption keys to decrypt the nonce key with the correct cryptographic algorithms. Once the ProtectedPortal retrieves the decryption keys the ProtectedPortal then uses the nonce key to decrypt the content payload for the consumer. The ProtectedPortal performs iterative decryption key resolution and content decryption processes e.g. SecureSession internally and does not expose these processes to the consumer to allow software developers to easily integrate these features into their applications.

In some embodiments transport API components can include a publisher API that can communicate with and or control various components of an access control system such as a distribution server a Content Store or a repository an encryption server an access policy manager and a metering server. After instantiating a transport stack for each component a proxy for each component is instantiated at the top of stack in order to control their respective systems. For example a key manager proxy component is instantiated at the top of a key manager transport stack and may communicate with a local key manager application on the local operating system or a remote application via CCN Messages e.g. by disseminating a CCN Interest to query the key manager and receiving a Content Object as a response from the key manager . The publisher API implements this communication on behalf of the publisher and abstracts this communication mechanism away from the publisher APIs.

The functions available via the publisher API are listed in Table 2. The publisher API is accessible via any entity of the access control system such as the distribution server a Content Store or a repository encryption server access policy manager and or metering server. Once instantiated a publisher ProtectedPortal instance exposes handles to each of these entities of the access control system so that the application may dynamically create content change access policies and permissions and serve protected content and Manifests for consumers. Additionally after the publisher API is instantiated each entity creates a transport stack e.g. stack for a specified namespace so that the consumer ProtectedPortal may issue Interests to communicate with other entities of the access control system. For example the CCNxAccessControlManagerProxy stack component can listen on the lci parc csl acm namespace and consumers requesting content decryption keys can issue Interests with a name derived from the name template lci parc csl acmkcontent name to obtain keys necessary to decrypt the nonce key. Also for session based access control the publisher ProtectedPortal stack component can handle the creation and maintenance of DTLS session information on behalf of its local entity.

In some embodiments communication module can obtain a Manifest for a collection of data and can obtain a set of encrypted Content Objects listed in the Manifest. Manifest processing module can parse the Manifest to obtain an Access Control Specification ACS associated with an encrypted Content Object. Access control module can process the ACS to obtain the appropriate decryption key for decrypting the Content Object. Security module can decrypt the Content Object using the decryption key.

Access control system can include instructions which when executed by computer system can cause computer system to perform methods and or processes described in this disclosure. Specifically access control system may include instructions for obtaining a Manifest for a collection of data and can obtain a set of encrypted Content Objects listed in the Manifest communication module . Further access control system can include instructions for parsing the Manifest to obtain an Access Control Specification ACS associated with an encrypted Content Object Manifest processing module .

Access control system can also include instructions for processing the ACS to obtain the appropriate decryption key for decrypting the Content Object access control module and can also include instructions for decrypting the Content Object using the decryption key security module .

Data can include any data that is required as input or that is generated as output by the methods and or processes described in this disclosure. Specifically data can store at least a Manifest an ACS from the Manifest and security information and or session information associated with a publisher.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described above can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

