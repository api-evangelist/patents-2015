---

title: Universal and adaptive software development platform for data-driven applications
abstract: A software application platform that abstracts a computing platform, a database layer, and a rendering medium is disclosed. A platform-independent application programming interface is disclosed, as well as an abstract database layer. The abstraction of the database layer comprises two sub-layers, including a layer having a uniform interface that treats data records as plain objects and a layer having constructs that facilitate the automated generation of user interfaces for data record navigation and management. Further, a software application platform that is independent of rendering medium is disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483257&OS=09483257&RS=09483257
owner: 
number: 09483257
owner_city: 
owner_country: 
publication_date: 20150519
---
Traditionally when applications are developed a developer first makes a decision as to what kind of platform to use e.g. Windows Linux . Decisions also have to be made about whether an application will be web based or desktop based whether it will run in a server client environment or as standalone application and what kind of database system the application will utilize. Once the relevant decisions are made the development commences. shows this process conceptually. Problems arise when requirements change over time and when suddenly a desktop application has to be turned into a web application. Problems also arise if a developer is required to move to a different database system. Frequently such changes require major restructuring and involve significant costs.

It is possible to develop applications that can run across operating system platforms. It is also possible to develop applications that abstract the communication with an underlying database system and are thus portable across database platforms. Applications that are capable of abstracting different presentation media are rare if not nonexistent. Abstracting presentation media means separating software development to a maximum degree from the medium on which it will be used whether it is a computer desktop a web browser or a mobile device. This type of abstraction is challenging in particular because by nature these applications behave differently. For instance a web application is inherently stateless. In order to provide a presentation medium abstraction layer these differences have to be taken into account and reconciled.

As shown in an inventive application platform that abstracts the computing platform the database layer and the rendering medium is disclosed. Typically application developers strive for independence across one or two of these aspects but not all three. Achieving independence across all three is not a trivial task. In the instant application platform costly choices in these three areas do not have to be made in advance of the development process. Instead software development is treated as a black box. As shown in the instant application platform has an application programming interface API which is consistent and identical on every platform making it platform independent. As shown in FIG. the application platform also abstracts away particulars of the data access layer to provide persistence independence. The abstraction of the database layer includes two sub layers. In the bottom layer database independence is achieved and a uniform interface is exposed that treats data records e.g. table rows as plain objects. In the upper data layer are constructs that facilitate automated generation of user interfaces for record navigation and management. The resulting system provides the immediate ability to manage database records programmatically as well as on the user side without the need to re implement the basic management tasks over and over again. Further as shown in the platform is not dependent on the rendering medium. This platform distinguishes itself the most in its abstraction of the rendering medium or presentation layer. It allows a developer to create an application once and make it available in several presentation forms such as the desktop the web or mobile devices with very little added effort. This application platform enables a developer to create several different application types in the same manner. For instance application types may include web applications rich client desktop application thin client desktop application mobile application games and server side services without any user interface.

While each aspect of the instant application platform is itself unique as shown in the combination of the independent aspects of the instant platform makes for a powerful application that achieves universality across various previously known computing environment restrictions.

One embodiment of the invention is a method of developing a software application configured to run on a computing device in an adaptive fashion and independent of operating system database system and presentation medium comprising the steps of using an operating system independent computer programming language to create a software application comprised of one or more modules using a persistence layer in the application configured to abstract access to a database residing on a physical storage medium wherein the persistence layer is capable of abstracting access to data records adaptively at runtime without hardcoding specific information about each record type using a record management layer in the application configured to enable collection and manipulation of data record information in the persistence layer through both an application programming interface and one or more user interfaces and capable of providing management functionality adaptively at runtime for a given record type using an adaptive presentation layer in the application capable of generating a plurality of views from a single set of data models that are capable of display on a plurality of presentation media and wherein the presentation layer is capable of auto generating views at runtime based on the structure of the data models such that the views reflect changes in the database and releasing the software application for use on one or more computing devices. The embodiment may further comprise one or more of the persistence layer being capable of adjusting itself to structural changes of data residing in the database the record management layer being capable of adjusting to changes in the persistence layer and storage medium the persistence layer being configured to access a plurality of database protocols the persistence layer being configured to access two or more databases simultaneously and the software application comprising a main application module a kernel module a storage module and any custom added modules.

Another embodiment is a persistence layer system for providing a computer software application uniform and dynamic access to a physical storage medium comprising a connection object configured to communicate data records between a file system or database residing on the storage medium and the application program residing in transient computer memory wherein the connection object includes functions to load find save create and synchronize record objects with corresponding entries in the storage medium and functions to initiate and end storage sessions and ensure exclusive access to storage medium resources wherein further the connection object initiates transactions with and communicates commands to the storage medium a connection definition object configured to use the connection object to read meta record information from the file system or database wherein the meta record information includes record type and record structure a plurality of record objects wherein each record object includes connection object origination information a meta record object containing information describing the record object structure record field values and functions to get and set field values field names field attributes and a record state that indicates a stage of a record life cycle wherein the connection definition object includes functions to retrieve information relevant to creating meta records dynamically wherein each meta record object corresponds to an object in the storage medium and includes one or more of field names and field types a plurality of entity objects wherein each entity object is configured to enforce data coherence rules over a set of related record objects and data fields wherein each entity object includes a meta entity object containing information describing the entity object structure and containing at least one meta record object wherein each entity object includes one or more default field values wherein each entity object is configured at runtime to accept instructions to modify one or more data fields consistent with the data coherence rules wherein each entity object provides a plugin mechanism to allow changes to be performed before and after life cycle events and wherein each entity object is configured at runtime to validate data field values.

The persistence layer system may further comprise the file system or database being a relational database the connection definition object including functions to retrieve table names table columns column types schemas primary and foreign keys that are relevant to creating record objects dynamically from relational databases and each meta record object including one or more of foreign keys and primary keys.

The persistence layer system may further comprise a plurality of connection objects each configured to communicate data records between a file system or database residing on the storage medium and the application program residing in transient computer memory wherein the system is configured to allow the transfer of data records between each connection object and its associated database.

Additionally the persistence layer system may further comprise one or more of each meta record object corresponding to a table in a relational database each meta record object corresponding to a file in a file system each meta record object being manually constructed each meta record object being created from an annotated class and a native or emulated reflection process and each meta record object being created dynamically at runtime from the connection definition object which in turn allows Record and Entity objects to be created dynamically at runtime.

Another embodiment is a record management system for managing information in a computer software application running on a computing device comprising a persistence layer capable of providing the computer software application uniform and dynamic access to a database residing on a physical storage medium a detail object configured at runtime to coordinate and manipulate a set of fields within an entity object wherein the detail object also allows custom operations to be infused and executed on the entity object a directory object configured at runtime to coordinate and manipulate a set of entity objects wherein the directory object includes a a connection with the persistence layer b a detail object c a filter manager and at least one filter configured to extract a subset of entity objects to be displayed d a parameter set with no or multiple parameters wherein parameters capture field names and values by which to search wherein the values are infused into the filter as conditions e a keeper object configured to generate one or more data models and one or more data views and which is used for generating views and models at runtime f a navigation model object configured to control the means for browsing through the set of available entity objects g a table entity face object configured at runtime by the filter object to store a page of the set of entity objects and h a lookup manager configured at runtime to manage a plurality of lookup objects wherein lookup objects are used to replace field values containing references with interpretable values wherein multiple directory objects can be assigned a single detail view by one or more owner relationship objects which indicate the fields by which entity objects are related a directory view object associated with the directory object configured to construct itself at runtime based upon the set of entity objects and further comprising a plurality of sub view objects wherein the directory view and subviews are capable of reflecting any changes in the underlying directory objects and field definitions in the database wherein the directory view generates a subview for each object included in the directory including but not limited to a parameter view a filter manager view a parameter set view a navigation view and a table view object wherein each subview is associated with the correspondingly named object from the directory object and wherein the subviews are generated at runtime using the keeper object wherein the directory view object and its subviews are configured to receive input signals from a user to modify one or more of the parameters in the parameter set at least one filter the set of entity objects the page and the table entity face object and to relay the signals to the directory object or relevant sub object and wherein the directory view object is further configured to create a detail view object in response to a signal from a user interface object wherein the detail view object is associated with the detail object.

The record management system may further comprise the table view including a plugin mechanism for rendering rows and cells. Further the record management system may further comprise a row renderer object configured to display table rows in a customized fashion and a cell renderer object configured to display table cells in a customized fashion wherein the cell renderer objects can be infused into the directory view for a specific cell for a specific field name or for a field type.

Another embodiment is a presentation layer system for providing a computer software application independent of presentation medium and capable of auto generating user interfaces for record management tasks and application tasks in general comprising a dynamic record management system one or more model objects implementing a model interface an abstract interface for a model that allows multiple views to bind and allows the views to explore its structure and presentation needs wherein the same set of models are associated with views on different presentation mediums one or more view objects each implementing a view interface wherein each view object interface is capable of being bound to a model object by a listener object that listens for messages originating from the model object wherein all views bound to the model object are notified of a change in the model object and subsequently update themselves wherein each view keeps a reference to each model object to which it is bound wherein each model keeps references to each view that is subscribed or bound to it wherein the model object interface of each model object is capable of being bound to multiple view objects wherein on receiving a user input signal the view relays information and commands to the model and updates itself if it is notified by the model of any resulting changes a rendering module configured to invoke the drawing of user interface objects on a specific presentation medium wherein each presentation medium shares the same set of underlying models and wherein the rendering module is configured to generate dynamically at runtime a plurality of medium and model specific user interface objects for the computer software application using the model interface to explore its structure and its view placement so as to reflect any changes in the models and in the underlying database structure and using a facility to request and construct views. This presentation layer system may further comprise the facility to request and construct views being a view keeper wherein the view keeper is capable of generating a view object when given a model and is capable of caching previously generated views and wherein the view keeper binds the view object to one model.

The application platform infrastructure and its associated objects and modules operate within a runtime environment within a computing device such as without limitation a server desktop computer laptop computer tablet computer mobile phone or other device. The computing device may be in electronic communication with one or more physical storage media such as without limitation a disc drive flash memory or other storage medium wherein one or more databases may reside as well as a transient medium or memory. The computing device may also be in electronic communication with a rendering medium such as without limitation a screen or monitor on which may be displayed a web browser window or dedicated visual interface.

As shown in each module including the application object as the top most module goes through a life cycle. The stages of the life cycle include initialization execution and termination .

During the initialization of the application it is common to load one or more modules such as the kernel. The order of the application initialization can be easily encoded as a configuration file. The loading process includes following steps 

During regular execution a module will act as a message loop processing messages dispatched in its queue by delivering them to the correct message listener objects or targets known as MessageListener objects. The message loop can run in own thread but does not have to. The message dispatching is able to differentiate these two cases and properly deliver messages across threads.

Finally the termination process reverses all the steps of the initialization process by broadcasting the termination event retracting any services that the module has published and finally cleaning up its own resources.

The module object is aware of the installation process. The application makes use of a repository of available or installed modules when instantiating new modules. The repository is usually statically determined by developer but it could also be dynamically managed by the application. In the dynamic setting the application would allow the user to install and remove modules from the application. For this case each module has entry points at which it can gain control of the installation process and effect changes to prepare the system including persistence layer for its proper functioning.

Independence from the runtime platform is achieved by two means. First the application platform represents a concise architecture with a corresponding application programming interface API . The adherence to the API contract guarantees compatibility with the framework and desired results from the underlying platform. Secondly the default implementation of the API is written in the Java language however implementations in other platform independent languages such as C and C can be constructed.

As shown in independence from the database or persistence layer is maintained by a storage module . The storage module manages several database connections which might or might not be implementing SQL language protocol. Each Connection object allows the application to work with plain data objects that are then properly serialized and de serialized from the persistence layer. The plain data objects must conform to the Record interface API. If they do so then the Connection is capable of managing their life cycle. The connection will optimize its operation by caching Record descriptions and frequently used queries. From a Connection object the application can also obtain meta information about the types and descriptions of allowed Records.

The system includes a framework to facilitate uniform access to data regardless of the database type. By database or database system is meant anything that can store data particularly in binary form. Relational database management systems RDBMS all claim to support the SQL language but that support is frequently violated in order to provide proprietary enhancements. The problem is that the same enhancements are present in many RDBMS but accessed differently. The end result technologically locks in developers and users complicating their freedom to migrate to alternatives. The framework liberates the developer from choosing a database platform. On one side the framework connects to a RDBMS and on the other it exposes tables and table records in a dynamic and uniform fashion. All table records are represented by plain objects in the programming language of choice. The developer can then work with these objects without regard to the particular database platform. SQL RDBMS is an exemplary embodiment here however but it might not be the only way to organize databases and the framework is configurable to work with other database protocols.

Frameworks that allow plain data objects to be used instead of directly dealing with the database exist already. The framework disclosed here has similar functionality but has been developed with performance in mind. This framework includes some unique features that differentiate it from existing approaches. Above all else this framework hides the intricacies of the underlying persistence layer. Furthermore the framework provides an SQL based implementation but the entire API is defined independently of the protocol language which makes it possible to implement support for other types of persistence layers and database protocols. At the core of the proposed framework is an interface or programming construct that describes a record.

A Record is an object comprising of a collection of fields that belong together. In the example of a relational database a Record would correspond to a row in a table. The record interface in the framework includes 

As shown in the record status reflects the record life cycle and can take on the following values NEW USED DELETED INVALID or COMPUTED. The record initially assumes the NEW state after conception but before it is persisted. If a record is persisted it assumes the USED state. Once a record needs to be removed from persistence it assumes the DELETED state. Sometimes and before the record is properly initialized it might be in an INVALID state and sometimes if it is used for non persistent transient purposes it might be in the COMPUTED state.

A unified modeling language UML diagram of the Record interface is shown in . PlainRecord and AnnotatedRecord are two implementations of the Record interface where PlainRecord is a plain record object and AnnotatedRecord is an annotated record object. The AnnotatedRecord inherits the PlainRecord . All Record implementations typically carry the values of the fields. Meta information such as field names field types field count record name and so on are stored in a special header object which is referred to as MetaRecord further described below.

The PlainRecord contains an array of objects that store the field values an array of field states the record status denoted by an integer and a plain meta record object or PlainMetaRecord which contains meta information about the fields. Methods from the Record interface that deal with field names field types field attributes the record name or any other field meta information utilize the PlainMetaRecord . Methods which modify and retrieve field values use the object array included in the PlainRecord object. The PlainRecord is very flexible and for that reason forms the basis for more convenient extensions.

The AnnotatedRecord inherits the PlainRecord . The AnnotatedRecord utilizes an annotated meta record object or AnnotatedMetaRecord rather than a PlainMetaRecord . The main difference in an annotated record has to do with how values are modified and retrieved. The AnnotatedRecord does not have its own functions to set and get field values rather it requests methods to get and set field values from the AnnotatedMetaRecord . These methods are retrieved as objects from the AnnotatedMetaRecord and executed subsequently.

The PlainRecord is manually constructed based on descriptions of the underlying database tables. The AnnotatedRecord is automatically created from the specified plain data object using reflection facilities of the programming language.

A meta record object or MetaRecord contains information about a record and the fields themselves. This includes databases related information such as table names as well as field names and field types. At the most basic level a MetaRecord in the framework is an interface which inherits the Record interface . It also provides a function to retrieve a MetaRecord signature. A signature in the framework corresponds to its address in the used namespace.

A PlainRecordField is a plain record field object containing information about a specific field such as class type default value field attributes field name and methods to set and get the field information.

An alternative implementation of the MetaRecord is an SQL meta record or SQLMetaRecord designed specifically for SQL based database interactions. The SQLMetaRecord inherits the PlainMetaRecord . In addition it provides information about whether a record is quoted catalog name schema name and the canonical name. The SQLMetaRecord stores each field value as a SQL record field or SQLRecordField . The SQLRecordField inherits the PlainRecordField . The SQLRecordField additionally provides information about the table name field length and regular expression patterns used for a given field.

An AnnotatedMetaRecord inherits the SQLMetaRecord . Each field value in the AnnotatedMetaRecord is a reflected record field type or ReflectedRecordField . The AnnotatedMetaRecord in its initialization is capable of extracting field information from an existing class via language reflection. For example if a table in the database described cars a developer can create an object class that mirrors the types in the car table and provides setter and getter methods. By passing this car class to the AnnotatedMetaRecord the developer can generate the needed field descriptions. In addition the AnnotatedMetaRecord stores the setter and getter methods as objects. This is accomplished by using reflectance property of the underlying programming language.

Information such as schema name can be encoded in the provided object class using annotations. Annotations are programming language constructs that describe or comment the code rather than producing executable instructions. An exemplary annotation describing the table name and schema name might look as follows Table name Car schema dbo 

The ReflectedRecordField object which is used to store individual field values in the AnnotatedMetaRecord inherits the SQLRecordField . Additionally it contains the setter and getter methods for a given field. These setter and getter methods are extracted from the annotated class and are stored as objects.

Records and MetaRecords provide a means of representing data. However they live in transient computer memory and are not directly stored on a storage medium or within a database. A connection is an object responsible for synchronizing Record instances with a persistence layer. A Connection in the framework is an interface that contains the following 

A Connection abstracts away the underlying database system that is being used. An exemplary embodiment of a connection object in the framework is an SQL connection object or SQLConnection object. In addition to implementing all of the required functionality from the Connection Interface to deal with a SQL based database connection the SQLConnection object provides 

During regular use the Connection object is responsible for caching known Record types and special frequently used queries to speed up Record synchronization with the persistence layer. The management of the Record types is what allows the framework to manage several Connections to different databases at the same time and to provide one place for all database access irrespective of which database is managing what Record.

A ConnectionDef is a connection definition object that contains information specific to a database that is needed by the Connection to perform its operations. In the case of the exemplary embodiment of an SQL based connection definition object the SQLConnectionDef provides 

The ability of the ConnectionDef to generate a MetaRecord based on existing tables in the database is important because it allows the framework ultimately to generate Record objects dynamically based on the underlying database structure.

There are at least three methods to retrieve and use records. In the simplest case a developer manually creates a PlainMetaRecord that describes corresponding records in the database. Subsequently the framework would use the Connection object to operate with these records creating deleting modifying and so on.

Alternatively a developer can create an object which inherits the AnnotatedRecord and mirrors the fields in a database table. For instance as with a previous example such an object could be called Car mirroring a table describing cars. Annotations in this object would specify the table and schema name. The AnnotatedMetaRecord object would be used to extract fields and methods from the Car class and generate field descriptions. Subsequently a developer would use the Car class directly to manipulate Car entries in the database. This is possible because the Car class was derived from the AnnotatedRecord. The advantage here is that the developer does not have to deal with a generic Record class but rather with a custom created class. A potential disadvantage is that an annotated class would have to be created for every database table.

A third method is the dynamic retrieval and use of records. In this method the developer only has to specify the table name and request a MetaRecord from the ConnectionDef object. One advantage of this approach is that the Record objects are generated dynamically. Unlike the above described approaches if underlying fields change in the database those changes cause the ConnectionDef object to produce updated MetaRecords to reflect the underlying the change. Another advantage is the fact very little work is required to start using data base records. This is especially important in cases with large collections of tables.

A diagram of the described database abstraction framework is shown in that is capable of supporting all of the above described approaches for retrieving and using records. This framework distinguishes itself from prior art systems and frameworks which are much more elaborate supporting complex caching schemes or mirror object relationships based on relationships in the database. The overhead of these approaches is too large especially when dealing with large scale databases. In most prior art approaches annotated classes are used to specify persistent objects. Even though tools exist to generate these annotated classes automatically when database changes start happening these classes become difficult to maintain. Because of the complexity of these systems it can be difficult to debug them when mistakes are made in annotations.

The described framework is very lightweight so it can be applied to large scale databases without any worries about the size of its footprint. Rather than concentrating on extracting complex object relationships from the database the described framework has been designed with scalability in mind. Unlike most existing approaches the described framework is capable of dealing with Records in a dynamic fashion with no annotations necessary.

At the software application level data needs to be accessed created modified deleted and otherwise managed in bundles of information parts or fields that belong together. This logical collection of fields is frequently referred to as an entity. Unfortunately all data belonging to an entity might not always be stored within the same Record. For example in an SQL database an entity might be distributed over multiple tables. If during entity management the framework does not take this into account the framework might produce data inconsistencies e.g. removing a row from one table but not another . The entity design abstracts and encapsulates both the record data and the functionality to manipulate them.

The Entity combines access to the records as well as functions to manipulate the records. It can be understood as an additional layer of abstraction on top of the architecture discussed in the previous section. A UML diagram of the Entity class and its related classes is shown in .

A MetaEntity inherits the Entity class . The records in a MetaEntity are MetaRecords corresponding to the Records used by the underlying Entity object . The MetaEntity object contains 

The MetaEntity carries a signaling facility to notify any interested listeners when something happens to the state of any Entity instance. Additionally the MetaEntity will host operators via the EntityAdjuster object that are invoked during the lifecycle of an Entity instance to populate or modify field content just before or after an event like removal or modification.

The EntityAdjuster is an interface which has a function to adjust a record given the entity and the occurrence of an event. Events are specified by before and prior to changes in the state of the entity. For example an EntityAdjuster can concatenate two fields prior to saving the entity .

An OwnerRelation is an object linking two entities into a parent child relationship. It is created by specifying a parent MetaEntity and a child MetaEntity along with the two fields by which they are linked. The OwnerRelaton also contains information about the type of join that is desired between the two Entities in the case of a SQL based connection . The OwnerRelation can be used to link Entities if the need arises.

Entities and MetaEntities rely on Records and MetaRecords and provide an additional abstraction layer. The added abstraction layer has several advantages. It allows logical entities to be comprised of one or more objects. It abstracts away functionality from the underlying connection. As a result a developer does not have use the Connection Object directly. This makes development efforts easier.

Just like Records and MetaRecords can be generated dynamically from the database by using a ConnectionDef one can similarly construct MetaEntities and Entities in a dynamic fashion by simply providing the name s of the underlying table s .

The database layer framework can be used on any computer processing device including without limitation laptops workstations servers and mobile devices. The framework can be implemented in Java C or any language that supports reflectance and the framework can be used with any underlying relational database. It can also be used on distributed databases or non relational databases as long as the Connection Interface is implemented for each type of connection.

Database driven applications by their nature are required to facilitate the management of data records. This typically includes the ability to view and search lists of records as well as to create delete and modify records. To avoid the need to re implement these basic management tasks for every newly developed application and every record type the system has abstracted these management tasks. Facilitating the management of records does not only include a programmatic interface and the logic to do it but a user interface as well. The proposed system is capable of providing user interface components to manage any given data record. The goal and advantage of the proposed system is to streamline the development for data driven applications and provide generic and extensible components for managing data records. The purpose of system is to facilitate various management tasks that pertain to data records. This includes 

The database record management system has two layers to it. One provides the logic that is necessary to facilitate the above tasks. Objects in this layer are referred to as models. The second part of the system is concerned with the user interface representation of the underlying models. The user interface components are referred to as views. Views present the model information to the user and delegate requested logical operations to the model.

The two principal objects in the model layer are a Directory and a Detail. The Directory is responsible for managing lists of records while the Detail is responsible for managing a single record.

The current range of Records is referred to as a page. All of the Records are referred to as a book. 

For the step of constructing a database query from a selected filter special filter encoder objects called FilterEncoders are used. In embodiments operating in connection with SQL based databases a Filter is converted to an SQL statement.

When conducting the step of executing a query an SQL cursor or SQLCursor is used to go to the first record specified by the current page. If there are 100 Records with a page size of 10 the second page would mean that the cursor would be placed on the 20Record.

For the step of generating a TableModel from the Filter the system first reads all fields from the Filter and their Types. The primary key is added as the first column which is set as hidden. For each field specified in the Filter the system adds a column to the TableModel and indicates visibility and the type of the data in the column.

For the step of populating the TableModel using results from the query the system first clears the TableModel contents then the cursor is moved over records from the current page and the TableModel is populated with records.

In order for a user to create a new Entity the Directory passes the request to a Detail object. In order to load an existing Entity the Directory passes a primary key value to a Detail object.

With reference again to the Detail object is responsible for operations on a single data Entity . The Directory can be thought of as a listing of data Entities and it may list a subset of the available fields. The Detail provides the ability to manipulate all aspects of a given data Entity . It is comprised of 

The NavigationModel is used in the Directory to simply keep track of the page. It only contains state relevant information. The actual retrieval of data is done within the Directory . The NavigationModel contains 

The FilterManager facilitates the management of Filter objects . It provides functions to manipulate the underlying Filters . A Filter object encodes various query options for a given Record type. The FilterManager contains 

A ParameterSet is an object which acts as the model for obtaining search parameters from the user. It allows for any field to be specified. In a DirectoryView explained in detail below parameter fields appear on the top. A ParameterSet is comprised of 

The column name shown to the user and the column name stored might differ when dealing with foreign keys where the presented version is textual while the stored value is numeric. In this case a Lookup object would also be used.

The LookupManager maintains a collection of Lookup objects . It provides the ability to add get remove and refresh Lookups . A Lookup object is an association of value name pairs. Lookups are most frequently used to associate a foreign key column to a field in the foreign key table.

A TableModel keeps raw data in a tabular structure. It provides actions which can be defined on single row or multiple rows. It further contains 

The TableEntityFace is a wrapper around the TableModel . The TableEntityFace also provides the ability to retrieve and set values as well as column types. However the difference with the TableEntityFace is that it can add rows in terms of Record objects rather than just raw data.

As the name suggests the purpose of a keeper object or Keeper is to keep other objects or to generate them. Provided an object URI such as company detail or company metaentity the Keeper is capable of retrieving the requested object. Model Keepers are maintained for objects specifically relevant for models such as Directories Details and so on. A Keeper is also maintained for views. A Keeper designated for views is able to retrieve Views for a given Model object.

Each View in the system is associated with an object from the Model layer. The Views themselves determine how to draw the model data. The views are very thin and do not contain any relevant logic or operations. The views only know how to draw themselves. They do however intercept user interactions and events and initiate actions in the model layer.

Once a record is clicked in the DirectoryView a detail view object or DetailView opens up. When the click occurs the TableView passes this action to the DirectoryView indicating the id of the row that was clicked. The DirectoryView in turn requests from the Directory model to load a Detail with the given primary key. Once the Detail has been loaded it is attached to a DetailView as a model. The View is then requested to draw itself.

The DetailView itself lists all of the Record fields in an accessible format. There are several implementations of the DetailView . One version simply lists all of the existing fields in a record in a grid like layout. The layout only specifies the dimensions of the grid. Another implementation is based on an XML layout whereby the locations and visual properties of the user interface are provided in an xml file. The XML layout also provides behavioral properties in terms of event scripts. A DetailView that is defined to draw records in general rather than specific fields only is advantageous because it can be used to draw generic records. If a developer is in need of customization it can easily be done on top of the existing framework

In reference to as described above Parameters are created based on Filters . When a condition in the FilterView is added with a special value such as the character this is used as a trigger to generate Parameters . The DirectoryView constructs a ParameterSet based on the Filter . The Filter condition is taken over as a Parameter condition. The column name is carried over as well. Using the MetaEntity from the Filter one can also extract a Lookup object if it exists. The next time the DirectoryView is drawn the ParameterView is no longer empty. When a user enters a Parameter value it is passed to the ParamterSet . The ParameterSet in turn notifies the Directory to reload its data.

Row and bulk options are part of the TableModel . A row operation only allows one row to be selected. Once an operation such Create is clicked the TableView passes on this event to the DirectoryView along with the selected ids in the Table. The DirectoryView translates the table ids to primary keys and passes on the action in most cases to the Detail model . Once the operation is completed either the DirectoryView is redrawn or a DetailView is opened.

The nature of the Views in the system is not specified on purpose. The views themselves could be HTML based desktop views or views on mobile devices. Exemplary embodiments of an HTML based DirectoryView an HTML based DetailView and an HTML based FilterView are shown in respectively.

Presentation independence is achieved via a module named Render. The Render module implements a generic rendering loop to allow views of the application state to be presented to the user on the medium of choice. Several rendering mediums exist including HTML renderer for web applications Desktop SWING renderer for desktop applications OpenGL graphics renderer for games and visual simulations and various mobile phone renderers for for example Android Blackberry and Apple systems and their number will grow. While each rendering medium is accessed differently the Render module describes a uniform way for the application to access this facility. The application platform puts strict constraints on what can happen within a View object that renders application state and is managed by the Render module

The primary purpose of the Render module is to act as a rendering loop. A rendering loop will issue drawing tasks to the underlying presentation medium. The presentation medium might be represented by a special driver object but the Render module should expose its functionality transparently. Frequently the layout of the views is represented by a hierarchy or a graph structure. Such graph structures implicitly determine the order of drawing. In special cases such as game rendering loops the ordering is not as clear because transparency and other effects might require the same view to be rendered multiple times. In these special cases the Render module will use the view hierarchy to compile a task list which is then executed in the loop. In some embodiments the Render module is configured to collect user input and associate the input with the view or views. After the association process the input events appear in the application as if they came from a view instead of an input device.

For a plain data object to be considered a model it needs to adhere to the ModelFace interface API contract. A model stores all or part of the application state and implements the logic to manipulate the state. All model objects primarily reside with the Kernel module. In some embodiments a model might have child models. If the models represent documents an entire graph is also known as a document object model. The model represents everything essential about the application. It is unaware of the way it is presented by the views except to manage a list of views and to dispatch messages to these attached views when the model state changes. In this way a model represents a unit of code that can be developed independently of the presentation layer.

The View interface API is a contract that describes what each view must do. A view implements the MessageListener interface and is therefore able to act as a monitor of state changes. A view is capable of painting its own state or the state of the underlying model to a presentation medium. The particular mechanics of how this occurs varies from case to case so the View interface does not specify the routine to delegate for painting or any parameters such a routine would have. The View interface implements following set of methods 

While a model might be monitored by several listeners a view is only able to monitor one model at a time. If the view receives input messages it will relay such messages to the model or call model routines to affect changes in state. The view also receives back messages from the model as part of it MessageListener contract and can react by signaling the need to repaint. The way a view receives messages from the model is through the single MessageListener method called onMessage. This routine accepts a generic Message object.

The Message class is meant to be extended for meaningful use but it can be used on its own. It stores three attributes a timestamp of creation the source of the message and the target of the message. Both the source and target must be implementing the MessageListener interface. The description of the Message and the MessageListener as the source and destination of such messages is given here in the context of view and the model however the same message passing is also implemented and used at the module level and in the application object. The modules and the application as the top most module all implement a message passing loop that can receive messages asynchronously and dispatch them to other modules or MessageListener objects.

A set of views dedicated to the same presentation medium form a toolkit of widgets and other viewable elements that an application developer can use to produce a graphic user interface. For complete compatibility each presentation medium must have the exact same set of views. One exemplary embodiment includes the following view sets 

Each of the view sets relies on the same underlying model objects. In the specific case of web applications HTML elements are represented as view objects. Only when the view is rendered is the actual HTML created. All of the properties of the view are encoded in the view object. For example exemplary view objects include HTMLComboboxView HTMLButtonView and HTMLTableView. When writing server side code other frameworks may represent HTML views in terms of objects for ease of use. What distinguishes the instant approach is that the HTML view objects are based on models.

The instant system provides a model view interface that is reusable across different presentation media. For example as shown in a single TableModel can be displayed in a SwingTableView for a desktop presentation and in an HTMLTableView for a web browser presentation. Both views in turn interact with the same TableModel . There are two consequences to this. First the same TableModel i.e. contents can be edited simultaneously through a web application and through a desktop application. Second when creating software developers can focus on developing models. The models encode the entire logic. Providing the software on a new medium such as the web is only a matter of adding the proper view sets. Since in this framework views are kept very thin in that they simply render underlying model objects the effort of providing the application on a new medium is minimized. More importantly developers can focus on developing software without having to worry about how it will be viewed.

With respect to the overall system what each module does during startup and shutdown can depend on the developer. However each module has the ability to cooperate with the Kernel and Render modules by providing these special modules with a model keeper a view keeper and a menu. Model and View keepers are factory objects that can create new instances of models and views.

A Kernel module is de facto top most model of the application. It contains a global menu a global model factory and the top document. The global menu of action commands is accumulated by merging all local menus from other modules that cooperate with the kernel. The global menu is later displayed by the top window or top most view of the Render module. The Kernel module routes action invocations from the local menus through itself to appropriate targets. The global model factory or keeper is another example of an aggregated or nested collection of model keepers from all participating modules. The global model keeper can create new instances of models or documents in one place regardless which module exported the particular model type. Finally in some embodiments the Kernel manages the top model or document. Embodiments in which the document model hosts child models which in turn host other child models are called document object models or DOMs. A DOM represents one central place for data and logic of an application. The behavior of the kernel module during initialization is important. Namely during initialization and in reverse order during shutdown the Kernel will attempt to query all other loaded modules for their local menus and will merge all discovered menus in one global menu. Furthermore it will also try to collect all local models and possibly view keepers or factories and make those available as a nested global factory to the rest of the application.

The Render module is typically more complex than the Kernel module. What data structures it holds depends heavily on the presentation medium it controls. Still two pieces of data belong with a Render module. First is a ubiquitous object called the context. The context represents the connection to the presentation medium and its actual interpretation is known to the Render module but not the rest of the application. The other data structure that belongs with Render module is the Top Window or top most view. The Top Window is the first and highest level user interface element of the application. In most embodiments it will expose to the user the global menu hosted by the Kernel. Furthermore when actions are invoked on the menu that result in the opening or creation of new documents the Top Window creates appropriate views and embeds them in the user interface layout. The Top Window consults the global View keeper or factory hosted either in the Kernel or Render module to create such views. If necessary such as in an HTML Render module the Top Window might be required to implement the management of view layout. This layout management can be as basic as keeping track of which view is on top or more complex such as including docking panes and floating user interface sections. In an embodiment for a web application the Top Window implementation keeps track of open windows. When a window is closed the one below is shown. This is a behavior not typical of web applications but because in the instant framework web pages are represented as view objects it is easily achievable. The behavior of the Render module is frequently limited to the initialization of the presentation medium and instantiation of the Top Window. The creation of the Top Window indirectly makes use of view and model keepers and binds the views to the models.

In some cases the underlying presentation medium is already constructed to support a model view architecture. For example in Java SWING each user interface element is supported by a corresponding model. To prevent the models in the instant framework from importing dependencies that could tie them to the presentation medium the models are wrapped so that they can be plugged into such model view architectures but without the models being aware of it.

The described approach can be implemented on nearly any general computing devices or computer processing devices such as desktop computers laptop computers work stations servers mobile devices and even hard wired into an electronic chip. It can use any database system and any operating system on which the chosen language is supported in connection with any storage medium. Presentation media can be anything from a computer desktop a mobile device or any programmable or networked device and may include both audio and visual media.

While the application platform systems and processes have been described in reference to some exemplary embodiments these embodiments are not limiting and are not necessarily exclusive of each other and it is contemplated that particular features of various embodiments may be omitted or combined for use with features of other embodiments while remaining within the scope of the invention. Moreover the use of computer programming naming conventions such as the use of capital letters concatenated words abbreviations and the like are not intended to be limiting in any way.

