---

title: Detecting deviation from a data packet send-protocol in a computer system
abstract: A determination is made as to whether an attempt to send a data packet from a computer system has deviated from an established protocol for sending data packets from the computer system is made. The determination includes obtaining a data structure describing the data packet, and, based on invocation of a function to deliver the data packet to a module of a stack of the computer system, the module interfacing network hardware for sending the data packet, checking for presence of a tag placed in the data structure by a component of the stack and indicative of whether the attempt to send the data packet has deviated from the established protocol. Processing is then performed based on the determination of whether the attempt has deviated from the established protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09654498&OS=09654498&RS=09654498
owner: ASSURED INFORMATION SECURITY, INC.
number: 09654498
owner_city: Rome
owner_country: US
publication_date: 20150512
---
Modern malicious software malware and rootkits pose a serious threat to information assurance IA . This class of software attempts to exfiltrate sensitive data by sending it from a computer system across a network to unauthorized systems. Because of firewalls or other security facilitates in place on the computer system to prevent such exfiltration malicious software often must perform the sending in a stealth manner. As an example the malicious software may employ kernel code that is code executing on a processor operating in a privileged mode such as kernel mode that bypasses portions of the driver stack in place on the computer system for sending data in order to avoid detection from modern host based intrusion detection systems HIDS firewalls rootkit detectors or other types of security facilities.

Modern operating systems rely on a system call interface specification to handle sending of data from a computer system. The system call interface specification serves as an application programming interface API for the physical hardware e.g. network interface cards NICs . It forms a layer of abstraction from the underlying complexity of the NIC in such a way that NICs for a given media e.g. Ethernet can be accessed using the common programming interface.

Examples are described herein with reference to the Network Driver Interface Specification NDIS which is the system call interface specification used in the Windows line of operating systems offered by Microsoft Corporation Windows is a registered trademark of Microsoft Corporation Redmond Wash. USA . The NDIS is implemented as a library of wrappers that create a standard interface between hardware level NIC drivers and network protocol drivers. Although examples are described herein with reference to NDIS these are only for purposes of example and illustration aspects described herein may be readily applied to other system call interface specifications such as those used in operating systems other than the Windows line of operating systems.

The NDIS is built using drivers that sit in logical layers to form a driver stack. The NDIS version 6.x architecture supports four primary types of network drivers the NDIS protocol driver NDIS lightweight filter LWF driver NDIS miniport driver and NDIS intermediate driver. The NDIS LWF driver is a relatively new driver type added in NDIS v6.0 to replace the NDIS intermediate driver type.

The NDIS is responsible for managing the relationship between each driver layer and maintaining critical information for each driver such as state information characteristics pointers to driver dispatch functions handles and parameter blocks for linkage as examples.

When data is to be sent from the computer system the data traverses a send path through the driver stack. This is described and depicted with reference to which illustrates a send path of a driver stack through which data originating from an application executing in user mode is sent from the computer system to a network using the network protocol provided by NDIS executing in kernel mode.

Application opens a channel socket between itself and a specific NDIS protocol driver for instance TCPIP.sys in protocol layer . Data is sent from the application to the protocol driver which will process the data sent from the application and generate a network packet. Once the network packet has been generated by NDIS protocol driver the packet is then provided through the filter layer stack of registered NDIS filter drivers called lightweight filters LWFs in filter layer . There are two LWFs in this example though there may be zero or more LWFs in other examples. Each NDIS LWF has the opportunity to perform processing on the network packet before the packet is provided for handling by the miniport driver in miniport layer . Miniport layer is a layer for abstracting device specific drivers e.g. network hardware NIC device specific drivers. The NIC is the hardware that sends the packet onto the network . A miniport driver communicates with a specific NIC driver in the system thereby interfacing the software with the NIC.

Miniport driver will communicate with the NIC i.e. through a NIC hardware specific driver not pictured in between the miniport and actual hardware and send the network packet out onto the network completing the process. Behavioral analysis of the example operating system has yielded that this is the appropriate method for sending a network packet to a remote host. Deviations from this path may be considered to be suspicious though some may purposefully be whitelisted as described in further detail below such as when a HID system legitimately originates a packet that does not follow the above described path .

The established protocol of the computer system for sending a data packet onto a network might include security features such as HIDS firewalls or rootkit detectors as examples to prevent malicious data exfiltration. Many times low level firewalls and HIDS are implemented within user mode or in kernel mode near the top of the filter layer of the NDIS kernel network stack i.e. as a NDIS LWF driver. As described above NDIS LWF drivers can monitor and filter the network traffic that passes between the protocol layer which generates the packet and the miniport layer which communicates the network packet to the NIC. Consequently in order for malware to bypass these security features they will attempt to circumvent the filter drivers present in the filter layer of the NDIS driver stack. One possibility is for the malicious software to execute code directly within the kernel e.g. as a kernel driver to send packets potentially containing sensitive data to bypass this normal protocol. Bypassing low level firewalls and HIDS tends to be the main motivating factor for developing a kernel driver that circumvents the normal send path.

Another example depicted in shows a malware driver executing in kernel mode directly invoking a miniport driver s send function. Here malware driver executes in kernel mode but outside of i.e. not as part of the driver stack. Here as in components of the protocol layer and filter layer are avoided because the packet is sent directly from malware driver which invokes directly the send function of the miniport driver . The packet then travels through the balance of the send path e.g. though miniport driver and to NIC onto network .

Aspects described herein provide for detection of network packets for which the sending has deviated from the established protocol for sending data packets such as those sent by malware as described and depicted with reference to . Components and related processing to facilitate this detection are collectively referred to herein as LastDefense . LastDefense is able to detect when sending packets does not follow the normal operating system provided paradigm for sending of packets and can perform processing based on the detection such as flagging the packets as potentially originating from malware within the kernel.

Detection is provided in part by LastDefense using packet tagging marking to identify packets arriving at protocol drivers from user mode applications. LastDefense also monitors a packet arriving at a miniport driver for sending to a NIC in order to verify that the packet has been so tagged. If a packet arriving at the miniport driver does not contain the proper tag then it may be flagged as potentially malicious because it originated from somewhere else in the kernel for instance . Logging of at least some of the contents or other data associated with the packet may be performed to enable subsequent review by a system administrator as an example.

Since LastDefense compares the network traffic generated in the protocol layer of the NDIS stack to the traffic that is sent to the NIC it will detect attempts to deviate from the established protocol for sending data packets for instance when malware attempts to hide network traffic or bypass HIDS by injecting packets into the system s network stack. Packets sent by malware in may be detected as deviating from the established protocol and logged as malicious because their sending has bypassed the protocol layer and therefore the packet was not tagged by a LastDefense component configured to perform that tagging.

Accordingly LastDefense identifies network traffic that does not take the defined path through the network driver stack. According to embodiments described herein hooks are placed in strategic locations of the NDIS driver stack in order to verify that network packets being sent out on the network have taken the defined path. These may be placed when the computer system is started such as during boot of the operating system as an example.

More specifically LastDefense can utilize multiple hooks on a Windows operating system based computer to accomplish this goal. They are described below with reference to the NDIS though the principles are more generally applicable to other system call interface specifications. The two hooks in this example are a Direct Kernel Object Manipulation DKOM hook and a function hook.

In order to place these hooks LastDefense first locates the address of the NDIS M DRIVER BLOCK data structure that corresponds to the NIC device it is monitoring. In this regard there is generally a linked list of NDIS M DRIVER BLOCK data structures each such structure corresponding to a NIC in the computer system. A NDIS M DRIVER BLOCK data structure is the root structure to the information held by NDIS. Since the NDIS M DRIVER BLOCK data structure is unexported it is referenced by first locating it in memory. In order to locate this data structure in memory a temporary function hook may be placed on the Windows function IoAllocateDriverObjectExtension which will return a reference to the first structure in the linked list of NDIS M DRIVER BLOCK structures when invoked by the exported Windows function NdisMRegisterMiniportDriver. Based on obtaining the reference to the first NDIS M DRIVER BLOCK the hook on IoAllocateDriverObjectExtension may be removed. The linked list may be traversed until the correct NDIS M DRIVER BLOCK i.e. the one corresponding to the NIC device for monitoring is located. As an example each NDIS M DRIVER BLOCK may include an AssociatedProtocol pointer to an associated NDIS PROTOCOL BLOCK structure. Within this structure may be field s i.e. BindDeviceName and RootDeviceName that identify the NIC associated with that NDIS M DRIVER BLOCK. The linked list of NDIS M DRIVER BLOCKS can be traversed until the NDIS M DRIVER BLOCK associated with the desired NIC is located. When the correct NDIS M DRIVER BLOCK is located the address of the data structure has been determined and the process can proceed to place the two hooks that facilitate operation of aspects described herein.

The first hook may be a DKOM hook on a function for delivering a data packet to a driver of a driver stack of the computer system. The DKOM hook may be placed by traversing standard data structures of the interface specification. This is described with reference to which depicts traversal of data structures defined by a system call interface specification to access pointers to functions for delivering a data packet to drivers of a driver stack of the computer system in accordance with aspects described herein. In this example which is based on NDIS the NDIS M DRIVER BLOCK data structure includes a pointer to a first NDIS MINIPORT BLOCK data structure in a linked list of NDIS MINIPORT BLOCK data structures. Each LWF and miniport driver in the stack may be associated with a corresponding NDIS MINIPORT BLOCK. To invoke handling of a data packet by a given driver in the stack a SendNetBufferListsHandler function associated with the driver is invoked. Thus the NDIS MINIPORT BLOCK associated with the first LWF e.g. LWF Y in in the filter layer for instance the first NDIS MINIPORT BLOCK in the linked list is located and the DKOM hook placed in accordance with aspects described herein is placed by replacing the function pointer for the SendNetBufferListsHandler function of an NDIS MINIPORT HANDLERS data structure associated with the NDIS MINIPORT BLOCK structure . More specifically the function pointer is overwritten with the address of a separate handler tagging component of LastDefense described in further detail below to perform placing a tag in data structures describing data packets generated by a protocol driver. By overwriting that function pointer a call to the function by a protocol driver for instance invokes the separate handler which places the tag. Then the separate handler can direct execution to the original pointer for SendNetBufferListsHandler that was previously overwritten. Adding the DKOM hook positions the tagging component to be the first entity to receive network packets on the send path after they have been generated by a protocol driver in the protocol layer of the NDIS driver stack. It sits conceptually between the protocol driver and the first LWF driver therefore at the bottom of the protocol layer or top of lightweight filter layer.

The purpose of the second hook is to position another handler a checking component of LastDefense described further below to check that data packets being invoked for sending by a miniport driver have been tagged by the tagging component. This evidences that the data packet traveled through the normal send path i.e. through the LWF drivers. The second hook placed is a direct function hook on the SendNetBufferListsHandler function that is exported to NDIS by the miniport driver e.g. of for the subject NIC. When the miniport driver loads it exports the address of the SendNetBufferListsHandler function for NDIS to invoke when it needs to deliver a network packet to the miniport driver. The address of this function is determined by for instance traversing the appropriate NDIS data structures for instance the NDIS MINIPORT BLOCKs. The function is hooked directly by for instance code patching the prologue of the function. This creates a deep hook that would prevent malware from circumventing the checking component of LastDefense by looking up the function address as LastDefense does and invoking it directly as opposed to going through the legitimate NDIS send path. In other words even an attempt by malware to deliver a packet directly to a miniport driver as shown in will be intercepted and identified as having deviated from the establish send protocol.

Techniques for Windows function lookup and kernel hooking are described in the prior art for instance in Hoglund Greg et al. Ch. 4 The Age Old Art of Hooking p. 71 112 2006 which is hereby incorporated herein by reference in its entirety.

As shown in LastDefense component is positioned by way of the DKOM hooking described above as the first entity in filter layer to handle a data packet generated by protocol driver in protocol layer . Alternatively component could be represented as being the last component in the protocol layer see for example . Given the parallel nature of protocol drivers in the NDIS protocol layer positioning of tagging component as being the target of protocol driver calls to invoke LWF driver Y allows it to intercept tag traffic that is generated by any of the protocol drivers destined for the NIC for which that component is monitoring the sending of data packets. In some examples a separate component is provided for each respective send path for the NICs in the system for which monitoring is performed though in other examples a component is responsible for tagging data packets being sent through any of several different NICs.

In this position component places a tag in a field of a data structure describing the data packets generated by protocol driver . An example such data structure in NDIS is the NET BUFFER LIST data structure an example definition of which is shown in . Each network packet sent according to NDIS is indirectly encapsulated and described by a NET BUFFER LIST data structure. The tag placed in the data structure field serves as a signature that can be identified later i.e. farther along in the send path by the checking component. Advantageously LastDefense component can avoid modifying the network packet itself rather it may place the tag in a field that is observed to be an unused field of the NET BUFFER LIST data structure as the packet traverses the network stack. Referring to a NET BUFFER LIST data structure is shown having an unused field which in this example is a Status field of type NDIS STATUS. The Status field may otherwise be unmodified throughout the lifetime of a send packet as documented by the operating system provider.

In other examples one or more tags may be placed in one or more other fields and or data structures describing the data packet if desired. In this manner the detection described herein may be performed absent modification to the data packet itself.

With the second hook in place upon invoking the SendNetBufferListsHandler function associated with miniport driver after the data packet is handled by LWF X the function hooking directs execution to the LastDefense checking component conceptually provided between the last lightweight filter in the lightweight filter layer and the miniport driver in the miniport layer . LastDefense component checks a received NET BUFFER LIST structure i.e. a field thereof such as the Status field for a tag placed by component . Presence of the tag is evidence that the data packet properly traveled through the send path and therefore was subject to the appropriate filtering and or other security measures in place for outgoing traffic. In this case the tag may optionally be removed from the data structure and or the original value of the field in the data structure may be restored and the data packet continues through the send path onto the network.

If no tag is present the tagging component was bypassed and the attempt to send the data packet has deviated from the established protocol send path. It may therefore be assumed that the data packet is the product of a malicious attempt to exfiltrate data. Any desired processing of the data packet may then be performed since execution at that point resides with the separate handler. In some examples the contents of the packet are logged to a local or remote file. By way of specific example some or all of the packet contents are logged in a packet capture file format such as .pcap to allow for easy viewing via any of a variety of packet analysis applications like Wireshark offered by the Wireshark project available at www.wireshark.org WIRE SHARK is a trademark of WIRESHARK FOUNDATION INC. California U.S.A. . A centralized logging infrastructure may be used for instance one built using tools such as Elasticsearch Logstash Logstash forwarder and Kibana offered by ElasticSearch BV Netherlands referred to as the Logstash Suite .

Log generation may be handled asynchronously by kernel worker threads minimizing or eliminating the effect that LastDefense has on network overhead. The logs may be stored on the hard disk of the local machine running LastDefense and or stored remotely for instance to be analyzed by remote analysis.

In malware application injects a data packet into the driver stack by sending the packet to malware driver in filter layer . Protocol driver in protocol layer and lightweight filter driver in filter layer are bypassed in this attempt to send data. Because the data packet was not properly constructed by protocol driver and consequently was not handled by LastDefense tagging component the data structure describing the data packet will not have a tag placed by LastDefense component . The malware driver will pass handling of the data packet to a next entity in the stack either an underlying filter layer driver or a miniport driver if the malware driver is the last entity in the filter layer as is the case in . Malware driver therefore invokes the send function of miniport driver in miniport layer . LastDefense component will hook into that function to perform a check for the tag paced into the data structure. This check will reveal that no such tag exists. Any appropriate action may be taken by component or another component such as logging packet contents and or blocking the data packet from being sent through miniport driver to NIC and network .

In a malware driver attempts to invoke miniport driver directly to send a data packet. However based on the hooking described above LastDefense component will obtain the data structure describing the packet and recognize that no tag from LastDefense component is present. As before any appropriate action may be taken such as logging packet contents and or blocking the data packet from being sent through miniport driver to NIC and network .

The tag placed into the data structure may be any appropriate tag such as a static value other than the default value for the field being used to hold the tag. In some examples the tag is a value defined at boot time and or random. Such a dynamic value can provide an added layer of security in case the static marker is reversed or compromised.

A false positive identified by the checking component e.g. of is a packet flagged as suspicious by LastDefense that originated from a legitimate source. A data packet generated by a legitimate uncompromised LWF in the network stack is one example. In such cases if present then a white list feature could be implemented to allow packets from a given source such as a particular trusted LWF to be trusted by the LastDefense checking component. An example implementation of this white list feature would see additional hook s included at one or more nodes of the NDIS MINIPORT BLOCK linked list which hook s would perform an inspection marking of the packet in between handling by the filter driver s in the stack.

If instead at it is determined that the tag is not present then the process may log contents of the data packet for analysis and or block the data packet from being sent from the computer system .

In some examples the tagging component installed into the stack is a handler that is configured to perform based on the data packet being generated by a protocol driver of the stack the placing of the tag in the data structure describing the data packet. Installing the tagging component into the stack may include replacing a function pointer of a send handler defined by a system call interface specification for the stack with a pointer to the handler to place the tag where the replacing positions the handler to place the tag as a first entity of the stack to handle the data packet after being generated by a protocol driver of the stack.

The data structure into which the tag is placed may include a data structure defined by a system call interface specification for the stack to facilitate sending of the data packet. The handler may place the tag in a field of the data structure that is observed to be an unused field of the data structure such as a Status field. In some examples the tag includes a static value dynamic value defined at boot time of the computer system a random value or some combination of one or more of the foregoing.

The established protocol for sending data packets from the computer system may include passing the data packet through a send path of the stack the send path including a protocol layer a filter layer and a device agnostic interface layer of the stack where the first component the tagging component is installed either in the protocol layer of the send path or in the filter layer of the send path and where the second component the checking component is installed in the interface layer of the send path. As examples the tagging component may be installed in the send path either as a last entity in the protocol layer to handle the data packet or a first entity in the filter layer to handle the data packet and the checking component may be installed in the send path as a first entity in the interface layer to handle the data packet. The checking component may be a handler that hooks a function to deliver the data packet to the module that interfaces the network hardware as an example.

Aspects described herein may be used to protect against attempts by malware to exfiltrate data. As a specific example case the attempt to send the data packet includes a malicious component introducing the data packet into the stack such that the tagging component and placement by the tagging component of the tag into the data structure is bypassed. In this situation the checking would indicate non presence of the tag and it will be determined based on that checking indicating non presence of the tag that the attempt to send the data packet has deviated from the established protocol.

Further computer system includes an input output I O communications interface component for communicating data between computer system and external devices such as I O and peripheral devices mouse keyboard display devices and network devices.

In some embodiments aspects described herein may take the form of a computer program product embodied in one or more computer readable medium s . The one or more computer readable medium s may have embodied thereon computer readable program code. Various computer readable medium s or combinations thereof may be utilized. For instance the computer readable medium s may comprise a computer readable storage medium examples of which include but are not limited to one or more electronic magnetic optical or semiconductor systems apparatuses or devices or any suitable combination of the foregoing. Example computer readable storage medium s include for instance an electrical connection having one or more wires a portable computer diskette a hard disk or mass storage device a random access memory RAM read only memory ROM and or erasable programmable read only memory such as EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device including a tape device or any suitable combination of the above. A computer readable storage medium is defined to comprise a tangible medium that can contain or store program code for use by or in connection with an instruction execution system apparatus or device such as a processor. The program code stored in on the computer readable medium therefore produces an article of manufacture such as a computer program product including program code.

Referring now to in one example a computer program product includes for instance one or more computer readable media to store computer readable program code means or logic thereon to provide and facilitate one or more aspects of the present invention.

Program code contained or stored in on a computer readable medium can be obtained and executed by a computer system computer computer system etc. including a component thereof and or other devices to cause the computer system component thereof and or other device to behave function in a particular manner. The program code can be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber and or radio frequency. Program code for carrying out operations to perform achieve or facilitate aspects of the present invention may be written in one or more programming languages. In some embodiments the programming language s include object oriented and or procedural programming languages such as C C C Java etc. Program code may execute entirely on the user s computer entirely remote from the user s computer or a combination of partly on the user s computer and partly on a remote computer. In some embodiments a user s computer and a remote computer are in communication via a network such as a local area network LAN or a wide area network WAN and or via an external computer for example through the Internet using an Internet Service Provider .

In one example program code includes one or more program instructions obtained for execution by one or more processors. Computer program instructions may be provided to one or more processors of e.g. one or more computer system to produce a machine such that the program instructions when executed by the one or more processors perform achieve or facilitate aspects of the present invention such as actions or functions described in flowcharts and or block diagrams described herein. Thus each block or combinations of blocks of the flowchart illustrations and or block diagrams depicted and described herein can be implemented in some embodiments by computer program instructions.

The flowcharts and block diagrams depicted and described with reference to the Figures illustrate the architecture functionality and operation of possible embodiments of systems methods and or computer program products according to aspects of the present invention. These flowchart illustrations and or block diagrams could therefore be of methods apparatuses systems and or computer program products according to aspects of the present invention.

In some embodiments as noted above each block in a flowchart or block diagram may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified behaviors and or logical functions of the block. Those having ordinary skill in the art will appreciate that behaviors functions specified or performed by a block may occur in a different order than depicted and or described or may occur simultaneous to or partially wholly concurrent with one or more other blocks. Two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order. Additionally each block of the block diagrams and or flowchart illustrations and combinations of blocks in the block diagrams and or flowchart illustrations can be implemented wholly by special purpose hardware based systems or in combination with computer instructions that perform the behaviors functions specified by a block or entire block diagram or flowchart.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprise and any form of comprise such as comprises and comprising have and any form of have such as has and having include and any form of include such as includes and including and contain and any form contain such as contains and containing are open ended linking verbs. As a result a method or device that comprises has includes or contains one or more steps or elements possesses those one or more steps or elements but is not limited to possessing only those one or more steps or elements. Likewise a step of a method or an element of a device that comprises has includes or contains one or more features possesses those one or more features but is not limited to possessing only those one or more features. Furthermore a device or structure that is configured in a certain way is configured in at least that way but may also be configured in ways that are not listed.

The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

