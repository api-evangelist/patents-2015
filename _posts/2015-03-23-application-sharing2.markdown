---

title: Application sharing
abstract: Ones of the windows associated with a software process are identified in a screen layout on a local display of a sharer network node. On the sharer network node, an image of the identified windows as they are arranged in the screen layout and free of obscuration by any other windows in the screen layout is generated. The image is transmitted from the sharer network node to a viewer network node. Also, commands derived from input device events on sharer and viewer network nodes are received. The received commands are processed into a command sequence, which is passed to a shared process executing on the sharer network node. Windows associated with the shared process are presented on the sharer network node in accordance with the received command sequence. An image of the presented windows is generated and transmitted from the sharer network node to the viewer network node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=RE046309&OS=RE046309&RS=RE046309
owner: Sococo, Inc.
number: RE046309
owner_city: Eugene
owner_country: US
publication_date: 20150323
---
This application is an application for reissue of U.S. Pat. No. 8 407 605 and relates to the following co pending patent applications the entirety of each of which is incorporated herein by reference 

When face to face communications are not practical people often rely on one or more technological solutions to meet their communications needs. These solutions typically are designed to simulate one or more aspects of face to face communications. Traditional telephony systems enable voice communications between callers. Instant messaging also referred to as chat communications systems enable users to communicate text messages in real time through instant message computer clients that are interconnected by an instant message server. Some instant messaging systems additionally allow users to be represented in a virtual environment by user controllable graphic objects referred to as avatars . Interactive virtual reality communication systems enable users in remote locations to communicate over multiple real time channels and to interact with each other by manipulating their respective avatars in three dimensional virtual spaces. Each of these modes of communications typically can handle some form of data sharing between the communicants.

A common form of data sharing is application sharing which involves transmitting application data from one node referred to as the sharer node to one or more other nodes referred to as viewer nodes . Application sharing has a variety of useful applications including providing remote technical support remote collaboration and remote presentation of demonstrations documents and images. In some proposed systems an application sharing program on the sharer node periodically collects drawing commands e.g. GDI calls for drawing lines and curves rendering fonts and handling palettes from a chained display driver process on the sharer node packages the drawing commands into an order packet and sends the order packet to a respective counterpart application sharing program on each of the viewer nodes that accurately constructs the shared view of the sharer s display. Such an application sharing approach however requires each viewer node to render its own version of the shared application by passing the drawing commands in the order packet to a display process e.g. the GDI interface provided by a Microsoft Windows operating system .

In one aspect the invention features a method in accordance with which ones of the windows that are associated with a software process are identified in a screen layout on a local display of a sharer network node. On the sharer network node a composite image of the identified windows as they are arranged in the screen layout and free of obscuration by any other windows in the screen layout is generated. The composite image is transmitted from the sharer network node to a viewer network node.

In one aspect the invention features a method in accordance with which locally generated commands that are derived from local input device events on a sharer network node are received. Remotely generated commands that are derived from remote input device events on a remote viewer network node also are received. The received commands are processed into a command sequence. The command sequence is passed to a shared process executing on the sharer network node. In a screen layout on a local display of the sharer network node one or more windows that are associated with the shared process are presented in accordance with the received command sequence. An image of the one or more windows as they are presented in the screen layout is generated. The image is transmitted from the sharer network node to the viewer network node.

The invention also features apparatus operable to implement the inventive methods described above and computer readable media storing computer readable instructions causing a computer to implement the inventive methods described above.

Other features and advantages of the invention will become apparent from the following description including the drawings and the claims.

In the following description like reference numbers are used to identify like elements. Furthermore the drawings are intended to illustrate major features of exemplary embodiments in a diagrammatic manner. The drawings are not intended to depict every feature of actual embodiments nor relative dimensions of the depicted elements and are not drawn to scale.

A window is a visual area of a display that typically includes a user interface. A window typically displays the output of a software process and typically enables a user to input commands or data for the software process. A window that has a parent is called a child window. A window that has no parent or whose parent is the desktop window is called a top level window. A desktop is a system defined window that paints the background of a graphical user interface GUI and serves as the base for all windows displayed by all software processes.

The term window scraping refers to a process of extracting data from the display output of another software process. The extraction process is performed by a scraper software process.

A layering order also referred to as the z order is an ordering of overlapping two dimensional objects such as windows in a graphical user interface GUI along an axis typically referred to as the z axis that is perpendicular to a display on which the GUI is presented.

 Compositing is the combining of visual elements from separate sources into a single composite image also referred to herein as a frame .

A communicant is a person who communicates or otherwise interacts with other persons over one or more network connections where the communication or interaction may or may not occur in the context of a virtual area. A user is a communicant who is operating a particular network node that defines a particular perspective for descriptive purposes. A sharer is a communicant who is operating a sharer network node. A viewer is a communicant who is operating a viewer network node.

A realtime contact of a user is a communicant or other person who has communicated with the user via a realtime communications platform.

A computer is any machine device or apparatus that processes data according to computer readable instructions that are stored on a computer readable medium either temporarily or permanently. An operating system is a software component of a computer system that manages and coordinates the performance of tasks and the sharing of computing and hardware resources. A software process also referred to as software an application computer software a computer application a program and a computer program is a set of instructions that a computer can interpret and execute to perform one or more specific tasks. A software process may have one or more threads of execution. A shared software process is a software process whose output is shared with a viewer network node. A computer data file is a block of information that durably stores data for use by a software application.

A database is an organized collection of records that are presented in a standardized format that can be searched by computers. A database may be stored on a single computer readable data storage medium on a single computer or it may be distributed across multiple computer readable data storage media on one or more computers.

A data sink referred to herein simply as a sink is any of a device e.g. a computer part of a device or software that receives data.

A data source referred to herein simply as a source is any of a device e.g. a computer part of a device or software that originates data.

A network node also referred to simply as a node is a junction or connection point in a communications network. Exemplary network nodes include but are not limited to a terminal a computer and a network switch. A server network node is a host computer on a network that responds to requests for information or service. A client network node is a computer on a network that requests information or service from a server. A network connection is a link between two communicating network nodes. The term local network node refers to a network node that currently is the primary subject of discussion. The term remote network node refers to a network node that is connected to a local network node by a network communications link. A connection handle is a pointer or identifier e.g. a uniform resource identifier URI that can be used to establish a network connection with a communicant resource or service on a network node. A sharer network node is a network node that is sharing content with another network node which is referred to as a viewer network node. A network communication can include any type of information e.g. text voice audio video electronic mail message data file motion data stream and data packet that is transmitted or otherwise conveyed from one network node to another network node over a network connection.

A communicant interaction is any type of direct or indirect action or influence between a communicant and another network entity which may include for example another communicant a virtual area or a network service. Exemplary types of communicant interactions include communicants communicating with each other in realtime a communicant entering a virtual area and a communicant requesting access to a resource from a network service.

 Presence refers to the ability and willingness of a networked entity e.g. a communicant service or device to communicate where such willingness affects the ability to detect and obtain information about the state of the entity on a network and the ability to connect to the entity 

A realtime data stream is data that is structured and processed in a continuous flow and is designed to be received with no delay or only imperceptible delay. Realtime data streams include digital representations of voice video user movements facial expressions and other physical phenomena as well as data within the computing environment that may benefit from rapid transmission rapid execution or both rapid transmission and rapid execution including for example avatar movement instructions text chat realtime data feeds e.g. sensor data machine control instructions transaction streams and stock quote information feeds and file transfers.

A virtual area also referred to as an area or a place is a representation of a computer managed space or scene. Virtual areas typically are one dimensional two dimensional or three dimensional representations although in some embodiments a virtual area may correspond to a single point. Oftentimes a virtual area is designed to simulate a physical real world space. For example using a traditional computer monitor a virtual area may be visualized as a two dimensional graphic of a three dimensional computer generated space. However virtual areas do not require an associated visualization to implement switching rules. A virtual area typically refers to an instance of a virtual area schema where the schema defines the structure and contents of a virtual area in terms of variables and the instance defines the structure and contents of a virtual area in terms of values that have been resolved from a particular context.

A virtual area application also referred to as a virtual area specification is a description of a virtual area that is used in creating a virtual environment. The virtual area application typically includes definitions of geometry physics and realtime switching rules that are associated with one or more zones of the virtual area.

A virtual environment is a representation of a computer managed space that includes at least one virtual area and supports realtime communications between communicants.

A zone is a region of a virtual area that is associated with at least one switching rule or governance rule. A switching rule is an instruction that specifies a connection or disconnection of one or more realtime data sources and one or more realtime data sinks subject to one or more conditions precedent A switching rule controls switching e.g. routing connecting and disconnecting of realtime data streams between network nodes communicating in the context of a virtual area. A governance rule controls a communicants access to a resource e.g. an area a region of an area or the contents of that area or region the scope of that access and follow on consequences of that access e.g. a requirement that audit records relating to that access must be recorded . A renderable zone is a zone that is associated with a respective visualization.

A position in a virtual area refers to a location of a point or an area or a volume in the virtual area. A point typically is represented by a single set of one dimensional two dimensional or three dimensional coordinates e.g. Cartesian coordinates polar coordinates or spherical coordinates that define a spot in the virtual area. A coordinate can be defined as any single or plurality of numbers that establish location. An area typically is represented by the three dimensional coordinates of three or more coplanar vertices that define a boundary of a closed two dimensional shape in the virtual area. A volume typically is represented by the three dimensional coordinates of four or more non coplanar vertices that define a closed boundary of a three dimensional shape in the virtual area.

A spatial state is an attribute that describes where a user has presence in a virtual area. The spatial state attribute typically has a respective value e.g. a zone ID value for each of the zones in which the user has presence.

A placemark is a stored reference e.g. a hyperlink to a location in a virtual area. A placemark typically can be selected to present a view of the associated location in the virtual area to a user. The verb placemark means the act or operation of creating a placemark.

In the context of a virtual area an object is any type of discrete element in a virtual area that may be usefully treated separately from the geometry of the virtual area. Exemplary objects include doors portals windows view screens and speakerphone. An object typically has attributes or properties that are separate and distinct from the attributes and properties of the virtual area. An avatar is an object that represents a communicant in a virtual area.

The term double click refers to the act or operation of entering or inputting an execution command e.g. double clicking the left computer mouse button or by single clicking a user interface button associated with an execute command e.g. enter zone or view object . The term shift click refers to the act or operation of entering or inputting a selection command e.g. clicking the left computer mouse button while the Shift key of an alphanumeric input device is activated. The term shift double click refers to the act or operation of entering or inputting an execution command while the Shift key of an alphanumeric input device is activated.

As used herein the term includes means includes but not limited to the term including means including but not limited to. The term based on means based at least in part on.

The embodiments that are described herein enable application sharing with high fidelity realtime performance viewer immersion and privacy protection. In some embodiments the screen content that is associated with each thread of a software process can be determined and composited into a respective composite image or frame that is free of other window content. The contents of the windows that are associated with one or more software application threads on a network node can be broadcasted to other network nodes without risk of obscuration by the screen content e.g. windows containing application content messages or dialog boxes that might be generated by other software processes thereby preventing corruption of shared window content by overlapping screen content that sometimes is generated by processes that are outside of the user s immediate control. This feature avoids the need for sharers to interrupt a presentation in order to remove obscuring screen content thereby creating a more immersive collaboration experience for viewers of the shared window content. In addition sharers don t have to worry that private information inadvertently will be shared along with the intended screen content thereby maintaining the sharer s privacy.

Some embodiments also enable multichannel application sharing in which two or more communicants share applications and screen content with each other at the same time. These embodiments typically include an interface that allows each receiver to distinguish one shared window from another.

Embodiments of the communications application may implement one or more of the following application sharing modes 

In accordance with the method of the communications application identifies ones of the windows that are associated with a software process in a screen layout on a display of the sharer network node block . In some embodiments the communications application may identify all of the windows in the screen layout that are associated with the software process or it may identify ones of the windows in the screen layout that match a handle that is assigned to a thread of the software process. In some cases this process involves identifying a parent window and at least one associated child window that are created by the software process thread. In some embodiments the communications application identifies all of the windows created by a designated group of software processes.

The communications application generates a composite image of the identified windows as they are arranged in the screen layout and free of obscuration by any other windows in the screen layout block . In some embodiments this process involves determining a layering order of the identified windows in relation to each other that corresponds to the relative layering order of the identified windows in the screen layout for each of the identified windows retrieving a respective image of the window and compositing the retrieved images into the composite image in accordance with the determined layering order. In some embodiments the process of determining the layering order involves for each of the windows in the screen layout generating a z order list that associates a respective z order value with a respective window handle of the window and deriving the layering order of the identified windows from the z order list The process of deriving the layering order typically involves for each of the z order values in the z order list matching the associated window handle with the window handle of a respective one of the identified windows and ordering the identified windows in the layering order in accordance with the respective z order values in the z order list associated with the ones of the z order values determined to match the window handles of the identified windows.

In addition to preventing obscuration by other windows some embodiments also prevent obscuration of the selected windows as a result of the windows being partially or completely off screen e.g. outside the visible desktop window that contains the screen layout . For example a respective image of each of the identified windows is stored in a respective memory buffer and the process of generating the composite image involves retrieving each of the images from the respective memory buffers and compositing the retrieved images into the composite image. For example in some exemplary embodiments each of the windows is a layered window whose screen data is stored in a respective memory buffer through a programmatic call to the Microsoft Win32 application programming interface API which is available in Microsoft Windows operating systems versions 2000 and later. These operating systems provide an extended window style that is invoked by setting the WS EX LAYERED window style bit. The WS EX LAYERED style bit that is associated with a particular window may be set by the shared software process at window creation time e.g. via the CreateWindowEx API call or it may be set by the communications application after creation time e.g. via SetWindowLong API call with GWL EXSTYLE . With the WS EX LAYERED window style bit set for a window the operating system redirects the drawing of the window into an off screen bitmap and buffer which can then be accessed by the communications application for generating the composite image. Similar layered windows functionality is available from other operating systems e.g. X Windows on a UNIX based operating system .

After the composite image has been generated the communications application transmits the composite image to the viewer one of the first and second network nodes i.e. the one of the first and second network nodes that receives the composite image block . In some embodiments this process involves transmitting the composite image to each of the remote viewer network nodes that requested or subscribed to to view the shared content on the sharer network node. The composite image and subsequent updates is transmitted to the subscribing viewer network nodes over respective realtime data stream connections that are established between the sharer network node and the viewer network nodes.

In some embodiments application sharing is initiated after a sharer network node has published one or more applications or documents that are available to share and at least one viewer has subscribed to at least one of the published applications or documents. In some embodiments the sharer can publish a shared application or document to a viewscreen object that is associated with a virtual area and the viewer can subscribe to the shared content by activating the viewscreen object in the virtual area e.g. by double clicking on the viewscreen object with a user input device .

The viewer typically is granted one of two types of access to the shared content view access which allows the viewer to only passively view the shared content and control access which allows the viewer to view control edit and manipulate the shared content. The type of access that is granted to the viewer can be set by the sharer or by one or more governance rules that are associated with the context in which the sharing takes place e.g. a governance rule that is associated with a zone of a virtual area as described below in section IV .

The shared content typically is streamed from the sharer network node to the viewer network node in the form of streaming bitmaps of the windows on the sharers display that are associated with the shared application or document The bitmap of each window can be streamed separately or already composited. The bitmaps typically are compressed before being streamed. If the viewer has only view access then the viewer can only passively view images of the shared windows on the sharers display. If the viewer has control access then the viewer network node can transmit remote control commands that are generated by a user input device e.g. a keyboard a computer mouse a touchpad and a touch screen to the sharer network node for controlling editing and manipulating the shared content on the sharers network node.

In some embodiments the application sharing functionality of the communications application is provided by a Scraper module which is a plug in for an Application Sharing Service that implements a platform specific part of the application sharing. This embodiment implements the application sharing mode in which all windows created by a shared application automatically are shared with subscribing network nodes. This section describes an exemplary embodiment of the Scraper module and the Application Sharing Service that are implemented in a Microsoft Windows application environment that provides layered windows functionality.

Before Application Sharing Service calls any method on the Scraper module it calls the start method and during shutdown it calls the stop method. In the illustrated embodiment no calls can be made before the start method was called and after the stop method was called.

In the start method the Scraper module starts the thread that listens for WinEvents. The Scraper module listens for WinEvents to get notifications when windows and menus are created destroyed and shown hidden.

In the stop method the Scraper module stops all the application monitors and then shuts down the thread that is listening for WinEvents.

When a WinEvent notification is received the Scraper module gets the thread identifier ID and the process ID for the window. The Scraper module then looks up a monitor by the process ID and notifies the application monitor about the event. In response to a notification that a window was destroyed the Scraper module notifies all of the application monitors of the event since the process and thread IDs are not available.

As shown in the Application Sharing Service can request the Scraper module to provide a list of applications that can be shared. In response the Scraper module builds up the list of IDs and titles of the topmost overlapped windows on the desktop that is presented on the display of the sharer network node. In the illustrated embodiments the list is built from the processes that currently are running on the sharer network node. In other embodiments the list also includes the processes that can be running on the node. This for instance might include all Microsoft Word documents that the sharer might want to share but currently are not running or another application e.g. a calculator application that the sharer might want to share but currently is not running.

Referring to when the Application Sharing service starts sharing an application the Scraper module creates an instance of the application monitor that will be responsible for scraping the application windows. The application monitor enumerates all topmost windows on the desktop. The application monitor uses the result of this enumeration as an initial list of the windows. The application monitor determines which windows in the initial list belong to the application being shared. The application monitor then spawns a scraper thread. The scraper thread is responsible for scraping content of the application windows composing all the application s windows to the final bitmap and sending the bitmap frame to all the subscribing network nodes.

Referring to stopping application sharing takes care of gracefully stopping application monitor. In this process the application monitor will shutdown the scraping thread which makes sure that no more samples are produced. After that it notifies all the subscribing network nodes that they are unsubscribed. Once all the references to the application monitor are gone the monitor will be destroyed.

Referring to the subscribe method expects as parameters a reference to a subscriber and an ID of the process to share. The subscriber is a class see that implements stream subscriber itf as shown in the class model shown in . The Scraper module finds the monitor by the application ID and adds the subscriber to the monitor. The next time the application monitor generates a frame it will deliver the frame to this subscriber as well.

Referring to the subscribe method expects as parameters a reference to a subscriber and ID of the process to share. This method finds the shared application by ID and tells it to remove the referenced subscriber. On removing the referenced subscriber the application monitor will notify the subscriber about the state change. The application monitor also checks shared process state and if the process exits then application monitor will notify all the subscribers about the state change unsubscribe all the subscribers and will terminate itself since there is nothing to monitor.

Each application monitor has a thread that wakes up on a periodic basis and performs window scraping.

In accordance with the method of the Scraper module determines the z order of all the windows that are associated with a shared software process and arranges all the windows according to the z order block .

The scraper module determines a bounding rectangle that encompasses all the windows that are associated with the shared software process block . For example shows a screen layout that includes a Microsoft Word main window and a Save As dialog box . The Scraper module calculates the rectangle which is the smallest bounding box that encompasses both windows including any off screen content e.g. the shaded area that corresponds to the bottom of the main window that is outside the visible desktop window . The bounding rectangle defines the size of the composite bitmap of all the windows to be shared.

For each of the windows that are associated with the shared software process the Scraper module calls a scrape function block . If the window is not a layered window block the scrape function sets the WS EX LAYERED bit that is associated with the window via the SetWindowLong API call with GWL EXSTYLE block . The scrape function then scrapes the layered window block . In this process the scraper module retrieves images of the windows including the parts that are obscured by other windows or is outside the visible desktop window e.g. the shaded area shown in and paints the retrieved images into the composite image. The windows are scraped according to the z order so the topmost window is painted on top of all the window images in the final composite image. After the scraper module has estimated the bounding rectangle the scraper module captures a screen image of the shared windows. In a Microsoft Windows application environment for each of the windows the Scraper module makes a GetDC function call to GDI the graphics device interface that retrieves a handle to a display device context DC for the window. The Scraper module performs an iterative capturing of each window. In this process BitBlt is called for each window being shared and the image data of each window is superimposed in the target DC according to the relative positions in the x y and z axes of the windows in the screen display. The BitBlt function performs a bit block transfer of the image data corresponding to a block of pixels from the specified source device context into a destination device context. The screen image constitutes the initial composite image. Performing iterative BitBlt requests automatically filters out screen data from unwanted windows and

allows individual window compressed bitmaps to be sent instead of just the compressed composited bitmap.

After completing the scraping process the Scraper module creates a device independent bitmap of the composite image block . The Scraper module then creates a sample from the bytes of the bitmap block . The sample is a bitmap in a temporal sequence of bitmaps that are captured. In some embodiments the sample is the current composite image. The current sample depicts how the shared application is displayed at current time. Successive samples give the viewers the perception that the shared application is not just a sequence of images but rather is a live application. Once sample is created the Application Sharing service presents the sample to all the subscribing network nodes one by one block . Samples typically are transmitted to the subscribing network nodes only if there has been a change in the composite image since the last sample was transmitted. The sample typically is compressed before being transmitted to the subscribing network nodes. The Scraper module then goes to sleep until the next scheduled time to scrape another image block . The Application Sharing service contemporaneously i.e. during the same period of time e.g. during the period between scraping cycles transmits the sample of the composite image to each of the subscribing remote network nodes.

The Scraper module starts with an initial list of all top level windows that are associated with the shared software process block . The initial list may be obtained from a previous iteration of the scraping process shown in . Alternatively the initial list may be obtained directly by querying the application environment For example in some embodiments the Scraper module is implemented in a Microsoft Windows application environment. In these embodiments each software process thread has an entry point function called WinMain which registers the window class for the main window by calling the RegisterClass function and creates the main window by calling the CreateWindowEx function. After creating a window the creation function returns a window handle that has the HWND data type and uniquely identifies the window the window handle is used to direct software process actions to the window. In these embodiments the Scraper module obtains a handle to each of the top level windows associated with the shared software process thread by calling the EnumWindows function which enumerates all the windows on the desktop and then query the process this window belongs to by calling GetWindowThreadProcessId.

The Scraper module determines a z order of all the windows that currently are associated with the shared software process block . When implemented in a Microsoft Windows application environment the Scraper module obtains a handle to each of the windows on the desktop window by calling the EnumChildWindows function which enumerates the child windows that belong to the desktop window in z order by passing the handle to each child window in turn to a callback function of the Scraper module. The Scraper module recursively iterates through all the windows on the desktop and identifies those windows that belong to the shared software application. In this process the Scraper module identifies the children of that desktop that correspond to the top level windows of the shared software application. For each of the matching top level windows the Scraper module calls a function that recursively iterates through the children of the matching top level window the function recursively calls itself.

The Scraper module sorts the initial list of top level windows that are associated with the software process according to the determined z order block .

The Scraper module appends to the sorted list any of the windows in the initial list of top level windows that are not included in the sorted list block . This step is used to cover any windows e.g. a window that was deleted after the sorting process started that might have been missed.

If the viewers have only view access then the Application Sharing Service on the sharer network node only transmits the composite images of the shared window content in the form of samples to the subscribing ones of the viewer network nodes. The viewers on the viewer network nodes can only passively view the composite images of the shared windows on the sharers display.

If the viewers have control access on the other hand then the Application Sharing Service on the sharer network node transmits the composite images of the shared window content in the form of samples to the subscribing ones of the viewer network nodes. In addition the Scraper module combines commands that are received from the viewer network nodes with the commands that are generated by the sharer on the sharer network node and passes the combined set of commands to the shared application. This allows the viewers to control edit and manipulate the shared application on the sharer network node. The commands typically are derived from events that are generated by one or more user input devices e.g. a keyboard a computer mouse a touchpad and a touch screen on the viewer and sharer network nodes.

The display processes provide the display facilities of the sharer network node and the viewer network node respectively. The display facilities control the writing of visual contents on the sharer and viewer displays . In some embodiments the display facilities include a graphic device interface e.g. the GDI available in Microsoft Windows application environments that provides functions that can be called by software processes in order to present visual content on the displays .

The network layers provide the networking facilities of the sharer network node and the viewer network node respectively. The network facilities include for example networking communications protocol stacks and networking hardware that perform processes associated with sending and receiving information over the network .

The communications applications respectively provide various communications facilities including application sharing facilities to the sharer network node and the viewer network node . In the illustrated embodiment the communications application on the sharer network node generates a composite image of the shared window content on the sharer s display transmits the composite image over the network to the viewer network node for presentation on the viewer s display and grants the viewer remote control access to the shared window content . The communications application on the viewer network node controls the presentation of the composite image on the display transforms user input into commands and transmits the commands to the sharer network node .

In accordance with the method of the communications application on the sharer network node captures a composite image of the windows that are associated with the shared software process block . In some embodiments the window scraping process described above is used to capture the composite image. The communications application transmits the composite image to the viewer network node block . In this process the communications application passes a sample of the composite image to the network layer which converts the sample into a network format and transmits the converted sample to the viewer network node over the network .

The communications application receives commands that are derived from local input device events generated on the sharer network node block . Contemporaneously the communications application receives commands that are derived from remote input device events that are generated on the viewer network node block . In this context the commands are directives or instructions to perform tasks where the directives or instructions are derived from interpretations of input device events that are initiated by user actions or inputs on one or more input devices e.g. clicking one or more buttons of a computer mouse or keys of a computer keyboard . Some pointer input device events such a computer mouse touch pad and touch screen events are tied to the position of a pointer or cursor in graphical user interface that is presented on a display. These types of input device events typically are converted into commands that include both an input type parameter value that describes the type of input e.g. left click right click left button double click scroll wheel etc. and a location parameter value that describes where the input was entered with respect to a context dependent coordinate system.

The operating systems on the sharer and viewer network nodes typically convert the pointer input device events into user commands where the location parameter values are defined with respect to the coordinate system of the main window of the graphical user interface e.g. the desktop window in a Microsoft Windows application environment . The sharer s input commands that are received by the communications application block are the operating system generated user commands these commands also are used to control the operation of user mode software processes e.g. the shared process on the sharer network node . The viewers input commands that are received by the communications application block on the other hand typically are versions of the operating system generated user input commands. In particular before transmitting the viewer commands to the sharer network node the communications application on the viewer network node remaps the location parameter values in the operating system generated commands from the coordinate system of the main window of the graphical user interface on the display to a coordinate system of the composite image . For example in the illustrated embodiment the location parameter values are remapped to a coordinate system that has an origin 0 0 at the upper left corner of the composite image and has x and y axes that extend along the bottom and left edges of the composite image .

The communications application processes the received commands into a command sequence block . In this process the communications application typically remaps the location parameter values in the viewer s commands from the coordinate system of the composite image to the coordinate system of the main window of the graphical user interface on the display . The communications application then arranges the received commands into a sequence in order of time of receipt and stores the resulting sequence of commands into a memory buffer.

The communications application passes the command sequence to the shared process block . In this process for each command the communications application typically invokes Win32 API functions that allows it to specify a window that Windows will send the command to.

The shared process calls one or more graphical device interface functions that are provided by the display process to present the windows that are associated with the shared software process on the sharer display in accordance with the received command sequence block .

In some embodiments the network infrastructure service environment manages sessions of the first and second client nodes in a virtual area in accordance with a virtual area application . The virtual area application is hosted by the virtual area and includes a description of the virtual area . The communications applications operating on the first and second client network nodes present respective views of the virtual area in accordance with data received from the network infrastructure service environment and provide respective interfaces for receiving commands from the communicants. The communicants typically are represented in the virtual area by respective avatars which move about the virtual area in response to commands that are input by the communicants at their respective network nodes. Each communicants view of the virtual area 32 typically is presented from the perspective of the communicants avatar which increases the level of immersion experienced by the communicant. Each communicant typically is able to view any part of the virtual area around his or her avatar. In some embodiments the communications applications establish realtime data stream connections between the first and second client network nodes and other network nodes sharing the virtual area based on the positions of the communicants avatars in the virtual area .

The network infrastructure service environment also maintains a relationship database that contains records of interactions between communicants. Each interaction record describes the context of an interaction between a pair of communicants.

The network may include any of a local area network LAN a metropolitan area network MAN and a wide area network WAN e.g. the internet . The network typically includes a number of different computing platforms and transport facilities that support the transmission of a wide variety of different media types e.g. text voice audio and video between network nodes.

The communications application see typically operates on a client network node that includes software and hardware resources which together with administrative policies user preferences including preferences regarding the exportation of the user s presence and the connection of the user to areas and other users and other settings define a local configuration that influences the administration of realtime connections with other network nodes. The network connections between network nodes may be arranged in a variety of different stream handling topologies including a peer to peer architecture a server mediated architecture and hybrid architectures that combine aspects of peer to peer and server mediated architectures. Exemplary topologies of these types are described in U.S. application Ser. Nos. 11 923 629 and 11 923 634 both of which were filed on Oct. 24 2007.

The network infrastructure service environment typically includes one or more network infrastructure services that cooperate with the communications applications in the process of establishing and administering network connections between the client nodes and other network nodes see . The network infrastructure services may run on a single network node or may be distributed across multiple network nodes. The network infrastructure services typically run on one or more dedicated network nodes e.g. a server computer or a network device that performs one or more edge services such as routing and switching . In some embodiments however one or more of the network infrastructure services run on at least one of the communicants network nodes. Among the network infrastructure services that are included in the exemplary embodiment of the network infrastructure service environment are an account service a security service an area service a rendezvous service and an interaction service.

The account service manages communicant accounts for the virtual environment. The account service also manages the creation and issuance of authentication tokens that can be used by client network nodes to authenticate themselves to any of the network infrastructure services.

The security service controls communicants access to the assets and other resources of the virtual environment. The access control method implemented by the security service typically is based on one or more of capabilities where access is granted to entities having proper capabilities or permissions and an access control list where access is granted to entities having identities that are on the list . After a particular communicant has been granted access to a resource that communicant typically uses the functionality provided by the other network infrastructure services to interact in the network communications environment .

The area service administers virtual areas. In some embodiments the area service remotely configures the communications applications operating on the first and second client network nodes in accordance with the virtual area application subject to a set of constraints see . The constraints typically include controls on access to the virtual area. The access controls typically are based on one or more of capabilities where access is granted to communicants or client nodes having proper capabilities or permissions and an access control list where access is granted to communicants or client nodes having identities that are on the list .

The area service also manages network connections that are associated with the virtual area subject to the capabilities of the requesting entities maintains global state information for the virtual area and serves as a data server for the client network nodes participating in a shared communication session in a context defined by the virtual area . The global state information includes a list of all the objects that are in the virtual area and their respective locations in the virtual area. The area service sends instructions that configure the client network nodes. The area service also registers and transmits initialization information to other client network nodes that request to join the communication session. In this process the area service may transmit to each joining client network node a list of components e.g. plugins that are needed to render the virtual area on the client network node in accordance with the virtual area application . The area service also ensures that the client network nodes can synchronize to a global state if a communications fault occurs. The area service typically manages communicant interactions with virtual areas via governance rules that are associated with the virtual areas.

The rendezvous service manages the collection storage and distribution of presence information and provides mechanisms for network nodes to communicate with one another e.g. by managing the distribution of connection handles subject to the capabilities of the requesting entities. The rendezvous service typically stores the presence information in a presence database. The rendezvous service typically manages communicant interactions with each other via communicant privacy preferences.

The interaction service maintains the relationship database that contains the records of interactions between communicants. For every interaction between communicants one or more services of the network infrastructure service environment e.g. the area service transmit interaction data to the interaction service. In response the interaction service generates one or more respective interaction records and stores them in the relationship database. Each interaction record describes the context of an interaction between a pair of communicants. For example in some embodiments an interaction record contains an identifier for each of the communicants an identifier for the place of interaction e.g. a virtual area instance a description of the hierarchy of the interaction place e.g. a description of how the interaction room relates to a larger area start and end times of the interaction and a list of all files and other data streams that are shared or recorded during the interaction. Thus for each realtime interaction the interaction service tracks when it occurred where it occurred and what happened during the interaction in terms of communicants involved e.g. entering and exiting objects that are activated deactivated and the files that were shared.

The interaction service also supports queries on the relationship database subject to the capabilities of the requesting entities. The interaction service presents the results of queries on the interaction database records in a sorted order e.g. most frequent or most recent based on virtual area. The query results can be used to drive a frequency sort of contacts whom a communicant has met in which virtual areas as well as sorts of who the communicant has met with regardless of virtual area and sorts of the virtual areas the communicant frequents most often. The query results also may be used by application developers as part of a heuristic system that automates certain tasks based on relationships. An example of a heuristic of this type is a heuristic that permits communicants who have visited a particular virtual area more than five times to enter without knocking by default or a heuristic that allows communicants who were present in an area at a particular time to modify and delete files created by another communicant who was present in the same area at the same time. Queries on the relationship database can be combined with other searches. For example queries on the relationship database may be combined with queries on contact history data generated for interactions with contacts using a communication system e.g. Skype Facebook and Flickr that is outside the domain of the network infrastructure service environment .

The communications application and the network infrastructure service environment typically administer the realtime connections with network nodes in a communication context that is defined by an instance of a virtual area. The virtual area instance may correspond to an abstract non geometric virtual space that is defined with respect to abstract coordinates. Alternatively the virtual area instance may correspond to a visual virtual space that is defined with respect to one two or three dimensional geometric coordinates that are associated with a particular visualization. Abstract virtual areas may or may not be associated with respective visualizations whereas visual virtual areas are associated with respective visualizations.

As explained above communicants typically are represented by respective avatars in a virtual area that has an associated visualization. The avatars move about the virtual area in response to commands that are input by the communicants at their respective network nodes. In some embodiments the communicants view of a virtual area instance typically is presented from the perspective of the communicants avatar and each communicant typically is able to view any part of the visual virtual area around his or her avatar increasing the level of immersion that is experienced by the communicant.

As explained in detail below the virtual area includes zones that are associated with respective rules that govern the switching of realtime data streams between the network nodes that are represented by the avatars in the virtual area . During a typical communication session the dashed lines demarcating the zones in are not visible to the communicants although there may be visual cues associated with such zone boundaries. The switching rules dictate how local connection processes executing on each of the network nodes establishes communications with the other network nodes based on the locations of the communicants avatars in the zones of the virtual area .

A virtual area is defined by a specification that includes a description of geometric elements of the virtual area and one or more rules including switching rules and governance rules. The switching rules govern realtime stream connections between the network nodes. The governance rules control a communicants access to resources such as the virtual area itself regions with the virtual area and objects within the virtual area. In some embodiments the geometric elements of the virtual area are described in accordance with the COLLADA Digital Asset Schema Release 1.4.1 April 2006 specification available from http www.khronos.org collada and the switching rules are described using an extensible markup language XML text format referred to herein as a virtual space description format VSDL in accordance with the COLLADA Streams Reference specification described in U.S. application Ser. Nos. 11 923 629 and 11 923 634.

The geometric elements of the virtual area typically include physical geometry and collision geometry of the virtual area. The physical geometry describes the shape of the virtual area. The physical geometry typically is formed from surfaces of triangles quadrilaterals or polygons. Colors and textures are mapped onto the physical geometry to create a more realistic appearance for the virtual area. Lighting effects may be provided for example by painting lights onto the visual geometry and modifying the texture color or intensity near the lights. The collision geometry describes invisible surfaces that determine the ways in which objects can move in the virtual area. The collision geometry may coincide with the visual geometry correspond to a simpler approximation of the visual geometry or relate to application specific requirements of a virtual area designer.

The switching rules typically include a description of conditions for connecting sources and sinks of realtime data streams in terms of positions in the virtual area. Each rule typically includes attributes that define the realtime data stream type to which the rule applies and the location or locations in the virtual area where the rule applies. In some embodiments each of the rules optionally may include one or more attributes that specify a required role of the source a required role of the sink a priority level of the stream and a requested stream handling topology. In some embodiments if there are no explicit switching rules defined for a particular part of the virtual area one or more implicit or default switching rules may apply to that part of the virtual area. One exemplary default switching rule is a rule that connects every source to every compatible sink within an area subject to policy rules. Policy rules may apply globally to all connections between the client nodes or only to respective connections with individual client nodes. An example of a policy rule is a proximity policy rule that only allows connections of sources with compatible sinks that are associated with respective objects that are within a prescribed distance or radius of each other in the virtual area.

In some embodiments governance rules are associated with a virtual area to control who has access to the virtual area who has access to its contents what is the scope of that access to the contents of the virtual area e.g. what can a user do with the contents and what are the follow on consequences of accessing those contents e.g. record keeping such as audit logs and payment requirements . In some embodiments an entire virtual area or a zone of the virtual area is associated with a governance mesh. In some embodiments a governance mesh is implemented in a way that is analogous to the implementation of the zone mesh described in U.S. application Ser. Nos. 11 923 629 and 11 923 634. A governance mesh enables a software application developer to associate governance rules with a virtual area or a zone of a virtual area. This avoids the need for the creation of individual permissions for every file in a virtual area and avoids the need to deal with the complexity that potentially could arise when there is a need to treat the same document differently depending on the context.

In some embodiments a virtual area is associated with a governance mesh that associates one or more zones of the virtual area with a digital rights management DRM function. The DRM function controls access to one or more of the virtual area or one or more zones within the virtual area or objects within the virtual area. The DRM function is triggered every time a communicant crosses a governance mesh boundary within the virtual area. The DRM function determines whether the triggering action is permitted and if so what is the scope of the permitted action whether payment is needed and whether audit records need to be generated. In an exemplary implementation of a virtual area the associated governance mesh is configured such that if a communicant is able to enter the virtual area he or she is able to perform actions on all the documents that are associated with the virtual area including manipulating the documents viewing the documents downloading the documents deleting the documents modifying the documents and re uploading the documents. In this way the virtual area can become a repository for information that was shared and discussed in the context defined by the virtual area.

Additional details regarding the specification of a virtual area are described in U.S. application Ser. No. 61 042 714 which was filed on Apr. 4 2008 Ser. No. 11 923 629 which was filed on Oct. 24 2007 and Ser. No. 11 923 634 which was filed on Oct. 24 2007 .

The local HIDs enable a communicant to input commands and other signals into the client network node while participating in a virtual area communications session. Exemplary HIDs include a computer keyboard a computer mouse a touch screen display and a microphone.

The audio playback devices enable a communicant to playback audio signals that are received during a virtual area communications session. Exemplary audio playback devices include audio processing hardware e.g. a sound card for manipulating e.g. mixing and applying special effects audio signals and speakers for outputting sounds.

The So3D engine is a three dimensional visualization engine that controls the presentation of a respective view of a virtual area and objects in the virtual area on a display monitor. The So3D engine typically interfaces with a graphical user interface driver and the HID devices to present the views of the virtual area and to allow the communicant to control the operation of the communications application .

In some embodiments the So3D engine receives graphics rendering instructions from the area service. The So3D engine also may read a local communicant avatar database that contains images needed for rendering the communicants avatar in the virtual area. Based on this information the So3D engine generates a visual representation i.e. an image of the virtual area and the objects in the virtual area from the point of view position and orientation of the communicants avatar in the virtual area. The visual representation typically is passed to the graphics rendering components of the operating system which drive the graphics rendering hardware to render the visual representation of the virtual area on the client network node.

The communicant can control the presented view of the virtual area by inputting view control commands via a HID device e.g. a computer mouse . The So3D engine updates the view of the virtual area in accordance with the view control commands. The So3D engine also updates the graphic representation of the virtual area on the display monitor in accordance with updated object position information received from the area service .

The system database and storage facility stores various kinds of information that is used by the platform. Exemplary information that typically is stored by the storage facility includes the presence database the relationship database an avatar database a real user id RUID database an art cache database and an area application database. This information may be stored on a single network node or it may be distributed across multiple network nodes.

A communicant typically connects to the network from a client network node. The client network node typically is implemented by a general purpose computer system or a dedicated communications computer system or console such as a network enabled video game console . The client network node executes communications processes that establish realtime data stream connections with other network nodes and typically executes visualization rendering processes that present a view of each virtual area entered by the communicant.

A communicant may interact e.g. input commands or data with the computer system using one or more input devices e.g. one or more keyboards computer mice microphones cameras joysticks physical motion sensors such Wii input devices and touch pads . Information may be presented through a graphical user interface GUI that is presented to the communicant on a display monitor which is controlled by a display controller . The computer system also may include other input output hardware e.g. peripheral output devices such as speakers and a printer . The computer system connects to other network nodes through a network adapter also referred to as a network interface card or NIC .

A number of program modules may be stored in the system memory including application programming interfaces APIs an operating system OS e.g. the Windows XP operating system available from Microsoft Corporation of Redmond Wash. U.S.A. the communications application drivers e.g. a GUI driver network transport protocols and data e.g. input data output data program data a registry and configuration settings .

In some embodiments the one or more server network nodes of the virtual environment creator are implemented by respective general purpose computer systems of the same type as the client network node except that each server network node typically includes one or more server software applications.

In other embodiments the one or more server network nodes of the virtual environment creator are implemented by respective network devices that perform edge services e.g. routing and switching .

Referring back to during a communication session each of the client network nodes generates a respective set of realtime data streams e.g. motion data streams audio data streams chat data streams file transfer data streams and video data streams . For example each communicant manipulates one or more input devices e.g. the computer mouse and the keyboard that generate motion data streams which control the movement of his or her avatar in the virtual area . In addition the communicants voice and other sounds that are generated locally in the vicinity of the computer system are captured by the microphone . The microphone generates audio signals that are converted into realtime audio streams. Respective copies of the audio streams are transmitted to the other network nodes that are represented by avatars in the virtual area . The sounds that are generated locally at these other network nodes are converted into real time audio signals and transmitted to the computer system . The computer system converts the audio streams generated by the other network nodes into audio signals that are rendered by the speakers . The motion data streams and audio streams may be transmitted from each of the communicant nodes to the other client network nodes either directly or indirectly. In some stream handling topologies each of the client network nodes receives copies of the realtime data streams that are transmitted by the other client network nodes. In other stream handling topologies one or more of the client network nodes receives one or more stream mixes that are derived from realtime data streams that are sourced or originated from other ones of the network nodes.

In some embodiments the area service maintains global state information that includes a current specification of the virtual area a current register of the objects that are in the virtual area and a list of any stream mixes that currently are being generated by the network node hosting the area service. The objects register typically includes for each object in the virtual area a respective object identifier e.g. a label that uniquely identifies the object a connection handle e.g. a URI such as an IP address that enables a network connection to be established with a network node that is associated with the object and interface data that identifies the realtime data sources and sinks that are associated with the object e.g. the sources and sinks of the network node that is associated with the object . The objects register also typically includes one or more optional role identifiers for each object the role identifiers may be assigned explicitly to the objects by either the communicants or the area service or may be inferred from other attributes of the objects or the user. In some embodiments the objects register also includes the current position of each of the objects in the virtual area as determined by the area service from an analysis of the realtime motion data streams received from the network nodes associated with objects in the virtual area. In this regard the area service receives realtime motion data streams from the network nodes associated with objects in the virtual area tracks the communicants avatars and other objects that enter leave and move around in the virtual area based on the motion data. The area service updates the objects register in accordance with the current locations of the tracked objects.

In the process of administering realtime data stream connections with other network nodes the area service maintains for each of the client network nodes a set of configuration data including interface data a zone list and the positions of the objects that currently are in the virtual area. The interface data includes for each object associated with each of the client network nodes a respective list of all the sources and sinks of realtime data stream types that are associated with the object. The zone list is a register of all the zones in the virtual area that currently are occupied by the avatar associated with the corresponding client network node. When a communicant first enters a virtual area the area service typically initializes the current object positions database with position initialization information. Thereafter the area service updates the current object positions database with the current positions of the objects in the virtual area as determined from an analysis of the realtime motion data streams received from the other client network nodes sharing the virtual area.

In addition to the local Human Interface Device HID and audio playback devices the So3D graphical display avatar and physics engine and the system database and storage facility the communications application also includes a graphical navigation and interaction interface referred to herein as a seeker interface that interfaces the user with the spatial virtual communication environment. The seeker interface includes navigation controls that enable the user to navigate the virtual environment and interaction controls that enable the user to control his or her interactions with other communicants in the virtual communication environment. The navigation and interaction controls typically are responsive to user selections that are made using any type of input device including a computer mouse a touch pad a touch screen display a keyboard and a video game controller. The seeker interface is an application that operates on each client network node. The seeker interface is a small lightweight interface that a user can keep up and running all the time on his or her desktop. The seeker interface allows the user to launch virtual area applications and provides the user with immediate access to realtime contacts and realtime collaborative places or areas . The seeker interface is integrated with realtime communications applications and or realtime communications components of the underlying operating system such that the seeker interface can initiate and receive realtime communications with other network nodes. A virtual area is integrated with the users desktop through the seeker interface such that the user can upload files into the virtual environment created by the virtual environment creator use files stored in association with the virtual area using the native client software applications independently of the virtual environment while still present in a virtual area and more generally treat presence and position within a virtual area as an aspect of their operating environment analogous to other operating system functions rather than just one of several applications.

The spatial virtual communication environment typically can be modeled as a spatial hierarchy of places also referred to herein as locations and objects. The spatial hierarchy includes an ordered sequence of levels ranging from a top level to a bottom level. Each of the places in a successive one of the levels of the spatial hierarchy is contained in a respective one of the places in a preceding one of the levels. Each of the objects in the spatial hierarchy is contained in a respective one of the places. The levels of the spatial hierarchy typically are associated with respective visualizations that are consistent with a geographical architectural or urban metaphor and are labeled accordingly. The zones of each virtual area are defined by respective meshes some of which define elements of a physical environment e.g. spaces such as rooms and courtyards that are associated with a building that may contain objects e.g. avatars and props such as view screen objects and conferencing objects .

The navigational controls of the seeker interface allow the user to traverse a path through the virtual environment in accordance with a navigational model that is tied to the underlying spatial hierarchy of places and objects. The network infrastructure service environment records the path traversed by the user. In some embodiments the network infrastructure service environment records a history that includes a temporally ordered list of views of the virtual area that are presented to the user as the user navigates through the virtual area. Each view typically corresponds to a view of a respective renderable zone of the virtual area. In these embodiments the navigation controls enable the user to move to selected ones of the zones in the history. The navigation controls also include a graphical representation of a depth path that shows the location in the spatial hierarchy that corresponds to the users current view of the virtual area. In some embodiments the graphical representation of the depth path includes a respective user selectable link to a respective view of each of the preceding levels in the spatial hierarchical model of the virtual area above the current view.

The interaction controls of the seeker interface allow the user to manage interactions with other communicants. The interaction options that available to the user typically depend on the zones in which the user has a presence. In some embodiments the interaction options that are available to communicants who have presence in a particular zone are different from the options that are available to other communicants who do not have presence in that zone. The level of detail and interactivity of the user typically depend on whether or not the user has a presence the particular zone. In one exemplary embodiment if the user is outside the virtual area the user is provided with a minimal level of detail of the interactions occurring within the virtual area e.g. the user can see an outline of the floorplan background textures and plants of the area but the user cannot see where other communicants are present in the area if the user is within the virtual area but outside a particular zone of the area the user is provided with a medium level of detail of the interactions occurring within the particular zone e.g. the user can see where other communicants are present in the area see a visualization of their current states talking typing a chat message whether or not their headphones and microphones are turned on and see whether any of the view screens are active if the user is within the particular zone of the area the user is provided with full level of detail of the interactions occurring with the particular zone e.g. the user can see a thumbnail of the file being shared on a view screen hear and speak with other communicants in the area and see elements of a log of chat messages that were generated by communicants in the zone . In some embodiments the switching and governance rules that are associated with the zones of the virtual area control how the network infrastructure services distinguish between those who have presence in the particular zone from those who do not.

Each of the tabs typically is associated with a respective view of the virtual environment. In the illustrated embodiment the view presented in the table labeled My Areas is associated with a respective set of virtual areas which may be a default set of virtual areas in the virtual environment or it may be a set of virtual areas that is identified by a respective filter on the interaction database. In particular the tab is associated with a set of three virtual areas i.e. Acme Sococo Help Area and Personal Space which may be a default set of areas that are associated with the user or may be identified by a filter that identifies all of the areas that are associated with the user e.g. all of the areas in which the user has interacted . Additional tabs may be created by selecting the button .

The browsing area of each tab shows graphic representations of the elements of the virtual environment that are associated with the tab. For example in the illustrated embodiment the browsing area shows top level views of the virtual areas that are associated with the tab . The user may navigate to the next lower level in the spatial hierarchical model of any of the virtual areas by selecting the corresponding graphic representation of the virtual area.

The toolbar includes an adaptive set of navigational and interaction tools that automatically are selected by the seeker interface based on the current location of the user in the virtual environment In the illustrated embodiment the toolbar includes a back button a forward button a placemarks button and a home button . The back button corresponds to a backward control that enables the user to incrementally move backward to preceding ones of the zones in the history of the zones that were traversed by the user. The forward button corresponds to a forward control that enables the user to incrementally move forward to successive ones of the zones in the history of the zones that were traversed by the user. The placemarks button provides a placemarking control for storing links to zones and a placemark navigation control for viewing a list of links to previously placemarked zones. In response to a user selection of the placemarking control a placemark is created by storing an image of the location shown in the current view in association with a hyperlink to the corresponding location in the virtual area. In response to a user selection of the placemark navigation control a placemarks window is presented to the user. The placemarks window includes live visualizations of all locations that have been placemarked by the user. Each of the images in the placemarks window is associated with a respective user selectable hyperlink. In response to user selection of one of the hyperlinks in the placemarks window a view of the virtual area corresponding to the location associated with the selected hyperlink is automatically displayed in the browsing area of the seeker interface window . The home button corresponds to a control that returns the user to a view of a designated home location in the virtual environment e.g. the view shown in .

Referring to in response to a user selection of the graphic representation of the Acme virtual area shown in the platform moves the user into a default zone of the virtual area automatically establishes a presence for the user in the default zone and automatically establishes a network connection between the user and each of the other communicants occupying the selected zone. Based on the switching rules established by the area designer the platform multiplexes the specified realtime data streams e.g. streams from the microphones and speakers of all the communicants in default zone such that they can both see each others sprites or avatars and communicate with e.g. speak to and hear each other.

The seeker interface shows a top or floorplan view of the Acme virtual area in the browsing area of the tab and provides the user with a default set of interaction options. In the illustrated embodiment a presence automatically is established in a courtyard zone of the virtual area and the user s microphone and default speakers e.g. headphones are turned on. In the floorplan view shown in the user is represented by a circular sprite the other users in the Acme virtual area also are represented by respective circular sprites . The state of the user s speakers is depicted by the presence or absence of a headphones graphic on the user s sprite when the speakers are on the headphones graphic is present and when the speakers are off the headphones graphic is absent. The state of the user s microphone is depicted by the presence or absence of a microphone graphic on the user s sprite and a series of concentric circles around the user s sprite when the microphone is on the microphone graphic and the concentric circles are present and when the microphone is off the microphone graphic and the concentric circles are absent The headphones graphic the concentric circles and the microphone graphic serve as visual reminders of the states of the users sound playback and microphone devices.

In addition to the backward button the forward button the placemarks button and the home button the toolbar also includes a series of one or more breadcrumb buttons that originate from and include the home button . The breadcrumb buttons correspond to a hierarchical sequence of successive user selectable links. Each of the successive links corresponds to a view of a respective level in the hierarchical model of the virtual area in which each successive level is contained by preceding ones of the levels. In the illustrated embodiment the breadcrumb buttons include the home button and an Acme button that corresponds to the current view of the Acme virtual area shown in . The breadcrumb buttons provide the user with single button selection access to respective views of different levels of the virtual environment. The toolbar additionally includes a button and a settings button .

When an area is selected or in focus the button appears as an iconographic representation of two people and is labeled members and allows members and moderators to see the list of people associated with an area. When an audio or chat zone is in focus the button has a different image e.g. an image of an arrow pointing downward onto a plane to represent the operation of getting and is labeled get . In response to a user selection of the button a list of all the members of the Acme virtual area is displayed in a user interface. The user may select any of the communicants in the list and click a get button that is presented in the user interface in response the platform transmits an invitation to the selected communicant to join the user in a designated one of the zones.

The settings button provides the user with access to a set of controls for specifying default settings that are associated with the current area.

The user may navigate from the view of the Acme virtual area shown in back to the view shown in in a variety of different ways. For example the user may select any of the back button the home button or any part of the zone that is outside the boundary of the graphic representation of the Acme virtual area shown in .

The user may navigate to any of the zones of the Acme virtual area. In some embodiments in order to move to a zone the user transmits a command to execute one of the zones displayed on the monitor e.g. by selecting the zone and then clicking the Enter button in the toolbar or as a shortcut double clicking the zone and in response the platform depicts the user s avatar in the zone corresponding to the zone object. In response to the zone execution command the seeker interface outlines the zone indicating to the user that it is selected and updates the breadcrumb buttons to show the selected zone location in the hierarchy. Toolbar buttons specific to the selection will also appear to the right of the breadcrumb buttons .

The user also may interact with any objects e.g. a screen table or file that are present in a zone. In some embodiments in order to interact with an object the user transmits a command to execute one of the objects displayed on the monitor e.g. by selecting the object and then clicking the View button in the toolbar or as a shortcut double clicking the object and in response the platform performs an operation with respect to the object e.g. present a zoomed in view of the object open an interaction interface window etc. . In response to the object execution command the seeker interface outlines or otherwise highlights the prop indicating to the user that it is selected and updates the breadcrumb buttons to show the selected object location in the hierarchy. Toolbar buttons specific to the selection will also appear to the right of the breadcrumb buttons .

Referring to in some embodiments in response to the user entering a Main space the platform automatically establishes a network connection between the user and each of the other communicants occupying the selected zone. The user also may enter and thereby establish a presence in a space by selecting the space and clicking the Enter button this causes the platform to move the user s sprite from its current location i.e. Courtyard to the selected space i.e. Main . The settings of user s speakers and microphone typically do not change when the user is moved from one location to another.

In response to the user s command to execute the wall object the seeker interface presents in the browsing area of the tab a 2.5 dimensional view of the contents of the wall object and areas of the Main space surrounding the wall object . In the embodiment shown in the selected wall object corresponds to a North Wall of the Main space . The North Wall contains a pair of view screen objects labeled 2 and 3 respectively that are presented on the North Wall object . The view screen objects can be used to present the contents of data files that are associated with the North Wall of the Main space . The . dimensional view also shows a West Wall object and an East Wall object that are located on the left and right sides of the North Wall object respectively. Each of the West Wall object and the East Wall object includes a respective view screen object labeled 1 and 4 respectively that can be used to present the contents of respective data files.

The interface also shows in the minimap a view of the Main space and areas of the Acme space surrounding the Main space . The minimap also shows a highlighted view of the selected North Wall object in the Main space .

The breadcrumb buttons shown in the toolbar of the tab include a North Wall button that corresponds to the current level in the hierarchical spatial model of the virtual area. The toolbar includes a rotate left button and a rotate right button that allow the user to rotate the current view left and right by ninety degrees 90 so that the user can view the contents of different walls of the Main space in the central viewing area of the 2.5 dimensional view of the Main space . The user also can double click a different one of the walls that are shown in the minimap in order to change the contents that are presented in the central viewing area of the 2.5 dimensional view of the Main space .

Referring to in response to a user selection of the Share button or the Share link the seeker interface opens a separate Select Source interface window that allows the user to designate a data file whose contents will be shared on the view screen object as described above in section IV. The Select Source interface includes a text box for receiving a data file identifier e.g. a local data file storage path name or a Uniform Resource Identifier URI and a Browse button that enables the user to browse different locations for the data file identifier. The data file identifier may be located on the client node or another network node. The Select Source interface window also includes a favorites button that allows the user to browse a list of previously bookmarked files applications or URIs for the data file identifier.

Referring to after the user has selected a data file identifier in the Select Source interface the communications application generates a thumbnail image of the selected data file In some embodiments the Scraper module is invoked to capture the thumbnail image of the selected data file. In some embodiments the thumbnail image may be a sample of the main window of the shared application that is associated with the selected data file. The thumbnail image is displayed on the view screen object in both the browsing area and the minimap . In the illustrated embodiment the designated data file corresponds to a PowerPoint data file that contains a slide of a pie chart. The user can terminate the presentation of the data file on the view screen object by selecting the clear icon .

One or more viewers can subscribe to the windows of the shared application showing the contents of the selected data file by clicking or double clicking on the thumbnail image shown on the viewscreen object . Each viewer can view control edit and manipulate the shared window content presented on the viewscreen object subject to any governance rules that are associated with the selected data file or the zone containing the viewscreen object . If a viewer has control access to the shared window content the viewer can input commands to the shared process executing on the sharer network node by using one or more input devices on the viewer s network node as described above in section IV. Assuming that realtime performance can be achieved over the respective network connections between the sharer network node and the viewer network nodes the edits and other manipulations of the shared data file typically will appear to each of the collaborators as if they were made on the same network node.

The embodiments that are described herein enable application sharing with high fidelity realtime performance viewer immersion and privacy protection. Some embodiments also enable multichannel application sharing in which two or more communicants share applications and screen content with each other at the same time. These embodiments typically include an interface that allows each receiver to distinguish one shared window from another.

