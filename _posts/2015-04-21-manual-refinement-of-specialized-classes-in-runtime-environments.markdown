---

title: Manual refinement of specialized classes in runtime environments
abstract: While a runtime specializer may always be able to generate an automated specialized version of a generic class, in some cases an alternate form of user control over specialization may allow the use of automated specialization while also adding (or overriding) specialization-specific method implementations. In general, the set of members of a generic class may not change when the class is specialized. In other words, the same members may exist in the auto-specialized version as in the generic version. However, manual refinement of specialized classes may allow a developer to hand specialize a particular (possibly a better) representation and/or implementation of one or more methods of the specialized class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477450&OS=09477450&RS=09477450
owner: Oracle International Corporation
number: 09477450
owner_city: Redwood City
owner_country: US
publication_date: 20150421
---
This application claims benefit of priority to the following provisional application which is hereby incorporated by reference in its entirety Ser. No. 61 982 802 filed Apr. 22 2014 titled Specializing Parametric Types with Primitive Type Arguments.

This application is related to the following application which is hereby incorporated by reference in its entirety Ser. No. 14 660 143 filed Mar. 17 2015 titled Metadata driven Dynamic Specialization.

This application is related to the following application which is hereby incorporated by reference in its entirety Ser. No. 14 660 177 filed Mar. 17 2015 titled Structural Identification of Dynamically Generated Pattern Based Classes.

This application is related to the following application which is hereby incorporated by reference in its entirety Ser. No. 14 660 604 filed Mar. 17 2015 titled Decomposing a Generic Class into Layers.

The present invention relates generally to software development and more specifically to various aspects of language development within any of various programming languages such as a platform independent object oriented programming language as one example.

In various programming languages parametric polymorphism e.g. generics may be considered as a way to make a language more expressive while still maintaining full static type safety. Parametric polymorphism may allow a function or a data type to be written in a generic fashion such that it can handle various data types in the same manner regardless of their different types. Such functions and data types may be called generic functions and generic datatypes. For example a generic list class may be written List which means that it can be a list of elements of any type T where T is specified separately from the specification of List.

Frequently when using object oriented languages that do not provide a single type which can be a supertype for all other types one cannot generify over certain types without using particular conversion operations such as boxing e.g. automatically converting a value of a primitive type like int into an object of a corresponding wrapper class like Integer . For example traditionally the Java language does not allow generics over both objects and primitives.

Parametric polymorphism generics may also involve a tradeoff between code size generation costs and type specificity. For example a programming language may support primitive specialized generics but may generates specialized classes statically thereby at potentially increased cost to code footprint and compilation cost. Another programming language may generate a specialized instantiation of templates for each instantiation used by the program which may result in a large static footprint. Yet a third language may use a templatized bytecode format only performing specialization to runtime which may require an additional step before using a generic class file thereby potentially harming runtime performance.

While a runtime specializer may always be able to generate an automated specialized version of a generic class in some cases an alternate form of user control over specialization may be utilized. For instance the use of automated specialization may be used while also allowing the use of specialization specific method implementations. Generally the set of members of a generic class may not change when the class is specialized. In other words the same members may exist in the auto specialized version as in the generic version. However manual refinement of specialized classes may allow a developer to hand specialize a particular possibly a better representation and or implementation of one or more methods of the specialized class.

Manual refinement of specialized class may include utilizing different versions of method to override existing or auto specialized versions of the methods. Additionally manual refinement may also include including additional methods in a specialized class only for particular and not other type parameterizations. Thus a refinement method may be included in a specialized class only when the corresponding generic class is specialized for a particular type parameterization.

For example a generic class List may be generic in any T and the auto specialized versions of List may include all the fields and methods of the generic version but if List is specialized for T int a new version of a particular one of the class methods may also be included in the specialized class. Thus if List is specialized for T int the hand specialized version of the method may be used in place of the auto specialized version according to some embodiments.

Described herein are various embodiments of enhancements to software development using a platform independent object oriented language such as the Java programming language to support various features related to specialization of generic types classes and methods.

For instance the loading or operation of a specialized class may trigger the specialization of other classes. For example if a first class extends a particular superclass the specialization of the first class may trigger the specialization of the superclass. Additionally specializing a class may trigger the specialization of various classes used internally as part of the implementation of the class. According to one embodiment a compiler may be configured to recognize dependency relationships between generic classes and to describe the classes in terms of the type variables of the triggering types e.g. the types and or type parameterizations that trigger the specialization of other classes based on the specialization of a first class.

A compiler may include references e.g. structural references indicating dependency relationships between classes when generating class files. For instance in one embodiment a compiler may be configured to write out e.g. to a class file a description of a generic supertype in terms of a type variable of the generic subtype. Thus in some embodiments the class file may include information e.g. metadata and or a description indicating a dependency relationship between a class and another class. Loading a first class may trigger the loading of a second class based on the dependency relationship. Additionally there may be multiple levels of dependency and specializing of one classes may trigger the specialization of multiple other classes which in turn may trigger the specialization of yet other classes according to various embodiments.

Additionally generic classes may have more than one specializable type parameter and it may be desirable to specialize one or more of the type variables while not specializing others e.g. leaving others generic . In some embodiments the result of partial specialization may be one or more additional generic classes that are further specializable on the remaining type parameters. A specializer executing during runtime may be configured to partially specialize a generic class e.g. to produce a partially specialized class and to subsequently further specialize the partially specialized class to generate fully specialized class according to some embodiments. Thus rather than performing the specialization of a generic class all at once such as by specializing Map into Map or Map one type parameter may be partially specialized such as resulting in Map and then at some later time the remaining type parameter s may be specialized such as to generate Map or Map.

While a runtime specializer may always be able to generate an automated specialized version of a generic class in some cases an alternate form of user control over specialization may allow the use of automated specialization while also adding or overriding specialization specific method implementations. In general the set of members of a generic class may not change when the class is specialized. In other words the same members may exist in the auto specialized version as in the generic version. However manual refinement of specialized classes may allow a developer to hand specialize a particular possibly a better representation and or implementation of the specialized class. Alternate as well as additional methods data layouts fields etc. may vary between the original generic class as well as an auto specialized version of the generic class and the replacement class according to various embodiments. Thus in some embodiments replacement versions of classes methods fields etc. may be provided for a generic class while maintaining the same interface and representation while in other embodiments an entirely different representation e.g. different and or additional methods data layout fields etc. may be provided for particular specializations of a generic class.

For example a generic class List may be generic in any T and the auto specialized versions of List may include all the fields and methods of the generic version but if List is specialized for T int a new version of a particular one of the class methods may also be included in the specialized class. Thus if List is specialized for T int the hand specialized version of the method may be used in place of the auto specialized version according to some embodiments. Manual refinement of specialized class may include utilizing different versions of method to override existing or auto specialized versions of the methods. Additionally manual refinement may also include including additional methods in a specialized class only for particular and not other type parameterizations. Thus a refinement method may be included in a specialized class only when the corresponding generic class is specialized for a particular type parameterization.

Furthermore specialization may include providing replacement classes for generic classes. Wholesale replacement of specialized classes may involve the ability to replace the auto specialization of a generic class with a replacement class. The auto specialized version of the class may not be used at all and instead a completely different hand written class may be used when the class is specialized for particular type parameterizations according to some embodiments. In some embodiments alternate hand written specializations of a class may be used and or required at the time that the generic class is compiled. In other embodiments however alternate e.g. replacement or refinement specializations of the generic class may be utilized after the class is compiled e.g. either before or at the time the generic class is specialized .

Additionally a replacement class may have the same interface as the generic or auto specialized version but it may have a completely different representation and or implementation. In some embodiments however the replacement class must have e.g. may be required to have the same interface as the generic or auto specialized version. For instance a replacement class not having the all the methods e.g. all the non private methods of the base class and therefore of an auto specialized version of the class may cause in an error according to some embodiments.

In some embodiments the replacement class may be required to have at least all the same methods that the generic or auto specialized versions of the class would have e.g. so that the alternate version of the class respects the Liskov Substitution Principle . A runtime environment may load the alternate version of the class whenever the particular specialization is instantiated. The generic or auto specialized version of the class may include information identifying the alternate version of the class and indicating which type parameterizations may trigger use of the alternate version.

Alternatively information identifying the alternate version of the class and indicating which type parameterizations may trigger use of the alternate version may be stored somewhere other than within the generic or auto specialized version of the class such as in the class file or in an information registry and thus the runtime may not have to load the generic or auto specialized version of the class when using the alternate version of the class.

In the following detailed description numerous specific details are set forth to provide a thorough understanding of claimed subject matter. However it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances methods apparatuses or systems are not described in detail below because they are known by one of ordinary skill in the art in order not to obscure claimed subject matter.

While various embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit the embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the disclosure. Any headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

Some portions of the detailed description which follow are presented in terms of algorithms or symbolic representations of operations on binary digital signals stored within a memory of a specific apparatus or special purpose computing device or platform. In the context of this particular specification the term specific apparatus or the like includes a general purpose computer once it is programmed to perform particular functions pursuant to instructions from program software. Algorithmic descriptions or symbolic representations are examples of techniques used by those of ordinary skill in the signal processing or related arts to convey the substance of their work to others skilled in the art. An algorithm is here and is generally considered to be a self consistent sequence of operations or similar signal processing leading to a desired result. In this context operations or processing involve physical manipulation of physical quantities. Typically although not necessarily such quantities may take the form of electrical or magnetic signals capable of being stored transferred combined compared or otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to such signals as bits data values elements symbols characters terms numbers numerals or the like. It should be understood however that all of these or similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout this specification discussions utilizing terms such as processing computing calculating determining or the like refer to actions or processes of a specific apparatus such as a special purpose computer or a similar special purpose electronic computing device. In the context of this specification therefore a special purpose computer or a similar special purpose electronic computing device is capable of manipulating or transforming signals typically represented as physical electronic or magnetic quantities within memories registers or other information storage devices transmission devices or display devices of the special purpose computer or similar special purpose electronic computing device.

Turning now to which illustrates a workflow for compiling and executing a computer program specified in a high level platform independent object oriented language that supports primitive and reference data types and various methods features and enhancements regarding specializations of generic classes and or methods as described herein according to various embodiments. For purposes of illustration the following description is provided largely in the context of using the Java programming language. However it is noted that the techniques described may be used with virtually any object oriented programming language that supports multiple kinds of types such as primitive types reference types record types union types etc. and specialization thereof in appropriate contexts.

According to the illustrated embodiment the workflow may begin when a compiler such as compiler may be implemented on one or more computing devices and may receive source code for a computer program such as source code . In various embodiments source code may be specified in various high level and or platform independent object oriented programming languages such as Java and or other languages. For example source code may be provided as a set of .java files in embodiments where Java is being used. In some embodiments source code may be specified using a combination of languages which may include one or more low level and or intermediate languages e.g. assembly . In some embodiments at least some of the source code may initially be written in a dynamically typed high level language such as Python or Ruby while in other embodiments all of the source code may be in a statically typed language such as Java .

In general a class may be considered a user defined type or data structure that may include data variables functions methods and or other attributes as members and that represents a definition blueprint or template for creating programming objects of a specific type. A class may provide initial values for data members and implementations for member functions and methods. Classes are frequently included in libraries. A library may be considered a collection of resources used by software programs or applications. A library may include any of various types of resources including but not limited to data documentation classes subroutines and or type specifications according to some embodiments. A library may be organized so as to be utilized by more than one application possibly at the same time and may promote re usability by providing resources so that applications may not have to implement or re implement the same behavior.

The compiler may analyze the source code to produce an executable version of the program or bytecode files such as annotated class file s e.g. .class files or .jar files in the case of Java in the depicted embodiment. Different types of executable code formats may be used in various embodiments for example binary machine language may be used instead of bytecodes. In some scenarios parts of the executable code e.g. annotated class files may be in bytecode while others are in a native binary machine language.

As part of compiling program source code into executable code e.g. annotated class files the compiler may perform a sequence of analysis operations and generate various intermediate data structures before generating the executable version such as to apply or implement specialization according to some embodiments. For example the compiler may apply a type erasure operation using an encoded annotated or decorated form of a program element in a generic class thus created annotated class file . As noted above the encoded form of the program element may include metadata indicating which type variables of the class or method declaration have been erased and which types are the erasures of type variables.

In some embodiments a compiler such as compiler may retain certain types of information that traditionally may not have been retained during the compilation process. For example in one embodiment compiler may retain information utilized as part of performing an erasure. The compiler may include at least part of such information in the annotated class file as metadata regarding specialization.

For instance a type erasure operation may be applied using an encoded or annotated form of a program element in a generic class. The program element may represent a class signature or declaration a method signature or declaration an instruction an argument to an instruction as well as virtually any program element that represents moves or manipulates data.

The encoded form of the program element may include metadata indicating which type variables of the class or method declaration have been erased and which types are the erasures of type variables. Additionally the metadata may include various types of specialization related information. For example the metadata may indicate that an instruction operates on values of the type variables of a class or method declaration . Similarly the metadata may indicate that an argument indicates types that are erasures of the type variables of the class or method declaration.

The metadata in an annotated class file may include specialization information indicating which type variables have been erased and which types are the erasures of type variables according to some embodiments. Type erasure pertains to the use of generics within a programming language e.g. the Java language . When performing a type erasure operation a compiler may be configured to replace all type parameters in generics types with their bounds or with an Object type if the type parameters are unbounded. The generated bytecode may thus contain only ordinary classes interfaces and methods.

Additionally structural descriptions may be utilized to extend the way classes are described in a runtime environment. Instead of describing classes only by name and using that name to locate that class e.g. in a class file on disk a class may be referred to as a combination of a code generator function and possibly some arguments. In other words in some embodiments a class may be described by a structural description specifying a generator function and possibly one or more parameters to that generator function. A structural description may in some embodiments be considered e.g. may be used instead of a class name for virtually any situation in which a class name may be used e.g. argument type return type field type supertype operand of instance of or cast operator etc. .

Thus in some embodiments a compiler and or virtualized runtime environment may be configured to allow descriptions of classes using structural descriptions. For example dependency relationships between classes e.g. superclass subclass relationships may be described using structural descriptions. According to some embodiments the structural identification of classes may be utilized using structural descriptions such as to extend the way classes are described in a runtime environment. A structural description of a class may appear anywhere a class name could otherwise appear in a purely nominal VM e.g. a VM not configured to support structural descriptions as class names according to some embodiments. For example a structural description of a class may appear as or in place of an argument type a return type a field type a supertype an operand of instance of or a cast operator and generally anywhere a class name may be used.

As illustrated in annotated class file may be passed to an execution environment such as virtualized runtime environment which executes the code on an execution platform thereby creating various output data and or behavior. The virtualized runtime environment may in turn comprise a number of different components such as memory manager specializer class loader bytecode verifier e.g. to check the validity of the executable code and or an interpreter and or just in time JIT compiler according to various embodiments. The JIT compiler may in some embodiments be responsible for translating some or all of the bytecode for example heavily used portions of bytecode into platform specific machine code to improve performance of the program execution. A virtualized runtime environment may also include code to implement a number of application programming interface API libraries in some embodiments. The virtualized runtime environment may run on top of lower level software such as an operating system in some embodiments.

In different embodiments the output or behavior produced as a result of the execution of the compiled code may include data stored in various levels of system memory e.g. in memory objects and or data structures on persistent storage e.g. files on a file system etc. The behavior may also include various program functionalities such as displaying output on a screen sending messages over a network and or otherwise interacting with various users and or components.

In some embodiments virtualized runtime environment may use the annotated class file s generated by compiler . According to some embodiments virtualized runtime environment may when loading a class to be specialized with a particular parameterization use annotated class file as a template along with the parameters with which to specialize and may produce a new class which is the particular specialization of the class being specialized. For example when specializing a class a set of type parameters may be part of the input to the specialization e.g. List may be specialized using T int as a parameter to obtain List . In general an annotated class file may be considered a class file marked up with specialization related metadata. Furthermore an annotated class file may be turned into a new class that is a specialization of the annotated class according to various embodiments.

According to some embodiments the loading or operation of a specialized class may trigger the specialization of other classes. For example if class ArrayList extends AbstractList the instantiation of ArrayList may require resolution of AbstractList. Similarly given a class Map that includes internally as part of its implementation a class representing a map s node that class would also be a generic in the keyType and the valueType. Using dependency driven co specialization when the generic class Map is instantiated as a map from int to long e.g. Map the specialized implementation of Map may then trigger the specialization of dependent type s such as the internal node class mentioned above according to some embodiments.

Thus according to some embodiments a compiler such as compiler may recognize dependency relationships between generic types and may describe the dependent types in terms of the type variables of the triggering types e.g. the types that trigger the specialization of the dependent types . For example when the compiler writes out a class file instead of writing doing everything nominally such as when ArrayList gets erased to just ArrayList so that ArrayList extends List as in done in legacy compilers a compiler configured to implement dependency driven co specialization may include structural references indicating dependency relationships in the class file.

For example if ArrayList extends List rather than just using the name List the compiler may utilize a structural description referring to the e.g. the class resulting from applying a specialization transform to List with the type parameter T. In other words the compiler may be configured to write out e.g. to a class file a description of a generic supertype in terms of a type variable of the generic subtype. Thus the class file may include a description indicating that class ArrayList extends the class resulting from applying the specialization code generator to the argument e.g. T . Loading ArrayList may trigger the loading of List and List may be described by a structural description such that the specializer and or class loader may apply the structural description to generate the class List for the particular parameterization of T and load it into the runtime cache. Thereafter List may be usable to be extended such as by ArrayList.

In the structural description of the superclass e.g. in an example of ArrayList extends List the type variable T from ArrayList appears in the structural description of the supertype so that when ArrayList is specialized for T int the occurrence of T in the structural description of the supertype is replaced with int according to one embodiment. Thus the type parameter for T as declared within ArrayList gives meaning to occurrences of T in the extends clause and in the body of ArrayList. When the class is generated class ArrayList may extend the class resulting from applying the specialize transform of List to int and that may trigger the loading of List resulting in having ArrayList extend List.

According to some embodiments the type parameter T when declared between the introduces a type variable T similar to the manner in which a formal parameter declared between the of a method introduces a variable. The type variable T may be used in the signature of the generic class e.g. as in an extends clause as well as in the body of the generic class e.g. as in the type of a field . Within the signature of the generic class the type variable T may appear in a type argument position e.g. extends AbstractList but may not appear in a top level position e.g. extends T according to some embodiments. However within the body of a generic class the type variable T may appear in a type argument position e.g. as a field declaration such as List f as well as in a top level position e.g. as a field declaration such as T f . Co specialization may be triggered whenever the type variable T is used in a type argument position according to some embodiments.

At runtime the specialization of one type or class may trigger the specialization of other types. For example if an implementation of Foo refers to Bar the specialization of Foo may trigger the specialization of Bar e.g. because Bar may be required to complete the specialization of the code for Foo according to some embodiments. The runtime environment such as virtualized runtime environment may recognize the dependency relation using any of various types of information such as by using the information about the dependent types included in the class file by the compiler.

Turning now to which is a logical block diagram illustrating one example embodiment of dependency driven co specialization of specialized classes as described herein. As shown in class file may include generic class A and generic class B which have a dependency relationship . For example in one embodiment class A may be dependent upon class B. When dependency specializer specializes class A to generate class A such as upon instantiation of class A for a particular type parameterization dependency specializer may determine e.g. recognize the dependency relationship between class A and class B and may therefore also specialize class B to generate class B according to some embodiments. Thus the dependency relationship between generic class A and generic class B may trigger the specialization of class B whenever class A is specialized.

From the developer s perspective the co specialization simply occurred automatically e.g. without any particular command by the developer based on the dependency relationship between the different types or classes .

For instance as described above generic class A defined in class file may be instantiated for a particular type parameterization. Thus the generic class may be specialized within virtual runtime environment e.g. within a platform independent object oriented runtime environment for that particular type parameterization.

According to one example embodiment a Java based class ArrayList may be specialized for type int. Thus the generic class ArrayList may be specialized within a Java based virtual machine for T int according to the example embodiment.

As shown in block a dependency relationship may be determined between the first generic class and a second generic class according to some embodiments. For example a specializer of the runtime environment such as specializer and or dependency specializer of virtualized runtime environment may be configured to determine dependency relationships between two classes such as dependency relationship between between generic class A and generic class B illustrated in described above.

The dependency between two classes may involve e.g. be created or triggered by virtually any type use of a type or class B within a class A according to various embodiments. For instance a dependency relationship may involve or be defined created by the use of a supertype a field descriptor a method descriptor or the use of another generic type or class within the body of a method. As one example class ArrayList may extend AbstractList thereby created e.g. defining a dependency relationship between class ArrayList and class AbstractList.

Dependency driven co specialization may be triggered whenever a generic type parameter e.g. characterized by in the above examples appears. Thus dependency driven co specialization may be triggered e.g. specialization may occur whenever a generic type parameter appears as a supertype as a target of a cast as the type of a method parameter or return type or virtually anywhere that a type parameter can appear according to some embodiments. Thus if a particular generic class appears virtually anywhere at all e.g. within the API or implementation of a dependent class then in order to be able to generate specialize the dependent class the particular generic class may be generated specialized as well e.g. either before during or after the generation specialization of the dependent class according to some embodiments.

As shown in block in response to determining the dependency relationship the second generic class may be specialized for the particular type parameterization based on the determined dependency relationship according to one embodiment. Continuing the example above the specialization of ArrayList for a particular type parameterization may trigger the specialization of AbstractList for the same parameterization. If class ArrayList were instantiated and therefore specialized for T int the class AbstractList may also be specialized for T int according to some embodiments.

Additionally the same dependency relationship between classes or other types may also be used to trigger specialization for different parameterizations. For example specializing ArrayList for int may trigger the specializing of AbstractList for int. Subsequently ArrayList may be specialized for long which may trigger the specialization of AbstractList for long. In other words once a dependency relationship between two generic classes is defined that dependency relationship may trigger the specialization of the dependent class whenever and however many times the first class is specialized according to some embodiments.

While described above using a dependency based on a superclass relationship in other embodiments a dependency may be based on other relationships between classes. For example if a helper class LinkedListNode is nested within the body of a class LinkedList instantiation of a LinkedList may trigger co specialization of LinkedListNode.

While described above as two separate and distinct specializations performed in a particular order the specialization of the first and second generic classes may occur in any order and or may overlap according to various embodiments. For example in one embodiment specializer may determine the dependency relationship between the first generic class and the second generic class and in response may specialize the second generic class prior to specializing the first generic class. In another embodiment specializer may begin specializing the first generic class determine the dependency relationship specialize the second generic class and then complete the specialization of the first generic class.

While the examples above regarding illustrate a single dependency relationship between two classes dependency driven co specialization may involve multiple even many layers of dependency or dependency chains . In some embodiments there may be many levels of dependencies in both depth and breadth. For example is a logical block diagram illustrating a dependency driven co specialization involving multiple dependencies within a dependency chain according to one embodiment. As illustrated in a class file may include multiple generic classes such as generic class A generic class B generic class C and generic class D . Additionally the class file may define dependency relationships between the generic classes. For example generic class A may depend on generic class B and generic class C as illustrated by dependency relationships and . Additionally generic class B may itself depend upon generic class D as indicated by dependency relationship .

Thus when a specializer of a runtime environment that is configured to implement dependency driven co specialization such as dependency specializer of virtualized runtime environment specialized generic class A to generate class A it may determine or recognize the dependency relationships between generic class A and generic class B and generic class C . In response to determining the dependency relationships e.g. when specializing generic class A dependency specializer may specialize generic class B and generic class C to generate class B and class C respectively.

Additionally when specializing generic class B whether independently e.g. due to an independent instantiation of class B or in response to the specialization of generic class A dependency specializer may specialize generic class D to generate class D .

As noted above the dependency between two classes may be defined based on various relationships between the classes. For example a dependency between two classes may exist because one class extends another or because its implementation references another class or because its API names another class as one of its arguments or return types according to various embodiments.

When a first generic class is specialized the specializer may trace through any dependency chains based on dependency relationships between the first generic class and any other generic classes and specializes the other classes accordingly in some embodiments.

Thus the class SortedList is dependent upon multiple other classes such as List Comparator Collection and Set. Specifically List is a superclass of SortedList Comparator is named within a field signature as a parameter to SortedList Collection is named within a method signature and the class Set is used within the body of a method. Thus SortedList is dependent upon each of the other classes based on different types of dependency relationships.

When specializing class to generate class dependency specializer may determine that the class SortedList is dependent upon the other classes and in response may specialize classes and to generate classes and respectively according to one example embodiment. Specifically according to one embodiment specializing SortedList may trigger the specialization of List superclass Comparator field signature Collection method signature and Set method body .

Additionally the timing of specialization may vary from embodiment to embodiment such as depending on differences between different runtime environments. For example in one embodiment Set may not be specialized until the method countUnique is actually called during execution of the program.

While the examples above utilize public types dependency driven co specialization is not limited to public types. For instance the following sample code illustrates dependency driven co specialization with nonpublic types 

In the above example even though the class Node is private to LinkedList it may be specialized whenever LinkedList is specialized according to some embodiments.

Additionally the same generic class may be specialized multiple times for different type parameters as part of specializing a single dependent class. As one simplistic example an interface Map may be implemented using two different ArrayLists one for keys and one for values as illustrated in the following example code 

Generic classes may have more than one specializable type parameter such as in the example Map. It may be desirable to specialize one or more of the type variables while not specializing others e.g. leaving others generic . is a logical block diagram illustrating the partial specialization of a generic class according to one embodiment. A specializer such as partial specializer of virtualized runtime environment may be configured to partially specialize generic class to produce partially specialized class and may also be configured to subsequently further specialize partially specialized class to generate fully specialized class according to some embodiments.

For example generic class may represent the generic class Map and partial specializer may be configured to specialized generic class to a map with generic keys but with int values for values such as Map. Alternatively the generic class Map may be specialized to a map with int values for keys but with generic values such as in Map. This may be referred to herein as partial specialization .

In some embodiments the result of partial specialization may be one or more additional generic classes that are further specializable on the remaining type parameters. For example partially specialized class may represent Map and may be further specializable to generate fully specialized class which may represent one or more maps with particular types for the keys such as Map or Map. In other words for a generic type with more than one type variable e.g. Map one of the type variables may be specialized e.g. Map while not specializing the other type variable s . The resulting class may be considered a partially specialized class that can be specialized further.

Thus rather than performing the specialization of a generic class all at once such as by specializing Map into Map or Map one type parameter may be partially specialized such as resulting in Map and then at some later time the remaining type parameter s may be specialized such as to generate Map or Map.

While illustrated in as storing the partially specialized class back to the class file in some embodiments the partially specialized class may be stored in a different location such as within a separate class file or in memory within virtualized runtime environment among other locations.

As shown in blocks and partially specializing the generic class may involve specializing the generic class for a particular one of the multiple type variables over a particular one of the multiple type parameterizations as shown in block and not specializing the generic class for another of the specializable type variables as shown in block such that the partially specialized class is further specializable for at least one other of the multiple specializable type variables for each of the multiple type parameterizations. For example 

may be partially specialized for one type variable such as K without specializing the other type variable. For instance in the following example 

IntBasedMap may be a partial specialization of Map. Only one of Map s type variables e.g. K has been specialized thus allowing IntBasedMap e.g. the partially specialized Map to be further specialized for V over any all of the type parameterizations over which Map may be specializable. In some embodiments the partially specialized class may be further specializiable over each of the plurality of possible type parameterizations for which the class is specializable. Thus after being partially specialized for K int as in the above example the partially specialized Map e.g. as IntBasedMap may be further specializable for V over other type parameterizations such as for V long V boolean V String etc. according to various embodiments. Furthermore as shown in the above example a partially specialized class such as Map may appear as a parameterized type e.g. in an extends clause . In some embodiments a parameterized type e.g. Map may be recognized as a partial parameterization of a generic class e.g. Map and the generic class may be partially specialized to form another generic class e.g. Map allowing a parameterized type to be formed. Frequently forming the parameterized type may mean instantiating the generic class Map by binding type arguments to the type parameters K and V but in some embodiments the identity function may be applied to the partially specialized generic class Map to form the parameterized type similarly to the manner in which the type String is the identity function applied to a non generic class String.

As shown in block the partially specialized class may then be subsequently further specialized for another of the specializable type variables such that the partially specialized class becomes fully specialized according to some embodiments. Continuing the above example the partially specialized Map e.g. as IntBasedMap may be further specialized for the remaining type variable e.g. V as in the following example code 

Thus Map may be further specialized for V int as one example resulting in a Map e.g. via IntBasedMap and IntToIntMap according to one example embodiment. Additionally after being further specialized over one type parameterization the same partially specialized class may be further specialized over other type parameterizations. For example the same partially specialized Map class may be further specialized for V long as in the following example code 

In some embodiments partial specialization of a class may be accomplished by partially specializing metadata injected into the class e.g. in order for the class to be specializable and then propagating the partially specialized metadata into the new partially specialized class file so that the result of the partial specialization is re specializable. Thus partial specialization may be accomplished by forward propagating a projection of specialization metadata from the original class into the result of the partial specialization according to some embodiments.

This may come about by the way a developer is writing his code the way he wants to have different levels of partial specialization. As described herein there may be two different reasons to specialize a generic class. Firstly specializing a generic class may result in better performance e.g. operations on ints are faster than operations on objects and secondly a generic class may be specialized to take advantage of particular information regarding the arguments e.g. such as to add new functionality that is only appropriate to certain type parameters .

Thus it may be beneficial to have a Map where the keys are ints even if you don t know anything about the values e.g. Map . This partially specialized Map class may then be specialized to use particular map values without having to specialize the entire class e.g. since Map was already partially specialized to Map .

Thus partial specialization of classes may involve the specialization of classes to produce further specializable classes according to some embodiments. For example below is a partial specialization of HashMap 

The partial specialization of HashMap requires propagating metadata as described above into the generated class so that the type variable K can be further specialized and allowing the result of that further specialization to be recognized as a subtype of HashMap.

In some embodiments partially specialized classes may be declared explicitly such as in the following example code 

Alternatively multiple different partial specializations e.g. Map Map etc. may be automatically generated e.g. by the runtime environment that are themselves specializable as needed whenever a use of the particular type occurs. Thus there may be multiple different partial specializations and they can appear anywhere in a class file that a parameterized type based on the specializable generic class could occur e.g. a supertype local variable field type the type of a method parameter a type cast etc. .

Furthermore partial specialization may be combined with dependency driven co specialization described above. is a logical block diagram illustrating partial specialization with dependency driven co specialization according to one embodiment. A generic class may include multiple generic type variables and may be partially specialized by specializer of virtualized runtime environment to generate partially specialized class . Additionally generic class may be dependent on generic class as indicated by dependency relationship . As noted above a dependency relationship may involve or be defined created by the use of a supertype a field descriptor a method descriptor or the use of another generic type or class within the body of a method. For example generic class may represent a generic class Map which may utilize as part of its implementation a generic MapNode class represented as generic class as in the following example code 

When specializer partially specializes the generic class to generate partially specialized class specializer may determine or recognize the dependency relationship between generic class and generic class and therefore may partially specialize generic class generating partially specialized class . For example partially specializing Map for K int may trigger the partial specialization of MapNode for K int as shown the following example code 

Subsequently the partially specialized class may be further specialized to generate fully specialized class which may also trigger the further specialization of partially specialized class to generate fully specialized class according to one embodiment. For instance partially specialized Map may be further specialized for V int triggering the further specialization of MapNode int V for V int as shown in the following example code 

As another example a generic class HashMap may extend Map. Partially specializing HashMap such as for K int may trigger the partial specialization of Map for K int according to some embodiments.

As yet another example a method of Map may take a mapping function from V to U and return a Map whose mappings may be k mapper v for all k v in the original map . When Map is partially specialized the specialization of the mapper function may be triggered based on a dependency relationship between the map class and the mapper function as shown in the following example code 

While a runtime specializer may always be able to generate an automated specialized version of a generic class in some embodiments an alternate form of user control over specialization may involve using the automated specialization while also adding or overriding specialization specific method implementations. In general the set of members of a generic class do not change when it is specialized the same members exist in the auto specialized version as in the generic version according to some embodiments. However manual refinement of specialized classes may allow a developer to hand specialize a better representation and or implementation of one or more methods of the specialized class.

In other words a generic class List may be generic in any T and the auto specialized versions of List may include all the fields and methods of the generic version but if List is specialized for T int a new version of a specific method may be included. Thus List is specialized for T int the hand specialized version of the method may be used in place of the auto specialized version according to some embodiments.

As another example methods for specific type parameterizations may be added to ArrayList as shown below 

In some embodiments certain methods might make sense for some instantiations of a generic class but not for others. For example a sum method on List might make sense if T is int or long but not Shoe or some other object. Some embodiments may include a declaration site mechanism to condition members on a given instantiation. This may also include members that might be inconsistent with each other if they both appeared such as an int bearing sum method for List and a double bearing sum method for List. Additionally some embodiments may include a class file representation that allows certain members to be ignored when the class is instantiated as an erased class that is without any type parameterization.

Manual refinement of specialized classes to replace override functionality that would otherwise be generated by the specializer according to some embodiments. In a manner similar to the wholesale replacement of auto specialized classes described above methods may also be added manually to replace functionality such as to override auto specialized members.

For some instantiations of a generic class it may be preferable to replace the auto specialized version. Some embodiments may include a mechanism such as a linguistic mechanism by which a single class file may describe both a generic version of a class member and then override that generic version in one or more instantiation specific layers. The class may then include both the generic version and the alternate version of the method for particular type specializations.

Thus an alternate form of user control may be utilized to enhance the automated specialization by overriding specific methods or adding new methods for specific type parameterizations according to some embodiments. Thus a developer may be able to utilize the best possible implementation for some types while relying on the generic e.g. auto specialized version for other types. For example List may have a sum method or an optimized version of existing methods may be hand written for specific type parameterizations. A user of the generic class may not have to know anything about the manual refinements. For instance a user of a generic class may not have to request or specify that the manual refinements or overridden versions be used in order to take advantage of them. Instead just instantiating the class for particular type parameters may trigger the use of the manual refinements e.g. as provided by the developer of the generic class without any particular knowledge or request by the user of the generic class according to some embodiments.

In one embodiments the developer of the generic class may write multiple versions e.g. of the overridden methods and the compiler may be configured to compile that code into multiple versions in the class file. The class file may also include information indicating which versions to use for which type specializations. Additionally the runtime environment may be configured to use the information in the class file to determine which version to use when loading a particular specialization.

In the above example the method toString may work for all types T but a more specialized version of toString may be provided for instantiations of Box where T int perhaps to give a better answer or because of a faster implementation. Additionally in some embodiments additional type constraints T int may be used within the body of the specialized version of toString to type check the body such as to ensure that the compiler knows that the type of t is really int not the generic T .

When overriding a particular method of a specialized generic class an alternate version of the method may be included in the class file and may be indicated as applying to particular set of specializations e.g. for certain type parameters according to some embodiments. In some embodiments when the methods of the generic class are specialized at runtime if one of the particular specializations corresponding to the alternate version of the method is used the alternate version of the method may be used e.g. copied to the specialized class rather than the auto specialized version.

In some embodiments a refinement method may be utilized for multiple type parameterizations. For example a refinement method may be specific to short and char as in the following example 

For instance a specializer may be configured to load and specialize a Box class for T int. As shown in block the specializer may determine a refinement method that matches an existing method for the generic class and that corresponds to the particular type parameterization. For example the specializer may determine that a refinement toString method exists for the Box class that overrides the generic toString method and that corresponds to the type parameterization T int.

As shown in block in response to determining that the refinement method corresponds to the particular type parameterization the specializer may include the refinement method in the specialized version of the generic class instead of including an auto specialized version of the existing method according to one embodiment. In other words when specializing the generic class for the particular type parameterization a specializer may be configured to include a refinement method in the specialized class based on the particular type parameterization. For example the specializer may include the refinement toString method in the specialized version of the Box class rather than including the generic or auto specialized version of the toString method. Thus the refinement method may provide an alternate implementation for a method of the generic class when that class is specialized for a particular type parameterization.

Additionally the generic class may be specialized for a different type parameterization as shown in block and the specializer may determine that the refinement method does not correspond to the different type parameterization as shown in block . For example the Box class from the example above may be specialized for a type parameterization other than T int and therefore the specializer may determine that the refinement toString method does not correspond to the type parameterization. In response the specializer may not include the refinement method in the specialization for the other type parameterization as shown in block . For example when specializing the Box class for another type parameterization other than T int the specializer may not include the refinement toString method e.g. that corresponds to T int in the specialized version of the class but instead may include the auto specialized version of the toString method. Alternatively another refinement stostring method may exist e.g. in the class declaration for the other type parameterizations and thus may be included in the specialized class when the class is specialized for the other type parameterization according to one embodiment.

When the developer has particular knowledge regarding the types there may be a better e.g. smaller faster more efficient implementation than the automated version. For example if a program uses the parameterized type ArrayList then the auto specialized version of the ArrayList class may utilize a default element size that is larger than the minimum needed to store a boolean value. For instance in the Java programming language a Boolean may by default be stored using an 8 bit or larger location. Thus in some embodiments a developer may be able to provide his own implementation that uses a different storage mechanism e.g. using an internal array of longs and performing bitwise calculations when ArrayList is specialized for T boolean.

Thus there may be a generic ArrayList but if it is instantiated for T boolean a different hand written class could be used in place of the auto specialized version. In some embodiments the auto specialized version and the hand written version may be required to have the same signatures but may have completely different representations and or completely different members etc.

Additionally an auto specialized version of a generic class may only be partially overridden with different methods for different specializations. Thus rather than replacing the entire class and or implementation individual methods may be replaced e.g. to use a better implementation or individual method could be add as noted above that only exists in a particular instantiation. Thus a developer may provide hand written refinements providing completely new representations of classes individual replacement e.g. override methods and or additional methods according to some embodiments.

For example while List may have an auto specialized implementation of add and get it may be beneficial to include a sum method for certain type parameterizations e.g. T int that may not be a member of all specialized versions of List e.g. for all type parameterizations of T .

In some embodiments the compiler and or runtime may allow methods such as to add new functionality to a specialized class to be manually added to the class for certain e.g. one some or all specialized versions of the class that would not be present in the auto specialized version.

However when the class is specialized for a type parameterization for which the new method does not correspond the specializer may not include the new method in the specialized class but instead may only include specialized versions of the existing method s as shown by class A including existing method s but not including a specialized version of the new method.

Thus rather than simply replacing the body of a method based on the instantiation of a type variable a new method may be added. The new method may be referred to as a conditional method since it may only be included in certain type specializations according to some embodiments.

In the example above two conditional sum methods are added to List. One of the Sum methods is a member of the instantiation List and the other which is a member of the instantiation List while neither is a member of List or the generic List.

As shown in block in response to determining that the new method corresponds to the particular type parameterization the specializer may include the new method in the specialized version of the generic class as well as including auto specialized versions of any existing methods according to one embodiment. For example the specializer may include the sum method in the specialized version of the List class as well as including the generic or auto specialized versions of the add and get methods.

Additionally the generic class may be specialized for a another type parameterization as shown in block and the specializer may determine that the new method does not correspond to the other type parameterization as shown in block . For example the List class from the example above may be specialized for a type parameterization other than T int and therefore the specializer may determine that the new sum method does not correspond to the type parameterization. In response the specializer may not include the new method in the specialization for the other type parameterization as shown in block . For example when specializing the List class for a type parameterization other than T int the specializer may not include the sum method e.g. that corresponds to T int in the specialized version of the class but may only include auto specialized version of the add and get methods.

In some embodiments a refinement method may be used for more than one type parameterization. For instance a generic class may include a refinement method for T Object. In some embodiments if the generic class is specialized for T String i.e. String is an Object the refinement method for T Object may be included in the specialized version of the generic class. In other embodiments however if the same generic class is specialized for T String the refinement method e.g. for T Object may not be included in the specialized version. Thus in some embodiments particular refinement methods may only be used when a generic class is specialized for the exact type parameterization for which the particular refinement method is specified while in other embodiments refinement methods may be used over multiple type parameterizations.

Additionally in some embodiments neither the auto specialization of a generic class nor a manual refinement of the class may be used but instead a completely new hand written class may be used instead. In general the replacement class may have the same interface as the generic or auto specialized version but it may have a completely different representation and or implementation. Thus according to some embodiments the replacement class may be required to have at least all the same methods that the generic or auto specialized versions of the class would have e.g. so that the alternate version of the class respects the Liskov Substitution Principle . At runtime the runtime environment may load the alternate version of the class whenever the particular specialization is instantiated.

In one embodiment the generic or auto specialized version of the class may include information identifying the alternate version of the class and indicating which type parameterizations may trigger use of the alternate version. In other embodiments however information identifying the alternate version of the class and indicating which type parameterizations may trigger use of the alternate version may be stored somewhere other than within the generic or auto specialized version of the class e.g. in the class file or an information registry and therefore the runtime may not have to load the generic or auto specialized version of the class when using the alternate version of the class.

For instance a replacement custom representation for a given instantiation of a generic class may be provided as in the following example 

When implementing wholesale replacement of classes the runtime classloader and or specializer may be configured to determine that the replacement class should be used e.g. based on the particular type parameter being instantiated and to locate and load the replacement class in place of the auto specialized and or manually refined version of the generic class according to some embodiments.

As shown in block in response to determining that the replacement class corresponds to the particular type parameterization the specializer may load the replacement class instead of loading an auto specialized version of the generic class according to one embodiment. For example the specializer may load the ArrayList version of ArrayList instead of the auto specialized version of the ArrayList.

Thus in one embodiment specializing a generic class may include loading a class corresponding to e.g. based on a refinement class declaration for the generic class that is specific to a particular type parameterization and that provides an alternate implementation for the generic class when the generic class is specialized for the particular type parameterization. Furthermore the generic class may be specializable for other type parameterizations without loading the class that corresponds to the refinement class declaration.

For instance the generic class may be specialized for another type parameterization as shown in block and the specializer may determine that the replacement class does not correspond to the other type parameterization as shown in block . For example the ArrayList class from the example above may be specialized for a type parameterization other than T boolean and therefore the specializer may determine that the replacement class e.g. ArrayList does not correspond to the other type parameterization. In response the specializer may not load the ArrayList version of ArrayList but instead may load an auto specialized version of ArrayList as shown in block according to one embodiment.

As described above regarding manual refinement of methods in some embodiments a refinement class declaration may be used for more than one type parameterization. For instance a generic class may have a refinement generic class declaration for T Object. In some embodiments if the generic class is specialized for T String i.e. String is an Object the refinement class declaration for T Object may be used for the specialized version of the generic class. In other embodiments however if the same generic class is specialized for T String the refinement class declaration e.g. for T Object may not be used for the specialized version of the class. Thus in some embodiments particular refinement class declarations may only be used when a generic class is specialized for the exact type parameterization for which the particular refinement class declaration is specified while in other embodiments refinement methods may be used over multiple type parameterizations.

In some embodiments manual refinement of specialized generic classes may also be combined with partial specialization and dependency driven co specialization of generic classes as described above. For example a partially specialized class may be manually refined to include some additional functionality for one or more specializations and the partial specialization may also trigger the full or partial specialization of one or more other generic classes.

In addition to utilizing manual refinements based on a specific instantiation of a class type parameter as described above manual refinements may also be provided based on a method type parameter of a generic method. When a generic method in a class e.g. the class itself does not have to be generic is specialized for a particular type an alternate version of the method may be used in some embodiments.

Here we re saying that this is a specialization of an existing generic method for a particular combination of type parameters. When a developer writes different versions of the method the different versions may be propagated by the compiler into the class file and at runtime a particular version of the method is loaded based upon the particular type parameters being specialized.

As shown in block in response to determining that the replacement method corresponds to the particular type parameterization the specializer may load the replacement method instead of loading an auto specialized version of the generic method according to one embodiment. For example the specializer may load the specialization version of the singletonList method instead of the auto specialized version of the singletonList.

Additionally the generic method may be specialized for a another type parameterization as shown in block and the specializer may determine that the replacement method does not correspond to the other type parameterization as shown in block . For example the singletonList method from the example above may be specialized for a type parameterization other than T int and therefore the specializer may determine that the replacement method e.g. the specialization version does not correspond to the other type parameterization. In response the specializer may not load the specialization version of the singletonList method but instead may load an auto specialized version of the singletonList method as shown in block according to one embodiment.

In at least some embodiments a computer system that implements a portion or all of one or more of the technologies described herein may include a general purpose computer system that includes or is configured to access one or more computer readable media. illustrates such a general purpose computing device suitable for implementing the method features and enhancements described herein. In the illustrated embodiment computing device includes one or more processors coupled to a system memory via an input output I O interface . Computing device further includes a network interface coupled to I O interface .

In various embodiments computing device may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may include any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the 86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store program instructions and data accessible by processor s . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing one or more desired functions such as those methods techniques and data described above are shown stored within system memory as code i.e. program instructions and data . For example memory and well as code and data may store in one embodiment program instructions and data for implementing compiler and or virtualized runtime environment described above.

In various embodiments compiler and or virtualized runtime environment and or any individual sub modules thereof may each be implemented in any of various programming languages or methods. For example in one embodiment compiler and or virtualized runtime environment may be written in any of the C C assembly Java or other general purpose programming languages while in another embodiment one or more of them may be written using a different more specialized programming language. Moreover in some embodiments compiler and or virtualized runtime environment and or various sub modules thereof may not be implemented using the same programming language.

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing device and other devices attached to a network or networks . In various embodiments network interface may support communication via any suitable wired or wireless general data networks such as types of Ethernet network for example.

In some embodiments system memory may be one embodiment of a computer readable e.g. computer accessible medium configured to store program instructions and data as described above with respect to for implementing embodiments of the corresponding methods and apparatus. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer readable media. Generally speaking a computer readable medium may include non transitory storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computing device via I O interface . A non transitory computer readable storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. that may be included in some embodiments of computing device as system memory or another type of memory.

Further a computer readable medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in may be used to implement the described functionality in various embodiments for example software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments portions of the described functionality may be implemented using storage devices network devices or special purpose computer systems in addition to or instead of being implemented using general purpose computer systems. The term computing device as used herein refers to at least all these types of devices and is not limited to these types of devices.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer readable medium. Generally speaking a computer readable medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc. In some embodiments a computer readable medium may also include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software hardware or a combination thereof. In various of the methods the order of the steps may be changed and various elements may be added reordered combined omitted modified etc. Various of the steps may be performed automatically e.g. without being directly prompted by user input and or programmatically e.g. according to program instructions .

While various systems and methods have been described herein with reference to and in the context of specific embodiments it will be understood that these embodiments are illustrative and that the scope of the disclosure is not limited to these specific embodiments. Many variations modifications additions and improvements are possible. For example the blocks and logic units identified in the description are for understanding the described embodiments and not meant to limit the disclosure. For example actions processes methods tasks or functions described herein as being performed by Compiler may in some embodiments be performed by virtualized runtime environment and vice versa. Additionally functionality may be separated or combined in blocks differently in various realizations of the systems and methods described herein or described with different terminology.

These embodiments are meant to be illustrative and not limiting. Accordingly plural instances may be provided for components described herein as a single instance. Boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of examples that follow. Finally structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component.

Although the embodiments above have been described in detail numerous variations and modifications will become apparent once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

