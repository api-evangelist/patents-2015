---

title: Using memory compression to reduce memory commit charge
abstract: A memory manager in a computing device allocates memory to programs running on the computing device, the amount of memory allocated to a program being a memory commit for the program. When a program is in a state where the program can be terminated, the content of the memory pages allocated to the program is compressed, and an amount of the memory commit for the program that can be released is determined. This amount of memory commit is the amount that was committed to the program less any amount still storing (in compressed format) information (e.g., data or instructions) for the program. The determined amount of memory commit is released, allowing that amount of memory to be consumed by other programs as appropriate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09632924&OS=09632924&RS=09632924
owner: Microsoft Technology Licensing, LLC
number: 09632924
owner_city: Redmond
owner_country: US
publication_date: 20150302
---
As computer technology has advanced the performance of computer processors has increased. This increased performance has resulted in more complex computer programs providing increased functionality to users. However this increased performance is not without its problems. One such problem is that as the computer programs become more complex they use increased amounts of computer memory. This has led to a need to include more computer memory in computers increasing the cost of such computers.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects a determination that a program is in a state from which the program can be terminated is made an amount of memory having been committed to the program the amount of memory being a memory commit for the program and a subset of the amount of memory committed to the program having been used by the program. The amount of memory committed to the program includes multiple memory pages. The content of the memory pages in the subset of memory used by the program is compressed and an amount of the memory commit for the program that can be released is determined. After the subset of memory used by the program has been compressed the determined amount of the memory commit for the program is released.

In accordance with one or more aspects a determination that one or more memory pages of a program are to be accessed is made the program having had at least part of its memory commit released. An attempt is made to re obtain the memory commit for at least the one or more memory pages of the program. In response to the attempt to re obtain the memory commit being successful the one or more memory pages are allowed to be accessed. In response to the attempt to re obtain the memory commit being unsuccessful the program is terminated and re launched.

Using memory compression to reduce memory commit charge is discussed herein. A memory in a computing device is made up of multiple blocks or portions referred to as memory pages or simply pages . These pages are backed by a page file on a storage device e.g. a disk and a memory manager of the computing device manages transferring data for various pages between the memory and the page file as appropriate. The memory manager also allocates amounts of memory to programs running on the computing device.

When memory is allocated to a program an address space is assigned or allocated to the program. This address space includes the allocated amount of memory and the memory manager allocates a commit charge for the allocated amount of memory. This allocated amount of memory is the amount of memory that is committed to the program and is also referred to as the memory commit for the program or simply the commit for the program . The memory commit guarantees availability of the allocated amount of memory to the program the memory manager guarantees that if a committed virtual address in the memory allocated to the program is accessed pages in physical memory e.g. RAM can be made available for the address. At the time the memory is allocated to the program no physical pages need be but alternatively can be allocated to the program. A maximum amount of commit charge permissible in the computing device is equal to the amount of physical memory e.g. RAM plus the size of all page files on a storage device that backs the physical memory e.g. RAM .

The content of one or more of the memory pages of a program is compressed. This compression can occur while the program is active e.g. running or otherwise permitted to access the memory allocated to the program and or in response to the program being suspended or otherwise placed in a non active state . When a program is suspended an amount of memory commit for the program that can be released is determined. This amount of memory commit that can be released is the amount that was committed to the program less any amount still storing in compressed format information e.g. data or instructions for the program. The determined amount of memory commit is released allowing that released amount of memory commit to be consumed by other programs as appropriate.

When one or more memory pages of a suspended program are to be accessed such as due to the suspended program being made active again or kernel mode code attaching to the memory space of the suspended program an attempt to re acquire the memory commit for those memory pages is made. Depending on what memory has been allocated to what other programs the attempt may be successful or unsuccessful. If the attempt is successful then access to the one or more memory pages is permitted. However if the attempt is unsuccessful then the program is terminated and the program is optionally re launched. Re launching the program allows the program to run allocating memory as appropriate to the program and optionally resulting in one or more other programs being terminated . Whether the program is re launched can vary based on the type of access e.g. the program may be re launched if the access is due to the suspended program being made active again but may not be re launched if the access is due to kernel mode code attaching to the memory space of the suspended program .

A program when running is also referred to herein as a process which is an instance of a running program so portions of the paged memory allocated to a program are also referred to as allocated to a process of the program . The pages allocated to a process are owned by or dedicated to that process and are used by that process and no other process and thus are also referred to as private pages . The programs can be applications operating system programs or other components or modules. The memory manager receives requests from these programs to retrieve data from the paged memory and to write data to the paged memory . The paged memory can be for example any type of CPU Central Processing Unit addressable memory such as volatile memory e.g. RAM or nonvolatile memory e.g. Flash memory .

The memory controller manages the paged memory using paging. The memory controller organizes the memory e.g. RAM into pages which are a particular e.g. fixed size unit of data. The act of paging refers to reading data in units of pages from the backing file also referred to as the swap file which is page file in system when the data is not in the memory . The act of paging also refers to writing dirty modified data back in units of pages into the page file . The memory pages are thus also referred to as page file backed memory pages. Such paging techniques are well known to those skilled in the art.

In response to a request for memory allocation for a program the memory allocator allocates a commit charge for the requested amount of memory which guarantees that if a virtual address in that memory were to be accessed at some point physical pages in memory would be made available to the program. This request is typically received from the program itself. The content e.g. data of pages of the memory allocated to the program may be transferred to and from the page file at different times but that transfer is managed by the memory controller and the program has access to the memory that is allocated to the program.

Alternatively the memory allocation and the programs follow a delayed memory commit approach. In the delayed memory commit approach no actual commit allocation happens when a memory allocation request is made by the program . Instead commit is allocated on demand when the program first writes to the allocated memory. If commit cannot be allocated at that time an exception is raised and or the program is terminated.

The system includes a program termination preparation module and a program access module . The program termination preparation module manages putting the program in a state where the program can be terminated also referred to as a terminatable state . This can involve communicating with the program so that the program saves a processing state of the program which refers to the various data settings or other information used by the program. By saving the processing state of the program if the program is terminated the program can be subsequently re launched and returned to the same processing state as it had prior to being terminated. Putting a program in a state where the program can be terminated also includes releasing at least some of the memory commit for the program as discussed in more detail below. In one or more embodiments a program that is put in a state where the program can be terminated is suspended which refers to the program not running on the system e.g. the program is not scheduled for execution by any processors of the system . Alternatively a program can be put in a state where the program can be terminated without suspending the program.

In one or more embodiments the system follows a suspend commit release approach. In the suspend commit release approach the program termination preparation module manages putting the program in a state where the program can be terminated as discussed above.

Alternatively the system can follow a runtime commit release approach. In the runtime commit release approach a program is considered terminatable at all times even when the program is active e.g. running . Memory commit can be saved at runtime when the application is still active but terminatable such that the commit charge for the subset of pages in the address space that are compressed can be released as soon as the pages are compressed into compressed memory pages. In this approach e.g. used in conjunction with the delayed memory commit approach discussed above the storage for the compressed data the compressed memory pages charges its own commit. When the program accesses a commit released page commit is re charged a physical page is allocated and data is decompressed from the compressed store into the physical page. If commit charge fails the commit charge cannot be re acquired then an exception is raised and or the program terminated .

The program access module manages allowing access to memory of a program that has been suspended or otherwise made terminatable. This allowing access can include resuming running of the program such as re launching of a program that was terminated or resuming running of a suspended program. This allowing access can also include re acquiring at least some of the memory commit charge previously allocated to a program so that another program can access the memory as discussed in more detail below.

In one or more embodiments as illustrated in the active state and the terminatable state do not overlap. Thus in such embodiments the program can be active or terminatable but not both active and terminatable concurrently. Alternatively as illustrated in the active state and the terminatable state partially overlap. Thus in such embodiments the program can be active but not terminatable terminatable but not active or both active and terminatable concurrently.

In the active state the program is running e.g. is being scheduled for execution by one or more processors of the system or device running the program . While in the active state the program is able to access the memory that has been allocated to the program. From the active state the program can transition to the terminatable state such as when the program is suspended or otherwise to be put in a state where the program can be terminated.

In the terminatable state the program is in a state where the program can be terminated e.g. the program is suspended . While transitioning from the active state to the terminatable state the program saves the processing state of the program so that if the program is terminated the program can be subsequently re launched and returned to the same processing state as it had prior to being transitioned to the terminatable state . While in the terminatable state the program is not able to access the memory that has been allocated to the program and at least some of the memory commit charge that has been allocated to the program may be released as discussed in more detail below.

From the terminatable state the program can transition to the active state . Transition to the active state can occur due to various different events such as a user request to run the program a request by another program to attach to the memory space of the program and so forth. Also from the terminatable state the program can transition to the terminated state . Transition to the terminated state can occur due to various different events such as a user request to close the program a determination that the memory previously allocated to the program is to be used for one or more additional programs and so forth.

In the terminated state the program is not running. The program is not loaded into memory e.g. RAM of the system or computing device that would run the program although is stored on another storage device and can be loaded into memory of the system or computing device. From the terminated state the program can transition to the active state . Transition to the active state can occur due to various different events such as a user request to run the program. Also from the terminated state the program can transition to the terminatable state . Transition to the terminatable state can occur due to various different events such as a user request to load but not run the program.

Returning to the memory controller manages compression of memory used by a program. The memory used by a program refers to memory pages that have been instantiated by the program or otherwise have been accessed by e.g. to write or store data the program. Compressing the memory of or used by a program refers to compressing the content of e.g. data stored in one or more memory pages of the memory allocated to the program. Any of a variety of different public and or proprietary compression techniques can be used to compress a memory page. For example a memory page can be compressed using run length encoding compression algorithms LZW compression algorithms Huffman coding algorithms and so forth. Multiple different compression algorithms can optionally be employed such as different compression algorithms for different types of content. For example one compression algorithm may be used for alphanumeric and or text content another compression algorithm may be used for image content and another compression algorithm may be used for audio content. The compression technique used to compress a memory page is typically a lossless compression algorithm although in certain circumstances e.g. for certain image and or audio content a lossy compression algorithm may alternatively be used. The particular compression algorithm may also be device dependent where a faster device e.g. with a more powerful one or more processors may be configured with a more processor intensive compression algorithm that compresses better whereas a slower device e.g. with a less powerful one or more processors may be configured with a less processor intensive algorithm that does not compress as well.

Memory used by a program can be compressed at different times. In one or more embodiments memory used by a program is compressed while the program is running. The memory controller can use any of a variety of different rules or criteria to determine which memory pages are compressed. For example all memory pages used by program may be compressed memory pages that have not been accessed by the program for a threshold amount of time can be compressed memory pages that are being written out to a page file can be compressed and so forth.

Additionally or alternatively to compressing memory while the program is running memory of the program can be compressed in response to the program transitioning to a terminatable state. The memory controller can compress all of the memory pages that are used by the program and have not already been compressed or alternatively apply other rules or criteria to determine which memory pages are compressed. In one or more embodiments the memory controller compresses all memory pages in the memory allocated to the program that have been accessed by are instantiated by the program. Memory pages that have not been accessed by the program would store no content for the program and thus would have no content to compress.

The program termination preparation module manages putting the program in a state where the program can be terminated. This includes communicating with the memory controller to compress memory pages that have not already been compressed. Additionally the program termination preparation module determines an amount of memory commit for the program that can be released. The program termination preparation module stores the compressed memory pages to the paged memory and or the storage device . The amount of memory commit for the program that can be released can vary based on the manner in which the compressed memory pages are stored.

In one or more embodiments the program termination preparation module writes the compressed memory pages to one or more additional files other than the page file of the storage device . In this situation the compressed memory pages are stored in neither the paged memory nor the page file and thus all of the memory commit for the program can be released. For example assume that 100 Megabytes MB of memory is committed to the program and that the memory pages used by the program can be compressed so that they take in compressed form 40 MB of memory. In this example the contents of the 40 MB of memory can be written to a file of the storage device and the 100 MB of memory commit for the program can be released.

Alternatively the program termination preparation module writes the compressed memory pages to the paged memory after which one or more pages may be transferred to the page file by the memory controller . In this situation the compressed memory pages are stored in the paged memory or the page file and the amount of memory commit that can be released is the amount committed to the program less the amount of memory into which the memory pages were compressed. For example assume that 100 MB of memory is committed to the program and that the memory pages used by the program can be compressed so that they take in compressed form 40 MB of memory. In this example the memory commit for the 40 MB of compressed memory cannot be released but an amount equal to the difference between the amount of memory committed to the program 100 MB and the amount of memory into which the memory pages were compressed 40 MB can be released 60 MB can be released . This example assumes that the memory pages into which the data is compressed do not themselves take up any additional memory commit. If the memory pages into which the data is compressed do themselves take up additional memory commit then the entire 100 MB of memory commit for the program can be released.

The program termination preparation module notifies the memory allocator of the amount of memory commit for the program that can be released and that memory commit is released. The memory allocator maintains a record e.g. in storage device paged memory or other memory or storage of the system of the amount of memory commit for the program that is released. This record of the released amount of memory commit for the program can be used in situations in which the application is subsequently resumed as discussed in more detail below.

Alternatively in some situations memory pages are released at runtime as discussed above. In such situations the program is active and memory commit is released on a per page basis as memory pages are compressed and an attempt is made to re acquire the memory commit in response to the program accessing a compressed memory page as discussed above. In such situations the memory allocator releases memory pages as they are compressed e.g. and written to memory pages in a compressed store and further maintains a record that identifies which memory pages committed to a program have had their memory commit released. This record e.g. a per page record of each memory page is used by the memory allocator to determine whether memory commit for a memory page is to be re acquired if the memory page is subsequently accessed. If memory commit has not been released for a particular page then the memory commit for that particular page need not be re acquired. However if memory commit has been released for a particular page then an attempt is made to re acquire the memory commit for that particular page.

Releasing memory commit for the program results in conservation of the memory commit in the system . The memory commit that was previously committed to a program that is not able to access the memory at the current time anyway e.g. due to the program being suspended is released allowing the memory commit to be consumed by other programs. For example if 60 MB of memory commit is released due to a program being suspended that 60 MB can be allocated to another program and thus become memory commit of that other program . It should be noted that if the program is not suspended then the program may attempt to access a commit released memory page at which point the memory manager will attempt to re acquire the commit for the memory page allocate a physical page if the attempt to re acquire the commit is successful and decompress compressed data into that physical page.

The program access module manages allowing access to memory of a program that has been suspended or terminated. While in the terminatable state the memory allocated to the program cannot be directly accessed by the program itself or other programs because the content is compressed and the memory into which the content if decompressed would be placed has been released. Various events can occur that include requests to access the address space of a program in the terminatable state. In response to such an event the program access module manages allowing access to at least some of the memory previously allocated to the program by attempting to re obtain also referred to as re acquire the memory commit for at least some of the memory that was previously committed to the program and released. If the attempt to re obtain the memory commit for at least some of the memory is successful then the requested access to the address space of the program is permitted. However if the attempt to re obtain the memory commit for at least some of the memory is unsuccessful then the program is terminated execution of the program ceases . The program can optionally be re launched resulting in a new memory allocation being made to the program which may result in one or more other programs being transitioned to a terminatable or terminated state .

In situations in which running of a program has been suspended or otherwise placed in a non active state the program access module can resume running of the program in response to various events. In one or more embodiments these events include a request to resume running of the program such as a user input requesting to make the application an active application an application that is currently running on the computing device . Additionally or alternatively these events can include other requests such as a request by another program or code to attach to the address space of the program. These other programs or code are typically executed in a more privileged space e.g. in a kernel mode than the program the address space of which is being accessed. These other programs can perform various operations on the address space such as analyze the address space to identify malware.

In such situations the program access module can attempt to re obtain the memory commit for all of the memory that was previously committed to the program and released or alternatively only some of the memory that was previously committed to the program and released. For example the program control module can attempt to re obtain memory commit for enough memory to allow a particular number of memory pages e.g. the memory pages including the portions of the address space being accessed to be accessed. In such situations the memory controller ensures that pages that have not had their commit charge re obtained cannot be accessed in order to avoid violating the rules of commit limits .

The program access module can also determine whether to attempt to re obtain some or all of the memory commit that was previously committed to the program and released based on the type of access being performed. For example if the type of access is a user request to resume running the program then the program access module attempts to re obtain all of the memory commit that was previously committed to the program and released. By way of another example if the type of access is a request by another program to attach to an address space of the program then the program access module attempts to re obtain enough memory commit to allow decompression and access to the memory pages including the portions of the address space being accessed.

The program access module can also determine that for certain types of accesses the memory commit that was previously committed to the program and released need not be re obtained. In one or more embodiments if the type of request is a request by another program to attach to and read from an address space of the program then the memory commit that was previously committed to the program and released need not be re obtained. Memory commit for a memory page that is already backed e.g. in compressed form in the page file need not be re obtained if the memory page is going to be read because no changes will be made to the memory page that would result in the memory page needing to be saved back to the page file or maintained in the paged memory . However if the type of request is a request by another program to attach to and perform a non read access e.g. a write access a memory page lock access etc. then the program access module attempts to re obtain enough memory commit to allow decompression and access to the memory pages including the portions of the address space being accessed.

In other situations as discussed above where the memory manager follows a runtime commit release approach the program remains active and the program access module need not resume running of the program. Rather when a request e.g. by the program or a request by another program to attach to and read from an address space of the program to access a commit released memory page of the program is received the commit is re charged a physical page is allocated and data is decompressed from the compressed store into the physical page. If commit charge fails the commit charge cannot be re acquired then an exception is raised and or the program terminated as discussed above.

In process memory pages of a program are optionally compressed while the program is active act . At least some of the memory pages of a program can optionally be compressed by the memory controller to conserve memory while the program is running as discussed above. However in alternate embodiments no such compression of memory pages while the program is active Occurs.

At some point a determination is made that a program is in a state from which the program can be terminated act . As discussed above the program can be in a state from which the program can be terminated by being transitioned to a terminatable state or by being concurrently in an active and terminatable state.

A subset of the memory pages of the program to be compressed is identified act . The subset of memory pages to be compressed are the memory pages included in the memory allocated to the program that have been accessed by are instantiated by the program and that have not already been compressed e.g. in act .

The identified subset of memory pages is compressed act . The memory pages can be compressed using any of a variety of different compression algorithms or techniques as discussed above.

An amount of memory commit for the program that can be released is determined act . The amount of memory commit that can be released is equal to the value derived by subtracting the amount of memory into which the memory pages were compressed from the amount of memory commit for the program. The memory commit for non instantiated pages memory pages of the program that were not used by the program is included in the amount of memory commit for the program that can be released. The amount of memory commit that can be released can be less than all of the memory commit for the program e.g. in situations in which the compressed memory is stored in a paged memory or page file or all of the memory commit for the program e.g. in situations in which the compressed memory is stored in an additional file on a storage device other than the page file or in situations in which the compressed memory has charged commit for itself .

It should be noted that in some situations certain memory commit for the program cannot be released due to guarantees made to other programs or code e.g. kernel mode drivers . Such memory commit is excluded from the amount of memory commit that can be released as determined in act . Thus the amount of memory commit that can be released is equal to the value derived by subtracting from the amount of memory commit for the program the amount of memory into which the memory pages were compressed and the amount of memory commit that cannot be released due to guarantees made to other programs or code.

The amount of memory commit determined in act is released act . Releasing the memory commit allows that amount of memory commit to be consumed by other programs that are running on the computing device. The commit charge for memory pages of the program that were not used by the program is reduced to zero and the commit charge for memory pages that were used by the program and subsequently compressed is reduced by the compression ratio.

A record of the amount of memory commit that is released is maintained act . This record allows a determination to be subsequently made as to how much memory commit is to be re obtained for a program. In one or more embodiments the record includes an indication of which memory pages committed to a program have had their memory commit released allowing the memory manager to know whether the memory commit for a memory page is to be re acquired if the memory page is accessed as discussed above.

In process a determination is made that one or more memory pages of a program that has had at least part of its memory commit released are to be accessed act . The one or more memory pages can be accessed as part of various different events as discussed above.

An attempt is made to re obtain the memory commit for at least the one or more memory pages of the program act . This attempt can be an attempt to re obtain all of the memory commit that was released e.g. as indicated in the record maintained in act of or a subset of the memory commit e.g. memory commit for particular memory pages being accessed as discussed above.

Process proceeds based on whether the attempt in act is successful act . If the attempt in act is successful then access to the one or more memory pages is allowed act . However if the attempt is unsuccessful then the program is terminated act and optionally re launched act . It should be noted that by terminating and re launching the program memory is allocated to the program in response to a memory allocation request for the program which may result in one or more other programs on the computing device being terminated.

The actions taken in terminating the program can vary based on implementation. In one or more embodiments terminating the program includes tearing down the address space of the program as though the program was exiting and triggering forceful thread termination for all threads in the process that is the running program e.g. which queues messages to the threads to wake up from their suspended state and terminate .

In one or more embodiments care is taken when terminating a program so that synchronization with other programs in the computing device is maintained. The program is terminated in act in a manner that is consistent with what the program as well as any other program e.g. that may have attached to the program being terminated expects. For example the program is terminated in act only if no other program is currently attached to the address space of the program.

Returning to in one or more embodiments the memory management system provides additional support to facilitate saving memory commit. The memory management system allows a program to indicate that a particular amount of memory commit previously allocated to the program can be released if the memory management system desires. By providing such an indication the program is acknowledging that the program can accept a loss of memory commit previously allocated to the program . Such an indication can be provided for example by invoking an application programming interface API exposed by the memory allocator . Providing the indication allows the memory allocator to release some of the memory commit previously allocated to the program and allocate the memory commit to another program that requests allocation of memory.

The techniques discussed herein support various usage scenarios. The techniques discussed herein conserve memory commit in a computing device by reducing the amount of memory commit allocated to programs in the computing device. This increases the number of programs that can be run or suspended in a computing device at any given time without having to terminate the programs. This also decreases the amount of paged memory and or storage device space for the page file needed to allow a given number of programs to be run or suspended in a computing device at any given time without having to terminate any of the programs.

Although particular functionality is discussed herein with reference to particular modules it should be noted that the functionality of individual modules discussed herein can be separated into multiple modules and or at least some functionality of multiple modules can be combined into a single module. Additionally a particular module discussed herein as performing an action includes that particular module itself performing the action or alternatively that particular module invoking or otherwise accessing another component or module that performs the action or performs the action in conjunction with that particular module . Thus a particular module performing an action includes that particular module itself performing the action and or another module invoked or otherwise accessed by that particular module performing the action.

The example computing device as illustrated includes a processing system one or more computer readable media and one or more I O Interfaces that are communicatively coupled one to another. Although not shown the computing device may further include a system bus or other data and command transfer system that couples the various components one to another. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures. A variety of other examples are also contemplated such as control and data lines.

The processing system is representative of functionality to perform one or more operations using hardware. Accordingly the processing system is illustrated as including hardware elements that may be configured as processors functional blocks and so forth. This may include implementation in hardware as an application specific integrated circuit or other logic device formed using one or more semiconductors. The hardware elements are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions.

The computer readable media is illustrated as including memory storage . The memory storage represents memory storage capacity associated with one or more computer readable media. The memory storage may include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . The memory storage may include fixed media e.g. RAM ROM a fixed hard drive and so on as well as removable media e.g. Flash memory a removable hard drive an optical disc and so forth . The computer readable media may be configured in a variety of other ways as further described below.

Input output interface s are representative of functionality to allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices using various input output devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone e.g. for voice inputs a scanner touch functionality e.g. capacitive or other sensors that are configured to detect physical touch a camera e.g. which may employ visible or non visible wavelengths such as infrared frequencies to detect movement that does not involve touch as gestures and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card tactile response device and so forth. Thus the computing device may be configured in a variety of ways as further described below to support user interaction.

Computing device also includes a memory management system . The memory management system provides various functionality for conserving memory by reducing memory commit charge as discussed above. The memory management system can implement for example the memory management system of . Although illustrated as separate from the computer readable media it should be noted that the memory management system can alternatively be implemented as part of the computer readable media .

Various techniques may be described herein in the general context of software hardware elements or program modules. Generally such modules include routines programs objects elements components data structures and so forth that perform particular tasks or implement particular abstract data types. The terms module functionality and component as used herein generally represent software firmware hardware or a combination thereof. The features of the techniques described herein are platform independent meaning that the techniques may be implemented on a variety of computing platforms having a variety of processors.

An implementation of the described modules and techniques may be stored on or transmitted across some form of computer readable media. The computer readable media may include a variety of media that may be accessed by the computing device . By way of example and not limitation computer readable media may include computer readable storage media and computer readable signal media. 

 Computer readable storage media refers to media and or devices that enable persistent storage of information and or storage that is tangible in contrast to mere signal transmission carrier waves or signals per se. Thus computer readable storage media refers to non signal bearing media. The computer readable storage media includes hardware such as volatile and non volatile removable and non removable media and or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions data structures program modules logic elements circuits or other data. Examples of computer readable storage media may include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage hard disks magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other storage device tangible media or article of manufacture suitable to store the desired information and which may be accessed by a computer.

 Computer readable signal media refers to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device such as via a network. Signal media typically may embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier waves data signals or other transport mechanism. Signal media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

As previously described hardware elements and computer readable media are representative of instructions modules programmable device logic and or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement at least some aspects of the techniques described herein. Hardware elements may include components of an integrated circuit or on chip system an application specific integrated circuit ASIC a field programmable gate array FPGA a complex programmable logic device CPLD and other implementations in silicon or other hardware devices. In this context a hardware element may operate as a processing device that performs program tasks defined by instructions modules and or logic embodied by the hardware element as well as a hardware device utilized to store instructions for execution e.g. the computer readable storage media described previously.

Combinations of the foregoing may also be employed to implement various techniques and modules described herein. Accordingly software hardware or program modules and other program modules may be implemented as one or more instructions and or logic embodied on some form of computer readable storage media and or by one or more hardware elements . The computing device may be configured to implement particular instructions and or functions corresponding to the software and or hardware modules. Accordingly implementation of modules as a module that is executable by the computing device as software may be achieved at least partially in hardware e.g. through use of computer readable storage media and or hardware elements of the processing system. The instructions and or functions may be executable operable by one or more articles of manufacture for example one or more computing devices and or processing systems to implement techniques modules and examples described herein.

As further illustrated in the example system enables ubiquitous environments for a seamless user experience when running applications on a personal computer PC a television device and or a mobile device. Services and applications run substantially similar in all three environments for a common user experience when transitioning from one device to the next while utilizing an application playing a video game watching a video and so on.

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one or more embodiments the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link.

In one or more embodiments this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one or more embodiments a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on.

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on.

The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples of the techniques described herein. This functionality may also be implemented all or in part through use of a distributed system such as over a cloud via a platform as described below.

The cloud includes and or is representative of a platform for resources . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The resources may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Resources can also include services provided over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the resources that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

In the discussions herein various different embodiments are described. It is to be appreciated and understood that each embodiment described herein can be used on its own or in connection with one or more other embodiments described herein. Further aspects of the techniques discussed herein relate to one or more of the following embodiments.

A method of reducing an amount of memory commit for a program in a computing device the method comprising determining that the program is in a state from which the program can be terminated an amount of memory having been committed to the program the amount of memory being a memory commit for the program a subset of the amount of memory committed to the program having been used by the program and the amount of memory committed to the program including multiple memory pages compressing the content of the memory pages in the subset of memory used by the program determining an amount of the memory commit for the program that can be released and releasing after the subset of memory used by the program has been compressed the determined amount of the memory commit for the program.

Alternatively or in addition to any of the above described methods any one or combination of the state from which the program can be terminated comprising a terminatable state in which a processing state of the program has been saved and to which the program can be subsequently resumed the state from which the program can be terminated comprising an active state the compressing comprising compressing by a memory controller of the computing device one or more of the subset of memory pages while the program is running and prior to the program being transitioned into the state from which the program can be terminated the compressing the content of the memory pages comprising compressing by a memory controller of the computing device in response to determining that the program has been transitioned into the state from which the program can be terminated one or more of the subset of memory pages the subset of memory used by the program comprising memory pages accessed by or instantiated by the program the subset of memory used by the program comprising less than all of the memory committed to the program the amount of memory commit for the program that can be released comprising all of the memory committed to the program the amount of memory commit for the program that can be released comprising an amount equal to all of the memory committed for the program less an amount of memory used in which the compressed content is stored and further comprising after releasing the memory commit for the amount of memory that can be released determining that one or more memory pages of the program are to be accessed attempting to re obtain the memory commit for at least the one or more memory pages of the program allowing in response to the attempt to re obtain the memory commit being successful the one or more memory pages to be accessed and terminating and re launching in response to the attempt to re obtain the memory commit being unsuccessful the program.

A method of reducing an amount of memory commit for a program in a computing device the method comprising determining that one or more memory pages of the program are to be accessed the program having had at least part of its memory commit released attempting to re obtain the memory commit for at least the one or more memory pages of the program allowing in response to the attempt to re obtain the memory commit being successful the one or more memory pages to be accessed and terminating and re launching in response to the attempt to re obtain the memory commit being unsuccessful the program.

Alternatively or in addition to any of the above described methods any one or combination of the attempting to re obtain the memory commit for at least the one or more memory pages comprising attempting to re obtain all of the previously released memory commit for the program the attempting to re obtain the memory commit for at least the one or more memory pages comprising attempting to re obtain memory commit for each of the one or more memory pages on a per page basis as requests to access the memory page are received the determining comprising determining that the one or more memory pages are to be accessed by code attaching to an address space of the program the determining further comprising determining that the one or more memory pages of the program are to be accessed by a write request or a lock request from the code attaching to the address space of the program further comprising allowing without attempting to re obtain memory commit for at least one of the one or more memory pages of the program the one or more memory pages to be accessed in response to determining that the one or more memory pages of a program are to be accessed by a read request from the additional program and the determining comprising determining that the one or more memory pages are to be accessed in response to a user request to run the program.

A computing device including a memory management system configured to conserve memory commit in the computing device the memory management system comprising a program termination preparation module configured to determine that a program is in a state from which the program can be terminated an amount of memory having been committed to the program the amount of memory being a memory commit for the program a subset of the amount of memory committed to the program having been used by the program and the amount of memory committed to the program including multiple memory pages have the content of the memory pages in the subset of memory used by the program compressed determine an amount of the memory commit for the program that can be released and release after the subset of memory used by the program has been compressed the determined amount of memory commit for the program and a program access module configured to after release of the commit charge for the amount of memory that can be released determine that one or more memory pages of the program are to be accessed attempt to re obtain the memory commit for at least the one or more memory pages of the program allow in response to the attempt to re obtain the memory commit being successful the one or more memory pages to be accessed and terminate and re launch in response to the attempt to re obtain the memory commit being unsuccessful the program.

Alternatively or in addition to any of the above described computing devices any one or combination of the memory management system further including a memory allocator configured to receive from the program an indication that a previously allocated amount of memory commit can be released if desired by the memory allocator and to release the previously allocated amount of memory commit and allocate the previously allocated amount of memory commit to another program of the computing device the program termination preparation module being further configured to have the content of the memory pages compressed by a memory controller of the memory management system in response to determining that the program has been transitioned into the state from which the program can be terminated wherein to attempt to re obtain the memory commit for at least the one or more memory pages is to attempt to re obtain memory commit for each of the one or more memory pages on a per page basis as requests to access the memory page are received and wherein to determine that the one or more memory pages of the program are to be accessed is to determine that the one or more memory pages are to be accessed by code attaching to an address space of the program.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

