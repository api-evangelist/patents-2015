---

title: Method for increasing cache size
abstract: A method for increasing storage space in a system containing a block data storage device, a memory, and a processor is provided. Generally, the processor is configured by the memory to tag metadata of a data block of the block storage device indicating the block as free, used, or semifree. The free tag indicates the data block is available to the system for storing data when needed, the used tag indicates the data block contains application data, and the semifree tag indicates the data block contains cache data and is available to the system for storing application data type if no blocks marked with the free tag are available to the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519593&OS=09519593&RS=09519593
owner: Hola Networks Ltd.
number: 09519593
owner_city: Netanya
owner_country: IL
publication_date: 20151028
---
The present application is a continuation application and claims priority to co pending U.S. patent application Ser. No. 14 210 995 filed on Mar. 14 2014 and having the title METHOD FOR INCREASING CACHE SIZE which is a continuation of and claims priority to U.S. patent application Ser. No. 14 024 977 filed on Sep. 12 2013 and having the title METHOD FOR INCREASING CACHE SIZE now patented as U.S. Pat. No. 8 719 505 issued on May 6 2014 which is a continuation of and claims priority to U.S. patent application Ser. No. 13 363 784 filed on Feb. 1 2012 and having the title SYSTEM AND METHOD FOR INCREASING CACHE SIZE now patented as U.S. Pat. No. 8 578 098 issued on Nov. 5 2013 which is a continuation of and claims priority to U.S. patent application Ser. No. 12 467 814 filed on May 18 2009 and having the title SYSTEM AND METHOD FOR INCREASING CACHE SIZE now patented as U.S. Pat. No. 8 135 912 issued on Mar. 13 2012 all of which are incorporated herein by reference in their entirety.

The present invention is generally related to electronic storage and more particularly is related to maximizing cache size.

Information stored by applications may be viewed as two types namely application data and cached data. Application data is data that an application or its users depends on for normal operation. Examples of application data may include bank account information stored by a bank application or a document saved by a word processing application. Application data may be regarded as requiring 100 storage reliability because application data that is written to a storage device must always be retrievable.

Unlike application data cached data is data that the application does not depend on for normal operation but that is stored in order to possibly benefit from for purposes of accelerating application operation. Specifically a cache is a temporary storage area where frequently used data can be stored for rapid access. This data is referred to as cached data. Once the data is stored in the cache future use by an application can be made by accessing the cached copy rather than re fetching or re computing the original data so that the average access time is shorter. An example of cached data may be pages stored by a Web browser after the pages were viewed just in case the user wants to view the pages again. In this example if the user wants to view the pages again but the cached copies of the pages which were written to the cache are no longer found the browser will maintain its normal mode of operation by bringing that information from the web site itself

As is known by those having ordinary skill in the art for each memory block the block storage handler and device driver maintain data that describes the memory block. This information about the block may contain the address of the memory block size or other characteristics of the memory block. As is also known a file system typically has two types of blocks namely used which are blocks that currently contain data which is to be kept and free which are blocks that may be used by the file system to store data in the future. A memory block typically has metadata associated with it where the metadata that may include any type of information related to the block that is useful for the operating system.

Unfortunately file systems today treat reliable data application data in the same way that the non reliable data cached data is treated. Specifically both application data and cached data are stored into free memory blocks after which the block is categorized as used. This brings about a reality where applications are careful about how much cached data is saved so that enough room is left on a storage device for the application data. The result is lower performance for the overall system than may theoretically be achieved.

Thus a heretofore unaddressed need exists in the industry to address the aforementioned deficiencies and inadequacies.

Embodiments of the present invention provide a system and method for increasing cache size. Briefly described in architecture one embodiment of the system among others can be implemented as follows. The system contains a memory and a processor wherein the processor is configured by the memory to perform the steps of categorizing storage blocks within the storage device within a first category of storage blocks if the storage blocks are available to the system for storing data when needed categorizing storage blocks within the storage device within a second category of storage blocks if the storage blocks contain application data therein and categorizing storage blocks within the storage device within a third category of storage blocks if the storage blocks are storing cached data and are available for storing application data if no first category of storage blocks are available to the system.

Other systems methods and features of the present invention will be or become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods and features be included within this description be within the scope of the present invention and be protected by the accompanying claims.

The present system and method provides for increasing the total amount of cached data that may be stored on a storage device without diminishing from the storage space available for normal application data by allowing for non deterministic file handling. Specifically cached data is stored on the free space of a storage device however the space on which cached data is stored is still regarded as free space for application data. By providing for non deterministic file handling much more cache data can be stored than in regular file systems since there is no concern about conserving space for future application data. It should be noted that a non deterministic file or block is the same as a non reliable file or block and a deterministic file or block is the same as a reliable file or block.

While the following describes the present system and method in detail it is beneficial to provide certain definitions that are known to those having ordinary skill in the art.

Cache Cache is a collection of data duplicating original values stored elsewhere or computed earlier where the original data is expensive to fetch owing to longer access time or to compute compared to the cost of reading the cache. In other words a cache is a temporary storage area where frequently accessed data can be stored for rapid access. Once the data is stored in the cache future use can be made by accessing the cached copy rather than re fetching or re computing the original data so that the average access time is shorter. Cache has proven to be extremely effective in many areas of computing because access patterns in typical computer applications have locality of reference.

Data Storage Device A data storage device is a device for recording storing information data . Recording can be done using virtually any form of energy spanning from manual muscle power in handwriting to acoustic vibrations in phonographic recording to electromagnetic energy modulating magnetic tape and optical discs. A storage device may hold information process information or both. A device that only holds information is a recording medium. Devices that process information data storage equipment may either access a separate portable removable recording medium or a permanent component to store and retrieve information.

Block In computing specifically data transmission and data storage a block is a sequence of bytes or bits having a nominal length a block size . Data thus structured is said to be blocked. The process of putting data into blocks is referred to as blocking. Blocking is used to facilitate the handling of the data stream by a computer program receiving the data. Blocked data is normally read a whole block at a time. Blocking is almost universally employed when storing data to 9 track magnetic tape to rotating media such as floppy disks hard disks optical discs and to NAND flash memory. Most file systems are based on a block device which is a level of abstraction for the hardware responsible for storing and retrieving specified blocks of data though the block size in file systems may be a multiple of the physical block size. It should be noted that in classical file systems a single block may only contain a part of a single file.

File System Most file systems make use of an underlying data storage device that offers access to an array of fixed size blocks sometimes referred to as sectors generally a power of 2 in size 512 bytes or 1 2 or 4 Kb are most common . File system software is responsible for organizing these sectors into files and directories and keeping track of which sectors belong to which file and which sectors are not being used. Most file systems address data in fixed sized units called clusters or blocks which contain a certain number of disk sectors usually 1 64 . This is the smallest logical amount of disk space that can be allocated to hold a file. However it is noted that file systems need not make use of a storage device at all. A file system can be used to organize and represent access to any data whether it be stored or dynamically generated.

Metadata Metadata is bookkeeping information typically associated with each file within a file system. The length of the data contained in a file may be stored as the number of blocks allocated for the file or as an exact byte count. The time that the file was last modified may be stored as the timestamp of the file. Some file systems also store the file creation time the time it was last accessed and the time that the metadata of the file was changed. Other information can include the device type e.g. block character socket subdirectory or other device types owner user ID and group ID and access permission settings of the file e.g. whether the file is read only executable or other properties .

The present system and method also referred to herein as a caching system and method can be implemented in software firmware hardware or a combination thereof. In a first exemplary embodiment the caching system is provided by a special or general purpose digital computer such as a personal computer workstation minicomputer PDA mobile computing platform or mainframe computer. The first exemplary embodiment of a general purpose computer architecture that can implement the caching system is shown in .

Generally in terms of hardware architecture as shown in the computer includes a processor memory storage device and one or more input and or output I O devices or peripherals that are communicatively coupled via a local interface . The local interface can be for example but not limited to one or more buses or other wired or wireless connections as is known in the art. The local interface may have additional elements which are omitted for simplicity such as controllers buffers caches drivers repeaters and receivers to enable communications. Further the local interface may include address control and or data connections to enable appropriate communications among the aforementioned components.

The processor is a hardware device for executing software particularly that stored in the memory . The processor can be any custom made or commercially available processor a central processing unit CPU an auxiliary processor among several processors associated with the computer a semiconductor based microprocessor in the form of a microchip or chip set a macroprocessor or generally any device for executing software instructions.

The memory can include any one or combination of volatile memory elements e.g. random access memory RAM such as DRAM SRAM SDRAM etc. and nonvolatile memory elements e.g. ROM hard drive tape CDROM etc. . Moreover the memory may incorporate electronic magnetic optical and or other types of storage media. Note that the memory can have a distributed architecture where various components are situated remote from one another but can be accessed by the processor .

Software in the memory may include one or more separate programs each of which comprises an ordered listing of executable instructions for implementing logical functions of the caching system as described below. In the example of the software in the memory defines certain functionality of the caching system in accordance with the present invention as is described in detail herein. In addition the memory contains an operating system O S . The operating system essentially controls the execution of computer programs and provides scheduling input output control file and data management memory management and communication control and related services. further illustrates certain elements of the O S as is described below.

Returning to the caching system may be provided by a source program executable program object code script or any other entity containing a set of instructions to be performed. When a source program then the program needs to be translated via a compiler assembler interpreter or the like which may or may not be included within the memory so as to operate properly in connection with the O S . Furthermore the caching system can be written as a an object oriented programming language which has classes of data and methods or b a procedure programming language which has routines subroutines and or functions.

The I O devices may include input devices for example but not limited to a keyboard mouse scanner microphone or other input device. Furthermore the I O devices may also include output devices for example but not limited to a printer display or other output device. Finally the I O devices may further include devices that communicate via both inputs and outputs for instance but not limited to a modulator demodulator modem for accessing another device system or network a radio frequency RF or other transceiver a telephonic interface a bridge a router or other device.

The storage device may be any block data storage device such as but not limited to floppy disks hard disks or hard drives optical discs NAND flash memories or any storage device capable of maintaining a sequence of bytes or bits having a nominal length block size .

When the caching system is in operation the processor is configured to execute the software stored within the memory to communicate data to and from the memory and to generally control operations of the computer pursuant to the software . The software and the O S in whole or in part but typically the latter are read by the processor perhaps buffered within the processor and then executed.

When the caching system is implemented in software it should be noted that the caching system can be stored on any computer readable medium for use by or in connection with any computer related system or method. In the context of this document a computer readable medium is an electronic magnetic optical or other physical device or means that can contain or store a computer program for use by or in connection with a computer related system or method. The caching system can be embodied in any computer readable medium for use by or in connection with an instruction execution system apparatus or device such as a computer based system processor containing system or other system that can fetch the instructions from the instruction execution system apparatus or device and execute the instructions. In the context of this document a computer readable medium can be any means that can store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable medium can be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection electronic having one or more wires a portable computer diskette magnetic a random access memory RAM electronic a read only memory ROM electronic an erasable programmable read only memory EPROM EEPROM or Flash memory electronic an optical fiber optical and a portable compact disc read only memory CDROM optical . Note that the computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory.

In an alternative embodiment where the caching system is implemented in hardware the caching system can be implemented with any or a combination of the following technologies which are each well known in the art a discrete logic circuit s having logic gates for implementing logic functions upon data signals an application specific integrated circuit ASIC having appropriate combinational logic gates a programmable gate array s PGA a field programmable gate array FPGA or other technologies.

As previously mentioned further illustrates certain elements of the O S . As shown by the block diagram of the O S contains a file system application programming interface API a block storage API and a block storage device driver . The file system API provides a programming interface for data storage manipulation and the block storage API provides a programming interface to the file system for storing discrete elements on the storage device . In addition the block storage device driver is a piece of software stored within the O S that manipulates the block storage device of the computer to provide the functionality of the O S .

Contrary to the prior art which only provides a free and used category for storage blocks the present caching system and method adds a third category for storage blocks namely semifree. A semifree block is one that is storing cached data and which may be consumed by application data if no free blocks are available for the application data. To provide this new category type the file system is modified to add this type of data tag to the metadata of each block of data. This tag marks each data block of the storage device as either free semifree or used and is continuously updated by the file system of the computer as required. It should be noted that the modification to the file system is not only in tagging the blocks but also manipulating them differently the blocks differently as is described herein in detail.

In accordance with the present caching system and method as is explained in more detail below when an application stores data the application requests from the operating system that this data be stored in a deterministic fashion or in a non deterministic fashion. Storing in a deterministic fashion means that the data must be stored in a manner so that the application must be able to retrieve the data in the future. Alternatively storing in a non deterministic fashion means that it is not mandatory that the data be stored in a manner so that the application is able to retrieve the data in the future.

The present system and method uses deterministic storage for storing application data and non deterministic storage for storing cached data. The method of storage is selected by the application when calling the file system API of the operating system . When deterministic storage is called for meaning that a call is made by an application to save application data the O S looks for storage blocks that are free meaning that the storage blocks are not being used for application data or cached data and allocates those blocks for the new data stored. If no such blocks are found then the O S will use blocks identified as semifree meaning that the blocks are storing cached data and thus will decrease the total size of the cached data to provide the required space for the application data.

Alternatively when non deterministic storage is called for meaning that a call is made by an application to save cache data the file system looks for free storage blocks to use for this purpose. If no such free blocks are found the file system returns an error code to which an application may respond by asking to free other cached data semifree blocks that are less important to the application.

Fortunately the abovementioned process which is described in detail below provides applications with the ability to use all of the available space on a storage device for cached data without compromising application data. This increases the size available to caching systems thereby potentially increasing performance of applications.

Non deterministic file system calls allocate free blocks and mark them as semifree for the duration of their use as cache data storage blocks on the storage device while these blocks may be overwritten by deterministic file system calls . Both types of files use a block manipulation system for handling both deterministic and non deterministic files. A block storage handler and device driver which manipulates blocks of data is the same as in the prior art and is in communication with the storage device .

For each block of data on the storage device there exists metadata that is used by the O S . For each block within the storage device metadata is stored. In addition to the metadata stored a block status marker is added to each block of the storage device . The block status marker may be one of free semifree or used. 

In comparison to the prior art is a schematic diagram illustrating the block storage device of the computer . As shown by the free space on the storage device is partitioned as either totally free space which is marked as free space that is used for caching but is free to the user to use which is marked as semifree or space used by applications for deterministic storage which is marked as used. 

Having described the structure of the present caching system the following further describes functionality performed by the caching system . is a flowchart illustrating high level functions performed by the caching system in receiving and handling deterministic and non deterministic commands in accordance with a first exemplary embodiment of the invention. Specifically the file system of the present invention determines whether a command received from an application is deterministic reliable file manipulation or not and calls on the block manipulation system the functions of which are outlined in .

It should be noted that any process descriptions or blocks in flowcharts should be understood as representing modules segments portions of code or steps that include one or more instructions for implementing specific logical functions in the process and alternative implementations are included within the scope of the present invention in which functions may be executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved as would be understood by those reasonably skilled in the art of the present invention.

Deterministic file system calls are called directly to the deterministic file system driver while non deterministic calls are made directly to the non deterministic file system call driver . If a received command is deterministic then regular block I O and file system manipulation is performed block and the relevant block within the storage device used for storing of the data is updated to be marked as used as long as the data is stored within the block or free if the block was released by the file system block It should be noted that if release is called through a deterministic file system call such as for deterministic data then the regular release process is done. If release is called through the non deterministic system call then all the blocks in the file that is being released a cache file are marked as free and removed from the metadata of the system. The system then awaits additional commands.

Alternatively if the block manipulation system determines that a command is not deterministic non deterministic the block manipulation system determines if any block from the file was over written by the file system with reliable data application data block by checking the status of the block. As an example if the block is still marked as semifree then the block was not overwritten with application data. If the block was overwritten with application data the block manipulation system returns an error message showing that the block no longer exists specifically that the block was overwritten by application data and therefore does not exist for caching. If the block was not overwritten with application data then the block still contains the information originally saved on it. In such a case regular block handling is performed . The status of the block in the storage device is set to free if the block was released and to semifree if the block continues to store cached data block . The system then awaits additional commands.

If the command is for a non deterministic block allocation the block manipulation system looks for a free block in the storage device block . If during searching for a free block block a free block of storage is not found the function returns an error message since there is no more free space to allocate block . Alternatively if a free block is found the block is marked as semifree block .

If the command is for a deterministic block allocation the block manipulation system looks for a block marked as free block . If during looking for a free block block a free block is found the block manipulation system marks the free block as used block . It should be noted that provides an illustration of allocation of a new block. As a result once a free or semifree block is found the block is allocated but not necessarily written to. Instead the block gets written to when a write command is issued on this allocated block. If however a free block is not found the block manipulation system looks for a block marked as semifree block that is currently being used for the non deterministic storage for cached data . If during looking for a semifree block block a semifree block is found currently being used for non deterministic storage the block manipulating system marks the block as used block and allocates the block. Alternatively if no semifree block is found an error message is returned to the user block .

If the command is for non deterministic block operation the block manipulation system determines whether the block still belongs to the non deterministic file system by checking if the block status is still semifree block . If the block is still semifree the block manipulation system writes to the semifree block block . Alternatively if the block is not semifree the block manipulation system returns an error meaning that the block no longer exists block . It should be noted that a block no longer existing means that the block no longer belongs to the non deterministic file system namely that the block was allocated to a deterministic file and is no longer relevant for our needs and cannot be written to.

If the command is not for reliable block operation namely for non deterministic block operation the block manipulation system determines whether the block still belongs to the non deterministic file system by checking if the block status is still semifree block . If the block is still semifree the block manipulation system reads the semifree block block and returns the read data from the read block to the user of the system block . Alternatively if the block is not semifree the block manipulation system returns an error meaning that the block no longer exists block .

If the command is not for reliable block operation namely for non deterministic block operation the block manipulation system determines whether the block still belongs to the non deterministic file system by checking if the block status is still semifree block and returns an error block . If the block is still semifree the block manipulation system performs normal file system activities for releasing a block block . The block is then marked as free for future use block .

If the command is for deterministic file operation the block manipulation system performs regular file system activities for releasing a block block . The block is then marked as free for future use block and success is returned block .

In accordance with the first exemplary embodiment of the invention as described above the file system is required to be replaced including the block storage handler of the prior art. It should be noted however that in accordance with a second exemplary embodiment of the invention the present cache system and method is implemented by a separate method that does not involve the replacing of the file system. The second exemplary embodiment of the invention is described in detail below.

In this system of the second exemplary embodiment regular file system calls namely calls for reliable data storage are called directly to the existing file system API of the prior art. The applications that require cache storage may call a non deterministic file system API which acts in parallel to the existing file system API. There also exists a listener module which listens on the standard communication of the file system driver while the alternative implementation module uses the block device driver to read and write directly to the storage device based on the information that the listener module collects. As is known by those having ordinary skill in the art a module is a separate piece of software that is referred to as an entity for simplicity.

A file system driver similar to the file system driver of the prior art is called by the operating system file system API . A listener module creates a map of the storage blocks in use by listening on the input of a block storage handler and device driver and by querying the file system driver for information regarding data blocks. It should be noted that the listener module s role is to understand which blocks have been written to by the operating system and which are free so that the alternative file system can operate in a correct fashion.

The listener module keeps track of the data blocks that the file system is using. For each read and write command received the listener module updates a table located within this is a table of metadata which is stored in the storage device referred to herein as the ND BLOCK STORAGE DB with a checksum of the block that is being written or written to and updates the table as verified. A verified block is a block for which the non deterministic system is sure about the contents of the block. It should be noted that initially all blocks are marked as unverified. 

During allocation of the blocks block the block storage device is asked to allocate a best space for an empty block for the system block . It should be noted that in systems where the block storage device can be asked to allocate a block in a specific storage location the heuristic determines where the best place for the block would be by learning the previous allocation patterns of the operating system. In systems where the block device cannot be asked to allocate in a specific storage location the heuristic is not active. In accordance with the alternative embodiment of the invention the best space is found by applying the heuristic whose primary goal is to find a space for this block that is assumed to be less likely to be overwritten soon by the known file system as an example finding a space that is distanced from other spaces that have recently been written to. As shown by block when each block is written the block it is added to the table of ND BLOCK STORAGE DB and marked as verified. 

As shown by block a determination is then made as to whether the checksum in the table of ND FILE SYSTEM DB which is the checksum that is expected to be stored in the block matches the checksum of the block in the table of ND BLOCK STORAGE DB . If there is a match it means that the block physically stored contains the data that was expected for the file. A determination is then made to determine if all blocks of the file have been verified block . If all blocks have not been verified the process continues until all blocks have been verified after which the user is provided with confirmation of success block . Alternatively as shown by block if the checksum is not the same the block is removed from the storage device and an error is returned to the user block .

Returning to a determination is made as to whether when checking if the file was valid an error was returned block . As is shown by block if the file is not valid an error is returned. If instead the file is valid a determination is then made to determine if the size of the file needs to be increased for the write action block . As shown by block if the file size does need to be increased the increase is performed by allocating new blocks. Then the blocks are added to the list of blocks associated with the specific file block . After creating each new block a determination is made as to whether more new blocks are required block . If the system has not completed the creation of new block new blocks are added. Alternatively data is written to all related blocks and the table of ND BLOCK STORAGE DB is updated with the checksum of the related blocks after which verification of the blocks is set to yes block .

Returning to if the block does not contain data in which the user is interested in all of the blocks of that file are released from the tables of the database block the file is deleted from the table of ND FILE SYSTEM DB block and an error message is returned to the user block .

Alternatively if the block does contain data in which the user is interested the block is read and added to a buffer block . It should be noted that the non deterministic file may contain a number of blocks. When reading the file all blocks have to be read and their aggregate content is the file that the application wants to get from the system. For this purpose a buffer is allocated at the onset of this action in and its contents are then returned to the user. A determination is then made to see if all blocks of the file being read have been considered block and if so a completion notification is returned to the user block .

As previously mentioned the process of determining if a block is valid is illustrated by the flowchart of . As shown by block the block of the file is read and the checksum of the block is calculated. The calculated checksum of the block is compared to the recorded checksum of the block block . When comparing the checksums block if the checksums are the same the system knows that the block is valid block . Alternatively if the checksums are not the same the block is known not to be valid block .

It should be noted that the present invention is intended to cover other ways of implementing storage of cache on free portions of the disk storage device . As an example the names free used and semifree need not be used but instead other designations for blocks may be used such as for example but not limited to a first second and third category of storage blocks. As such the first category of storage blocks includes storage blocks that are available to the system for storing data when needed the second category of storage blocks includes storage blocks containing application data therein and storage blocks within the third category of storage blocks includes storage blocks that are storing cached data and that are available for storing application data if no first category of storage blocks are available to the system. One having ordinary skill in the art will appreciate that non used blocks as categorized by the present system and method are viewed by the user and application as free space.

In addition to the abovementioned it is noted that in accordance with the present invention it is possible for a block to be in use by the non deterministic system i.e. marked semifree then used and released by the deterministic system i.e. marked as used then free and then allocated again by the non deterministic system i.e. marked as semifree now . As a result when the non deterministic system wants to read the data from this block the system would see that the block is still marked as semifree and the system would assume that the information on the block is correct. In accordance with an alternative embodiment of the invention this situation can be fixed by either storing the checksum of the block as metadata or by marking blocks as obsolete in the non deterministic system once the blocks been overwritten by the deterministic file system.

It should be emphasized that the above described embodiments of the present invention are merely possible examples of implementations merely set forth for a clear understanding of the principles of the invention. Many variations and modifications may be made to the above described embodiments of the invention without departing substantially from the spirit and principles of the invention. All such modifications and variations are intended to be included herein within the scope of this disclosure and the present invention and protected by the following claims.

