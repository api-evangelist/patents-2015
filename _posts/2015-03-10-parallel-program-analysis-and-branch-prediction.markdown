---

title: Parallel program analysis and branch prediction
abstract: Systems and methods for predicting execution paths of at least one target program of a plurality of programs that are run in parallel are described. In one method, execution flows of programs are generated. In addition, the programs are executed to obtain debug logs from the programs. Further, communication messages transmitted between the execution flows are identified from the debug logs. A deduction that at least one conditional branch was taken in at least one given execution flow of the first execution flows by the target program is made based on the communication messages. Based on the deduction, at least one conditional branch that was not taken is removed from the given execution flow. In addition, modified execution flows that were modified in accordance with the removal are output to indicate predicted execution paths of the target program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454375&OS=09454375&RS=09454375
owner: International Business Machines Corporation
number: 09454375
owner_city: Armonk
owner_country: US
publication_date: 20150310
---
This application is a Continuation application of co pending U.S. patent application Ser. No. 13 955 669 filed on Jul. 31 2013 which is commonly assigned and incorporated by reference herein.

The present invention relates to parallel program analysis and more particularly to predicting execution flows of parallel programs.

Predicting the behavior of the programs executed on a computer is relatively complicated due to a multitude of possible execution flows resulting from various conditional branches that can be taken and combinations of branches that can be taken by the programs. The problem is even more complex when considering the realistic and practical scenario in which several programs and processes are executed simultaneously and in which the various programs and processes can affect the execution of other programs and processes. There are many different types of programs which process in parallel among a plurality of hosts and processes. These programs communicate with each other while executing various processes and their behavior changes frequently as messages are exchanged between programs and processes. Debug messages generated by the program can be used to identify the behavior of the programs.

One embodiment of the present invention is directed to a method for predicting execution paths of at least one target program of a plurality of programs that are run in parallel. In accordance with the method first execution flows of the plurality of programs are generated. In addition the programs are executed to obtain debug logs from the programs. Further communication messages transmitted between the execution flows are identified from the debug logs. A deduction that at least one conditional branch was taken in at least one given execution flow of the first execution flows by the target program is made based on the communication messages. Based on the deduction at least one conditional branch that was not taken is removed from the given execution flow. In addition modified execution flows that were modified in accordance with the removal are output to indicate predicted execution paths of the target program.

Another embodiment of the present invention is directed to a non transitory computer readable medium comprising a computer readable program for predicting execution paths of at least one target program of a plurality of programs that are run in parallel wherein the computer readable program when executed on a computer causes the computer to perform the following steps generating first execution flows of the plurality of programs executing the programs to obtain debug logs from the programs identifying communication messages transmitted between the execution flows from the debug logs deducing that at least one conditional branch was taken in at least one given execution flow of the first execution flows by the target program based on the communication messages and removing based on the deduction at least one conditional branch that was not taken from the given execution flow and outputting modified execution flows that were modified in accordance with the removal to indicate predicted execution paths of the at least one target program.

Another embodiment of the present invention is directed to a system for predicting execution paths of at least one target program of a plurality of programs that are run in parallel. The system includes a module a parallel program analysis module and a third module. The module is configured to generate first execution flows of the programs. In addition the parallel program analysis module is configured to execute the programs to obtain debug logs from the programs identify communication messages transmitted between the execution flows from the debug logs deduce that at least one conditional branch was taken in at least one given execution flow of the first execution flows by the target program based on the communication messages and remove at least one conditional branch that was not taken from the given execution flow. Further the third module is configured to output modified execution flows that were modified in accordance with the removal of the conditional branch that was not taken to indicate predicted execution paths of the at least one target program.

These and other features and advantages will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

Embodiments of the present invention described herein are directed to determining the most likely executed branches of programs that are run in parallel. In particular preferred embodiments are directed to interrelated programs that send and receive messages between themselves and as a result affect the various processes run by the programs. The determination of the executed branches and more importantly the determination of branches that are likely not executed can provide insights that enable the improvement of the efficiency of executing the programs. For example as noted below in preferred embodiments of the present invention unnecessary modules or tasks of an operating system such as application programming interfaces associated with unlikely branches can be removed from the operating system to conserve resources and expedite processing calls associated with the parallel execution of the programs. In addition the embodiments can achieve this without in any way modifying the software of the parallel programs or adding new debugging software to the programs.

In general it is difficult to predict and identify the paths taken in an execution flow of a program using only the debug messages provided by the program when the program interacts with other programs run in parallel. Further it is also difficult for developers to add new debug message software to any of the programs without affecting their functionality and operability. Moreover the debugging features of the programs have limits on the number of debug messages they produce because such software needs to execute effectively in real time and concurrently with the debugging features.

As discussed in detail herein below in accordance with various aspects of the present invention the most likely executed branches of the program are determined by static analysis of the program code and by employing debug logs of the executed program without modification of the program or the execution environment. Here the static analysis finds all workflows of the program including points at which the portions of the debug log are output as well as send receive application programming interface pairs. Further the executed workflows of other programs run in parallel with the target program can also be found by static analysis and the paths taken by the execution flows of the other programs can be determined based on the effects of the execution flows of the target program on these programs. Moreover by determining and predicting the execution flows of the parallel programs processing efficiency can be improved by removing modules and scheduled tasks of the operating system associated with branches that are not likely to be taken as mentioned above and as described in detail herein below.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium which is different from a computer readable signal medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing. Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the blocks may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Reference in the specification to one embodiment or an embodiment of the present invention as well as other variations thereof means that a particular feature structure characteristic and so forth described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of the phrase in one embodiment or in an embodiment as well any other variations appearing in various places throughout the specification are not necessarily all referring to the same embodiment.

It is to be appreciated that the use of any of the following and or and at least one of for example in the cases of A B A and or B and at least one of A and B is intended to encompass the selection of the first listed option A only or the selection of the second listed option B only or the selection of both options A and B . As a further example in the cases of A B and or C and at least one of A B and C such phrasing is intended to encompass the selection of the first listed option A only or the selection of the second listed option B only or the selection of the third listed option C only or the selection of the first and the second listed options A and B only or the selection of the first and third listed options A and C only or the selection of the second and third listed options B and C only or the selection of all three options A and B and C . This may be extended as readily apparent by one of ordinary skill in this and related arts for as many items listed.

Referring now to the drawings in which like numerals represent the same or similar elements and initially to a block flow diagram illustrating a simplified representation of programs and and processing characteristics of interest is depicted. Here the program A sends a message to the program B along timeline . In turn program B includes a decision step at which the program determines which of two conditional branches and it will take. In this example the conditional branch receives a message at block along time line . Exemplary embodiments of the present invention described herein can determine the execution flows of the programs by static analysis and can deduce which conditional branches are likely to be taken and not taken based on debug logs obtained by executing the programs. For example the system can deduce that the branch is taken by matching the conditional branch of the program B with the send message of the program A by using log times of the debug logs of the executed programs. Further based on this information the operating system can be modified by removing any unnecessary modules and tasks associated with the branch that is not likely to be taken branch thereby improving the processing efficiency of the operating system when running the programs in parallel.

With reference now to an exemplary system for predicting execution paths of at least one target program of a plurality of programs that are run in parallel is illustratively depicted. The system can include a static analysis module a parallel program analysis module and a pruning module . The static analysis module can receive source code information of the programs to be run in parallel and can output an initial set of execution flows to the parallel program analysis module . In turn the parallel program analysis module can analyze the execution flows with debug logs obtained by executing the programs in parallel.

Further the parallel program analysis module can deduce most likely and least likely branches of the execution flows and can remove the least likely branches from the execution flows to produce the set of execution flows . In addition the pruning module can prune the set of execution flows using for example send receive API pairs as discussed further herein below. The pruning module can then modify the execution flows to remove additional unlikely branches and thereby generate modified execution flows . The system can also include a controller of an operating system that is configured to modify the operating system to remove unnecessary tasks and modules.

To illustrate the various functionalities of the system reference is made to depicting a block flow diagram of a method for predicting execution paths of at least one target program of a plurality of programs that are run in parallel which can be performed by the system . Reference is also made to which provides a detailed block flow diagram of the process implemented by the method with respect to a specific example.

The method can begin at step at which the static analysis module conducts a static analysis of the source code of programs that are to be run in parallel and thereby generate an initial set of execution flows for the programs. For example as illustrated in the static analysis module can receive the source code of the parallel programs and can receive pairs of send receive API pairs for messages transmitted between processes of the parallel programs. These API pairs are generated by the existing lexical analysis of the source code or are inputted manually by the users. Based on the source code and the APIs the static analysis module can generate the execution flow of a first process A and the execution flow of a second process B. Here the process A and process B can be processes executed by different programs of the parallel programs or can be different processes that are executed by a single program of the parallel programs. Nodes in each of the execution flows can denote the point at which debug log messages or values are output and can denote sending of messages to and or receiving messages from other programs or processes run in parallel with the execution flow. A node can contain additional information about the messaging procedure such as send or receive operations from the static analysis which can be based on an analysis of dataflow or strings.

At step the parallel program analysis module can execute the parallel programs to obtain debug logs from the programs. For example as illustrated at block the programs can be executed in parallel and debug logs can be obtained from the programs after they are executed.

At step the parallel program analysis module can identify communication messages transmitted between the execution flows from the debug logs. For example the parallel program analysis module can determine that elements and are send messages snd2 and snd1 as indicated in the execution flow and can identify receive messages rcv2 not shown in block and rcv1 as receive messages that can be received after the decision step as indicated in the execution flow .

At step the parallel program analysis module can deduce that at least conditional branch was taken by the target program in at least one given execution flow of the execution flows based on the communication messages that are identified in the debug logs. Further the parallel program analysis module can remove at least one conditional branch that was not taken from the given execution flow based on the deduction. For example as illustrated in at block the parallel program analysis module can conduct an analysis of the debug logs and the execution flows and to determine that the rcv1 message branch in the execution flow of the process A was taken. Further based in this determination the parallel program analysis module can deduce that the rcv2 message branch not shown in block after element in the execution flow of the process A was not taken and can remove the branch from the execution flow . Thus the parallel program analysis module can output execution flow and execution flow from which the rcv2 message branch was removed.

Based on the code fragments as described above with respect to the static analysis module can generate an execution flow for the process A task A and an execution flow for the process B task B. Based on the source code and and or the execution flows and as well as the debug messages and the parallel program analysis module can deduce that the conditional branch 1 of the Task B was taken. For example the parallel program analysis module can compare a debug log time of a send or a receive task of at least one execution flow to a debug log time of a task that includes given conditional branches to determine which of the given conditional branches was taken and to remove any of the given conditional branches that was not taken. For example here the parallel program analysis module can compare the debug log time of message Al in message which corresponds to the transmission of the queueing message sent by the task A to the debug log times of debug messages B1 and B2 which correspond to the conditional branches 1 and 2 of the task B. In particular based on the code fragment it is clear that one of the conditional branches 1 and 2 was taken between debug message B1 time 02 58 00 and debug message B2 time 03 00 57. Thus the parallel program analysis module can make the comparison to determine whether the debug log time of the send message of task A falls within the interval defined by debug message B1 time 02 58 00 and debug message B2 time 03 00 57 which denotes the taking of one of the conditional branches 1 or 2 . If the debug log time of the send message falls within the interval then the parallel program analysis module determines that the conditional branch 1 was taken as the sending of the message from task A would indicate that the task B received the message at the appropriate time frame. Otherwise the parallel program analysis module determines that the conditional branch 2 was taken. In this case because the debug log time of the send message of task A is 03 00 54 which falls within the interval defined by debug message times B1 and B2 the parallel program analysis module deduces that the conditional branch 1 was taken and that the conditional branch 2 was not taken in the execution flow . As such the parallel program analysis module can delete the conditional branch 2 from the execution flow . It should be noted that in other implementations the parallel program analysis module can apply one or more user defined time buffer values to each of the debug message times B1 and B2 of the interval to account for processing time for the transmission of messages between the tasks. Thus for example assume that the task B receives the message sent from task A. However the debug message log time B1 may denote a time that is after the log time for debug message A1 due to the processing time of the operating system. Thus a buffer time value accounting for the transmission time of the message sent by Task A can be subtracted from the debug message log time B1 so that the debug log time of the send message of task A falls within the interval and enables the parallel program analysis module to determine that the conditional branch 1 was taken.

Scenarios and illustrate cases in which a flow including a SND function is identified by the parallel program analysis module as being executed based on the debug logs. For example the parallel program analysis module can identify that the SND function was executed in the same manner in which the parallel program analysis module identified that the send message associated with the queuing operation was executed based on the code and log of . In the scenario the SND function of the flow needs a response confirmation from the RCV branch of the flow . For example in response to sending a send message to the task of flow the task of flow expects to receive an acknowledgement message . In this case if the execution flow including the SND Function repeatedly executes the SND function after the initial call of the SND function as indicated by the debug log of the flow the parallel program analysis module identifies the conditional branch of the flow corresponding to the RCV function of the flow as being taken. In addition as a result the parallel program analysis module can deduce that the conditional branch was not taken and can delete the branch .

In the scenario it can be assumed that the SND function does not need an acknowledgment message and that the RCV function sleeps until receiving the message from the send function. Here the SND function of the execution flow sends a send message with a debug log time of 1 23 41 according to the debug log for the flow . In addition the debug log for the flow indicates that a task was executed at 01 23 32 according to the debug log message and that a task was executed at 01 23 42 according to the debug log message . As indicated by the flow one of the conditional branches and are executed between tasks and and within the execution time interval defined by the times of the debug log messages and . In this scenario a user can specify an execution time interval threshold such that any execution time interval that exceeds the threshold indicates that the receive function was in a sleep mode. Thus if the time difference of the execution timestamps of the log messages and i.e. the interval is larger than the user specified execution time interval threshold when the SND function execution time falls within that interval then the parallel program analysis module determines that the RCV function was in sleep mode and in response thereto determines that the conditional branch was taken. In addition as a result the parallel program analysis module can deduce that the conditional branch was not taken and in response thereto can delete the branch .

As such in these ways for example the portions of the execution flows which cannot be executed are identified and deleted from the flows by employing the debug logs generated by the programs executing in parallel. Here the parallel program analysis module can collect the debug log of a target program and other programs which affect the target program and can then delete portions of the execution flows using these debug logs and the output point of the debug logs in the execution flows generated through the static analysis.

With continuing reference to the method can proceed to step at which the pruning module can determine other unlikely branches based on the deductions of step to prune the execution flows. For example as illustrated in the pruning module can implement the pruning at block by comparing one or more execution flows to pairs of send receive application programming interfaces deduced from the source code or obtained from an operating system or a user to determine any other conditional branches that were not taken. For example if an API pair of sending receiving messages Snd1 Rcv1 . . . SndN RcvN exists and there is no corresponding pair in the execution flows then any corresponding send or receive task in any of the execution flows is deleted. For example assume that the pairs of send receive application programming interfaces includes a pair snd2 from flow and rcv2 which was deleted from flow by the parallel program analysis module . Here the pruning module compares the snd2 rcv2 API pair to the execution flows and determines that the pair does not exist due to the fact that the rcv2 branch is missing from the execution flows. As such the pruning module deletes the branch from the flow to generate flow for output with flow at step as modified execution flows output by the pruning module of the system of . It should be noted that the additional pruning although preferred is optional and that the execution flows can alternatively be output by the system as the flows .

Optionally at step a controller of an operating system can modify the operating system based on the execution flows. For example the controller can remove pairs of send receive application programming interfaces associated with any conditional branches removed from the flows by the system . For example the controller can remove the snd2 rcv2 API described above with respect to . The controller can perform the same comparison between API pairs and the execution flows described above with respect to step to determine the APIs to be removed. Indeed the controller can delete any modules or tasks deemed unnecessary based on the execution flows .

Thus exemplary embodiments of the present invention can determine the most likely executed branches of a program based on static analysis of the code and on debug logs as described above without modifying the program or the monitoring software in any way. The determination of the most likely executed branches can improve the precision of operational verification processes by using the debug logs of a number of programs. Further the efficiency of the execution environment can be improved by identifying the most likely execution flow of the operating system and by removing any unnecessary modules and or tasks.

Referring now to an exemplary computing system in which system embodiments of the present invention described above can be implemented and by which method embodiments of the present invention described above can be implemented is illustrated. The computing system includes a hardware processor that can access random access memory and read only memory through a central processing unit bus . In addition the processor can also access a storage medium through an input output controller an input output bus and a storage interface as illustrated in . The system can also include an input output interface which can be coupled to a display device keyboard mouse touch screen external drives or storage mediums one or more external networks etc. for the input and output of data to and from the system . In accordance with one exemplary embodiment the processor can access software instructions stored in the storage medium and can access memories and to run the software and thereby implement the method described above. In addition the hardware processor can for example by executing software instructions stored on the storage medium implement system elements described above such as the static analysis module the parallel program analysis module the pruning module and the controller . Alternatively each of these system elements can be implemented via a plurality of respective processors in one computer system or in a plurality of different computer systems on a network. Further the source code of the programs the debug logs the execution flows the execution flows the APIs and the modified execution flows can be stored in the storage medium . Additionally the input output interface can be employed to output the modified execution flows . Alternatively or additionally the modified execution flows can be stored in the storage medium for subsequent retrieval by the operating system and or by a user.

Having described preferred embodiments of systems and methods for parallel program analysis and branch prediction which are intended to be illustrative and not limiting it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in the particular embodiments disclosed which are within the scope of the invention as outlined by the appended claims. Having thus described aspects of the invention with the details and particularity required by the patent laws what is claimed and desired protected by Letters Patent is set forth in the appended claims.

