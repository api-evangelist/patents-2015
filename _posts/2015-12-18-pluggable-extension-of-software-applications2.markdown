---

title: Pluggable extension of software applications
abstract: Various embodiments of systems and methods to provide pluggable extensions of software applications are provided herein. In one aspect, plugin application package is received for deployment. The plugin application package includes configuration data to comprising various definitions for the deployment of the plugin application. In another aspect, configuration data of a host software application is updated with at least a part of the configuration data of the plugin application. The host application is reconfigured based on the updated host configuration data to refer to the plugin application. In yet another aspect, one or more plugin services provided by the plugin application are exposed through the reconfigured host application, to handle corresponding user requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652214&OS=09652214&RS=09652214
owner: SAP SE
number: 09652214
owner_city: Walldorf
owner_country: DE
publication_date: 20151218
---
Modern software application architectures embrace microservices design pattern that decomposes monolithic applications into independently deployable services. This approach provides a high degree of flexibility and efficiency e.g. by reuse of similar services. The advantages that microservice architecture provides are especially noticeable when implemented in cloud environments where they are operated by the development teams DevOps model . The developed and deployed services can be extended with small local configuration changes and rewired to integrate with new services to deliver additional functionality.

However when applications are deployed by customers in a more traditional way e.g. as packaged applications the benefits of microservice architecture do not pay off immediately. To extend the functionality of such applications by adding new services would require code changes and reconfiguration of execution environments. Alternatively such extensions need to be foreseen so they can be plugged in later by just changing implicitly the configuration of the corresponding execution environments. Thus no manual rewiring would be needed that would require expert knowledge about the inner structure of the deployed applications. However foreseeing what future functionality would be added to the deployed applications is not always possible.

Embodiments of techniques for pluggable extension of software applications are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the presented ideas can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Generally a software application or a product built upon microservices architecture encompasses a number of independently deployable software components where the different components provide different services. Accordingly the different components may have separate lifecycles independent from each other. For example one component may be provided and or managed by one design and or support team while another component may be handled by another team. That approach ensures more efficient development and maintenance of the different components and the corresponding services. However this flexibility and efficiency is not so evident in private cloud and on premise scenarios where no dedicated teams are available to handle the different services. The below described techniques for pluggable extension of microservices applications overcome the aforementioned shortages of such scenarios.

In system environment one or more shareholders or users e.g. developers system administrators end users etc. operate on one or more client systems . Users may request different services or execute various operations available within client systems . The requested services could be provided by one or more server systems via network . The illustrated one or more server systems represent one or more backend nodes or application servers in the computer system environment e.g. clustered or not. In the context of SAP SE system landscape application server could be HANA XS HANA eXtended application Services application server providing a platform for running applications accessing HI ANA in memory database HANA DB e.g. database . Users can access the functionality of the applications running on application server via browser for example. Alternatively dedicated client applications running on client system may be utilized e.g. various mobile apps .

Application server could be based on micro services architecture e.g. HANA XS and oriented towards hosting cloud type applications. For example the application server could implement runtime platform as a cloud based computing platform such as Cloud Foundry originally developed by VMWare Inc. company. In one embodiment runtime platform is an on premise solution built upon Cloud Foundry open source cloud platform e.g. HANA XS runtime platform to provide various frameworks to deploy cloud based application services on premise. As illustrated in runtime platform may support multiple runtimes such as XS JavaScript SAP SE specific Node.js Java C etc.

Various applications may run simultaneously together or independently on one or more of the supported runtimes to provide a number of application services at application server . In the common scenario a user accesses an application user interface UI e.g. in a browser at a client system to request a particular service. The submitted service request is provided at an application server e.g. via a public or a private network where a router such as application router identifies an application that could handle the request and calls the application at the corresponding runtime or of a runtime platform for processing. In one embodiment application router e.g. may be a routing service that dispatches client requests directed to an application package to particular application services implementing requested functionality. In one embodiment different instances of the application router service may be instantiated e.g. to subordinate in dispatching application requests.

In one embodiment the functionality available at the application server could be further enhanced by deploying additional services e.g. application components . The traditional deployment of new applications on premise to extend the functionality of a product requires a number of manual expert activities such as repackaging of the product source files with the additional functionality updating the configuration metadata with the configuration information of the new applications to wire up the new services into the product and subsequently redeployment or reinstalling of the extended product. Obviously this require significant development and or administrative knowledge and efforts which normally is not available at customer premises. Therefore an automated mechanism is implemented in application server to ensure the identification and the calling of the additional services when requested. An overview of this mechanism is provided in the context of illustrating a process to provide pluggable extension of microservices applications according to one embodiment.

The description of process is based on an assumption that the microservices applications architecture is deployed in an on premise computing environment. However similar techniques may be used when extending the functionality of software products in public and private cloud environments. For example even when developers and support specialists are available to deploy a new functionality in a public cloud environment it is still more efficient to apply the described mechanism for automated pluggable extension of the microservices applications. Private cloud scenarios are similar to the implementation of additional functionality on premise as the process is handled by customers or tenants in private cloud based computing system environments.

At a plugin application package is received. The package may include one or more services to enhance the functionality of an already implemented software product. For example a customer of a particular product may license additional functionality e.g. access to further modules of the product. Thus the corresponding vendor may send or provide access for downloading the installable package of the new functionality the plugin application package to the respective customer e.g. when the product is installed on premise.

Together with the programming code the plugin application package may include configuration information or metadata necessary for establishing the execution environment for the pluggable services e.g. wiring the pluggable service in the corresponding runtime environment. In one embodiment such metadata is provided as a separate file e.g. plugin application descriptor and is included in the deployable package. Alternatively the plugin configuration and wiring metadata could be provided in the form of annotations of the programming code could be separately sent or downloadable etc. At the plugin application descriptor is identified in the received plugin application package. In one embodiment the plugin application descriptor includes a definition of the plugin application.

The software application or product to be extended with the plugin application may have been also delivered as a deployable package e.g. a host application package according to one embodiment. The host application package may contain the source or executable code of the software application to be deployed as well as the metadata required for the setup and configuration of the software product within the runtime environment. Similarly to the plugin application package the host configuration data could be provided in a separate host application descriptor. When the plugin application descriptor is identified an automatic update of the host application descriptor based on the plugin metadata may be performed at . For example the update may be performed by a built in functionality of the deploy mechanism of the runtime platform or by a separate service available at the application server. The update may be triggered automatically and or by a user and may not involve further manual interactions. The update may add the registrations and the definitions of the plugin service or application to the definitions of the host application or product.

At the host application is automatically reconfigured based on the updated host application descriptor according to one embodiment. The reconfiguration may involve various changes to the host application package to ensure wiring of the plugin application to the software product in the runtime environment. For example the new functionality provided by the plugin application is included in the host application descriptor with the appropriate references. Thus when the new functionality is requested the software product would route it to the plugin application for handling. This wiring of the plugin application in the runtime environment and exposing the plugin service through the host application is provided at .

In one embodiment the plugin definition that comes with the plugin application descriptor may be enhanced with configuration data determined when the plugin is deployed. This information may be then injected into the configuration of the host application package to register the plugin with the extended application. This enables the host application package to reconfigure its execution under consideration of the newly added plugin to provide additional functionality. This functionality can then be accessed by exposing plugin services through the host application package.

There may be different approaches in exposing the plugin application functionality as well as different elements of this exposing. From user s perspective the new functionality may become available in the graphical user interface as a separate selectable option e.g. part of the software product. The new selectable option may be placed in a common software application launchpad for example. There may be other options for integrating the extended functionality into the software product. For example the new functionality may be automatically applied e.g. in reporting UIs and so on.

Taking a specific software product e.g. HANA Foundation for Health a customer may initially acquire and install the generic business application and subsequently enhance the basic functionality with various plugins e.g. provided and installed as microservices . The customer may want to add and use some of the available plugins such as Genome Analysis which is available as a separate application plugin to the HANA Foundation for Health product. Thus by the described automated deployment of the pluggable application the new functionality would be available to the users without manual reset and redeployment of the whole product.

The added application plugins should be wired up with the product. Thus the product processes are aware about the added functionality and how to provide it e.g. allow access to this functionality through the product or in cooperation with the product. This may be achieved by extending the metadata e.g. configuration files and or annotations updating the environment variables by altering the existing ones and or adding new variables corresponding to the plugin applications etc.

From architectural perspective the deployed applications typically have one central entry point from a user standpoint. In other words a browser may connect to one location e.g. one server or router including a proxy with one logon one central security session. There may be different reasons for this mostly based on the web application security model principles e.g. same origin policy. According to this users service requests are delivered at the single end point of the software product. Behind this one endpoint requests may be forwarded to different backend services. The single end point could be referred to as application router e.g. application router in .

The application router may be configured to know e.g. depending on a uniform resource locator URL in a client s request where to forward this request for handling alternatively the application router may dedicate a HyperText Markup Language HTML page to serve the request itself . Such application proxy configuration for a software product is provided by the configuration metadata e.g. host application descriptor. Since the client cannot access through the UI e.g. in the browser the extended functionality directly through a separate endpoint no other application router may be available for direct access. Accordingly the metadata of the plugin application descriptor is integrated in the host application descriptor.

Plugin application package extends the functionality of the host application package. Similarly the requests for the plugin application services are dispatched by plugin application router based on the definitions in plugin application descriptor . However these requests may not be provided by the user e.g. directly at the plugin application router since the enhanced software product has only one endpoint at the application router . Therefore the application router should be aware that such requests should be forwarded to the plugin application router . In one embodiment this is achieved by registering or injecting plugin configuration information to the host application package e.g. from the plugin application descriptor to the host application descriptor . The wiring of the plugin services may also include adding references e.g. to the host application descriptor that can be used by the application services to call directly the plugin services when necessary not illustrated .

As it was mentioned the host application descriptor and the plugin application descriptor could be separate files in a particular format to provide the configuration metadata used for setting up the runtime environments for the corresponding application services. The formats of these files could be for example plain text formats structured files etc. The structured files may correspond for example to some table form. In the flat files special language for defining and or tagging the metadata may be used for example eXtensible Markup Language XML . Alternatively the configuration metadata could be provided in other forms e.g. as annotations in the source code database references references to external resources etc.

As illustrated the configuration presented with links the different components of the host application package by pointing out the required and provided services. For example host router component is defined to require host services service see . Correspondingly host service service is provided by host app module see . Similarly host app module requires host db service which is provided by host app db component of the host application package. Based on the configuration and the wiring of the different modules when a request for the host service is received at the host router the request is forwarded to the host app implementing and providing the host service . The definitions in also show a wiring example of how the destination for the host service is defined as host url and host url is further defined as default url in the context of the host app module. The default url may be a special key word showing that host service is deployed at the default host URL. This is where the requests for this particular service should be forwarded to execution.

In illustrates an exemplary contents of a plugin application descriptor. Similarly to the host application descriptor e.g. and using the same syntax the host application descriptor defined that a plugin application package with the ID com.sap.plugin has two components plugin router and plugin app . The plugin app may provide a service e.g. plugin service required at and referred to by the plugin router . Therefore a package internal dependency is modeled e.g. requires plugin service and resolved for wiring e.g. provides name plugin service . In the plugin application descriptor example no modules requiring or providing database services are included but such can also be added. Another element of the descriptor is the definition of the plugin properties such as name set to plugin source plugin pluginType Launchpad destination plugin router .

In one embodiment application descriptors define only those dependencies and configurations the application package is aware of. If a plugins is added to a host application package the wiring between package internal components needs to be extended to components from the plugin application package. Additionally plugins come with configuration that needs to be injected into the host application s configuration so it can react on the availability of the plugin in a concrete deployment and embed it appropriately. For such reasons the plugin application descriptor in the plugin application package is extended by a section for the plugin definition. The plugin router module should be wired to the component hostModule in the application package with ID com.sap.host hostID . Accordingly the properties the plugin defines in its plugin application descriptor are used for registration of the plugin in the host e.g. injected to the host application descriptor .

In one embodiment when the plugin application package is registered the host application package configuration is extended with the plugin definitions e.g. provided with the plugin application descriptor or otherwise . Semantically based on the descriptors and in the result is an extended host application descriptor illustrated with in . The derived descriptor may be the actual runtime configuration of the host application package replacing the original one e.g. after extending the software product functionality. In the illustrated example section in shows the extension of the original application descriptor of the software product and results from the injection of the configuration data from the plugin application descriptor e.g. .

When the host application package provided with the merged configuration including the data from the plugin registration is deployed it is reconfigured to leverage the additional functionality from the plugin. For the provided example this means that in the host router the predefined route and destination to the host service needs to be extended by another route and destination to the plugin router . Such extended routing is shown in where additional configurations are generated based on or in connection with the converging of the host application descriptor and the plugin application descriptor. The definition of destinations for the extended software product are illustrated with the configuration snippets in where section specifies the definitions provided by the plugin metadata according to an embodiment. These snippets provide concrete values e.g. physical URLs for the logical destinations of the host router and plugin router .

Properties and or environment artefacts or variables for the plugin are also defined. For example the pluginType is set to Launchpad which most likely corresponds to adding the plugin functionality as a separate option accessible from the Launchpad of the software product host application . An extended routing may be defined using configuration data e.g. provided by the plugin application descriptor as illustrated with the snippets in where section shows the new route. Based on the definitions in an updated touting table may be generated and referred by the application router during runtime to select the right route for the service requests.

There may be several options regarding how to expose additional functionality provided by plugins through host applications. For example a host application service can call a plugin application service peer to peer in its internal implementation of basic functionality that thus gets extended. The examples provided with this description present another common option of routing client requests directly to the plugin without invoking a host application service first. In this scenario the host application does not need to prepare for pluggability. Accordingly the generic application router components are re configured with appropriate routes. Then it is up to a client typically running in a browser to make the corresponding requests that are directed either to the host or the plugin. Additionally a direct request to a plugin application router may not work e.g. because of single endpoint and or same origin policy restrictions. Therefore the host application router may act as a reverse proxy.

To enable the client application to detect the additional functionality and the routes under which it is accessible the application router may expose the registered plugins in a list as web resources. The list may be compiled from the properties in the plugin definitions introduced in the plugin application descriptors. In shows a specific extraction of the plugin definitions also included in as well as in and .

The techniques for pluggable extensions of packaged microservices applications enables host application packages to be extended as simply as automatically applying or altering configuration with no manual interventions to the code or to the metadata definitions. In one embodiment this configuration may be performed implicitly when extensions are deployed without subsequent manual rewiring that would require deeper knowledge about the inner workings of the applications. Such flexibility allows building of applications based on microservices design pattern that are suited for cloud deployment and could be also shipped to on premise customers without compromising simplicity of operations. Furthermore the described techniques could be used also for hierarchically extending applications e.g. when a plugin service is added to a previously plugged application.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the presented embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limiting to the precise forms disclosed. While specific embodiments and examples are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope of the specification is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

