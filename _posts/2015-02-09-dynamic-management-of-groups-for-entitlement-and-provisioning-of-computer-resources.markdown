---

title: Dynamic management of groups for entitlement and provisioning of computer resources
abstract: Methods, systems, and techniques for managing groups of entities, such as individuals, employees, or systems, and providing entitlement and access to computer resources based on group membership are provided. Example embodiments provide a Group Management System having a Group Management Engine “GME,” an Entitlement Engine, and a Provisioning Engine, which work together to allow simplified grouping of entities and providing entitlement and access to the entities based upon the group membership. In one embodiment, the GME leverages dynamic programming techniques to enable accurate, scalable systems that can manage near real time updates and changes to the group's status or to the entities' status. These components cooperate to enable provisioning of applications based upon current entitlement.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09491116&OS=09491116&RS=09491116
owner: VMware, Inc.
number: 09491116
owner_city: Palo Alto
owner_country: US
publication_date: 20150209
---
This application is a divisional of and claims priority to U.S. patent application Ser. No. 13 459 028 entitled DYNAMIC MANAGEMENT OF GROUPS FOR ENTITLEMENT AND PROVISIONING OF COMPUTER RESOURCES filed on Apr. 27 2012. This Application claims the benefit of U.S. Provisional Application No. 61 481 184 entitled RULE BASED APPROACH FOR MANAGING USER ACCESS TO APPLICATIONS INCLUDING SOFTWARE SERVICES filed on Apr. 30 2011. The disclosure of the foregoing applications are incorporated here by reference.

The present disclosure relates to methods techniques and systems for managing groups of entities including people and computer systems and for providing entitlement and access to computer resources to members of the groups and in particular to methods techniques and systems for providing efficient and nearly instantaneous updates to membership conditions for groups and for individual entities even in a large scale environment.

Today s world demands that administering entitlements and access to computer resources be efficient accurate and secure. As more and more computing is done remotely and as organizations grow in size and complexity these challenges continue to grow. Multiple waves of technology have left most organizations with IT infrastructure that is complex inflexible and expensive to run. People devices and applications are tightly coupled making it difficult to roll out new applications or support new work patterns. IT organizations within corporations have to manage a hundreds if not thousands of applications based on divergent technologies and run thousands of PCs and servers each with its own operating requirements and idiosyncrasies.

Maintaining software on a distributed PC or other access device is expensive and time consuming. As the number of applications and services provided through the PC grow the complexity of the PC configuration increases.

Historically this problem has been addressed by locking down the PC to limit the changes that can be made to it. Products have also been introduced to push software to physical devices but these approaches depend on there being a small well defined number of access devices as well as a relatively infrequent update cycle. Until a few years ago this was difficult but achievable in a well managed environment. However an explosion in the number and type of access devices which now encompass devices such as PCs laptops PDAs and mobile phones combined with a need for frequent real time updates e.g. to protect against viruses worms and security loopholes has rendered such an approach unworkable.

In large organizations the problem of access device diversity is compounded by the fact that end users use applications that run on many different platforms. Some run on the user s PC some run centrally as terminal applications thin clients or web services and some run on virtual machine technology. Previously the infrastructure for supporting and managing these applications was entirely separate.

Embodiments described herein provide enhanced computer and network based methods and systems for efficiently accurately and securely granting access to computer resources to entities based on group membership. Example embodiments provide an Entitlement Management System EMS which enables users such as IT managers administrative users or the like to grant entitlement to and provision computer resources according to end user or other entity membership in the groups in near real time. That is as the needs of for example an organization change the changes to the group membership are reflected almost immediately using separate synchronization processes executable threads or the like so that the computer resources a user is entitled to and provisioning of such resources is kept current virtually instantaneously without a lot of administrative overhead. Group membership can be based upon end user roles within the organization and not potentially arbitrary and soon out of date access control lists. As an end user s role within the organization changes the groups that the end user belongs to are quickly updated. With little delay the computer resources then available to that end user are also updated automatically so that access and security needs can be maintained. Moreover the techniques used by the EMS are independent of the target device or of the computer resource being provisioned. Thus the ability for an EMS to manage entitlements and provision applications and other software using these techniques improves the ability for administrators to ensure access integrity across the infrastructure regardless of the type of application e.g. local application virtualized application software as a service etc. device or entity being administered. As used herein groups can comprise people computer systems or a combination thereof. Also as used herein distinction is not made between the users that may manage the EMS groups e.g. administrators managers or other users or the end users or other entities receiving access to resources unless otherwise indicated as in some embodiments the users who receive access may also administer the system.

In example embodiments an EMS comprises a set of tools including a Group Management Engine an Entitlement Engine and a Provisioning Engine. The Group Management Engine GME receives information about the entities and one or more rules which define membership in one or more groups and generates tables that correlate users with groups. In an example embodiment the rules are logic clauses requiring certain criteria for membership in the respective group. The Entitlement Engine EE receives information from the GME that the GME keeps current and generates tables that correlate users with appropriate resource e.g. application entitlements based upon group membership without requiring individual user entitlements. The Provisioning Engine PE receives information from the EE that the EE keeps current and provisions the appropriate computer resources to the entities again based upon their group membership.

In some embodiments the EMS is structured such that the operation of the various components is visible to the user e.g. the administrator . In other embodiments the components of the EMS operate together without requiring the user to directly observe or instruct the various components. The components of the EMS can be linked together to propagate changes to the user information group information or entitlement information automatically.

In some embodiments the Group Management Engine of the EMS includes an analysis and refactoring component that analyzes the rules in the group definitions for inefficiencies inaccuracies logical conflicts or other problems and refactors the rules to minimize or eliminate problems. The analysis component can analyze the group definitions empirically by looking at the results of executing the group definition or theoretically by analyzing the rules themselves independent of the results of applying the rules to a given set of entities.

The EMS simplifies the task of managing which entities have access to which computer resources by removing the need to change a given entity s access when circumstances change. If an entity s status changes this change is input to entity e.g. user data tables of the EMS and the appropriate computer resource entitlement and provisioning are automatically generated. For example if an employee is fired the manager simply makes note of the change in status e.g. in an appropriate data structure and the prior employee s access to computer resources based upon his role as an employee are automatically revoked when the EMS updates the tables.

As mentioned the EMS accomplishes these tasks using various components including a Group Management Engine GME an Entitlement Engine EE and a Provisioning Engine PE . The GME receives information describing various entities and one or more group definitions and uses this information to manage group membership. Each group comprises a set of group composition rules GCRs an included entities list and an excluded entities list . Each GCR includes one or more logic clauses that define membership in the group. For example the logic clauses may comprise conjunctive or disjunctive properties or attributes that need be met in order to be included in or excluded from the group. The lists of included and excluded entities e.g. lists and can be given greater or lesser priority than the GCRs or can be represented as GCRs listing single entities for inclusion or exclusion. The members of the groups can be entities such as entity and entity including people computer resources systems or some combination thereof.

The GME can store data pertaining to the entities and as for example a set of name value pairs which is used to determine whether a given entity is a member of the group when the logic clauses are evaluated. An example entity Entity A is shown having various attributes stored as name value pairs such as Department Sales Tenure 2 years and Region North America. Virtually any suitable attribute of the entity can be stored and used to determine group membership. For example suppose that Group A is defined as including entities that are employees who are in sales and excluding people with less than one year with the organization. As illustrated Entity A meets both criteria since the entity an employee has been in the sales department for 2 years and works in North America and is therefore a member of Group A . As another example suppose that Group B is defined as people who have been with the organization for 2 years or more. As illustrated in the Entity A is a member of that group as well.

Membership in one or more of the groups also can be used as a criteria for defining membership in another group. For example suppose that a third group is defined as including those entities who belong to Group A but who do not belong to Group B . Entity A discussed in the above example who is a member of both groups and fails to satisfy or meet this criteria and therefore is excluded from the third group. The logic clauses can therefore be as complex or as simple as occasion presents and as needed by the organization.

Once the desired groups are defined the administrator can assign entitlements to the groups based on the definition of the group and the subscription licenses or other attributes of the computer resources being provisioned. The members of the groups that receive such entitlements are then able to access the computer resource once the resource is provisioned. The Entitlement Engine oversees assigning entitlements to the different groups . Different members of an organization may have different needs for certain software or hardware resources for the organization and the EE permits the administrator to track employees and grant access appropriately and easily.

The Provisioning Engine then provisions the computer resources for example applications to the various entities and based upon the entitlements assigned to groups . Thus for example if Group B has been entitled to use a particular application then provisioned application may be provisioned by the PE to both Entity A and Entity B .

The components of the EMS each contain one or more processes which in different embodiments may be implemented as processes tasks threads or other executable code to synchronize the data tables. In particular the GME includes a process called UserGroup Sync which creates or updates a UserGroup table triggered by changes and or additions to the Group Data repository or the User Data repository . In some embodiments the UserGroup table includes a flat list of entities and the groups they belong to for easily and quickly reflecting changes to group membership. Of note although referred to herein as tables other data structures may be used to store equivalent information such as files lists or the like. Also although described with reference in some examples to data bases other means for storing and querying information may be similarly incorporated. The EE includes an EntitlementSync process that in combination with entitlement data automatically generates or updates a UserEntitlement table triggered by changes to the UserGroup table . The UserEntitlement table is a flat list of entities and the computer resources to which users are entitled. The PE includes a ProvisionSync process which generates or updates a Provision State table describing the state of the entities and the computer resources to which the entities are entitled and a method of provisioning the computer resources to the entities. Changes to the Provision State table are automatically triggered by changes to the UserEntitlement Table . The PE may also include a DeliveryEngine process that executes the provisioning of a resource according to the Provision State table . The PE may also communicate and cooperate with third party services to provision the computer resources for example a software as a service SaaS application . Accordingly the EMS receives changes to a user s status or a group s status and propagates the changes through the system to generate flat tables that describe to which computer resources a given entity is entitled. An administrator can then perform certain management tasks with ease such as querying which computer resources does entity X have access to or which entities are members of Y group or which entities have access to Z computer resource 

Once the tables are created they may be used to directly and efficiently determine entitlement and provisioning information with or without regard to group membership. In some embodiments membership in a group is a means to an end but not the end itself the end being provisioning the appropriate computer resources to entities. For example when a certain entity attempts to access a given computer resource the tables quickly can be accessed to determine whether or not to grant access. The tables may have been calculated ahead of the request using the group information but at the time of access the information is in place and recalculating the tables is unnecessary. Eliminating the need to recalculate the tables in response to an access attempt because the calculations have been performed ahead of time is one way in which the techniques of the present description offer increased efficiency and accuracy. Moreover the tables may be kept current by updating them on a continual periodic or timed basis.

In one example embodiment the GME comprises one or more functional components modules that work together to permit efficient management of groups of entities and to administer entitlements to and provisioning of computer resources. is an example block diagram of components of an example Group Management Engine. The GME receives input from a user e.g. an administrator or manager as described above. The GME receives and stores one or more group definitions that include Group Composition Rules GCRs an included user list and an excluded user list. The GCRs of the group definition include logic clauses such as include people over age 30 or exclude people outside the Continental United States or any other suitable rule as desired. The included users and excluded users components can be similar to rules but they are specific to one or more users and can be recast as entity specific rules. The rules can be combinations of rules such as disjunctive or conjunctive combinations. In some embodiments the rules are complex logical expressions with features such as flow control statements found in programming languages.

The GME passes e.g. forwards directs etc. each group definition to a Group Definition Compiler which parses the rules into a rule tree discussed in more detail with respect to below. The term compiler generally refers to any type of processor and is used in embodiments of this disclosure without loss of generality. The branches of each rule tree are individual rules from each group definition . The GME also includes a user rule compiler which receives the rule trees and creates one or more data repository queries corresponding to each group. In some embodiments the data repository queries can be SQL queries or other suitable data queries. From the data repository queries one or more tables are generated such as the UserGroup table discussed above with reference to . These tables are used to determine which entities are entitled to access which computer resources.

The GME also includes an analysis and refactoring component that can from time to time analyze the accuracy and efficiency of the GME by refactoring the group definitions or the rule trees. In particular the analysis portion of the analysis and refactoring component seeks to determine whether a given group definition is redundant with another group definition whether a group definition is inaccurate or whether a group definition is trivial returning all possible results or zero results. The refactoring portion of the analysis and refactoring component then alters the group definitions accordingly to remove the inefficiency or inaccuracy.

In some embodiments the analysis and refactoring component is implemented as a single component . In other embodiments the analysis and refactoring component is implemented as two separate components an analysis component and refactoring component . The analysis component or portion can look at any number of rule trees and compare the trees to determine if any refactoring is desirable. An example of an inefficiency in a rule tree occurs when a logic clause within a rule tree is repeated in several rule trees or when a rule tree returns zero results or when a single logic clause can be better written as two or more logic clauses. The refactoring component or portion corrects the inefficiency either by replacing logic clauses in a rule tree or by writing a new logic clause as a new rule tree. The analysis component can determine redundancies inefficiencies or inaccuracies in different manners such as by empirically reviewing the tables produced by the rule trees or theoretically by analysis of the rule trees directly. By reviewing the rule trees directly the analysis component can operate without requiring the user rule compiler to execute the rule trees and create the data repository queries or the table .

There are many other ways in which the analysis component and the refactoring component can improve the efficiency of the calculations required to generate the tables described above with reference to . For example the analysis component can detect when a rule tree returns zero results perhaps a sign of a contradictory logic clause or pair of logic clauses that are impossible to satisfy e.g. Include Managers and Exclude Managers . Or perhaps the logic clauses are too broad and return a trivial response including all possible results. The analysis and refactoring component can notify an administrator before making a change to avoid an unwanted result or just to confirm the execution.

Although the techniques of managing and entitling dynamic groups and the EMS are generally applicable to any type of organization the phrase computer resource is used generally to imply any type of resource and need not necessarily be limited to computer resources. The techniques systems and methods of the present disclosure can be used to grant access to anything not just computer resources. Essentially the concepts and techniques described are applicable to any organization such as a company a government an organization or a family.

Also although certain terms are used primarily herein other terms could be used interchangeably to yield equivalent embodiments and examples. For example it is well known that equivalent terms could be substituted for such terms as compiler database data repository network etc. Specifically the term compiler can be used interchangeably with processor. In addition terms may have alternate spellings which may or may not be explicitly mentioned and all such variations of terms are intended to be included.

Example embodiments described herein provide applications tools data structures and other support to implement an Entitlement Management System to be used for dynamically managing and entitling groups. Other embodiments of the described techniques may be used for other purposes including for dynamically managing groups of human and or non human entities such as computer systems. In the following description numerous specific details are set forth such as data formats and code sequences etc. in order to provide a thorough understanding of the described techniques. The embodiments described also can be practiced without some of the specific details described herein or with other specific details such as changes with respect to the ordering of the logic different logic etc. Thus the scope of the techniques and or functions described are not limited by the particular order selection or decomposition of aspects described with reference to any particular routine module component and the like.

The computing system may comprise one or more server and or client computing systems and may span distributed locations. In addition each block shown may represent one or more such blocks as appropriate to a specific embodiment or may be combined with other blocks. Moreover the various blocks of the EMS may physically reside on one or more machines which use standard e.g. TCP IP or proprietary interprocess communication mechanisms to communicate with each other.

In the embodiment shown computer system comprises a computer memory memory a display one or more Central Processing Units CPU Input Output devices e.g. keyboard mouse CRT or LCD display etc. other computer readable media and one or more network connections . The EMS is shown residing in memory . In other embodiments some portion of the contents some of or all of the components of the EMS may be stored on and or transmitted over the other computer readable media . The components of the EMS preferably execute on one or more CPUs and manage the GME EE and PE as described herein. Other code or programs and potentially other data repositories such as data repository also reside in the memory and preferably execute on one or more CPUs . Of note one or more of the components in may not be present in any specific implementation. For example some embodiments embedded in other software may not provide means for user input or display.

In a typical embodiment the EMS includes one or more GMEs one or more EEs one or more PEs and one or more data repositories for example a data repository with for example user data and a data repository with for example application data. In some embodiments the EMS includes an EMS application programming interface API to enable other programs to access EMS data. In at least some embodiments the EE or the PE is provided external to the EMS and is available potentially over one or more networks . Other and or different modules may be implemented. In addition the EMS may interact via a network with application or client code that receives entitlement data or group membership data computed by the EMS one or more client computing systems and or one or more third party information provider systems . Also of note the user data repository or data application attribute map may be provided external to the EMS as well for example in a data repository accessible over one or more networks .

In an example embodiment components modules of the EMS are implemented using standard programming techniques. However the EMS and the various components thereof can be implemented using dynamic programming techniques object oriented techniques or even in a distributed computing model. For example the EMS may be implemented as a native executable running on the CPU along with one or more static or dynamic libraries. In other embodiments the EMS may be implemented as instructions processed by a virtual machine. In general a range of programming languages known in the art may be employed for implementing such example embodiments including representative implementations of various programming language paradigms including but not limited to object oriented e.g. Java C C Visual Basic.NET Smalltalk and the like functional e.g. ML Lisp Scheme and the like procedural e.g. C Pascal Ada Modula and the like scripting e.g. Perl Ruby Python JavaScript VBScript and the like and declarative e.g. SQL Prolog and the like .

The embodiments described above may also use well known or proprietary synchronous or asynchronous client server computing techniques. Also the various components may be implemented using more monolithic programming techniques for example as an executable running on a single CPU computer system or alternatively decomposed using a variety of structuring techniques known in the art including but not limited to multiprogramming multithreading client server or peer to peer running on one or more computer systems each having one or more CPUs. Some embodiments may execute concurrently and asynchronously and communicate using message passing techniques. Equivalent synchronous embodiments are also supported. Also other functions could be implemented and or performed by each component module and in different orders and in different components modules yet still achieve the described functions.

In addition programming interfaces to the data stored as part of the EMS e.g. in the data repositories and can be available by standard mechanisms such as through C C C and Java APIs libraries for accessing files databases or other data repositories through scripting languages such as XML or through Web servers FTP servers or other types of servers providing access to stored data. The data repositories may be implemented as one or more database systems file systems or any other technique for storing such information or any combination of the above including implementations using distributed computing techniques.

Also the example EMS may be implemented in a distributed environment comprising multiple even heterogeneous computer systems and networks. Different configurations and locations of programs and data are contemplated for use with techniques of described herein. In addition the portions of the EMS may be executed on physical or virtual computing systems and may reside on the same physical system. Also one or more of the modules may themselves be distributed pooled or otherwise grouped such as for load balancing reliability or security reasons. A variety of distributed computing techniques are appropriate for implementing the components of the illustrated embodiments in a distributed manner including but not limited to TCP IP sockets RPC RMI HTTP Web Services XML RPC JAX RPC SOAP etc. and the like. Other variations are possible. Also other functionality could be provided by each component module or existing functionality could be distributed amongst the components modules in different ways yet still achieve the functions of an EMS .

Furthermore in some embodiments some or all of the components of the EMS may be implemented or provided in other manners such as at least partially in firmware and or hardware including but not limited to one or more application specific integrated circuits ASICs standard integrated circuits controllers executing appropriate instructions and including microcontrollers and or embedded controllers field programmable gate arrays FPGAs complex programmable logic devices CPLDs and the like. Some or all of the system components and or data structures may also be stored as contents e.g. as executable or other machine readable software instructions or structured data on a computer readable medium e.g. a hard disk memory network other computer readable medium or other portable media article to be read by an appropriate drive or via an appropriate connection such as a DVD or flash memory device to enable the computer readable medium to execute or otherwise use or provide the contents to perform at least some of the described techniques. Some or all of the components and or data structures may be stored on tangible non transitory storage mediums. Some or all of the system components and data structures may also be transmitted in a non transitory manner via generated data signals e.g. as part of a carrier wave or other analog or digital propagated signal on a variety of computer readable transmission mediums such as media including wireless based and wired cable based mediums and may take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly embodiments of this disclosure may be practiced with other computer system configurations.

As mentioned with respect to one of the functions of the Entitlement Management System is to manage group membership in order to generate user entitlement data. is a flow diagram illustrating example logic performed by an example Group Management Engine. The logic of may be performed for example by GME illustrated in . In block the GME receives application entitlement data. The entitlement data may describe who is entitled to access which computer resource. This entitlement data may not be associated with a particular user but rather may be expressed as characteristics such as what devices the application can be run with how many users at a time during what hours etc. Entitlement data can also determine when how and for how long the entitled party can access the resource such as by subscription or license.

At block the GME receives a group definition. The group definition may include one or more logic clauses that must be satisfied for a certain member candidate to be part of the group. The group definition may be any suitable combination of logic clauses and or combinations thereof as described above. The group definitions can be correlated by roles of the entities relative to an organization which may simply be defined by management when the computer resource in question relates to the entities ability to perform their role. The group definition can however be any arbitrary criteria.

Blocks define a loop that can repeat as often as required to process changes to user and or group data. In block the GME generates one or more queries based on the group composition logic rules. This portion of the logic can be executed by a group definition compiler as described above with reference to .

At block the logic clauses of the group definition are executed against the member candidates candidate entities . That is the attributes of each candidate are compared with the logic clauses of the group to determine which candidates satisfy the group composition rules or are on the included list and are not on the excluded list. The result of this process is to generate database queries such as SQL database queries to generate the flat table data structures or equivalents that can be used to simply and efficiently access a list of members in each group.

In block the database queries are performed and tables are generated. The tables can be flat tables that simply list the members in each group. These tables can then be used to look up members in the group without having to compute the group composition logic rule in response to an attempt to access a computer resource. Once the table is created it can be used to identify which entities are members in a given group or to identify which groups a given entity belongs to easily and quickly.

In block the logic determines whether user data has changed such as when a user retires or leaves the organization or any other change that changes the user s status relative to one or more logic clauses that define membership in a group. When a change is made in block the logic updates the user attribute data and instructs the logic to initiate the loop again at block including regenerating the tables. When no change has occurred then at block the logic determines whether there have been changes to group information that will affect one or more entity s membership in the group such as changing a definition for a group of senior employees from those having 3 years of experience to those having 4 years of experience. If yes the logic continues at block and otherwise continues at block . At block the logic updates the group definition and instructs the logic to initiate the loop again at block . In some embodiments the loop can initiate in response to receiving a change to the user s status or the group s status.

At block when no change to a user or a group has occurred the logic waits for an additional input such as a change to the user s status or the group s status.

The logic may respond to a request to update or recalculate the information in the tables with or without any changes to the user or group information. The logic can be structured such that these recalculations are idempotent so that calculating the tables again or continuously has little computational cost unless there are changes to the information. In some embodiments recalculating the tables can happen in less than about one second in real time minimizing the time during which information is out of synchronization. In response to a change of information the logic can recalculate the entire table or simply recalculate an affected portion of the table. In some embodiments the logic can be instructed to recalculate the tables periodically. Depending on the organization in which the logic is deployed the period for recalculating the tables may vary. For example in a large scale environment receiving frequent requests for access and frequent user and or group changes the tables may need to be recalculated frequently.

Also as mentioned with respect to the EMS may include an analysis and refactoring component for creating further efficiencies. is a flow diagram illustrating example logic performed by an example analysis and refactoring component of an Entitlement Management System. The logic can analyze and refactor group definitions to minimize inefficiencies conflicts or inaccuracies as described with reference to . The logic of can be performed for example by the analysis and refactoring component in in response to determining a need for improving the group definitions or to perform periodic maintenance checks.

At block the logic examines group definitions containing GCRs include lists and exclude lists. The GCRs can include rules based on membership in one or more other groups.

At block the logic determines whether or not a given logic clause is over used. This can be the case if the logic clause appears in more than one group definition or if the logic clause is redundant with one or more other logic clauses in the same group definition. If yes the logic refactors the group definition at block . If no the logic continues at block .

At block the logic determines whether or not a given logic clause is under used such as if the logic clause is not called for a given period of time and the group can be formed using other logic clauses. If yes the logic refactors the group at block . If no the logic continues at block .

At block the logic determines whether or not a given logic clause returns zero results or all possible results. In many cases a logic clause that returns all or zero possible entities is a sign of a logical conflict or a mistake. If yes the logic refactors the group definition at block . If no the logic continues at block .

At block the logic determines the accuracy of a given logic clause. An example inaccuracy can be if the logic clause for any reason yields unforeseen results. A complex rule scheme including multiple group dependencies and cross reference membership rules may cause an unintended membership or omission. For example the order of execution of group definitions may affect membership if membership in certain groups is a criteria for membership in another group. If yes the logic refactors the group definition at block . Part of the analysis and refactoring process can be to run the group definitions in various orders and comparing the results. If no inaccuracy is found the logic continues at block .

At block the logic performs any other suitable check on the group definitions as desired by a given organization or implementation. If any problems are found the logic can refactor at block . If no further problems are found the logic proceeds to block .

The logic or any portion thereof can be executed in any order. The logic can initiate in response to virtually any measurable event or according to an arbitrary or determined schedule.

In an example embodiment of the EMS the persistent calculated data might be stored as described in Table 2 

The data can flow through the entitlement and provisioning system through a series of synchronization sync processes. Sync processes are single threaded operations that look up changes in their source tables and update a destination table. There are three sync processes 

In an example EMS each sync process operates in roughly the same way 1 it runs on a timer e.g. in a java process possibly on multiple machines and 2 it wakes up and participates in a leader election to find which instance to determine which sync process should actually perform the sync . The leader will then look for any changes in the source tables and feed them into core CacheServicer which is responsible for generating changes to the target table. The last update time is stored as a Global Configuration Parameter and is only updated when a sync operation has completed successfully.

The UserGroup Sync process looks at two input tables Users and Groups. In an example embodiment the UserGroup Sync is the only process that writes to the UserGroup table. Also in an example embodiment writing to the UserGroup table is the only side effect of the UserGroup Sync process . Table 4 below illustrates actions that occur when specific events affect the user and or group input tables.

The Entitlement Sync process looks at four input tables in the specified order 1 UserGroup 2 AppEntitlement 3 ActiveServices and 4 UserAuthData . In an example embodiment the EntitlementSync process is the only process that writes to the UserEntitlement table. Also in an example embodiment Writing to the UserEntitlement table is the only side effect of the EntitlementSync process .

In some embodiments the UserAuthData is the last table to be reviewed so that if an activation and an entitlement occur in the same sync period they will be processed in the right order. In another embodiment the Entitlement Sync process is implemented in two parts an Entitlement Sync process and Activation Sync process. Table 5 below illustrates actions that occur when specific events affect the input tables and to the EntitlementsSync process .

The design of the system is meant to be resilient to failures. Modification of tables relating to users can be simple operations that occur in database transactions. Updating calculated data tables is an idempotent operation that occurs periodically. This means that any failures that bring these out of sync e.g. code errors massive usage spikes database crash corruption can be corrected by running the sync processes over again.

The following relationships as illustrated in Table 6 are a part of the system s security in an example embodiment.

The description below describes some of the different states of an entitlement and the user based operations that may occur to cause transitions across the states. These states can be managed through three different fields 

 1 ActiveServices status describes whether an application is active for an organization or not. This comes from the Active Service idServiceStatus .

 2 EntitlementState describes whether an application is entitled to a user or not. This information is calculated from the UserGroup Users and AppEntitlement tables.

 3 ActivationState describes whether a user should actually have a subscription to an application or not. This information comes from the UserAuthData table.

These states can be changed through both administrator and user operations. The following tables 1 describe each of these states and what they mean 2 describe the Admin User operations that change these states 3 describe the processes used to manage these changes in the context of the system architecture and 4 describe extensions to the state model for integration with workflows without describing any of the processes for these state changes .

The app and entitlement state transitions are designed to decompose the global state into three well defined states that match directly to user operations 

 1 ActivationServiceStatus is managed by administrators. This status is controlled by the add remove application operations.

 2 EntitlementState is managed by administrators. It is controlled with modifications to Application Entitlements.

 3 ActivationState is managed by users. It is controlled by activating or de activating applications the users are entitled to.

ActiveServices status describes whether an application is activated for an organization or not. In an example embodiment only a request thread not a sync thread should set this state. An organization with no ActiveService for an application should be semantically the same as an organization with a Deactivated ActiveService for an application.

EntitlementState is the entitlement state for a user based on the AppEntitlements UserGroup and Users tables. ActivationPolicy in the Entitlement structure in AppEntitlement will determine if an entitlement is User or Auto. If it is user the user indicates when to launch an application the user is entitled to for example by double clicking on an icon with an input device. If it is Auto the system may launch the application upon user login. Having an entitlement state of None is represented in our system by having no UserEntitlement record. There is no explicit None state for ActivationPolicy. In an example embodiment only a request thread not a sync thread should make changes to the AppEntitlement table.

Activation State describes whether an entitlement is activated or not. This acts as expected state for the provisioning operations and subscription information. When ActivationState is activated the application should have subscription parameters provided with it. It may at any time be provisioned based on whether the proper parameters are filled out. When ActivationState is notActivated the application may have subscription parameters associated with it if it was activated earlier. The application should be either de provisioned or in the process of de provisioning. When ActivationState is deleted the application should not have subscriptions parameters associated with it. If it was previously activated its parameters should be cleared.

These are operations that directly affect activation state. There are several operations already listed above that will cause activation states to change as a result e.g. disabling an application for an organization.

All of the above U.S. patents U.S. patent application publications U.S. patent applications foreign patents foreign patent applications and non patent publications referred to in this specification and or listed in the Application Data Sheet including but not limited to provisional patent application No. 61 481 184 filed on Apr. 30 2011 are incorporated herein by reference in their entireties.

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention. For example the methods and systems for performing dynamic group management discussed herein are applicable to other architectures other than a computer resource architecture. For example the entitlements can pertain to other resources such as physical plants or organizational privileges. Also the methods and systems discussed herein are applicable to differing group management protocols communication media optical wireless cable etc. and devices such as wireless handsets electronic organizers personal digital assistants portable email machines game machines pagers navigation devices such as GPS receivers etc. .

