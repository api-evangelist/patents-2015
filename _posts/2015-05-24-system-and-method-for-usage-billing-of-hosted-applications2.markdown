---

title: System and method for usage billing of hosted applications
abstract: A system, method, and computer readable medium for usage billing of one or more hosted applications serving one or more clients. The hosted applications are contained within one or more isolated environments or run without isolated environments. The system may include usage billing based on one or more of resources open, amount of data flowing through resources, number of open files, number of transactions, number of concurrent users, number of processes, CPU utilization and memory usage, The system may further include a management interface where administrators may add, remove and configure isolated environments, configure client policies and credentials, and force upgrades. If using isolated environments, the isolated environments may be isolated from other applications and the host operating system on the clients and applications within the isolated environments may run without performing an application-installation on the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09576308&OS=09576308&RS=09576308
owner: Open Invention Network LLC
number: 09576308
owner_city: Durham
owner_country: US
publication_date: 20150524
---
This application is a continuation and claims priority from U.S. application Ser. No. 14 450 879 filed on Aug. 4 2014 titled SYSTEM AND METHOD FOR USAGE BILLING OF HOSTED APPLICATIONS which is a continuation of U.S. application Ser. No. 14 170 830 filed on Feb. 3 2014 titled SYSTEM AND METHOD FOR USAGE BILLING OF HOSTED APPLICATIONS now U.S. issued U.S. Pat. No. 8 799 119 issued on Aug. 5 2014 which is a continuation of U.S. application Ser. No. 13 844 878 filed on Mar. 16 2013 titled SYSTEM AND METHOD FOR USAGE BILLING OF HOSTED APPLICATIONS now U.S. issued U.S. Pat. No. 8 645 240 issued on Feb. 4 2013 which is a continuation of U.S. application Ser. No. 12 851 663 filed on Aug. 6 2010 titled SYSTEM AND METHOD FOR USAGE BILLING OF HOSTED APPLICATIONS now U.S. issued U.S. Pat. No. 8 401 941 issued on Mar. 19 2013 which is a continuation in part and claims priority from U.S. application Ser. No. 12 813 593 filed on Jun. 11 2010 titled SYSTEM AND METHOD FOR APPLICATION ISOLATION WITH LIVE MIGRATION now U.S. issued U.S. Pat. No. 8 539 488 issued on Sep. 17 2013 which is a continuation in part of U.S. application Ser. No. 12 421 691 filed on Apr. 10 2009 titled SYSTEM AND METHOD FOR APPLICATION ISOLATION now U.S. issued U.S. Pat. No. 8 341 631 issued on Dec. 25 2012 each of which are incorporated herein by reference in their entirety. This application is related to the following commonly assigned applications U.S. patent application Ser. No. 12 813 618 filed on Jun. 11 2010 titled SYSTEM AND METHOD FOR HIERARCHICAL INTERCEPTION WITH ISOLATED ENVIRONMENTS now U.S. issued U.S. Pat. No. 8 464 256 issued on Jun. 11 2013 is related to U.S. patent application Ser. No. 12 421 692 filed on Apr. 10 2009 titled SYSTEM AND METHOD FOR APPLICATION ISOLATION now U.S. issued U.S. Pat. No. 8 904 004 issued on Dec. 2 2014 is related to U.S. patent application Ser. No. 12 421 694 filed on Apr. 10 2009 titled SYSTEM AND METHOD FOR APPLICATION ISOLATION now U.S. issued U.S. Pat. No. 8 782 670 issued on Jul. 15 2014 is related to U.S. patent application Ser. No. 12 839 576 filed on Jul. 20 2010 titled SYSTEM AND METHOD FOR STREAMING APPLICATION ISOLATION now U.S. issued U.S. Pat. No. 8 418 236 issued on Apr. 9 2013 is related to U.S. patent application Ser. No. 12 839 610 filed on Jul. 20 2010 titled SYSTEM AND METHOD FOR CACHED STREAMING APPLICATION ISOLATION is related to U.S. patent application Ser. No. 12 839 673 filed on Jul. 20 2010 titled SYSTEM AND METHOD FOR ON LINE AND OFF LINE STREAMING APPLICATION ISOLATION now U.S. issued U.S. Pat. No. 8 555 360 issued on Oct. 8 2013 each of which are incorporated herein by reference in their entirety.

A portion of the material in this patent document is subject to copyright protection under the copyright laws of the United States and of other countries. The owner of the copyright rights has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the United States Patent and Trademark Office publicly available file or records but otherwise reserves all copyright rights whatsoever. The copyright owner does not hereby waive any of its rights to have this patent document maintained in secrecy including without limitation its rights pursuant to 37 C.F.R. 1.14.

This invention pertains generally to enterprise computer systems computer networks embedded computer systems wireless devices such as cell phones and PDAs computer systems and more particularly to methods systems and procedures i.e. programming for providing application isolation for multiple applications running on a host operating system and for providing usage billing for applications running within the isolated environments. The invention further provides application usage billing for applications running within a cloud computing or hosted environment with or without isolated environments.

In many environments one of the most important features is to ensure that one running application doesn t affect other running applications and that the crash of one application doesn t compromise other running applications. In many environments applications share system resources libraries and hardware which expose subtle interconnects between seemingly unrelated applications.

Several approaches have been developed addressing this fundamental problem. The first level of application isolation is provided by the operating system. Modern operating systems such as Linux UNIX Windows2000 NT XP and Vista provide some level of application isolation through the use of processes and the underlying hardware memory management unit. The use of processes generally ensure than one running application process cannot address memory owned by other processes. This first level of isolation does not address the use of shared resources such as files file systems shared memory and libraries so other approaches have been developed.

The present invention builds on the teachings in U.S. application Ser. No. 12 813 593 wherein Havemose teaches SYSTEM AND METHOD FOR APPLICATION ISOLATION WITH LIVE MIGRATION now U.S. issued U.S. Pat. No. 8 539 488 issued on Sep. 17 2013 and U.S. application Ser. No. 12 813 618 wherein Havemose teaches SYSTEM AND METHOD FOR HIERARCHICAL INTERCEPTION WITH ISOLATED ENVIRONMENTS now U.S. issued U.S. Pat. No. 8 464 256 issued on Jun. 11 2013 collectively identified as Havemose throughout the disclosures. Havemose further discloses system and methods for creating isolated environments and for the use of pre created isolated environment as installation free images that can run on a client without requiring direct application installation on the client. Havemose teaches an approach that works on commodity operating system using off the shelf applications. Havemose is incorporated herein by reference in its entirety.

In a Cloud computing environment where resources and applications are dynamically assigned and accessed remotely a related challenge is one of charging for the use of the application. Historically applications were purchased by a corporation installed in the company s datacenter and managed by in house IT staff. With the shift to cloud computing the applications are hosted somewhere in the internet cloud and accessed remotely. The actual end user or the end user s IT group are typically not responsible for installing hosting and maintaining the application.

A variety of approaches have been designed to manage billing for application use. Historically software was purchased and paid for once and keep updated using an annual maintenance contract. With the move to hosted applications the hosting provider needs a flexible way to do usage billing where the user pays based on actual use patterns. Existing billing mechanisms are often either fixed one time licenses as just described or require custom applications custom operating systems or custom hardware.

In U.S. Pat. No. 5 047 928 and U.S. Pat. No. 5 155 680 Wiedmer teach Billing System for Computer Software and Billing System for Computing Software respectively. The teachings rely on a combination of algorithms and custom hardware security and billing modules. The billing modules are replaced periodically and the billing information is read from the billing module. In a typical cloud environment requiring custom hardware and replacement of modules to do billing is impractical and not well suited to hosting in a datacenter. Furthermore the teachings do not address usage billing.

In U.S. Pat. No. 5 235 290 Cauffman et al teach Billing System with Data Indexing . The teachings describe a pre processing mechanism to facilitate display under the control of a service customer for services rendered to a customer. The teachings do not disclose steps for collection of usage billing information or the use in a cloud computing environment only a pre processing step for displaying the results.

In U.S. Pat. No. 5 386 369 Christiano teach License Metering System for Software Applications . The teachings rely on a hardware dongle as metering device and disclose various techniques to ensure that the application metering data is accurately stored and cannot easily be lost due to hardware failures. The teachings do not address the actual metering mechanics the use within the context of cloud computing or application isolation.

In U.S. Pat. No. 5 708 709 Rose teach System and Method of managing try and buy usage of application programs . The teachings focus on ensuring that a user only can run applications properly licensed using a combination of encryption and verification. The teachings do not address collecting usage billing information or application isolation.

Therefore in many systems providing usage billing of hosted applications requires one or more of customized operating systems customized applications and proprietary billing infrastructure Furthermore the above cited references do not include or address application isolation. Hence there is a need for systems and methods that combine application isolation with usage billing of hosted applications running on commodity operating systems such as Windows and Linux

The present invention provides a system and methods for usage billing of one or more hosted applications. The one or more applications are pre configured inside one or more isolated environment and the isolated environments are hosted on one or more central servers. The teachings of Havemose work on commodity operating systems such as Windows and Linux and work with standard off the shelf applications no customizations of operating system or applications are required and no virtual machines virtual file system or any other proprietary protocols are needed. The isolated environments with said one of more applications are accessed remotely or locally and clients can run said one or more applications without ever performing a local installation. Usage billing information is collected for said one or more applications and collected and aggregated for billing purposes. In one embodiment an implementation in the Linux environment is disclosed in another embodiment an implementation on Windows is disclosed. In yet another embodiment an implementation of usage billing without isolated environments is disclosed.

Another aspect of the present invention is the fine granularity on which usage billing is provided. Examples include billing based on application time used application memory used number of open files number of transactions amount of air time and a variety of other metrics. Yet another aspect of the present invention is a flexible event driven billing aggregator providing summary billing information for each chosen event type.

Yet other aspects of the present invention are a two way authentication subsystem and encryption of communication data. The streaming server is authenticated by clients before they accepting any streaming data and clients likewise are authenticated against pre defined credentials before the streaming servers delivers any isolated environments or updates.

A user of the client computer can run the application without needing to install or configure the application the user runs the application as pre configured and provided on the streaming server. The present teachings require no special virtual file systems proprietary streaming protocols or any other proprietary protocols.

The terms Windows and Microsoft Windows is utilized herein interchangeably to designate any and all versions of the Microsoft Windows operating systems. By example and not limitation this includes Windows XP Windows Server 2003 Windows NT Windows Vista Windows Server 2008 Windows 7 Windows Mobile and Windows Embedded.

The terms Linux and UNIX is utilized herein to designate any and all variants of Linux and UNIX. By example and not limitation this includes RedHat Linux Suse Linux Ubuntu Linux HPUX HP UNIX and Solaris Sun UNIX .

The term node and host are utilized herein interchangeably to designate one or more processors running a single instance of an operating system. A virtual machine such as VMWare KVM or XEN VM instance is also considered a node . Using VM technology it is possible to have multiple nodes on one physical server.

The terms application is utilized to designate a grouping of one or more processes where each process can consist of one or more threads. Operating systems generally launch an application by creating the application s initial process and letting that initial process run execute. In the following teachings we often identify the application at launch time with that initial process.

In the following we use commonly known terms including but not limited to client server API java process process ID P D thread thread ID TID thread local storage TLS instruction pointer stack kernel kernel module loadable kernel module heap stack files disk CPU CPU registers storage memory memory segments address space semaphore loader system loader system path sockets TCP IP http ftp Inter process communication IPC Asynchronous Procedure Calls APC POSIX and signal . These terms are well known in the art and thus will not be described in detail herein.

In the following we use commonly known terms from computer security and encryption including but not limited to certificate certificate authority Secure Socket Layer SSL MD 5 MD 6 Message Digest SHA Secure Hash Algorithm NSA NIST private key public key key pair and hash collision . These terms are well known in the art and thus will not be described in detailed herein.

The term transport is utilized to designate the connection mechanism and or protocols used for communicating across the distributed application. Examples of transport include TCP IP Message Passing Interface MPI Myrinet Fibre Channel ATM shared memory DMA RDMA system buses and custom backplanes. In the following the term transport driver is utilized to designate the implementation of the transport. By way of example the transport driver for TCP IP would be the local TCP IP stack running on the host.

The term interception is used to designate the mechanism by which an application re directs a system call or library call to a new implementation. On Linux and other UNIX variants interception is generally achieved by a combination of LD PRELOAD wrapper functions identically named functions resolved earlier in the load process and changes to the kernel sys call table. On Windows interception can be achieved by modifying a process Import Address Table and creating Trampoline functions as documented by Detours Binary Interception of Win32 Functions by Galen Hunt and Doug Brubacher Microsoft Research July 1999 . Throughout the rest of this document we use the term interception to designate the functionality across all operating systems.

The term file context or context is used in relation with file operations to designate all relevant file information. By way of example and not limitation this includes file name directory read write append execute attributes buffers and other relevant data as required by the operating system.

The term transparent is used herein to designate that no modification to the application is required. In other words the present invention works directly on the application binary without needing any application customization source code modifications recompilation re linking special installation custom agents or other extensions.

The terms private and isolated environment and isolated environment IE are used herein interchangeably to designate the private area set aside for application isolation as described in Havemose. The abbreviation IE is used to designate an isolated environment on the diagrams and throughout the text.

The Term Isolated Environment Infrastructure IEI is used herein to designate the entire isolated environment infrastructure as disclosed in Havemose. It s comprised of shared libraries a series of interceptors and other configuration information is described in the cited reference. Details of IEI will not be further described herein.

The terms Cloud Computing Software as a service SaaS Utility Computing and Hosted Applications are used herein interchangeably to designate a deployment model where applications are hosted centrally often off site and accessed remotely. Typically the applications are hosted and managed by an independent company and the end user pays to access the software services.

The term usage billing is used herein to designate that the user of an applications pays to use the application based on one or more metrics. Possible metrics include but are not limited to time used storage used number of open files number of records in a database and number of times the application has been launched.

Further aspects of the invention will be brought out in the following portions of the specification wherein the detailed description is for the purpose of fully disclosing preferred embodiments of the invention without placing limitations thereon.

Referring more specifically to the drawings for illustrative purposes the present invention will be disclosed in relation to through . It will be appreciated that the system and apparatus of the invention may vary as to configuration and as to details of the constituent components and that the method may vary as to the specific steps and sequence without departing from the basic concepts as disclosed herein.

The context in which this invention is disclosed is one or more applications installed inside isolated environments and hosted on an Isolated Environment Streaming Server IESS with the isolated environments being streamed to one or more clients. The Havemose reference cited above included in its entirety by reference teaches the creation and maintenance of the isolated environments. Usage billing information is collected by the Isolated Environment Infrastructure IEI present on all clients and aggregated by a billing manager system. Without affecting the general case of multiple applications the following scenarios often depict and describe one or two applications as applicable. Multiple applications are handled in a similar manner. Similarly the following scenarios often depict one or two clients multiple clients are handled in a similar manner. Similarly the following scenarios often depict one isolated environment per client multiple isolated environments are handled in a similar manner. Similarly the following scenarios often depict one IESS multiple IESSes are handled in a similar manner. The term client is used only to designate that it s the recipient of the isolated environments steamed from the IESS. By way of example the client may be a desktop workstation a server in a data center or a virtual machine hosted on some other server

Each client connects to the IESS via the Client Policy Manager CPM . The CPM validates the credentials and maintains an Account for each credentialed client. Associated with each Client Account is an update cache used to optimize access to isolated environments enabled for the particular client. Each client has one update cache per credentialed IE. If a client account has access to two IEs there are thus two update caches for that particular client.

It is readily apparent to someone skilled in the art that the architecture extends to any number of clients any number of isolated environments on any one client and to any number of pre configured isolated environments on the IESS.

System resources such as CPUs I O devices Network interfaces and storage are accessed using the operating system . Devices accessing remote resources use some form of transport network . By way of example system networking may use TCP IP over Ethernet transport Storage may use Fibre Channel or Ethernet transport and I O may use USB.

System resources such as CPUs I O devices Network interfaces and storage are accessed using the operating system . Devices accessing remote resources use some form of transport network . By way of example system networking may use TCP IP over Ethernet transport Storage may use Fibre Channel or Ethernet transport and I O may use USB.

To ensure secure and private communication the IESS most be properly credentialed. By way of example if personnel in HR want to interact with the payroll system on the IESS and upload payroll information the client system used by the HR employee validates the credentials of the IESS before uploading sensitive payroll information. If the IESS credential validation fails the client system disconnects and stops interacting with the IESS.

A related issue is security ensuring that no malware of spyware gets downloaded into the clients isolated environments. By requiring a credentialed IESS there a no risks of connecting to a malware site by mistake as such connections would be refused by the isolated environment infrastructure without establishing any connection beyond the initial attempt to validate credentials.

Full IESS credentials are provided by a standard SSL certificate issued by either a certificate authority or generated in house. If the IESS is accessed over the internet a preferred implementation uses a certificate issued by a Certificate Authority. If the IESS only is accessed via a private LAN WAN or VPN an in house generated certificate would suffice but a certificates issued by a Certificate Authority equally works.

The present invention establishes the initial secure communication using Secure Sockets Layer SSL a standardized technology widely available in modern operating systems such as Windows and Linux. Open source implementations of SSL include OpenSSL www.openssl.org .

First a certificate for the IESS is generated. Generation of the IESS certificate only is needed when creating a new certificate or when a certificate has expired. Generally a certificate is valid for one or more years if generated by a certificate authority. First a private and public key pair is generated . This is accomplished using commonly available tools such as makekey provided by OpenSSL. In a preferred implementation the a certificate request is prepared certreq in OpenSSL with the public key and transmitted to the Certificate Authority together with information confirming the senders identity. The Certificate Authority generates a certificate and delivers it back to the originator and the certificate is installed on the IESS. In an alternate implementation the certificate is self generated using one of the available tools such as testreq from OpenSSL. The certificate is used to establish the credentials of the IESS by clients.

The client initiates communication with the IESS using SSL. In response to the initial contact the IESS accepts the request for the certificate and delivers the certificate to the client. The client validates the certificate . Validation can take one of two forms in a preferred implementation the certificate is compared against a local copy provided by the administrator as part of present invention in an alternate implementation the certificate is validated against known and pre approved certificate authorities. Modern operating systems such as Linux and Windows provide a mechanism to store pre approved certificates. If the validation fails the client disconnects as the IESS is rogue mis configured or has an invalid certificate. If the certificate validates the client proceeds and using SSL establishes secure and encrypted communication with the IESS.

The client is now ready to have its client credentials validated by the Client Policy Manager CPM within the IESS.

With possibly multiple isolated environments hosted on an IESS proper authentication of clients is important. By way of example if a particular isolated environment contains a payroll software application only clients with the proper credentials generally personnel in human resources should have access to the payroll application. The Client Policy Manager CPM running on the IESS governs which clients have access to which isolated environment. The specific client privileges are set by the system administrator and are implemented by the CPM.

The connection between client and IESS as describe above is established using SSL and is therefore secure and encrypted. The client only needs the client account as its credentials. All IEs available to a particular client are managed by the CPM and the key pair needed for encryption is managed by SSL.

When a client wishes to use a particular application within an isolated environment the client makes a request to the Client Policy Manager CPM for access to the requested IE. The CPM validates the client credentials at two levels first the client is validated as having access to the IESS services followed by validation of the client s credentials for the requested IE.

If the client is credentialed to run the particular IE the IE needs to be either installed or potentially updated. If the IE is not installed on the client it is copied to the client environment and the IESS update caches are updated to reflect the current state of the client copy. If the IE already is installed on the client the update caches on IESS are queried and updates propagated as necessary. The caching and installation are described in more detail below.

When a client starts the present invention he is presented with a list of available IEs based on his credentials. illustrates by way of example embodiment a client obtaining the list of credentialed applications and launching a chosen application. First the client is credentialed as described above. The client requests a list of credentialed IEs and the CPM responds with a list of IEs available and credentialed for the particular client. The list is presented to the client . In a preferred embodiment the client is presented with a graphical user interface allowing the client to choose from a list of credentialed applications and starting the application directly by clicking either on the application name or OK . The launch can be cancelled by selecting Cancel . The client can also force a refresh of available IEs thereby updating the IE list . In a preferred embodiment the most recently chosen application is automatically highlighted. By way of example illustrates the scenario with two credentialed applications Payroll and Benefits and one application no longer credentialed Investor Relations . By selecting Off line the user indicates no synchronization against the IESS and that the local already installed IE should be run.

The Client Policy Manager CPM within the IESS is the main contact point between clients and the IESS. The functionality of the CPM fall in several broad categories 1 delivery of certificates to clients and establishment of SSL 2 general client account access 3 administration and 4 management and implementation of the caching subsystem. illustrates by way of example embodiment the architectural blocks of the CPM .

As disclosed previously the IESS is credentialed by clients using a SSL certificate. The certificate serves dual roles as a mechanism for the clients to validate the identity of the IESS and by providing keys for secure encrypted communication over SSL. Referring to for illustrative purposes the IESS certificate interface is responsible for responding to certificate requests and to deliver them. The SSL interface is responsible for the IESS end of SSL. In modern operating systems SSL is in general pre defined to use certain ports such as and for SSL certificates and https respectively. In a preferred implementation the present invention uses different ports that the default ports to avoid conflicts with web browsing and to minimize attacks. In an alternate implementation the standard ports are used.

As previously disclosed the CPM provides a number of client services. Referring to for illustrative purposes The validation of clients as disclosed in section 5 the enumeration of available IEs given the clients credentials section 5 and the general client account and credentials subsystem containing an account database with account info for each valid client account

Associated with each client account is a record in the account database containing specific information about the account and subsystems for cache management and billing logging . Each client account record in the database contains at least the following fields 

The client login is the user id used to validate the client account while the account holder name is the actual name of the person to which the account is assigned. The status of account indicates if the account is valid and credentialed. Finally the database maintains a list of isolated environments to which the user is credentialed. This list is presented to the user when requesting Client IE enumeration as disclosed in section 5.

Associated with the client account are also the caching subsystem and the billing and logging subsystem .

When a client requests access to a credentialed isolated environment the IE is streamed in its entirety if not already present on the client system or the client IE is selectively updated with changes as appropriate. In the following the details on these steps are disclosed.

By way of example a typical Microsoft Office 2003 installation consists of approximately 1800 files with a combined size of about 315 MB. Some of the largest files are Word at 12 MB Excel at 10 MB and PowerPoint at 6 MB. On a typical 1 Gbit sec corporate network a typical good transmission rate is about 100 MB sec but can be significantly less. A typical ADSL connection runs at 1.5 Mbit sec or 150 kB sec and can be less.

The one time installation of the entire environment with Office 2003 therefore typically takes about 3.1 sec or longer over corporate network. Over ADSL the Office IE takes 35 min or longer. While the 3.5 seconds on the office network is acceptable the 35 minutes for ADSL access is not practical. The present invention includes an update caching subsystem ensuring that only changed files are streamed to the client and furthermore that the streaming is compressed when appropriate.

To reduce the need to stream files already present on the client computer an update cache is employed for each IE. The update cache contains pre computed information assisting in quickly indentifying which files have changed since last time the IE was accessed thereby reducing unnecessary streaming of IE files.

The update cache for a particular IE is comprised of a list of records called CacheLine where each record corresponds to one file within the isolated environment. The data structure for CacheLine in pseudo code 

The field m FileName is the name of the file and m Directory the directory location of the file. The combination of m FileName and m Directory uniquely identifies the file. The field m LastChangeTime is the time at which the particular file was most recently changed updated or created and m FileSize is the size of the file.

To make the update cache efficient the present invention pre computes a m messageDigest representing the file. The message digest is a 128 bit or longer integer calculated in a manner to ensure that two different files have different message digests. Message Digests are well known within the art. Commonly deployed digests are MD5 Message Digest algorithm 5 of size 128 bit MD6 Message Digest algorithm 6 with sizes up to 512 bits and SHA n Secure Hash Algorithm n with sizes up to 1024 bits . The message digest is used as part of the validation to see if a particular file should be streamed to the client. A practical issue is hash collision where two different files produce the same hash value. SHA 2 has no known hash collisions and is the default in a preferred embodiment. To further reduce the risk of a hash collision possibly affecting the update caches the size of the file m FileSize and the time stamp of the most recent file change m LastChangeTime are also used in the comparing against the update cache.

All supported Message Digests Algorithms are predefined as integers and the one used encoded in the field m MessageDigestAlgorithm .

Another field m CompressionOn determines if compression is used for the particular file corresponding to the CacheLine. Depending on file size network bandwidth and available CPU cycles files may selectively be compressed prior to being streamed to the client. All supported compression algorithms are pre defined as integers and the one used encoded in the field m compressionAlgorithm . Compression algorithms are provided as part of modern operating systems such as Windows and Linux. In a preferred embodiment the operating systems default compression algorithm is used. In an alternate embodiment a customized compression algorithm is used. A wide selection of open source and commercial no loss compression algorithms exists including but not limited to LZ LZR LZX PKZIP GZIP and ZIP. In a preferred embodiment files are automatically compressed if the network operates at less than 1.5 mbit sec and the file size is greater than 1 MB. In an alternate embodiment every file is compressed. In another alternate embodiment no files are compressed.

The Havemose reference cited above and included in its entirety teach creation and updating of isolated environments. The IE s associated update cache is generated after install update as follows in pseudo code 

When creating a new Isolated Environment and installing applications within the IE all CacheLines in the update cache are new. The above listed set of instructions thus creates the update cache with all new elements.

By way of example after applying a software patch the update cache needs to be updated. A software patch generally modifies adds and removes files and the update cache is updated to reflect the changes. Referring to the pseudo code above CacheLines corresponding to new files are added CacheLines corresponding to modified files are re computed and updated and CacheLines corresponding to now deleted files are removed. Files unaffected by the software patch are left unchanged in the update cache. Similarly the update caches are updated after a patch to the operating system.

Optimized streaming where the fewest possible files are streamed from the IESS to a client requesting the use or update of a particular isolated environment is achieved by using of the update caches on both the client and the IESS

To determine which files within the IE on the IESS have been modified since the client last connected the Cache Mgr compares the client s u cache with the corresponding update cache on the IESS. The entire process is as follows 

Initially the client and the IE are credentialed against the CPM as previously disclosed . The client requests an update of the IE and transmits the client s u cache to the CPMs cache mgr . The CacheMgr s traverses the update cache one CacheLine at a time and comparing against the u cache received from the client . First test is to see if the current CacheLine is present in the client s u cache. If the CacheLine is not in the u cache it signifies a new file in the IE and the file corresponding to the CacheLine is prepared to be transmitted to the client . If the CacheLine exists in the u cache a second test is performed. The second test is to see if the CacheLine entry has been updated when compared to the corresponding u cache CacheLine. If the IESS CacheLine indicates a change has been made the file corresponding to the CacheLine is prepared to be transmitted to the client. If the CacheLines are identical in the update cache and u cache no further steps on this CacheLine are necessary.

The second test to see if two CacheLine Entries are identical is performed as follows The client u cache and the update cache CacheLines are considered identical if all of the following are identical m FileName m Directory m LastChangeTime m FileSize and m MessageDigest. If one or more of said fields are different the entry is deemed not too match.

The final step after identifying a file for transmittal to the client is to test if the file should be compressed per the field in the CacheLine. If the file is to be compressed it s compressed and transmitted . If compression is not activated the file is transmitted .

Upon completing the comparison of the client s u cache with the update cache the update cache is sent to the client

On the client all new files are received and copied into the environment . Finally the u cache is replaced with the update cache corresponding to the just completed update . The final step is to synchronize the client s new u cache against the client s IE and remove files no longer included in the u cache . If the client immediately reconnected the update process would detect no new files and the update process would be instantaneous.

In continuation of the example above a typical Microsoft Office security patch modifies few of the 1800 files in full installation of Office. By way of example if 50 files are modified only those 50 files need to be streamed to the client corresponding to less than 3 of the total installation. This reduces the ADLS update from 35 minutes to 1 minute which is a practical delay to install a patch over a slower network.

The present invention supports two modes of operation an off line mode of operation where the client runs an already installed isolated environment without connecting to the IESS and an on line mode where the client is fully validated and updates automatically are streamed.

By way of example a user connects with the present invention while at the office retrieves and updates all credentialed IEs and works with the applications within the IE as if they were locally installed. Later the user is travelling and loads the present invention again. This time the user selects the off line mode of operation. In stead of getting credentialed by the IESS the user simply runs the applications within the already installed IEs. No updates are forced and no changes are streamed. The off line mode allows the user to work without needing network access.

If the network is available on line mode is enabled and the user can choose to operate in on line or off line mode . If the user chooses off line the user is presented with the list of already credentialed IEs available to run . The user chooses an IE and the IE is run. If the user chooses to proceed in on line mode the steps outlined in section and are followed . Upon finishing the IEI exits the IE

The present invention provides administration for both clients and the IESS. Administration on the client is a matter of installing the IEI and the user account name all other administrative options are contained and controlled on the IESS.

In a preferred embodiment the administration is performed using a graphical user interface. In an alternate embodiment as software application programming interface API is used.

The Havemose disclosures included in their entirety by reference teach layered interception for multi process multi threaded application groups. The following disclosures build on said layered interceptions system and methods to add fine grained usage billing

By way of example the application group consists of one application A . Multiple applications are handled in a similar manner. The Application Group Control Process AGCP launches Application A and launches the local Billing Manager . The AGCP loads the barrier for the application group. As part of the load process the AGCP preloads the interceptors including the Interception Layer IL for each application process the billing interceptors and the checkpointer library for each application process. The application process interception layer the billing interceptors and the checkpointing library are shared libraries and pre loaded together. In an alternate implementation the application process interception layer the billing interceptors and the checkpointing library are combined into one shared library. All libraries operate within the address space of the application process where they were loaded.

As part of loading and initializing the application A AGCP further creates a dedicated checkpointing thread for each process in the application group. illustrates by way of example a one process application A with one corresponding checkpointing thread . Multi process applications are handled in a similar manner with one checkpointing thread created per process. As processes are created and terminated checkpointing threads are added and removed as necessary as disclosed in Havemose. As part of initializing the checkpointing library the checkpointing library registers the current process with the checkpoint barrier The registration ensures that the current thread and process is included in the barrier and ensures that the current process checkpoint thread is called as part of the barrier The billing interceptor run within the address space of the application process and are automatically included in the checkpoints.

The Interception database IDB is global to all application groups within the isolated environment. If the IDB has not been loaded the AGCP launches the IDB prior to the performing the load process disclosed above.

The checkpointer billing interceptors and the isolated environment all need access to all intercepted functions. In general the checkpointer operates on the running application and utilizes interception to capture resource and their usage. The isolated environment utilizes the interception to re direct resource usage to the isolated environment and the billing interceptors add billing counters to a variety of system calls. By way of example and not limitation when application A reaches function ifunc which is subject the interception the function ifunc is intercepted and re directed to the application process interception library . At this point ifunc its context and parameters reflects the actual running application process. The intercepted call is first processed by the billing interceptor then forwarded to the checkpointing library where all relevant stack information is saved. If ifunc changes the process hierarchy the change is communicated to AGCP in order to have AGCP preload or remove the interceptors as previously disclosed. Control is then returned to the application process interception layer . The application process interception layer calls to the Interception Layer IL . The IL remaps resources using the Interception Database as disclosed in Havemose. Adjusted resources or data are returned to the interceptor and sent back to the calling application process via the return of ifunc .

Usage billing requires sampling and monitoring of application group execution. By way of example an application user may be billed based on one or more of amount of CPU time used by the application amount of resources required number of open files number of concurrent users number of transactions number of processes and the number of time the application has been run.

The billing interceptors run as part of the application group s application processes and are only activated when an intercepted function is called. This makes the billing interceptors especially efficient for capturing data related to resource usage transactions or any other activity triggered by the application. illustrates by way of example embodiment this in detail. Continuing with the example embodiment from but reducing it to the essential elements related to the billing subsystem the AGCP launches the application A and the local billing manager . The interceptors consists of the application process interception layer and the billing interceptors .

The billing interceptors are broken down into one or more sub groups . Example sub groups include but are not limited to files opened used transaction count user count and resources used opened . By way of example the files opened used interceptor intercepts all calls that open files such as open and fopen and increments counters each time a new file is opened.

The interceptor keeps track of the billing information using a data structure. Example data structure in pseudo code

Such are provided in Java by Big Integer and the equivalent classes and libraries in C and C . All that is required is that they can fully represent m usecount and m DataAmount. The m InterceptorID is an integer assigned to each interceptor at development time enabling the Local Billing Manager to determine which interceptor generated a certain billing event.

The billing interceptor for fopen would increment its m usecount counter by one indicating the use of a file and the interceptor for fwrite would increment its m Usecount by one and it s m DataUsed by strlen pStr 1 bytes corresponding to the number of bytes written. Other function interceptors work in a similar manner.

Upon completing the interception the interceptor forwards the BillingEvent to the Local Billing Manager s Pending Billing Events message buffer . In a preferred embodiment the BillingEvent is forwarded using sockets. In an alternate embodiment named pipes are used. In yet another alternate embodiment IPC is used.

The Billing aggregation subsystem process all incoming BillingEvents and keeps a running total for each m InterceptorID. The billing aggregator maintains an array of all Billing Events and updates the array as new BillingEvents come in. The Billing Aggregation is described by the following pseudo code 

At all times the Billing Aggregation has subject to processing of pending incoming Billing Events an up to date view of billable events and thus has all the data to generate true usage based billing.

If an isolated environment contains multiple applications there is one application group control process for each application and each AGCP launches its own Local Billing Manager.

The teachings so far cover collection of usage billing information within an isolated environment using a combination of interception and profiling. The local billing manager within each isolated environments communicate the usage billing information to a Central Billing Manager responsible for aggregation across all running isolated environments and applications.

Using the same algorithm and with an extended message structure the local billing manager forwards its aggregated billing information to the central billing manager . One additional field is added to the BillingEvents to form the BillingManagerEvents

Where m ClientLogin is the user name corresponding to the isolated environment. This uniquely identifies the party responsible for the billing event i.e. the Client and the type of billing event.

The message format disclosed above thus enables the CBM to accurately aggregate billing information both by client and by isolated environment.

In a preferred embodiment the local billing manager sends the BillingManagerEvents to the central billing manager using sockets. In a preferred embodiment the local billing manager aggregates billing events on a user configurable timer.

As disclosed for the Local Billing Manager the CBM process all incoming BillingManagerEvents using the same algorithm disclosed above to build a complete billing history for all isolated environments by client and by Billing Event. This provides very fine grained usage billing of running applications. At any point in time the Central Billing Manager thus has all usage data available and can generate usage billing in real time.

The usage billing provides detailed usage by client and usage type. Said billing details may be provided as XML structured data Microsoft Excel format or any other pre defined export format.

In one embodiment the invention is configured with the IESS on a central server . Two application servers have their applications and isolated environments streamed from the IESS and are serving the applications to clients over the LAN . In this embodiment a PC on the LAN access the hosted applications . In another embodiment a PC access the hosted applications over the internet In a third embodiment the invention is configured to serve applications to a cell phone or PDA accessing the applications over a wireless internet . The invention runs on one or more of the devices can be distributed across two or more of these elements and allows for running the invention on any number of the devices at the same time and without interfering with each other.

The just illustrated example embodiments should not be construed as limiting the scope of the invention but as merely providing illustrations of some of the exemplary embodiments of this invention

The teachings above are built on the layered interception disclosed in Havemose. While the teachings above are presented in the context of the isolated environments the billing system and methods only rely on the layered interception and the disclosed messaging and data structures.

The local billing manager inserts the client login into the BillingManagerEvents it generates. For embodiments without isolated environments the client login is replaced with the account login as found on all Windows Linux and UNIX platforms. The teachings in any other way remains the same.

The teachings regarding usage billing thus apply to all applications not just applications running within isolated environments.

In the embodiments described herein an example programming environment was disclosed for which an embodiment of programming according to the invention was taught. It should be appreciated that the present invention can be implemented by one of ordinary skill in the art using different program organizations and structures different data structures and of course any desired naming conventions without departing from the teachings herein. In addition the invention can be ported or otherwise configured for use across a wide range of operating system environments.

Although the description above contains many details these should not be construed as limiting the scope of the invention but as merely providing illustrations of some of the exemplary embodiments of this invention. Therefore it will be appreciated that the scope of the present invention fully encompasses other embodiments which may become obvious to those skilled in the art and that the scope of the present invention is accordingly to be limited by nothing other than the appended claims in which reference to an element in the singular is not intended to mean one and only one unless explicitly so stated but rather one or more. All structural and functional equivalents to the elements of the above described preferred embodiment that are known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the present claims. Moreover it is not necessary for a device or method to address each and every problem sought to be solved by the present invention for it to be encompassed by the present claims. Furthermore no element component or method step in the present disclosure is intended to be dedicated to the public regardless of whether the element component or method step is explicitly recited in the claims. No claim element herein is to be construed under the provisions of 35 U.S.C. 112 sixth paragraph unless the element is expressly recited using the phrase means for. 

