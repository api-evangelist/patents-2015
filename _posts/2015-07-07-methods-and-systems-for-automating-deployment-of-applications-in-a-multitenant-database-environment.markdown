---

title: Methods and systems for automating deployment of applications in a multi-tenant database environment
abstract: In accordance with embodiments disclosed herein, there are provided mechanisms and methods for automating deployment of applications in a multi-tenant database environment. For example, in one embodiment, mechanisms include managing a plurality of machines operating as a machine farm within a datacenter by executing an agent provisioning script at a control hub, instructing the plurality of machines to download and instantiate a lightweight agent; pushing a plurality of URL (Uniform Resource Locator) references from the control hub to the instantiated lightweight agent on each of the plurality of machines specifying one or more applications to be provisioned and one or more dependencies for each of the applications; and loading, via the lightweight agent at each of the plurality of machines, the one or more applications and the one or more dependencies for each of the one or more applications into memory of each respective machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09524185&OS=09524185&RS=09524185
owner: salesforce.com, inc.
number: 09524185
owner_city: San Francisco
owner_country: US
publication_date: 20150707
---
This divisional application is related to and claims priority to the utility application entitled METHODS AND SYSTEMS FOR AUTOMATING DEPLOYMENT OF APPLICATIONS IN A MULTI TENANT DATABASE ENVIRONMENT filed on Mar. 21 2011 having an application number of Ser. No. 13 052 897 and provisional utility application entitled METHODS AND SYSTEMS FOR AUTOMATING DEPLOYMENT OF APPLICATIONS IN A MULTI TENANT DATABASE ENVIRONMENT filed on May 18 2010 having an application number of 61 345 977 and the entire contents of which are incorporated herein by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Embodiments of the invention relate generally to the field of computing and more particularly to methods and systems for automating deployment of applications in a multi tenant database environment.

The subject matter discussed in the background section should not be assumed to be prior art merely as a result of its mention in the background section. Similarly a problem mentioned in the background section or associated with the subject matter of the background section should not be assumed to have been previously recognized in the prior art. The subject matter in the background section merely represents different approaches which in and of themselves may also correspond to disclosed embodiments.

Conventional large scale farms of machines or machine farms lack sufficient automated architecture that provides functionality to automate provisioning for use of each or any of the respective machines in the farm including remote installation and upgrading of test applications Java based applications and the like as well as general management and maintenance of machines within the farm. Further lacking in conventional mechanisms is functionality to easily run the respective applications hosted by such machines in an automated fashion without requiring human intervention.

Improved mechanisms for automating deployment of applications to multiple machines such as those operating within a machine farm or a datacenter is therefore desirable. Solutions to the above mentioned problems and other benefits of Applicants disclosed embodiments are described in additional detail below.

Described herein are systems devices and methods for automating deployment of applications in a multi tenant database environment for example automating application deployment onto respective machines within a machine farm without requiring human intervention.

In a particular embodiment such mechanisms include managing a plurality of machines operating as a machine farm within a datacenter by executing an agent provisioning script at a control hub within the datacenter instructing the plurality of machines to download and instantiate a lightweight agent pushing a plurality of URL Uniform Resource Locator references from the control hub to the instantiated lightweight agent on each of the plurality of machines specifying one or more applications to be provisioned and one or more dependencies for each of the one or more applications and loading via the lightweight agent at each of the plurality of machines the one or more applications and the one or more dependencies for each of the one or more applications into memory of each respective machine.

In the following description numerous specific details are set forth such as examples of specific systems languages components etc. in order to provide a thorough understanding of the various embodiments. It will be apparent however to one skilled in the art that these specific details need not be employed to practice the embodiments disclosed herein. In other instances well known materials or methods have not been described in detail in order to avoid unnecessarily obscuring the disclosed embodiments.

In addition to various hardware components depicted in the figures and described herein embodiments further include various operations which are described below. The operations described in accordance with such embodiments may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the operations. Alternatively the operations may be performed by a combination of hardware and software.

Embodiments also relate to an apparatus for performing the operations disclosed herein. This apparatus may be specially constructed for the required purposes or it may be a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition embodiments of are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the embodiments as described herein.

Embodiments may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosed embodiments. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. a machine e.g. computer readable transmission medium electrical optical acoustical etc.

Any of the disclosed embodiments may be used alone or together with one another in any combination. Although various embodiments may have been partially motivated by deficiencies with conventional techniques and approaches some of which are described or alluded within the specification the embodiments need not necessarily address or solve any of these deficiencies but rather may address only some of the deficiencies address none of the deficiencies or be directed toward different deficiencies and problems where are not directly discussed.

In one embodiment control hub executes an agent provisioning script e.g. via agent provisioner . Agent provisioner or an agent provisioning scrip instructs each of the plurality of machines A G to download and instantiate a lightweight agent . The lightweight agent is depicted as a deployable within the application repository . In alternative embodiments the lightweight agent resides within the control hub and is pushed to the respective machines A G directly from the control hub .

Lightweight agent is depicted as having already been downloaded to some of the machines A G including machine A machine B machine C and machine D. Machines E F and G do not yet have a lightweight agent downloaded or instantiated upon them.

Agent provisioner or an agent provisioning scrip additionally pushes a plurality of URL Uniform Resource Locator references from the control hub to the instantiated lightweight agent on each of the plurality of machines e.g. machines A D having the lightweight agent downloaded thereupon . The URLs specify one or more applications to be provisioned and one or more dependencies for each of the one or more applications .

The lightweight agent at each of the plurality of machines loads the one or more applications and the one or more dependencies for each of the one or more applications into memory of each respective machine e.g. machines A to D as shown in . Loading the one or more applications and the one or more dependencies may constitute the control hub triggering or initiating the loading of the one or more applications and the one or more dependencies for example by sending instructions or manipulating the lightweight agent via commands issued e.g. through a command shell or other interface at each of the machines responsive to which the machines download the necessary applications and dependencies based on the URLs . In an alternative embodiment once deployed each lightweight agent operates autonomously to retrieve the necessary applications and dependencies based on the URLs upon receipt of the URLs or responsive to receiving the URLs .

Within application repository two interfaces are depicted control interface and URL interface . Control interface provides a mechanism over which control hub may interact with application repository as necessary. URL interface provides a mechanism over which the machines A G in the machine farm may interact with the application repository. More particularly the machines A G upon having received URLs from the control hub may commence to download the one or more applications to be provisioned and one or more dependencies for each of the one or more applications from the application repository as specified by the control hub. For example the machines A G may communicate with the application repository via HTTP Hyper Text Transfer Protocol and or FTP File Transfer Protocol or other available protocols as specified by the one or more URLs .

In one embodiment the lightweight agent is a small program which functions similar to a bootstrap loader insomuch as it provides each respective machine A G having the lightweight agent with minimal but sufficient logic to retrieve and load more sophisticated functionality. For example in development and testing of one embodiment as described herein the deployable lightweight agent constituted less than 300 total lines of code and required nothing more than a base JDK Java Development Kit hence the lightweight description. Obviously a deployable agent to serve such a role may vary in size and sophistication but still operating in accordance with the disclosed embodiments.

In one embodiment the control hub manages a database specifying relationships between all available applications and all dependencies for the available applications . For example while multiple dependencies are provided e.g. classes objects linkable programs etc. not all dependencies are required for every application . Additionally while several different and distinct applications are available different subsets of dependencies will be required depending on which application is being loaded and utilized. These relationships and requirements are tracked by database in accordance with one embodiment.

The applications themselves may be test cases or test suites for validating code testing interfaces and the like. Some applications may constitute grid based functionality in which each machine A G operates as a node within a grid that for example computes data and reports back results for use in a master application.

For example in accordance with one embodiment the agent provisioner or agent provisioning script instructs each of the plurality of machines e.g. A B and C to download and instantiate the lightweight agent . In such an embodiment instructing the plurality of machines e.g. A B and C to download and instantiate the lightweight agent includes the agent provisioner or agent provisioning script to access a list specifying a location name for each of the plurality of machines A C to be provisioned with the lightweight agent. The list may reside locally within control hub or in alternative embodiments may reside within and be accessed from database . List may include a listing of one or more data including host names host IP addresses Internet Protocol addresses MAC addresses Media Access Control addresses passwords encryption keys zoning hardware type or hardware specification data etc. Database further includes a table structure specifying the relationships between all available applications and all dependencies for the available applications which may be utilized by the control hub in determining what applications and dependencies to provision to the machines A C e.g. by pushing URLs corresponding to the determined applications and all dependencies . The doubled headed line between agent provisioner and database depicts the interactions by which the agent provisioner retrieves information from database table structure or list as necessary.

In such an embodiment instructing the plurality of machines A C to download and instantiate the lightweight agent additionally includes for each of the plurality of machines A C specified by the list a logging in to a command shell e.g. a Command Line Interface CLI or other remotely accessible interface on the specified machine e.g. one of A B and C from the control hub b instructing by issuing commands to the command shell the specified machine e.g. one of A B and C to download the lightweight agent from the control hub and c instructing by issuing the commands to the command shell the specified machine e.g. one of A B and C to start the lightweight agent . In alternative embodiments the control hub may access the command shell and instruct each respective machine to download the lightweight agent from the application repository . The straight double headed line between agent provisioner and the command shell of machine B represents the interaction and connectivity between the two elements in fulfillment of the above communication of commands and triggering of the described events.

In one embodiment each of the plurality of machines A C pulls the lightweight agent from the control hub responsive to the agent provisioning script or the agent provisioner . In such an embodiment each of the plurality of machines A C pulls the one or more applications and the one or more dependencies for each of the one or more applications from a central application repository . Therefore in accordance with the described embodiments control hub may cause the machines A C to pull the lightweight agent or the control hub may directly push the lightweight agent to each of the machines A C e.g. via remote copy or other such mechanisms capable of pushing data and or files onto another machine .

In accordance with one embodiment the control hub and the central application repository each reside on physically separate and distinct computer servers. In accordance with one embodiment each of the plurality of machines A C in the machine farm are physically separate and distinct computer servers from the control hub and from the central application repository . In such an embodiment each of the plurality of machines A C in the machine farm are physically separate and distinct computer servers from each other. In alternative embodiments at least a portion of the machines A C are distinct computing blades within a blade server or blade machine or distinct nodes within a computing grid of nodes. In alternative embodiments at least a portion of the machines A C are distinct virtual machines co located upon a single physical computing device but are virtualized to appear as independent and physically distinct computing devices.

In one embodiment each of the physically separate and distinct computer servers e.g. machines A C and the control hub are communicatively interfaced through a high speed network e.g. of the datacenter .

In accordance with one embodiment the lightweight agent is downloaded and instantiated within memory of each of the plurality of respective machines A C. In such an embodiment execution of the lightweight agent is isolated to the memory of each of the respective machines A C. In one embodiment the one or more applications and the one or more dependencies for each of the one or more applications reside only within the memory of the respective plurality of machines. In one embodiment each of the lightweight agents the one or more applications and the one or more dependencies for each of the one or more applications do not access or reference hard disk drive storage on any of the plurality of respective machines A C having the lightweight agent downloaded and instantiated thereon. Stated differently regardless of whether any one of the respective machines A C is provisioned with a hard disk drive the lightweight agent operates memory resident and does not rely upon or make use of the hard disk drive. In accordance with other embodiments the applications and dependencies operate in the same manner. In some embodiments the machines A C are headless keyboardless and diskless but include at least a CPU and memory upon which to execute and perform instructions e.g. bare metal machines .

Further depicted within are elements and . Element represents the lightweight agent being provisioned to machine B in accordance with one embodiment. In such an embodiment the lightweight agent is pushed to machine B from control hub . Element represents the plurality of URLs which are pushed to machine B by the control hub enabling machine B via its lightweight agent to pull the appropriate applications and dependencies from the application repository. Element represents the lightweight agent pulling one or more applications from the application repository as specified by the control hub e.g. based on the plurality of URLs pushed to the machine . And element represents the lightweight agent pulling one or more application dependencies from the application repository as specified by the control hub in support of the pulled applications .

In accordance with one embodiment the control hub manages an upgrade procedure for the plurality of machines A C. In such an embodiment the upgrade procedure includes the control hub issuing a graceful interrupt to each of the plurality of machines A C in which the graceful interrupt permits each respective machine to complete currently executing work for example each of the plurality of respective machines A C will allow the one or more applications currently executing work to complete e.g. without early termination responsive to receiving a graceful interrupt. In one embodiment the upgrade procedure includes each of the plurality of respective machines to stop accepting work instructions responsive to the graceful interrupt issued by the control hub to respond to the control hub with a notification indicating the respective machine is ready to receive instructions from the control hub and to receive upgrade instructions from the control hub . In one embodiment the upgrade procedure operates asynchronously such that various operations undertaken by each of the plurality of respective machines A C will begin and end on their own schedules and time tables. For example one machine may be continuing execution of its current work while another machine receives upgrade instructions from the control hub .

In one embodiment the upgrade procedure further includes the control hub responsive to receiving the notification from each respective machine performs an unloading operation of a test class installation e.g. an application from the machine s memory via the machine s lightweight agent e.g. the control hub instructs lightweight agent to unload specified test class or other installed application . In such an embodiment the upgrade procedure further includes the control hub to perform an unloading operation of all dependencies associated with the test class installation e.g. application dependencies from the machine s memory as specified by the control hub e.g. where the operation is implemented via the machine s lightweight agent . In such an embodiment the upgrade procedure further includes the control hub to cause or instruct the machine s lightweight agent to download and install a new application from an application repository to the machine s memory as specified by the control hub and download and install via the machine s lightweight agent all dependencies for the new application from the application repository to the machine s memory as specified by the control hub . In such an embodiment the upgrade procedure further includes the control hub to start via the machine s lightweight agent the new application within the respective machine e.g. one of A C as depicted at or one of A G as depicted by .

In accordance with one embodiment the lightweight agent implements a container for managing class objects within each of the respective machines A C. In such an embodiment loading the one or more applications into the memory of the respective plurality of machines A C includes a allocating an exclusive memory space for each of the one or more applications within the memory of the respective machine e.g. one of A C b uniquely associating a dynamically generated URL class loader A and B for each of the one or more applications within the exclusive memory space allocated to the one or more applications and loading via the uniquely associated URL class loader A and B each respective application into the exclusive memory space and each of the one or more dependencies into the exclusive memory space allocated to the respective application based on the plurality of URL references pushed to the lightweight agent .

In one embodiment the container for managing class objects implemented via the lightweight agent includes a managed bean server. In one embodiment the lightweight agent is implemented as a JVM Java Virtual Machine which includes the managed bean server e.g. MBeanServer . In one embodiment the lightweight agent further includes a Java Remote Method Invocation Application Programming Interface e.g. a Java RMI or a Java based or Java compatible Application Programming Interface API that performs the object oriented equivalent of Remote Procedure Calls RPC or another Remote Method Invocation RMI mechanism. The lightweight agent may further include an RMI registry and a custom security manager. In such embodiments the lightweight agent acts as a remote agent when communicating with the control hub . The lightweight agent installed onto each of the machines A C in the server farm or machine farm exposes Transmission Control Protocol TCP ports that are used to send application control requests. The methods for application control include for example load stop start and unload. Additionally within the applications themselves additional methods may be arbitrarily defined in accordance with the disclosed embodiments. Such additional methods are available to be executed remotely once the application has been loaded into the lightweight agent s MBeanServer.

In one embodiment the MBeanServer is responsible for listening for external commands and is additionally responsible for staying alive within each of the machines A C e.g. responsible for keeping itself and the communication capabilities of the lightweight agent alive so that each machine remains responsive to remote commands without becoming a dead node requiring human interaction such as a hard reboot . In one embodiment the managed bean server provides a container for plugging in applications .

In one embodiment the managed bean server exposes standard interfaces to the control hub . For example the standard interfaces exposed may include start and interrupt. In some embodiments a graceful interrupt and a hard interrupt may be exposed or defined and selectable by the issuing entity e.g. the control hub .

In one embodiment the managed bean server additionally provides query and self discovery mechanisms which dynamically discover identify find all non standard and arbitrarily defined interfaces within provisioned applications . In such an embodiment other than implementing standard stop interrupt stop type methods custom interfaces defined by code authors are also discoverable and will be exposed by the managed bean server upon discovery without requiring further intervention. Such exposed interfaces whether standard or arbitrarily defined are thus accessible to and accessible via the control hub which may issue commands instructions and interactions to the various exposed methods to launch events tests and so forth. Such exposed methods are therefore also manipulatable via administration consoles and interfaces provided thorough the control hub as will be described in additional detail below.

In one embodiment at least a portion of the machines A C in the machine farm are provisioned with a JMX Java Management Extension based or JMX compatible lightweight agent which receives remote instructions from a control hub . In one embodiment when an application is loaded and an operation is executed remotely all processing happens within a JVM of a JMX based or JMX compatible lightweight agent .

JMX based lightweight agents may automatically pull down application code and dependency Java Archives JARs from a application repository and subsequently run each application represented within the application code and dependency JARs in a separate classloader but within the same JVM Java Virtual Machine based or JVM compatible interpreter. Such a mechanism yields complete control over the deployment and lifecycle management of deployed Java based or Java compatible applications in a large scale distributed system all from a single remote controller application accessible from for example control hub . Such an approach may simplify the role of a system administrator and thus reduce cost and complexity and the risk of human error on behalf of an Enterprise e.g. a host organization or a business Enterprises and an associated computing environment that supports the business objectives of the host organization business Enterprise through computing systems in for example a datacenter or machine farm .

In one embodiment a JMX based or JMX compatible lightweight agent loads managed applications and dependent libraries and or application dependencies from an application repository via URL mappings as set forth by one or more of the plurality of URLs pushed to the various machines A C. In such an embodiment relationships between the applications and the dependent libraries and or application dependencies are managed within a database schema accessible to control hub or via a relationships table structure as described above. The database schema and or relationships table structure may reside within control hub as an alternative to being accessible from database as described above. In one embodiment the applications themselves are packaged as JAR files and as such do not include the dependent libraries and or application dependencies because all dependencies are handled within classloaders A and B which are created dynamically within the JMX based or JMX compatible lightweight agent s MBeanServer. When dependent libraries and or application dependencies are needed by the applications they are populated in the classloader A or B assigned to the loaded application operating within an isolated memory space e.g. exclusive memory space .

Classloader isolation is supported in accordance with certain embodiments. Classloader isolation facilitates the hosting of multiple applications within a single JVM where each application is given it s own dynamically generated URL Classloader A or B. By isolating each classloader A or B dependencies between an application and it s corresponding dependent libraries and or application dependencies are strictly maintained while also creating a process space dedicated to each application within the agent s JVM. For example exclusive memory space is allocated to the one or more applications within the memory of the respective machine e.g. one of A C . In certain embodiments the machine A C and its JMX based or JMX compatible lightweight agent makes exclusive use of URL Classloaders A and B which in turn assures that there are no dependencies on any local file system or hard disk drive within the machine A C upon which the lightweight agent .

Embodiments which implement URL class loaders A and B and managed bean servers as described above additionally make applications pluggable and are able to better leverage a highspeed network available within the datacenter for downloading and provisioning applications and dependencies to the machine farm .

In accordance with one embodiment a non transitory computer readable storage medium has instructions stored thereon. In such an embodiment the instructions when executed by control hub having a processor and memory therein cause the control hub to perform operations perform a method or carry out instructions for managing a plurality of machines A C within a datacenter by implementing operations and functionality as described in accordance with the various embodiments set forth above.

For example in one embodiment instructions stored upon a non transitory computer readable storage medium causes a control hub to perform operations including instructing each of a plurality of machines A C to download and instantiate a lightweight agent e.g. either JMX based JMX compatible or non JMX based . In such an embodiment operations further include pushing a plurality of URL references from the control hub to the instantiated lightweight agent on each of the plurality of machines A C in which the plurality of URL references specify one or more applications to be provisioned and one or more dependencies for each of the one or more applications also to be provisioned in support of the applications . In such an embodiment operations further include instructing the lightweight agent at each of the plurality of machines A C to load the one or more applications and the one or more dependencies for each of the one or more applications into memory of the respective one of the plurality of machines A C.

In accordance with one embodiment a remote control Graphical User Interface GUI is implemented in which each of the plurality of deployed lightweight agents are individually graphically displayed via the GUI and individually controllable via a JMX remote control client implemented as a servlet in the control hub . In such an embodiment connections may be established to each of the plurality of deployed lightweight agents by specifying both the JMX and RMI URL s to create a connection string of the form of 

Upon establishing a connection to one of the lightweight agents two separate MBeans are created. A first for the application that is being loaded and a second for the classloader A or B that the loaded application will use e.g. be uniquely associated with and under the control of . When the application MBean is created an application specific classloader MBean is provided to a createMBean method associating the two MBeans and allowing the application to load its main and dependent libraries and or application dependencies in an isolated manner within the exclusive memory space established for the one or more applications within the memory of the respective machine e.g. one of A C .

A jconsole connection may be established with any of the one or more running lightweight agents via the GUI. JConsole is a graphical monitoring tool to monitor Java Virtual Machines JVM and java based or java compatible applications on both local and remote machines such as the remote applications executing on the machines A C which are remote from the control hub .

In one embodiment the upgrade procedure described above is implemented via an external client application which uses upgrade information inserted into the control hub to perform automatic upgrades of JMX based or JMX compatible applications executing within JMX based or JMX compatible lightweight agents . In one embodiment the external client application waits until a targeted application provisioned to one of the plurality of machines A C is marked as offline via the control hub . In such an embodiment the external client application then proceeds to destroy the classloader A and B and unload the application MBean from the JMX based or JMX compatible lightweight agent . The lightweight agents disables URLConnection caching to prevent stale classes e.g. classes embodying applications and dependencies from being used once an upgrade is performed. In embodiments that make exclusive use of URLClassloaders e.g. MLetClassloaders an upgrade or reload of an application destroys all references to the application and its associated classloader A and B. In such an embodiment the external client application then reloads the specified application and recreates the classloader A and B MBean to make the application available for execution and management e.g. makes it deployable . MLetClassloaders are a class that represents the class loader that the m let service uses to load classes and resources. The term Mlet or M let refers to a Management applet which is a utility MBean to load instantiate and register MBeans in the MBeanServer.

In one embodiment a GUI additionally provides an administration console to select the machines A C within the machine farm select the application s executing within the machine farm and or select the associated remote method s to invoke which are exposed to the control hub and made accessible and viewable via the GUI of the control hub s administration console in accordance with the above embodiments. For example such an administration console permits system administrators to perform remote operations on applications and to load unload the applications from deployed lightweight agents . The administration console again makes use of the servlet that is exposed on the control hub . Such an administration console further permits an administrator to perform operations on multiple lightweight agents deployed within the machine farm concurrently. For example an administrator may start a specific application on several different machines A C via the administration console which permits the administrator to select the machines A C select the application s and select the associated remote method s to invoke in accordance with the disclosed embodiments.

In one embodiment system includes a memory and a processor or processors . For example memory may store instructions to be executed and processor s may execute such instructions. System includes bus to transfer transactions and data within system such as transactions between hardware based control hub and database or the data store . System further includes database which may store a relationship table structure specifying the relationships between available applications and dependencies available from an application repository and which control hub may provision to remote machines e.g. A C as set forth in . Database may additionally store a list of remote machines and location information for such machines e.g. host names IP addresses etc. . Alternatively such a list may be stored within data store e.g. list .

System includes data store to store data and information. Data store stores a copy of deployable lightweight agent in accordance with one embodiment.

Distinct within system is hardware based control hub which includes Remote Method Invocation RMI Agent Agent Provisioner and Machine List Manager . In accordance with one embodiment Remote Method Invocation RMI Agent enables hardware based control hub to remotely communicate with remotely trigger remotely initiate and remotely instruct lightweight agents deployed within machines in a machine farm to perform actions and events as specified by the hardware based control hub . In such an embodiment Agent Provisioner deploys the deployable lightweight agent to machines within a machine farm and Machine List Manager provides a listing of the machines within the machine farm upon which the deployable lightweight agent may be deployed and controlled and a location location name IP address or other appropriate information for the machines in the machine farm so that the deployable lightweight agent may be deployed by the hardware based control hub .

Method of begins with processing logic executing an agent provisioning script at a control hub block . At block processing logic in a control hub accesses a list specifying a location name for each of a plurality of machines to be provisioned with a lightweight agent.

At block processing logic in a control hub logs into a command shell on each specified machine from the control hub. The control hub may continue to execute instructions or deploy a provisioning script which when executed on a target machine performs operations specified by the control hub. At block processing logic instructs via commands to a remote command shell each specified machine to download the lightweight agent from the control hub. Alternatively the control hub may deploy and execute the provisioning script thus causing the target machine to pull or download the lightweight agent from the network e.g. .

At block processing logic instructs via commands to the remote command shell each specified machine to start the lightweight agent previously downloaded. Alternatively the provisioning script may instantiate the lightweight agent subsequent to its pull or download operations.

At block processing logic on the control hub pushes a plurality of URL Uniform Resource Locator references from the control hub to the instantiated lightweight agent on each of the plurality of machines specifying applications and dependencies to be provisioned.

At block processing logic on the control hub instructs each of the plurality of machines to load via the lightweight agent applications and dependencies into a memory of each respective machine.

At block processing logic on the control hub instantiates triggers initiates an upgrade procedure for the plurality of machines or a portion thereof. At block processing logic on the control hub issues a graceful interrupt to each of the plurality of machines in furtherance of the upgrade procedure or to the portion of machines for which the upgrade procedure is instantiated triggered initiated. At block processing logic on the control hub waits for and receives a notification from each of the plurality of machines indicating the respective machine is ready to receive instructions from the control hub. The notifications from the respective machines are received asynchronously as each respective machine reaches a state at which it issues such notifications.

At block processing logic on the control hub issues upgrade instructions to each of the plurality of machines in an asynchronous manner responsive to each of the received notifications including unloading installed applications and dependencies downloading and installing new applications and dependencies and starting the new application s .

Method of begins with processing logic executing one of any of a plurality of machines within a machine farm where the processing logic pulls a lightweight agent from a control hub responsive to remote instructions from the control hub. Alternatively the machine receives a provisioning script from the control hub executes the provisioning script and pulls the lightweight agent from the control hub based on instructions within the provisioning script block .

At block processing logic in the machine receives a plurality of URL references specifying applications and dependencies to be downloaded. At block processing logic in the machine downloads the applications and dependencies via the URL references.

At block processing logic in the machine uniquely associates a dynamically generated URL class loader with each application. At block processing logic in the machine loads via the uniquely associated URL class loader each respective application and its dependencies into the exclusive memory space allocated to the applications.

At block processing logic in the machine responds to an upgrade procedure initiated by the control hub by first receiving a graceful interrupt from the control hub. At block processing logic in the machine allows currently executing work of the loaded application s to complete in view of the graceful interrupt e.g. the interrupt is not a hard interrupt demanding immediate termination . At block processing logic in the machine stops accepting work instructions responsive to the graceful interrupt.

At block processing logic in the machine responds to the control hub with a notification when the machine is ready to receive further instructions from the control hub e.g. indicating to the control hub that it is now ready to proceed with further instructions other instructions or the upgrade procedure initiated by the control hub . The actual notification sent may be only a ready notice or a message indicating the machine is at a state capable of receiving further instruction.

At block processing logic in the machine receives upgrade instructions from the control hub including instructions to unload all test classes and applications and associated dependencies to download and install a new application and dependencies and to start the new application e.g. by either instructing the lightweight agent to start the new application or by restarting the lightweight agent thus causing it to restart its known applications upon startup .

Method of begins with processing logic exposing from a machine in a machine farm one or more standard methods including at least start stop and interrupt block .

At block processing logic searches within the machine in the machine farm one or more applications and dependencies loaded at the machine for arbitrarily defined non standard methods associated with the one or more applications and dependencies and at block processing logic exposes from the machine in the machine farm the arbitrarily defined non standard methods discovered by the search.

At block processing logic at an administration console of a control hub lists a plurality of machines in the machine farm. For example the administration console may list all active a zone a subset or a specified type or class of machines etc.

At block processing logic lists at the administration console all invokable methods for each machine listed by the administration console including both standard methods exposed by each respective machine and arbitrarily defined non standard methods exposed by each respective machine.

At block processing logic at the administration console of the control hub receives a selection specifying one or more standard and or non standard methods to invoke at one or machines listed in the machine farm.

At block processing logic at the control hub generates one Remote Method Invocation RMI connection string for every specified standard and or non standard method to invoke at each specified machine upon which the specified standard and or non standard method is to be invoked. For example if two machines are selected via the administration console and two invokable methods are selected at each four RMI strings would be generated in accordance with such an embodiment.

At block processing logic at the control hub issues the generated RMI connection strings for example invoking them via a network connecting the control hub with the machines in the machine farm.

At block processing logic at each machine in the machine farm identified by at least one RMI connection string receives instructions to invoke one or more standard and or non standard methods and at block processing logic at each respective machine identified by at least one RMI connection string issued from the control hub invokes the one or more standard and or non standard methods in accordance with the instructions received by the corresponding machine.

The exemplary computer system includes a processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. static memory such as flash memory static random access memory SRAM volatile but high data rate RAM etc. and a secondary memory e.g. a persistent storage device including hard disk drives and a persistent database and or a multi tenant database implementation which communicate with each other via a bus . Main memory includes a list of machines e.g. names and location information for machines in a machine farm and a deployable lightweight agent which is pushed to communicatively interfaced machines in a machine farm. Main memory and its sub elements e.g. and are operable in conjunction with processing logic and processor to perform the methodologies discussed herein.

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processor is configured to execute the processing logic for performing the operations and functionality which is discussed herein.

The computer system may further include a network interface card . The computer system also may include a user interface such as a video display unit a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. an integrated speaker . The computer system may further include peripheral device e.g. wireless or wired communication devices memory devices storage devices audio processing devices video processing devices etc. . The computer system may further include a Hardware based control hub to manage a plurality of machines operating as a machine farm within a datacenter in accordance with the described embodiments.

The secondary memory may include a non transitory machine readable or computer readable storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable storage media. The software may further be transmitted or received over a network via the network interface card .

While the subject matter disclosed herein has been described by way of example and in terms of the specific embodiments it is to be understood that the claimed embodiments are not limited to the explicitly enumerated embodiments disclosed. To the contrary the disclosure is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosed subject matter is therefore to be determined in reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

