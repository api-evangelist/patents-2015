---

title: Systems and methods for processing software application metadata associated with a software application
abstract: Systems and methods for processing software application metadata associated with a software application are provided. A representative method includes the step of collecting software application metadata associated with a software application. The software application metadata includes a first set of information related at least one of the following: screens, paths, and layers associated with the software application. The method further includes the step of storing the software application metadata in a data repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514033&OS=09514033&RS=09514033
owner: 
number: 09514033
owner_city: 
owner_country: 
publication_date: 20150405
---
This application is a continuation of U.S. utility application entitled SYSTEMS AND METHODS FOR PROCESSING SOFTWARE APPLICATION METADATA ASSOCIATED WITH A SOFTWARE APPLICATION having Ser. No. 13 603 374 filed on Sep. 4 2012 which claims the benefit of U.S. provisional application entitled APPLICATION MAP having Ser. No. 61 530 401 filed on Sep. 2 2011 all of which are entirely incorporated herein by reference.

The present disclosure is generally related to computer software and more particularly is related to systems and methods for processing software application metadata associated with a software application.

Computer and web based software applications are becoming larger in size and more complex mainly because they can perform more functionality than their predecessors. This can result in an increase in defects that occur in the software applications. Test and quality software applications are available to aide software developers in identifying areas within software applications that have the highest rate of software defects.

Desirable in the art is a test and quality software application that would improve upon the test and quality software application.

Systems and methods for processing software application metadata associated with a software application are provided. A representative method includes the step of collecting software application metadata associated with a software application. The software application metadata includes a first set of information related at least one of the following screens paths and layers associated with the software application. The method further includes the step of storing the software application metadata in a data repository.

Another representative method includes the step of creating and mapping areas on an application map based on software application metadata collected from a software application. The software application metadata includes a first set of information related at least to one of the following screens paths and layers associated with the software application. The method further includes the steps of associating unique identifiers with the respective areas on the application map and overlaying a second set of information of the software application metadata on top of the areas on the application map using the unique identifiers respectively. The second set of information is related to various attributes of the software application.

A representative system includes a processing device and a data repository that stores an application map manager having instructions that are executed by the processing device. The application map manager includes a map builder that performs the following steps collecting software application metadata associated with the software application wherein the software application metadata includes a first set of information related at least one of the following screens paths and layers associated with the software application and storing the software application metadata in the data repository.

A representative application map displays a map like visualization of a software application and aides software developers in navigating and analyzing the various software components of the software application. The application map includes areas on the application map that include screens area layers that group at least one area on the application map paths that link the areas on the application map to another area to show progression of the software application from one area to another and data layers that show information that are related to quality assurance of the features functionalities and attributes of the software application.

Other systems devices methods features of the invention will be or will become apparent to one skilled in the art upon examination of the following figures and detailed description. It is intended that all such systems devices methods features be included within the scope of the invention and be protected by the accompanying claims.

Exemplary systems are first discussed with reference to the figures. Although these systems are described in detail they are provided for purposes of illustration only and various modifications are feasible. After the exemplary systems are described examples of flow diagrams of the systems are provided to explain the manner in which software application metadata associated with a software application is processed and an application map is provided.

In general application map is a technology that enables a map like visualization of a software application. It also provides tracking modules that obtain quality related information from the analysis of the software applications. The quality related information is generally data that are related to quality assurance of the features attributes and functionalities of the software applications. The quality related information can be overlaid on top of the map like visualization of screens associated with quality assurance of the software applications. The application map can be applied to a variety of software applications including but not limited to desktop and web applications. This technology assists stakeholders to easily understand various quality aspects of different parts attributes features functionalities of the software applications at many levels of granularity. The application map can complement existing reporting and dashboard methods for presenting project quality information to stakeholders.

The map builder captures software application metadata at line from a software application at a computing device or a web based software application that is under testing. The map builder uploads information associated with an application map to a map cloud at line . The map builder is further described in connection to .

The defect capture tool and the test composer can also capture and process software application metadata associated with the software application at line for defects and information associated with test cases scripts. The defect capture tool and the test composer upload the detected defects at line and the information associated with test cases scripts at line respectively to the map cloud .

The defect capture tool can associate screen unique identifier with defect information before uploading a defect to the map cloud or a defect tracker . The test composer can allow users to generate test cases and or test scripts automatically and upload those test cases and scripts to the map cloud . Users can execute a test scenario on the software application under test and have the tools generate execution steps in various formats such as text and programming scripts. The test composer can also allow users to gather unique identifiers of screens and sequence of steps covered by each test case script during the test execution. When each test case script is uploaded associated screens can also be uploaded as metadata to either the map cloud or a test manager .

The map cloud is the centralized cloud based web application providing a user interface for application map users and an application programming interface for other components of the application map manager . The map cloud enables collaboration among users and serves as the integration point for other components of the application map manager . The map cloud launches a map visualizer at line which retrieves the uploaded software application metadata from the map cloud for generating the application map . The map visualizer is further described in connection to .

A defect tracker retrieves the software application metadata associated with the detected defects from either the defect capture tool or the map visualizer at lines respectively. The defect tracker can track the number of defects severity of defects defects category and assigned developers associated with the defects based on the collected software application metadata that is related to the defects. Although the defect tracker is shown to be at the application map server or in the cloud one skilled in the art would appreciate that all defect tracker can located at the workstation A in the customer premise A.

A test manager retrieves the software application metadata associated with the information associated with the test cases script from either the test composer or the map visualizer at lines respectively. The test manager can be a 3 party test management system.

At block the map visualizer of the application map manager creates and maps areas on an application map based on software application metadata collected from the software application . At block the application map manager associates unique identifiers with the respective areas on the application map .

And at block the map visualizer overlays a second set of information of the software application metadata on top of the areas on the application map using the unique identifiers respectively. The second set of information of the software application metadata is related to various attributes of the software application such as quality related or defect information application features application field level constraints data entered into the application frequency of access and entry into screens paths layers and fields and version of the software application. The map visualizer can allow project stakeholders to understand the user interface flow of their software application test coverage and defect information.

Additionally or alternatively the map builder can collect the software application metadata related to defects occurred during a test execution of the software application A to overlay the defect information on top of the application map . Additionally or alternatively the map builder can track the number of defects severity of defects defects category and assigned developers associated with the defects based on the collected software application metadata that is related to the defects.

Additionally or alternatively the map builder can collect software application metadata by combining static analysis of the source and or binary and dynamic execution of the software application. Additionally or alternatively the map builder can index the software application metadata such that the software application metadata is able to be searched and combined with a second set of information that are related to various attributes of the software application.

Additionally or alternatively the map builder can collect the software application metadata by automatically capturing whole or part of all screens and paths in the software application by way of the instructions that are executed by the processing device e.g. automated crawler and by the users manually capturing whole or part of all screens and paths in the software application by using the software application as the collecting is performed in the background and by the users manually combining screens and paths captured with screens and paths captured automatically to populate the data repository of application screens paths and layers.

At block the process of collecting software application metadata is completed and the map builder is halted. At block the map builder determines whether to store the software application metadata and or the metadata file in a data repository . If yes the map builder at block stores the collected software application metadata and or the metadata file associated with software application A at a local data repository not shown . At block the map builder determines whether to upload the collected software application metadata and or the metadata file to a map cloud . If yes the map builder at block uploads the collected software application metadata and or the metadata file to a map cloud . If no is determined at blocks and the map builder at block can discard the collected software application metadata and or the metadata file.

At block the map visualizer provides an application map of the software application A based on the software application metadata and a user interface controls for users to modify and manipulate the application map . At block the user can interact with the map visualizer controls and can chose to overlay a second set of information of the software application metadata that is collected from the map builder defect capture tool or test composer at block .

The map visualizer can overlay the second set of information of the software application metadata on top of the areas on the application map by for example creating data layers that enable a user to zoom into and out of the application map to access the various attributes of the software application A. A top zoom out position can be displayed to show the root screen s where the user can choose to zoom into a particular screen to see its children screens at a next area layer .

The map visualizer at block can display the application map including the overlaid software application metadata. At block the user exits the map visualizer . At block the map visualizer can monitor for new updated software application metadata associated with the software application A. At block the map visualizer can determine whether the new updated software application metadata is in fact associated with the software application A. If no the map visualizer repeats the functionality at block . If yes the map visualizer at block updates the current application map associated with the software application A with the new updated software application metadata. The map visualizer can update the current application map with updated metadata file associated with the software application A at block . The map visualizer can automatically update the software application metadata collected in real time. The map visualizer repeats blocks and .

Area layers group at least one area on the application map . For example area layer groups area area layer groups areas area layer groups areas area layer groups areas and area layer groups areas . Paths link the areas on the application map to another area to show progression of the software application from one area to another. For example path links areas path links areas path links areas path links areas path links areas path links areas path links areas path links areas path links areas path links areas path links areas and path links areas .

Data layers show information that are related to quality assurance of the features functionalities and attributes of the software application. In this example defect counts are associated with screens C E F J and the screen with a high defect number screen C in this case can be highlighted. Such information allows users to make better decisions to improve the software quality. The data layers are further described in connection to .

As a specific example if the software application to be analyzed is Microsoft Word then screen A may represent its Home screen not shown screen B its Insert screen not shown which is accessible from the Home screen and screen F its SmartArt dialog not shown which is accessible from the Insert screen.

Depending on the application s unique characteristics and attributes such as business logic use of Ajax technology UI frameworks and elements etc. the map builder can automatically capture whole or part of all screens and paths in Microsoft Word . For example certain navigation path is enabled when specific data is entered or specific user accesses the screen. In addition the map builder can capture screens of applications developed using a certain UI framework or with custom UI elements. In such scenarios end users can manually drive the capturing process by executing Microsoft Word while having the map builder running in the background. When this method is used the map builder also generates screen unique identifications captures screenshot not shown 0 and determines the area layer for each screen.

The map builder can combine screens and paths captured via this manual execution to those captured automatically to populate the data repository of application screens paths and layers. When there are changes to the system users can trigger any of these processes to update the package with new deleted or modified screens and paths. The application map can be updated automatically as the software application metadata is collected in real time.

The map builder can automatically capture information by combining static analysis of application s source and or binary and dynamic execution of the application including output HTML analysis in the case of web applications. Between every two screens the map builder can maintain one 1 or more paths such as path from screens A to B and another path from screen B to A regardless of the actual number of ways to navigate between A and B which could be numerous especially in the context of web applications. As the map builder captures each screen the map builder can also assign a screen unique identification a screenshot and an area layer . The root screen can be placed at area layer and its immediate children i.e. those screens accessible from the root screen having area layer and so on. If a screen is located at multiple area layers such as in the case where there are multiple paths to it from different screens the shallowest area layer is assigned to that screen.

The map visualizer can presents screens A B C D E F G H I J K L paths and area layers in a map like user interface. The map visualizer allows users to zoom out and in of the application map such as that shown in . The top zoom out position shows the root screen s where users can choose to zoom into a particular screen to see its children screens at the next data layer . As zooming occurs the map visualizer can re arrange screens and paths properly to best visualize them at the current area layer . The map visualizer can allow users to search filter screens re organize layers of screens and change paths among screens. The map visualizer can visually reflect modification in real time as users make changes. In addition the map visualizer can allow users to view at least some or all screens and paths at any layer.

Besides displaying screens and paths the map visualizer overlays on top of the application map various quality related information that include but are not limited to test coverage information and defect information. Such information can be captured by the test composer and the defect capturing tool .

The map visualizer overlays a second set of information of the software application metadata on or on top of area of the application map using the unique identifier . The second set of information of the software application metadata is related to various attributes of the software application.

The overlaying of the second set of information of the software application metadata on or on top of area of the application map can be achieved by creating data layers that enable a user to zoom into and out of the application map to access the various attributes of the software application. Data layer displays the defect count associated with screen C having a unique identifier .

A user can also access more information through data layers which can be displayed on a graphical user interface GUI and show the second set of information of the software application metadata which includes at least one of the following quality related or defect information application features application field level constraints data entered into the application frequency of access and entry into screens paths layers and fields and version of the software application .

Attributes can be displayed on a graphical user interface GUI and shows the details of the attributes of the selected data layer from data layers . If defects were selected at data layer attributes can display information related to defect distribution defect category distribution and tester distribution. Examples of other attributes include but are not limited to displaying time lapsed defect state changing activities over a period of time based on the software application metadata displaying highlighted screens that were covered by test cases enabling users to assess the current coverage ratio of at least one test suite listing the screens from highest to lowest priority based on the results of test cases and displaying defects trend over time based on number of defects severity of defects defects category and assigned developers associated with the defects.

The one or more user interface devices comprise those components with which the user e.g. administrator can interact with the generic computer . Where the generic computer comprises a server computer or similar device these components can comprise those typically used in conjunction with a PC such as a keyboard and mouse.

The one or more I O devices comprise components used to facilitate connection of the generic computer to other devices and therefore for instance comprise one or more serial parallel small system interface SCSI universal serial bus USB or IEEE 1394 e.g. Firewire connection elements. The networking devices comprise the various components used to transmit and or receive data over networks where provided. By way of example the networking devices include a device that can communicate both inputs and outputs for instance a modulator demodulator e.g. modem a radio frequency RF or infrared IR transceiver a telephonic interface a bridge a router as well as a network card etc.

The data repository normally comprises various programs in software and or firmware including an operating system O S and the application map manager which has been described above. The O S controls the execution of programs and provides scheduling input output control file and data management memory management and communication control and related services.

The systems and methods disclosed herein can be implemented in software hardware or a combination thereof. In some embodiments the system and or method is implemented in software that is stored in a memory and that is executed by a suitable microprocessor P situated in a computing device. However the systems and methods can be embodied in any computer readable medium for use by or in connection with an instruction execution system apparatus or device. Such instruction execution systems include any computer based system processor containing system or other system that can fetch and execute the instructions from the instruction execution system. In the context of this disclosure a computer readable medium can be any means that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system. The computer readable medium can be for example but not limited to a system or propagation medium that is based on electronic magnetic optical electromagnetic infrared or semiconductor technology.

Specific examples of a computer readable medium using electronic technology would include but are not limited to the following an electrical connection electronic having one or more wires a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory . A specific example using magnetic technology includes but is not limited to a portable computer diskette. Specific examples using optical technology include but are not limited to optical fiber and compact disc read only memory CD ROM .

Note that the computer readable medium could even be paper or another suitable medium on which the program is printed. Using such a medium the program can be electronically captured using for instance optical scanning of the paper or other medium compiled interpreted or otherwise processed in a suitable manner and then stored in a computer memory. In addition the scope of the certain embodiments of the present disclosure includes embodying the functionality of the preferred embodiments of the present disclosure in logic embodied in hardware or software configured mediums.

It should be noted that any process descriptions or blocks in flowcharts should be understood as representing modules segments or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process. As would be understood by those of ordinary skill in the art of the software development alternate embodiments are also included within the scope of the disclosure. In these alternate embodiments functions may be executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved.

This description has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the disclosure to the precise forms disclosed. Obvious modifications or variations are possible in light of the above teachings. The embodiments discussed however were chosen to illustrate the principles of the disclosure and its practical application. The disclosure is thus intended to enable one of ordinary skill in the art to use the disclosure in various embodiments and with various modifications as are suited to the particular use contemplated. All such modifications and variation are within the scope of this disclosure as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly and legally entitled.

