---

title: Protecting operating system configuration values using a policy identifying operating system configuration settings
abstract: In a pre-operating system environment on a device prior to loading and running an operating system on the device, a policy identifying configuration settings for the operating system is obtained. The operating system itself is prevented from changing this policy, but the policy can be changed under certain circumstances by components of the pre-operating system environment. The policy is compared to configuration values used by the operating system, and the operating system is allowed to boot with the configuration values if the configuration values satisfy the policy. However, if the configuration values do not satisfy the policy, then a responsive action is taken.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424431&OS=09424431&RS=09424431
owner: Microsoft Technology Licensing, LLC
number: 09424431
owner_city: Redmond
owner_country: US
publication_date: 20150914
---
This application is a continuation of U.S. patent application Ser. No. 13 037 962 filed Mar. 1 2011 entitled Protecting Operating System Configuration Values Using A Policy Identifying Operating System Configuration Settings the entire disclosure of which is hereby incorporated by reference herein in its entirety.

Computers have become increasingly interconnected via various networks such as the Internet. While such connectivity allows users to access a variety of different services and data such connectivity is not without its problems. One such problem is that such connectivity can allow malicious programs to be run on these computers. These malicious programs can perform a variety of undesirable actions such as launching attacks against other computers sending private data to other users computers preventing a user from being able to use his or her computer and so forth. It remains difficult to protect computers against such malicious programs.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects in a pre operating system environment on a device prior to loading and running an operating system on the device a policy identifying configuration settings for at least one operating system is obtained. The operating system is prevented from changing this policy. This policy is compared to configuration values used by the operating system and the operating system is allowed to boot with the configuration values if the configuration values satisfy the policy. However if the configuration values do not satisfy the policy then a responsive action is taken.

In accordance with one or more aspects a change to a policy identifying configuration settings that are to be satisfied by configuration values of the operating system in order for the operating system to be executed on the device is received. The operating system itself is prevented from changing this policy. A check is made as to whether the change to the policy is approved by an entity trusted by a pre operating system environment and the policy is changed only if the change to the policy is approved by the pre operating system environment.

Protecting operating system configuration values is discussed herein. During a process of booting a device a set of configuration values used by at least part of one or more operating systems of the device and optionally including one or more configuration values used by components of a pre operating system environment of the device is checked against a policy for the device. If the configuration values satisfy the policy then the operating system is permitted to run on the device but if the configuration values do not satisfy the policy then one or more appropriate actions are taken e.g. not running the operating system changing the values etc. . The policy is stored in a manner protecting against unauthorized modification by the operating system and other applications running on the computing device. However one or more policy issuers can update the policy allowing the policy to change over time.

References are made herein to symmetric key cryptography public key cryptography and public private key pairs. Although such key cryptography is well known to those skilled in the art a brief overview of such cryptography is included here to assist the reader. In public key cryptography an entity such as a user hardware or software component a device a domain and so forth has associated with it a public private key pair. The public key can be made publicly available but the entity keeps the private key a secret. Without the private key it is computationally very difficult to decrypt data that is encrypted using the public key. So data can be encrypted by any entity with the public key and only decrypted by an entity with the corresponding private key. Additionally a digital signature for data can be generated by using the data and the private key. Without the private key it is computationally very difficult to create a signature that can be verified using the public key. Any entity with the public key can use the public key to verify the digital signature by executing a suitable digital signature verification algorithm on the public key the signature and the data that was signed.

In symmetric key cryptography on the other hand a shared key also referred to as a symmetric key is known by and kept secret by the two entities. Any entity having the shared key is typically able to decrypt data encrypted with that shared key. Without the shared key it is computationally very difficult to decrypt data that is encrypted with the shared key. So if two entities both know the shared key each can encrypt data that can be decrypted by the other but other entities cannot decrypt the data if the other entities do not know the shared key. Similarly an entity with a shared key can encrypt data that can be decrypted by that same entity but other entities cannot decrypt the data if the other entities do not know the shared key. Additionally digital signatures can be generated based on symmetric key cryptography such as using a keyed hash message authentication code mechanism. Any entity with the shared key can generate and verify the digital signature. For example a trusted third party can generate a symmetric key based on an identity of a particular entity and then can both generate and verify digital signatures for that particular entity e.g. by encrypting or decrypting the data using the symmetric key .

When device is powered on or otherwise reset device boots. Booting of device refers to the beginning operation of device typically loading and executing an operating system of device . The booting of device typically includes at least two stages. In the first stage components of a pre operating system environment are loaded and run on device . In the pre operating system environment various components or modules run performing various operations including booting the operating system. In the second stage components of the operating system environment are loaded and run on device . In the operating system environment the operating system is running on device. .

Loading of a component refers to copying the component into a volatile or alternatively nonvolatile memory and optionally performing additional configurations to other components or data stores. Executing a component refers to the running of execution of the instructions of the component by a processor or controller of device . After device is booted various other programs can be run on device by the operating system.

Device can be a variety of different types of physical devices. For example device can be a desktop computer a laptop or netbook computer a notepad or tablet computer a mobile station an entertainment appliance a set top box communicatively coupled to a display device a television a cellular or other wireless phone a game console an automotive computer and so forth. Device can also be a virtual device such as a virtual machine running on a physical device. A virtual machine can be run on any of a variety of different types of physical devices.

During the boot process firmware is loaded and executed by device . Firmware is stored in a nonvolatile memory of device . Firmware can be stored in a read only memory or alternatively in writeable nonvolatile memory such as Flash memory . In embodiments in which firmware is stored in writeable nonvolatile memory care is typically taken to ensure that such firmware is not tampered with and thus not altered by a malicious program . Such care can be taken for example by verifying a signature on the firmware stored in writeable nonvolatile memory storing firmware in protected memory that is accessible only to firmware using a variety of conventional trusted boot or secure boot techniques and so forth.

Firmware initiates execution of operating system loader . Operating system loader is typically loaded and verified by firmware before being executed. Operating system loader can be verified in different manners such as by verifying a digital signature generated by an entity that firmware is configured e.g. programmed to trust of operating system loader .

Operating system loader loads and executes operating system kernel . Operating system kernel is typically loaded and verified by operating system loader before being executed. Operating system kernel can be verified in different manners such as by verifying a digital signature generated by an entity that operating system loader is configured e.g. programmed to trust of operating system kernel . Operating system kernel can then proceed to load and execute a variety of different operating system components and or user mode components. These operating system components and user mode components can be executed in response to a user request to execute such a component or in response to a request from another component or module.

Operating system kernel obtains and operates in accordance with various operating system configuration values . Although illustrated as being accessed by operating system kernel operating system configuration values can also be accessed by operating system loader and or other components or modules of device . Operating system configuration values can be any of a variety of different information that is used to determine how operating system kernel and or operating system loader is to operate what components of operating system kernel and or operating system loader are to be loaded and executed combinations thereof and so forth. For example operating system configuration values can be an indication of whether operating system kernel and or operating system loader is to permit untrusted programs or components to execute on device or whether operating system kernel and or operating system loader is to authenticate programs or components before running on device . By way of another example operating system configuration values can be an indication of whether an anti malware application or a particular anti malware application is to be run on device . By way of another example operating system configuration values can be an indication of configuration values or settings to be used for a virtual machine manager that manages virtual machines running on device . By way of yet another example operating system configuration values can be an indication of particular processor or processor core settings to be used e.g. areas of memory that are to be marked as non executable .

In one or more embodiments firmware and operating system loader are implemented as part of a pre execution environment also referred to as a preboot environment or pre operating system environment which refers to an environment running on device before the operating system has finished booting and is running. In such embodiments firmware and operating system loader can be stored on a component of device e.g. in read only memory ROM or flash memory such as on a network interface card of device . Alternatively firmware and operating system loader can be obtained from another device or service during the pre execution environment. For example firmware and operating system loader can be included as part of a boot image provided to the device from another device or service.

The pre execution environment can be implemented in a variety of different manners and can be based on a variety of different conventional techniques. For example the pre execution environment can be implemented in accordance with the Preboot eXecution Environment PXE standard version 2.0 or other versions. By way of another example the pre execution environment can be implemented in accordance with the Unified Extensible Firmware Interface UEFI standard version 2.3 or other versions. By way of yet another example the pre execution environment can be implemented using a variety of different personal computer basic input output system BIOS versions.

During the boot process operating system loader obtains policy record which is a record of one or more policies to which device is to conform. This record of policies includes configuration settings or values that operating system configuration values are to satisfy. Operating system loader compares the one or more policies in policy record to operating system configuration values and proceeds with initiating execution of operating system kernel components if operating system configuration values satisfy the one or more policies in policy record . However if one or more operating system configuration values do not satisfy a policy in policy record then an appropriate responsive action is taken. A variety of different responsive actions can be taken such as not loading operating system kernel changing an operating system configuration value and so forth. These responsive actions are discussed in more detail below. Operating system loader thus protects operating system configuration values identifying situations in which operating system configuration values may have been changed by a malicious program.

In one or more embodiments the one or more policies in policy record also include configuration settings or values that one or more components of a pre operating system environment of the device are to satisfy. These configuration settings or values to be satisfied by the pre operating system environment can be any of a variety of different indications of how the pre operating system environment is to operate what components of the pre operating system environment are to be loaded and executed combinations thereof and so forth. These configuration settings or values can be included as part of operating system configuration values or alternatively can be other settings or values. For example these configuration settings or values can specify that only a particular operating system is to be loaded and executed.

Although a single operating system kernel is illustrated in it should be noted that alternatively multiple different operating system kernels can be loaded and executed on device . Each of these different operating system kernels can have its own operating system configuration values and its own policy record or its own policies within policy record and operating system loader compares the appropriate one or more policies to the appropriate operating system configuration values for the operating system kernel being booted. Alternatively two or more of these different operating system kernels can share at least part of operating system configuration values and or policy record and or policies within policy record .

Policy identifier identifies policy allowing different policies to be distinguished from one another. Policy identifier can be for example a globally unique ID GUID assigned to policy . Policy ancestor list is a list of zero or more other policies which policy replaces. Policy ancestor list facilitates preventing certain types of attacks as discussed in more detail below.

Configuration values and or settings include the values that the operating system configuration values e.g. values of are to satisfy. Configuration values and or settings can also include the responsive action to take if one or more of the configuration values in policy are not satisfied by the operating system configuration values. One or more of the configuration values and or settings can optionally be set by an operating system loader component as discussed in more detail below.

Configuration values and or settings can also include references to identifiers of one or more other policies. The configuration values and or setting in these one or more other policies are included as part of policy . Thus a policy can effectively incorporate or include one or more other policies. Configuration values and or settings can also include identifiers of one or more trusted policy issuers. Thus a new policy issuer that is allowed to add policies to the policy record e.g. policy record of can be identified in policy .

Returning to operating system loader checks whether operating system configuration values satisfy the one or more policies in policy record . Policy record can include a single policy which can be changed by one or more different policy issuers as discussed in more detail below. Alternatively policy record can include multiple policies each of which can be changed by one or more policy issuers. Accordingly different policy issuers can for example provide different policies that they can subsequently change for inclusion in policy record .

The configuration values can be identified in the policies in a variety of different manners. In one or more embodiments policies identify values in name value pairs including a name or other identifier of an operating system configuration value and one or more values that that operating system configuration value is to have in order to satisfy the policy. In other embodiments values are included in a policy in an ordering or other structure in which the corresponding operating system configuration values are inherent.

The determination of whether operating system configuration values satisfy the one or more policies in policy record can be performed in different manners. In one or more embodiments a mathematical operator is used to determine whether an operating system configuration value satisfies a policy. A variety of different mathematical operators can be used such as equals greater than less than and so forth. In other embodiments other operators or logical formulas are used to determine whether an operating system configuration value satisfies a policy such as whether the operating system configuration value is included as one of a set of values in the policy.

In situations in which multiple policies are included in policy record the determination of whether operating system configuration values satisfy the policies in policy record is a determination of whether operating system configuration values satisfy each of the multiple polices in policy record . Thus the multiple policies can be viewed as being combined for purposes of determining whether operating system configuration values satisfy the policies in policy record .

If operating system configuration values satisfy policy record then operating system loader proceeds with initiating execution of operating system kernel . However if one or more operating system configuration values do not satisfy policy record then an appropriate action in response to the one or more operating system configuration values not satisfying policy record is taken. Different responsive actions can be taken for different operating system configuration values or the same responsive action can be taken for multiple operating system configuration values. These responsive actions can include actions that stop the boot process so that the operating system is not loaded and run on device as well as actions that allow the boot process to continue so that the operating system is loaded and run on device .

In one or more embodiments the responsive action to be taken is included in policy record . Each policy in policy record can include an indication e.g. as part of configuration values settings of of the responsive action to be taken if at least part of the policy is not satisfied e.g. a particular operating system configuration value does not satisfy the policy . In other embodiments the responsive action to be taken is included in e.g. programmed in or set as a configuration value or otherwise obtained by operating system loader .

The responsive action can be to stop the boot process operating system loader does not initiate execution of operating system kernel so the operating system is not loaded and run on device . The responsive action can alternatively be to ignore the operating system configuration value that does not satisfy the policy and use another value e.g. included in the policy instead. The responsive action can alternatively be to overwrite the operating system configuration value with the value from or otherwise identified by the policy and allow the boot process to continue. The responsive action can alternatively be to use the operating system configuration value and allow the boot process to continue but report an event such as record or send e.g. to another component device or service a notification that the operating system configuration value did not satisfy the policy an indication of the particular operating system configuration value and or policy can be included in the notification .

The responsive action can alternatively be to prompt a user of device e.g. to receive user approval to proceed with the boot process . This prompting can include for example a prompt requesting the user to approve of a current operating system configuration value. This prompting can also include an indication of what the configuration value should be in order to satisfy the policy. The user can then provide a variety of different inputs to approve or disapprove proceeding with the current operating system configuration value such as pressing a button or key touching a particular portion of a screen providing an audible input providing a security token that is trusted or can be verified by operating system loader and so forth. Operating system loader takes care to verify that the input is received from a user of device e.g. received from a keyboard touchscreen microphone etc. of device rather than a remote device e.g. verifies that the user input is received from a key press or local microphone rather than a request received from a remote device . Thus in such situations the boot process can continue only if a user is present at device and approves of continuing the boot process a malicious device or a malicious component of device cannot approve of continuing the boot process.

Policy record is maintained in a secure manner in which operating system loader can change policy record but that components executed after operating system loader in particular operating system kernel as well as other operating system components and or user mode components are prevented from changing policy record . Policy record is illustrated as surrounded by a dashed line to reflect this security. Policy record can be maintained in this secure manner in a variety of different manners.

In one or more embodiments policy record is stored in a writeable nonvolatile memory such as nonvolatile random access memory NVRAM . The writeable NVRAM can be accessed only under certain conditions and or at certain times. In one or more embodiments the writeable NVRAM is accessed via a Trusted Platform Module TPM . Additional information regarding TPM is available from the Trusted Computing Group of Beaverton Oreg. The TPM allows the writeable NVRAM to be read from and written to until a certain point in time or a certain event occurs after which the TPM allows the writeable NVRAM to be read but not written. This certain point in time or event can be for example a request from a component to close or lock the writeable NVRAM. Accordingly operating system loader can make changes to policy record in the writeable NVRAM and then have the writeable NVRAM locked. Operating system loader can thus prevent a malicious program from tampering with policy record because the writeable NVRAM is locked. The writeable NVRAM is not unlocked until device is booted again. The writeable NVRAM is unlocked the next time device is booted but operating system loader locks the writeable NVRAM again before a malicious program would be able to execute and write to the writeable NVRAM. Similarly other types of storage devices e.g. magnetic disk drives can be implemented so as to be accessed only under certain conditions and or at certain times.

Alternatively policy record can be maintained in a secure manner using other techniques such as by policy record being accessible only through a protected interface e.g. an application programming interface API that permits changes to policy record only if the change is signed by a trusted entity. Such a trusted entity is an entity that is trusted by operating system loader e.g. an entity that is known by operating system loader as being trustworthy and for which operating system loader has a public key . For example policy record can be stored as a UEFI authenticated variable which can be changed only if the change is signed by a trusted entity. Any requested changes to policy record are verified as being signed by a trusted entity and such requested changes are made if signed by a trusted entity but are not made if not signed by a trusted entity.

By way of another example in situations in which device is implemented as a virtual machine policy record can be maintained in a secure manner by a virtual machine manager that manages operation of one or more virtual machines on a device. The virtual machine manager can permit operating system loader but not other components to change the policies in policy record .

Changes to policy record include adding policies to policy record removing policies from policy record and or replacing policies in policy record with new policies. In one or more embodiments changes to policy record are performed by operating system loader if such changes are received from a trusted policy issuer e.g. the changes are digitally signed by a policy issuer entity that is trusted by operating system loader . Requests to change policies in policy record can be provided to operating system loader in different manners. In one or more embodiments operating system kernel or another component running on device stores the change to the policy in a persistent location that is accessible to operating system loader on the next boot of device . On the next boot of device operating system loader obtains the change and implements the change if appropriate. The operating system kernel or other component running on device can also store a request for a particular type of change along with the change e.g. an indication that a particular policy is to be removed or is to replace another policy . Alternatively the request for a particular type of change can be inherent e.g. the presence of a saved policy in the persistent location is deemed by operating system loader as a request to add that policy to policy record .

Operating system loader can remove a policy from policy record in response to a request from a policy issuer to remove the policy. Operating system loader verifies that the request is from a policy issuer that is a trusted entity then removes the policy if the request is from a policy issuer that is a trusted entity and does not remove the policy if the request is not from a policy issuer that is a trusted entity.

Similarly operating system loader can add a new policy to policy record in response to a request from a policy issuer to add the policy. Operating system loader verifies that the new policy and optionally the request is from a policy issuer that is a trusted entity and adds the new policy if the new policy and optionally the request is from a policy issuer that is a trusted entity but does not add the new policy if the new policy and or optionally the request is not from a policy issuer that is a trusted entity.

Additionally operating system loader can replace a policy in policy record also referred to as the current version of the policy with a new policy also referred to as the new version of the policy . When a new policy is received operating system loader verifies that the new policy and optionally the request is from a policy issuer that is a trusted entity. If the new policy and or optionally the request is not from a policy issuer that is a trusted entity then operating system loader does not replace the current version of the policy with the new version of the policy.

However if the new policy and optionally the request is from a policy issuer that is a trusted entity then operating system loader checks whether the new version of the policy is indeed a newer version of the current version of the policy. Operating system loader can check whether the new version of the policy is indeed a newer version of the current version of the policy by checking whether the current version of the policy is included in an ancestor list of the new version of the policy. The new version of the policy includes a policy ancestor list that identifies zero or more previous policies issued by that same policy issuer that are replaced by the new version of the policy. The policy ancestor list can identify previous policies by their policy identifiers e.g. GUIDs . If the new version of the policy is from a policy issuer that is a trusted entity and the current version of the policy is included in the policy ancestor list of the new version of the policy then operating system loader replaces the current version of the policy with the new version of the policy. Otherwise operating system loader does not replace the current version of the policy with the new version of the policy.

It should be noted that use of the policy ancestor list facilitates protecting against rollback or replay attacks by a malicious program or user. For example a malicious program or user may attempt to replace the current version of a policy e.g. that includes new security related values or settings with an older version of the policy e.g. that included out dated security related values or settings that would allow the malicious program or user to gain inappropriate access to components of device . By replacing the current version of the policy with the new policy only if the current version of the policy is included in the policy ancestor list of the new version of the policy operating system loader ensures that the current version of the policy is not replaced by an older version of the policy. Even though an older version of the policy may have been made available by a policy issuer that is a trusted entity the older version of the policy would not have an ancestor list that includes the current version of the policy and thus operating system loader would not replace the current version of the policy with the older version of the policy.

Additionally in one or more embodiments changes to policy record are performed by operating system loader only if such changes are approved by an entity trusted by the pre operating system environment e.g. trusted by operating system loader and or firmware such as a user of device or other trusted entity. When the entity is a user of device operating system loader prompts the user of device for approval of the change such as by displaying a visual prompt on a screen of or coupled to device playing back an audible prompt on a speaker of or coupled to device and so forth. The user can approve the change to the policy by providing a variety of different inputs such as pressing a button or key touching a particular portion of a screen providing an audible input and so forth. Operating system loader takes care to verify that the input is received from a user of device e.g. received from a keyboard touchscreen microphone etc. of device rather than a remote device e.g. verifies that the user input is received from a key press or local microphone rather than a request received from a remote device . Thus in such situations changes to policy record can be performed only if a user is present at device and approves of the changes a malicious device or a malicious component of device cannot approve of such changes.

When the entity is another entity trusted by the pre operating system environment other than a user the changes to policy record are digitally signed by the entity. Operating system loader verifies the digital signature and performs the changes to policy record only if the digital signature is verified as being from an entity trusted by the pre operating system environment e.g. trusted by operating system loader . If the digital signature is not verified then the changes to policy record are not made.

In one or more embodiments policies in policy record have an associated timestamp e.g. date and time . The timestamp associated with a policy can be included as part of the policy or alternatively can be maintained separately. For example a separate record of policy identifiers and timestamps can be maintained by operating system loader and this record is maintained in a secure manner e.g. in a variety of different secure manners analogous to those discussed above regarding policies in policy record being maintained in a secure manner .

Operating system loader can use these timestamps in determining whether to change policy record e.g. in determining whether a new version of the policy is indeed a newer version of the current version of the policy . A policy issuer can intend to replace one version of a policy with a new version of that policy using the same policy identifier for both versions of the policy but different timestamps. Operating system loader checks whether the new version of the policy and optionally the request to change the policy is from a policy issuer that is a trusted entity and whether the new version of the policy has a more recent timestamp than the current version of the policy. If the new version of the policy is from a policy issuer that is a trusted entity and the current version of the policy has a more recent timestamp than the current version of the policy then operating system loader replaces the current version of the policy with the new version of the policy. Otherwise operating system loader does not replace the current version of the policy with the new version of the policy. As the current version of the policy and the new version of the policy have the same policy identifier the determination of whether to replace the current version of the policy with the new version of the policy is based on the timestamps of the versions of the policy rather than an ancestor list of the new version of the policy.

Similarly policies in policy record can have an associated version number that is assigned by the policy issuer. The version number of a policy is incremented or a next version number in a set is selected for each new version of the policy. Version numbers can be used analogously to timestamps but are numbers and or other characters other than timestamps.

Alternatively operating system loader need not use timestamps and or version numbers in determining whether to change policy record . In such situations if a policy issuer intends to replace one version of a policy with a new version of that policy the policy issuer uses different policy identifiers for the two versions of the policy and includes the policy identifier of the version of the policy to be replaced in the ancestor list of the new version of the policy.

In one or more embodiments changes to policy record also include values written by an operating system loader during the boot process. For particular configuration settings in a policy operating system loader captures one or more current values or settings in device during the boot process. These captured values or settings are saved as part of or otherwise associated with the policy and treated as part of the policy to be satisfied on subsequent boots of device . Accordingly operating system loader verifies that on subsequent boots of device these captured settings or values are satisfied by operating system configuration values .

Which settings are to have their current values or settings captured during a boot process can be identified in different manners. For example a policy can include a setting indicating that a particular value is to be captured and saved by operating system loader during the boot process. By way of another example operating system loader can be configured with e.g. programmed with or otherwise obtain indications of which particular values are to be captured and saved by operating system loader during the boot process. By way of another example operating system loader can detect when security of device gets stronger or improves e.g. when an anti malware program is installed when a firewall program is installed etc. and capture and save a value or setting associated with that stronger or improved security e.g. capture and save an indication of the anti malware program .

As device can be booted multiple times which one of those multiple boot processes is the boot process during which the values are to be captured and saved can be identified in different manners. The values can be captured and saved during the first time device is booted without the value having already been captured and saved or if no values are found to have been already captured and saved . Alternatively operating system loader can be configured with e.g. programmed with or otherwise obtain indications of on which boot of device the values are to be captured and saved. Alternatively a policy in policy record can include an indication of on which boot of device the values are to be captured and saved.

Alternatively a user input can be received that indicates to operating system loader that the values are to be captured and saved e.g. during the current boot process or on the next boot of device . The user input can be provided in different manners such as by the user pressing a button or key touching a particular portion of a screen providing an audible input and so forth. Operating system loader takes care to verify that the input is received from a user of device rather than a remote device e.g. verifies that the user input is received from a key press or local microphone rather than a request received from a remote device . Thus in such situations a request to capture and save the values can be performed only if a user is present at device and approves of such capture and saving a malicious device or a malicious component of device cannot approve the capture and saving of such values.

In process a policy identifying configuration settings and or values for an operating system is obtained act . The policy can be changed by an operating system loader but the operating system is prevented from changing the policy as discussed above.

The policy is compared to configuration values used by the operating system act and a check is made as to whether the configuration values used by the operating system satisfy the policy act . Whether the configuration values used by the operating system satisfy the policy can be determined in a variety of different manners as discussed above.

If the configuration values satisfy the policy then the operating system is allowed to boot with the configuration values act . However if the configuration values do not satisfy the policy then a responsive action is taken act . A variety of different responsive actions can be taken as discussed above.

In process a change to a policy identifying configuration settings and or values for an operating system that are to be satisfied by configuration values of the operating system in order for the operating system to be executed or run are received act . The operating system is prevented from changing the policy as discussed above.

A check is made as to whether the change to the policy is approved by a trusted entity act . Such a trusted entity is an entity trusted by the pre operating system environment e.g. an operating system loader and this check can be made by prompting the user to approve the change or verifying that the change is digitally signed by a trusted entity as discussed above. If the change is not approved by a trusted entity then the policy is not changed. However if the change is approved by a trusted entity then the policy is changed act in accordance with the change received in act . In addition to the trusted entity approval various other verifications or checks can also be performed before changing the policy as discussed above such as checking timestamps ancestor lists and so forth.

The protecting operating system configuration values techniques discussed herein support various usage scenarios. For example operating system configuration values and a policy can indicate that an anti malware program from one of various manufacturers or developers is to be run on a device and that the operating system should not be loaded and run on the device unless such an anti malware program is running on the device. If a malicious program were to attempt to modify the operating system configuration values to indicate that an anti malware program is not required to be running in order to load and run the operating system then the next time the device is booted an operating system loader component will detect that the operating system configuration values do not satisfy the policy and thus does not load and run the operating system without the anti malware program.

By way of another example a device can be shipped from a manufacturer or distributor with a default operating system policy. A purchaser of the device can desire to use the device in an enterprise environment e.g. as part of a corporate or home network and have an enterprise policy that he or she desires to have used in place of the default operating system policy. This enterprise policy can have different security related settings and so forth than the default operating system policy and the enterprise policy has an ancestor list that includes an identifier of the default operating system policy. An administrator of the enterprise environment can be a trusted entity and generate a digital signature over the enterprise policy which is provided to the operating system loader. As the enterprise policy is signed by a trusted entity and identifies the default operating system on its ancestor list the enterprise policy replaces the default operating system policy in the policy record. However a subsequent default operating system policy would not accidentally replace the enterprise policy because the subsequent default operating system policy would not identify the enterprise policy on its ancestor list.

Computing device includes one or more processors or processing units one or more computer readable media which can include one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Computer readable media and or one or more I O devices can be included as part of or alternatively may be coupled to computing device . Bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port a processor or local bus and so forth using a variety of different bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

The techniques discussed herein can be implemented in software with instructions being executed by one or more processing units . It is to be appreciated that different instructions can be stored in different components of computing device such as in a processing unit in various cache memories of a processing unit in other cache memories of device not shown on other computer readable media and so forth. Additionally it is to be appreciated that the location where instructions are stored in computing device can change over time.

One or more input output devices allow a user to enter commands and information to computing device and also allows information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs applications objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Generally any of the functions or techniques described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module and component as used herein generally represent software firmware hardware or combinations thereof. In the case of a software implementation the module or component represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices further description of which may be found with reference to . The features of the protecting operating system configuration values techniques described herein are platform independent meaning that the techniques can be implemented on a variety of commercial computing platforms having a variety of processors.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

