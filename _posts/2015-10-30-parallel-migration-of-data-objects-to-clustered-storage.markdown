---

title: Parallel migration of data objects to clustered storage
abstract: Data objects can be migrated, while live, to virtualized clustered storage arrays in an efficient manner to allow for efficient transition from non-clustered storage to the virtualized clustered storage arrays. A data migration specification indicates data objects to be migrated and parameters for the migration. The parameters include a source of a data object, a destination of the data object in the virtualized clustered storage arrays, and a transfer space. A migration engine validates and parses the data migration specification. For each unique association of source, destination, and transfer space, the migration engine instantiates a migration process that drives and monitors migration of the corresponding data object. The migration processes operate in parallel for migration of the specified data objects into the virtualized clustered storage arrays.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503522&OS=09503522&RS=09503522
owner: NetApp, Inc.
number: 09503522
owner_city: Sunnyvale
owner_country: US
publication_date: 20151030
---
This application is a continuation of U.S. patent application Ser. No. 14 134 939 filed Dec. 19 2013 and entitled PARALLEL MIGRATION OF DATA OBJECTS TO CLUSTERED STORAGE the disclosure of which is incorporated herein by reference in its entirety for all purposes.

Embodiments of the inventive subject matter generally relate to the field of data storage and more particularly to migrating data to clustered storage.

Cluster computing aggregates computing devices to provide greater reliability higher availability of computing resources and performance gains of throughput load balancing etc. Clustering is also being applied to storage solutions. Storage equipment e.g. hard disk arrays tape drives NetApp v series open storage controllers Fiber Channel switches etc. can be clustered to also provide gains in reliability performance and availability for storage solutions. With NetApp Data ONTAP 8 NetApp Inc. leverages virtualization with clustering to provide a unified flexible and scalable clustered storage solution. Although NetApp Inc. already allows pooling of heterogeneous storage devices e.g. RAID equipment controllers can be clustered. A virtualization layer conceals the details of the clustering and provides a powerful storage solution with the clustered storage equipment via an elegant and simple interface presented as a single controller or pair of controllers.

The description that follows includes example systems methods techniques instruction sequences and computer program products that embody techniques of the inventive subject matter. However it is understood that the described embodiments may be practiced without these specific details. For instance although examples refer to storage controllers embodiments are not limited to interacting with storage controllers. References to storage controllers within these described examples could be replaced with references to file servers servers tape drive controllers or any other of the various types of storage equipment used in storage virtualization and or network based storage. In other instances well known instruction instances protocols structures and techniques have not been shown in detail in order not to obfuscate the description.

Data may be migrated due to an upgrade or modification of hardware and or software corresponding to the devices that host or access the data. Data migration can be resource intensive and interrupt data availability and or services that rely on that data. Maintaining accessibility of the data during a migration i.e. migrating live data increases the complexity of the migration. A migration engine as disclosed herein can migrate live data from various storage technologies to a virtualized clustered storage solution with efficiency and reliability. The migration engine spawns multiple migration processes to perform migration of multiple data objects in parallel. The migration engine distributes the data migration based on migration path exclusivity to insure migration job independence among the migration processes. Each migration process drives its own migration and communicates migration state to allow for recovery by the migration engine if needed.

A migration engine obtains a job specification or job list at a stage A. The migration engine is an executing instance of program code that handles processing of job lists and dispatches those jobs to migration processes. The migration engine may also implement recovery of aspects of a migration. The job list may be a file loaded into a system hosting the migration engine a list created from a graphical user interface etc. Each line in the depicted job list represents a data migration job. In this example a job is represented by parameters that indicate a data object a source of the data object a transfer space for the data object and a destination in the virtualized clustered storage array for the data object. The job list can specify other parameters that affect the migration process. The job list identifies migration jobs for data objects N. The parameters of each migration job indicate a data object and a migration path. The migration path is identified by the source transfer and destination. The job list indicates that a DATA OBJECT is to be migrated from source SRC to destination DST via transfer space TRANSFER. The job list indicates that a DATA OBJECT is to be migrated from source SRC to destination DST via transfer space TRANSFER. The job list indicates that a DATA OBJECT is to be migrated from source SRC to destination DST via transfer space TRANSFER. The job list indicates that a DATA OBJECTN is to be migrated from source SRC to destination DST via transfer space TRANSFER.

The migration engine processes the job list to create a migration log and instantiate a migration process for each migration job. The migration engine ensures that each indicates job indicates a unique migration path within the job list . The migration engine creates the migration log at a stage B. The migration log is used to track state of each migration process that will be instantiated throughout performing the data migration jobs specified by the job list . This state information can be used by the migration engine to recover resume from incidents that prevent any of the migration processes from completing. The migration engine at stage C instantiates migration process through N. Each migration process works on an exclusive migration path. In other words the migration processes through N will not be migrating data objects over the same migration path. Different migration processes however can migrate a same data object over different migration paths.

Each of the migration processes through N drives and monitors its migration job at a stage D. Driving the migration process involves causing actions to be performed with any one of application programming interface API function calls message based commands e.g. remote procedure calls remote login and command line execution etc. The migration processes through N configure a transfer space as an intermediary point for the data migration. Prior to configuration the transfer space is raw storage space available for the migration. This raw storage space can be separate from the source or on a same storage device as the source. The transfer space may be dynamically allocated or designated for data migrations. The migration processes through N communicate with the controller to cause replication of data objects from the storage devices to the configured transfer space . The migration processes through N communicate with the logical interfaces and to prepare the virtualized clustered storage array for migration of data from the configured transfer space to the virtualized clustered storage array .

Although the migration processes through N drive the migration jobs the controller and the storage equipment that implements the virtualized clustered storage array and the transfer space carry out the data migration. In accordance with communications commands from the migration processes through N the controller replicates data to the transfer space at stage E Likewise storage equipment that implements the transfer space replicates data to the virtualized clustered storage array at stage E in accordance with the messages commands from the migration processes through N.

Throughout the migration specified by the job list the migration processes through N update the migration log as represented by label F. Each of the migration processes through N update the migration log to reflect a current state of the particular migration process. The granularity of state maintained in the migration log is based on design of the migration engine that balances performance e.g. a greater number of states may impact migration performance against robustness of recovery e.g. a greater number of states allows for more precise recovery . In addition the state granularity may be configurable. The migration log is not limited to being used for recovery and may be used for other purposes examples of which include troubleshooting and data center analysis.

After the transfer space is configured the migration process establishes data paths for the data migration. depicts the data path establishment as operations A and B since the order will vary depending upon implementation. With operation A the migration process establishes a data path s between the controller and the transfer space . With the operation B the migration process establishes a data path s between the transfer space and the logical interface which can also be referred to as the virtual storage controller within the context of this example illustration. Establishing the data paths results in network stack processes at the end points being instantiated resumed and structures created initialized to handle communications of the data migration.

After the data paths are established the migration process initiates replication of the data object from the storage devices via the storage controller to the transfer space . The migration process initiates replication of the data object in a manner that prepares the data object for replication to the clustered virtualized storage arrays . For instance the migration process may pass commands to the controller to replicate decomposed units of the data object e.g. command the controller to replicate individual directories of a volume . Afterwards the migration process initiates replication of data from the transfer space to the logical interface .

As stated in the context of the migration process updates the migration log to reflect current state throughout migration of the data object for which the migration process is responsible. The migration process can update state after receipt of confirmation that an operation has been performed by any of the targeted storage equipment. The migration process can also update state in response to acknowledgements of messages sent to the storage equipment. The migration process can write directly to the migration log as depicted in . The migration processes can also write state to an event log from which the migration engine pulls information. The migration engine can pull information from the event log to determine whether an action should be triggered e.g. recovering a migration process . The migration engine can then write state to the migration log .

At block a list of data objects for migration is obtained. This migration job list may be obtained from a file from a graphical user interface from a message etc. The information that encapsulates the data objects to be migrated is referred to herein as a migration job list or job list but can be implemented in any of a variety of formats and structures e.g. an array a text file etc. . Indication of the data object to be migrated the migration data path and other values parameters that affect the migration are referred to as a migration job. Examples of the other values parameters include a logical group transfer space size for the data migration resource limitations e.g. bandwidth allowed etc. Logical groups can be specified in accordance with an organizations roles policies etc. For example a data object to be migrated may be specified for a legal department as well as an accounting department. These different logical groups likely have different permissions that will be applied to their data objects and perhaps the structure s or device that hosts the data objects. Different instances of the migration engine can assume responsibility for the different logical groups indicated in a job list.

At block the migration job list is validated. The migration job list is evaluated to determine whether different migration jobs indicate a same data path. If the migration job list indicates a same data path for different migration jobs then the job list violates the rule that each job have a unique data path relative to the other jobs in the job list. If this rule is violated then a validating action can be taken. Jobs that repeat data paths can be removed from the job list and written into a new migration job list. The job with the violating data path could be removed and a notification created that the job was not carried because it violated the path exclusivity rule. A validating action can also be changing the specified transfer space in the migration data path. If a different transfer space is available e.g. a different host or different storage device a migration engine can modify the migration data path to specify the different transfer space. If the migration job list indicates different logical groups then a migration engine can create a different instance of the migration engine to handle the different logical group. If the jobs that have the same migration path are in different logical groups then the migration path exclusivity rule is satisfied by the separation of logical groups into different migration engine instances.

At block a loop begins for each job indicated in the validated list. In this example flowchart the loop carries out operations of blocks and .

At block a job identifier is generated based on the migration data path of the job. For instance the job identifier can be a concatenation of a source identifier e.g. volume identifier and source host network address destination identifier e.g. destination volume identifier and destination host network address and transfer space identifier network address. As another example the job identifier can be generated by computing a hash of the source volume identifier and source host network address destination volume identifier and host network address and transfer space network address. The job identifier can be used to identify the migration process that will be instantiated or mapped to the process identifier of the migration process. The job identifier allows the state information of a migration process to resolve back to the corresponding job tasked to the migration process.

At block a migration process is instantiated based on the parameters of the indicated job. The migration job is also instantiated with an initial state to reflect instantiation of the migration process. This state can be written directly into a migration log by a migration engine or passed into the migration process to seed a state engine of the migration process. The migration process can be instantiated on a same machine as that hosting a migration engine on a different machine on a machine associated with the transfer space etc. The migration process can be instantiated with the parameters of the job. The migration process can also be instantiated with a reference e.g. address link or pointer to a location that hosts the parameters for the migration job. The migration process can access the parameters after being instantiated.

At block the migration process is associated with the job identifier. For example a migration log is updated to identify the migration process with the job identifier. The migration process may be identified by a thread identifier process identifier host address virtual machine identifier etc. Whatever identifier used to identify the migration process is mapped to the job identifier.

At block the migration log is updated to indicate that the migration process has been instantiated for the indicated job. This update may be in response to an acknowledgement message from the migration process. For instance migration program code can be written to accept an identity of a launching process e.g. a migration engine instance as a parameter. The migration program code can also be written to provide an acknowledgement to the identified launching process after the parameters have been loaded by the migration process.

At block it is determined whether an additional job is indicated. If all jobs in the validated migration job list have been processed then the launching process monitors the migration log. If additional jobs remain to be processed then control flows back to block .

At block of an identifier for a writeable transfer structure corresponding to the data object to be migrated is generated. The writeable transfer structure is a structure that allows data to be written into the transfer space as a result of configuring the transfer space e.g. creation of boot records and or partition tables . Although examples refer to creating a volume in the transfer space embodiments can also create logical disks partitions etc. The identifier for the writeable structure can be based on the job identifier or even be the job identifier . However embodiments may not generate an identifier for the writeable structure. Embodiments may rely on the storage equipment and software of the transfer space to assign an identifier and communicate that identifier back to the migration process.

At block space sufficient for the migration of the data object in the indicated transfer space is requested. The space to accommodate the data object being transferred may be indicated as a parameter of the migration job. If not the migration process can query the source of the data object to determine the amount of storage space to accommodate the data object including control information e.g. metadata access structures etc. for the data object. A message is sent to the transfer space device requesting allocation of storage space of the amount sufficient for replication of the data object.

At block it is determined whether the transfer space has sufficient space to accommodate the request. If not then control flows to block . If sufficient space is available then control flows to block .

At block a notification is generated that the transfer space does not have sufficient space for the migration of the data object. The notification may be a message sent to a migration engine or job dispatcher. The notification may be reflected in a migration state update. If space is insufficient for migration of the data object then the job may be eliminated or delayed. Corrective action can be taken to obtain transfer space from different storage equipment or release other storage space that can be cleared reformatted for use as transfer space. Embodiments can handle the space insufficiency in transfer space differently. A migration engine can suspend all migration processes and take this corrective action before resuming the suspended migration processes. A migration engine can suspend the affected migration process take corrective action and restart the migration process. Embodiments can also implement the program code for a migration process to take the corrective action itself.

At block the space for the data object migration is obtained and the obtained space is configured. A migration process for example begins sending configuration commands or directly configures the transfer space after receiving acknowledgement that the requested space is available in the transfer space.

At block job migration state for the migration job is updated after confirmation has been received that the obtained space has been configured. After sending the configuration commands the migration process waits for a confirmation for proceeding to a next phase of the migration job. The migration process updates migration state for the migration job to indicate that the transfer space has been configured for the migration job and information for accessing the configured transfer space. A recovery action can commence with the configured transfer space if needed.

At block a data path is established between the destination and the transfer space. Commands are communicated to create communication endpoints at the source and the transfer space to support the migration operations.

At block the job migration state is updated after confirmation that the data path has been established between the source and the transfer space. Migration state could be updated at a finer granularity for instance after each endpoint is established instead of waiting until both endpoints are established.

At block a data path is established between the transfer space and the destination. Commands are communicated to create communication endpoints at the destination and the transfer space to support the migration operations.

At block the job migration state is updated after confirmation that the data path has been established between the transfer space and the destination. As mentioned earlier migration state can be updated at different degrees of granularity. Migration state could be updated after each endpoint is established instead of waiting until both endpoints are established. In addition establishing the data paths may not explicitly be reflected in the job migration state and may be understood when state is updated to indicate that replication has begun. Control flows to block of from block .

At block of replication of the data object from the source to the transfer structure is initiated. For example a migration process may send a command for a controller to execute the NetApp SnapMirror program with parameters communicated by the migration process.

At block the job migration state is updated after confirmation that replication of the data object from the source to the transfer structure has commenced.

At block replication of data from the transfer structure to the destination is initiated. Replication is initiated for the data since the data object may not yet have been replicated to the transfer structure. In the case that replication from the transfer structure to the destination is initiated before replication completes from the source to the transfer structure the replication can be carried out to account for the ongoing changes to the transfer structure. For instance snapshotting can be implemented to replicate each change from the transfer structure to the destination. A migration process can initially communicate a replicate command from the transfer structure to the destination. The migration process can then communicate a command to perform snapshots until the migration process terminates the snapshotting.

At block the job migration state is updated after confirmation that replication of data from the transfer structure to the destination has commenced.

At block the process waits for receipt of a message. When a message is received control flows to block for processing of that message.

At block it is determined whether the message corresponds to the source to transfer structure replication. This can be determined with various techniques. The message can be considered as corresponding to the source to transfer structure replication if the sender is identified with the source network address if the message includes a phase identifier that represents the source to transfer structure replication if the message indicates port numbers that correspond to the source and transfer space if the message indicates a function name or value that relates to the replication program being utilized etc. If the message corresponds to the source to transfer structure replication then control flows to block . Otherwise control flows to block .

At block job migration state is updated to reflect completion of the source to transfer structure replication. This presumes that the types of messages corresponding to the source to transfer structure replication consist of an error message and a completion message. The replication functionality implemented by the source may generate additional messages to communicate progress of the replication. Migration program code can account for these additional messages and update migration state to reflect what each replication message conveys. An implementation can copy the content of progress messages to indicate current state of the migration job. Embodiments can also locally maintain state of replication progress without relaying this progress to the migration state log.

At block updates between the source and transfer structure are initiated. For example a migration process can communicate a command to the source to implement snapshotting to capture changes to the data object. Since the data object being migrated is live the data object can be modified during the migration. To capture these changes each change at the source can be captured and relayed to the transfer structure. Embodiments can also record a history of changes to the data object during the migration process. The migration process can then send the history of changes to be performed by the destination before the destination goes live with the migrated data object.

At block it is determined whether the message corresponds to source to transfer structure updates. As discussed with respect to block the message can be characterized with various techniques. If the message corresponds to the source to transfer structure updates then control flows to block . Otherwise control flows to block of .

At job migration state is updated to reflect completion of the source to transfer structure update phase. This state update presumes that the update message is sent when the update ends e.g. snapshotting ends . The updates can be specified to end after a particular time period a number of updates etc. Ending of the updates corresponds to switch over from the source to the destination. The source may provide an update message for each snapshot copied to the transfer structure. In that case the migration process can maintain a local state of the update phase and only convey completion of updates to the migration log. Also the update message will include information to allow distinction between progress messages and a completion message. The migration process could also be implemented to convey each progress message from the update process to the migration state log.

At block migration resources between the source and transfer space are released. Releasing the resources can include tearing down data path endpoints terminating communication processes etc. The migration process may send individual commands to carry out release of individual resources. The migration process may invoke clean up code at the source and or transfer space responsible for releasing all resources allocated for the data migration.

Control flowed to block of if the message did not correspond to the source to transfer structure replication or updates. At block it is determined whether the message corresponds to transfer structure to destination replication. As discussed earlier the purpose of the message can be determined with various techniques. If the message corresponds to the transfer structure to destination replication then control flows to block .

At block job migration state is updated to reflect completion of the transfer structure to destination replication. Similar to block this presumes that the types of messages corresponding to the transfer structure to destination replication consist of an error message and a completion message. The replication functionality implemented by the transfer space host may generate additional messages to communicate progress of the replication. Migration program code can account for these additional messages and update migration state to reflect what each replication message conveys. An implementation can copy the content of progress messages to indicate current state of the migration job. Embodiments can also locally maintain state of replication progress without relaying this progress to the migration state log.

At block updates between the transfer structure and destination are initiated. For example a migration process can communicate a command to the transfer space host or transfer space controller to implement snapshotting to capture changes to data in the configured transfer space. This would capture the changes streaming into the configured transfer space without waiting for the source to transfer structure phase to complete. Embodiments can also communicate a recorded a history of changes to the data of the transfer structure and a command for the destination to perform the recorded changes before the destination goes live with the migrated data object.

If the message is determined to be a message corresponding to update between the transfer structure and the destination then the job migration state is updated at block . The job migration state is updated at block to reflect completion of the transfer structure to destination update phase. This state update presumes that the update message is sent when the update ends e.g. snapshotting ends . The updates can be specified to end when the updates between the source and transfer structure end. The migration process can send a command to the source to notify the transfer space host when the updates end between the source and the transfer structure. The update process run by the transfer space host can then terminate the updates. The transfer space host may provide an update message for each snapshot copied to the destination. In that case the migration process can maintain a local state of the update phase and only convey completion of updates to the migration log. Also the update message will include information to allow distinction between progress messages and a completion message. The migration process could also be implemented to convey each progress message from the update process to the migration state log.

At block source data object attributes are applied to the migrated data object. The source data attributes can include read and write privileges roles security keys security preferences roles group identifiers etc. In some cases the migration job may have specified that the data object was to be split and migrated. When a data object is split into multiple data objects the attributes of the source data object are applied to the resulting data objects. If multiple source data objects are merged into a single data objects at the destination the each attribute can be applied individually dependent upon priorities between attributes of the multiple source data objects. For instance the greater security requirement and more restrictive privileges of the multiple source data objects would be applied to the resulting destination data object.

At block the destination is published to allow access to the migrated data object. For example a directory is updated to replace an identifier of the source with an identifier of the destination.

At block migration job resources between the transfer space host and the destination are released. Releasing the resources can include unmounting a logical disk or a volume in the transfer space releasing a partition in the transfer space terminating a virtual machine running in the transfer space tearing down data path endpoints etc. The migration process may send individual commands to carry out release of individual resources. The migration process may invoke clean up code at the transfer space host and or destination responsible for releasing all resources allocated for the data migration.

Although a virtualized clustered storage solution can encompass a variety of heterogeneous storage technologies embodiments may convert data objects being migrated into the virtualized clustered storage solution. The transfer space can be employed as an intermediate point to migrate the data in a manner suitable for the destination. This allows the data to be migrated into the destination in a uniform manner that can provide greater efficiency in the data migration. For instance a data object may be a file system based data object but the destination employs a block based storage system. For example a qtree can be replicated to a configured transfer space using the qtree mode of NetApp SnapMirror technology. A qtree is a subunit of a volume or FlexVol virtual volume that is similar to a partition although a qtree can be an entire FexVol volume or volume. The qtree is replicated to a volume configured in the transfer space. The volume can then be replicated to the destination using the volume mode of NetApp SnapMirror technology. The source data object may also have to be replicated in decomposed units in cases of data object variation between the source and destination. In addition decomposed units of the source data object may be more suitable when using available replication technology. The data object can be replicated to the transfer space with a file system based replication process that replicates decomposed units of the data object. And the decomposed units replicated from the transfer space to the destination with a block based replication process. For example a migration job may identify a volume in a source to be migrated. Instead of replicating the volume each qtree in the volume is replicated to a different volume in the transfer space. Each volume in the transfer space is then replicated to the destination. depicts example operations for a data migration that accounts for decomposing data objects. builds upon the early example operations depicted in . presumes that control flows from block to block .

At block it is determined whether a data object is a volume. If the data object to be migrated is not a volume then control flows to block of . If the data object is a volume then control flows to block .

At block it is determined whether the volume has multiple file system based data objects. For instance the volume is accessed to determine whether the volume encompasses qtrees folders logical unit numbers LUNs or directories depending upon the hosting technology. If multiple file system based data objects reside within the volume then control flows to block . Otherwise control flows to block .

At block space is obtained in the transfer space for the migration. Computing the space for the migration can go beyond reading the space occupied by the source data object and adding default space for changes that occur during the migration. Computing the space to be configured in the transfer space for the data object migration can involve determining space for each decomposed data object and then adding space sufficient for the separate volumes that will be created for each decomposed data object.

At block a loop begins for each file system based data object i.e. decomposed data object in the volume. The loop in this illustration includes operations represented by blocks and .

At block a volume is created in the obtained space for the file system based data object. After obtaining a total amount of space for the data object migration a migration process can begin configuring the obtained space for replication of the file system based data objects.

At block it is determined whether an additional file system based object has not been processed. If so control flows to block . If there are no additional file system based data objects in the volume to be migrated then control flows to block .

Block represents a process of migrating each volume. Migrating each volume is similar to the operations represented by block through the rest of the blocks of . However a migration job now consists of multiple replications. A migration process will maintain state for each of the replications. The multiple replications may be able to utilize a single data path. Or multiple data paths will be established for the multiple replications. Although refers to a volume embodiments can decompose a data object of other formats technologies and or names that encompass other data objects.

The flowcharts are provided to aid in understanding the illustrations and are not to be used to limit scope of the claims. The flowcharts depict example operations that can vary among embodiments and among implementations of embodiments. Additional operations may be performed fewer operations may be performed the operations may be performed in parallel and the operations may be performed in a different order. For instance the operation represented by block of may not be performed. Embodiments can use identifiers generated by the host device or software of the transfer space. An operating system of a machine that hosts a transfer space may automatically generate volume identifiers when volumes are created. Additional operations could be depicted in to generate identifiers of the transfer structures thus tasking the migration engine with identifying transfer structures. Furthermore embodiments are not required to instantiate or launch a migration process for each migration job. Embodiments can leverage processes threads etc. that have previously been launched or instantiated and assign migration jobs to those processes or threads.

As will be appreciated by one skilled in the art aspects of the inventive subject matter may be embodied as a system method or computer program product. Accordingly aspects of the inventive subject matter may take the form of a hardware embodiment a software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the inventive subject matter may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to an electro magnetic signal an optical signal an infrared signal or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with a computer. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the inventive subject matter may be written in any combination of one or more programming languages including an object oriented programming language such as the Java programming language C or the like a dynamic programming language such as Python a scripting language such as Perl programming language or PowerShell script language and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a stand alone computer may execute in a distributed manner across multiple computers and may execute on one computer while providing results and or accepting input on another computer.

Aspects of the inventive subject matter are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the inventive subject matter. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The term computer as used herein comprises any kind of computing system machine or device including a personal computer a laptop a server a tablet a smartphone a smartwatch etc. A computer can also comprise a computing system that is communicatively coupled with other computer systems to form a set of computing systems that coordinate to perform functions similar to that of a single computing system.

While the embodiments are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the inventive subject matter is not limited to them. In general techniques for parallel migration of data into a virtualized clustered storage solution based on migration path exclusivity as described herein may be implemented with facilities consistent with any hardware system or hardware systems. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the inventive subject matter. In general structures and functionality presented as separate components in the example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the inventive subject matter.

