---

title: Framework for efficient security coverage of mobile software applications using machine learning
abstract: For one embodiment, a method is described that involves the instrumenting of an application of a computing system with at least one monitoring function, where the monitoring function is capable of operating in a run-time environment during processing of the instrumented application. The movement of data associated with the application is tracked by one or more monitoring functions. This data is at least partially identified by a storage location. Thereafter, a determination is made whether movement of the data from a first storage location to a second storage location is suspicious, and if so, suspicious movement of the data is reported.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09594905&OS=09594905&RS=09594905
owner: FireEye, Inc.
number: 09594905
owner_city: Milpitas
owner_country: US
publication_date: 20151012
---
This is a Continuation application claiming the benefit of priority on U.S. patent application Ser. No. 13 775 170 filed Sep. 23 2013 which is incorporated by reference in its entirety.

The field of invention pertains generally to computing systems and more specifically to a framework for efficient security coverage of mobile software applications using machine learning.

With the emergence of mobile and or handheld computing e.g. as embodied by the prevalence of tablet computers and smart phones the security of the application software that runs on these devices has become a matter of concern. The concern is becoming particularly acute as more powerful mobile platforms are supporting more capable and important application software applications. With increased capability and importance the applications and underlying platforms are handling more sensitive information more intensively.

The central intelligence engine controls the testing strategy of an application under test that is executing within the dynamic runtime environment . Essentially the central intelligence engine identifies regions of interest within the code of the application determines specific stimuli to reach these regions of interest causes such stimuli to be applied to the application monitors the behavior of the application in response to these stimuli and determines whether or not the application is safe or unsafe in view of the application s observed behavior.

As observed in the central intelligence engine includes a behavior and logic engine BALE   and an explorer engine  . The behavior and logic engine   observes the application to ultimately reach a conclusion in view of its observations whether or not the application is safe . The behavior and logic engine   in response to its observations and in pursuit of its ultimate objective of determining whether or not the application is safe may identify stimuli to be applied to the application identify specific monitoring functions that should be enabled to detect certain application behaviors and or identify possible regions of interest that may exist in the application based on its observed behavior and notify the explorer engine   of such possible regions of interest.

The explorer engine   assists the behavior and logic engine by studying the internal structure and operation of the application looking for and identifying regions of interest within the application code i.e. portions of the code that correspond to unsafe operations as opposed to benign safe operations . Besides being notified of the possibility that certain regions of interest may exist in the application based on the behavior and logic engine s   observations of the application s behavior the explorer engine   may also look for certain kinds of regions of interest based on one or more rules provided by the user one or more rules gleaned from a machine learning platform and or one or more hardcoded rules. Subsequent applied stimuli and observations of the application are focused on the identified regions of interest. By focusing the stimuli and observations on the regions of interest the overall testing and characterization of the application is more streamlined and efficient because execution of large portions of benign application code is largely avoided.

According to one approach the behavior and logic engine   is implemented as an inference engine. As is understood in the art an inference engine recursively collects information facts describing the current state of a system under observance and matches them against applicable rules for the system. Acts are defined for specific patterns sets of facts that match the applicable rules. The set of available acts for a particular set of matching facts and rules corresponds to an agenda . The engine then performs conflict resolution which is the process of determining which acts from the agenda should be performed the conflict set and in what order they should be performed in. After conflict resolution the selected acts are then performed on the system in the determined order here the conflict set may define a next set of stimuli to be applied to the application . The acts generate a new state of the system being observed which corresponds to the generation of new facts. The process described above then repeats in a recursive fashion until some conclusion about the system is reached. That is the engine s recursive conflict resolution actions are generally aimed at reaching some conclusion about the system in this case ideally whether the application software is safe or unsafe .

The explorer engine   analyzes a control flow graph or other representation of the application s internal structure operation that defines different states of the application and the stimuli needed to cause a transition from one particular application state to another particular application state including multiple transitions through multiple states . In an embodiment the representation of the application that is analyzed by the explorer engine   is generated by the static instrumentation engine with one or more various software analysis techniques e.g. control flow analysis data flow analysis value set analysis event analysis etc. . The explorer engine   e.g. through reference to various rules that describe appropriate and or inappropriate code structures and or code and or by way of notification from the behavior and logic engine   that certain inappropriate code structures and or code may exist in the application based on its observed behavior identifies regions of interest within the representation of the application. The explorer engine   then attempts to identify specific stimuli that may be applied to the application to cause it to transition to an identified region of interest.

The corpus of rules available to the behavior and logic and explorer engines     are provided from i rules provided from the platform specific knowledge base ii rules generated from a machine learning platform and iii customer user provided rules . More discussion concerning the use of these rules is provided in more detail further below.

The run time test engine and observation environment includes the application software being observed and an instance of the type of operating system the application is expected to later run on if ultimately deemed safe. In various embodiments the run time test environment may include a first virtual machine between the application under test and the operating system instance . Here the application software is typically received as abstract executable code e.g. Java byte code or other CPU hardware agnostic code. The first virtual machine converts the application s generic executable code into appropriate instructions for the underlying hardware platform . The first virtual machine and application under test can together be referred to as a process .

The operating system instance may also run on a second virtual machine that itself runs on a virtual machine monitor VMM layer that exists between the second virtual machine and hardware platform .

As is known in the art a VMM layer is responsible for partitioning allocating the resources of the underlying hardware platform e.g. system memory CPU threads non volatile storage space etc. amongst the various second virtual machines   through  N. Essentially each of the second virtual machines   through  N attempts to present the image of an entire computing system and its resources to its respective operating system instance   through  N. The VMM layer and its virtual machines   through  N largely hide from the operating system instances   through  N the perspective that they are actually sharing a single underlying computing system .

The existence of multiple second virtual machines   through  N essentially permits the instantiation of multiple run time test processes   through  N that are isolated from one another. The concurrent existence of multiple isolated run time test processes   through  N permits different types of coverage and observation sequences to be concurrently run on a single application.

That is different instances of the same application may be provided in different run time processes so that different types of coverage and observance sequences can be concurrently performed on the same application. Alternatively or in combination different applications can be concurrently observed in the multiple run time processes. For instance a first application may be observed in a first run time test process e.g. process   while a second different application is observed in a second run time test process e.g. process   . The second different application may be a different version of the first or a different application entirely.

Additionally instances of different operating system types may support different run time processes. For example an ANDROID operating system instance may support a first run time process while an iOS operating system instance may support a second run time process. Elsewise different versions of same operating instance may concurrently execute on a virtual machine monitor layer to support two different run time processes. Concurrent testing of multiple application instances whether different instances of the same application or respective instances of different applications or different versions of a same application or some combination thereof enhances the overall performance of the system.

The central intelligence engine returning to is therefore capable of concurrently analyzing multiple application instances. This includes maintaining parallel inference engine recursions and internal analyses of the multiple application instances. In cases where multiple instances of a same application are being concurrently tested communications information sharing may exist amongst the testing schemes of the two or more of the application instances to help formulate a single global multi threaded testing strategy for the application. For simplicity the remainder of the application largely refers to a single run time test process.

Here each of the first virtual machine the operating system instance and the second virtual machine is retrofitted with various monitoring functions   through  M that the central intelligence engine is able to enable disable. For example the central intelligence function may enable certain monitoring functions e.g. monitoring functions   and   while disabling the remaining monitoring functions e.g. functions   and   not shown through  M . In an embodiment the monitoring functions at least include i a system calls monitoring function   ii a data tracking monitoring function   and iii a device operation monitoring function  .

As observed in the system calls monitoring function   is embedded in the operating system instance the data tracking monitoring function   is embedded in the first virtual machine and the device operation monitoring function is embedded in the second virtual machine . Notably these monitoring function locations are exemplary as they could likewise be located in different locations. For example the data tracking monitoring function   could be located in the second virtual machine and the system call monitoring function   could be located in the first virtual machine .

The system calls monitoring function   monitors the run time execution of the application s executable code and flags any system calls. Here a system call is essentially any invocation of the underlying operating system instance made by the application under test or its virtual machine . As is understood in the art an operating system provides services for basic uses of the hardware platform. An application s request to use such a service corresponds to a system call. The types of system calls an application can make typically include process control system calls e.g. load execute create process terminate process wait e.g. for an event allocate or free a system memory range file management system calls e.g. create delete file open close file get set file attributes information maintenance system calls e.g. get set time or date and I O system calls such as communication system calls e.g. create delete network connection send receive messages attach detach remote devices and user interface operating system OS calls.

In order to flag any system calls made by the application or virtual machine in an embodiment monitoring function   detects a system call such as any of or a masked subset of any of the system calls mentioned above and reports the event to the central intelligence engine along with any parameters associated with the call to the central intelligence function. For example if an application seeks to open a network connection to a particular network address the system call monitoring function   will report both the request to open the connection and the network address to the central intelligence engine . The monitoring function may intercept system calls by hooking the system calls to capture the passed parameter.

The data tracking monitoring function   tracks specific items of data within the application . As is understood by those of ordinary skill data is usually identified by the memory location and or register location where it is stored. The executable code of an application specifically calls out and identifies these locations. Frequently data will move from one memory register location to another. The data tracking monitoring function   tracks the movement of a specific item of data and reports any suspicious activity to the central intelligence engine . More specifically in an embodiment the data tracking monitoring function   is provided with the identity of a specific sensitive e.g. highly confidential data item and reports to the central intelligence engine any attempt by the application to cause the data to be directed out of the run time environment such as attempting to send the data over a network connection or stored in a file or other storage e.g. register and or memory location other than an approved location.

In an embodiment the data tracking monitoring function   maintains internal tables having an entry for register and system memory addresses referred to by the application code. Each entry also identifies whether its corresponding register memory address is tainted . The data tracking monitoring function   marks as tainted any register memory location where the sensitive information is kept. Additionally the data tracking monitoring function   marks as tainted any register or memory location to which a tainted register memory location s content is moved. The data tracking monitoring function   will also clear a tainted register memory location i.e. mark it as no longer tainted if it is overwritten with the contents of a non tainted register memory location or is otherwise erased e.g. by being reset to cleared to all zeroes .

By so doing all locations where the sensitive information resides are known. Any attempt by the application to direct data from a tainted location outside the run time environment or to an unapproved register memory or file location is reported to the central intelligence engine . The report includes pertinent ancillary information associated with the attempt such as the network address to where a data transmission was attempted or the unapproved file location where an attempted store was made . In the case of unapproved network destinations and or storage locations the data tracking monitoring function   is informed beforehand of at least one of the data item s approved or unapproved data destinations locations by the central intelligence function . In many cases the identity of the sensitive information to the central intelligence engine is made by way of the user provided rules .

The device operation monitoring function   monitors calls made by the application or virtual machine to the underlying hardware platform directly i.e. not through an OS system call . Here a device is generally understood to be any attachment or peripheral attachments peripherals are typically coupled to a hardware system s I O control hub ICH or system memory control hub MCH . Attachments peripherals typically include non volatile storage devices e.g. disk drives SSD devices network interfaces e.g. SMS functions HTTP functions keyboards displays and mouse touchpad control stick devices integrated camera devices integrated audio devices both input e.g. microphone and output e.g. speaker system and printers among other possible devices. In the context of the device monitoring function   however the term device is understood to be broader than just peripherals. For example if an application attempts to directly write to control register space such as model specific register space of a CPU core or a memory controller within the hardware platform the device operation monitoring function   will track these operations as well.

Here depending on system implementation various devices within the underlying hardware may be manipulated by the application or virtual machine through direct communication to the underlying hardware without involvement of the operating system e.g. by writing to the underlying platform s register space . These operations are tracked by the device operation monitoring function  . By contrast the application s behavior with respect to those devices or functions called thereon that are not directly communicated to the hardware are typically manipulated through the operating system . These calls are therefore tracked with the system call monitoring function  .

When a call is made to a device directly through the hardware the device operation monitoring function   reports the call to the central intelligence engine identifying both the targeted device and the type of call that was made.

As mentioned above in one approach a monitoring function will not monitor and or report out an event it is designed to detect unless it is specifically enabled e.g. by the central intelligence engine beforehand.

In many cases the application instance is a mobile application that is effected with abstract executable code e.g. Java bytecode that needs to be converted into the object code of a particular type of CPU by the first virtual machine . In cases where the application instance is provided as object code that is already targeted for a specific CPU type i.e. the first virtual machine is not needed the monitoring functions   to  M may nevertheless be integrated into the run time environment so as observe the interface between the application and the operating system instance . For example as stated earlier the data tracking monitoring function   can be integrated into the second virtual machine instead.

Along with the monitoring functions   through  M stimuli functions   through  P are also integrated into the run time environment . Whereas the monitoring functions   through  M are designed to report observed behaviors of the application to the central intelligence engine by contrast the stimuli functions   through  P are designed to apply specific input values and or signals to the application e.g. to drive the application s execution to a region of interest to observe the application s behavioral response to these inputs etc. . The specific input values and or signals to be applied are provided by the central intelligence engine .

As observed in the stimuli functions include i a data value stimuli function   ii as OS event state stimuli function   and iii a hardware event state stimuli function  .

The data value stimuli function   is able to set specific low level data values of the application s code. The data value may be specific data that is processed by the application or control data used to control the application. For example the data value stimuli function   may be used to set an instruction pointer to a specific value to begin or jump application execution to a specific point in the application s code. Likewise the data value stimuli function   may be used to create change delete any data value within the register or system memory space that is processed by the application . This capability may be used for instance to change the state of the application to any particular state so the application s behavior in response to the artificially set state can be observed.

The OS event state stimuli function   is used to create any event that the OS might report to the application e.g. incoming call incoming packet etc. or present any OS state that is observable to the application e.g. such as the state of various devices within the system . Here the OS event state stimuli   is essentially used to manipulate the OS portion of the application s environment. Likewise the hardware event state stimuli function   is used to create any event that the hardware might report to the application e.g. an incoming call for an SMS device that does not communicate to the application through the OS etc. or present any state of the hardware observable to the application e.g. such as the state of various control registers within the system . Here the hardware event state stimuli   is essentially used to manipulate the hardware portion of the application s environment.

Whereas the run time environment has standard monitoring and stimuli functions embedded in the software platform beneath the application under test the static instrumentation engine returning to by contrast modifies the application code itself to include within itself special monitoring functions and or special stimuli functions. The monitoring functions report their results to the central intelligence engine and the stimuli functions are told what stimuli to generate by the central intelligence engine . As such the static instrumentation engine adds additional monitoring and stimuli functions to the application apart from the monitoring stimuli functions that are embedded in the application s underlying platform.

Notably mobile applications written for ANDROID of Google Inc. as well as applications written in Java whether mobile or desktop conform very well to the framework outlined in because they are normally executed with a first virtual machine e.g. a DALVIK virtual machine for ANDROID a Java Virtual Machine for Java . Applications written for iOS from Apple Inc. include an operative layer between the application and operating system objective C runtime in iOS that dynamically converts abstract code to a lower level code and therefore can be regarded as a first virtual machine for purposes of the present discussion.

Other applications e.g. for other systems may not normally use an available first virtual machine. In one approach applications that normally use an available first virtual machine are stimulated monitored in the dynamic runtime environment with one or more functions e.g. functions   and  M 2 among others being embedded in the first virtual machine level whereas applications that are not normally written to run on an available first virtual machine level e.g. an application that has been compiled to run on its underlying hardware CPU may have these monitoring functions embedded in the underlying OS instance or second virtual machine level of the run time environment . Alternatively one or more of these stimulation monitoring functions may be statically added to the applications themselves by the static instrumentation engine of . In the case of applications received in an encrypted form e.g. at least some iOS applications static instrumentation may not be an option.

According to one embodiment of the process flow of the static instrumentation engine an application to be observed is provided to the translator in a first low level form e.g. DALVIK .dex executable code . The translator translates the executable object code up to a higher more abstract code level e.g. in the case of .dex a .dex application is translated up to a RISC like version of Java byte code which contemplates fewer instructions in the instruction set architecture than pure Java byte code . The higher level code representation of the application is then provided to the application representation generation unit which studies the application s internal structures code flows etc. to generate a representation of the application such as a control flow graph that defines specific states of the application and various stimuli needed to cause a transition from one application state to another application state. The representation of the application is then provided to the explorer component   of the central intelligence function .

The explorer portion   of the central intelligence function analyzes the application representation to identify what parts of the application may correspond to improperly behaving code a region of interest within the code and what set of stimuli are needed to reach that code and activate it. Identification of a region of interest may be based on any of the user provided rules machine learned rules hard coded rules or observations made by the behavior and logic engine   that are reported to the explorer  . In an embodiment one or more of the identities of the types of regions of interest found in the application the types of stimuli needed to reach such code and the types of stimuli that might activate it are shared with the behavior and logic engine  . The behavior and logic engine   utilizes this information to establish a next set of acts stimuli to be performed on the application e.g. a next conflict set and establish e.g. at least partially specific behaviors of the application to be monitored.

As part of the definition of the next set of stimuli to be generated and or next set of behaviors to be monitored certain ones of the run time environment monitoring and or stimuli functions   to  M   to  P of may be enabled or disabled. Additionally certain already existing monitoring and or stimuli functions within the application itself may be enabled or disabled. Further still certain monitoring and or stimuli functions that do not exist in the application but should be are also identified. In the later situation the application needs to be instrumented with additional code that corresponds to the desired monitoring and or stimuli functions. Notably typically not all recursions of the behavior and logic engine   will necessarily require fresh instrumentation of the application. In those cases where instrumentation of the application is deemed appropriate however the central intelligence component communicates which specific monitoring and or stimuli functions need to be instrumented in the application.

In response the instrumentation unit instruments the abstracted translated version of the application s code with the desired monitoring and or stimuli functions. In cases where the application has already been instrumented with other static monitoring stimuli functions in an embodiment the application s state within the run time environment e.g. specific data values is externally saved outside the application and the application is returned to the static instrumentation engine . The static instrumentation engine retranslates the application with the translator unit and then instruments it with the new monitoring stimuli functions with the instrumentation unit . The retranslator retranslates the newly instrumented code to a lower level of code and provides it to the run time environment . The previously saved application state information is reloaded into the application.

In one embodiment a new application that has not yet entered the run time environment is instrumented with default static monitoring stimuli functions. In this case the new application is retranslated with translator a representation of the new application is generated with representation generation unit and presented to the explorer engine the explorer engine   identifies where the default static monitoring stimuli functions should be placed in the translated application s code structure and communicates these locations to the instrumentation unit the instrumentation unit instruments the translated application at the identified location s the re translation unit retranslates the statically instrumented application to a lower level code and the lower level code instance of the instrumented application is sent to the run time environment.

In an embodiment the application instrumentation unit can embed any of a system calls monitoring function a data tracking monitoring function and a device operation monitoring function as discussed above with respect to into the program code of an application. Again this approach may be particularly useful if the application does not normally run on a first virtual machine level. Likewise the application instrumentation unit can embed any of a data value stimulus function an OS event state stimulus function and a hardware event state stimulus function also as described above with respect to into the application instead of relying on such functions existing within the software platform beneath the application within the run time environment.

Moreover in an embodiment the application instrumentation unit can implement two additional types of monitoring stimulation into an application. The additional types of monitoring include i dynamic load monitoring and ii application API call event monitoring. The additional stimuli function includes application API call stimulation.

In the case of dynamic load monitoring the application is modified to track the effects of any code that the application dynamically loads. Here as is understood in the art an application may not initially include all of the code that it could execute. Instead the application includes references to network and or file locations containing additional code that the application will load under certain circumstances such as the application needs to execute it . An application typically executes the code it dynamically loads.

In the case of dynamic load monitoring the explorer engine   of the central intelligence unit analyses the representation of the application s internal structures flows looking for program code constructs that correspond to dynamic code loading. In a typical circumstance the application refers to dynamically loaded code with a character string. As such simplistically the explorer unit   looks for a character string associated with a dynamic load operation and causes the application instrumentation unit to add monitoring code into the application that will detect if the string is invoked as a dynamic load reference as well as monitor the behavior of any code that is dynamically loaded from the string and subsequently executed.

The instrumented monitoring code is also configured to report pertinent observations to the central intelligence function . Such observations include whether code has been dynamically loaded where dynamically loaded code was loaded from whether dynamically loaded code is being or has been executed and various behaviors of the executing code. The reported behaviors can include any of the behaviors described above with respect to the system call data tracking and device monitoring functions whether tracked within the application or beneath it .

In the case of application API call event monitoring the instrumentation code that is inserted into the application monitors calls made to the application during runtime and or events or other output generated from the API. Here as is known in the art an application is used by making a call to the application s application programming interface API e.g. by a user acting through a graphical user interface GUI . The API call event monitoring function detects such calls events output and reports them to the central intelligence function . Here the application itself may contain improperly behaving code that artificially invokes the application s API.

For example the improperly behaving code may artificially generate application API related actions to cause the application to believe a user is invoking the application for a specific use. The application API call monitoring function would detect any calls made to the API and report them. Knowing what precise user inputs were actually generated if any the central intelligence unit could determine that the API calls are malicious.

The application API stimulation function provides stimuli to the application through its API. Here the central intelligence function can ask the application to perform certain tasks it was designed to perform. By logging the stimuli applied to the application by way of the application API stimulation function and comparing these stimuli to reports received from the application API tracking function the central intelligence unit will be able to detect any API invocations made by malicious code. That is any detected API call that was not purposefully stimulated by the API stimulation function may be the act of malicious code.

The explorer component therefore i identifies sections of the application s code that are of interest ii identifies paths through the application s code that can be used to reach a particular region of interest within the code and iii identifies input stimuli that may be necessary to trigger one or more state transitions of the application along any such paths to the identified code regions of interest.

In performing these tasks the explorer is provided with monitored information from one or more of the above described monitor functions within the run time environment. The reports from the monitoring functions permit the explorer to identify the application s current state. For example based on the reported monitor information the explorer may determine that the application is currently within state  . Notably in order to receive this monitored information the explorer may have previously requested e.g. for a previous inference engine recursion that certain monitors be enabled and or that certain previously non existent static monitors be embedded in the application. Further still the explorer may have requested such a particular set of monitors because the explorer could not identify the application s state and needed to add the additional monitoring capability to determine it.

With the application s current state eventually recognized at state   the explorer is next able to identify a section of the application s code as being of interest . In the present example assume the explorer identifies code region as being of interest. Here the ability to identify a section of code as being of interest may be derived from any of the aforementioned rules. For example the aforementioned user provided rules may identify an item of data as being particularly sensitive. In this case the explorer might recognize that basic blocks of code region are written to process or otherwise use this item of data. As another example which may work in combination with the aforementioned example the aforementioned machine learning rules and or platform specific rules may identify a specific combination of states and associated basic blocks that correspond to the operation of improperly behaving code. Additionally or in the alternative the behavior and logic engine   may determine that based on its observations of the application that it may contain certain types of improperly performing code and notify the explorer component of these determinations. In response the explorer engine can look for corresponding region s of interest. That is the explorer component can look for code structure s profile s that correspond to the type s of improper code identified by the behavior and logic engine  .

With a region of interest having been identified the explorer next begins the process of determining a path through the code from the current state   to the region of interest . The exemplary path of essentially corresponds to the proper sequence of state transitions from state   to state  . As such the explorer attempts to understand and then cause the creation of the set of stimuli that will help cause this sequence of state transitions to transpire.

According to one approach referred to as symbolic execution the explorer reduces each basic block of each state to one or more logical expressions and their associated variables . Here ultimately each of the instructions of a basic block can be expressed as a logical axiom of some kind. The logical axioms of the basic block s instructions can be combined to form one or more logical expressions that express the processing of the basic block as a function of the data values now expressed as variables that are processed. The expression s are presented to a solver which determines whether a solution exists to the expression s and if so what the constraints are. Here typically the constraints correspond to limited ranges of the variables data values that are processed by the basic block s instructions.

Thus at this point the explorer has reduced the application s data values to specific limited combinations thereof that have the potential to cause the application to transition to a desired state. In an embodiment the explorer causes these solutions to be crafted as appropriate input stimuli to input stimuli embedded in the run time environment . Conceivably certain input stimuli functions will need to be enabled or instrumented into the application. Eventually e.g. through a limited trial and error approach the specific set of variables that lead to the correct state transition are realized. Repeating the process for each state eventually leads program execution to the region of interest .

Through these kinds of processes the explorer is able to efficiently direct program execution to regions of interest.

Upon reaching a region of interest the monitors within the runtime environment are set to observe the kinds of behaviors that will help determine whether the region of interest corresponds to improperly behaving code or not. Here the behavior and logic engine   receives the reported information from the monitors and can begin the process of determining whether the region of interest corresponds to improper behavior.

Thus in this fashion the explorer   is able to efficiently bring the application to various regions of interest and the behavior and logic engine   can determine whether the regions of interest correspond to improperly behaving code. Here thorough examination of the application can be achieved by repeatedly using the explorer   to bring the application to a next region of interest and the behavior and logic engine   to characterize the next region of interest. That is the overall behavior of the central intelligence can be somewhat recursive in nature where the explorer engine   repeatedly identifies respective regions of interest and what is needed to bring the code s execution to the region of interest. The explorer engine   and or behavior and logic engine   then instrument and or enable appropriate monitors and bring the application s execution state to the region of interest. The behavior and logic engine then receives the monitoring data and executes a series of inference engine recursions to reach a conclusion about the region of interest and or application. The overall process then repeats with the explorer engine   identifying a next region of interest. Throughout the process the explorer engine may also receive reported information from various monitors so it can determine confirm the present state of the application.

Notably in an embodiment comprehending the application s state includes the explorer engine   maintaining the state of the application s GUI so it can determine how the GUI triggers certain application acts to be performed e.g. the application representation utilized by the explorer engine   provides information that links specific GUI feature activations to specific processes performed by the application . With this information the explorer engine   can set input conditions that effectively use the GUI to bring the application s state to or at least closer to a desired region of interest within the application. Additionally the explorer engine e.g. with reference to applicable rules and behavior and logic engine notifications detects the presence of possible improper behaving code. Here certain types of improperly behaving code will attempt to trigger processes of an application by pretending to be a user that is using the application through the GUI. That is improperly behaving code within the application or external code that is in communication with will attempt to cause certain application actions by accessing various GUI triggers.

Apart from just the GUI more generally the explorer engine e.g. by reference to particular rules may also identify improper low level application behavior such as any improper state transition . This detected behavior can likewise be reported to the behavior and logic engine   which incorporates this information into a following inference engine recursion.

The explorer function also analyzes the application representation and based on characterization information from the behavior and logic engine and or one or more hard coded rules machine learned rules and or user provided rules identifies a region of interest within the application . The explorer engine determines stimuli that can be applied to the application to drive its execution to the region of interest . Based on the identified region of interest and or the determined stimuli the explorer and or behavior and logic engine determine what monitoring and stimuli functions and associated stimuli should be enabled . This may optionally include instrumenting the application itself with additional monitoring and or stimuli functions .

The determined stimuli are applied and the enabled monitoring functions report respective monitoring information . The behavior and logic engine uses the reported information to characterize the application s behavior and the explorer engine uses the reported information to track the state of the application . New stimuli and or monitoring functions may be determined which may require additional instrumentation of the application itself that are enabled and or otherwise applied . The process repeats until the region of interest is reached and characterized as safe or unsafe . Upon the region of interest having been characterized as safe or unsafe the explorer function re analyzes the representation to determine a next region of interest. When all identified regions of interest are identified the coverage analysis of the application is complete.

Although not shown in for simplicity in an embodiment the framework is also able to back out of its current analysis of a specific region of interest to redefine region s of interest and or jump to another region of interest e.g. because a newly suspected region of interest takes priority over the current region of interest .

Referring back to along with or apart from the customer provided rules the behavior and logic engine   and or explorer engine   may refer to hardcoded rules and or machine learned rules .

Hardcoded rules typically provide generic or well known public rules and or rules that have been written manually. For example certain viruses and other forms of mis behavioral code have signatures or other behaviors features that are widely known and rules to address them can be scripted by humans. For example rules that encapsulate the signature or behavior of a well known trojan horse virus may be hand written and added to database . Here for example database is a store that keeps rules for all known forms of mis behaving code and or handwritten rules. Upon bring up of the framework these rules are made accessible to the framework. Typically the hard coded rules are not provided by the user but are instead largely created or otherwise accessed by a software security entity e.g. a corporation that provides software security products that provides the framework of .

In a further embodiment database also provides platform specific information to the monitoring functions and or stimuli functions which are themselves generically written. For example in an embodiment the OS monitoring function is originally written around a set of generic OS calls e.g. save file read file etc. . These generic calls however have specific forms in a particular environment platform e.g. an iOS save file call has a certain syntax that is different than the syntax of an ANDROID save file call . Database therefore additionally provides platform specific information for the generic monitoring functions so they can detect events within a particular environment platform. Similarly database additionally provides platform specific information for generic stimuli functions that are used to generate stimuli that are particular to a specific environment platform e.g. a generic event generated according to its specific iOS form or ANDROID form .

In the case of the machine learning function and rules generated therefrom as is known in the art multiple e.g. millions of software instances and or environments some of which may be similar to the application being observed many of others of which may be nothing like the application being observed have been previously studied e.g. over the course of years by a machine learning system that has deduced from its observations of these software instances environments that certain behaviors can be characterized as improper and reduced to a set of rules which are then provided in rule set . For example a machine learning system could be trained on email messages to learn to distinguish between malware code and non malware code. After this learning it can then establish a set of rules that classify code as either malware or non malware.

In general a machine learning system will typically be given a task e.g. identify malware and gain experience attempting to satisfy that task with commensurate feedback as to its successes and failures. Over time with automated modification to the manner in which attempts to accomplish the task the machine learning system may recognize improvement in its ability to accomplish the task. In this sense the machine can be said to have learned. Eventually e.g. if its success in accomplishing the task crosses some threshold of success the machine learning system may identify rules for rule set that essentially educate the framework of with whatever the machine learning system has so far learned.

Because of the automated nature of machine learning the machine learning system can have a massive history of experience in terms of the number of software instances and environments it had observed and the amount of time over which it has been able to observe them. Here the machine learned rules provide details as to the specific behaviors of various improperly behaving forms of code that used by the behavior and logic engine   to determine whether the application s behavior corresponds to such mis behavior. Additionally the machine learned rules may provide details as to specific low level code structures of improperly behaving code that are used by the explorer engine   to identify regions of interest within the application.

The custom rules are entered through the user interface and incorporated into the set of rules that are referred to by the behavior and logic engine     and explorer engine     of the central intelligence function discussed at length in the preceding discussion s .

In a typical scenario the user rules will identify sensitive items of data that are operated on or otherwise processed by the application being analyzed. For example if the mobile application is designed to operate on information from a corporate database the custom rules will identify sensitive items of information from the database e.g. confidential and or highly confidential information . In response to these rules possibly in combination with other rules or input by the behavior and logic engine   the explorer engine   will identify as a region of interest any application code that operates on this information and cause execution of the application to be brought to any such region of interest.

The behavior and logic engine   will understand acceptable versus unacceptable uses of this information by the application and monitor the application s use of the information accordingly. For example the behavior and logic engine   may cause the application or its underlying platform in the runtime environment to perform data tracking on the information. Upon data tracking being enabled for one or more of the sensitive data items and the application having moved its execution to regions of interest that use the information through the influence of the explorer engine   the behavior and logic engine   will track locations where the data is actually stored and or sent and compare these locations against acceptable register system memory and non volatile memory storage locations where the sensitive information can be stored as well as acceptable network destinations e.g. network address locations where the information can be sent. These acceptable storage and or network address locations may be defined partially or entirely by the user through the user interface likewise unacceptable storage locations and or network destinations may also be identified .

Alternatively or in combination because data tracking may involve low level insight into the application the explorer engine may likewise be configured to detect improper low level movements of the data via detected improper state transitions within the application. Definitions of such improper movements transitions may additionally be provided to the explorer engine by the user through the custom user rules

In another typical scenario the user identifies improper behaviors e.g. an attempt to engage in a communication session with a particular location machine or database within a protected corporate intranet or attempts to access information within a protected or private region of system memory and or register space of the application s run time environment . Again the explorer engine   can attempt to identify regions of code that will perform the user identified improper action and bring the application s execution to such code. Either or both of the explorer engine   and behavior and logic engine   cause the application to be monitored appropriately. The explorer engine   causes the application s execution state to be brought to the region of interest and the behavior and logic engine   receives the monitoring data implements further points of analysis and ultimately reaches a conclusion whether the region of interest is malicious. If the improper behaviors are defined at the application state transition level the explorer engine can detect such improper behavior as well and report it to the behavior and logic engine.

As observed in an application and or its operating environment can also be retro fitted with various plug ins . Here plug in corresponds to one or more publically available plug ins and plug in corresponds to one or more mobile device management MDM plug ins. A plug in is essentially program code that implements an additional set of functions to the main application and or its underlying operating platform such as its virtual machine or operating system . For example an application or operating system may receive a plug in to process a new type of file format or perform a new function. In the later case a new GUI feature may appear after installation of the plug in.

Publically available plug ins are often downloaded from the Internet. They may be procured or free. MDM plug ins may be publically available or may be private code. They are typically used to manage the software environment of a smartphone or other mobile device. For example with an MDM plug in an IS department may be able to remotely configure monitor install un install and or enable or disable various functions and or software applications on any of its issued smartphones.

Here through the user interface a user is able to plug in any such plug in to the application before it is submitted to the static instrumentation engine for translation and representation generation. Here the representation generation function generates a representation of the application with any of the plug ins that the user has defined should be plugged into the application.

Applications may also be analyzed on their respective devices. In the case of a typical smartphone which does not contain a large scale virtual machine monitor layer the runtime environment discussed above with respect to showing multiple concurrent application instances executing on a virtual machine monitor layer may not be applicable. Instead the runtime environment will be as observed in . is similar to except that lower second virtual machine layer is missing.

Here feature corresponds to an actual mobile device and run time environment corresponds to the run time environment of the mobile device . The aforementioned possibilities for the locations and functions of various monitor functions and stimuli functions are as discussed in the applicable preceding sections above. In some implementations a user may not have the ability to change modify re install or replace the virtual machine layer or operating system in the device in which case all monitors and stimuli functions may be located within the application by way of instrumentation.

In a typical usage case a device with an application is communicatively coupled to the overall framework depicted in through an interface to the framework. The coupling may take various forms such as wireless and or hardwired. The wireless communication may be over any wireless network e.g. WWAN or WLAN or wireless point to point link e.g. Bluetooth .

In the case of typical network connectivity applications may be screened for safety on mobile devices that are in the field . For instance as just one example an application may be installed for actual use on mobile device that is active in the field but the application has been fully instrumented with all monitoring and stimuli functions. Should a need arise to confirm that the application is still safe while it is in the field e.g. because of a suspicious event or as matter of periodic check ups the rest of the framework can communicate with these instrumented functions as well as any monitoring and or stimuli functions that were embedded into the software layers beneath the application e.g. virtual machine operating system before the device was released into the field for actual use. With any standard communication session between the device and the framework e.g. over the Internet the application can be fully screened. That is monitors can send their respective monitoring information over the network to the framework and the framework can send commands to the stimuli functions and monitors over the network. Thus the application itself can be screened while it is

Hardwired communicative coupling may be achieved through the mobile device s standard hardware I O interface e.g. a USB interface . Here commands to the monitoring functions and stimuli functions are submitted by the framework to the mobile device through the interface . Likewise information from the monitoring functions are reported to the framework through the interface.

In the case of instrumentation of the application an instrumented application is created according to the processes discussed above in preceding sections and installed on the mobile device . If an instrumented application that is installed on the device needs to be instrumented with additional monitoring and or stimuli functions in an embodiment the state of the application is externally saved e.g. through the interface and into storage associated with the framework a new instance of the application having the new instrumentation set is created and installed on the device . The application state is then reloaded onto the mobile device through the interface and analysis of the application continues. Alternatively the application state could conceivably be stored on the mobile device rather than being externally stored. Further still in an embodiment because of possible difficulties associated with the saving of state information of an application that is installed on a mobile device as a default an application to be analyzed may be fully instrumented with a complete suite of monitors and stimuli functions before its initial installation on the mobile device. In this case no new instance of the application with additional instrumentation would ever need to be created.

Apart from analyzing an application the framework discussed above may also be used to modify application software so as to specifically prevent it from improper behavior. Here the instrumentation unit discussed above serves to insert additional code into an application so that it is specifically prevented from performing unwanted actions. As just one example an application may be retrofitted with software that prevents certain specific sensitive information from being transmitted from the smartphone that the application will be installed on.

The application is then translated by the application translation unit to e.g. create a higher level object code instance of the application . A representation of the application such as a control flow graph or other structure that describes the application s states and state transitions is created by the application representation generation unit from the abstracted application instance and submitted to the explorer component .

The explorer component studies the specified unwanted action s to be prevented and the code s representation and defines changes to made to the application s code to remove from the application any ability to perform the unwanted action s . For example if the unwanted action is the sending of certain sensitive information outside the application the explorer may define all possible exit points of information from the application. The explorer may further determine that a data monitoring function is to be embedded in the application that is configured to track the information. The explorer may further determine that additional code needs to be added to the application that will prevent the execution of any exit point if it uses information from a tainted source e.g. a tainted register location system memory location and or non volatile storage location . Alternatively or in combination the explorer may simply remove certain blocks of code from the application in order to remove the unwanted function from the application.

The explorer s determinations are then communicated to the instrumentation unit which instruments the application with code designed to effect the functions mandated by the explorer . The application is then retranslated to its original code level by the re translator and installed on a mobile device .

The types of unwanted behaviors that can be specified and prevented through the instrumentation process described above are too numerous to detail in full here. However some basic applications of the above described sequence are discussed immediately below.

In a first embodiment certain device functions are disabled. For example the audio function e.g. the ability of an application to turn on the microphone of a mobile device so it can internally process the audio information near it such as a conversation of a mobile device may be disabled. According to one approach the explorer determines any states within the application that could cause a command to be sent to the hardware and or OS to turn on the device s audio function and determines that such states should be modified to remove or otherwise squelch this ability.

In a further embodiment the disablement of the function is made conditional. For example the specific unwanted behavior may be that the audio device should be disabled whenever the device is within range of a certain wireless network out of range of a certain wireless network whenever the device is within one or more specific GPS location s or outside one or more specific GPS location s . Here the instrumentation code that disables the audio is written to only take effect if the stated condition is detected. To support this ability the explorer identifies the parts of the application code that are sensitive to the conditions needed to determine whether to enable disable the function. Apart from an audio device a network interface camera or video device may similarly be disabled as discussed above.

In a second embodiment an application s ability to engage in communication with an external system e.g. a packet exchange with another computer over a network is tightly controlled. Here permissible and or unwanted actions may be specified such the external communication is permitted only through specific networks not permitted over specific networks or types of networks e.g. public networks permitted only with specific systems e.g. servers or other computers not permitted with specific systems or types of systems.

In a third embodiment an application s ability to access data either external from the mobile device or internal to the mobile device is tightly controlled. For example network communications sessions with specific external computing systems may be prevented and or access to certain files or system memory regions within the mobile device may be prevent.

Other usage models of the framework are also possible where various parts of the framework other than just the machine learning and hard coded rules portions as in or the entire framework as in are provided as a cloud service .

Other usage models may direct applications for screening to the framework however it is implemented as part of their normal download and installation process. For example a user may chose to download an application from the Internet however before the application is allowed to be downloaded and installed on the user s device it is instead routed to the framework which analyzes it. Here the application is only permitted to be installed on the device if it is deemed safe by the framework.

Although the above discussion has been directed to the security analysis of application software on mobile devices it is pertinent to point out that the above described framework could also be applied to application software to larger systems such as a personal computers e.g. laptop and desktop systems and server systems.

The various components of the framework described above can be performed on any number of computing systems. At one extreme all of the components of the framework could be implemented on a single computing system e.g. on a large server system . Alternatively each of the components of the framework could be implemented on its own respective computer system apart from the other framework components and their respective computer systems. A single framework component could be implemented with multiple computer systems. A single computer system could contain some but not all of the components of the framework. A single framework component may be implemented on more than one computing system. Different combinations of various ones of these possibilities may be used to create a single framework. To the extent different computing systems are used to implemented the framework they may be communicatively coupled with one or more networks.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which cause a machine such as a virtual machine a general purpose CPU processor disposed on a semiconductor chip or special purpose processor disposed on a semiconductor chip to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

A storage medium may be used to store program code. A storage medium that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The applicable storage medium may include one or more fixed components such as non volatile storage component e.g. a hard disk drive FLASH drive or non volatile memory or system memory and or various movable components such as a CD ROM a compact disc a magnetic tape etc operable with removable media drive . In order to execute the program code typically instructions of the program code are loaded into the Random Access Memory RAM system memory and the processing core then executes the instructions. The processing core may include one or more CPU processors or CPU processing cores.

It is believed that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a Java 2 Enterprise Edition J2EE environment or environments defined by other releases of the Java standard or other environments.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

