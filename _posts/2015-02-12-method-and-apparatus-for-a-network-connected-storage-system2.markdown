---

title: Method and apparatus for a network connected storage system
abstract: A Data Storage Device (DSD) includes a Non-Volatile Memory (NVM) for storing data, a network interface for communicating on a network, and a processor. According to one aspect, a command is received via the network interface for storing data in the NVM or retrieving data from the NVM. Based on a transport attribute of the command, it is determined whether to execute a file interface for accessing files stored in the NVM or an object interface for accessing data objects stored in the NVM. According to another aspect, computer-executable instructions are received from a device via the network interface and the computer-executable instructions are executed using an off-load interface. The computer-executable instructions cause the processor to transform data stored in the NVM or data received from the network and send the transformed data to another device on the network or store the transformed data in the NVM.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621653&OS=09621653&RS=09621653
owner: Western Digital Technologies, Inc.
number: 09621653
owner_city: Irvine
owner_country: US
publication_date: 20150212
---
This application claims the benefit of U.S. Provisional Application No. 61 940 269 filed on Feb. 14 2014 which is hereby incorporated by reference in its entirety. This application also claims the benefit of U.S. Provisional Application No. 61 940 313 filed on Feb. 14 2014 which is hereby incorporated by reference in its entirety.

Data Storage Devices DSDs are often used to record data onto or to reproduce data from a storage media such as rotating magnetic disks or solid state memories such as flash. DSDs are conventionally used by a host that processes or transforms data and stores data in the DSD or retrieves data from the DSD. The DSD often accesses data stored in the DSD with a file system that organizes the data into files used by an application running on the host.

The growth of distributed computing mobile applications social media applications and big data applications i.e. the collection of large amounts of data or complex data has led to an increase in object based storage which generally allows for better scalability than file based storage. In many cases the data objects may never be accessed again but they are expected to remain accessible if needed. Examples of such data objects can include photos movies e commerce data or archival data stored across a network as in cloud storage. The growth of object based storage has created a need for a storage environment that can accommodate both file based storage and object based storage.

In addition distributed computing mobile applications social media applications and big data applications have led to the need for larger storage capacities to retain the data used by these applications. The traditional model of a host retrieving data from a DSD processing the retrieved data and storing the processed data back in the DSD may not provide the most efficient use of resources in terms of processing efficiency or network traffic when dealing with large amounts of data distributed among different DSDs. In addition data storage systems will need to provide for more flexibility in handling data such as allowing for the use of new interfaces and applications being developed in fields such as distributed computing.

In the following detailed description numerous specific details are set forth to provide a full understanding of the present disclosure. It will be apparent however to one of ordinary skill in the art that the various embodiments disclosed may be practiced without some of these specific details. In other instances well known structures and techniques have not been shown in detail to avoid unnecessarily obscuring the various embodiments.

In the example of DSD includes one or both of solid state memory and rotating magnetic disk as Non Volatile Memory NVM for storing data. If both are included DSD can be considered a Solid State Hybrid Drive SSHD in that it includes both solid state and disk NVM. In other embodiments DSDs or can include different types of NVM such as for example a magnetic tape drive or the NVM of DSDs or may only disk NVM or solid state NVM. In yet other embodiments each of disk or solid state memory may be replaced by multiple Hard Disk Drives HDDs or multiple Solid State Drives SSDs respectively so that DSD includes pools of HDDs or SSDs. Along these lines and as an example of a further example environment the embodiment of depicts data storage system with multiple Hard Disk Assemblies HDAs each including at least one rotating magnetic disk and at least one head for accessing data on a corresponding disk surface.

In the example environment of DSD includes System on a Chip SoC which includes circuitry for executing instructions and can include a microcontroller a Digital Signal Processor DSP an Application Specific Integrated Circuit ASIC a Field Programmable Gate Array FPGA hard wired logic analog circuitry and or a combination thereof. An example arrangement of SoC is discussed in more detail below with reference to .

Network interface is configured to connect DSD with network using for example an Ethernet connection or a WiFi wireless connection. Network interface allows DSD to interface with other devices on network e.g. host or DSD using a protocol such as TCP IP. As will be appreciated by those of ordinary skill in the art network interface can be included as part of SoC . In other embodiments network interface may be replaced with an interface for communicating on a data bus according to a standard such as Serial Advanced Technology Attachment SATA PCI express PCIe Small Computer System Interface SCSI or Serial Attached SCSI SAS .

As shown in DSD also includes sensor for obtaining environmental information about an environmental condition of DSD . Sensor can include one or more environmental sensors such as for example a mechanical shock sensor a vibration sensor an accelerometer e.g. XYZ or YPR accelerometer a temperature sensor a humidity sensor or an air pressure sensor. In addition one type of sensor can be used to indicate multiple environmental conditions. For example an accelerometer can be used to indicate both vibration and mechanical shock conditions or an air pressure sensor can be used to indicate changes in altitude and changes in air pressure. In other embodiments DSD may obtain data from an external sensor such as a camera a radio frequency sensor or Radar.

In the example of disk is rotated by a Spindle Motor SM . DSD also includes head connected to the distal end of actuator which is rotated by Voice Coil Motor VCM to position head in relation to disk . SoC can control the position of head and the rotation of disk using VCM control signal and SM control signal respectively.

As appreciated by those of ordinary skill in the art disk may form part of a disk pack with additional disks radially aligned below disk . In addition head may form part of a head stack assembly including additional heads with each head arranged to read data from and write data to a corresponding surface of a disk in a disk pack.

Disk includes a number of radial spaced concentric tracks for storing data on a surface of disk . Tracks can be grouped together into zones of tracks with each track divided into a number of sectors that are spaced circumferentially along the tracks.

In some implementations some or all of tracks can be written by a write element of head using Shingled Magnetic Recording SMR so as to overlap adjacent tracks. SMR provides a way of increasing the amount of data that can be stored in a given area on disk by overlapping tracks like roof shingles. The non overlapping portion then serves as a narrow track that can be read by a read element of head . In other implementations all of tracks may be written such that they do not overlap by using Conventional Magnetic Recording CMR .

Although a higher number of tracks per inch is ordinarily possible with SMR the overlap in tracks can generally prevent new writes to a previously overlapped track since such new writes would affect data written in the overlapping track. For this reason tracks are usually sequentially written in SMR implementations to avoid affecting previously written data.

In addition to or in lieu of disk the NVM media of DSD may also include solid state memory for storing data. While the description herein refers to solid state memory generally it is understood that solid state memory may comprise one or more of various types of memory devices such as flash integrated circuits Chalcogenide RAM C RAM Phase Change Memory PC RAM or PRAM Programmable Metallization Cell RAM PMC RAM or PMCm Ovonic Unified Memory OUM Resistance RAM RRAM NAND memory e.g. Single Level Cell SLC memory Multi Level Cell MLC memory or any combination thereof NOR memory EEPROM Ferroelectric Memory FeRAM Magnetoresistive RAM MRAM other discrete NVM chips or any combination thereof.

Memory can represent a volatile memory of DSD such as Dynamic Random Access Memory DRAM for temporarily storing data used by SoC . In other embodiments memory can be an NVM such as MRAM. In addition memory can be included as part of SoC in other embodiments. Those of ordinary skill in the art will also appreciate that other embodiments may include less than all of the items depicted as being stored in memory .

In operation a processor of SoC e.g. processor shown in accesses information stored in memory during execution of computer executable instructions in software programs such as application Operating System OS file system s file interface s object interface s off load interface s driver s or application s . More specifically SoC can load computer executable instructions from an NVM of DSD e.g. disk or solid state memory into a region of memory and then execute the stored process instructions from memory .

Application OS is an embedded OS of DSD in the sense that application OS is executed on DSD and not executed on a host such as host . Application OS manages hardware and software resources of DSD and can include for example a Linux OS Android OS Windows OS Mac OS or a customized OS. Hardware resources managed by application OS can include for example network interface solid state memory disk memory and one or more processors in SoC e.g. processor shown in . Software resources managed by application OS can include for example file system s file interface s object interface s off load interface s driver s or application s .

File system s can include one or more file systems for accessing or organizing files stored in NVM of DSD . By executing a file system on DSD it is ordinarily possible to tailor the file system to a particular storage media used by DSD to store data. In one example file system s can include a file system that may be well suited to sequentially writing data on SMR media such as Linear Tape File System LTFS or a log structured file system like New Implementation of a Log structured File System NILFS . Other file systems of file system s can include for example B tree file system Btrfs ext2 ext3 ext4 or XFS. File system s can operate in a kernel space of application OS as shown in the example of the kernel space of .

File interface s provide one or more file system interfaces for retrieving or storing data as files in NVM of DSD via network . Such file interfaces can include for example network file systems such as Common Internet File System CIFS Network File System NFS or Server Message Block SMB . File interface s can operate in a kernel space of application OS .

Object interface s provide an object based storage interface for retrieving or storing data as data objects in NVM of DSD via network . Such an object interface can include for example Amazon Web Services Simple Storage Service AWS S3 . Object interface s can operate in a user space as shown in .

Object based storage at DSD can provide several advantages over file based storage such as a better use of the full capacity of the storage media and more efficient accessing of data by making the DSD more data aware of what is being accessed. In one example object interface s can provide additional information about data objects with metadata pertaining to for example the ownership of the data object the creation date of the data object or the type of data object so that certain data objects or related data can be cached e.g. stored in memory for quicker access.

Off load interface s provide a way of shifting processing from a host on network e.g. host to DSD . In one implementation host sends computer executable instructions to DSD via network interface . A processor of SoC e.g. processor executes the computer executable instructions to create an off load interface for accessing or transforming data stored in NVM of DSD . Off load interface s can operate in a kernel space of application OS as shown in .

Examples of an off load interface can include a Ceph or OpenStack software platform or a Hadoop software framework. In some implementations a processor of SoC may partition its available storage capacity in NVM e.g. available data capacity in disk and solid state memory based on areas reserved for different interfaces. For example a processor of SoC may reserve 20 of its NVM storage capacity to AWS S3 storage 30 to Ceph functions and 50 to OpenStack functions. The NVM of DSD could also be dynamically allocated as needed. In one example 10 of NVM could be reserved for AWS S3 storage 10 for Ceph functions 10 for OpenStack functions and 70 to be allocated among AWS S3 Ceph and OpenStack as needed. As discussed in more detail below with reference to below off load interface s can also provide for distributed compute applications that allow DSD to act as a compute node in a cluster of DSDs on network .

Driver s can include software for interfacing with a firmware of DSD e.g. controller firmware or servo firmware shown in or a firmware of network interface and can execute in a kernel space of application OS as shown in . Driver s can also allow for interfacing with other devices on network such as DSD .

Application s can include applications developed by a manufacturer of DSD and or independently developed applications that have been downloaded from network . For example DSD may receive computer executable instructions from host via network interface and then execute the computer executable instructions to create an application . In some implementations a Software Development Kit SDK e.g. SDK shown in could be made available to allow users on network to develop their own applications to run on DSD .

Application s or driver s can include data storage related applications such as sniff and store applications to collect information about data use e.g. identify file types attributes IP addresses and store traffic information a user interface for operating DSD DSD health monitoring for monitoring a reliability of DSD and or migrating data to another DSD or NVM within DSD before losing data data encryption data compression erasure coding or error correction directing data for storage on disk or solid state memory based on attributes of the data e.g. tiered storage deduplication of data stored in DSD or mirroring data e.g. data backup .

In addition application s or driver s can customize DSD for specific uses such as working with sensor data e.g. where application might include MATLAB or LabVIEW streaming certain types of media over network configuring DSD to operate as a DVR or media server managing the synching or backup of compute devices providing a Bluetooth connection such as for an A V system providing a WiFi hotspot or configuring DSD to operate as a Network Attached Storage NAS . Application s or driver s can also provide for certain network functions on network such as bit coin mining identification of another DSD on network and identification of data stored on another DSD migration or copying of data from a failed DSD NVM to another DSD NVM in the network or the rerouting of data to other DSDs in the network based on environmental conditions such as vibration or temperature detected by sensor .

In one implementation an application can allow a processor of DSD e.g. processor of SoC shown in to monitor at least one indicator of a reliability of another DSD on network e.g. DSD for storing data with the use of network interface . An indicator of reliability could include for example a number of errors in retrieving or storing data on the other DSD or an amount of use of a particular NVM of the other DSD such as a number of Program Erase P E cycles for a flash memory of the other DSD. In some cases the application may also cause a processor of DSD to copy data from another DSD to an NVM of DSD if one or more indicators of reliability for the other DSD reach an unsafe or undesirable threshold.

In another implementation an application can cause a processor of DSD to receive an input from sensor indicating an environmental condition of DSD such as a vibration condition an air pressure condition a humidity condition or a temperature condition. The processor can then determine whether the input exceeds an unsafe or undesirable threshold. If the input exceeds the threshold the processor can redirect at least one command to store data in NVM of DSD to another DSD on network e.g. DSD . The processor may also request environmental condition information from other DSDs on network to identify another DSD to receive one or more redirected commands. In addition the processor may stop redirecting commands if a subsequent input from sensor indicates that the subsequent input has fallen below a threshold thereby indicating that it is safe to store data in an NVM of DSD .

Data included in mapping write pointers command queue buffer or data to be stored in or retrieved from NVM can also be stored in memory so that the data can be accessed by a processor of DSD e.g. processor shown in during execution of software programs to the extent that such software programs have a need to access and or modify the data. In addition to shifting processing from host to DSD with off load interface s running application OS at DSD can allow for shifting tasks to file system s driver s and or application s that may otherwise have been performed by firmware e.g. controller firmware shown in of DSD . In addition to the tasks mentioned above of data encryption data compression erasure coding or other error correction the direction of data for storage on disk or solid state memory deduplication of data and data mirroring a processor of DSD e.g. processor shown in executing file system s driver s or application s can use mapping write pointers command queue and buffer to perform other tasks related to the management of storage media in DSD . By moving one or more such tasks from a firmware of DSD to a file system application or driver executed on a processor of DSD the tasks can be more easily modified in the field and the firmware of DSD can be simplified.

In one example mapping can map logical addresses e.g. Logical Block Addresses LBAs for data to physical addresses e.g. block addresses corresponding to locations in NVM of DSD that store the data. This can allow for a processor executing application OS to direct data to a particular NVM e.g. disk or solid state memory or particular zones within an NVM based on attributes of the data. Mapping may also be stored in an NVM of DSD such as disk or solid state memory so that mapping is available after DSD has been powered off. Alternatively memory may be an NVM such as MRAM.

In some cases a processor of DSD executing application OS may perform address indirection using mapping to make better use of storage media such as zones of overlapping tracks i.e. SMR zones on disk or cells not shown in solid state memory . In the case of solid state memory the processor may use a mapping indirection system to facilitate the rewriting of data associated with a particular logical address at different physical locations on the storage media to provide for wear leveling so that solid state memory is more evenly used to prolong a usable life of solid state memory .

In the case of SMR tracks on disk a processor executing application OS may use indirection to facilitate the rewriting of data associated with a particular logical address at different physical locations on disk while maintaining a sequential writing. When data is updated for a particular logical address the update is often written in a different location on disk than where the data for the logical address was previously written to avoid having to rewrite an entire SMR zone of overlapping tracks. Mapping can be used to keep track of where the current versions of the data are stored for a particular logical address.

Write pointers can be used by a processor executing application OS to keep track of a location for performing a next write in a sequentially written zone such as an SMR zone on disk . Write pointers may also be stored in an NVM of DSD such as disk or solid state memory so that write pointers are available after DSD has been powered off.

In another example a processor executing application OS may reorder the performance of pending write commands in command queue so that the data to be written in performing the pending write commands follows an increasing or decreasing order of logical addresses to be written. In one example the processor may group the order of performance of commands by host so that all of the commands from a particular host are performed in a sequential manner. Such an ordering of commands can allow for an improved overall performance in processing the commands. In addition the processor can manage command queue and mapping so that all of the write commands from a particular host are written in a localized area of NVM such as in a particular zone of tracks on disk . The processor may also reorder the performance of pending read and write commands for disk as part of a Rotational Position Optimization RPO algorithm to reduce the amount of movement needed in positioning head over disk in performing the commands.

Buffer may be used by a processor executing application OS in performing Read Modify Write RMW operations on disk such as garbage collection to reclaim portions of disk storing invalid or obsolete data. In such an operation the processor may read a zone of tracks and store the valid data from the zone in buffer before rewriting the valid data on disk . In addition the processor may identify or prioritize a particular zone for garbage collection by determining a level of invalid or obsolete data stored in the zone and or a frequency of use of the zone.

In one implementation each of processors and is a processor core such as an ARM M3 processor. In another implementation processor can include an ARM A5 or A6 processor while processors and can be ARM M3 processors. In yet other implementations different types of processors can be used such as Intel processors.

As shown in processor executes application OS file system s file interface s object interface s off load interface s driver s and application s . Processor interfaces with memory in executing such software and interfaces with network interface in communicating via network .

As discussed above having application OS embedded or running on DSD can provide several advantages over conventional DSDs that do not locally execute an embedded application OS. Such advantages include the ability to support TCP IP over Ethernet or WiFi interfaces e.g. via network interface the ability to embed a file system e.g. file system s that is better adapted to a particular storage media of DSD and to allow for new applications e.g. application s to be developed for different uses of DSD . As will be appreciated by those of ordinary skill in the art one or both of processors and may run a Real Time Operating System RTOS that is intended to perform real time processes for servo firmware or controller firmware . In contrast processor runs application OS which allows for the execution of file system s file interface s object interface s off load interface s driver s and or application s as discussed in more detail below.

In storing or retrieving data from NVM of DSD processor executes application OS to interface with processor which executes controller firmware . Controller firmware controls operation of the NVM of DSD and may be stored in a dedicated memory of SoC e.g. a flash memory not shown or may be stored on other NVM of DSD such as disk or solid state memory .

As noted above the use of an application OS at processor can allow for a simplified firmware of DSD . In more detail many of the tasks conventionally performed by executing DSD firmware may be shifted to software executed by processor . As a result controller firmware in some implementations may primarily serve only to store or retrieve data in NVM with many of the maintenance operations for the NVM being performed by file system s driver s and or application s . Tasks that may be shifted to processor can include for example data encryption data compression erasure coding or other error correction data deduplication data mirroring the direction of data for storage on disk or solid state memory based on attributes of the data the direction of data for storage in a CMR zone i.e. a zone of non overlapping tracks or an SMR zone i.e. a zone of overlapping tracks of disk based on attributes of the data address mapping with mapping maintenance of write pointers ordering of command queue or garbage collection using buffer .

In operation processor can execute application OS to interface with processor and send a command to processor to retrieve data from or store data in disk or solid state memory . The interface between processor and processor can be object based use a standard such as SAS or SATA or be a custom interface. In the case of an object based interface processor can use application OS to execute object interface to send a command to retrieve store or delete particular data objects stored in disk or solid state memory . In the case of using a standard such as SAS or SATA processor can use a file system a file interface or a driver to send read write or trim commands for particular LBAs associated with the data. In the case of a custom interface a manufacturer may provide a customized file system or a driver to send commands to processor .

If access to disk is needed processor communicates with processor which executes servo firmware . In this regard processor controls SM via SM control signal to rotate disk . Processor also controls VCM via VCM control signal to position head over disk .

As shown in object interface s and application s can run in a user space and can access libraries and in the user space to make system calls to a kernel of application OS e.g. kernel . Libraries and can include for example specific OS libraries such as Android s SQLite or protocols such as Google Buffer Protocols or AWS protocol.

Hardware drivers such as network interface driver HDD driver and Solid State Memory SSM driver can operate in the kernel space. Off load interface s file interface s and file system s can also operate in the kernel space. In other implementations a driver or file system may be treated like application s and run in user space instead of kernel space e.g. a customized DSD driver or a File System in User Space FUSE .

In block processor uses application OS to send a command to processor to retrieve data from NVM e.g. disk or solid state memory or to store data in NVM. As discussed above the command to processor can be object based in specifying device block addresses or the command to processor can specify LBAs for the data with a standard such as SAS or SATA. In this regard application OS may execute a file interface an object interface or a driver such as HDD driver or SSM driver to retrieve or store data in the NVM.

In block processor executes the computer executable instructions received in block to install an application or install an interface such as an object interface or off load interface . As discussed above application s can include applications developed by a manufacturer of DSD and or applications developed by others. In some implementations an SDK e.g. SDK shown in could be made available to allow users on network to develop their own applications to run on DSD with access to certain libraries such as library or .

In the example shown in host applications can interface with DSD via host file system and NFS SMB mount or through client library with or without FUSE . When host interfaces through NFS SMB mount a file interface such as CIFS SMB mounts to host file system which can send commands from processor to processor of DSD to retrieve data or store data in NVM such as disk or solid state memory .

When host interfaces with DSD through client library an object interface such as AWS S3 or an off load interface such as Ceph Hadoop or OpenStack executing in processor can perform object commands such as Create Read Update and Delete CRUD commands on objects stored in NVM of DSD . In this regard the object interface or the off load interface may send a read or write command to processor to access the data stored in NVM.

Each of the example interfaces executed at DSD i.e. CFS NFS AWS S3 Ceph Hadoop OpenStack is implemented by application OS within a software container such as a docker in a Linux OS to provide an additional layer of abstraction and resource isolation. This can be accomplished for example with different namespaces that allow for different software containers to operate in a single instance while generally avoiding the overhead associated with running a Virtual Machine VM .

In block processor receives a command for storing data in NVM or retrieving data from NVM. The data is received by processor from network via network interface and may come from a host or client e.g. host on network or from another DSD e.g. DSD on network .

In block processor determines whether to execute a file interface or an object interface based on a transport attribute of the command received in block . provides an example of the receipt of commands with different transport attributes. In the example of DSD receives multiple commands i.e. commands to N from network . Each of the commands are directed to an appropriate interface such as a file interface an object interface or an off load interface based on a socket i.e. sockets to N that receives the command. In one implementation an interface e.g. file interface object interface or off load interface may create a socket and a service e.g. services 1 2 or 3 of application OS routes an incoming command to the appropriate interface based on a socket address included with the command that may specify a protocol local address local port remote address and remote port. In such an implementation the socket address of the command can serve as a transport attribute that can be used by application OS to determine whether to use a file interface an object interface or an off load interface .

Returning to processor in block performs the received command using the interface determined in block . In the case where a file interface is used processor can interface with processor using a standard such as SATA or SAS. In the case where an object interface is used processor can either provide processor with LBAs for the data object or can provide device block addresses for the data object without specifying LBAs. Processor may also use a custom interface with either of file interface or object interface .

In block processor executes a file interface to represent data from the first and second data objects as a file. In one example the file may be represented to a device on network based on a request received from the device to retrieve data stored in NVM of DSD . In this regard different devices on network may interface with DSD using different interfaces of DSD . For example one host on network executing a particular file system may retrieve and store data on DSD by specifying LBAs associated with the data in the host s file system while another host on network may retrieve and store data on DSD by specifying Object IDs OIDs that are uniquely associated with particular data objects stored in network . By using both file interface and object interface it is ordinarily possible for DSD to perform commands received from a device using a file system and from a device using object based storage. This arrangement can allow for more flexibility in the devices and software used on network and the distributed functions that can be performed on network .

In block processor executes an object interface to represent data from the first file and the second file as a data object. In one example the data object may be represented based on a request received from a device such as host to retrieve data stored in NVM of DSD . As noted above with respect to different devices on network may interface with DSD using different interfaces of DSD .

As described in more detail with reference to below the use of an off load interface executed on DSD can allow for processing at DSD that might otherwise be performed by host or by other hosts clients in network . By off loading or shifting processing closer to where data is stored it is ordinarily possible to process data more efficiently and reduce network traffic since the data to be processed does not need to be retrieved by a host or client. In addition data that is locally processed by a DSD in some cases may not need to be sent back to the host or client which further improves overall processing efficiency and network traffic. These improvements are particularly apparent where large amounts of data need to be processed.

In block processor executes the computer executable instructions using an off load interface to transform data stored in NVM of DSD or data received from network via network interface . Examples of the off load interface can include for example a Ceph software platform a Hadoop software framework or an OpenStack software platform. The computer executable instructions received in block can then correspond to the particular off load interface used by processor .

In block processor using the off load interface sends the transformed data to another device on network and or stores the transformed data in NVM of DSD . As discussed in more detail below with reference to in some implementations the transformed data can be sent to another DSD in a cluster of DSDs for further processing or transformation of the transformed data.

In block processor optionally authenticates the data received in block to verify that the data came from a device on network . In one implementation an off load interface or an application can be used to apply a public key to verify a digital signature encrypted by a device on network that sent the data using the device s private key. Other methods of authentication may be used in other implementations. In other embodiments block can be omitted.

In block processor using the off load interface optionally identifies a portion of the data received in block for transformation based on a predetermined criterion. The predetermined criterion can result from execution of computer executable instructions received from host via network interface . For example processor may receive data corresponding to a set of digital photographs. The computer executable instructions received from host can configure processor to identify portions of the data corresponding color photographs that are to be transformed into black and white photographs. This may be based on attributes of the data or in the case of data objects metadata sent with the data objects indicating that a particular data object corresponds to a color photograph.

In block processor executes computer executable instructions received from host via network interface to transform the data received in block . In one implementation the computer executable instructions may cause processor to transform the received data by combining the received data with data stored in NVM of DSD . For example the computer executable instructions can cause processor to add a zip code from a data structure stored in NVM when the received data includes an address that is missing a zip code.

In block processor optionally generates metadata concerning the transformed data. In one example the metadata may provide statistical information about the transformed data such as a count of a certain type of data received by DSD . The metadata can be stored in NVM of DSD and or sent to a device on network via network interface . In other embodiments block can be omitted.

In block processor executing the off load interface stores the transformed data in NVM of DSD and or sends the transformed data to another device on network via network interface . As discussed below with reference to the transformed data can be sent to another device on network for further processing or storage of the transformed data.

In block processor optionally authenticates the data retrieved in block to verify that the data is the correct data or that the data has not been altered. In one implementation an off load interface or an application can be used to authenticate the retrieved data with a cryptographic hash function. Other methods of authentication may be used in other implementations. In other embodiments block can be omitted.

In block processor using the off load interface optionally identifies a portion of the data retrieved in block for transformation based on a predetermined criterion. In some implementations the predetermined criterion can result from execution of computer executable instructions received from host via network interface . In other embodiments block can be omitted.

In block processor using the off load interface transforms the data retrieved from NVM in block . In block processor optionally generates metadata concerning the transformed data and sends the metadata to a device on network and or stores the metadata in NVM of DSD . In one example the generated metadata provides statistical information concerning the transformed data. In other embodiments block can be omitted.

In block processor executing the off load interface stores the transformed data in NVM of DSD and or sends the transformed data to another device on network via network interface . As discussed below with reference to the transformed data can be sent to another device on network for further processing or storage of the transformed data.

Raw data is fed to DSD from a device on network e.g. a host client or DSD where DSD executes the executable instructions received from host to transform the raw data into first transformed data. The transformation of the raw data can follow a process such as the process described above for .

The first transformed data is sent to DSD which further transforms the first transformed data into second transformed data before sending the second transformed data to another DSD in cluster . This process may continue for a set number of transformations or until a particular result is obtained. In other embodiments the second transformed data can be stored at DSD without sending the second transformed data on to a next DSD in cluster .

As shown in the DSDs in cluster are arranged in three tiers to perform a MapReduce function. A MapReduce function can provide for parallel processing of a large data set to search analyze log and or return a reduced data set. In the example of raw data is mapped using a first tier of DSDs to output transformed data to a second tier of DSDs which shuffles or redistributes the transformed data to a third tier of DSDs to perform a reduce function. Other embodiments may include more than three tiers of DSDs or may include more DSDs than those shown in for each tier.

In one example DSDs and store the raw data and transforms the raw data using a process such as the process described above in and sends the transformed data to DSDs and in a second tier of cluster . DSDs and store the transformed data and further transform the data and directs the transformed data to DSD in a third tier of cluster which reduces the transformed data to a result that is stored in DSD .

In one example the MapReduce function can be used to identify certain combinations of DNA from sets of raw DNA sequences received in the first tier of cluster . The second tier of cluster can be used to further refine the identified DNA combinations based on a narrower set of characteristics before sending the refined data set to the third tier for further reducing. Since each set of DNA combinations is stored on a DSD in cluster a different reduction can subsequently be performed using a different set of characteristics at different tiers. A similar application of a MapReduce function can be used for example with chemical bacterial or viral analysis.

In another example the MapReduce function can be used for photo analytics where raw photos are stored in the first tier and search criteria at the first tier is used to filter the raw photos to a reduced set of photos that are then stored in the second tier. The reduced set stored in the second tier can be further reduced for example by location using cell phone logistical information applied by an off load interface at DSD .

In another example the MapReduce function can be used to analyze shopping behaviors. Raw data stored in the first tier can include data for all shoppers including items purchased and the time of purchase. The transformed data stored in the second tier can include data for shoppers who bought a particular item during a certain time period. The third tier of DSD can store transformed data identifying which of the shopping data stored in the second tier includes items purchased with a coupon. In such an example the resulting data stored in DSD can be used to target marketing to particular shoppers.

In another example cluster can be used for an Internet or Intranet search engine function where the first tier of DSDs store a raw set of searches parsed by user the second tier stores transformed data reduced to the most frequent searches and the most frequent users to enable faster retrieval and the third tier can be used to further reduce the transformed data to very high frequency searches such as viral hits.

In yet another example the MapReduce function of cluster can be used to perform sound analysis. The first tier could store all sounds from all sources and locations the second tier could store a subset of the raw data based upon search criteria i.e. known voice matching or recognition background noise identification or machine noise recognition and the third tier of DSD may match the data stored in the second tier to a particular sound or location for a criminal investigation.

As demonstrated by the five examples provided above many more example applications of cluster with a MapReduce are possible within the scope of this disclosure.

As discussed above by using an off load interface at a DSD it is ordinarily possible to improve processing efficiency and network traffic in a distributed system by taking advantage of local data processing. In addition the use of a off load interface as described above can allow for a wider variety of devices software and functions to be performed in a network of DSDs.

As shown in bridge includes network interface for communicating on network memory and processor for executing certain software discussed above. Network interface can for example allow processor to communicate on network using TCP IP over Ethernet or WiFi. Memory can represent a volatile memory of data storage system e.g. DRAM for temporarily storing data used by bridge or SoC . In other embodiments memory can be an NVM such as MRAM.

In the example of processor is configured to execute application OS file system s file interface s object interface s off load interface s driver s and application s . Application s can include applications developed by a manufacturer of data storage system and or independently developed applications that have been downloaded from network . For example data storage system may receive computer executable instructions via network interface and then execute the computer executable instructions to create an application . In some implementations an SDK e.g. SDK shown in could be made available to allow users on network to develop their own applications to run on data storage system .

Driver s or application s can include data storage related applications such as sniff and store applications to collect information about data use a user interface for operating data storage system an HDA health monitoring for monitoring HDA reliability and or the migration of data to another DSD on network or NVM within data storage system before losing data data encryption data compression an erasure coding or error correction directing data for storage in a particular NVM of data storage system e.g. tiered storage deduplication of data stored in data storage system or mirroring data e.g. data backup among HDAs of data storage system .

In addition driver s or application s can customize data storage system for specific uses such as streaming certain types of media over network or configuring data storage system to operate as a DVR or media server. Driver s or application s can also provide for certain network functions on network such as bit coin mining identification of another DSD or data storage system on network and identification of data stored in another DSD or data storage system migration or copying of data from a failed DSD or HDA NVM to another DSD or HDA NVM on network or the rerouting of data to other DSDs in the network based on environmental conditions such as vibration or temperature.

Data included in mapping write pointers command queue buffer or data to be stored in or retrieved from HDAs can be stored in memory so that the data can be accessed by processor during execution of software programs to the extent that such software programs have a need to access and or modify the data. In addition to shifting processing from a host on network to data storage system with off load interface s running application OS at processor can allow for shifting tasks to file system s driver s and or application s that may otherwise have been performed by firmware of data storage system e.g. controller firmware . In addition to the tasks mentioned above of data encryption data compression erasure coding or other error correction the direction of data for storage in HDAs based on data attributes the direction of data for storage in different zones of NVM e.g. SMR zones and CMR zones deduplication of data and data mirroring processor can use mapping write pointers command queue and buffer as described above for the embodiment of to perform other tasks related to the management of HDAs in data storage system . By moving such tasks from controller firmware to a file system application or driver executed on processor the tasks can be more easily modified in the field. For example a new HDA can be added as part of data storage system that may require or benefit from a new driver or new application that can be more easily added to bridge than by changing a firmware of data storage system . In addition shifting more tasks to software operating on processor from firmware of data storage system can ordinarily allow for a simplified firmware.

Unlike the example embodiment of processor interfaces with processor of SoC that executes interface firmware for interfacing with processor . The interface between processor and processor can be accomplished using a bus standard such as for example SATA PCIe SCSI or SAS. In other implementations processor may use an object interface or a custom interface such as a customized file system or off load interface to provide processor with for example device block addresses indicating a physical location for retrieving or storing data objects in HDAs or .

SoC also includes processor for executing controller firmware and processor for executing servo firmware . In other embodiments two or more of processors or can be combined into a single processor. In the example of each of processor and communicate with HDAs and to retrieve data from the HDAs and store data in the HDAs. In this regard SoC may include one or more multiplexers not shown for sending signals such as VCM control signals SM control signals or read write signals to each of HDAs and . Processors and can be configured to interface with one HDA at a time or with multiple HDAs at the same time depending on different design criteria for data storage system . In one example processors and may only interface with one HDA at a time to conserve power in a data archive implementation. In another example processors and may interface with multiple HDAs at the same time to offer quicker access to mirrored data stored on rotationally synchronized disks in different HDAs.

In this regard each of HDAs and can include one or more rotating magnetic disks such as disk in together with one or more heads for reading and writing data on a disk surface. As with the embodiment of the heads used in HDAs and can be positioned relative to a corresponding disk surface by moving an actuator with a VCM.

As shown in controller includes network interface for communicating on network memory and processor . Network interface can for example allow processor to communicate on network using TCP IP over Ethernet or WiFi. Memory can represent a volatile memory of data storage system e.g. DRAM for temporarily storing data used by controller . In other embodiments memory can be an NVM such as MRAM.

In the example of processor is configured to execute application OS file system s file interface s object interface s off load interface s driver s and application s . Application s can include applications developed by a manufacturer of data storage system and or independently developed applications that have been downloaded from network .

Similar to the driver s and application s discussed above driver s or application s can include data storage related applications such as sniff and store applications DSD health monitoring and or the migration of data to another DSD on network or DSD within data storage system data encryption data compression erasure coding or error correction directing data for storage in a particular NVM of data storage system based on attributes of the data e.g. tiered storage deduplication of data stored in data storage system or mirroring data e.g. data backup or Redundant Array of Independent Disks RAID applications .

In addition driver s or application s can customize data storage system for specific uses such as streaming certain types of media over network or configuring data storage system to operate as a DVR or media server. Driver s or application s can also provide for certain network functions on network such as bit coin mining identification of another DSD or data storage system on network and identification of data stored in another DSD or data storage system migration or copying of data from a failed DSD NVM to another DSD NVM on network or the rerouting of data to other DSDs in the network or within data storage system based on environmental conditions such as vibration or temperature. In this case a sensor such as sensor can be located at each of DSDs and or at selected DSDs in data storage system to determine environmental conditions at different DSDs.

Data included in mapping write pointers command queue buffer or data to be stored in or retrieved from NVM can be stored in memory so that the data can be accessed by processor during execution of software programs to the extent that such software programs have a need to access and or modify the data. In addition to shifting processing from a host on network to data storage system with off load interface s running application OS at processor can allow for shifting tasks to file system s driver s and or application s that may otherwise have been performed by firmware e.g. controller firmware at DSDs in data storage system . By moving such tasks from a controller firmware to a file system application or driver executed on processor the DSD firmware can be simplified and tasks for maintaining data storage system can be more easily modified in the field. In one such example a new DSD with a different type of NVM can be added to data storage system and a new driver or application executed by processor can be added for managing the different type of NVM.

Those of ordinary skill in the art will appreciate that the various illustrative logical blocks modules and processes described in connection with the examples disclosed herein may be implemented as electronic hardware computer software or combinations of both. Furthermore the foregoing processes can be embodied on a computer readable medium which causes a processor or computer to perform or execute certain functions.

To clearly illustrate this interchangeability of hardware and software various illustrative components blocks and modules have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Those of ordinary skill in the art may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present disclosure.

The various illustrative logical blocks units modules and controllers described in connection with the examples disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The activities of a method or process described in connection with the examples disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. The steps of the method or algorithm may also be performed in an alternate order from those provided in the examples. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable media an optical media or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an Application Specific Integrated Circuit ASIC .

The foregoing description of the disclosed example embodiments is provided to enable any person of ordinary skill in the art to make or use the embodiments in the present disclosure. Various modifications to these examples will be readily apparent to those of ordinary skill in the art and the principles disclosed herein may be applied to other examples without departing from the spirit or scope of the present disclosure. The described embodiments are to be considered in all respects only as illustrative and not restrictive and the scope of the disclosure is therefore indicated by the following claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

