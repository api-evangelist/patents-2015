---

title: Graph-based system and method of information storage and retrieval
abstract: Structure of a resultant Every Document as a Graph (EVG) graph may be outlined using an EVG query. First metadata for a first data source may be retrieved. At least one entity key may be determined for a first entity, the entity key coming directly from the EVG query or from an entity on a preceding level of the EVG graph. Based on the first metadata and entity key, an edge may be created in the EVG graph beginning at the first entity, wherein the edge contains information retrieved from the first data source. Second metadata for a second data source may be retrieved. Based on the second metadata and information contained in the edge retrieved from first data source, a second entity may be created in the EVG graph, wherein the edge connects to the second entity, wherein the second entity contains information retrieved from the second data source.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09418176&OS=09418176&RS=09418176
owner: LinkedIn Corporation
number: 09418176
owner_city: Mountain View
owner_country: US
publication_date: 20151009
---
This application is a continuation of U.S. patent application Ser. No. 14 590 845 filed Jan. 6 2015 which is a continuation of U.S. patent application Ser. No. 14 146 623 filed Jan. 2 2014 now U.S. Pat. No. 8 954 441 issued Feb. 10 2015.

This application relates to the technical fields of software and or hardware technology and in one example embodiment to a graph based system and method of information storage and retrieval.

Storing large numbers of documents in an efficient and quick to retrieve manner is a common problem with databases. A number of different solutions have been provided in the database arena where data is stored in a single database in a single domain. However recently web sites such as social networks have attempted to gather and access documents from different domains and combine them to satisfy a particular business case. A number of problems have been encountered in such situations including having to deal with redundant data stores for relationships duplication of operation and maintenance effort and significant scalability issues that need to be addressed frequently.

in an example embodiment a uniform generic system for user case specific relationships is provided. A graph based model may be provided to allow for simpler and consistent mental models. Users are able to define domain models and perform queries in an efficient and easy to understand manner. Furthermore the system simplifies scaling and operations by leveraging a small number of relatively generic systems and an open multi tenant architecture for features of appropriate scale. Data sources are abstracted and the system is able to store and retrieve metadata about the data sources and is able to efficiently use this metadata to gather desired data from the data sources. In this way a service provider such as a social networking website may accelerate time to market of new features and services and reduce cost by enabling reuse and abstraction of existing data objects which has the effect of reducing duplicate effort.

As used herein the term or may be construed in either an inclusive or exclusive sense. Similarly the term exemplary merely means an example of something or an exemplar and not necessarily a preferred or ideal means of accomplishing a goal. For the purposes of this description the phrase an on line social networking application may be referred to as and used interchangeably with the phrase an on line social network or merely a social network. It will also be noted that an on line social network may be any type of an on line social network such as for example a professional network an interest based network or any on line networking system that permits users to join as registered members. For the purposes of this description registered members of an on line social network may be referred to as simply members.

Each member of an on line social network is represented by a member profile also referred to as a profile of a member or simply a profile . A member profile may be associated with social links that indicate that member s connection to other members of the social network. A member profile may also include or be associated with comments or endorsements from other members of the on line social network with links to other network resources such as for example publications etc. As mentioned above an on line social networking system may be designed to allow registered members to establish and document networks of people they know and trust professionally. Any two members of a social network may indicate their mutual willingness to be connected in the context of the social network in that they can view each other s profiles profile recommendations and endorsements for each other and otherwise be in touch via the social network. Reputation scores may be computed based on information obtained from trusted sources such as patent databases publications databases skills endorsement of skills or even enterprise contracts.

In addition to member profiles there may be a number of different types of data stored by the social network site. Additionally data from other data sources such as audio and video content email and business documents calendars text messages etc. may also be accessed by the social network site. It would be helpful if all this data can be accessed in an efficient manner and that whatever features the social network site is attempting to set up to access new data types or new data sources can be set up in an efficient manner.

In an example embodiment a concept known as Every Document as a graph EVG is introduced. EVG is a shared multi tenant service for supporting entity persistence and discovery managing relationships and integrating social gestures. It is a layer on top of data store implementations such as Espresso Voldemort Oracle etc. and acts as a proxy to these data stores.

In an example embodiment EVG also acts to assemble complex documents and display them as a simple query offer strongly typed representations of data to use case specific clients and use metadata to function when new types of edges and entities are introduced without having to rebuild redeploy or disrupt existing clients.

In an example embodiment EVG breaks down rich domain objects that are often represented as hierarchical documents into a graph where individual entities are tied together via directional associations or edges. In EVG every relationship is represented as an edge and every rich object or document is a graph.

The generic framework of EVG makes it easy for the user to assemble a graph from distinct data stores. In an example embodiment from a database perspective EVG follows a normalized approach where entities and edges are stored in separate tables making it easy to recombine these elements to satisfy different use cases. In an example embodiment EVG is metadata driven to distinguish stored edges from entities. The metadata also may map entities to physical data stores. EVG can then handle the assembly of these data objects based on an intuitive query language expression.

For purposes of this disclosure a document may be considered to be a rich data object combining elements of different domains. An element may be considered a generic term for a data envelope and can either be an entity or an edge. An entity or vertex may be considered a material part of a domain model carrying attributes. An association or relationship may be considered to be a direct connection between two entities. An edge may be considered to be a meaning attached to an association. A gesture may be considered a sum of social interactions with entities e.g. comments likes feeds etc. . A feed may be considered to be an activity stream for a given number of entities.

The assembly may construct the graphs by accessing one or more external data stores A B and storing the corresponding graph information in the metadata store entity store and edge store . A search service may be used to find relationships spanning several degrees of separation and traverse bidirectional relationships. The search service may also extend an EVG query to support the indexing of metadata.

In an example embodiment at least one of the external data sources A B is a key value store system such as Espresso. Key value store systems lose the ability to perform traditional JOIN operations common to relational databases. In light of this the system may be designed with query parameters and features designed to maintain edges in a manner that helps make up for the loss of such traditional JOIN operations.

The domain layer may also via the EVG client library perform validations driven by schemas and provide strongly typed interfaces proxying data maps stencils .

A presentation layer may then emit flattened simplified Javascript Object Notation JSON for consumption by clients and take user input to be persisted and send it to the business layer to be stored in an EVG graph.

In an example embodiment data sources are abstracted to provide a single interface for multiple data sources. The EVG graphs stich together heterogeneous data and a query engine is then able to access multiple data stores in parallel. By partitioning data the EVG graphs also become extremely scalable. Related entities may be clustered and parallel queries may be executed for additional scalability.

Data structures used by the EVG graphs in one example embodiment are described herein. One of ordinary skill in the art will recognize that these are merely examples and that other data structures may be utilized in some embodiments.

URNs may be represented as a sequence of variables including scheme entity type partition key and entity key. For example the URN urn li media urn li member 123 456 may indicate a scheme of urn li an entity type of media a partition key of member 123 and an entity key of 456 .

Entities may be represented as strongly typed Java objects having sub entities and lists. They may contain properties such as URN and type.

Edges may be represented as strongly typed Java objects having various properties such as URNS from entity URNs to entity URNs edge types and various attributes.

Adjacency lists may contain properties such as from entity URN edge type and an ordered list of edges.

In an example embodiment associations can be modeled in two ways sub entities and entities edges. Composition part of relations such as where the member has a list of positions he has worked at may be modeled as sub entities while non composition relations such as which companies the member has worked for may be modeled as entities edges.

The following is example code illustrating setting up an ECG client in accordance with an example embodiment.

Here the edge data indicates two edges A B each to a decision card node A B defined by entity data . Each decision card node A B then contains a URN pointing to a second data store having a second data store type such as Oracle. The second data store then contains entity data indicating comment nodes A B C D. Another URN may point to another data store where edge data is stored. This additional data store is depicted as another Oracle database and in some embodiments may be the same data store as the second data store . In other embodiments this additional data store may be a completely different type than the second data store .

If a user wishes to perform a query such as get all decision cards from a member board and get all the comments on the decision cards the user can create a query language query as follows 

In an example embodiment a Java based client may be provided for programmatic access to the EVG graphs. The client utilizes a common builder pattern for constructing requests and responses. It may provide a layer of abstraction above the REST layer and may be capable of producing and consuming objects typed to client specific domain classes.

The client may be used to construct basic requests and responses. The following is sample code for creating an entity in accordance with an example embodiment 

In an example embodiment the system may support metadata and index metadata for entities and edges. Metadata may be used to define each entity and edge type for a particular use case and index metadata may be used to access entity data through a data source s secondary index.

In an example embodiment a number of different attributes are available for a user to create metadata for a new entity or edge including entityType urnResolver urnResolverConfig edge rowPerEdge edgeMultiTenant and reducedEdge.

The urnResolverConfig attribute is a map with attributes specific to the resolver data store . The map may include database and table information for the entity and the URN pattern which will specify the URN to database translation.

The rowPerEdge attribute indicates whether each edge is stored in one separate row or several edges can be aggregated into one row.

Referring back to the example in having a member entity with an edge to an entity for treasuryMedia various metadata for each of these elements may be provided. For example the following is sample metadata for the entity treasuryMedia in accordance with an example embodiment 

In an example embodiment a number of different attributes are available for a user to create index metadata for a new entity or edge including indexName urnResolver urnResolverConfig edge toIndexField indexFields and supportedEdges.

The urnResolverConfig attribute is a map with attributes specific to the resolver data store . The map includes database and table information for the entity and the URN pattern which specifies the URN to database translation.

The toIndexField attribute is used if the entity is an edge and specifies a full valid URN. The system then retrieves and returns the data defined in this URN.

In an example embodiment entities are stored in a table per per domain object. In an alternative embodiment a completely opaque binary envelope is used. In the table per per domain object case this means that users create a table for their objects. In order to allow the data to be partitioned all keys for both entities and edges begin with a partition key. In an example embodiment this may be a member identification. Consequently since the URN needs to carry enough information to fill in the parameters of the request to perform any of the operations on the underlying data store it also needs to have the identification of the domain specific object along the way.

The results of using an EVG graph is that data from multiple data sources may be abstracted and queries for data from these multiple data sources can be sent to a single destination the EVG system. The EVG system maintains the edges for the data in these multiple data sources. Each entity itself may be unaware that another entity exists even if an edge is present between the two entities because the EVG system maintains the edges separately from the entities.

The EVG system is also able to retrieve all pieces of data in parallel despite the fact that they may be disparate pieces of data in disparate data sources as opposed to prior art techniques where the system retrieves at least some data in series necessitating a waiting period until the final piece of data is retrieved prior to loading. Additionally the EVG system is also intelligent enough such that if one of the disparate pieces of data being retrieved has an edge to another piece of data e.g. a sub entity it can immediately retrieve that other piece of data. Thus for example if there are two entities labeled media and media each having an edge to sub entities labeled group and group the system upon retrieving media can immediately begin retrieving group without waiting for media to be completely retrieved. Thus the EVG system is designed to accept queries that specify edges rather than goal entities to retrieve. The EVG system then uses these specified edges to return whatever entities reside on the other ends of these edges.

A result context gathers URNs generated by the tasks and retrieves corresponding data from the data sources for these URNs. This helps eliminate duplicate requests. For example if two different entities are linked to the same media file the media file while referenced by two different tasks will only be retrieved once as the result context is intelligent enough to recognize duplicate URNs and only retrieve one piece of data.

Notably the request tasks look up in the resolver to determine how to actually retrieve the corresponding data. The resolver provides this information based on the metadata allowing the request tasks to schedule actual data retrieval calls via URNs. Communication flows and indicate how the edgeResult task can actually cause a loop or cycle by then initiating calls to entityRequest and or edgeRequest .

At operation the AST query engine sends an AST message for content to the assembler . At operation the assembler sends a get request to the metadata source which returns the metadata at operation . At operation the assembler then creates the tasks. At operation the assembler sends a get request to the 1st data source which returns content at operation . At operation the assembler populates the content in a data structure. At operation the assembler sends a get request to the 2nd data source which returns content at operation . At operation the assembler populates the content in a data structure.

At operation the assembler sends the content to the EVG engine which at operation forms a response from the content. This response is sent to the middle tier at operation . The middle tier then returns a model to the front end at operation . The front end then returns an HTML page at based on the model.

The example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard a user interface UI navigation device e.g. a cursor control device a storage device a signal generation device e.g. a speaker and a network interface device .

The storage device includes a machine readable medium on which is stored one or more sets of instructions and data structures e.g. instructions embodying or utilized by any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system with the main memory and the processor also constituting machine readable media .

The instructions may further be transmitted or received over a network via the network interface device utilizing any one of a number of well known transfer protocols e.g. Hyper Text Transfer Protocol HTTP .

While the machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions e.g. . The term machine readable medium shall also be taken to include any medium that is capable of storing and encoding a set of instructions e.g. for execution by the machine and that cause the machine to perform any one or more of the methodologies of embodiments of the present disclosure or that is capable of storing and encoding data structures utilized by or associated with such a set of instructions e.g. . The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media. Such media may without limitation also include hard disks floppy disks flash memory cards digital video disks random access memory RAMs read only memory ROMs and the like.

The embodiments described herein may be implemented in an operating environment comprising software installed on a computer in hardware or in a combination of software and hardware. Such embodiments of the inventive subject matter may be referred to herein individually or collectively by the term disclosure merely for convenience and without intending to voluntarily limit the scope of this application to any single embodiment if more than one is in fact disclosed.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied 1 on a non transitory machine readable medium or 2 in a transmission signal or hardware implemented modules. A hardware implemented module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more processors may be configured by software e.g. an application or application portion as a hardware implemented module that operates to perform certain operations as described herein.

In various embodiments a hardware implemented module may be implemented mechanically or electronically. For example a hardware implemented module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware implemented module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware implemented module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware implemented module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily or transitorily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware implemented modules are temporarily configured e.g. programmed each of the hardware implemented modules need not be configured or instantiated at any one instance in time. For example where the hardware implemented modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware implemented modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware implemented module at one instance of time and to constitute a different hardware implemented module at a different instance of time.

Hardware implemented modules can provide information to and receive information from other hardware implemented modules. Accordingly the described hardware implemented modules may be regarded as being communicatively coupled. Where multiple of such hardware implemented modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the hardware implemented modules. In embodiments in which multiple hardware implemented modules are configured or instantiated at different times communications between such hardware implemented modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple hardware implemented modules have access. For example one hardware implemented module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware implemented module may then at a later time access the memory device to retrieve and process the stored output. Hardware implemented modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

Similarly the methods described herein may be at least partially processor implemented. For example at least some of the operations of a method may be performed by one or more processors or processor implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processor or processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. application program interfaces APIs . 

Although embodiments have been described with reference to specific example embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the inventive subject matter. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

