---

title: Parallel runtime execution on multiple processors
abstract: A method and an apparatus that schedule a plurality of executables in a schedule queue for execution in one or more physical compute devices such as CPUs or GPUs concurrently are described. One or more executables are compiled online from a source having an existing executable for a type of physical compute devices different from the one or more physical compute devices. Dependency relations among elements corresponding to scheduled executables are determined to select an executable to be executed by a plurality of threads concurrently in more than one of the physical compute devices. A thread initialized for executing an executable in a GPU of the physical compute devices are initialized for execution in another CPU of the physical compute devices if the GPU is busy with graphics processing threads.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471401&OS=09471401&RS=09471401
owner: Apple Inc.
number: 09471401
owner_city: Cupertino
owner_country: US
publication_date: 20150515
---
This application is a divisional of U.S. application Ser. No. 11 800 319 now U.S. Pat. No. 9 052 948 issued on Jun. 9 2015 which is related to and claims the benefits of U.S. Provisional Patent Application No. 60 923 030 filed on Apr. 11 2007 entitled DATA PARALLEL COMPUTING ON MULTIPLE PROCESSORS Aaftab Munshi et al. and U.S. Provisional Patent Application No. 60 925 620 filed on Apr. 20 2007 entitled PARALLEL RUNTIME EXECUTION ON MULTIPLE PROCESSORS Aaftab Munshi which are hereby incorporated herein by reference.

The present invention relates generally to data parallel computing. More particularly this invention relates to data parallel runtime execution across both CPUs Central Processing Units and GPUs Graphical Processing Units .

As GPUs continue to evolve into high performance parallel compute devices more and more applications are written to perform data parallel computations in GPUs similar to general purpose compute devices. Today these applications are designed to run on specific GPUs using vendor specific interfaces. Thus they are not able to leverage CPUs even when both GPUs and CPUs are available in a data processing system nor can they be leveraged across GPUs from different vendors where such an application is running.

However as more and more CPUs embrace multiple cores to perform data parallel model of computations more and more processing tasks can be supported by either CPUs and or GPUs whichever are available. Traditionally GPUs and CPUs are configured through separate programming environments not compatible with each other. Most GPUs require dedicated programs which are vendor specific. As a result it is very difficult for an application to leverage both CPUs and GPUs for processing resources such as GPUs with data parallel computing capabilities together with multi core CPUs.

Therefore there is a need in modem data processing systems to overcome the above problems to allow an application to perform a task in any available processing resources such as CPUs and one or more GPUs capable of performing the task.

An embodiment of the present invention includes methods and apparatuses that load one or more executables for a data processing task of an application running in a host processing unit in response to an API request from the application. One of the loaded executables is selected to be executed in another processing unit such as a CPU or a GPU attached to the host processing unit in response to another API request from the application.

In an alternative embodiment an application program running in a host processing unit generates an API request to load one or more executables for a data processing task. A second API is then generated by the application program to select one of the loaded executables for execution in another processing unit such as a CPU or a GPU attached to the host processing unit.

In an alternative embodiment a source for a target processing unit is compiled during run time based on an executable loaded to a processing unit. The processing unit and the target processing unit may be central processing units CPUs or graphics processing units GPUs . A difference between the processing unit and the target processing unit is detected to retrieve the source from the loaded executable.

In an alternative embodiment a queue of tasks associated with a plurality of processing units such as CPUs or GPUs is updated with a new task including a plurality of executables in response to an API request from an application. A condition is determined to schedule performing the new task from the queue in the plurality of processing units. One of the plurality of executables associated with the new task is selected for execution based on the determined condition.

In an alternative embodiment a source to perform a data processing function is loaded from an application in response to an API request from the application to execute an executable in one or more of a plurality of target data processing units such as CPUs or GPUs. A plurality of types of the target data processing units is automatically determined. The executable is compiled based on the determined types to be executed in one or more of the target processing units concurrently.

In an alternative embodiment a source and one or more corresponding executables compiled for a plurality of processing units are stored in an API library to implement an API function. In response to requests to the API library from an application running in a host processor the source and the one or more corresponding executables of the API function are retrieved from the API library. An additional executable is compiled online from the retrieved source for an additional processing unit not included in the plurality of processing unit. The additional executable and the one or more retrieved executables are executed in the additional processing unit together with the one or more processing units concurrently according to the API function

In an alternative embodiment an API call is received on a host processor to execute an application having a plurality of threads for execution. The host processor is coupled a CPU and a GPU. The plurality of threads are scheduled for execution on the CPU and the GPU in parallel asynchronously. A thread scheduled to be executed on the GPU may be executed in the CPU if the GPU is busy with graphics processing threads.

In an alternative embodiment an API call is received on a host processor to execute an application having a plurality of threads for execution. The host processor is coupled to a CPU and a GPU. The plurality of threads are initialized for execution on the CPU and the GPU in parallel asynchronously. A thread initialized for execution in the GPU may be initialized for execution in the CPU if the GPU is busy with graphics processing threads.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.

A method and an apparatus for data parallel computing on multiple processors are described herein. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

A Graphics Processing Unit GPU may be a dedicated graphics processor implementing highly efficient graphics operations such as 2D 3D graphics operation and or digital video related functions. A GPU may include special programmable hardware to perform graphics operations e.g. blitter operations texture mapping polygon rendering pixel shading and vertex shading. GPUs are known to fetch data from a frame buffer and blend pixels together to render an image back into the frame buffer for display. GPUs may also control the frame buffer and allow the frame buffer to be used to refresh a display such as a CRT or LCD display which is a short persistence display that requires refresh at a rate of at least 20 Hz e.g. every 1 30 of a second the display is refreshed with data from a frame buffer. Usually GPUs may take graphics processing tasks from CPUs coupled with the GPUs to output raster graphics images to display devices through display controllers. References in the specification to GPU may be a graphics processor or a programmable graphics processor as described in Method and Apparatus for Multitheraded Processing of Data In a Programmable Graphics Processor Lindholdm etl al. U.S. Pat. No. 7 015 913 and Method for Deinterlacing Interlaced Video by A Graphics Processor Swan et al. U.S. Pat. No. 6 970 206 which are hereby incorporated by reference

In one embodiment a plurality of different types of processors such as CPUs or GPUs may perform data parallel processing tasks for one or more applications concurrently to increase the usage efficiency of available processing resources in a data processing system. Processing resources of a data processing system may be based on a plurality of physical compute devices. A physical compute device maybe a CPU or a GPU. In one embodiment data parallel processing tasks may be delegated to a plurality types of processors for example CPUs or GPUs capable of performing the tasks. A data processing task may require certain specific processing capabilities from a processor. Processing capabilities may be for example dedicated texturing hardware support double precision floating point arithmetic dedicated local memory stream data cache or synchronization primitives. Separate types of processors may provide different yet overlapping sets of processing capabilities. For example both CPU and GPU may be capable of performing double precision floating point computation. In one embodiment an application is capable of leveraging either a CPU or a GPU whichever is available to perform a data parallel processing task.

In another embodiment selecting and allocating a plurality of different types of processing resources for a data parallel processing task may be performed automatically during run time. An application may send a hint including desired list of capability requirements for a data processing task though an API Application Programming Interface to a runtime platform of a data processing system. In accordance the runtime platform may determine a plurality of currently available CPUs and or GPUs with capabilities matching the received hint to delegate the data processing task for the application. In one embodiment the list of capability requirements may depend on the underlying data processing task. A capability requirement list may be applicable across different sets of processors including for example GPUs and multi core CPUs from different vendors and of different versions. Consequently an application may be insulated from providing programs targeting a particular type of CPU or GPU.

In one embodiment the hosting systems may support a software stack including software stack components such as applications a compute platform layer a compute runtime layer a compute compiler and compute application libraries . An application may interface with other stack components through API Application Programming Interface calls. One ore more threads may be running concurrently for an application in the hosting systems . The compute platform layer may maintain a data structure or a compute device data structure storing processing capabilities for each attached physical compute device. In one embodiment an application may retrieve information about available processing resources of the hosting systems through the compute platform layer . An application may select and specify capability requirements for performing a processing task through the compute platform layer . Accordingly the compute platform layer may determine a configuration for physical compute devices to allocate and initialize processing resources from the attached CPUs and or GPUs for the processing task. In one embodiment the compute platform layer may generate one or more logical compute devices for the application corresponding to one or more actual physical compute devices configured.

The compute runtime layer may manage the execution of a processing task according to the configured processing resources for an application such as for example one or more logical compute devices. In one embodiment executing a processing task may include creating a compute kernel object representing the processing task and allocating memory resources e.g. for holding executables input output data etc. An executable loaded for a compute kernel object may be a compute kernel object. A compute executable may be included in a compute kernel object to be executed in a compute processor such as a CPU or a GPU. The compute runtime layer may interact with the allocated physical devices to carry out the actual execution of the processing task. In one embodiment the compute runtime layer may coordinate executing multiple processing tasks from different applications according to run time states of each processor such as CPU or GPU configured for the processing tasks. The compute runtime layer may select based on the run time states one or more processors from the physical devices configured to perform the processing tasks. Performing a processing task may include executing multiple threads of one or more executables in a plurality of physical processing devices concurrently. In one embodiment the compute runtime layer may track the status of each executed processing task by monitoring run time execution statuses of each processor.

The runtime layer may load one or more executables corresponding to a processing task from an application . In one embodiment the compute runtime layer automatically loads additional executables required to perform a processing task from a compute application library . The compute runtime layer may load both an executable and its corresponding source program for a compute kernel object from an application or the compute application library . A source program for a compute kernel object may be a compute kernel program. A plurality of executables based on a single source program may be loaded according to a logical compute device configured to include multiple types and or different versions of physical compute devices. In one embodiment the compute runtime layer may activate a compute compiler to online compile a loaded source program into an executable optimized for a target processor e.g. a CPU or a GPU configured to execute the executable.

An online compiled executable may be stored for future invocation in addition to existing executables according to a corresponding source program. In addition the compute executables may be compiled offline and loaded to the compute runtime via API calls. The compute application library and or applications may load an associated executable in response to library API requests from an application. Newly compiled executables may be dynamically updated for the compute application libraries or for applications . In one embodiment the compute runtime may replace an existing compute executable in an application by a new executable online compiled through the compute compiler for a newly upgraded version of compute device. The compute runtime may insert a new executable online compiled to update a compute application library . In one embodiment the compute runtime may invoke the compute compiler when loading an executable for a processing task. In another embodiment the compute compiler may be invoked offline to build executables for the compute application library . The compute compiler may compile and link a compute kernel program to generate a compute kernel executable. In one embodiment the compute application library may include a plurality of functions to support for example development toolkits and or image processing. Each library function may correspond to a compute source program and one or more executables stored in the compute application library for a plurality of physical compute devices.

A compute device may include one or more compute processors such as Processor  and Processor L . A local memory may be coupled with a compute processor. Shared memory among threads in a single thread block running in a compute processor may be supported by the local memory coupled with the compute processor. Multiple threads from across different thread blocks such as thread and thread N may share a stream stored in a stream memory coupled to the compute device . A stream may be a collection of elements that can be operated on by a compute kernel executable such as an image stream or a variable stream. A variable stream may be allocated to store global variables operated on during a processing task. An image stream may be a buffer which may be used for an image texture or frame buffer.

In one embodiment a local memory for a compute processor may be implemented as a dedicated local storage such as local shared memory for Processor  and local shared memory for Processor L. In another embodiment a local memory for a compute processor may be implemented as a stream read write cache for a stream memory for one or more compute processors of a compute device such as stream data cache for compute processors in the compute device . In another embodiment a local memory may implement a dedicated local storage for sharing among threads in a thread block running in a compute processor coupled with the local memory such as local shared memory coupled with Processor  . A dedicated local storage may not be shared by threads across different thread blocks. If the local memory of a compute processor such as Processor  is implemented as a steam read write cache e.g. stream data cache a variable declared to be in the local memory may be allocated from the stream memory and cached in the implemented stream read write cache e.g. stream data cache that implements the local memory. Threads within a thread block may share local variables allocated in the stream memory when for example neither stream read write cache nor dedicated local storage are available for the corresponding compute device. In one embodiment each thread is associated with a private memory to store thread private variables that are used by functions called in the thread. For example private memory may only be accessed by thread .

Hosting systems may include the host CPU . Each of the physical compute devices Physical Compute Device . . . Physical Compute Device N may be one of the CPUs or GPUs of . In one embodiment the compute platform layer may generate a compute device identifier in response to API requests from the application for configuring data parallel processing resources according to a list of capability requirements included in the API requests. The compute device identifier may refer to a selection of actual physical compute devices Physical Compute Device . . . Physical Compute Device N according to the configuration by the compute platform layer . In one embodiment a logical compute device may represent the group of selected actual physical compute devices separate from the host CPU .

At block in one embodiment process may build a data structure or a compute device data structure representing a plurality of physical compute devices associated with one or more corresponding capabilities. Each physical compute device may be attached to the processing system performing the process . Capabilities or compute capabilities of a physical compute device such as CPU or GPU may include whether the physical compute device support a processing feature a memory accessing mechanism or a named extension. A processing feature may be related to dedicated texturing hardware support double precision floating point arithmetic or synchronization support e.g. mutex . A memory accessing mechanism for a physical processing device may be related to a type of variable stream cache a type of image stream cache or a dedicated local memory support. A system application of the data processing system may update the data structure in response to attaching a new physical compute device to a data processing system. In one embodiment the capabilities of a physical compute device may be predetermined. In another embodiment a system application of the data processing system may discover a newly attached physical processing device during run time. The system application may retrieve the capabilities of the newly discovered physical compute device to update the data structure representing the attached physical compute devices and their corresponding capabilities.

According to one embodiment process may receive a compute capability requirement from an application at block . The application may send the compute capability requirement to a system application by calling APIs. The system application may correspond to a platform layer of a software stack in a hosting system for the application. In one embodiment a compute capability requirement may identify a list of required capabilities for requesting processing resources to perform a task for the application. In one embodiment the application may require the requested processing resources to perform the task in a plurality of threads concurrently. In response process may select a set of physical compute devices from attached physical compute devices at block . The selection may be determined based on a matching between the compute capability requirement against the compute capabilities stored in the capability data structure. In one embodiment process may perform the matching according to a hint provided by the capability requirement.

Process may determine a matching score according to the number of compute capabilities matched between a physical compute device and the compute capability requirement. In one embodiment process may select a plurality of physical compute devices with highest matching scores. In another embodiment process may select a physical compute device if each capability in the capability requirement is matched. Process may determine a plurality of sets of matching physical compute devices at block . In one embodiment each set of matching physical compute devices are selected according to load balancing capabilities. At block in one embodiment process may generate a compute device identifier for each set of physical compute devices selected at block . Process may return one or more of the generated compute device identifiers back to the application through the calling APIs. An application may choose which processing resources to employ for performing a task according to the compute device identifiers. In one embodiment process may generate at most one compute device identifier at block for each capability requirement received.

At block in one embodiment process may allocate resources to initialize a logical compute device for a set of physical compute devices selected at block according to a corresponding compute device identifier. Process may perform initializing a logical compute device in response to API requests from an application which has received one or more compute device identifiers according to the selection at block . Process may create a context object on the logical compute device for an application. In one embodiment a context object is associated with one application thread in a hosting system running the application. Multiple threads performing processing tasks in one logical compute device or across different logical compute devices concurrently may be based on separate context objects.

In one embodiment process may be based on a plurality of APIs including cuCreateContext cuRetainContext and cuReleaseContext. The API cuCreateContext creates a compute context. A compute context may correspond to a compute context object. The API cuRetainContext increments the number of instances using a particular compute context identified by a context as an input argument to cuRetainContext. The API cuCreateContext does an implicit retain. This is very helpful for 3rd party libraries which typically get a context passed to them by the application. However it is possible that the application may delete the context without informing the library. Allowing multiple instances to attach to a context and release from a context solves the problem of a compute context being used by a library no longer being valid. If an input argument to cuRetainContext does not correspond to a valid compute context object cuRetainContext returns CU INVALID CONTEXT. The API cuReleaseContext releases an instance from a valid compute context. If an input argument to cuReleaseContext does not correspond to a valid compute context object cuReleaseContext returns CU INVALID CONTEXT.

At block according to one embodiment process may create a compute kernel object for the logical compute device. A compute kernel object may be an object created for the associated streams and executables of the corresponding processing task to perform a function. Process may set up function arguments for a compute kernel object at block . Function arguments may include streams allocated for function inputs or outputs such as the streams allocated at block . Process may load compute kernel executable and or a compute kernel source into the compute kernel object at block . A compute kernel executable may be an executable to be executed according to a logical compute device to perform the corresponding processing task associated with a kernel object. In one embodiment a compute kernel executable may include description data associated with for example the type of target physical compute devices versions and or compilation options. A compute kernel source may be the source code where the compute kernel executable is compiled from. Process may load a plurality of compute kernel executables corresponding to a compute kernel source at block . Process may load a compute kernel executable from an application or through a compute library such as compute application library of . A compute kernel executable may be loaded with the corresponding compute kernel source. In one embodiment process may perform operations at blocks and according to API requests from an application.

At block process may update an execution queue to execute the compute kernel object with a logical compute device. Process may execute the computer kernel in response to API calls with appropriate arguments to a compute runtime e.g. compute runtime of from an application or a compute application library such as applications or compute application library of . In one embodiment process may generate a compute kernel execution instance to execute a compute kernel. API calls to a compute runtime such as compute runtime of to execute a compute kernel may be asynchronous in nature. An execution instance may be identified by a compute event object that may be returned by a compute runtime such as compute runtime of . A compute kernel execution instance may be added to an execution queue to execute a compute kernel instance. In one embodiment API calls to a compute runtime to execute a compute kernel may include the number of threads that execute simultaneously in parallel on a compute processor and the number of compute processors to use. A compute kernel execution instance may include a priority value indicating a desired priority to execute the corresponding compute kernel object. A compute kernel execution instance may also include an event object identifying a previous execution instance and or expected number of threads and number of thread blocks to perform the execution. The number of thread blocks and number of threads may be specified in the API calls. In one embodiment an event object may indicate an execution order relationship between the execution instance that includes the event object and another execution instance identified by the event object. An execution instance including an event object may be required to be executed after another execution instance identified by the event object finishes execution. An event object may be referred to as a queue after event object. In one embodiment an execution queue may include a plurality of compute kernel execution instances for executing corresponding compute kernel objects. One ore more compute kernel execution instances for a compute kernel object may be scheduled for execution in an execution queue. In one embodiment process may update the execution queue in response to API requests from an application. The execution queue may be hosted by the hosting data systems where the application is running.

At block process may select a compute kernel execution instance from the execution queue for execution. In one embodiment process may select more than one compute kernel execution instances to be executed concurrently according to the corresponding logical compute devices. Process may determine whether a compute kernel execution instance is selected from the execution queue based on its associated priority and dependency relationships with other execution instances in the execution queue. A compute kernel execution instance may be executed by executing its corresponding compute kernel object according to an executable loaded to the compute kernel object.

At block in one embodiment process may select one of the plurality of executables loaded to the compute kernel object corresponding to the selected compute kernel instance for execution in a physical compute device associated with the logical compute device for the compute kernel object. Process may select more than one executables to be executed in more than one physical compute devices in parallel for one compute kernel execution instance. The selection may be based on current execution statuses of the physical compute devices corresponding to the logical compute device associated with the selected compute kernel execution instance. An execution status of a physical compute device may include the number of threads running the local memory usage level and the processor usage level e.g. peak number of operations per unit time etc. In one embodiment the selection may be based on predetermined usage levels. In another embodiment the selection may be based on the number of threads and number of thread blocks associated with the compute kernel execution instance. Process may retrieve an execution status from a physical compute device. In one embodiment process may perform operations to select a compute kernel execution instance from the execution queue to execute at blocks asynchronously to applications running in hosting systems.

At block process may check the execution status of a compute kernel execution instance scheduled for execution in the execution queue. Each execution instance may be identified by a unique compute event object. An event object may be returned to an application or a compute application library such as application or compute application library of which calls APIs to execute the execution instance when the corresponding compute kernel execution instance was queued according to a compute runtime such as the runtime of . In one embodiment process may perform the execution status checking in response to API requests from an application. Process may determine the completion of executing a compute kernel execution instance by querying a status of the compute event object identifying the compute kernel execution instance. Process may wait until the execution of a compute kernel execution instance is complete to return to API calls from an application. Process may control processing execution instances reading and or writing from various streams based on compute event objects.

At block according to one embodiment process may retrieve results of executing a compute kernel execution instance. Subsequently process may clean up processing resources allocated for executing the compute kernel execution instance. In one embodiment process may copy a stream memory holding results of executing a compute kernel executable into a local memory. Process may delete variable streams or image streams allocated at block . Process may delete a kernel event object for detecting when a compute kernel execution is completed. If each compute kernel execution instance associated with a specific compute kernel object has been completely executed process may delete the specific compute kernel object. In one embodiment process may perform operations at block based on API requests initiated by an application.

If there are existing compute kernel objects selected process may determine if any of the selected compute kernel executables is optimized for a physical compute device at block . The determination may be based on for example the version of the physical compute device. In one embodiment process may determine that an existing compute kernel executable is optimized for a physical compute device if the version of target physical compute device in the description data matches the version of the physical compute device.

At block in one embodiment process may build a new compute kernel executable optimized for a physical compute device from the corresponding computer kernel source using an online compiler such as compute compiler of . Process may perform the online build if none of the selected compute kernel executables are found to be optimized for the physical compute device at block . In one embodiment process may perform the online build if none of existing compute kernel executables are found to be compatible with the physical compute device at block . The compute kernel source may be available from an application or through a compute library such as compute application library of .

If the build at block is successful in one embodiment process may load the newly built compute kernel executable into the corresponding compute kernel object at block . Otherwise process may load the selected compute kernel executables to the kernel object at block . In one embodiment process may load a compute kernel executable to a compute kernel object if the compute kernel executable has not yet been loaded. In another embodiment process may generate an error message if none of existing compute kernel executables for a compute kernel object is compatible with a physical compute device and the corresponding compute kernel source is not available.

At block in one embodiment process may select a compute kernel execution instances for execution from a plurality of scheduled compute kernel execution instances without any outstanding dependency condition. The selection may be based on a priority level assigned to an execution instance. In one embodiment the selected compute kernel execution instance may be associated the highest priority level among the plurality of compute kernel execution instances without outstanding dependency conditions. At block process may retrieve current execution statuses for the physical compute devices corresponding to the selected compute kernel execution instance. In one embodiment execution status of a physical compute device may be retrieved from predetermined memory locations. In another embodiment process may send a status request to a physical compute device to receive an execution status report. Process may designate one or more of the physical compute devices to execute the selected compute kernel execution instance based on the retrieved execution statuses at block . In one embodiment a physical compute device may be designated for execution according to a load balancing consideration with other physical compute devices. The selected physical compute device may be associated with an execution status satisfying a predetermined criteria such as below a predetermined processor usage level and or memory usage level. In one embodiment the predetermined criteria may depend on the number of threads and the number of thread blocks associated with the selected compute kernel execution instance. Process may load separate compute kernel executables for the same execution instance or multiple instances to one or more designated physical compute devices to execute in parallel in a plurality of threads.

In one embodiment processing operation may attach variables and streams as function arguments for the created compute kernel object. Processing operation may be performed by process at block of . Processing operation may execute the created compute kernel object. In one embodiment processing operation may be performed by process at block of . Processing operation may cause an execution queue to be updated with a compute kernel execution instance corresponding to the created compute kernel object. Processing operation may synchronously wait for a completion of executing the create compute kernel object. In one embodiment processing operation may retrieve a result from executing the compute kernel object. Subsequently processing operations may clean up allocated resources for executing the compute kernel object such as an event object the created compute kernel object and the allocated memories. In one embodiment processing operation may be based on whether a kernel event object is set. Processing operation may be performed by process at block of .

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s such as CPUs and or GPUs a ROM Read Only Memory volatile RAM and a non volatile memory . The microprocessor may retrieve the instructions from the memories and execute the instructions to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory. The display controller coupled with a display device may optionally include one or more GPUs to process display data. Optionally GPU memory may be provided to support GPUs included in the display device .

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless networking interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

