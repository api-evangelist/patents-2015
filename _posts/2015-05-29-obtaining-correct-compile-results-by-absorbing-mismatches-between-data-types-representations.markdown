---

title: Obtaining correct compile results by absorbing mismatches between data types representations
abstract: Methods and a system are provided. A method includes implementing a function, which a compiler for a first language does not have, using a compiler for a second language. The implementing step includes generating, by the compiler for the first language, a first abstract syntax tree. The implementing step further includes converting, by a converter, the first abstract syntax tree to a second abstract syntax tree of the compiler for the second language using a conversion table from data representation types in the first language to data representation types in the second language. When a compilation error occurs, the implementing step also includes generating a special node for error processing in the second abstract syntax tree and storing an error token in the special node. When unparsing, the implementing step additionally includes outputting the error token, in the form of source code written in the first language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09459848&OS=09459848&RS=09459848
owner: International Business Machines Corporation
number: 09459848
owner_city: Armonk
owner_country: US
publication_date: 20150529
---
This invention was made with Government support under Contract No. DE SC0008923 DoE MIT 5710003274 MIT IBM awarded by the Department of Energy. The Government has certain rights in this invention.

The present invention relates generally to compiling and in particular to obtaining correct compile results by absorbing mismatches between data type representations when different compilers are combined.

After converting a type in a domain specific language DSL to a corresponding type in an existing compiler e.g. a ROSE compiler when a field access or a method invocation that is not defined in the existing compiler exists the compilation will fail because the field or the method does not exist in the converted type in the existing compiler.

For example it may be necessary to convert an abstract syntax tree AST that is created by the DSL compiler to an AST of the existing compiler. However simply converting an AST as per the prior art not only disables the optimization support of the existing compiler but also causes compilation errors. For example there is a mismatch of data type representations between the two compilers. Consider the following two examples involving a ROSE compiler and an X10 compiler. In the first example to represent the type for an integer value X10 uses an object type x10.lang.Int while in contrast ROSE uses the primitive type int . In the second example to represent the type for an array of integers X10 uses x10.lang.Rail x10.lang.Int while in contrast ROSE uses int . Also there are different functions between these corresponding classes.

Thus there is a need for obtaining correct compile results by absorbing the mismatch between data type representations when different compilers are combined.

According to an aspect of the present principles a method is provided. The method includes implementing a function which a compiler for a first language does not have using a compiler for a second language. The implementing step includes generating by the compiler for the first language a first abstract syntax tree by parsing source code written in the first language or a domain specific language based on the first language. The implementing step further includes converting by a data representation type converter the first abstract syntax tree to a second abstract syntax tree of the compiler for the second language using a conversion table from data representation types in the first language to data representation types in the second language. When a compilation error occurs in the compiler for the second language the implementing step also includes generating therein a special node for error processing in the second abstract syntax tree and storing an error token indicating information of the compilation error in the special node. When unparsing by the compiler for the second language the implementing step additionally includes outputting the error token stored in the special node in the form of source code written in the first language.

According to another aspect of the present principles a method is provided. The method includes transforming a program from a first language to a second language using a compiler for a third language and data type representation conversion without helper classes. The transforming step includes generating by a compiler for the first language an abstract syntax tree by parsing source code written in the first language or a domain specific language based on the first language. The transforming step further includes converting by the compiler for the third language the first abstract syntax tree to a given abstract syntax tree of the compiler for the third language using a conversion table from data representation types in the first language to data representation types in the third language. When a compilation error occurs in the compiler for the third language the transforming step also includes generating therein a special node for error processing in a second abstract syntax tree of the compiler of the second language and storing an error token indicating information of the compilation error in the special node. When unparsing by the compiler for the second language the transforming step additionally includes outputting the error token stored in the special node in the form of source code written in the first language.

According to yet another aspect of the present principles a system is provided. The system includes a compiler for a first language a first abstract syntax tree by parsing source code written in the first language or a domain specific language based on the first language. The system further includes a compiler for a second language. The system also includes a data representation type converter for converting the first abstract syntax tree to a second abstract syntax tree of the compiler for the second language using a conversion table from data representation types in the first language to data representation types in the second language. The compiler for the second language when a compilation error occurs generates a special node for error processing in the second abstract syntax tree and stores in the special node an error token indicating information of the compilation error. The compiler for the second language when unparsing outputs the error token stored in the special node is output in the form of source code written in the first language.

These and other features and advantages will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

The present principles are directed to obtaining correct compile results by absorbing mismatches between data type representations when different compilers are combined.

For example consider the case of transforming a first program written using a first compiler for a first language e.g. a domain specific language to a second program written using a second compiler for a second e.g. target language. In an embodiment the present principles advantageously allow for the implementation of a function which the second compiler for the second language does not have using an existing compiler e.g. a third compiler for a third language . Thus as used herein the phrase existing compiler can refer to a compiler that is not necessarily part of the transformation from a first language written by a first compiler to a second language written by a second compiler but is available for use to in order to absorb mismatches between data type representations among the first compiler and the second compiler.

For the sake of illustration examples will focus on transforming a program written in a domain specific language DSL using a DSL compiler to X10 as the target language written using an X10 compiler where optimization support will be provided by an existing third compiler implemented as a ROSE compiler. Of course the preceding compiler and language types are merely illustrative and thus other compiler and language types can also be used in accordance with the teachings of the present principles while maintaining the spirit of the present principles. Moreover other embodiments can involve different numbers of compilers while maintaining the spirit of the present principles.

In an embodiment we reuse optimization support that is not provided by the compiler for the target programming language but another compiler e.g. a ROSE compiler . Reusing existing support involves a lower cost than implementing new support in the target compiler. Thus for example we can use ROSE s optimization support that is not provided by the X10 compiler when transforming a program from a DSL to X10.

In an embodiment the present principles advantageously convert an abstract syntax tree AST created by a domain specific language DSL compiler to an AST for an existing compiler e.g. a ROSE compiler without using helper classes. An AST is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code. The syntax is abstract in not representing every detail appearing in the real syntax.

In an embodiment when an error occurs at the time of conversion of an AST created by a DSL compiler to an AST for an existing compiler e.g. a ROSE compiler the information of a token that causes the error is stored in a special AST node of the existing compiler after handling the error and the unparser of the existing compiler outputs the information stored in the special AST node as is.

Thus in an embodiment even if a compilation error occurs at the time of conversion into a ROSE AST the parser can advantageously handle the error by storing the information into a corresponding ROSE AST node and the parser can continue its compilation process. When the unparser outputs source code the stored information can be output as is.

Since errors in a source file can be detected by a DSL compiler other errors that occur during the semantic analysis such as type checking at the time of conversion into a ROSE AST can be considered to be caused by the mismatch of data types between the DSL compiler and the ROSE compiler

A first storage device and a second storage device are operatively coupled to system bus by the I O adapter . The storage devices and can be any of a disk storage device e.g. a magnetic or optical disk storage device a solid state magnetic device and so forth. The storage devices and can be the same type of storage device or different types of storage devices.

A speaker is operatively coupled to system bus by the sound adapter . A transceiver is operatively coupled to system bus by network adapter . A display device is operatively coupled to system bus by display adapter .

A first user input device a second user input device and a third user input device are operatively coupled to system bus by user interface adapter . The user input devices and can be any of a keyboard a mouse a keypad an image capture device a motion sensing device a microphone a device incorporating the functionality of at least two of the preceding devices and so forth. Of course other types of input devices can also be used while maintaining the spirit of the present principles. The user input devices and can be the same type of user input device or different types of user input devices. The user input devices and are used to input and output information to and from system .

Of course the processing system may also include other elements not shown as readily contemplated by one of skill in the art as well as omit certain elements. For example various other input devices and or output devices can be included in processing system depending upon the particular implementation of the same as readily understood by one of ordinary skill in the art. For example various types of wireless and or wired input and or output devices can be used. Moreover additional processors controllers memories and so forth in various configurations can also be utilized as readily appreciated by one of ordinary skill in the art. These and other variations of the processing system are readily contemplated by one of ordinary skill in the art given the teachings of the present principles provided herein.

Moreover it is to be appreciated that compiler described below with respect to is a compiler for implementing respective embodiments of the present principles. Part or all of processing system may be implemented in one or more of the elements of compiler .

Further it is to be appreciated that processing system may perform at least part of the methods described herein including for example at least part of method of and or at least part of method of . Similarly part or all of compiler may be used to perform at least part of method of and or at least part of method of . Moreover any of the multiple compiler configurations and can be used to perform at least part of method of and or at least part of method .

The compiler includes one or more front ends a middle end and one or more back ends . For the sake of simplicity only one of the front ends and only one of the back ends are shown in .

In an embodiment at least one of the front ends e.g. the one depicted in is a ROSE compiler. Of course the present principles are not limited to any of the compiler types described herein and thus other types of compilers can also be used in accordance with the teachings of the present principles while maintaining the spirit of the present principles.

Each of the front ends can include a lexical analyzer also referred to as a scanner A a syntax analyzer B and a semantic analyzer C for respectively performing a lexical analysis a syntax analysis and a semantic analysis on input code e.g. input source code . In an embodiment the lexical analyzer A outputs tokens the syntax analyzer B outputs an abstract syntax tree and the semantic analyzer C outputs a decorated abstract syntax tree. Each of the front ends can also include a parser D for parsing the input code to assist in one or more of the preceding analysis. In other embodiments the parser D is part of one or more of the analyzers e.g. analyzers B and C . Each of the front ends can further include an intermediate representation IR generator E for generating an IR of the source code for processing by the middle end . The IR is generated based on a result s of one or more of the preceding analysis. Each of the front ends can additionally include a type checker F and an error generator G for respectively performing type checking and generating errors and warnings. Each of the front ends can include a set of abstract syntax tree AST nodes H for storing any errors that occur at the time of conversion of an AST created by a domain specific language DSL compiler to an existing compiler e.g. ROSE compiler . Thus for example when the type checker F detects an error the error can be stored in one of the nodes H as described further herein below.

The middle end can include an optimizer A for performing optimizations on the intermediate representation and an intermediate representation IR generator B for generating another intermediate representation for the back end . The optimizations can include but are not limited to removing useless code relocating computations to more advantageous e.g. less frequently executed locations e.g. out of loop computation specialization based on context and so forth. The intermediate representation generated by the middle end can be source code machine code independent to enable optimizations that are shareable between different languages and target processors.

The back end can include a code generator A for generating code. The code can be assembly code or executable code already assembled . In an embodiment the code generator A can include an optimizer AA for performing optimizations e.g. target platform specific optimization including but not limited to register allocation and optimized target code utilization of target platform hardware an assembly code generator AB for generating assembly code and an assembler AC for assembling the assembly code into an executable code. The back end can generate target code via code generator A for a particular target platform e.g. a processor or set of processors and a particular operating system .

The configuration includes a DSL compiler a ROSE from DSL converter a ROSE compiler an X10 from ROSE converter and an X10 compiler .

The input to the configuration includes a program written in a DSL. The output from the configuration includes optimized code for a target language.

A DSL AST is created by the DSL compiler . The ROSE from DSL converter converts the DSL AST to a ROSE AST . The X10 from ROSE converter converts the ROSE AST to an X10 AST .

The ROSE from DSL converter the ROSE compiler and the X10 from ROSE converter can be considered to form a reusable part .

Converting the DSL AST to the ROSE AST can be implemented by using application programming interfaces APIs provided by the ROSE compiler . Thus by using the APIs the cost to implement the converter is low. Also the APIs do not depend on the grammar of the DSL.

Moreover and quite advantageously the transformations to ultimately obtain the optimized code are performed without the use of helper functions. Since helper functions are dependent on the DSL and would require three scripts a script for generating the definition of helper functions a script for applying the helper functions and a script for eliminating the applied helper functions the avoidance of using helper functions by the present principles is a significant advantage over any prior art approaches that require and use such helper scripts. For example six hundred and seventeen helper functions are necessary to support the functions of the following fourteen X10 classes Rail Float Double Int Byte Char Short Boolean UByte Ushort UInt ULong and String.

The configuration includes a DSL compiler a ROSE from DSL converter a ROSE compiler an X10 from ROSE converter and an X10 compiler.

The input to the configuration includes a program written in a DSL. The output from the configuration includes code for a target language.

A DSL AST is created by the DSL compiler by parsing the DSL source code . The ROSE from DSL converter converts the DSL AST to a ROSE AST . During compilation e.g. during type checking an error is detected and error handling is performed by the ROSE compiler . The X10 from ROSE converter converts the ROSE AST to an X10 AST . The X10 AST includes a special node where an error token from the error handling is stored that indicates information of the compilation error .

Converting the ROSE AST to the X10 AST can be implemented by using application programming interfaces APIs provided by the X10 compiler . Thus by using the APIs the cost to implement the converter is low.

Moreover and quite advantageously the transformations to ultimately obtain the output code are performed without the use of helper functions.

The input to the configuration includes X10 source code . The output from the configuration includes optimized X10 source code .

The X10 compiler parses the X10 source code generates an X10 AST and copies replaces Rail Int by int to the ROSE compiler .

The ROSE compiler generates a ROSE AST performs loop invariant hoisting and unparses to output the optimized X10 code.

At step generate by the compiler for the first language a first abstract syntax tree by parsing source code written in the first language or a domain specific language based on the first language.

At step convert by a data representation type converter the first abstract syntax tree to a second abstract syntax tree of the compiler for the second language using a conversion table from data representation types in the first language to data representation types in the second language.

At step responsive to the occurrence of a compilation error in the compiler for the second language generate therein a special node for error processing in the second abstract syntax tree and store an error token indicating information of the compilation error in the special node.

At step when unparsing by the compiler for the second language output the error token stored in the special node in the form of source code written in the first language.

At step perform a data representation type check between the source compiler and the existing compiler. While shown as a separate step it is to be appreciated that step can be performed as part of e.g. step or step .

At step store any errors identified during the data representation type check performed at step in a special AST node.

At step generate an intermediate representation IR of the input code for the middle end . In an embodiment the IR is generated based on a result s of one or more of the analysis performed in steps and and the check performed in step . In an embodiment step involves converting an abstract syntax tree AST created by the DSL compiler into an AST supported by the existing compiler.

At step generate a target code corresponding to the input code. The target code is generated from the other intermediate represented generated at step . The target code is generated to include the stored information from the special AST node as is.

Thus by referring to table of type conversions hereinafter type conversions table between a DSL and ROSE compiler when an AST created by the DSL compiler is converted into a ROSE AST if a corresponding type that is listed in the type conversions table is found the corresponding type is converted according to the conversion rule in the type conversions table and if a compilation error occurs during the semantic analysis at the time of conversion into a ROSE AST a special AST node is created to store the information of an error token when unparser outputs the source code the stored information in the special AST node is extracted as is into the output source code.

In the table correlations are made between data type representations between DSL and ROSE as follows. The correlations are used to substitute code on one side left with code on the other side right .

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

Reference in the specification to one embodiment or an embodiment of the present principles as well as other variations thereof means that a particular feature structure characteristic and so forth described in connection with the embodiment is included in at least one embodiment of the present principles. Thus the appearances of the phrase in one embodiment or in an embodiment as well any other variations appearing in various places throughout the specification are not necessarily all referring to the same embodiment.

It is to be appreciated that the use of any of the following and or and at least one of for example in the cases of A B A and or B and at least one of A and B is intended to encompass the selection of the first listed option A only or the selection of the second listed option B only or the selection of both options A and B . As a further example in the cases of A B and or C and at least one of A B and C such phrasing is intended to encompass the selection of the first listed option A only or the selection of the second listed option B only or the selection of the third listed option C only or the selection of the first and the second listed options A and B only or the selection of the first and third listed options A and C only or the selection of the second and third listed options B and C only or the selection of all three options A and B and C . This may be extended as readily apparent by one of ordinary skill in this and related arts for as many items listed.

Having described preferred embodiments of a system and method which are intended to be illustrative and not limiting it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in the particular embodiments disclosed which are within the scope of the invention as outlined by the appended claims. Having thus described aspects of the invention with the details and particularity required by the patent laws what is claimed and desired protected by Letters Patent is set forth in the appended claims.

