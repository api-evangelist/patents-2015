---

title: State recovery methods and apparatus for computing platforms
abstract: State recovery methods and apparatus for computing platforms are disclosed. An example method includes inserting a first instruction into optimized code to cause a first portion of a register in a first state to be saved to memory before execution of a region of the optimized code; and maintaining a value indicative of a manner in which a second portion of the register in the first state is to be restored in connection with a state recovery from the optimized code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507575&OS=09507575&RS=09507575
owner: INTEL CORPORATION
number: 09507575
owner_city: Santa Clara
owner_country: US
publication_date: 20150511
---
This patent arises from a continuation of U.S. patent application Ser. No. 13 538 175 filed Jun. 29 2012 the entirety of which is hereby incorporated herein by reference.

This disclosure relates generally to computing platforms and more particularly to state recovery methods and apparatus for computing platforms.

Some computing platforms attempt to improve machine level execution of code by translating the code according to one or more optimization techniques. For example original code corresponding to an iterative loop may be optimized into translated code to better utilize resources of the computing platform. In such instances when the translated code is executed in lieu of the original code an event e.g. an interrupt an exception a trap termination of an iterative loop etc. may result in a need to recover a state of the computing platform. For example when an interrupt occurs during execution of translated code corresponding to an iterative loop the system may need to recover to a state that would have resulted from execution of the original code. The state of the computing platform to be recovered includes information such as for example register content and or pointer values e.g. a value of a program counter corresponding to an instruction of the original code . As the translated code often includes different instructions and or differently ordered instructions than the original code recovery of the state of the computing platform presents challenges.

Example methods apparatus and articles of manufacture disclosed herein provide a state recovery mechanism for computing platforms that optimize original code into translated code. In particular examples disclosed herein enable such computing platforms to recover to an expected state e.g. according to execution of the original code when for example an exit from an execution of the translated code occurs e.g. in response to an interrupt exception trap etc. or when an iteration of the translated code ends. The state of the computing platform to be recovered includes information such as for example register content and or pointer values e.g. a value of a program counter corresponding to an instruction of the original code corresponding to a point in program execution to which the computing platform is to return.

As described in greater detail below examples disclosed herein insert instructions and or metadata into dynamically translated code that enable recovery of register values and or pointer values. Moreover as described in greater detail below examples disclosed herein interpret information provided by a generator of the translated code e.g. an optimizer operating according to one or more optimization techniques to translate the code . Examples disclosed herein utilize the interpretations to generate and maintain one or more tracking values e.g. bitvectors that indicate how the state of the registers is to be recovered should the need arise.

Examples disclosed herein utilize the inserted instructions and the tracking values to recover the proper state of the computing platform when needed. In doing so examples disclosed herein avoid the need to repeatedly move e.g. copy data of the registers and or pointers for each region e.g. atomic region of the translated code and or for each iteration of the translated code. Moreover the significant additional overhead incurred by having to repeatedly move the data is avoided via the examples disclosed herein.

In the illustrated example of the translator implements a vector widening technique to optimize original code. Vector widening optimization is useful when original code intended for execution via registers of a first size is to be executed via registers of a second size larger than the first size. In other words original code may be intended for compilation and execution on a first machine having registers of the first size. However the original code may be compiled and executed on a second machine e.g. a more modern or advanced computing platform than the first machine having registers of the second larger size. In such instances vector widening optimization translates the original code to take advantage of the additional space in the larger registers of the second machine.

In some examples vector widening optimization involves using the additional bits e.g. relative to the amount of register bits expected by the original code of the larger registers for parallel execution of more than one instruction or set of instructions in the same register. For example the translator may generate optimized code that enables multiple threads e.g. each corresponding to adjacent loop iterations to utilize the same register by for example using the upper bits of the larger registers. Without the vector widening optimization provided by the example translator the multiple threads utilize separate registers. Accordingly the vector widening optimization provided by the example translator results in more efficient use of system resources and thus better performance e.g. as measured by processing speed . The vector widening optimization implemented by the example translator of is further described below in connection with .

The example translator of also utilizes restricted transactional memory RTM in connection with the optimization of the original code. In brief RTM provides a hardware mechanism for executing code in atomic regions which may be executed in parallel. An atomic region of code sometimes referred to as a transaction is an isolated set of instructions that writes to registers and memory as the instructions are executed. The register and memory writes of an atomic region are committed when the region is fully executed e.g. each instruction of the region is executed as intended . However when execution of the atomic region is aborted e.g. in response to an interrupt the writes made during execution of the atomic region are rolled back or undone. RTM and the associated instructions enable hardware to implement the rollback of the register and memory writes. When RTM is used to execute code some instructions are grouped into an atomic region or transaction that is defined by an RTM BEGIN instruction e.g. XBEGIN in an Intel architecture and an RTM END instruction e.g. XEND in an Intel architecture .

To enable the rollback of register and memory writes made during a transaction systems in which RTM is implemented provide data to other system components e.g. state recovery components depending on for example a point in the code at which an abort event e.g. an interrupt a trap an exception etc. occurs. If an abort event occurs when code within a defined RTM transaction or region e.g. between the corresponding RTM BEGIN and RTM END instructions is being executed an address of the corresponding RTM BEGIN instruction is made available to for example state recovery components. If an abort event occurs when code outside a defined RTM transaction or region e.g. outside the corresponding RTM BEGIN and RTM END instructions is being executed a program counter e.g. a pointer an address of the last retired instruction in the translated code is made available to for example state recovery.

Thus the example optimizer and the example translator of implement a vector widening optimization for instructions to be executed in RTM. The vector widening optimization improves performance of original code via utilization of additional register space. Further the use of RTM enables transactional execution of code that can be rolled back such that the computing platform can recover to a particular state. While the examples disclosed herein are described in connection with vector widening and RTM the examples disclosed herein can be utilized in additional or alternative environments and or in connection with additional or alternative types of optimizations.

The example of includes a state recovery mechanism constructed in accordance with teachings of this disclosure. As described in greater detail below the example state recovery mechanism of inserts instructions disclosed herein into translated or optimized code to enable a recovery of a state of the computing platform . Moreover as described in detail below the example state recovery mechanism of generates and maintains tracking values e.g. bitvectors that store information that can be used to recover a state of the computing platform . In other words the example tracking values generated and maintained by the example state recovery mechanism of indicate a manner in which the state of the computing platform can be recovered. To generate and maintain such tracking values the state recovery mechanism of communicates with a metadata interface of the example optimizer . As described in detail below the example optimizer provides information related to the translation of original code to the state recovery mechanism via the metadata interface . In some examples the metadata interface facilitates the communication between the state recovery mechanism and the optimizer via a handshake relationship. For example the metadata interface informs the example state recovery mechanism of locations e.g. within registers and or in memory at which data corresponding to the recovery state can be retrieved. Additional communications between the example state recovery mechanism and the metadata interface are described below.

The example state recovery mechanism of includes a state preserver and a state restorer . The example state preserver of provides instructions and tracking values that enable the state restorer to recover the computing platform to a desired state in response to for example an exit event e.g. an abort a trap an exception or completion of an atomic region of the translated code. For example when translated code experiences an exit event or a region of the translated code has been completed the return instruction pointer RIP of the translated code points to an address of the translated code to which execution is to jump in response to the event or completion. To properly recover the desired state of the computing platform when needed the example state preserver tracks an address of the original code associated with the address of the translated code to which the RIP points. In other words the RIP of the translated code points to a point in the translated code and the state preserver tracks and makes available to the example state restorer the address in the original code corresponding to that point in the translated code. By tracking the address in the original code corresponding to the RIP of the translated code the example state preserver is aware of the address in the original code to which execution should return upon for example completion of the translated code or an exit from the translated code. The address of the original code at which execution resumes e.g. when exiting from a loop being executed via translated code is sometimes referred to as a program counter PC . In other words the PC for the original code corresponds to an address of the next instruction of the original code to be executed.

The example state preserver of includes first and second mechanisms to track and recover the appropriate PC for the original code. In particular the example state preserver of implements a PC recovery register and a PC recovery table . The example PC recovery register stores an address of the original code for the PC in the native format of the original code addressing scheme. The example state preserver cooperates with the example optimizer to insert load instructions into the translated code that load the appropriate address e.g. the original code address for the appropriate next instruction into the PC recovery register . The load instructions for the PC recovery register are inserted into the translated code at points in execution at which the value of the PC should be updated. For example when an exit event occurs in connection with the translated code during execution of an atomic region e.g. a chunk of code corresponding to an iteration of a loop the value of the PC to be loaded into the PC recovery register should be a first value. Further when an exit event occurs in connection with the translated code after execution of the atomic region is complete the value of the PC to be loaded into the PC recovery register should be a second value different than the first value. In this example scenario the example state preserver cooperates with the code optimizer to insert a first load instruction for the PC recovery register at a first point in the translated code before the atomic region. The first load instruction moves the first value for the PC into the PC recovery register . Further the example state preserver cooperates with the code optimizer to insert a second load instruction for the PC recovery register at a second point in the translated code after the atomic region. The second load instruction moves the second value for the PC into the PC recovery register . Accordingly the example PC recovery register of stores a value corresponding to the address in the original code depending on a location in the translated code at which the exit event occurs.

An example implementation of the recovery ability provided by the PC recovery register is shown in connection with and . illustrates an example section of original code that is to be translated by the example translator . The example original code of is a SAXPY loop Single precision alpha X plus Y . The example of shows an address for each instruction of the original code . illustrates an example translation of the original code of . The example translated code of includes different instructions than the original code and thus presents challenges to recovering the proper PC and the proper state of the corresponding registers. As described above the example computing platform includes restricted transactional memory RTM and the example translator optimizes the original code accordingly. For example as shown in the SAXPY loop of the original code has been placed into an RTM transaction by the translator . The RTM transactions which are atomic regions in the example of are respectively defined by an RTM BEGIN instruction and an RTM END instruction. For example several instructions of the SAXPY loop are implemented in an atomic region of the translated code defined by a first RTM BEGIN instruction and an RTM END instruction.

Reference to shows that an exit event occurring within the atomic region of the translated code should correspond with a return to address 0x40490a of the original code . As described above an exit event occurring within an RTM transaction causes the RIP of the translated code to point to the beginning of the transaction e.g. the corresponding RTM BEGIN instruction . Therefore when an exit event occurs within the atomic region of the address of the original code to which the PC should correspond is the beginning of the loop. Accordingly the example state preserver of cooperates with the code optimizer to insert a first load instruction mov RR 0x40490a into the translated code before the atomic region to load the address of the beginning of the loop in the original code . As a result the PC recovery register will store a value of 0x40490a during execution of the atomic region . Moreover the example state preserver of cooperates with the code optimizer to insert a second load instruction mov RR 0x404938 into the translated code before a second atomic region to load a different address of the original code . In particular the PC recovery register is loaded with a value of 0x404938 during execution of the second atomic region . As shown in this address in the original code corresponds to a loop instruction. Moreover the example state preserver of cooperates with the code optimizer to insert a third load instruction mov RR 0x40493a into the translated code after the first and second atomic regions to load a different address of the original code . In particular the PC recovery register is loaded with a value of 0x40493a after execution of the first and second atomic regions . As shown in this address in the original code corresponds to a next instruction in the original code .

Thus the example state preserver of maintains the value of the example PC recovery register e.g. via one or more load instructions to correspond to the appropriate address of the original code to which execution is to return. In some examples the state preserver uses data provided by the optimizer via the metadata interface to determine which address of the original code corresponds to the RIP of the translated code during execution of the translated code and or as the original code is optimized. In other words the example optimizer can inform the example state preserver of the appropriate address of the original code that should be loaded into the PC recovery register depending on for example a value of the RIP for the translated code at different points in the translated code .

Alternatively the example state preserver of can utilize the example PC recovery table to track the correct value of the PC for the original code at different points within the translated code. Similar to the use of the PC recovery register described above the example state preserver of utilizes data from the optimizer regarding a correspondence between the current RIP of the translated code and the proper address for the PC of the original code. In other words the example state preserver communicates with the metadata interface of the code optimizer to determine which value of the PC is appropriate at different points in execution of the translated code. Instead of inserting load instructions into the translated code as described above in connection with the example PC recovery register the example PC recovery table includes one or more address ranges in the translated code and the corresponding appropriate value of the PC of the original code.

The example PC recovery table includes PC values that each correspond to one of the address ranges . The example state preserver of uses data supplied via the metadata interface of the optimizer to fill in the PC values . That is the example optimizer of informs the state preserver of the proper correspondence between the addresses of the translated code and the associated proper PC value for the original code. Accordingly should an exit event occur in the translated code at an address in the 800 804 range the PC recovery table indicates that the appropriate PC value for the original code is 0x40490a. Other address ranges and the corresponding PC values are shown in .

The example PC recovery table also includes an EXTRACT bit . The example EXTRACT bit of indicates whether content of the registers has changed such that recovery of the content is necessary upon an exit event. That is in some instances execution of the translated code may not progress to a point at which content of the registers is altered. If the content of the registers has not been altered no need exists for recovery or re creation of the proper state of the registers. The example EXTRACT bit provides an option to avoid unnecessary restore procedures. In the illustrated example of the optimizer provides metadata to the state preserver indicative of a point in the translated code at which register content is to be altered. The example state preserver uses the provided metadata to set the EXTRACT bit in the table for ones of the address ranges corresponding to points in the translated code at which register content has changed or has likely undergone a change . In the example of a value of yes or true indicates that the registers require state recovery procedures while a value of no or false indicates that the registers do not require state recovery procedures. The recovery of register content is described in detail below.

The example state preserver of implements a JUMP ORIGINAL instruction for use in the translated code generated by the example code optimizer . In the example of the state preserver includes a JUMP ORIGINAL inserter to insert the instruction at a point in the translated code. In some examples the point at which the JUMP ORIGINAL instruction is to be inserted is based on data provided to the state preserver via the metadata interface . That is the example code optimizer of can inform the state preserver of the point in execution of the translated code at which the JUMP ORIGINAL instruction should be inserted. In the example translated code of and the example translated code of the JUMP ORIGINAL inserter inserts the JUMP ORIGINAL instruction at the end of the translated code.

The example JUMP ORIGINAL instruction provided by the state preserver obtains the appropriate PC value for the original code such that execution is returned to the correct address in the original code e.g. upon completion of the translated code . Depending on which one of the PC recovery register or the PC recovery table is being used to track the proper PC value for the original code the example JUMP ORIGINAL instruction either accesses the PC recovery register or analyzes the PC values of the PC recovery table . The returned value of the PC for the original code is then used to jump execution to the corresponding address of the original code. In the illustrated examples of translated code and of the inserted JUMP ORIGINAL instruction is placed at the end of the translated code. Accordingly the proper PC value of the address in the original code should correspond to the next instruction of the original code after completion of the example loop. In particular the proper value of the PC for the original code is 0x40493a when the JUMP ORIGINAL instruction is encountered in the translated code .

In addition to the proper PC value for the original code to which execution is to return upon a state recovery event the example state preserver tracks and maintains a state of the registers that should be restored upon a state recovery event. To enable recovery of the state of the registers the example state preserver includes a register preserver . The example register preserver preserves states of different types of registers such as for example vector registers and general purpose registers. In some instances the example register preserver preserves the state of a vector register differently than a general purpose register.

As described above the example code optimizer and the example translator of implement a vector widening technique to optimize original code intended for e.g. written and or compiled for registers of a first size that will be executed using registers of a second size larger than the first size. The size or length of the registers for which the original code is intended is referred to herein as OLEN original length . In the illustrated examples the OLEN of the original code is a number of bits in the type of register for which the original code is intended. For example when the original code is SSE128 code intended for Xmm registers OLEN is one hundred twenty eight 128 . The size or length of the registers of the computing platform that are used to execute code is referred to herein as TLEN target length . In the illustrated examples the TLEN is a number of bits in the type of registers for which the translated code is optimized. For example when the translator is to translate original code into translated code for execution in 512 bit AVX512 registers TLEN is five hundred twelve 512 . As described in detail below OLEN and TLEN are used by the example register preserver to preserve a state of the registers.

In the illustrated example of the register preserver includes an upper portion preserver and a lower portion preserver . Vector widening performed by the example optimizer translates the original code such that additional bits of the larger target registers are utilized to for example widen a loop for parallel execution of more than one loop iteration. That is the vector widening provided by the example optimizer may involve one or more registers including multiple portions each dedicated to execution of a separate thread or loop iteration. As a result some content e.g. data of the registers is replaced as the translated code is executed. However as described above the state of the registers corresponding to the expected state associated with the original code is to be tracked such that the state of the registers can be recovered e.g. in response to an exit event and or at boundaries of atomic regions . The example upper portion preserver is configured to preserve an upper portion of the vector registers utilized by the computing platform to execute the translated code. Further the example lower portion preserver is configured to preserve a lower portion of the vector registers utilized by the computing platform to execute the translated code.

The example upper portion preserver of includes a SAVE UPPER inserter a RESTORE UPPER inserter and a zero bit setter . The example upper portion preserver implements a SAVE UPPER instruction that is inserted into translated code to preserve an upper portion of vector registers of the computing platform . In particular the SAVE UPPER instruction causes data of the upper portion of the registers to be saved to memory e.g. Random Access Memory RAM . In the example of the upper portion preserver defines the portion of the registers to be saved to memory according to the values of OLEN and TLEN. For example the upper portion preserver defines the upper portion of the vector registers as a range of TLEN 1 OLEN . Thus the SAVE UPPER instruction results in bits TLEN 1 OLEN of the vector registers to be saved to memory. To continue the above example when the original code is SSE128 code intended for Xmm registers and the translator is to translate the original code for execution in 512 bit AVX512 registers the SAVE UPPER instruction provided by the example register preserver saves the bits of the address range 511 128 of the vector registers to memory.

In the example of the register preserver cooperates with the code optimizer to determine a location in the translated code at which the SAVE UPPER instruction is to be inserted. For example the metadata interface provides the SAVE UPPER inserter with an address or pointer to an address in the translated code corresponding to a beginning of the translated code or a beginning of an atomic region. As shown in the example SAVE UPPER inserter inserts the SAVE UPPER instructions into a beginning portion of the translated code such that the state of the upper portions of the registers is saved to memory before the translated code begins manipulating the content of the vector registers.

The example upper portion preserver also implements a RESTORE UPPER instruction that is inserted into translated code to restore the upper portion of the vector registers. In particular the RESTORE UPPER instruction causes retrieval of the register data from the memory e.g. as stored via the SAVE UPPER instruction and a restoration of the data of the upper portions of the vector registers. As described above the example of defines the upper portion of the vector registers as TLEN 1 OLEN . Thus the RESTORE UPPER instruction results in the data stored in memory via the SAVE UPPER instruction to be written to the TLEN 1 OLEN bits of the vector registers. To continue the above example when the original code is SSE128 code intended for Xmm registers and the translator is to translate the original code for execution in 512 bit AVX512 registers the RESTORE UPPER instruction writes the data stored in memory to the address range 511 128 of the vector registers.

In the example of the register preserver cooperates with the code optimizer to determine a location in the translated code at which the RESTORE UPPER instruction is to be inserted. For example the metadata interface provides the RESTORE UPPER inserter with an address or pointer to an address in the translated code corresponding to an end of the translated code or an end of an atomic region. As shown in the example RESTORE UPPER inserter inserts the RESTORE UPPER instructions at an end portion of the translated code such that the state of the upper portions of the registers is restored after the translated code or a region of the translated code corresponding to an iteration is complete and no longer needs access to the vector registers.

Additionally the example upper portion preserver implements the zero bit setter to indicate instances in which the upper portion of one or more vector registers are to be zeroed instead of restored from memory. For example execution of translated code may proceed to a point at which the previous state of the vector registers e.g. according to the previous expected state associated with the original code does not correspond to the desired recovery state. In other words the content of the upper portions of the vector registers that was stored to memory via the SAVE UPPER instruction may no longer be the desired content for the registers upon an exit from the translated code. In some examples the register preserver or some other component may determine that the state to be saved includes all zeroes in the upper portion s . In such instances the SAVE UPPER instruction may not have to be executed. Instead the zero bit setter may be informed that the registers are to be zeroed instead of being restored from memory. To avoid the unnecessary procedure of recovering the state of the upper portions in such instances the example zero bit setter maintains a tracking value such as a bitvector for the vector registers that can be set when the upper portions of the registers should be zeroed instead of recovered from memory. For example the bitvector may include a bit for each vector register and the respective bits can be set to 1 or 0 by the example zero bit setter . In the illustrated example the metadata interface informs the example zero bit setter when one of the vector registers no longer needs to be restored from memory for a proper state recovery e.g. upon an exit event from the translated code . In response the zero bit setter sets the corresponding bit in the bitvector. Without information from the metadata interface or any other suitable source of information to the contrary the example zero bit setter keeps the bits of the bitvector at 0 such that the upper portions of the vector registers are recovered from memory. As described below in connection with the example state restorer the values of the bitvector managed by the zero bit setter are checked when the RESTORE UPPER instruction is encountered during execution of the translated code. For vector registers having a set bit e.g. 1 in the bitvector the upper portion TLEN 1 OLEN is zeroed. For vector registers having an unset bit e.g. 0 in the bitvector the upper portion is recovered from memory.

The example lower portion preserver of implements a register to register bitvector setter to enable preservation and recovery e.g. in response to an exit event in the translated code of the lower portions of vector registers of the computing platform . The example lower portion preserver generates and maintains a register to register bitvector that is set by the register to register bitvector setter in accordance with data provided via the metadata interface . As described above the optimizer and the translator utilize additional bits of the larger vector registers relative to the register size for which the original code is written and or compiled via the vector widening technique. This utilization of the vector register bits may include moving the data of the lower portion of the vector register to a different portion of the same vector register. In other words the vector widening implemented by the example optimizer may involve storing a state of the lower portion of a first vector register at a different location within the first vector register for purposes of a later potential recovery. Thus the state of the first vector register that is to be recreated or restored upon for example an exit event is stored in the same first vector register via the optimization of the original code.

When the lower portion of a vector register is to be recovered from the same vector register the example optimizer provides information to the lower portion preserver regarding a manner in which the lower portion data is to be recovered. In particular for each vector register the example metadata interface provides a tracking value indicative of an address range in the respective vector register at which the state recovery data can be found. The tracking value provided by the metadata interface is used by the example register to to register bitvector setter to set the corresponding bit s of the register to register bitvector. In the illustrated example the register preserver defines a value referred to herein as a WidenFactor. The WidenFactor is equal to TLEN OLEN. To continue the above example the WidenFactor of the illustrated example is 512 128 which evaluates to four 4 . The tracking value provided by the optimizer for each vector register has a length of log 2 WidenFactor . The register to register bitvector includes an entry for each vector register. Therefore the register to register bitvector has a length of log 2 WidenFactor the number of vector registers bits. To continue the above example with the assumption that the number of vector registers is equal to 20 the register to register bitvector is 2 20 which evaluates to forty 40 bits.

For each of the vector registers the example register to register bitvector setter uses the tracking value provided by the optimizer to set the respective bit s of the register to register bitvector. In the illustrated example when the tracking value for each vector register has a length of two 2 bits e.g. when the WidenFactor is four 4 a value of 00 corresponding to an instance in which the data does not need to be recovered from a region to which the data was relocated. For example the tracking value being 00 may correspond to an instance in which the lower portion of the vector register was not relocated inside the vector register as part of the optimization process or otherwise does not require a recovery process e.g. when the translation code has been executed to a point at which the previous state of the register is no longer valid for a state recovery process . On the other hand the tracking value may be set to 01 10 or 11. Each of the possible values of the tracking value provided via the metadata interface corresponds to a region in the corresponding vector register at which the data of a lower portion of the same vector register to be restored can be retrieved.

In particular the tracking value is set according to an equation to be utilized by the example state restorer when recovering a state of the vector registers. In the illustrated example where the tracking value is represented by d the location within a vector register from which the state recovery data is to be retrieved is OLEN d 1 OLEN d 1 . Further the lower portion of the vector register is defined as OLEN 1 0 . Accordingly upon a state recovery trigger e.g. an exit event in the translated code when the lower portion of a vector register is to be recovered from a location within itself the bits at OLEN d 1 OLEN d 1 are copied to OLEN 1 0 of the vector register. In some examples one or more additional bits of the vector register are zeroed to comply with one or more requirements of the register format and or protocol.

As an example implementation of the register to register bitvector assume that the translator has translated scalar 64 bit double precision floating point original code for a 512 bit AVX register system. Thus OLEN is sixty four 64 TLEN is five hundred twelve 512 the WidenFactor is eight 8 and each vector register has three 3 bits in the register to register bitvector. When the metadata interface provides a tracking value of two 2 for a particular vector register the example register to register bitvector setter sets the three bits of the bitvector corresponding to the particular vector register to 010. When the state restorer checks the appropriate portion of the register to register bitvector and determines that the value is 010 the value of two 2 is inserted into the above equation to identify the proper manner of restoring the lower portion of the particular vector register. When d equal two 2 in the above equation the state restorer determines that the bits at 127 64 of the vector register are to be copied to 63 0 to restore the lower portion of the vector register.

The example lower portion preserver also generates and maintains a memory register bitvector that is set by a memory to register bitvector setter . The example memory to register bitvector maintained by the example lower portion preserver indicates whether any of the registers have lower portion data that is to be restored from memory as opposed to another location of the same register to which the data was relocated per the optimization . For example the lower portion of some of the vector registers may be stored to memory as part of the optimization. Additionally in the illustrated example of entire content of the general purpose registers are copied to memory before execution of the translated code. For each of the registers having data to be restored from memory the example memory to register bitvector setter sets a corresponding entry of the memory to register bitvector. Thus when an entry in the memory to register bitvector for a particular vector register is set e.g. to 1 the example state restorer is informed that the lower portion of the vector register is to be recovered from memory upon a state recovery trigger e.g. an exit from the translated code . Further when an entry in the memory to register bitvector for a particular general purpose register is set e.g. to 1 the example state restorer is informed that the entire content of the general purpose register is to be recovered from memory. On other hand when the entry in the memory to register bitvector for the general purpose register is not set e.g. is 0 the example state restorer is informed that the general purpose register need not be recovered e.g. when the stored state of the general purpose register is no longer valid for a state recovery process . The example state restorer recovers the lower portions of the vector registers and or the entire general purpose registers according to the memory to register bitvector by copying the appropriate values from memory to the lower OLEN bits of the register bit range OLEN 1 0 .

While an example manner of implementing the platform has been illustrated in one or more of the elements processes and or devices illustrated in may be combined divided re arranged omitted eliminated and or implemented in any other way. Further the example code optimizer the example translator the example state recovery mechanism the example metadata interface the example state preserver the example state restorer the example PC recovery register the example PC recovery table the example JUMP ORIGINAL inserter the example register preserver the example upper portion preserver the example lower portion preserver the example SAVE UPPER inserter the example RESTORE UPPER inserter the example zero bit setter the example register to register bitvector setter the example memory to register bitvector setter and or more generally the example platform of may be implemented by hardware software firmware and or any combination of hardware software and or firmware. Thus for example any of the example code optimizer the example translator the example state recovery mechanism the example metadata interface the example state preserver the example state restorer the example PC recovery register the example PC recovery table the example JUMP ORIGINAL inserter the example register preserver the example upper portion preserver the example lower portion preserver the example SAVE UPPER inserter the example RESTORE UPPER inserter the example zero bit setter the example register to register bitvector setter the example memory to register bitvector setter and or more generally the example platform of could be implemented by one or more circuit s programmable processor s application specific integrated circuit s ASIC s programmable logic device s PLD s and or field programmable logic device s FPLD s etc. When any of the appended system or apparatus claims of this patent are read to cover a purely software and or firmware implementation at least one of the example code optimizer the example translator the example state recovery mechanism the example metadata interface the example state preserver the example state restorer the example PC recovery register the example PC recovery table the example JUMP ORIGINAL inserter the example register preserver the example upper portion preserver the example lower portion preserver the example SAVE UPPER inserter the example RESTORE UPPER inserter the example zero bit setter the example register to register bitvector setter the example memory to register bitvector setter and or more generally the example platform of are hereby expressly defined to include a tangible computer readable storage medium such as a memory DVD CD Blu ray etc. storing the software and or firmware. Further still the example platform of may include one or more elements processes and or devices in addition to or instead of those illustrated in and or may include more than one of any or all of the illustrated elements processes and devices.

The example state recovery mechanism of can be implemented via a micro code sequence that is inserted into program execution e.g. as a micro code assist . Additionally or alternatively the example state recovery mechanism can be an explicit recovery handler that invokes a runtime code of the computing platform to perform the functionality disclosed herein.

As mentioned above the example processes of may be implemented using coded instructions e.g. computer readable instructions stored on a tangible computer readable medium such as a hard disk drive a flash memory a read only memory ROM a compact disk CD a digital versatile disk DVD a cache a random access memory RAM and or any other storage media in which information is stored for any duration e.g. for extended time periods permanently brief instances for temporarily buffering and or for caching of the information . As used herein the term tangible computer readable medium is expressly defined to include any type of computer readable storage and to exclude propagating signals. Additionally or alternatively the example processes of may be implemented using coded instructions e.g. computer readable instructions stored on a non transitory computer readable medium such as a hard disk drive a flash memory a read only memory a compact disk a digital versatile disk a cache a random access memory and or any other storage media in which information is stored for any duration e.g. for extended time periods permanently brief instances for temporarily buffering and or for caching of the information . As used herein the term non transitory computer readable medium is expressly defined to include any type of computer readable medium and to exclude propagating signals. As used herein when the phrase at least is used as the transition term in a preamble of a claim it is open ended in the same manner as the term comprising is open ended. Thus a claim using at least as the transition term in its preamble may include elements in addition to those expressly recited in the claim.

The example state recovery mechanism determines whether the state preserver is configured to utilize the PC recovery register or the PC recovery table to track the proper value for the PC of the original code for a state recovery process block . As described above the proper value of the PC of the original code is tracked such that execution can resume from the appropriate address according to the original code when for example an exit event occurs in connection with the translated code. When the example state preserver is configured to utilize the PC recovery table block the example state preserver communicates with the optimizer via the metadata interface to generate the example PC recovery table according to the manner that the original code has been translated block . In the illustrated example the information provided to the state preserver by the optimizer includes values of the PC for the original code that should be used for a state recovery process at different address ranges in the translated code. As shown in the example PC recovery table includes the provided PC values and the corresponding address ranges of the translated code. As described above the address ranges of the translated code correspond to for example atomic regions and or the boundaries that define atomic regions of the translated code. When the PC recovery table has been generated in the example of control then proceeds to block .

Referring to block when the state preserver is configured to utilize the PC recovery register the example state preserver communicates with the optimizer via the metadata interface to obtain data to be loaded into the PC recovery register . The data to be loaded into the PC recovery register is indicative of a PC value for the original code corresponding to a current point in execution of the translated code. The example state preserver inserts load instructions into the translated code according to the information received from the optimizer such that the data stored in the PC recovery register at different point throughout execution of the translated code includes the proper value of the PC for the original code that should be used for a state recovery process at the respective points in the translated code block .

To preserve the upper portions of the vector registers of the computing platform in a certain state the example SAVE UPPER inserter inserts one or more SAVE UPPER instructions into the translated code block . When executed the SAVE UPPER instruction copies bits in the address range TLEN 1 OLEN of the vector registers to memory. Further the example RESTORE UPPER inserter inserts one more RESTORE UPPER instructions into the translated code that each correspond to a SAVE UPPER instruction block . When executed the RESTORE UPPER instruction restores the bits in the address range TLEN 1 OLEN of the vector registers from memory. The example of then ends block .

The example lower portion preserver calculates the WidenFactor for the optimization implemented by the example optimizer block . In the illustrated example the WidenFactor is TLEN OLEN. Further for the vector registers having a state of the corresponding lower portion stored in the same vector register for purposes of a state recovery the example register to register bitvector setter configures the bit s in the register to register bitvector maintained by the example lower portion preserver block . As described above the example register to register bitvector setter uses a tracking value provided by the optimizer to set the appropriate bit s of the register to register bitvector. The tracking value provided by the optimizer is indicative of a location in a vector register at which the data of the lower portion to be restored has been relocated. If an updated tracking value is provided by the optimizer during execution of the translated code block the example register to register bitvector setter adjusts the register to register bitvector accordingly block . When the execution of the translated code is not complete block control returns to block . Otherwise the example of ends block .

Thus if the EXTRACT bit is set in the entry of the PC recovery table block or if the state preserver is utilizing the PC recovery register rather than the PC recovery table block the example state restorer restores the lower portions of the vector registers based on the register to register bitvector block . As described above the restoration or recreation of the lower portions of the vector registers uses the respective bit s of the register to register bitvector to locate the data of the recovery state with the same vector registers. In the illustrated example the state restorer determines the location within each vector register from which the state recovery data is to be retrieved is as OLEN d 1 OLEN d 1 where the value of the respective bit s of the bitvector is represented by d. Further the lower portion of the vector register to be restored is defined as OLEN 1 0 .

The example state restorer also restores data to registers such as the general purposes registers and or vector registers having data stored in memory according to the memory to register bitvector block . After the data of the lower portions of the vector registers has been restored the example state restorer executes the RESTORE UPPER instruction which checks the value of the zero bitvector and restores the upper portions of the vector registers in accordance with the zero bitvector block . As described above a bit of the zero bitvector being set results in the corresponding upper portion being zeroed for the restoration thereof. Otherwise when the bit is not set the data of the upper portions corresponding to the state being recovered is copied into the vector registers from memory where the SAVE UPPER instructions previously stored the data.

The tracked value of the PC for the original code is recovered from the PC recovery register or the PC recovery table depending on which of the recovery mechanisms is being used by the state preserver for the current instance of the translated code block . The example state restorer executes the JUMP ORIGINAL instruction using the recovered PC value such that execution jumps to the corresponding address in the original code block . The example of then ends block .

The processor platform of the instant example includes a processor . For example the processor can be implemented by one or more microprocessors or controllers from any desired family or manufacturer.

The processor includes a local memory e.g. a cache and is in communication with a main memory including a volatile memory and a non volatile memory via a bus . The volatile memory may be implemented by Synchronous Dynamic Random Access Memory SDRAM Dynamic Random Access Memory DRAM RAMBUS Dynamic Random Access Memory RDRAM and or any other type of random access memory device. The non volatile memory may be implemented by flash memory and or any other desired type of memory device. Access to the main memory is controlled by a memory controller.

The processor platform also includes an interface circuit . The interface circuit may be implemented by any type of interface standard such as an Ethernet interface a universal serial bus USB and or a PCI express interface.

One or more input devices are connected to the interface circuit . The input device s permit a user to enter data and commands into the processor . The input device s can be implemented by for example a keyboard a mouse a touchscreen a track pad a trackball isopoint and or a voice recognition system.

One or more output devices are also connected to the interface circuit . The output devices can be implemented for example by display devices e.g. a liquid crystal display a cathode ray tube display CRT a printer and or speakers . The interface circuit thus typically includes a graphics driver card.

The interface circuit also includes a communication device such as a modem or network interface card to facilitate exchange of data with external computers via a network e.g. an Ethernet connection a digital subscriber line DSL a telephone line coaxial cable a cellular telephone system etc. .

The processor platform also includes one or more mass storage devices for storing software and data. Examples of such mass storage devices include floppy disk drives hard drive disks compact disk drives and digital versatile disk DVD drives.

The coded instructions of may be stored in the mass storage device in the volatile memory in the non volatile memory and or on a removable storage medium such as a CD or DVD.

Example methods include inserting a first instruction into optimized code to cause a first portion of a register in a first state to be saved to memory before execution of a region of the optimized code and maintaining a value indicative of a manner in which a second portion of the register in the first state is to be restored in connection with a state recovery from the optimized code.

Some example methods further include inserting a second instruction into the optimized code to cause the first portion of the register in the first state to be restored from the memory after execution of the region of the optimized code.

Some example methods further include defining the first portion according to a relationship between a first size of the register and a second size of a second register associated with original code on which the optimized code is based.

In some example methods the value is to indicate the manner in which the second portion is to be restored by providing a location within the register at which data of the second portion is relocated as part of an optimization of original code.

Some example methods further include maintaining an address of original code on which the optimized code is based the address corresponding to a point in execution of the original code for a state recovery to the first state.

In some example methods the maintaining of the address includes inserting load instructions into the optimized code to cause the address to be stored in a dedicated register.

Some example methods further include storing the address in a table having an entry corresponding to the address that includes an address range of the translated code.

Example tangible machine readable storage media include instructions that when executed cause a machine to at least insert a first instruction into optimized code to cause a first portion of a register in a first state to be saved to memory before execution of a region of the optimized code and maintain a value indicative of a manner in which a second portion of the register in the first state is to be restored in connection with a state recovery from the optimized code.

In some examples the instructions when executed cause the machine to insert a second instruction into the optimized code to cause the first portion of the register in the first state to be restored from the memory after execution of the region of the optimized code.

In some examples the instructions when executed cause the machine to define the first portion according to a relationship between a first size of the register and a second size of a second register associated with original code on which the optimized code is based.

In some examples the value is to indicate the manner in which the second portion is to be restored by providing a location within the register at which data of the second portion is relocated as part of an optimization of original code.

In some examples the instructions cause the machine to maintain an address of original code on which the optimized code is based the address corresponding to a point in execution of the original code for a state recovery to the first state.

In some examples the instructions cause the machine to maintain the address by inserting load instructions into the optimized code to cause the address to be stored in a dedicated register.

In some examples the instructions cause the machine to store the address in a table having an entry corresponding to the address that includes an address range of the translated code.

Example apparatus include a register having a first size a translator to optimize original code into translated code the original code being intended for execution in registers of a second size different than the first size and a state preserver to save data of an upper portion of the register in a first state to memory before execution of a region of the translated code and maintain a value indicative of a location in the register at which data of a lower portion of the register in the first state is relocated in connection with the optimization of the original code.

Some example apparatus further include a recovery table to store an address range of the translated code and a corresponding address of the original code to which execution is to return in response to a state recovery being triggered in connection with the address range of the translated code.

In some examples the recovery table includes a bit indicative of whether data of the register in the first state is to be restored in response to the state recovery being triggered.

In some examples the state preserver is to maintain the value based on metadata provided by the translator.

Some example apparatus further include a restorer to restore the data of the upper portion of the register in the first state from the memory in response to a state recovery being triggered.

Some example apparatus further include a restorer to restore data of the lower portion of the register in the first state from the location of the register according to the value.

Although certain example apparatus methods and articles of manufacture have been disclosed herein the scope of coverage of this patent is not limited thereto. On the contrary this patent covers all apparatus methods and articles of manufacture fairly falling within the scope of the claims of this patent.

