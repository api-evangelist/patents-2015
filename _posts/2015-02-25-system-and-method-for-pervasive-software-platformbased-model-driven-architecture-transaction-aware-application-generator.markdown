---

title: System and method for pervasive software platform-based model driven architecture transaction aware application generator
abstract: In developing applications for a plurality of node types, a meta-data definition of the application can be captured into an application definition module. The meta-data definition can describe the application for the plurality of node types. A code generation module can then automatically generate the application code for the plurality of node types, including transaction aware code. The code can be compiled per node type and the packaging necessary to deploy the application to the plurality of node types can also be automatically generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424007&OS=09424007&RS=09424007
owner: Open Invention Network, LLC
number: 09424007
owner_city: Durham
owner_country: US
publication_date: 20150225
---
This application is a continuation of U.S. Ser. No. 13 151 782 filed on Jun. 2 2011 issued U.S. Pat. No. 8 978 021 issued on Mar. 10 2015. This application is related to U.S. application Ser. No. 13 151 671 filed on Jun. 2 2011 U.S. application Ser. No. 13 151 707 filed on Jun. 2 2011 and U.S. application Ser. No. 13 151 594 filed on Jun. 2 2011. The entire contents of each of these patent applications is incorporated herein by reference.

This disclosure relates to applications that run on multiple node and device types and in particular to systems and methods for generating pervasive applications.

There is an explosion of mobile and embedded devices throughout the consumer commercial and government arenas. These devices have ever increasing processing power data gathering power and data storage capacity. Additionally there is a growing need for advanced applications that are centered around the use case of a dynamic collection of people and devices for some transient period of time participated in a coordinate process task goal involving knowledge sharing. These types of application range from the DoD DHS and Commercial and Consumer worlds. The need for a software platform that enables a Distributed Knowledge Network is now very evident.

In the U.S. Ser. Nos. 13 151 671 and 13 151 594 referenced above there is described a pervasive platform that enables a distributed network of agents sensors and applications. However there remains a need to pass user interface presentation and process layer data either wired wirelessly to another device or communities of devices in a completely decentralized manner. So for example it is not possible to have an application running that can dynamically and in an ad hoc manner share move its state data and user interface from one device to another device or groups thereof that span heterogeneous networks devices and their underlying operating systems software languages software protocols and messaging capabilities.

In one aspect of the disclosure there is provided a method for creating pervasive applications executable by a plurality of node types. The method comprises capturing a meta data definition of the application into an application definition module the meta data definition describing at least the plurality of node types and whether a class of the application is transaction aware. Code per node type may be automatically generated and compiled for the plurality of node types in a code generation module including transaction aware code. The packaging necessary to deploy the application to the plurality of node types may also be generated.

In one aspect of the disclosure there is provided a system for generating applications comprising an application object model definition module and a code generator module. The application object model definition module provides an interface to receive inputs from a user that define an object model for an application including whether a class of the application is transaction aware. The code generator module generates the application code for an object model of an application defined through the application object model definition module including transaction aware code.

In one aspect of the disclosure there is provided a pervasive computing platform comprising a device API Abstraction layer configured to operate as an interface between one or more applications operating on a device and an operating platform of the device the device API abstraction layer comprising a universal set of APIs the universal set of APIs comprising a transaction API that provides an abstraction of a universal set of transaction engines.

The Universal Distributed UI and Whiteboard embodiments to be described would enable advanced collaborative applications that would span consumer enterprise and governmental segments. These advanced collaborative applications would also include those that fall into the category of Distributed Knowledge Networks and Intelligent Sensor Network based applications.

These types of advanced applications will run on the Internet of Things that include smartphones MIDs UMPCs Netbooks eBooks Auto based Computers Home Storage Devices Desktops Laptops Routers Switches Sensors and on and on. This capability at a very high level can be broken down into a Universal Distributed Business Object Whiteboard and Universal Distributed UI. There is an underlying dynamic behavior to these capabilities that may implemented using a Universal Transaction API that allows for the incremental delivery of dynamic rule sets at runtime. The Universal Distributed UI may only pertain to devices with computer screens i.e. faces but the accompanying Universal Distributed Business Object Whiteboard of data apply to any device that has memory.

The systems and methods to be described allow for advanced dynamic collaborative capabilities across heterogeneous ad hoc groups of devices. This is accomplished using technology that is outlined below in conjunction with aspects that are described in the patent applications referenced above and incorporated herein by reference. The dynamic behavior is accomplished in part by the ability to deliver rule sets incrementally and in an atomic manner to peer nodes at runtime for execution. This differs from prior art systems in which the actual behavior of the application is defined via predefined rules that are compiled into the application. Therefore the behavior of applications running on heterogeneous devices cannot be modified at runtime. This is in large part because there has been no software platform such as the platform described U.S. application Ser. No. 13 151 671 referenced above that is available with the same Peer 2 Peer and Peer 2 Group application level API s in multiple languages platforms that supports multiple protocols and messaging to simply the code generation process. Also there has been no platform that allows for the dynamic atomic distribution of rule sets and algorithms that can be executed on any peer node or group thereof. A true pervasive software platform such as described in U.S. application Ser. No. 13 151 671 with a single set of APIs for discovering accessing and hosting services and data across operating systems languages protocols and rule engines assists in making this feasible.

The remainder of the dynamic behavior is accomplished by the ability to update the user interfaces of groups of nodes again at runtime using a Universal Distributed UI. This feature also facilitates the advance collaborative capabilities. The collaborative capabilities are further enhanced by a Universal Whitboard API which allows for objects data and content to be created viewed and updated in a transaction aware manner across ad hoc communities of nodes. The transactional aspect of the whiteboard is implemented through a Universal Transaction API. A Universal Distributed UI White Board and Transaction capability are extremely powerful in and of themselves. When built using a Pervasive MDA tool such as described in U.S. application Ser. No. 13 151 594 that runs on top of a Pervasive Software Platform that supports the features needed it will allow applications with these capabilities to span any device and network. The systems and methods to be described provide tools to spawn advanced Collaborative Distributed Knowledge Network and Intelligent Sensor Network based applications that will impact every aspect of our daily lives.

The present embodiments utilize the following particular aspects and capabilities of the pervasive software platform described in U.S. application Ser. No. 13 151 671 referenced above. The Pervasive Software Platform provides a Universal set of API s for Peer 2 Peer and Peer 2 Group Application Level Messaging. The relevant APIs and modules are as follows 

The Transaction aware Universal Business Objects that are part of the application specific APIs are available on all platforms ranging from servers to sensors making use of the Universal Serialization Interface of the Pervasive Software Platform.

The Universal UI API has underlying implementations that communicates to the UI engine that is available natively on the underlying platform making use of the Universal User Interface Sub Module of the Pervasive Software Platform.

The Universal UI Remote Service is an implementation of a local Universal UI API which is remotely accessible to any other device or groups of devices on the network.

In addition to the above modules there may also be provided a Pervasive Software Platform Universal Transaction API that allows Universal Business Objects to be Transactional and participants in two phase commits.

A Pervasive Software Platform Universal Whiteboard API may also be provided that allows Universal Business Objects to be Shared Leased and Locked at various levels Read Only Read Write Write Only to Peers and Peer Groups based on pluggable policies Security Location Riles and any other Application level policies etc .

The code to provide the Universal availability of the Business Objects i.e. via universal object serialization are generated via a Universal Business Object Code Generation Process. The Generate Source Code Module of the pervasive software platform described in U.S. application Ser. No. 13 151 594 referenced above generates source code for all Mobile Data Transfer Object DTO Classes and Classes needed to support various distributed messaging payload serialization and network protocols. These classes represent the data complex objects that is passed returned as part of method invocations and responses.

The code to provide the Universal Discovery Access and Hosting of application specific Whiteboard and UI services are generated via a Universal Service Code Generation Process. This process generates Application Data Service Hosting classes for any services hosted on device leveraging the Universal Service Discovery Access Host Sub Module API of the Pervasive Computing Platform. This process includes generating the Proxy classes that are responsible for serialization de serialization of payload object reference method arguments exceptions and return values. These Proxy classes communicate with underlying Universal Core Request Brokering Sub Module API of the Pervasive Computing Platform.

An embodiment of the process for development of pervasive applications is depicted in the flowchart of . At step an application developer defines an object model and associated meta data for an application through a development interface. The specification of the meta data includes the target types any transaction aware indicators as will be described below. At step the development interface processes the meta data as per the application object model to generate the code for the application including transaction aware code. At step the development interface generates the packaging for deployment of the application to the indicated device types.

A process for capturing the application definition is shown in more detail in the flowchart of . At step the development interface receives inputs from the application developer that specify an application object model for the application. At step the development interface receives inputs that define the application nodes and node connectivity. At step the development interface receives a definition of the user interface.

In capturing the meta data a first step is to describe the Application Object Model through a tool and store it in an Object Model Repository. Above and beyond the typical data captured in an object model classes interfaces and their attributes methods exceptions etc. certain additional information is captured such as whether the class is mobile or persistent or location aware. For interfaces the meta data may include whether they are remotely accessible. All classes and interfaces are associated with one or more applications.

Once the application object model has been defined various meta data may then be captured. This usually is only done once. For example Language Types Java .NET Languages Unmanaged C Javascript PHP etc. . Virtual Machine Language Type JME JSE Dalvik .NET CF Silverlight etc. Operating System Types Linux Win Mobile CE XP Unix Blackberry MAC iPhone Symbian etc. Platform Types JSE .NET CF Android Limo Symbian Meego iPhone etc. Network Types Wire WiFi GSM CDMA WiMax LTE Bluetooth Zigbee NFC Database Types Relational Object Object relational XML Database Type Instances SqlLite DB2 DB2e Oracle Oracle Light DB40 Protocol Types SOAP HTTP XML RPC IIOP RMI IIOP OBEX REST etc. Message Types JMS MSMQ RPC Socket DDS etc. Serialization Type Binary XML JSON Character etc. Message Serialization Type. In the present embodiments the reference table setup module is modified to further allow definition of the Transaction Server Types which are supported for an application typically one or more of Java Transaction Server JTS Microsoft Transaction Server MTS Object Transaction Server OTS and mainframe transaction servers CICS IMS .

A process is used to capture information about the pervasive application. The process may comprise defining the node types associating the business processes with the particular device types and defining the messaging that occurs between node types associated with the application. For example the various Node Types participating in the application are first specified. This may be performed for example from drop down menus on the development interface or by dragging and dropping device types into the application. The main attributes that describe a Node Type are its device type platform type operating system supported networks preferred software development languages and virtual machines. Then the business processes that are desired are associated with the particular device type. The business process involves message flows between objects etc. This may be captured thru conventional OOA OOD tools such as use cases sequence diagrams and interaction diagrams.

When a business object is configured onto a node the development interface prompts the user developer to specify a whether the business object is remotely accessible b whether the business object is mobile can migrate between devices and c whether the business object is persistable. The business intelligence objects may also be rules aware.

In the pervasive computing world with applications spanning heterogeneous device sets there is the additional need for capturing additional type of messaging that occurs between node types associated with the application. This is done as follows. In the case of peer 2 peer messaging between two node types there are two important pieces of information. The first is the network type that connects the two devices IP based or some other non IP based network . The second is the preference for distributed protocols to be used when invoking services on the two devices. For example a first preference of Binary XML followed by IIOP XML RPC and SOAP if performance is a concern. The process is similar in the case of peer 2 group messaging between groups of node types. After the collection of node types is selected again as above the network type that connects these devices is selected. Then the messaging protocol is established. This list would include such protocols as TCP IP UDP JMS MSMQ or DDS for example.

The above described processes may be performed using an application development system as illustrated in . The development system may include a plurality of software modules including a reference table setup module an application object model module an application node connectivity module a user interface module a source code generation module and a distribution file generation module . The development interface also includes one or more databases for storing pervasive meta data and application data in various tables as will be described in more detail below.

The reference table setup module is shown in more detail in . The reference table module operates to provide a user interface by which a user such as an application developer may define pervasive environment reference data . This data describes the device types the device type platforms networks etc that can be utilized by any application within the organization utilizing the MDA Tool.

Through this module the enterprise architect system administrator or application developer can populate tables based on suggestions provided and knowledge of targeted devices networks platforms etc. The reference table setup module generates one or more reference data tables that are added to the pervasive meta data database . The reference data tables may be stored in XMI MOF Format in. The reference data may include the following 

By way of example a process for defining the language type is depicted in . The designer provides the language type name and description at step and defines if the language is a scripting language at step . A language table in the reference database is then updated with the new language type data at step including generating and storing an ID for the language type. Similar processes may be followed for defining the other types of reference table data mentioned above.

The system includes an Application Object Model Definition module which performs as shown in more detail in . The Application Object Model Definition module provides an interface enabling an application developer to define an object model for the application under development by way of one or more application object model tables . When defining the Business Objects it also needs to be determined if this Business Object is Transaction Aware and can participate in two phase commit Transactions. The Application Object Model Definition module may prompt the developer to define 

In prompting the developer for these definitions the Application Object Model Definition module may make reference to the reference data tables stored in the database. Once the object model has been defined for the application the Application Object Model Definition module stores the provided definitions as meta data in one or more application object model tables in the database . The object model may be stored in XMI MOF Format including data for 

To define an application a designer may initially define an application include a name and description. The application may be given an application ID which is added to an application table in the Application Object Model database. The designer may then provide an application UI type name and description which is also assigned an ID and added to an Application UI Type table in the Application Object Model database in association with the application ID for the application. Any Application Instance UI types can be similarly defined.

A process for defining an application component is depicted in . The designer selects through the development interface the application that is being developed step . The designer then enters the application component name and a description of the application component step . At step the defined application component is added to the application component table in the application object model database. Application Component Packages can be defined for an application component by selecting the application and the application component and then entering the application component package name and description. The Application Component Package data is then added to an Application Component Package Table in the Application Object Model database.

The designer may then define any classes for the application component package following a process depicted in . At step the designer enters the class name and description. The designer then selects the application component application component package parent class and interface for this class step . The designer may then provide indicators that specify whether the class is persistent location aware and mobile as well as data transfer class and agent indicators step . The data is then stored in a class table in the application object database step . Data for each of the application parameters and components mentioned above may be added in a similar manner to the process depicted in . Data fields for each of the respective application object model data tables is provided in an example database schema described below. When defining the User Interface it also needs to be determined if this User Interface will be remotely accessible to other Peers and Peer Groups.

The system may include a User Interface Definition module which may provide an interface to receive inputs from the application developer. Through this interface the developer may 

The meta data provided via the User Interface Definition module may be stored in one or more Application Instance User Interface tables . The meta data stored may include 

An example schema for the UI tables is provided in the sample database schema below. A process for defining the application instance UI data representation class is depicted in . At step the developer enters the application instance name and description. The developer then enters the respective application instance UI data representation class and name and description step . The developer then selects an application instance UI type and class step . After selection the application instance UI type class table is updated step . The developer then sets the CRUDs and Browse indicators step CUD indicators only being set if the class is persistent . These indicators are then updated in the relevant table in the Application Object Database step .

A process for defining the application instance UI Webview Source callback is depicted in . At step the developer enters the application instance UI webview page name and description. The developer then sets the application instance UI class step . A javascript HTML template file is then generated step which is used to update the class and class source tables for the application instance UI web view page class step . At step the javascript functions are generated from the class methods and CRUD indicators and used to update the Application Instance UI WebView JavaScript Function Table in the application object database step . At step the Javascript callback Classes for each Javascript function are generated. The callback class delegates calls from the corresponding javascript function to the WebView Page. This data is added to the respective Application Instance UI Source Callback table step . At step the Class and Class Source Tables in application object database are updated with Application Manager Class which contains methods to show hide each WebView Page.

The application development system may include an Application Node Connectivity module that provides an interface configured to receive input from the application developer that defines Application Node Types as well as connectivity between the node types. The developer may indicate node types in various ways such as by selecting from drop down menus that reference defined node types in the reference data tables by drag drop into an application window etc. A target type may have subtypes. For example a mobile device type may have subtypes such as MiD UMPC Smartphone PND etc.

The Application Node Connectivity module may also enable the application developer to define Peer 2 Peer Connectivity between node types. For example the user may select two Application Nodes select or indicate Network Type s between the Application Nodes and then select or indicate Distributed Protocol Type s between both Application Nodes. The network types and distributed protocol types may be indicated by selecting the available types from data provided in the reference data tables .

The Application Node Connectivity module may also enable the application developer to define Peer 2 Group Connectivity. Through this interface the developer may 

The meta data provided via the Application Node Connectivity module may be stored in the pervasive meta data database in one or more application node connectivity tables . The connectivity tables may include fields for

To enable the application developer to describe the node connectivity the system may provide information from the reference data tables as well as definitions from the Application Object Model tables . An example schema for the connectivity tables discussed above is provided below.

A process for defining a peer to peer link is depicted in . At step the developer enters a peer to peer link name and description. The developer then selects two node types that will communicate peer to peer step . This information is then added to a peer to peer link table in the application object database step .

A process for defining a peer group node type is depicted in . At step the developer enters a peer group node type name and description. The developer then selects a peer group node type step . If the selected node type hosts a peer group an indicator is turned on step . The data is then updated to a peer group node type pay table in the application object database step .

The system may include a Generate Source Code module . The generate source code module is the module that produces the application code based upon the definitions provided by the application developer in the respective tables and with reference to the reference data tables . Once the definitions for the application have been provided the Generate Source Code module reads all of the tables i.e. tables as well as tables joined from other repositories. In the code generation phase the code generator module generates the source code and either byte code or machine code for the specified target types. The Code Generator accesses class libraries or executables which are provided per target type. The code generator may generate the whole application or parts of the application.

For each node type of the application node connectivity table the generate source code module generates code for the node type using the application class library or executable library for that node type. The process for generating the source code is depicted in the flowchart of . At step the code generator module generates all Interface source code. This is generated from the Application Object tables and put in table

At step the code generator module generates source code for all Mobile Data Transfer Object DTO Classes and Classes needed to support various distributed messaging payload serialization and network protocols. The source code is generated using the data from the Application Object Model tables and .

These classes represent the data complex objects that is passed returned as part of method invocations and responses. This process utilizes the Universal Serialization Sub Module API of the Pervasive Computing Platform described in U.S. application Ser. No. 13 151 671 referenced above. The Universal Serialization API is accomplished by interfaces and accompanying methods that are implemented for a DTO to be universally Serializable. The DTO classes are generated with these interfaces methods implemented. These methods utilize the Universal Serialization Sub Module API of the Pervasive Computing Platform. At step the code generator module reads the Application Object Model tables and and generates Business Object Classes with stubbed out business process methods.

At step the code generator module processes the data tables to generate Application Data Client Access classes that allow for access to any node P2P or group of nodes P2Group using any protocol specified in the application node connectivity tables.

For P2P the code generator module utilizes the Universal Service Discovery Access Host Sub Module APIs of Pervasive Computing Platform. These modules provide the capability for services running on a device to be discovered via any other devices by name White Pages or description Yellow Pages .

For P2Group the code generator module utilizes the Universal Pub Sub Group Messaging Sub Module API of Pervasive Computing Platform. These modules provide the capability for devices to invoke method services on each other in a Peer 2 Peer manner or can publish subscribe Universal Business Objects i.e. Universally Serializable DTOs to virtual groups of heterogeneous devices.

There is Pub Sub Messaging Factory which loads an instance of the appropriate class that implements the above Pub Sub interface based on the platform the application is running on and configuration settings describing the type of publish and subscribe messaging capability desirable on such a platform.

The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal Directory with a well known name. From that point on the local application communicates with the Universal Pub Sub Messaging interface described above. Remote nodes can communicate with the remotely accessible interface by discovering it via the Universal Directory based on its well known name.

At step the code generation module generates JavaScript HTML UI JavaScript HTML to support CRUDS interface Presentation Layer.

At step the code generate module generates Native SDK Presentation Layer code to provide interact with JavaScript HTML code to with underlying Web Engine is also generated leveraging the Universal User Interface Sub Module API of the Pervasive Computing Platform. This module provides a UI API that allows for communicating bi directionally with the platforms underlying web engine WebKit IE Silverlight etc via JavaScript and support HTML 5. It allows for Bi directional communication between Application Process Layer and Presentation Layer utilizing Universal API s of Pervasive Computing Platform.

1 A remotely accessible Interface which represents the type of actions that can be done to render or access a User Interface s state

2 A locally accessible Interface which represents additional actions that are needed to interact with the underlying user interface engine

There is Universal UI Factory which loads an instance of the appropriate class that implements the above interfaces based on the platform the application is running on. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages with a well known name. From that point on the local application simply communicates with the Universal UI interface described above. Remote nodes can communicate with the remotely accessible interface by discovering it via the Universal White Pages based on its well known name.

At step the code generation module generates code for Bi directional communication between Application Process Layer and Presentation Layer utilizing Universal API s of Pervasive Computing Platform. At step the code generation module generates Application Data Service Hosting classes for any services hosted on a device. This process leverages the Universal White Pages Yellow Pages and Peer 2 Peers Sub Modules API of Pervasive Computing Platform. This step includes generating any Proxy classes that are responsible for serialization de serialization of payload object reference method arguments exceptions and return values. These Proxy classes communicate with underlying Universal Core Request Brokering Sub Module API of the Pervasive Computing Platform.

For those classes marked as persistent the corresponding database persistence code is generated at step leveraging the Universal Database Sub Module API of the underlying Pervasive Computing Platform.

1 An Interface UniversalDBAction which represents the type of actions that can be done on a database 

There is Database Factory which loads an instance of the appropriate class that implements the above interfaces based on the platform the application is running on and configuration settings describing the desired database type. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages with a well known name. From that point on the local application simply communicates with the Universal Database interface described above. Remote nodes can communicate with the remotely accessible interface by discovering it via the Universal White Pages based on its well known name.

For those classes marked as agents the corresponding agent code is generated at step leveraging the Universal Agent Sub Module API of the underlying Pervasive Computing Platform.

There is an Agent Factory which loads an instance of the appropriate class that implements the above interface based on the platform the application is running on as well as configuration information describing any particularly desired agent platform. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages with a well known name. From that point on the local application communicates with the Universal Agent interface described above.

For those classes marked as location aware the corresponding location awareness code is generated at step leveraging the Universal Location PIM Sub Module API of the underlying Pervasive Computing Platform.

For those classes methods associated with rule sets the corresponding logic to interface with the rule engine is generated at step leveraging the Universal Rules Sub Module API of the underlying Pervasive Computing Platform.

For those classes marked as transaction aware the corresponding source code is generated at step leveraging the Universal Transaction Sub Module API of the underlying pervasive computing platform. The Universal Transaction Interface allows for two phase commit transactions which can span multiple instances and types of Transaction Servers. This API can be used to deliver rule sets incrementally within the context of a transaction to pervasive nodes that are participating in rule driven whiteboard collaborative applications. A specific implementation of the enterprise transaction server s is utilized via a configuration file.

The types of Transaction Servers supported are Java Transaction Servers JTS Object Transaction Servers OTS Microsoft Transaction Servers MTS Application Transaction Monitoring Interface ATMI based and Mainframes IMS CICS though other transaction servers may become available and still others may be apparent to a person skilled in the art. The Universal Transaction API may be created from an abstraction of the API s that exist for the common and prominent types of transaction servers. Implementations of that interface can then be created that can communicate with the most common commercial and open source implementations of transaction servers.

An embodiment of the Universal Transaction Service API is depicted in . The Universal Transaction API may include 

There may be a Transaction Factory which loads an instance of the appropriate class that implements the above interfaces based on the platform the application is running. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages with a well known name. From that point on the local application communicates with the Universal Transaction interface described above. Remote nodes can communicate with the remotely accessible interface by discovering it via the Universal White Pages based on its well known name.

For those classes marked as whiteboard aware the corresponding whiteboard support code is generated at step leveraging the Universal Whiteboard Sub Module API of the underlying Pervasive Computing Platform. The system may include a Universal Whiteboard Interface that allows for Transaction Aware Universal Business Objects to be shared amongst heterogeneous dynamic communities of devices. The implementation supports objects having read write access permissions configurable lease lock and stale times configurable policy based access with default policies for security location and role permissions.

An embodiment of the Universal Whiteboard API is depicted in . The Universal Whiteboard API may include 

There is a Whiteboard Factory which loads an instance of the appropriate class that implements the above interfaces based on the platform the application is running. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages with a well known name. From that point on the local application communicates with the Universal Whiteboard interface described above. Remote nodes can communicate with the remotely accessible interface by discovering it via the Universal White Pages based on its well known name.

At step the Classes and Interfaces are aggregated based on the packages they were associated with duration definition of the Object Model for the application i.e. as described in the Application Object Model tables described above.

Finally at step generated source code for the node type may be stored in Class Interface Tables in the database . The Class Interface Tables may define 

The Universal Transaction API and Universal Whiteboard API may form part of a universal set of APIs that provides a hardware independent agent software abstraction layer of the pervasive software computing platform as described in U.S. application Ser. No. 13 151 671 referenced above. As described in that patent application the API Abstraction layer operates between a network layer representing the most common type of wired and wireless networks a.k.a. Networks and an operating platform layer which represents the most common Operating Systems and software platforms Operating Systems Platforms .

The system may include an Application Node Type Distribution File Generation Module . This module generates the corresponding application distribution file Midlet JAD Windows Mobile CAB Android APK Apple APP Blackberry COD etc based on device type platform type and selected language. Classes and Interfaces are put into libraries based on the Components they were associated with during definition of the object model for the application. The module associates specific node instances to deploy files and stores Application Node Type Distribution File in Deployment Tables including 

A process for generating the node application component is depicted in . At step the developer enters the node application component name and description. The developer then selects node type application instance application instance UI type and application components for an application component step . At step the generation module generates the resource file for modification. The application component table is then updated with the resource file data step . A process for generating the node application deployment file is depicted in . At step the developer enters the node application deployment file name and description and selects the node application components step . At step the generation module generates the application descriptor for modification and then creates the application deployment file step . The node application deployment file table is then updated step .

The Application Node Type Distribution File Generation Module may also be responsible for generating the data and files required to deploy Application Deployment File to Specific Devices. The data required may be provided in tables including 

A process for deploying the files to the devices is depicted in . At step the developer enters the node instance application deployment file name and description and selects a node instance step . The deployment file for the selected node instance is then deployed to the relevant device step . In addition the resource file and application description files are updated as necessary step and the node instance application deployment file table is updated step .

As described above the data meta data and application code may be stored as one or more tables in one or more databases such as the database . An example database design may be as follows 

The embodiments described herein may be completely decentralized and ad hoc and would be useful for business consumer and governmental business applications gaming applications etc. Additionally the platforms and MDA tools described herein and in the cross referenced patent applications allow for these types of applications to be built quickly while supporting a wide array of devices.

Although embodiments of the present invention have been illustrated in the accompanied drawings and described in the foregoing description it will be understood that the invention is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the spirit of the invention as set forth and defined by the following claims. For example the capabilities of the invention can be performed fully and or partially by one or more of the blocks modules processors or memories. Also these capabilities may be performed in the current manner or in a distributed manner and on or via any device able to provide and or receive information. Further although depicted in a particular manner various modules or blocks may be repositioned without departing from the scope of the current invention. Still further although depicted in a particular manner a greater or lesser number of modules and connections can be utilized with the present invention in order to accomplish the present invention to provide additional known features to the present invention and or to make the present invention more efficient. Also the information sent between various modules can be sent between the modules via at least one of a data network the Internet an Internet Protocol network a wireless source and a wired source and via plurality of protocols.

