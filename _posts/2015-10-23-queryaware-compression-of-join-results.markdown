---

title: Query-aware compression of join results
abstract: A method is provided for compressing results of a join query. A join order of a result set is determined from the join query, where the result set includes a plurality of tuples. A plurality of dictionary entries for the result set is received. A nested hierarchy of dictionaries is created based on the join order and the dictionary entries. A plurality of encoded tuples is received. The nested hierarchy of dictionaries is used by a processor to decode the plurality of encoded tuples so as to produce the plurality of tuples of the result set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529853&OS=09529853&RS=09529853
owner: Armonk Business Machines Corporation
number: 09529853
owner_city: Armonk
owner_country: US
publication_date: 20151023
---
The present invention generally relates to database management systems and more particularly relates to join queries.

Application programs often need to retrieve data from remote database servers using a data access API application programming interface such as JDBC Java Database Connectivity . In the case of join queries the result set from the join can be quite large. Therefore transmitting the results from the server to the client can significantly increase latency delays and also affects the query response time.

In one embodiment a method for decompressing results of a join query is disclosed. According to the method a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.

In another embodiment a computer program product for compressing results of a join query is disclosed. The computer program product comprises a computer readable storage medium having program code embodied therewith the program code readable executable by a processor to perform a method. According to the method a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.

In yet another embodiment an information processing system for compressing results of a join query is disclosed. The information processing system comprises a memory and a processor that is communicatively coupled to the memory. A result encoder is communicatively coupled to the memory and the processor. The result encoder is configured to perform a method. According to the method a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.

Other objects features and advantages of the present invention will become apparent from the following detailed description. It should be understood however that the detailed description and specific examples while indicating various embodiments of the present invention are given by way of illustration only and various modifications may naturally be performed without deviating from the present invention.

Various embodiments of the present invention will be discussed in detail hereinbelow with reference to the attached drawings.

Embodiments of the present invention compress the result sets of join queries for more efficient transmission. The join query is exploited in order to partition the join result set. The redundancy in the joined data is also exploited. For example consider the simple case in which the query is a join between two tables Table A and Table B. The join results comprise tuples with some subset of columns from Table A and another subset of columns from Table B. Without loss of generality assume the tuples are of the form . As the results are scanned a dictionary is maintained for each table the same dictionary is maintained in synchronization. As the results are scanned if a value for columns A is not in dictionary A the value is inserted into the dictionary and the value is transmitted in plaintext along with a flag. Otherwise the code for the value is transmitted. The process applies to the values of columns B . As the stream of code is read it is checked for a plaintext flag. If the flag exists the code is treated as plaintext and inserted into the dictionary. Otherwise a lookup is performed in the dictionary to decode the code. If the joins involve multiple tables a join ordering can be exploited to perform cascading or nested encoding.

While some traditional compression methods use dictionaries to indicate how various data tokens are compressed this embodiment of the present invention provides a novel nested dictionary and that is particularly suited for compressing join results of varying nesting complexity. In this embodiment a result encoder receives the join result which can be incremental from the query server and consults updates a local nested dictionary to generate the compressed query result as output. This compressed query result is then transmitted over the network and received by a result decoder at the client side. The result decoder decompresses the results using its own local nested dictionary . These decompressed results which can be incremental are then passed to the query client .

While shows the query passing through the result decoder and the query packet passing through the result encoder in some embodiments the decoder and encoder are situated in the transmission paths of the query client and query server . However this configuration is not required and the query and packets are not required to pass through these components during their transmission from the client to the server .

As shown the first table comprises two columns Col1 and Col2 . The second table comprises three columns Col3 Col4 and Col5 . In this example the issued query is a join of the two tables and with an equality condition between Col2 and Col3 . The result set is shown as a table with four columns Col1 Col2 3 Col4 and Col5 .

If this result data table were to be transmitted as shown in the data would be about 400 bytes long assuming 20 bytes per field . In particular the result data table comprises four columns of data and the following data would be transmitted.

Instead in this embodiment the size of the transmitted result data table is reduced compressed by maintaining a dictionary and that assigns a short identifier to each field value as shown in Table 1 below. The result encoder analyzes the result data table and translates each tuple into a compressed format that comprises short identifiers and also generates dictionary entry information that is transmitted therewith. Table 1 shows one example of a dictionary and that is generated for the result data table of . This example of a compressed format is Dict Entry No Col1 Dict Entry No Col2 Dict Entry No Col3 . . . Dict Entry No ColN . This format comprises a number of elements equal to the number of elements in the tuples with each identifier value of this format identifying a dictionary entry Dict Entry No and where each position in the format corresponds to a given column of the result data table .

For example the first tuple of the result data table in is A X L E . The result encoder compresses this first tuple into a compressed format that comprises short identifiers such as 1 1 1 1 . Note that because the original tuple A X L E comprises four values the compressed format also comprises four values. The compressed tuple format 1 1 1 1 identifies to the result decoder the dictionary entries to retrieve for decoding this compressed data with each position in this format corresponding to a column in the result data table and identifying which entry e.g. the first or second entry in the dictionary to use for the particular column. The compressed tuple format of 1 1 1 1 indicates that this tuple comprises the first entry in the dictionary for Col1 followed by the first entry in the dictionary for Col2 followed by the first entry in the dictionary for Col3 followed by the first entry in the dictionary for Col4 .

Stated differently each position within the compressed format corresponds to a column in the result data table . Starting from the leftmost element in the compressed format and moving to the right the first position corresponds to Col1 the second position corresponds to Col2 the third position corresponds to Col3 and the fourth position corresponds to Col4. The identifier value at each position corresponds to the entry within the dictionary e.g. the first entry for the given column where the corresponding value of the original uncompressed tuple can be located. For example a 1 in the first position of the compressed format indicates to the result decoder to look in its dictionary for the value under the first entry for Col1. As can be seen from Table 1 the result decoder decodes 1 1 1 1 into the first tuple A X L E .

The result encoder also generates dictionary entry information that is used to store information in a dictionary. Table 1 below shows one example of a dictionary maintained by both the encoder and decoder based on the dictionary entry information generated by the encoder . In this embodiment each row of the table is in itself a separate dictionary. The set of rows within the table is a nested hierarchy of dictionaries based on the join order.

In this embodiment the dictionary entries are generated in the formation of Value Row where Value is a value within the tuple and Row identifies the row within the dictionary where the value corresponding to Value is to be added. In this embodiment each row of the dictionary corresponds to a column in the result data table . For the first tuple of A X L E the result encoder generates dictionary entries A 1 X 2 L 3 and E 4 and adds these entries into its dictionary . The A in A 1 indicates that value A is to be added to the dictionary in the first row corresponding to Col1 of the result data table as indicated by the 1 . The X in X 2 indicates that value X is to be added to the dictionary in the second row corresponding to Col2 3 of the result data table as indicated by the 2 . The L in L 3 indicates that value L is to be added to the dictionary in the third row corresponding to Col4 of the result data table as indicated by the 3 . The E in E 4 indicates that value E is to be added to the dictionary in the fourth row corresponding to Col5 of the result data table as indicated by the 4 . As can be seen from Table 1 above the dictionary only comprises one unique entry for each value in the result data table . Because these dictionary entries are associated with the first tuple A X L E they are entered into the first entry location of the dictionary because no other entries have been added for the columns at this point .

In this embodiment the dictionary entries A 1 X 2 L 3 and E 4 are transmitted before the compressed tuple 1 1 1 1 and therefore are received by the result decoder prior to the compressed tuple. However this is not required. When the decoder receives these dictionary entries it adds the corresponding information into its dictionary . Therefore the dictionaries and of the encoder and decoder remain synchronized.

In this embodiment as the encoder scans the results if a value is not in its corresponding dictionary the encoder inserts the value into the dictionary and transmits the value in plaintext along with a flag. Otherwise the encoder transmits the code for the value. When the decoder receives this data it analyzes the received data to determine if there is a plaintext flag. If the flag exists the decoder treats this code as plaintext and inserts it into the corresponding dictionary. Otherwise the decoder performs a look up in the corresponding dictionary to decode the code.

For the second tuple A X M F in the result data table of the result encoder only needs to add M and F to the dictionary because A and X are already in the dictionary. Therefore the result encoder creates dictionary data items M 3 and F 4 which are transmitted in addition to the compressed tuple 1 1 2 2 . The transmitted dictionary entry data indicates that M is added to the dictionary as a second entry since L has already been added in the first entry in the third row of the result data table F is added to the dictionary as a second entry since E has already been added in the first entry in the fourth row of the result data table .

The transmitted compressed tuple 1 1 2 2 indicates to the decoder that the first element of the uncompressed tuple is the value A in the first dictionary entry in the first row corresponding to Col1 the second element is the value X in first dictionary entry in the second row corresponding to Col2 3 the third element is the value M in the second dictionary entry in the third row corresponding to Col4 and the fourth element is the value F in the dictionary second entry for the fourth row corresponding to Col5. Therefore when the result decoder receives this compressed tuple 1 1 2 2 the decoder uses its dictionary to translate 1 1 2 2 into A X M F which is the second tuple of the result data table of .

The encoder performs similar operations for the remaining tuples A Y L F B X L E and B X M F of the result data table . In particular the dictionary entries and compressed tuple for A Y L F are Y 2 and 1 2 1 2 the dictionary entries and compressed tuple for B X L E are B 1 and 2 1 1 1 and the compressed tuple for B X M F is 2 1 2 2 . The last tuple B X M F does not require any additional dictionary information because all field values of B X M F are already stored in the dictionaries and . Table 1 shows the data maintained by the dictionaries and after the encoder has generated all of the necessary dictionary entries for the result data table of . The format of the dictionary ensures that every unique value per column is transmitted only once so as to reduce redundancy.

For the example shown in the encoder transmits the following as the compressed results for the result data table of .

When the decoder receives this compressed data it builds its dictionary to comprise the same data as dictionary and decodes the compressed data to obtain the tuples A X L E A X M F A Y L F B X L E and B X M F . Overall due to this encoding only 280 bytes assuming each field is 20 bytes of data need to be transmitted including the dictionary data which is a significant savings.

If a result table is a wide table with many columns the encoder of one embodiment also applies a second compression technique. This additional compression process significantly reduces the size of the transmitted data when the result set is very wide many columns and or the join is deeply nested. Considering again the example shown in instead of encoding each column value separately the encoder of this embodiment encodes each tuple of each side of a join separately. In the example of there are three tuples on the left side Table of the join AX AY and BX. There are also three tuples on the right side Table of the join XLE XMF and YLF. When the encoder is going to transmit the first tuple A X L E the encoder first generates a dictionary entry for the left component AX in the first table and a dictionary entry for the right component XLE in the second table .

Thus in this embodiment the format of the dictionary entries is Value Row where Value is a value within the tuple and Row identifies the row within the dictionary and where the value corresponding to Value is to be added. Further in this embodiment each row of the dictionary and corresponds to each side e.g. left side or right side of the join operation. Stated differently each row corresponds to each table Table 1 and Table 2 used in the join operation. These dictionary entries are AX 1 and XLE 2 respectively.

These dictionary entries are then transmitted by the encoder followed by the compressed tuple which is now only 1 1 . The compressed tuple 1 1 indicates to the decoder to select the value A X in the first entry of the dictionary for the first table the left side of the join and also select the value XLE in the first entry of dictionary for the second table the right side of the join . In other words the compressed tuple in this embodiment has a format of Entry NO Row 1 Entry No Row 2 . The first position of the compressed tuple corresponds to the first row of the dictionary and and comprises a value identifying which entry of the first row to select and the second position of the compressed tuple corresponds to the second row of the dictionary and and comprises a value identifying which entry of the second row to select. The second tuple A X M F simply becomes a dictionary entry XMF 2 followed by the compressed tuple 1 2 and so on. The resulting dictionaries created by the encoder and decoder based on these dictionary entries is shown below in Table 2. Similar to Table 1 above the set of rows within the table is a nested hierarchy of dictionaries based on the join order.

When the decoder receives this compressed data it builds its dictionary to comprise the same data as dictionary and decodes the compressed data to obtain the tuples A X L E A X M F A Y L F B X L E and B X M F . Because the example of has a narrow result table as compared to a wide result table the compression is slightly lower e.g. 380 bytes assuming each field is 20 bytes using this process. However the compression is significantly greater when the result table is very wide and or the join is nested and or the columns are highly correlated which lead to many identical tuples on either side.

The example of uses the first two tables and and the results table of . The third table in comprises two columns Col6 and Col7 . The new join condition is an equality between Col5 of the results table and Col6 of the third table . The overall join result is shown as a new results table . One example of a set of nested dictionaries for the compression process discussed below is shown in Tables 3 and 4. In this embodiment each row of the dictionaries in Tables 3 and 4 corresponds to each table used in the respective join operation associated therewith

The first tuple in the results table is A X L E R . In order to compress this first tuple the encoder utilizes the second compression technique discussed above and creates dictionary entries ax 1 and ER 2 based on the uppermost join between table and table . Here ax 1 represents the tuple A X L E from the left side of the join i.e. Table and ER 2 represents the tuple E R from the right side of the join i.e. table . In this example A X L E is itself the result of a join from tables and . Therefore the encoder recursively encodes the tuple A X L E by considering the left side table and right side table of that join operation. In other words the ax in ax 1 represents AX XLE . Therefore the encoder creates the dictionary entries AX 1.1 and XLE 1.2 and updates its dictionaries for the left side table and right side table of the first join operation accordingly as shown in Table 4.

Therefore the overall encoding of the first tuple is AX 1.1 XLE 1.2 ax 1 ER 2 and 1 1 . This indicates that AX and XLE are added to first join s dictionary Table 4 in the first entry of the first row corresponding to Table 1 and the first entry of the second row corresponding to Table 2 respectively. The elements 1.1 and 1.2 of AX 1.1 XLE 1.2 are exemplary identifiers that indicate that the preceding element such as AX and XLE respectively is to be placed in the dictionary see Table 4 associated with the first join operation for the left row and the right row respectively. In other words the 1.1 and 1.2 value identify the table from which AX and XLE came.

The element ax in the first position of ax 1 comprises two positions a first position comprising a and a second position comprising x . The first position corresponds to the first element AX in the first dictionary entry AX 1.1 and the second position corresponds to the first element XLE in the second dictionary entry XLE 1.2 of the transmitted compressed tuple. The element ax represents the concatenation of the first entry AX of left the lower join side table and the first entry XLE of the right lower join side table . The 1 in the second position of ax 1 indicates that element ax is to be added to an entry in the first row in the upper join dictionary See Table 3 . Therefore based on this format when the decoder receives this transmitted dictionary entry information along with the compressed tuple and detects ax 1 it knows to associate a with AX and x with XLE in its dictionaries.

The element ER 2 indicates that ER is to be added to an entry in the second row of the upper join s dictionaries as shown in Table 3. The compressed tuple 1 1 represents a concatenation of the first entry ax of the left upper join side table and the first entry ER of right upper join side table . Therefore the first position in the compressed tuple 1 1 corresponds to the dictionary associated with the upper join dictionary Table 3 and the value at the first position corresponds to the entry number associated with the first row for obtaining a value. Because a 1 exists at the first position of the compressed tuple 1 1 this indicates to the decoder that the first entry is to be selected from the first row of the upper join dictionary Table 3 which comprises ax . In this embodiment the entries for the first row of the upper join dictionary can comprise a pointer or any other type of mapping to the entries of the first and second rows of the lower join dictionary. Thus the dictionaries are nested and comprise a set of leaf level dictionaries and a set of intermediate level dictionaries. The set of leaf level dictionaries map data tuple fragments to a first set of code and the set of intermediate level dictionaries map a tuple created from the first set of code to a second set of code that is smaller than the first set of code.

The second position in the compressed tuple 1 1 corresponds to the dictionary associated with the lower join dictionary and the value at the second position corresponds to the entry number associated with the second row for obtaining a value. Because a 1 exists at the second position of the compressed tuple 1 1 this indicates to the decoder that the first entry is to be selected from the second row of the lower join dictionary which comprises XLE .

Returning now to second result table the encoder encodes the second tuple A X L E S as ES 2 and 1 2 . As the encoder generates the dictionary entries it adds this dictionary information into its dictionaries . The encoder only generates a dictionary entry of ES 2 because dictionary entries have already been generated for AX and XLE . Because ES comes from the right side table of the upper join the dictionary entry comprises a 2 in the second position. This indicates that ES is to be added to the dictionary for the upper join in the second entry for Col2. The compressed tuple 1 2 indicates to the decoder that the first entry value ax for Coil of the lower join dictionary and the second entry value ES for Col2 of the upper join dictionary are to be used to decode this compressed tuple. Therefore when the decoder receives ES 2 and 1 2 it enters appropriate dictionary information based on the dictionary entry ES 2 and decodes the compressed tuple of 1 2 into A X L E S . Even though ax is equal to AX XLE and the other decoded element is equal to ES the decoded result is not A X X L E E S because a join operation has be performed. Therefore the decoded result is A X L E S .

The above processes are performed on the remaining tuples and the encoder transmits the following information to the decoder .

When the decoder receives this set of information comprising dictionary entries and compressed tuples it builds its dictionaries to decode the compressed tuples. For example the decoder translates 1 1 into A X L E R 1 2 into A X L E S 2 3 into A X M F R 3 3 into A Y L F R 4 1 into B X L E R 4 2 into B X L E S and 5 3 into B X M F R .

At line a result tuple T is obtained by joining tables T1 and T2. For example a first result tuple of T A X L E R is obtained by joining A X L E and E R where A X L E T1 and E R T2. A recursive encoding function is then called beginning at line . This recursive encoding function spans from line to line . At line a determination is made as to whether T is in a base table e.g. a table used in the join operation . If so an identifier n for T in dictionary join id is obtained where dictionary join id identifies the table from which T came from. If this Tuple T is not in the dictionary then a dictionary entry such as AX 1.1 in the format of T join id n is returned at line . Otherwise a dictionary entry is not returned at line .

If T is not in the base table then the process goes to the else branch where T Jx T1 T2 where x join id. For example the tuple A X L E R is not in a base table. Therefore for tuple A X L E R the else branch is performed so that recursive encoding functions line are called for each of the join components T1 and T2 of tuple A X L E R at lines and respectively. The output of these recursive encoding operations occurs at lines and based on whether identifiers are already in the dictionary lines and . For example recursive encoding functions are called for A X L E and E R with the recursive encoding function being performed on the A X and X L E components of A X L E . The result of this recursive encoding process for the tuple A X L E R comprises the dictionary entries of AX 1.1 XLE 1.2 ax 1 and ER 2 with a compressed tuple 1 1 .

Thus the compression technique for nested joins takes advantage of the join nesting information to provide a more efficient compression result than conventional techniques. Assuming that each field is 20 bytes an uncompressed transmission would be around 700 bytes 35 fields 20 bytes . However with the compression technique explained above with respect to the transmission size is 460 bytes. This technique can be extended to arbitrarily nested joins. Also as the amount of nesting increases the compression provided by the above compression technique also increases.

The various compression techniques discussed above are fully incremental in that one tuple can be transmitted after the other together with some dictionary entries . Thus the client can receive and decode these tuples incrementally via the decoder . This allows for overlap between decoding tuple processing and transmission so as to reduce the overall response time. Traditional compression has less information about the result set table to be compressed and therefore is much less beneficial as compared to embodiments of the present invention. Specifically conventional compression techniques do not comprise or utilize information regarding the join nesting that led to the result set. The various compression techniques of explained above can be combined or can be mixed in further embodiments to generate the compressed result.

The information processing system includes a computer . The computer has a processor s that is connected to a main memory mass storage interface and network adapter hardware . A system bus interconnects these system components. The main memory in this embodiment comprises the encoder or the decoder their components and the nested dictionaries.

Although illustrated as concurrently resident in the main memory it is clear that respective components of the main memory are not required to be completely resident in the main memory at all times or even at the same time. In this embodiment the information processing system utilizes conventional virtual addressing mechanisms to allow programs to behave as if they have access to a large single storage entity referred to herein as a computer system memory instead of access to multiple smaller storage entities such as the main memory and data storage device . The term computer system memory is used herein to generically refer to the entire virtual memory of the information processing system .

The mass storage interface is used to connect mass storage devices such as mass storage device to the information processing system . One specific type of data storage device is an optical drive such as a CD DVD drive which may be used to store data to and read data from a computer readable medium or storage product such as but not limited to a CD DVD . Another type of data storage device is a data storage device configured to support for example NTFS type file system operations.

Although only one CPU is illustrated for computer computer systems with multiple CPUs can be used equally effectively. Embodiments of the present invention further incorporate interfaces that each includes separate fully programmed microprocessors that are used to off load processing from the CPU . An operating system included in the main memory is a suitable multitasking operating system such as any of the Linux UNIX Windows and Windows Server based operating systems. Embodiments of the present invention are able to use any other suitable operating system. Some embodiments of the present invention utilize architectures such as an object oriented framework mechanism that allows instructions of the components of operating system to be executed on any processor located within the information processing system . The network adapter hardware is used to provide an interface to a network . Embodiments of the present invention are able to be adapted to work with any data communications connections including present day analog and or digital techniques and any future networking mechanism.

Although the exemplary embodiments of the present invention are described in the context of a fully functional computer system those of ordinary skill in the art will appreciate that various embodiments are capable of being distributed as a program product via CD or DVD CD ROM or other form of recordable media or via any type of electronic transmission mechanism.

The flowcharts and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. Also each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. A computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention have been discussed above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiments above were chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

