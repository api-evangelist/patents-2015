---

title: Prioritizing security findings in a SAST tool based on historical security analysis
abstract: A cloud-based static analysis security tool accessible by a set of application development environments is augmented to provide for anonymous knowledge sharing to facilitate reducing security vulnerabilities. To the end, a crowdsourcing platform and social network are associated with the application development environments. Access to the social network platform by users of the application development environments is enabled. The anonymous access enables users to post messages without exposing sensitive data associated with a particular application development environment. As the static analysis security tool is used, a knowledgebase of information regarding identified security findings, fix priorities, and so forth, is continuously updated. Social network content (e.g., in the form of analytics, workflow recommendations, and the like) is then published from the knowledgebase to provide users with security knowledge generated by the tool from the set of application development environments. The approach provides for secure and anonymous cross-organization information sharing based, for example, on analytics generated by an analytics platform.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09544327&OS=09544327&RS=09544327
owner: International Business Machines Corporation
number: 09544327
owner_city: Armonk
owner_country: US
publication_date: 20151120
---
This disclosure relates generally to identifying and remediating application vulnerabilities using static analysis tools.

Today most organizations depend on web based software and systems to run their business processes conduct transactions with suppliers and deliver sophisticated services to customers. Unfortunately many organizations invest little to no effort in ensuring that those applications are secure. Web based systems can compromise the overall security of organizations by introducing vulnerabilities that hackers can use to gain access to confidential company information or customer data.

To address this deficiency static analysis tools and services have been developed. Static security analysis or static analysis for short solutions help organization address web and mobile application vulnerabilities through a secure by design approach. This approach embeds security testing into the software development lifecycle itself providing organizations with the tools they require to develop more secure code. Static analysis tools are often used by computer software developers to provide information about computer software while applying only static considerations i.e. without executing a computer software application . Such tools simplify remediation by identifying vulnerabilities in web and mobile applications prior to their deployment generating results reports and fix recommendations through comprehensive scanning and combining advanced dynamic and innovative hybrid analyses of glass box testing run time analysis also known as integrated application security testing with static taint analysis for superior accuracy. A representative commercial offering of this type is IBM Security AppScan which enhances web application security and mobile application security improves application security program management and strengthens regulatory compliance.

Typically application analysis tools of this type are delivered to end users as traditional software packages which the user is responsible for installing configuring and maintaining. With this model there are many obstacles to quickly and effectively incorporating security analysis into application development lifecycles. For example prior to actually performing any security analysis the user first needs to download and install the tool address licensing and user management issues for the tool and then understand where and how to integrate the functionality into existing build and development workflows. The user also has to have basic familiarity with the tool interface and how to configure the product for scanning. In addition to these basic challenges additional obstacles often arise during use of the tool due to the sensitive nature of application security findings that the tool generates. In particular because these findings can be used as a guide for a malicious user to attack an application users typically are not willing to share security data even with other teams in their own organization. This leads to several sub optimal behaviors or outcomes namely little or no cross team or cross user collaboration on security analysis best practices or issue remediation a lack of interaction or feedback loops between the user and the tool provider to help improve the analysis tool in terms of accuracy performance or usefulness of the findings as well as significant duplication of work which occurs as many users scan the same source components.

A cloud based static analysis security tool accessible by a set of application development environments is augmented to provide for anonymous knowledge sharing to facilitate reducing security vulnerabilities. To the end a crowdsourcing platform and social network are associated with the application development environments. Access to the social network platform by users of the application development environments is enabled. The anonymous access enables users to post messages without exposing sensitive data associated with a particular application development environment. As the static analysis security tool is used a knowledgebase of information regarding identified security findings fix priorities and so forth is continuously updated. Social network content e.g. in the form of analytics workflow recommendations and the like is then published from the knowledgebase to provide users with security knowledge generated by the tool from the set of application development environments. The approach thus provides for secure and anonymous cross organization information sharing. To facilitate the generation of useful analytics an analytics platform is provided.

The foregoing has outlined some of the more pertinent features of the disclosed subject matter. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed subject matter in a different manner or by modifying the invention as will be described.

With reference now to the drawings and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments of the disclosure may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which aspects or embodiments of the disclosed subject matter may be implemented. Many modifications to the depicted environments may be made without departing from the spirit and scope of the present invention.

With reference now to the drawings depicts a pictorial representation of an exemplary distributed data processing system in which aspects of the illustrative embodiments may be implemented. Distributed data processing system may include a network of computers in which aspects of the illustrative embodiments may be implemented. The distributed data processing system contains at least one network which is the medium used to provide communication links between various devices and computers connected together within distributed data processing system . The network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example server and server are connected to network along with storage unit . In addition clients and are also connected to network . These clients and may be for example personal computers network computers or the like. In the depicted example server provides data such as boot files operating system images and applications to the clients and . Clients and are clients to server in the depicted example. Distributed data processing system may include additional servers clients and other devices not shown.

In the depicted example distributed data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course the distributed data processing system may also be implemented to include a number of different types of networks such as for example an intranet a local area network LAN a wide area network WAN or the like. As stated above is intended as an example not as an architectural limitation for different embodiments of the disclosed subject matter and therefore the particular elements shown in should not be considered limiting with regard to the environments in which the illustrative embodiments of the present invention may be implemented.

With reference now to a block diagram of an exemplary data processing system is shown in which aspects of the illustrative embodiments may be implemented. Data processing system is an example of a computer such as client in in which computer usable code or instructions implementing the processes for illustrative embodiments of the disclosure may be located.

With reference now to a block diagram of a data processing system is shown in which illustrative embodiments may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable program code or instructions implementing the processes may be located for the illustrative embodiments. In this illustrative example data processing system includes communications fabric which provides communications between processor unit memory persistent storage communications unit input output I O unit and display .

Processor unit serves to execute instructions for software that may be loaded into memory . Processor unit may be a set of one or more processors or may be a multi processor core depending on the particular implementation. Further processor unit may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another illustrative example processor unit may be a symmetric multi processor SMP system containing multiple processors of the same type.

Memory and persistent storage are examples of storage devices. A storage device is any piece of hardware that is capable of storing information either on a temporary basis and or a permanent basis. Memory in these examples may be for example a random access memory or any other suitable volatile or non volatile storage device. Persistent storage may take various forms depending on the particular implementation. For example persistent storage may contain one or more components or devices. For example persistent storage may be a hard drive a flash memory a rewritable optical disk a rewritable magnetic tape or some combination of the above. The media used by persistent storage also may be removable. For example a removable hard drive may be used for persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit is a network interface card. Communications unit may provide communications through the use of either or both physical and wireless communications links.

Input output unit allows for input and output of data with other devices that may be connected to data processing system . For example input output unit may provide a connection for user input through a keyboard and mouse. Further input output unit may send output to a printer. Display provides a mechanism to display information to a user.

Instructions for the operating system and applications or programs are located on persistent storage . These instructions may be loaded into memory for execution by processor unit . The processes of the different embodiments may be performed by processor unit using computer implemented instructions which may be located in a memory such as memory . These instructions are referred to as program code computer usable program code or computer readable program code that may be read and executed by a processor in processor unit . The program code in the different embodiments may be embodied on different physical or tangible computer readable media such as memory or persistent storage .

Program code is located in a functional form on computer readable media that is selectively removable and may be loaded onto or transferred to data processing system for execution by processor unit . Program code and computer readable media form computer program product in these examples. In one example computer readable media may be in a tangible form such as for example an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage for transfer onto a storage device such as a hard drive that is part of persistent storage . In a tangible form computer readable media also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that is connected to data processing system . The tangible form of computer readable media is also referred to as computer recordable storage media. In some instances computer recordable media may not be removable.

Alternatively program code may be transferred to data processing system from computer readable media through a communications link to communications unit and or through a connection to input output unit . The communications link and or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non tangible media such as communications links or wireless transmissions containing the program code. The different components illustrated for data processing system are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system . Other components shown in can be varied from the illustrative examples shown. As one example a storage device in data processing system is any hardware apparatus that may store data. Memory persistent storage and computer readable media are examples of storage devices in a tangible form.

In another example a bus system may be used to implement communications fabric and may be comprised of one or more buses such as a system bus or an input output bus. Of course the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example memory or a cache such as found in an interface and memory controller hub that may be present in communications fabric .

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C C Objective C or the like and conventional procedural programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system other than the SMP system mentioned previously without departing from the spirit and scope of the disclosed subject matter.

As will be seen the techniques described herein may operate in conjunction within the standard client server paradigm such as illustrated in in which client machines communicate with an Internet accessible Web based portal executing on a set of one or more machines. End users operate Internet connectable devices e.g. desktop computers notebook computers Internet enabled mobile devices or the like that are capable of accessing and interacting with the portal. Typically each client or server machine is a data processing system such as illustrated in comprising hardware and software and these entities communicate with one another over a network such as the Internet an intranet an extranet a private network or any other communications medium or link. A data processing system typically includes one or more processors an operating system one or more applications and one or more utilities. The applications on the data processing system provide native support for Web services including without limitation support for HTTP SOAP XML WSDL UDDI and WSFL among others. Information regarding SOAP WSDL UDDI and WSFL is available from the World Wide Web Consortium W3C which is responsible for developing and maintaining these standards further information regarding HTTP and XML is available from Internet Engineering Task Force IETF . Familiarity with these standards is presumed.

An emerging information technology IT delivery model is cloud computing by which shared resources software and information are provided over the Internet to computers and other devices on demand. Cloud computing can significantly reduce IT costs and complexities while improving workload optimization and service delivery. With this approach an application instance can be hosted and made available from Internet based resources that are accessible through a conventional Web browser over HTTP. An example application might be one that provides a common set of messaging functions such as email calendaring contact management and instant messaging. A user would then access the service directly over the Internet. Using this service an enterprise would place its email calendar and or collaboration infrastructure in the cloud and an end user would use an appropriate client to access his or her email or perform a calendar operation.

Cloud compute resources are typically housed in large server farms that run one or more network applications typically using a virtualized architecture wherein applications run inside virtual servers or so called virtual machines VMs that are mapped onto physical servers in a data center facility. The virtual machines typically run on top of a hypervisor which is a control program that allocates physical resources to the virtual machines.

Cloud computing is a model of service delivery for enabling convenient on demand network access to a shared pool of configurable computing resources e.g. networks network bandwidth servers processing memory storage applications virtual machines and services that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics at least three service models and at least four deployment models all as more particularly described and defined in Draft NIST Working Definition of Cloud Computing by Peter Mell and Tim Grance dated Oct. 7 2009.

On demand self service a cloud consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with the service s provider.

Broad network access capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones laptops and PDAs .

Resource pooling the provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or datacenter .

Rapid elasticity capabilities can be rapidly and elastically provisioned in some cases automatically to quickly scale out and rapidly released to quickly scale in. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS the capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser e.g. web based e mail . The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS the capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly application hosting environment configurations.

Infrastructure as a Service IaaS the capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on premises or off premises.

Community cloud the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns e.g. mission security requirements policy and compliance considerations . It may be managed by the organizations or a third party and may exist on premises or off premises.

Public cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.

Hybrid cloud the cloud infrastructure is a composition of two or more clouds private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

A cloud computing environment is service oriented with a focus on statelessness low coupling modularity and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes. A representative cloud computing node is as illustrated in above. In particular in a cloud computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like. Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

Referring now to by way of additional background a set of functional abstraction layers provided by a cloud computing environment is shown. It should be understood in advance that the components layers and functions shown in are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted the following layers and corresponding functions are provided 

Hardware and software layer includes hardware and software components. Examples of hardware components include mainframes in one example IBM zSeries systems RISC Reduced Instruction Set Computer architecture based servers in one example IBM pSeries systems IBM xSeries systems IBM BladeCenter systems storage devices networks and networking components. Examples of software components include network application server software in one example IBM WebSphere application server software and database software in one example IBM DB2 database software. IBM zSeries pSeries xSeries BladeCenter WebSphere and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide 

Virtualization layer provides an abstraction layer from which the following examples of virtual entities may be provided virtual servers virtual storage virtual networks including virtual private networks virtual applications and operating systems and virtual clients.

In one example management layer may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment and billing or invoicing for consumption of these resources. In one example these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement SLA planning and fulfillment provides pre arrangement for and procurement of cloud computing resources for which a future requirement is anticipated in accordance with an SLA.

Workloads layer provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include mapping and navigation software development and lifecycle management virtual classroom education delivery data analytics processing transaction processing enterprise specific functions in a private cloud and according to this disclosure static security analysis .

It is understood in advance that although this disclosure includes a detailed description on cloud computing implementation of the teachings recited herein are not limited to a cloud computing environment. Rather embodiments of the disclosed technique are capable of being implemented in conjunction with any other type of computing environment now known or later developed. These include standalone computing environments e.g. an on premises desktop machine client server based architectures and the like.

Thus a representative cloud computing environment has a set of high level functional components that include a front end identity manager a business support services BSS function component an operational support services OSS function component and the compute cloud component. The identity manager is responsible for interfacing with requesting clients to provide identity management and this component may be implemented with one or more known systems such as the Tivoli Federated Identity Manager TFIM that is available from IBM Corporation of Armonk N.Y. In appropriate circumstances TFIM may be used to provide federated single sign on F SSO to other cloud components. The business support services component provides certain administrative functions such as billing support. The operational support services component is used to provide provisioning and management of the other cloud components such as virtual machine VM instances. The cloud component represents the main computational resources which are typically a plurality of virtual machine instances that are used to execute a target application that is being made available for access via the cloud. One or more databases are used to store directory log and other working data. All of these components included the front end identity manager are located within the cloud but this is not a requirement. In an alternative embodiment the identity manager may be operated externally to the cloud. The service provider also may be operated externally to the cloud.

Some clouds are based upon non traditional IP networks. Thus for example a cloud may be based upon two tier CLOS based networks with special single layer IP routing using hashes of MAC addresses. The techniques described herein may be used in such non traditional clouds.

Generalizing the cloud computing infrastructure provides for a virtual machine hosting environment that comprises host machines e.g. servers or like physical machine computing devices connected via a network and one or more management servers. Typically the physical servers are each adapted to dynamically provide one or more virtual machines using virtualization technology such as VMware ESX ESXi. Multiple VMs can be placed into a single host machine and share the host machine s CPU memory and other resources thereby increasing the utilization of an organization s data center. Among other tasks the management server monitors the infrastructure and automatically manipulates the VM placement as needed e.g. by moving virtual machines between hosts.

In a non limiting implementation representative platform technologies are without limitation IBM System x servers with VMware vSphere 4.1 Update 1 and 5.0.

In one embodiment a static analysis tool such as IBM AppScan Enterprise Edition is implemented as a cloud based application.

As is well known static analysis tools are used by computer software developers to provide information about computer software while applying only static considerations i.e. without executing a computer software application . More formally and as used herein the term static program analysis means an analysis of a static representation of an application. In one type of static analysis data flows are traced within a computer software application from sources typically application programming interfaces API that introduce untrusted input into a program such as user input to sinks typically security sensitive operations such as modifying a database. More generally the term sink or security sink means a module function or procedure that consumes in input value and performs an operation on the input value that is security sensitive.

Such flows are identified as security vulnerabilities that may require remediation typically by ensuring that a flow that is identified as a security vulnerability encounters a downgrader that validates and or sanitizes untrusted input such as by checking whether the input contains illegal characters or is in an illegal format both common tactics used in malicious attacks. Generalizing a downgrader refers to a module routing or function that endorses sanitizes and or validates input data. Static analysis tools that identify security vulnerabilities typically provide computer software developers with a short description of each type of security vulnerability found and may even provide sample code snippets that may be used by the developer to construct a downgrader for remediating the security vulnerability.

In operation a static program analysis may analyze a call tree representing previously recorded call stacks of the application to identify security vulnerabilities that may be present in the application. The term call stack refers to a stack data structure that stores information about the active subroutines of a computer program such as an application. Without limitation the static security analysis typically takes the form of taint analysis where the analysis is parameterized by a set of security rules each rule being a triple where Source denotes source statements that read untrusted user inputs San denotes downgrader statements that endorse untrusted data by validating and or sanitizing it and Sink denotes sink statements which perform security sensitive operations. Given a security rule R any flow from a source in Sourceto a sink in Sinkthat does not pass through a downgrader from Sancomprises a potential vulnerability. This approach thus reduces security analysis to a graph reachability problem.

During static analysis of the computer program the security analysis application analyses the computer model represented by the control flow call graph to determine whether there are potential paths during execution of the computer program from the source to the sink without the user provided data being downgraded by the downgrader. One such path is indicated in the call graph by an edge. This path generally is undesirable and may indicate a security vulnerability in the computer program. In this regard the edge can represent a witness to a security vulnerability and this witness is then reported as a finding to the user.

An application analysis platform may be extended to provide for automatic generation of so called abstract program representations APRs each an APR that are amenable to static data flow analyses for finding security vulnerabilities. An abstract program representation refers to a highly compact version of the actual source code it represents. An APR for a particular source code component is generated automatically preferably from either an existing build system or a source repository and it is then encapsulated into a particular binary format for consumption by static application security tools which may operate on premises or via a cloud based services platform.

As also depicted the environment typically includes a build system and a source code repository . A generator tool is provided to automatically generate abstract program representations APRs each an APR with respect to the source code component of the application . There may be one or more abstract program representations APRs per code component and an APR may be used by more than one code component. As noted above the APR is a compact version of the actual source code it represents. The generator tool creates the APR automatically preferably from code generated within the build system itself i.e. on the fly as the code is built or by integrated directly with the source code repository that stores components already developed.

The generator tool preferably includes an additional function namely it operates to encapsulate the APR into a binary archive file which is referred to herein as an Archive for Security Analysis ARSA file . The ARSA file is sometimes referred to as a container because it contains the abstract program representation albeit in a form that does not expose details regarding the source code from which the APR is generated. In a preferred approach an ARSA file for an APR is created by serializing the APR into a compact binary file format container that preferably contains only the data necessary for static application security analysis. The ARSA file effectively obfuscates the source code that will be subjected to the static analysis. Preferably this obfuscation is accomplished with encryption and or direct manipulation and translation of sensitive data into generic data that would be unhelpful to malicious users. With this approach the ARSA file is protected from being reverse engineered even if it moved off premises into the cloud or otherwise shared with other users teams and even organizations. The ARSA file has a reduced amount of data thereby reducing the bandwidth required to transport it across the network e.g. to cloud based platform .

The generator tool typically is implemented in software e.g. as a set of computer program instructions executed by one or more hardware processors. A particular generator tool may comprise any number of programs processes execution threads and the like together with appropriate databases to support data used or created by the tool. The tool may be configured or administered with a web based front end via a command line or the like. The tool may include one or more functions that are implemented programmatically or that interoperate with other computing entities or software systems via an application programming interface API or any convenient request response protocol. One component of the generator tool may be used to create the APR while a second component of the generator tool may be used to convert the APR into the ARSA file. These functions may be separate or distinct co located or separated or implemented with distinct tools modules programs processes or devices. The particular nomenclature of the tool is provided merely for illustration purposes and is not intended to limit this disclosure.

ARSA files generated separately from different source code components may be readily merged and analyzed together to provide more effective static data flow analysis even with respect to components that are built on different machines by different teams and at different times. This merging function typically occurs in the cloud platform and thus is indicated by the merge function . The merge function may be implemented on premises as well or in a system or location dedicated to this operation. The use of component specific ARSA files that can be readily merged and tested e.g. in the cloud also facilitates incremental static analysis of the application as a whole because changes to an individual component do not necessarily require re generation and upload of ARSA files for other unaffected components.

As also seen in typically the cloud platform interoperates with other development environments that may be located remotely from the main development environment shown and that include other users teams and or organizations. The described facilitates cross user collaboration within the development environment as well as cross team and cross organization collaboration across the environments and . This collaboration may occur even with the parties remaining anonymous from one another with respect to the code component ARSAs that are provided to the cloud platform and merged there by the merge function .

By way of additional background the following provides additional details regarding the APR and how it is converted into an ARSA file. Without intending to be limiting a typical Abstract Program Representation ABR for a source code component may be described as follows 

Abstract Program Representation function declarations function definitions global variables class fields

operations call operation assignment operation return operation field load operation field store operation

The abstract program representations may be generated automatically from existing build systems in the development environment. In this embodiment the generator tool interfaces to the build system over an application programming interface API or via some other request response communication protocol. The particular technique by which the generator tool interfaces to the build system is not intending to be limited.

The basic operation is shown in the process flow in . At step a set of build artifacts is received. The routine then continues at step to analyze the build artifacts to extract certain information such as the paths to the build outputs the paths to the source code directories compile time dependencies and the like. At step the information obtained from the analysis in step is used to generate the APR. At step the APR is then converted into the ARSA file to complete the process. The ARSA file is then consumed by the SAST tool either locally or following transport to the cloud. Preferably the process shown in operates autonomously and in an automated manner generating the ARSA file as the set of build artifacts are received or otherwise made available.

Alternatively the abstract program representation is generated from the source repository. This approach typically involves the operations shown in the process flow in . The operation begins at step with the user pointing to the repository data containing the code component s that need to be scanned by the SAST tool. At step a discovery operation is initiated. In particular and in order to handle any arbitrary code extracted from source repositories the discovery process preferably is designed to be extensible with technology specific run strategies. A given run strategy determines whether a build artifact is a target that is a container of other targets and files or a file for which abstract program representation should be generated. The relationship between targets and files lends itself well to a file system hierarchy. Thus in one example the discovery operation simply identifies a containing directory as a target and then crawls through the directory to collect files of recognizable extension types. In a more complex run strategy the discovery operation treats the directory as a project e.g. from an Integrated Development Environment IDE e.g. Eclipse or Visual Studio. In either case the discovery operation extracts the metadata from such a project to find the build dependencies that would be needed for the generation of the abstract program representation. In yet another example that involves a yet more complex run strategy the discovery operation works by transforming the source it finds into other formats e.g. building of C C into object code as required. In these example scenarios which are not intended to be limited a target does not necessarily have to physically contain the files under it. For example an Ant build XML file can be thought of as a target that contains the files that the build produces and this relationship is dictated by an appropriate Ant run strategy that understands the structure of build XML files.

Generalizing the discovery process either alone or in combination with the one or more technology specific run strategies takes as input source code extracted from a repository and then identifies the targets files and related build information that are present. The various run strategies may be quite varied e.g. a scan target file strategy a directory based strategy an Eclipse Workspace strategy a build.xml strategy a custom run strategy and others. The discovery process enables the generator tool to find build artifacts when available e.g. by file browsing and direct pointing and to distinguish non build outputs identified during directory browsing from build objects e.g. class files EARs WARs JARs EXEs DLLs etc. throughout the code tree.

The process then continues at step to index the artifacts i.e. source files and build information . At this step the data collected from the discovery process is written out to a series of control files that mirrors the hierarchy of targets and files. These control files act as instructions to the generator tool and in particular to pinpoint the source files that the generator needs to process. At step the generator tool is executed against these control files to generate the abstract program representation. At step the APR is serialized and or encrypted and written into the ARSA file to complete the process.

Preferably the ARSA file generated in this manner is uploaded back to the source repository and stored together with the code that it was generated from. This enables the ARSA file to be sent for security scanning whenever needed. Moreover when other components use the code in question likely in the form of a library other users may access the repository obtain the ARSA and then stitch together the component s APR with that of the other components.

As described above preferably there are two approaches for building ARSA files automatically e.g. by plugging the ARSA generator tool into a build system or by pointing it to a source repository to thereby create a library of ARSA files that can be pulled in for analysis whenever required. This analysis is sometimes referred to herein as a whole application analysis wherein different components of the application although built at different times different locations or by different teams are still scanned together as an integrated or unitary whole. This analysis also is useful for incremental analysis wherein an individual component of the whole is updated and modified with the result updated or modified ARSA then re integrated into the whole and the result then scanned.

As noted above typically the merge operation is carried out in the cloud platform with one or more component ARSA files provided from one or more distinct sources.

The above described techniques are advantageous as they avoid traditional installation and deployment troubles that often accompany SAST tools. Because the generator tool generates obfuscated application metadata the abstract program representation users can feel comfortable uploading off site namely to the cloud. As also noted the approach thus promotes simple and effective cross user cross team and cross organization collaboration with sufficient anonymity to alleviate or ameliorate security concerns. The approach may be implemented by users that are entirely anonymous to one another. Given the protections and functionalities afforded by the described technique a cloud based security analysis platform may even expose these functionalities on a crowdsourced basis. The following provides a further description of several preferred methods for secure and anonymous collaboration between and among users of the system. As will be seen to encourage this collaboration one or more incentives may be provided to the users.

By way of additional background and as known in the art crowdsourcing has developed as an increasingly popular approach for performing certain kinds of important tasks. In a crowdsourcing effort or procedure a large group of organizations individuals and other entities that desire to provide pertinent services such as a specific community of providers or the general public are invited to participate in a task that is presented by a task requester.

As depicted the crowdsource security management environment typically includes a group of computer systems that support a crowdsourcing security analysis platform the crowdsourcing platform and an associated social network . The crowdsourcing platform executes a crowdsource management application for the purposes described below. The crowdsourcing platform and the social network in turn are hosted on the group of computer systems . As used herein group of when used with reference to items means one or more items. For example group of computer systems is one or more computer systems such as computer system . When computer system is more than one computer the computer system may take the form of a computer cluster group of computer systems or other configurations of computer systems configured to run server applications . A server application provides one or more services to support the crowdsourcing environment .

Typically an individual user or more generally entity executes a development environment system and each environment system communicates securely with social network and the crowdsourcing platform over one or more communication networks. In this example the social network may be a web based application having data entered by users. The social network typically provides various services such as provided by services to search for browse enter and modify such data . The data may include one or more user posts to a user forum that is hosted by the social network .

In general and as will be described further the crowdsourcing platform serves as a broker or intermediary between information requesters and providers who are interested in undertaking or participating in user forums or other social networking activities that are associated with the development environment s that are operated by the users. To this end the crowdsourcing platform executes the crowdsource management application typically as a set of one or more cooperating computing entities programs modules execution threads etc. and associated databases. Typically the management application is web accessible. The management application is depicted as a single application but this is not a limitation as the various functions and operations provided by the application may operate over the group of computer systems utilizing the server applications and associated services. The management application operations may be carried out in a centralized or distributed manner. Further one or more application programming interfaces APIs may be provided by or in association with the management application to provide for programmatic or automated operations.

Without limitation the crowdsourcing platform environment depicted in may be implemented in whole or in part within the cloud environment previously described although this is not a limitation.

The social network may comprise a dedicated component of the management environment or it may leverage existing social network infrastructure or services e.g. Facebook . Generalizing social network comprises a social network application that hosts a social networking site or application on a social networking server such as one or more of the server applications . The social networking application provides interfaces for clients for interacting with the different implemented functions of the social networking application. For example the social network application can allow a user to share messages images videos blog or journal posts and the like. The social networking application also allows permitted users to create their own profile and search and browse other users profiles to establish new contacts or a larger social network. One or more of such operations or functional capabilities are implemented by the services . In a typical scenario a social network is secure and open only to particular individuals as opposed to being open to the general public. To support such privacy one or more security features e.g. secure registration peer invitation peer acceptance secure posts password protected pages etc. may be implemented.

It is not required that end users interact with the crowdsourcing platform and social network via a development environment such as depicted in but this is anticipated to be a typical implementation. In an alternative environment end users interact with the platform and social network using conventional end user client machines executing HTTP or HTTPS based rendering tools such as web browsers mobile applications and the like.

According to this disclosure the crowdsourcing platform by and through its crowdsource management application provides several distinct service methods for secure and anonymous collaboration which service methods are now described. These service methods preferably include one or more of the following an anonymous discussion forum techniques to enhance or encourage collaboration among users and techniques to integrate access to third parties to enable users to obtain third party assistance with respect to application security workflow related issues.

A first service method to facilitate collaboration among such users is for the crowdsourcing platform to provide for an anonymous online discussion forum where questions and solutions can be discussed by participating forum members or participants. In this service method a user registers with the forum and is permitted to submit posts to the user forum. The user forum typically is implemented as an on line web accessible forum via secure communications between an end user machine and the machines upon which the user forum executes. The user forum may be organized by subject by chronology or the like. The user forum is output as a service in the form of one or more web pages. The user forum typically has an associated search engine front end interface although searches may also be carried out programmatically through an API. For example users who are seeking guidance about how to interpret a security finding can search the forum to find related discussions and also ask questions via posts . As noted an implementation of the online discussion forum may be provided through hosting interactive web pages on a service provider domain associated with the group of computer system a particular computer system or even a server application together with known discussion forum tools.

In one aspects preferably users of the forum are given unique names by the management application . The management application generates these unique names as needed e.g. as users join the discussion forum. A unique name is an identifier or designation that is viewed and referred to by other members. Preferably a user has no control over the user name that the management application generates and assigns to that user so there is no risk of a user name revealing too much about a user s company or project.

In addition to the system supplied unique user name preferably the management application ensures that content communicated to the platform generally and to the user forum in particular is protected against inadvertent leakage of sensitive e.g. corporate identity data. As noted above preferably the crowdsourcing occurs within the context of multiple development environments operated by distinct entities but in a manner that enforces or at least attempts to insure participant both enterprise and end user anonymity. To this end management application preferably executes one or more content parsers that look for given information or patterns in communications that original from the individual development environment entities and that may be suspicious or include information that might otherwise undermine the desired anonymity of the information exchanges that are enabled by the crowdsourcing platform. Such patterns include without limitation company name user name one or more attribution type phrases such as work at my project I m from and many others and the like.

Regarding company or user name preferably a particular entity registers with the crowdsourcing platform and thus the management application has knowledge of which company a particular user works. This information is aggregated and stored in a database a content parser searches against this database to determine whether a message to the service includes company name information. Similarly the database can be populated with one or more attribution type phrases that are searchable by the content parser to identify information that might inadvertently identify sensitive corporate data. Preferably the management application also includes one or more content parsers that process crowdsourced messages uploaded to the service to ensure that they do not inadvertently include code snippets. To this end a content parser searches received messages for use of characters or expressions most normally indicating source code such as curly braces lines ending in semi colons and various keywords such as int boolean char and the like.

Upon submission of a new message posted in or attempted to be posted to the user forum the management application processes the message through one or more content parsers to determine whether any data leakage has occurred. If the management application finds any of these or various other indications of data leakage in the message content the application alerts the user or some other designated individual and highlights the areas of the message in question. Preferably the management application also provides automatic and inline code obfuscation if the message post does include did include source code.

Preferably the management application exposes various social networking widgets such as comment widgets voting widgets rating widgets and the like throughout the various pages. Thus for example comment widgets may be used to collect information from participants about existing or new features of the platform to collect information on fix recommendations for a given security finding and so forth. Voting widgets for example may be used to enable participants to vote on which aspects of the platform they like or that they might like to see changed or modified etc. These are merely representative examples of how such widgets may be used to facilitate participant feedback.

In addition preferably the management application provides one or more incentives to facilitate user participation especially from users who can offer helpful guidance. To incentivize those users to participate in the forum preferably the management application provides a backend social networking tool that collects user ratings. For example using the social networking tools users can rate answers in terms of their usefulness. A point system associated with the ratings systems associates given system configurable points to particular ratings. Individuals that are more prolific in responding to posts or that who are rated by the peers as providing more useful answers to posts receive such points which can then be accumulated and used as credits towards additional security analysis or other prizes.

The next service method supported by the crowdsourcing platform provides for one or more improvements to how users of the system collaborate. In particular preferably the management application or exposes social networking tools pervasively across all or given pages to enable users to rate comment and influence the evolution of the system itself. To this end and to insure that users remain engaged with the system and feel that is responding to their needs preferably all pages in the system have capabilities built in e.g. via user textboxes fill in forms etc. to accept user feedback. From this information the management application either natively or with additional support e.g. from a machine learning algorithm learns and can extend and personalize responses or other information available from the forum. In one embodiment the management application includes backend machine learning ML tools to collect feedback from users or from aggregate analysis of user behaviors and engagement with the system. Direct feedback may be gathered for example by the social networking tools that are exposed throughout the forum.

With users having the ability to comment on the forum in general and the system can evolve in use preferably based on real and current usage or other activity data. As an example the management application may alter the information that is provided or otherwise exposed by the forum based on user feedback or other collected information. As another example the management application informs users when changes to the system have been made as a direct result of the user feedback. This capability enables the management application to provide information that is responsive to user needs. Preferably the system also monitors user engagement and use data e.g. such as which pages get the most attention and which may need to be removed or rethought so that the management application may be modified or updated accordingly once again with the end goal to improve continually the user experience with the collaboration site.

The management application also preferably supports the ability to personalize the system. One of the traditional problems with known security tools is that the security information provided by such tools is static and the user must internalize it and make it applicable for its environment. The problem is exacerbated when many users from the same application have to all go through that process separately. The management application addresses this problem by providing a capability for a user to customize provided data and to share that custom data with other users e.g. within a post . To take an example when a security tool finds an issue in application code such as a SQL Injection vulnerability it typically provides the user with some documentation about what the issue is what is important to fix and perhaps one or more recommendations for how to remediate this issue. All of that data can be associated with one or more posts to the forum so that others similarly situated may benefit. If a user desires to augment that information with other data to modify the existing information or to completely write their own information he or she can do so and then make that available for others to view and share. One use case this supports is a large enterprise that wants to enforce not just a security policy but also how certain issues should be fixed. One user from that organization can update the documentation and then other users can benefit. Of course these are merely representative use cases and are not intended to limit this disclosure

According to still another aspect the management application provides a service method for connecting users with other users e.g. to enable an organization to delegate some parts of the application security workflow under development. For example if a user has completed a security scan and is struggling to prioritize or remediate the issues preferably the system whether in the user forum or otherwise offers the user the ability to connect to a third party who perhaps for a fee can help with that task. Preferably third parties providing such services would be vetted before gaining access to the platform. Preferably these third parties also are subject to comments voting and ranking so that users can make good choices regarding which third parties to use and under what circumstances. In this manner the platform provides a way to match security issues to subject matter experts either within the same company or in a different company .

In addition to users manually choosing third parties preferably the management application further provides support to enable users to opt in to a capability to have the system automatically connect them with other users that may be able to help with respect to particular development related activities. For example crowdsourcing platform may interoperate with one or more of the security analysis functions of the cloud platform to provide a mechanism that makes suggestions based on the results of a security analysis. For example if a user performs an application security scan and the report contains issues that are very similar to issues found by someone else from the same or some other company the system may offers to connect those users and suggest they collaborate on the solution. Or the system could direct them to the user forum to see related discussions.

The management application also may provide for programmatic access to the system by which users generate or obtain information including without limitation customized reports specialized information or the like. Preferably and as noted above one or more application program interfaces APIs may be exposed by the platform to enable programmatic interaction with the management application. Thus certain classes of permitted users may be allowed to augment to system to facilitate analysis with additional capability. For example a business partner may want to provide a new type of analysis such as support for scanning a new language and the system provides all the appropriate extension points to do that in a way where the development efforts of the core system and the business partner can remain separate. Once again this example is not intended to be limiting.

This subject matter of the crowdsourcing platform may be implemented as a service. As previously noted and without limitation the subject matter may be implemented within or in association with a cloud deployment platform system or appliance or using any other type of deployment systems products devices programs or processes. As has been described the crowdsource management application functionality may be provided as a standalone function or it may leverage functionality from other products and services.

A representative cloud application platform with which the crowdsourcing security analysis environment and service may be implemented includes without limitation any cloud supported static analysis tool s which operating environment can be extended to facilitate secure and anonymous collaboration between and among users of the cloud based platform in the manner described.

The techniques described herein provide numerous advantages primarily cross user cross team and cross organization information sharing and collaboration all with sufficient anonymity to alleviate any possible security concerns despite the highly sensitive nature of the underlying code development activities. Indeed the approach here may be implemented by users that are entirely anonymous to one another. A fact based quantitative analysis as well as incentive based award programs provide ways to guide the evolution of the platform to provide further end user use and acceptance thereby increasing the value of the information that is made available from the site. The crowdsourced approach enables the providing of much more fine grained information to users including the providing of targeted and specific remediation advice where needed.

The crowdsourcing platform provides participants with the ability to take advantage of SAST generated security findings from others. The notion here is that historical security analysis triage and remediation data from different projects and organizations can be leveraged to help SAST tools filter and prioritize security findings which can significantly reduce the time needed to identify real security vulnerabilities and to select high priority security vulnerabilities to fix.

To this end with the SAST tool supported in the cloud preferably the system automatically collects and analyzes historical data from the users of that tool to improve the result of security findings. An analytics platform is provided for this purpose. The analytics platform typically comprises one or more analytics processes supported e.g. by the services . Using the crowdsourcing platform and social network security knowledge sharing is enabled anonymously among organizations that use the tool all without revealing sensitive data. Preferably the system supports an analysis platform that includes one or more machine learning ML algorithms that receive the security knowledge generated by the tool and then create up to date security knowledge data.

One aspect of the analytics platform is now described. This aspect deals with how security information is persisted and re used for commonly used APIs. Security information on an API is commonly referred to herein as markup. The markup describes different potential security flaws present within an API. Usually markup is added a whole package at a time. In lieu of that approach the platform may implement a method whereby the markup for commonly used APIs in the ARSA files uploaded to the cloud environment as opposed to the entire package is persisted and re used.

Preferably the process of persistence is supported in a markup REST server which is represented by server application . Preferably the markup server uses a bucket design to control the flow of markup artifacts. Thus one bucket bucket 1 may identify factory markup which is a list of currently known APIs with markup. A second bucket bucket 2 may identify missing markup which is a list of currently unknown APIs without markup. A third bucket bucket 3 may identify new markup which is a list of APIs which are targeted as high priority to markup. A fourth bucket bucket 4 may identify ignored markup which is a list of APIs that do not yet require markup. With this data the markup server can then perform one or more persistence and re use functions such as 

Identifying commonly used APIs and adding markup for them by i obtaining a list of APIs for which to obtain markup ii comparing this list against the list of known APIs with markup bucket 1 and iii saving any unknown APIs to the missing bucket bucket 2 

Identifying which APIs are important and which one might be ignored presently by i reviewing the missing bucket bucket 2 ii adding APIs that are important to the new markup bucket bucket 3 and iii adding APIs that can be ignored presently into the ignore bucket bucket 4 

Add new markup to important APIs by i adding new markup to the APIs identified as important and ii add the newly marked up APIs to the factory bucket bucket 1 for future workflow requests and

Audit added markup by answering one or more questions such as how many methods were added since date what methods were added since date how many methods were added between date and date what methods were added between date and date and so forth.

Preferably this method for persistence and re use of security information about commonly used APIs identifies APIs that were used in ARSA files submitted to the cloud SAST service thereby eliminating the need to determine a priori which libraries need markup. This approach is advantageous as it enables users of the service to obtain the latest available markup for the APIs used in their application thereby resulting in more accurate security findings. Also because the markup is done preferably on an on demand basis security researchers can be more efficient.

The information generated by the analysis platform preferably is stored in a knowledgebase which is accessible through an information retrieval mechanism. As noted preferably the information is specific to APIs and their security information.

The analytics platform may also support other service methods. One such other service method may be used to provide insights e.g. identifying actionable security findings or to enable automated learning from past scans to thereby improve the accuracy of security workflow. Such information may be generated and maintained in the knowledgebase. This service method preferably exposes several different operational components which are now described.

In one aspect an analytics process compares the security findings for the same project scanned at different times to learn the priority of security findings. For example if a cloud server scanned a project in week one and scans the same project with fixes from developers in week two there are two security analysis results for the same project. By comparing the security findings from these two analysis results the analysis process identifies which findings have been fixed by the customer client . It can be assumed that the user would have fixed severe vulnerabilities that were reported earlier as high priority and that the user would have ignore false positives or security findings that were less important to them. By looking at the security findings which customers have fixed the analysis process identifies which findings are more important than others. As more and more data is generated and collected in the knowledgebase it reflects the priority of findings.

Different industries and types of applications have different criteria to filter security findings and prioritize the fix for the security findings. Thus typically it is not generally useful to apply the same security finding ranking approach to all the applications from different industries. To address this preferably the analysis process also identifies major characteristics of applications and classifies them into different categories such as by associated industry e.g. financial services e commerce insurance entertainment etc. by public API used by the application by programming language of the application and so forth. This information preferably is collected in the knowledgebase and accessible from the crowdsourcing platform.

Given the above identified categorization scheme a project may be associated with one or more categories. For each project preferably the analysis process obtains a list of security findings and can prioritize them e.g. using the above described prioritization scheme. The resulting prioritization information i.e. the priority of security findings for the project may then be used as input to machine learning algorithm that also receives as input the category of the application and a list of security findings from the application. Using these inputs the machine learning algorithm can learn and establish a relationship between the priority of findings data and the category data. Thus when a new application with a list of security findings is presented i.e. a new project the trained machine learning algorithm can prioritize the security findings in the list.

Thus for example after the cloud based SAST tool scans a new project from a customer and obtains a list of security findings the trained machine learning algorithm preferably filters and prioritizes the security findings presented to the customer. As a more concrete example assume that the historical data of scanning applications belonging to financial services industries the category the machine learning algorithm learns that a specific type of security finding is always fixed as soon as it was reported by the SAST tool with that information in the knowledgebase the machine learning algorithm can use this information to identify such findings in future scans of applications that originate from customers clients in the financial services industry. In such circumstances there is a high likelihood that those new security findings with the same type have a high priority are thus need to be fixed promptly.

In addition to the above by analyzing data obtained over a time period and from different users the analysis program can proactively recommend or offer opinions on the security of various source components including open source revisit past scans when new security information is available notifying users of changes if necessary include specifics about issues and fixes for vulnerabilities in remediation advice as guidance for users and generally improve security analysis results based on analytics. Any of such information may be posted or otherwise published to the crowdsourcing platform and its associated social network.

The analytics platform may also provide insight into security analysis activity across the system. To this end analytics may also be performed on overall scan results on the platform to provide additional insight into security analysis activity across the system. Based on that information users can be provide useful information that may assist them in identifying the areas that are currently interesting in the security domain in choosing secure libraries and so forth. To this end when a user uploads a scan able artifact to the cloud or registers for an account in the cloud platform the user is queried whether to agree that data about the scan can be collected anonymously for analytics purposes. If the user provides consent the analytics data is then collected into a data store and made available to the knowledgebase. Based on the scan the following types of information may then be collected and available as part of the knowledgebase the vulnerability types of findings such as XSS SQL injection etc. and related function signatures for a given application which security vulnerabilities have been fixed from a previous scan as determined by comparing consecutive scan results that a user uploads program language s of the application size of the program scanning time the libraries and frameworks used by the application the density of findings and so forth. After this data is collected the cloud platform analysis process can provide different types of analytics such as top vulnerabilities identified over a given time period days weeks months etc. top vulnerabilities fixed over a given time period average time for fixing each vulnerability or a particular vulnerability most least vulnerable programming language library and framework average density of security findings and so forth. These analytics may be exposed in web accessible reports or otherwise output to the crowdsourcing platform and social network participants.

The knowledgebase also may include a compatibility database such that for each function signature representing an application function that signature may be grouped together with other e.g. semantically equivalent function signatures. For each function in the same group the knowledgebase preferably records the percentage of application s that use each of them and the system may also calculate the percentage of secure applications namely those that have some defined density findings lower than a configurable threshold . As an example the compatibility database may report the following sample findings 

 strcpy 40 of overall applications use this function 10 of high score secure applications use this function 

 strncpy 40 of overall applications use this function 20 of high score secure applications use this function 

 stricpy 40 of overall applications use this function 70 of high score secure applications use this function . 

Such a report can be sent back to a specific user to suggest more secure practices or it may be made available to the social network e.g. as a list of top vulnerabilities displayed on a dashboard.

Another aspect of the analytics platform may provide for education suggestions based on assessment analytics collected across multiple projects implemented by a particular group of users typically associated with a single organization . In this method educational requirements for a development group may be modified or aggregated e.g. based on the analysis of assessment findings from the SAST tool. This method typically assume that the SAST scan reports are available for a group s development projects or at least some of them . These scan reports preferably are provided without filtering enabled which means that the reports typically will include both false positives as well as true positives. That said preferably findings classified as noise e.g. incomplete traces non trace findings etc. are removed. Given such reports the analytics platform can be perform an analysis looking for insecure code using the following representative steps i group security finding reports by language platform ii group all security findings within each language platform group by vulnerability type e.g. XSS SQLi etc. and then iii assign the total number of security findings for each type group to that group. As a result the top vulnerabilities that are encountered most in each language platform are identifiable typically the vulnerability types that have the largest numbers assigned to them. Once these top vulnerability types are identified the analysis process can correlate them e.g. to the developers that wrote the insecure code. This correlation may be accomplished by identifying the developer that checked in the first or some other given iteration of the code and associating that iteration to the code containing the sink. Generalizing the top vulnerability grouping s are identified and used to locate one or more code files containing the sinks. Using the code repository used to check in this code the analysis program correlates the code file s with the developer s that made the check in to the repository. An identified developer is then associated mapped with a particular vulnerability type for which he or she may then be responsible. This association may be done to preserve privacy and anonymity.

Once completing the list containing the mapping of developers to the vulnerabilities they are responsible for writing into the code the analysis process may produce one or more recommendations e.g. a list identifying the specific developers as well as the additional training that might be provided for those developers. Additionally the system may add a weighting to each developer based on the number of vulnerability types that they were responsible for checking into the code repository. This provides the recommendation engine or similar functionality with additional fine grained data by which to make educational recommendations. For example if a particular developer is responsible for a majority of the SQLi vulnerability type check ins the system may recommend that this individual be moved to the top of a training list on how to spot and prevent SQL injection attacks.

The above described technique may be supplemented with machine learning algorithms or other expert systems to enhance the recommendation engine functionality. The approach ensures that educational requirements for individual s can be determined efficiently so that associated training can be appropriately targeted to where it will be of most value. This helps ensure that educational budgets are not wasted on those individual that do not need additional training.

By including false positive findings the analysis process also can determine where there exists a need for education even if the developer in question has not produced any readily exploitable code. Using the above identified approach an analysis process may also identify weaknesses in SDLC Secure Development Life Cycle .

The above described cross application and cross client analytics persistence and re use of security information about commonly used APIs techniques to learn from past scans to improve the accuracy of results and or to identify actionable security findings providing education suggestions and recommendations etc. may be expanded to include other useful information that may then be made available to the crowdsourcing platform and social network. By accessing the knowledgebase a user can obtain highly useful information that can then be leveraged to assist the user to generate and implement workflows for resolving vulnerabilities identified by static scans.

Generalizing the techniques herein may be implemented as a management solution service product appliance device process program execution thread or the like. Typically the techniques are implemented in software as one or more computer programs executed in hardware processing elements in association with data stored in one or more data sources such as a problems database. Some or all of the processing steps described may be automated and operate autonomously in association with other systems. The automation may be full or partial and the operations in whole or in part may be synchronous or asynchronous demand based or otherwise.

These above described components typically are each implemented as software i.e. as a set of computer program instructions executed in one or more hardware processors. The components are shown as distinct but this is not a requirement as the components may also be integrated with one another in whole or in part. One or more of the components may execute in a dedicated location or remote from one another. One or more of the components may have sub components that execute together to provide the functionality. There is no requirement that particular functions of the generator service be executed by a particular component as named above as the functionality herein or any aspect thereof may be implemented in other or systems.

The crowdsource management application functionality in whole or in part can interact or interoperate with security analytics systems or services.

As has been described the functionality described above may be implemented as a standalone approach e.g. one or more software based functions executed by one or more hardware processors or it may be available as a managed service including as a web service via a SOAP XML interface . The particular hardware and software implementation details described herein are merely for illustrative purposes are not meant to limit the scope of the described subject matter.

More generally computing devices within the context of the disclosed subject matter are each a data processing system such as shown in comprising hardware and software and these entities communicate with one another over a network such as the Internet an intranet an extranet a private network or any other communications medium or link. The applications on the data processing system provide native support for Web and other known services and protocols including without limitation support for HTTP FTP SMTP SOAP XML WSDL UDDI and WSFL among others. Information regarding SOAP WSDL UDDI and WSFL is available from the World Wide Web Consortium W3C which is responsible for developing and maintaining these standards further information regarding HTTP FTP SMTP and XML is available from Internet Engineering Task Force IETF .

As noted and in addition to the cloud based environment the techniques described herein may be implemented in or in conjunction with various server side architectures including simple n tier architectures web portals federated systems and the like.

Still more generally the subject matter described herein can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the security assurance service or any component thereof is implemented in software which includes but is not limited to firmware resident software microcode and the like. Furthermore the download and delete interfaces and functionality can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain or store the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical electromagnetic infrared or a semiconductor system or apparatus or device . Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD. The computer readable medium is a tangible non transitory item.

The computer program product may be a product having program instructions or program code to implement one or more of the described functions. Those instructions or code may be stored in a computer readable storage medium in a data processing system after being downloaded over a network from a remote data processing system. Or those instructions or code may be stored in a computer readable storage medium in a server data processing system and adapted to be downloaded over a network to a remote data processing system for use in a computer readable storage medium within the remote system.

In a representative embodiment the techniques are implemented in a special purpose computing platform preferably in software executed by one or more processors. The software is maintained in one or more data stores or memories associated with the one or more processors and the software may be implemented as one or more computer programs. Collectively this special purpose hardware and software comprises the functionality described above.

While the above describes a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

Finally while given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

The techniques herein provide for improvements to another technology or technical field namely static security analysis tools and systems and cloud based systems as well as improvements to the functioning of software development tools and methods.

