---

title: Managing execution of programs by multiple computing systems
abstract: Techniques are described for managing the execution of programs on multiple computing systems, such as on virtual machine nodes executing on the computing systems. A program execution service may in some situations provide the multiple computing systems and manage the program execution on behalf of multiple customers or other users, including to select appropriate computing systems to execute one or more instances of a program for a user, such as based in part on configuration information specified by the user. The described techniques may further include managing communications between multiple intercommunicating computing nodes in some situations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621593&OS=09621593&RS=09621593
owner: Amazon Technologies, Inc.
number: 09621593
owner_city: Incline Village
owner_country: US
publication_date: 20151030
---
This application is related to U.S. patent application Ser. No. 11 395 463 entitled Managing Execution Of Programs By Multiple Computing Systems which is hereby incorporated by reference in its entirety.

The following disclosure relates generally to managing communications between computing nodes such as to control outgoing transmissions of data to remote destination nodes so as to reflect dynamically determined authorizations for the transmissions.

Data centers housing significant numbers of interconnected computing systems have become commonplace such as private data centers that are operated by and on behalf of a single organization and public data centers that are operated by entities as businesses that provide access to computing resources to customers under various business models. For example some public data center operators provide network access power and secure installation facilities for hardware owned by various customers while other public data center operators provide full service facilities that also include the actual hardware resources used by their customers. However as the scale and scope of typical data centers has increased the task of provisioning administering and manacling the physical computing resources has become increasingly complicated.

The advent of virtualization technologies for commodity hardware has provided a partial solution to the problem of managing large scale computing resources for many customers with diverse needs allowing various computing resources to be efficiently and securely shared between multiple customers. For example virtualization technologies such as those provided by VMWare XEN or User Mode Linux may allow a single physical computing machine to be shared among multiple users by providing each user with one or more virtual machines hosted by the single physical computing machine with each such virtual machine being a software simulation acting as a distinct logical computing system that provides users with the illusion that they are the sole operators and administrators of a given hardware computing resource while also providing application isolation and security among the various virtual machines. Furthermore some virtualization technologies are capable of providing virtual resources that span one or more physical resources such as a single virtual machine with multiple virtual processors that actually spans multiple distinct physical computing systems.

However one problem that arises in the context of data centers that virtually or physically host large numbers of applications or systems for a set of diverse customers involves providing network isolation for the systems operated by or on behalf of each customer such as to allow communications between those systems if desired by the customer while restricting undesired communications to those systems from other systems. Traditional firewall technologies may be employed to provide limited benefits but problems persist. For example firewalls are typically configured to filter incoming network traffic at or near the destination of the traffic but this allows malicious applications to cause resource outages by flooding a given network with traffic even if the firewalls were able to perfectly block all such incoming network traffic. In addition firewalls do not typically include facilities for dynamically modifying filtering rules to reflect the types of highly dynamic resource provisioning that may occur in the context of a large scale data center hosting many thousands of virtual machines. Thus as new applications and systems come online and others go offline for example traditional firewalls lack the ability to dynamically determine appropriate filtering rules required to operate correctly instead necessitating time consuming and error prone manual configuration of such filtering rules.

Thus given such problems it would be beneficial to provide techniques that allow users to efficiently specify communications policies that are automatically enforced via management of data transmissions for multiple computing nodes such as for multiple hosted virtual machines operating in one or more data centers or other computing resource facilities.

Techniques are described for managing communications between multiple intercommunicating computing nodes. In some embodiments the computing nodes include virtual machine nodes that are hosted on one or more physical computing machines or systems and the communications include transmissions of data e.g. messages data packets or frames etc. between nodes hosted on distinct physical machines over one or more networks. In addition in some embodiments the management of a data transmission or other communication between a source node and a destination node is provided by one or more intermediary computing nodes that are capable of identifying and manipulating the communications between the source and destination nodes. For example in embodiments in which a source node and a destination node are each virtual machines hosted on two distinct physical computing machines the intermediary computing nodes may include one or more other virtual machines hosted on one or both of the two physical computing machines.

In addition in at least some embodiments the management of data transmissions includes analyzing outgoing data transmissions that are requested or otherwise initiated from a source node to one or more destination nodes in order to determine whether the data transmissions are authorized such as under control of an intermediary computing node associated with the source node and with the data transmissions being allowed to continue over one or more networks to the destination node s only if authorization is determined to exist. The determination of authorization by a intermediary computing node may for example be based at least in part on defined data transmission policies that specify groups of one or more source nodes that are authorized to communicate with groups of one or more destination nodes such as when a source node and destination node both belong to a common group of nodes. In addition an intermediary computing node associated with a source node may communicate with a distinct intermediary computing node associated with an intended destination node in order to negotiate for authorization for a data transmission and may further store a rule or other indication that reflects the results of the negotiation for use with future data transmissions from the source node to the destination node such as a transmission management rule that indicates that future such data transmissions are authorized if the negotiation indicates that authorization is provided for the current data transmission.

In some embodiments an application execution service executes third party customers applications using multiple physical machines e.g. in one or more data centers that each host multiple virtual machines which are each able to execute one or more applications for a customer and the described techniques may be used by one or more data transmission management systems executing as part of the application execution service to control communications to and from the applications of each customer. Customers may provide applications for execution to the execution service as discussed in greater detail below and may reserve execution time and other resources on physical or virtual hardware facilities provided by the execution service. In addition customers may create new groups of computing nodes e.g. multiple computing nodes that are currently each executing one of multiple instances of a program of the customer specify access policies for the groups and have the membership of the groups and or the specified access policies be updated whether automatically or manually to reflect changing conditions such as to reflect new application instances that are executed previously executing application instances that are no longer executing and or new or adjusted access policies e.g. to reflect new security requirements such as by changing whether access to other computing nodes groups and or applications is allowed or denied .

In some embodiments access policies describe source nodes also referred to as sending nodes or senders that are allowed to transmit data to a particular destination node or group of nodes such as by describing such source nodes individually e.g. via network address or other identifier via ranges of network addresses or other identifiers as one or more groups of related source nodes etc. while in other embodiments access policies may instead in a similar manner describe destination nodes that are allowed to receive data transmissions from one or more particular source nodes or groups of nodes. In the absence of specified access policies and or the ability to determine that a particular initiated data transmission is authorized some embodiments may provide default access policies and or authorization polices such as to deny all data transmissions unless determined to be authorized or instead to allow all data transmissions unless determined to not be authorized.

In one example embodiment multiple data transmission manager components of a Data Transmission Management DTM system work together to manage the data transmissions of a number of intercommunicating participant computing nodes. Initially when a participant computing node comes online a data transmission manager component associated with the participant node determines the node s network address e.g. IP address or other network location any groups to which the node belongs and indications of source nodes that are authorized to transmit data to the node. Later when the participant node attempts to initiate communication with a remote destination node the associated data transmission manager component detects the initiated communication and determines whether authorization for the communication already exists based on obtained authorization for a prior communication from the participant source node to the destination node. If existing authorization is not available the associated data transmission manager component attempts to negotiate authorization to communicate with the remote destination node such as by communicating with a remote data transmission manager component associated with the remote destination node e.g. by sending a negotiation request that triggers the negotiation a negotiation request for a data transmission from a participant source node to a destination node may contain information related to the network identity and group membership of the participant source node.

After the remote data transmission manager component associated with the remote destination node receives a negotiation request on behalf of a source node the component determines whether the source node is authorized to communicate with the remote destination node based on any access and or transmission policies of the remote destination node e.g. based on the groups of which the remote destination node is a member . If it is determined that authorization exists the remote data transmission manager component responds to the negotiation request with a reply indicating that authorization to communicate is provided. The data transmission manager component associated with the participant source node receives this reply and proceeds to allow data to be transmitted to the remote destination node whether by transmitting the data on behalf of the participant source node allowing a data transmission by the participant source node to proceed etc. . If the reply instead indicates that authorization to communicate has not been obtained the data transmission manager associated with the participant source node proceeds to prevent the data transmission to the destination node from occurring whether by dropping or otherwise discarding an intercepted data transmission by indicating to the participant source node and or others not to perform any data transmissions to the destination node etc. . In addition the data transmission manager component associated with the participant source node may cache or otherwise store the result of the negotiation so that future transmissions do not require the additional step of negotiation and the data transmission manager component associated with the destination node may similarly cache or otherwise store the result of the negotiation. In this manner data transmission manager systems dynamically determine whether the associated computing nodes that they manage are authorized to transmit data to various remote destination nodes.

For illustrative purposes some embodiments are described below in which specific types of management of communications are performed in specific types of situations. These examples are provided for illustrative purposes and are simplified for the sake of brevity and the inventive techniques can be used in a wide variety of other situations some of which are discussed below and the techniques are not limited to use with virtual nodes with outgoing data transmissions within one or more data centers etc.

In addition the example data center further comprises additional computing systems and that are not located on a rack but share a common network interconnect to a TM component associated with those additional computing systems although in other embodiments such additional non rack computing systems may not be present. In this example computing system also hosts a number of virtual machine nodes while computing systems instead act as a single physical machine node. The TM component similarly manages incoming and outgoing data transmissions for the associated virtual machine nodes hosted on computing system and for computing system nodes . An optional computing system is also illustrated at the interconnect between the data center local network and the external network such as may be employed to provide a number of services e.g. network proxies the filtering or other management of incoming and or outgoing data transmissions etc. including to manage outgoing data transmissions from some or all nodes internal to the data center to nodes located in additional data centers or other systems external to the data center and or to manage incoming data transmissions to some or all internal nodes from external nodes. An optional DTM Group Manager component is also illustrated and may provide a number of services to TM components local to the data center such as to maintain global state information for the TM components e.g. group membership information access policies etc. .

The example data center is connected to a number of other computing systems via a network e.g. the Internet including additional computing systems that may be operated by the operator of the data center or third parties additional data centers that also may be operated by the operator of the data center or third parties and an optional DTM System Manager system . In this example the DTM System Manager may maintain global state information for TM components in a number of data centers such as the illustrated data center and additional data centers . The information maintained and provided by the DTM System Manager may for example include group membership information access policies etc. Although the example DTM System Manager is depicted as being external to data center in this example embodiment in other embodiments it may instead be located within data center .

In the illustrated embodiment an example TM component is executing in memory in order to manage the data transmissions between associated nodes that are being managed and other nodes such as those represented by the illustrated other computing systems connected via a network . In the present example the managed nodes are resident on independent computing systems and are connected to the computing system and TM via a physical network although in other embodiments one or more of the managed nodes may alternatively be hosted on computing system as virtual machine nodes. further illustrates a DTM System Manager system connected to the computing system such as to maintain and provide information related to the operation of one or more TM components such as access policies and group membership as discussed in greater detail elsewhere.

It will be appreciated that computing systems and are merely illustrative and are not intended to limit the scope of the present invention. For example computing system may be connected to other devices that are not illustrated including through one or more networks such as the Internet or via the World Wide Web Web . More generally a node or other computing system may comprise any combination of hardware or software that can interact and perform the described types of functionality including without limitation desktop or other computers database servers network storage devices and other network devices PDAs cellphones wireless phones pagers electronic organizers Internet appliances television based systems e.g. using set top boxes and or personal digital video recorders and various other consumer products that include appropriate inter communication capabilities. In addition the functionality provided by the illustrated components and systems may in some embodiments be combined in fewer components or distributed in additional components. Similarly in some embodiments the functionality of some of the illustrated components may not be provided and or other additional functionality may be available.

It will also be appreciated that while various items are illustrated as being stored in memory or on storage while being used these items or portions of them can be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively in other embodiments some or all of the software components and or systems may execute in memory on another device and communicate with the illustrated computing system via inter computer communication. Some or all of the components systems and data structures may also be stored e.g. as software instructions or structured data on a computer readable medium such as a hard disk a memory a network or a portable media article to be read by an appropriate drive or via an appropriate connection. The systems components and data structures can also be transmitted as generated data signals e.g. as part of a carrier wave or other analog or digital propagated signal on a variety of computer readable transmission mediums including wireless based and wired cable based mediums and can take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly the present invention may be practiced with other computer system configurations.

In the example shown in access policies may be specified on a per transmission protocol basis. In the present example when a source is granted access via a particular protocol such as HTTP this may be taken to mean that the sender may send Transmission Control Protocol TCP packets to nodes in the specified group at the default port for HTTP port 80. Other embodiments may allow access rights to be specified at other levels of details such as to not indicate particular protocols or to further specify particular ports for use with particular protocols. For example some embodiments may allow access rights to more generally be specified with respect to any transmission properties of particular network transmissions such as types of packets within particular protocols e.g. TCP SYN packets broadcast packets multicast packets TCP flags generally etc. connection limits e.g. maximum number of concurrent connections permitted packet size packet arrival or departure time packet time to live packet payload contents e.g. packets containing particular strings etc. In addition other embodiments may specify access policies in various manners. For example some embodiments may provide for the specification of negative access policies such as ones that specify that all nodes except for the specified senders have certain access rights. Also different embodiments may provide varying semantics for default unlisted access policies. For example some embodiments may provide a default policy that no sender may communicate with nodes of a given group unless authorized by a particular other policy with other embodiments may provide a default policy that senders operated by a given user may by default communicate with any other nodes operated by the same user or that nodes in a given group may by default communicate with other nodes in the same group. Finally various embodiments may specify groups and group membership in various ways such as by providing for hierarchies of groups or to allow for groups to be members of other groups such that a policy would apply to any node below an indicated point in the hierarchy or to any node that is a member of a indicated group or of any sub groups of the indicated group.

In the example illustrated in two example TM components DTM and DTM dynamically generate and modify transmission management rules over time based on initiated data transmissions with DTM managing two associated nodes A and B and with DTM managing associated node D. Both example DTMs also maintain information related to the group memberships of nodes being managed as well as to associated access policies for the groups. In the present example node A belongs to Group node B belongs to Group and node D belongs to Group and Group as shown in rows in . The DTMs may obtain information about group membership and access policies in various ways. For example when a new node to be managed by a particular DTM comes online the DTM may be notified of this new node and its network address e.g. IP address and the DTM may be able to access the group membership and access policy information for the new node e.g. by querying and or being notified by the DTM Group Manager component or the DTM System Manager system by retrieving the information from a network accessible data store etc. . In addition changes related to group membership e.g. a particular existing node is added to or removed from a group and access policies e.g. the access policies related to a particular group are modified such as to now allow data transmissions from another group that previously did not have such authorization may be communicated to DTMs in a variety of ways. In some embodiments only the DTMs that are managing nodes affected by a particular change will be notified such as via information sent from for example a DTM Group Manager component and or a DTM System Manager system. In other embodiments such changes may be broadcast to all DTMs or instead all DTMs may be configured to periodically poll an appropriate component in order to obtain updates related to such state changes.

In some embodiments any data destined for node D that was received from node B by DTM before the negotiation completed would have been queued by DTM until it was determined whether or not node B was authorized to transmit data to node D. In such embodiments after having received an indication of authorization to communicate with node B DTM would then transmit any queued data to node D as well as any data that arrived subsequent to the negotiation. In other embodiments any data destined for node D that was received from node B by DTM prior to the completion of the negotiation would instead be discarded by DTM. Such techniques may be appropriate in situations in which some data transmission loss is acceptable or in which a sending node will resend any data transmissions that are not received and acknowledged by the intended recipient. For example many transmission protocols will retransmit any lost packets e.g. based on the timeout and retransmission mechanisms of TCP and while such a discard based approach may result in the initial loss of some packets that should ultimately have been delivered e.g. in the case of a successful negotiation in this situation the retransmission will ensure that those initial packets will be resent. Alternatively in some embodiments before a negotiation is completed or authorization is otherwise obtained for node B to transmit data to node D the data transmissions could be sent toward node D and be queued at DTM e.g. after being intercepted by DTM until authorization is obtained or DTM otherwise determines to forward the queued data transmissions to node D or to discard the data transmission if authorization is ultimately not obtained .

Thus in the manner indicated the transmission manager components may dynamically create transmission management rules based on managing initiated data transmissions. While not illustrated here in other embodiments the rule sets for a transmission manager component and or for a particular node may be modified in other manners such as to remove all rules corresponding to a node after its associated group membership or other relevant information changes e.g. after a program being executed on behalf of a first customer on a virtual machine node is terminated so that the node or another node that is later allocated the same relevant information such as the same network address as was previously used by the node will need to re negotiate to determine appropriate authorizations or instead to remove only rules that are affected by a particular change. For example if the access policies for group are dynamically changed at the current time so that group no longer is authorized to sent HTTP communications to group node B of group will no longer be authorized to send HTTP transmissions to node D of group . Accordingly rule for DTM and rule for DTM are no longer valid and the change to the access policy will prompt those two rules to be removed but other rules involving nodes B and D e.g. rules and for DTM and DTM respectively may be maintained in at least some embodiments.

Next shows an example of messages passed between nodes and DTMs during a successful negotiation as described with reference to . Initially node D attempts to transmit data to node B via HTTP by way of the Send message . If the data transmission is related to the prior authorized data transmissions from node B to node D using HTTP e.g. is a reply to received Send message or otherwise is part of the same session DTM and DTM will in some embodiments automatically have authorized such reply data transmissions as part of the prior negotiation process as discussed in greater detail elsewhere this ability to automatic authorize such replies may provide various benefits such as to enable some types of transmission protocols e.g. TCP to function effectively. In this example however DTM instead initiates a separate authorization negotiation for the data transmission with the Is Allowed message . DTM determines by inspection of the appropriate data that node B has authorized such transmissions and therefore responds with an Allowed message . Finally DTM forwards the queued data from Send message by way of a new Send message which DTM forwards to its ultimate destination by way of Send message . Finally shows an example of messages passed between nodes and DTMs during a negotiation that results in a denial of authorization as described with reference to . Initially node B attempts to transmit data to node D via FTP by way of the Send message . DTM initiates negotiation with DTM via the Is Allowed message . DTM determines by inspection of the appropriate data that node D has not authorized such transmissions and therefore responds with a Not Allowed message . In response DTM drops the data received by way of the Send message .

The routine begins in step where it receives data sent from another node or an indication to transmit data to a remote node e.g. from another part of the actions of the node . In step the routine determines whether data was received from another node. If so it proceeds to step and processes the received data. If it was instead determined in step that an indication to transmit data was received the routine proceeds to step and transmits data to the appropriate destination. After step or the routine proceeds to step to determine whether to continue. If so the routine returns to step and if not continues to step and ends.

The routine begins in step and receives an outgoing transmission an incoming transmission a negotiation request or a management message. The routine then proceeds to step and determines the type of message or request received in step . If it is determined in step that the routine has received an indication of an outgoing transmission the routine proceeds to step to determine whether it has an applicable rule indicating a prior negotiation for authorization. An applicable rule may be one that either allows or denies the transmission from the source node to the destination node indicated by the outgoing transmission. If it is determined that no such rule exists the routine proceeds to step and initiates a negotiation for authorization by sending a request to the destination node. In the example embodiment while the request is sent to the destination node it is intercepted by a remote DTM that manages the destination node thus allowing the DTM to initiate negotiation without specific knowledge of the network address of the remote DTM although in other embodiments the negotiation request message may instead be send directly to an appropriate DTM e.g. via a mapping of destination nodes to the remote DTMs that manage them or in another manner. Next the routine proceeds to step to receive either a response or a timeout. A timeout may be received if for some reason the remote DTM has gone offline or is otherwise unreachable. If no response from the remote DTM is received within a pre determined timeout the lack of response is treated as a response that denies authorization to communicate in this embodiment although in other embodiments the lack of a response could be treated as an authorization or could trigger additional attempts to negotiate for authorization. The routine then proceeds to step to determine whether authorization has been granted to transmit data from the source to the destination node. If an explicit allowance of authorization was received e.g. a message containing an indication of authorization the routine proceeds to step and adds an allowance transmission management rule that authorizes future data transmissions from the source to the destination node. If instead the routine receives an explicit denial of authorization or a timeout the routine proceeds to step to add a rule indicating a denial of authorization and drops any data that is received from the source node and bound for the given destination node. In this example the added denial of authorization rule includes expiration criteria such as a timeout or expiration date such as to force renegotiation of data transmission rules on a periodic basis in order to assure that dynamic changes to group memberships access policies and or node network identities will be correctly reflected in the rule sets maintained by various DTMs.

If it is instead determined in step that a rule governing data transmissions from the source node to the destination node does exist the routine proceeds to step to determine whether the rule authorizes such transmissions. If so or after step the routine proceeds to step and transmits the data from the source node to the destination node. If it is instead determined in step that the rule denies authorization for data transmissions from the source node to the destination node the routine proceeds to step and drops any data from the source node that is bound for the given destination node. Note that in embodiments that do not queue and instead discard data received during pending negotiations for authorization steps such as and may be somewhat simplified. For example an embodiment that does not queue data while awaiting a response to a negotiation request may not wait to receive a timeout as described with reference to step above because there will be no accumulation of queued data to either discard or transmit depending on the outcome of the pending negotiation. In addition in such cases the routine may proceed directly from step to step bypassing step because there will be no data to transmit since any data that initiated an authorization negotiation would have been discarded rather than queued .

If it is instead determined in step that the routine has received a negotiation request from a remote DTM that is attempting to obtain permission for a source node to communicate with one of the destination nodes managed by the DTM the routine proceeds to step to determine the source node address and the groups to which the source node belongs. In some embodiments some or all of information will be provided to the DTM as part of the received negotiation request from the remote DTM. Alternatively the DTM may acquire some or all of this information in other manners such as from another system component e.g. the DTM Group Manager or DTM System Manager of . Next the routine proceeds to step to determine whether the network address of the source node has been granted authorization to communicate with the destination node. If not the routine continues to step to determine whether at least one of the source node s groups has been granted permission to communicate with the destination node. If not the routine continues to step and adds a rule that denies authorization for transmissions from the source node to the destination node which may include expiration criteria to force renegotiation of data transmission rules on a periodic basis. Next the routine continues to step and sends a response to the remote DTM denying authorization to communicate. If it is instead determined in step or step that the source node has been granted authorization to communicate with the destination node however the routine proceeds to step and adds a rule that authorizes communication from the source node to the destination node. Next the routine proceeds to step where it sends a response to the remote DTM indicating the authorization for the source node to communicate with the destination node.

If it is instead determined in step that the routine has received incoming data the routine proceeds to step . In step the routine determines whether a rule exists in the rule set that authorizes communication from the source node of the incoming data to the destination node of the incoming data. If it is so determined in step the routine continues to step and forwards the data onwards to the final destination node. If no rule exists that denies authorization for such communication or a rule exists that explicitly denies authorization for such communication the routine proceeds to step and drops the incoming data. In addition in some embodiments the DTM may in this case send a message to the remote DTM that originally sent the data that such communication was not permitted thereby informing the remote DTM that it should invalidate some or all of the rules related to this particular destination node.

If it is instead determined in step that the routine has received a management message the routine proceeds to step . Management messages may include notifications that one or more of the nodes managed by the DTM have gone offline notifications that a new node to be managed by the DTM has come online etc. In some embodiments when a new node comes online the DTM that manages the new node may determine network location e.g. network address of the new node the groups to which the new node belongs the source nodes or other senders individual nodes or groups that have been granted authorization to communicate with the new node the particular protocols that senders may use to communicate with the new node etc. In other embodiments the DTM may alternatively delay the acquisition of such information until a later time such as when the new node first sends outbound communication or when the first inbound communication destined for the new node arrives. Such information may be obtained by the DTM by communicating with other system components such as the DTM Group Manager or the DTM System Manager of or by reference to network accessible data stores. Similarly when a node managed by the DTM goes offline the DTM may flush any rules from its rule set that reference the node as either a source or a destination node. The DTM may also flush any information related to the network identity group membership and or access policies of the node.

After steps or the routine continues to step to optionally perform housekeeping tasks e.g. checking the expiration criteria associated with rules stored in a TM component s rule set . In some embodiments rules may be set to expire automatically after a specified time interval. In other embodiments the DTM periodically examines the rules in the rule set and flushes or deletes those that have reached a certain age. Other housekeeping tasks may include operations such as updating or rotating logs or handling additional messages or requests not illustrated in the above flowchart. For example in some cases the above example embodiment of a DTM will have an authorization rule that has gone stale that is the authorization rule will make reference to a destination node that has at some point after the initial negotiation of permission gone offline. In such a case the DTM may not be aware that the destination node has gone offline until one of the source nodes under the management of the DTM attempts to transmit data to that node. Because the DTM has a rule that allows such transmission the DTM will transmit the data to the destination node. However the remote DTM will reject the transmission and reply with a message informing the DTM to invalidate the rule that allowed such a transmission or alternatively all rules that reference the node as a destination node . In response the DTM will flush some or all stored rules related to the given destination node as appropriate.

After step the routine proceeds to step to determine whether to continue. If so the routine returns to step and if not continues to step and ends.

Those skilled in the art will also appreciate that in some embodiments the functionality provided by the routines discussed above may be provided in alternative ways such as being split among more routines or consolidated into fewer routines. Similarly in some embodiments illustrated routines may provide more or less functionality than is described such as when other illustrated routines instead lack or include such functionality respectively or when the amount of functionality that is provided is altered. In addition while various operations may be illustrated as being performed in a particular manner e.g. in serial or in parallel and or in a particular order those skilled in the art will appreciate that in other embodiments the operations may be performed in other orders and in other manners. Those skilled in the art will also appreciate that the data structures discussed above may be structured in different manners such as by having a single data structure split into multiple data structures or by having multiple data structures consolidated into a single data structure. Similarly in some embodiments illustrated data structures may store more or less information than is described such as when other illustrated data structures instead lack or include such information respectively or when the amount or types of information that is stored is altered.

As previously noted in some embodiments the initiation of a data transmission or other communication by a computing node may occur and may be identified by an associated data transmission manager component in a variety of ways. In some embodiments the computing node may send an explicit message to the TM component that manages it requesting permission to communicate with a remote node while in other embodiments the existence of the TM and the authorization negotiation that it performs may be entirely transparent to the computing node if so the computing node simply attempts to send data to the remote node while the TM component monitors and processes all outgoing transmissions from the computing node. When the TM component identifies an initiated data transmission from the computing node whether by receiving an explicit request message from the computing node by detecting an outbound transmission for which it has not already negotiated permission such as by inspecting the source and destination network addresses of TCP or UDP packets as they flow across a network interface etc. the TM components initiates an authorization negotiation if the existence of authorization or an authorization denial does not already exist. While the TM component negotiates authorization it may queue the outgoing data from the computing node that is bound for the remote destination node and process the data according to the authorization negotiation results e.g. by allowing or preventing the data transmission to proceed to the destination node as well as optionally manipulate data before it is forwarded on to the destination node e.g. to include indications of obtained authorization for use by the destination computing node and or destination transmission component in verifying authorization and or authenticity of the data transmissions to modify the manner in which the data is transmitted such as to change the data format and or transmission protocol to reflect preferences of the destination computing node or for other reasons to modify the data that is transmitted such as by adding and or removing data etc. .

In addition various embodiments may provide mechanisms for customer users and other users to interact with an embodiment of the DTM system. For example some embodiments may provide an interactive console e.g. a client application program providing an interactive user interface a Web browser based interface etc. from which users can manage the creation or deletion of groups and the specification of communication access policies or group membership as well as more general administrative functions related to the operation and management of hosted applications e.g. the creation or modification of user accounts the provision of new applications the initiation termination or monitoring of hosted applications the assignment of applications to groups the reservation of time or other system resources etc. . In addition some embodiments may provide an API application programming interface that allows other computing systems and programs to programmatically invoke such functionality. Such APIs may be provided by libraries or class interfaces e.g. to be invoked by programs written in C C or Java and or network service protocols such as via Web services.

In addition various implementation architectures are possible for embodiments of the DTM system. In some embodiments multiple TM components may act in a distributed manner to each manage the data transmissions of one or more associated nodes whether by each operating as an independent autonomous program or by cooperating with other TM components and may possibly be hosted virtual machines on the same computing system as the nodes being managed or may instead operate on computing systems remote from the nodes that they manage. While authorization negotiations have been described in which TM components interact directly with each other in other embodiments such TM components may instead negotiate authorizations in other manners such as by communicating with a central component that manages communication policies for the entire system or by referencing configuration files or other static information stores that are available locally or over a network. In addition the authorization negotiation performed by TM components may have a variety of forms. For example in some embodiments the actual network address or other identity of a remote TM component may be known to a TM component initiating a negotiation and if so that TM component may interact directly with that remote TM component while in other embodiments the TM component may send information to the network address of the destination computing node with the expectation that the sent information will be intercepted by the appropriate remote TM component. In other embodiments a single central TM component or other component may manage the data transmissions for a large number of computing nodes e.g. an entire data center if the single component has access to data transmissions initiated by those nodes whether due to configuration of the nodes or to a network structure or other mechanism that provides such access . In still other embodiments the functionality of a TM component may be distributed such as by being incorporated into each of the computing nodes being managed e.g. by being built into system libraries used for network communications by all of the nodes or a distinct TM component may operate on behalf of each computing node.

In addition in embodiments in which the functionality of the DTM system is distributed amongst various system components various negotiation schemes and protocols are possible. Negotiation requests and other messages related to data transmission policies and permissions that are passed between TM components or between TM components and other system components may be implemented in various manners such as by sending low level UDP packets containing the relevant information or by way of protocols implemented upon higher level protocols such as HTTP e.g. XML RPC SOAP etc .

As previously noted the described techniques may be employed on behalf of numerous computing nodes to provide various benefits to those computing nodes. In addition such computing nodes may in at least some embodiments further employ additional techniques on their own behalf to provide other capabilities such as by each configuring and providing their own firewalls for incoming communications anti virus protection and protection against other malware etc.

When the described techniques are used with a group of computing nodes internal to some defined boundary e.g. nodes within a data center such as due to an ability to obtain access to the data transmissions initiated by those computing nodes the described techniques may also in some embodiments be extended to the edge of the defined boundary. Thus in addition to managing data transmissions between computing nodes within the defined boundary one or more transmission manager components that may access communications passing through the boundary between internal and external computing nodes may similarly provide at least some of the described techniques for those communications. For example when a data communication is received at the boundary from an external computing node that is intended for an internal computing node a transmission manager component associated with the edge may similarly treat the communication as an outgoing data transmission initiated by a managed computing node such as by queuing the communication and allowing it to be passed into the internal network only if authorization is negotiated and obtained e.g. by negotiating with a transmission manager component associated with the destination computing node or instead with a component acting on behalf of all internal computing nodes .

Techniques are described for managing the execution of programs on multiple computing systems. In some embodiments described techniques are performed on behalf of a program execution service for executing multiple programs on behalf of multiple users of the service e.g. customers . In some embodiments the program execution service may use a variety of factors to select an appropriate computing system to execute an instance of a program such as the location of one or more previously stored copies of the program from which the selected computing system may acquire a copy of the program to execute and or of available computing system resources for execution of the program instance. For example in some embodiments the selection of an appropriate computing system to execute an instance of a program may be based in part on determining a computing system that already stores a local copy of the program. In another example the selection of an appropriate computing system may be based in part on determining a computing system that is sufficiently proximate whether geographically and or logically to one or more other computing systems that each store such a local copy such as one or more other computing systems in a common group with the determined computing system.

In some embodiments the multiple computing systems available to execute programs may include multiple physical computing machines interconnected via one or more networks or other data exchange mediums that are capable of transmitting data between the computing machines. The multiple computing systems may for example be located in a physical location e.g. a data center and may be separated into multiple groups and may be managed by one or more system manager modules responsible for those multiple computing systems as a whole and by multiple machine manager modules that are each associated with one of the groups in order to machine the computing systems of the group. At least some of the computing machines may each include sufficient resources to execute multiple programs simultaneously e.g. sufficient writeable memory and or one or more of sufficient storage CPU cycles or other CPU usage measure network bandwidth swap space etc. . For example at least some of the computing machines in some such embodiments may each host multiple virtual machine nodes that each may execute one or more programs on behalf of a distinct user. As noted in at least some embodiments the multiple computing systems managed by the program execution service may be organized into multiple distinct groups e.g. with each computing system belonging to a single group such as based on criteria including physical or logical proximity or having a common data exchange medium. In one example the common data exchange medium for a group may be provided by a single network switch and or rack backplane that provides high bandwidth communications between the computing systems of the group e.g. with some or all of the computing systems that are connected to the network switch or rack backplane being the members of the group . Each group of computing systems may also be connected to other computing systems e.g. computing systems of other groups or remote computing systems that are not managed by the program execution service by one or more other data exchange mediums e.g. Ethernet based wiring a wireless connection or other data connections such as other data exchange mediums with lower bandwidth than the groups common data exchange mediums. Furthermore in at least some embodiments some or all of the computing systems may each have local program repositories e.g. hard disks or other local storage mechanisms that can be used to store local copies of programs for execution such as prior to or at the time of execution of the program. Additionally in at least some embodiments each group of multiple computing systems may use one or more computing systems of the group to store local copies of programs for use by other computing systems of the group.

In an illustrated embodiment the program execution service may include a software facility that executes on one or more computing systems in order to manage the execution of the programs. The software facility may include one or more machine manager modules for each group of one or more computing systems that manage the retrieval storage and execution of programs by the computing systems of that group. For example a distinct machine manager module may be provided for each distinct physical computing machine such as with a machine manager module for a physical computing machine being executed on at least one of multiple virtual machines of that computing machine. In addition in some embodiments the software facility may include one or more system manager modules executing on one or more computing systems that manage retrieval storage and execution of programs for all of the multiple computing systems being used to execute programs. The system manager modules may interact with machine manager modules as appropriate as discussed in greater detail below.

In at least some embodiments the execution of one or more instances of a program on one or more computing systems may be initiated in response to a current execution request for immediate execution of those program instances. Alternatively the initiation may be based on a previously received program execution request that scheduled or otherwise reserved the then future execution of those program instances for the now current time. Program execution requests may be received in various ways such as directly from a user e.g. via an interactive console or other GUI provided by the program execution service or from an executing program of a user that automatically initiates the execution of one or more instances of other programs or of itself e.g. via an API or application programming interface provided by the program execution service such as an API that uses Web services .

Program execution requests may include various information to be used in the initiation of the execution of one or more instances of a program such as an indication of a program that was previously registered or otherwise supplied for future execution and a number of instances of the program that are to be executed simultaneously e.g. expressed as a single desired number of instances as a minimum and maximum number of desired instances etc. . In addition in some embodiments program execution requests may include various other types of information such as the following an indication of a user account or other indication of a previously registered user e.g. for use in identifying a previously stored program and or in determining whether the requested program instance execution is authorized an indication of a payment source for use in providing payment to the program execution service for the program instance execution an indication of a prior payment or other authorization for the program instance execution e.g. a previously purchased subscription valid for an amount of time for a number of program execution instances for an amount of resource utilization etc. and or an executable or other copy of a program to be executed immediately and or stored for later execution. In addition in some embodiments program execution requests may further include a variety of other types of preferences and or requirements for execution of one or more program instances. Such preferences and or requirements may include indications that some or all of the program instances be executed in an indicated geographical and or logical location such as in one of multiple data centers that house multiple computing machines available for use on multiple computing systems that are proximate to each other and or on one or more computing system that are proximate to computing systems executing one or more other indicated program instances e.g. instances of the same program or of another program . Such preferences and or requirements may further include indications that some or all of the program instances each be allocated indicated resources during execution.

After receiving a request to execute one or more instances of a program at an indicated time the program execution service determines one or more computing systems to use in executing the program instances. In some embodiments the determination of the computing systems to be used is performed at the time of the request even if for future execution. In other embodiments the determination of the computing systems to be used for future execution of one or more program instances may be deferred to a later time such as at the future time of execution based on information that is then available. The determination of which computing system to use for execution of each program instance may be made in a variety of ways including based on any preferences and or requirements specified in the program request or otherwise specified for the program and or associated user e.g. at a time of prior registration . For example if criteria are determined for preferred and or required resources for execution of a program instance the determination of an appropriate computing system to execute a program instance may be based at least in part on whether a computing system has sufficient resources available to satisfy those resource criteria.

In some embodiments the program execution service may base the determination of which computing system to utilize to execute the program to be executed on the location of one or more previously stored copies of the program to be executed. In particular as previously noted in at least some embodiments the various computing systems that are available to execute programs may be organized into groups such as with each computing system belonging to one of multiple groups . Accordingly the determination of whether a computing system is appropriate to execute an instance of a program may be based in part on whether one or more computing systems in that computing system s group store local copies of the program. By selecting a computing system to execute an instance of a program that already has a locally stored copy of the program or that belongs to a group that has one or more locally stored copies various benefits may be obtained such as to reduce the program execution startup latency based on obtaining a copy of the program. When a computing system in a group stores a local copy of a program to be executed the program execution service may nonetheless select one or more other computing systems in the group to currently execute instances of the program for various reasons such as if the computing system with the locally stored copy does not currently have sufficient resources to execute an instance the program if the computing system with the locally stored copy already is executing one or more instances of the program etc.

In a further embodiment the program execution service may select one or more computing systems to execute instances of the program on various other factors. For example when a user requests that multiple instances of an indicated program be executed at the same time the program execution service may prefer to distribute the execution of the program instances among computing systems that are members of different groups such as to provide enhanced reliability in the face of group specific network outages or other problems. Similarly in some embodiments multiple instances of a program may be executed on multiple computing systems rather than a single computing system even if the single computing system has sufficient resources to execute the multiple instances . Such distribution of program instances may for example provide enhanced reliability in the face of failure of a single computing system that would instead execute all of the program instances or of loss of connection to that single computing system. In addition if the computing systems managed by the program execution service are physically e.g. geographically separate the program execution service may be instructed by a user or otherwise prefer to execute multiple instances of a program on computing systems located within a single data center such as to provide relatively high network bandwidth for communications between instances of the executing program. Alternatively the program execution service may be instructed or otherwise prefer to execute the multiple program instances in multiple distinct data centers such as if the program instances have little or no inter communications and or if the various program instances support a number of distinct end users or applications that are geographically distributed.

After the program execution service determines one or more computing systems to use in executing the instances of a program the program execution service may initiate execution of those program instances in various ways. For example the system manager modules may provide instructions and various other execution information to the selected computing systems. Such other information may include for example indications of one or more other computing systems that store or that may store local copies of the program. Other types of information provided to a selected computing system may include an indication regarding how long to execute the program instance an indication regarding resources to allocate to the program instance an indication of access rights to provide to the program instance an indication of any restrictions on how to manage execution of the program instance e.g. what types of communications if any to allow the program instance to send or receive etc.

After a selected computing system is notified to execute one or more instances of an indicated program the selected computing system attempts to perform the program instance execution in accordance with any received instructions or other associated information e.g. predefined preferences or requirements . The program execution notification may in at least some embodiments be received by a machine manager module associated with the selected computing system e.g. a machine manager module executing on the selected computing system or a machine manager module executing on behalf of a group to which the selected computing system belongs . In such embodiments the machine manager module may operate to manage the execution of the program instance. For example in situations in which a selected computing system does not already store a local copy of an indicated program to be executed the machine manager module may operate to obtain or otherwise acquire a copy of the program for execution as well as for optional local storage. The acquisition of a program copy may for example include contacting one or more computing or other systems e.g. data storage systems that are indicated in the notification or that are otherwise known to at least potentially store local copies of the program in order to request or retrieve a copy of the program. The acquisition of a program copy may be performed in a variety of ways in various embodiments as discussed in greater detail below including by receiving a copy of the program along with the received notification to execute the program instance s . As discussed in greater detail below the program execution service may take a variety of other actions to manage execution of programs in at least some embodiments.

In another aspect an API may be provided that allows other programs to programmatically initiate requests to execute program instances as well as to possibly programmatically perform a variety of other types of administrative provisioning and management operations. Such operations include but are not limited to the creation of user accounts the reservation of execution resources the registration of new programs to be executed the management of groups and access policies the monitoring and management of executing program instances etc. The functions provided by the API may be invoked for example by client computing systems and devices on behalf of users including by program instances executing on computing systems of the program execution service.

For illustrative purposes some embodiments are described below in which the execution of specific types of programs on specific types of computing systems is managed in specific ways. These examples are provided for illustrative purposes and are simplified for the sake of brevity and the inventive techniques can be used in a wide variety of other situations some of which are discussed below and the techniques are not limited to use with virtual machines data centers or other specific types of computing systems or computing system arrangements.

In addition the example data center further includes additional computing systems and that share a common data exchange medium with a node manager and node manager manages computing systems a b and . In the illustrated example computing system also hosts a number of virtual machines as execution environments for use in executing program instances for one or more users while computing systems do not host distinct virtual machines. In this example an optional computing system resides at the interconnect between the data center and an external network . The optional computing system may provide a number of services such as to act as a network proxy to manage incoming and or outgoing data transmissions etc. Additionally an optional system manager computing system is also illustrated to assist in managing the execution of programs on other computing systems located within the data center or optionally on computing systems located in one or more other data centers . The optional system manager computing system may execute a system manager module. As previously noted a system manager module may provide a variety of services in addition to managing execution of programs including the management of user accounts e.g. creation deletion billing etc. the registration storage and distribution of programs to be executed the collection and processing of performance and auditing data related to the execution of programs the obtaining of payment from customers or other users for the execution of programs etc.

In this example the data center is connected to a number of other systems via a network e.g. the Internet including additional computing systems that may be operated by the operator of the data center or third parties additional data centers that also may be operated by the operator of the data center or third parties and an optional system manager . In a manner similar to system manager the system manager may manage the execution of programs on computing systems located in one or more data centers and or in addition to providing a variety of other services. Although the example system manager is depicted as external to any particular data center in other embodiments it may be located within a data center such as one of the data centers .

In this example depicts two groups Group A and Group B . Group A includes three computing machines named MA MA and MA respectively. Group B similarly includes three computing machines named MB MB and MB. Each group may instead have differing numbers of computing machines of differing types and in some embodiments a computing machine may be a member of multiple groups or of no group. As described in more detail elsewhere the computing machines of each group share a common data exchange medium for that group not shown .

In an illustrative example each computing machine of may execute one or more program instances and may store one or more local program copies in local a program repository e.g. as part of persistent storage provided by for example a hard disk or other storage device . For example computing machine MA has local copies of programs P P P P and P stored in its program repository and is currently executing an instance of program P as shown in box . In this example the program repository on each computing machine is limited in storage capacity to a maximum of five program copies and each computing system is limited in execution resources to a maximum of two program instances executing simultaneously. The limits on the sizes of the program repositories and the number of executing programs employed in this example are for illustrative purposes only and in other embodiments each computing system may further have distinct resources. Furthermore while the size of the program repository may in many embodiments be one or more orders of magnitude larger than the size of memory available for use in executing program instances this need not necessarily be the case. In other embodiments the maximum number of simultaneously executing program instances may be higher lower or the same as the number of programs copies that may be locally stored in the program repository. Accordingly at least some computing machines or other systems may instead provide only one of a local program repository and available resources to execute program instances. Finally as will be described in greater detail elsewhere in some embodiments local stored copies of at least some of the programs may be evicted or otherwise removed from storage under certain circumstances such as to make room for other program copies after a program repository has reached its capacity. In some embodiments executing instances of at least some of the programs may be terminated or otherwise removed from execution under certain circumstances such as to make room for other executing program instances after program execution resources have reached their capacity.

A number of example scenarios are presented here for illustrative purposes to provide examples of some types of operation of one embodiment of the program execution service. The program execution service may use one or more specified predefined and or learned policies to affect the placement of executing program instances on computing machines with a simplified set of policies used in this example as follows. First multiple instances of a program will be executed on computing machines of more than one group if possible. Second multiple instances of a program will be executed on more than one computing machine if possible. Third an instance of a program will be executed on a computing machine that has already stored a copy of the program in its program repository if possible. Fourth an instance of a program will be executed on a computing machine that is a member of a group that has at least one computing machine that has a stored local copy of the program in its program repository if possible. Finally an instance of a program will be executed on a computing machine with the highest execution resource availability if possible.

Beginning the illustrative examples of managing program execution for these six computing systems suppose that a client of the program execution service has requested the execution of two instances of program P. In this case given the policies described above the example embodiment of the program execution service will likely opt to execute one instance of P in Group A and one instance in Group B because such placement tends to distribute the copies over more than one group. As between the computing machines of Group A since none of the computing machines of the group store a local copy of the program the program execution service will likely opt not to execute a copy of P on computing machine MA since it is already executing two programs P and P . As between computing machines MA and MA MA will be chosen for execution because it is currently not executing any programs. In the illustrated embodiment machine MA will acquire a copy of program P for execution and optionally for local storage in repository from one or more computing systems external to Group A. For example machine MA may acquire the copy of program P from a remote program repository for all of the computing machines of the program execution service and or from a location external to the program execution service. As for the computing machines of Group B the program execution service may select any of the three computing machines to execute the P program instance since none of the computing systems store a local copy of the program and each of the computing machines is executing one program. However the program execution service may select machine MB because it currently only stores one program copy in its program repository. Accordingly machine MB can store a local copy of program P if so desired without needing to evict a stored program copy from its program repository.

Next starting again with the initial conditions shown in suppose that a client of the program execution service has requested the execution of two instances of program P. In this case given the policies described above the example embodiment of the program execution service will again likely opt to execute one instance of P in group A and one instance of P in group B because such placement will distribute instances over more than one group. As between the computing machines of Group A computing machine MA will likely be selected again because none of the computing systems store a local copy of program P and computing machine MA is the least busy. As amongst the equally busy computing machines of Group B computing machine MB may not be selected because of the policy preferring to distribute copies of a single program over multiple computing machines within a group despite the fact that only MB stores a local copy of the program. Note however that other embodiments with different policies that reflect valuing efficiency over reliability may in fact select to execute P on computing machine MB precisely because a copy of P is already stored in the program repository of MB. As between the remaining candidate computing machines MB and MB the program execution service may again prefer machine MB because there is no need to potentially evict any copies of programs from the MB program repository. Accordingly machine MB will in this embodiment acquire a copy of program P from MB for execution and for possible storage in local repository

Next starting again with the initial conditions shown in suppose that a client of the program execution service has requested the execution of one instance of program P. In this case given the policies described above the example embodiment of the program execution service will likely opt to execute P on computing machine MB. In particular since there are no instances of P already executing and only one instance was requested to be executed the policies preferring to distribute program instances among multiple groups and preferring to avoid placing multiple executing instances of a program on a single computing machine do not apply. Therefore since MB has already stored a local copy of program P in its program repository MB will likely be chosen to execute P.

Next starting again with the initial conditions shown in suppose that a client of the program execution service has requested the execution of one instance of program P. In this case given the policies described above the example embodiment of the program execution service will likely opt to execute P on MA. As with the prior example the policies preferring to distribute instances of programs for execution among multiple groups and avoiding placing multiple instances of a program on a single computing machine do not apply. And while computing machine MA is an attractive candidate because it has already stored a copy of P in its repository it does not have the capacity to currently execute P because it is already at its limit of two executing programs P and P . That leaves computing machines MA and MA as preferable to any computing machines in Group B because MA and MA are in the same group as a computing machine MA that has a stored local copy of program P in its repository. As between MA and MA MA will likely be selected because it is the least busy and it will acquire a copy of program P from MA.

Next starting again with the initial conditions shown in suppose that a client of the example embodiment of the program execution service has requested the execution of additional instances of program P. In this case given the policies described above the program execution service will likely execute two instances on computing machine MA and one instance on each of computing machines MA MB MB and MB. No instances will likely be executed on computing machine MA because that computing machine is already at its limit of two executing programs P and P . Note that in this case some embodiments could evict stored local copies of programs from those computing machines with program repositories without excess capacity in order to store a local copy of program P. For example in embodiments that choose to always store a copy of the program to be executed in the local program repository prior to execution computing machines MA and MB could evict one local program copy from their respective program repositories. Note also that in this case computing machines MA and MB will likely each end up executing two instances of P counter to the policy preferring to distribute multiple instances of executing programs among multiple computing machines. However because there are no additional computing machines for executing P program instances in the given example the program execution service would choose to execute multiple instances of P on a single computing machine if the request is to be satisfied. Alternatively in some embodiments the program execution service may apply different weights to the policies such that the program execution service may instead opt to execute less than the requested number of instances such as to execute a single instance on each of the computing machines MA MA MB and MB. Similarly in some embodiments if more than six additional instances are requested of program P and the program and or requester are of sufficiently high priority the program execution service may instead opt to execute additional instances of P such as by terminating execution of another program instance e.g. instances of programs P and or P on MA and or by reserving the next available program instance execution for P after one of the currently executing program instances terminates naturally.

In continued reference to the current example computing machine MB has multiple available sources to acquire a copy of program P for execution since both MB and MB from Group B store local copies of the program as do computing machines MA and MA of Group A. In this embodiment MB will request that both MB and MB of its own group provide a portion of program P e.g. the first X bytes and the second X bytes where X is a number selected by the program execution service . Machine MB will then monitor how rapidly the responses are received from the computing machines and will request the more responsive computing machine to provide at least the majority and possibly all of the remaining portions of the program. In other embodiments the acquisition of a copy of program P for computing machine MB may be performed in other manners such as by requesting the program copy from only one of computing machines MB and MB by requesting at least portions of the program copy from computing machines MA and or MA in Group A whether in addition to or instead of from MB and MB of Group B etc.

In this example embodiment computing system includes a central processing unit CPU storage memory and various input output I O devices with the illustrated I O devices including a display a network connection a computer readable media drive and other I O devices . Other I O devices that are not illustrated may include keyboards mice or other pointing devices microphones speakers etc. In the illustrated embodiment a system manager module is executing in memory in order to manage the execution of programs on other computing systems and one or more other programs may also optionally be executing in memory . Computing system and computing system s are connected to each other as well as other computing systems via a network .

Each computing system similarly includes a CPU various I O devices storage and memory . In the illustrated embodiment a machine manager module is executing in memory in order to manage the execution of one or more other programs on the computing system for the program execution service such as on behalf of customers of the program execution service. In some embodiments some or all of the computing systems may host multiple virtual machines. If so each of the executing programs may be an entire virtual machine image e.g. with an operating system and one or more application programs executing on a distinct hosted virtual machine. The machine manager module may similarly be executing on another hosted virtual machine such as a privileged virtual machine that is able to monitor the other hosted virtual machines. In other embodiments the executing program instances and the machine manager module may execute as distinct processes on a single operating system not shown executed on computing system . Thus in this example embodiment the capabilities of the program execution service are provided by the interactions of system manager and the machine manager modules that communicate via network to jointly manage the distribution acquisition and execution of programs on the computing systems being managed.

It will be appreciated that computing systems such as computing systems and are merely illustrative and are not intended to limit the scope of the present invention. Computing systems and may be connected to other devices that are not illustrated including network accessible database systems or other data storage devices. More generally a computing machine or computing system or data storage system may comprise any combination of hardware or software that can interact and perform the described types of functionality including without limitation desktop or other computers database servers network storage devices and other network devices PDAs cellphones wireless phones pagers electronic organizers Internet appliances television based systems e.g. using set top boxes and or personal digital video recorders and various other consumer products that include appropriate inter communication capabilities. In addition the functionality provided by the illustrated system modules may in some embodiments be combined in fewer modules or distributed in additional modules. Similarly in some embodiments the functionality of some of the illustrated modules may not be provided and or other additional functionality may be available.

It will also be appreciated that while various items are illustrated as being stored in memory or on storage while being used these items or portions of them can be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively in other embodiments some or all of the software components and or modules may execute in memory on another device and communicate with the illustrated computing systems via inter computer communication. Some or all of the system modules or data structures may also be stored e.g. as software instructions or structured data on a computer readable medium such as a hard disk a memory a network or a portable media article to be read by an appropriate drive or via an appropriate connection. The system modules and data structures can also be transmitted as generated data signals e.g. as part of a carrier wave or other analog or digital propagated signal on a variety of computer readable transmission mediums including wireless based and wired cable based mediums and can take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly the present invention may be practiced with other computer system configurations.

The routine begins in step and receives a status message or a request related to the execution of one or more programs. The routine then proceeds to step and determines the type of the received message or request. If it is determined that a request to execute one or more instances of one or more indicated programs has been received the routine proceeds to step . In step the routine identifies one or more groups of computing systems to execute the indicated program s . In step the routine selects one or more computing systems in each of the one or more identified groups to execute instances of the indicated program s . The selection of the one or more groups may be based on various factors such as whether a group has one or more computing systems that store one or more local copies of the program s the availability of appropriate computing resources and locations of the computing systems of the groups. The selection of one or more computing systems in an identified group may similarly be based on various factors such as the location s of stored local copies of the program s among computing systems of the group and computing resource availability. As previously noted various specified policies and other criteria may be used as part of the selection of groups and computing systems in various embodiments including criteria specified by a user or other requester. In addition in other embodiments groups and particular computing systems may not be individually selected such as to merely pick the most appropriate one or more computing systems regardless of groups e.g. if no groups are used .

Next at step the routine provides an indication of the program s to be executed to the selected computing system s and or to one or more machine manager modules associated with those computing systems such as by sending a message that includes instructions to execute those program instances. In the illustrated embodiment a distinct machine manager module executes on each of the computing systems and is the receipt of the message. As previously noted a variety of types of information may be provided to the machine manager modules including indications of how to identify one or more computing systems from which to acquire a copy of the program to be executed. Alternatively in some embodiments the system manager may directly provide a copy of an indicated program to a computing system and or initiate the execution of a program on a computing system without the intervention of a machine manager module or other additional module.

If it was instead determined in step that a request to register a new program was received such as from a user the routine proceeds to step and stores an indication of the program and any associated administrative information such as the identity of the user who registered the program. Next in step the routine optionally initiates distribution of a copy of the indicated program to one or more computing systems. For example in some embodiments the system manager may elect to seed one or more computing systems and or program repositories in one or more data centers with stored local copies of the indicated program in order to improve the efficiency of later program execution initiation.

If it was instead determined in step that a status message was received to reflect the operations of one or more of the managed computing systems the routine proceeds to step and updates status information for the one or more computing systems. For example the machine manager module may determine that an associated computing system has modified the program instances being executed and or the local program copies being stored and may accordingly provide a status message to the system manage. In some embodiments status messages will be sent periodically by machine manager modules in order to keep the system managers informed as to the operational status of the managed computing systems for use in the selection of appropriate computing systems to execute programs. In other embodiments status messages may be sent at other times e.g. whenever a relevant change occurs . In other embodiments the system manager module may instead request information from machine manager modules as desired. Status messages may include a variety of types of information such as the number and identity of programs currently executing on a particular computing system the number and identity of copies of programs currently stored in the local program repository on a particular computing system performance related and resource related information e.g. utilization of CPU network disk memory etc. for a computing system configuration information for a computing system and reports of error or failure conditions related to hardware or software on a particular computing system.

If it was instead determined in step that any other type of request was received the routine proceeds to step and performs other indicated operations as appropriate. Such operations may include for example responding to status queries from other components in the system suspending or terminating the execution of one or more currently executing programs migrating currently executing programs from one computing system to another shutting down or restarting the system manager etc.

After steps and the routine proceeds to step and optionally performs any housekeeping tasks such as calculating billing information for users updating display information sending periodic queries to node managers or other components rotating logs or other information etc. Next the routine proceeds to step and determines whether to continue. If so the routine returns to step and if not proceeds to step and returns.

The routine begins in step and receives a request related to the execution of one or more programs such as from the system manager module. The routine proceeds to step to determine whether a request to execute or store an indicated program was received. If so the routine proceeds to step to determine whether the indicated program is currently stored in the local program repository of the computing system being managed. If not the routine continues to step to determine whether the local program repository has sufficient capacity to store the indicated program. If not the routine continues to step and evicts one or more programs from the local program repository such as is indicated in the request received in step or otherwise based on an eviction policy used by the machine manager module. After step or if it was instead determined in step that the local program repository did have sufficient capacity to store a local copy of the indicated program the routine proceeds to step and acquires a copy of the indicated program from one or more determined other computing systems. The routine may determine other computing systems that have a stored local copy of the program in various ways including based on information received as part of the request received in step . Additionally using one or more other techniques such as broadcasts to neighboring computing systems requests to central directories and or peer to peer data exchanges may also be used. In other embodiments the copy of the program may instead be provided along with the request in step . Next the routine proceeds to step and stores the obtained copy of the indicated program in the local program repository. After step or if it was instead determined in step that the indicated program was already stored in the repository the routine proceeds to step to determine whether an indication of a program to be executed was received. If so the routine proceeds to step and initiates execution of the indicated program.

If it was instead determined in step that a request to store or execute a program was not received the routine proceeds to step and performs other indicated operations as appropriate. For example other operations may include suspending or terminating execution of one or more programs such as in response to a received request and or based upon information gathered regarding the performance of the program such as that the program was behaving erratically or excessively utilizing resources. Additionally other operations may include responding to requests for status information regarding currently executing programs or the contents of the local program repository etc.

After steps or if it was instead determined in step that an indication of a program to execute was not received the routine proceeds to step and sends a status information message to one or more system manager modules. In the illustrated embodiment the routine sends a status information message to the system manager module after every operation in order to keep the system manager apprised of the state of the computing system managed by the node manager. In other embodiments the status information may be sent at other times and in other manners. After step the routine proceeds to step and determines whether to continue. If so the routine returns to step and if not proceeds to step and returns. While not illustrated here the routine may also perform various housekeeping operations at various times as needed.

The routine begins in step and receives a request related to the execution of one or more programs. In step the routine determines the type of the received message. If the request is related to registration of a new program or a new version of a previously registered program the routine proceeds to step and sends an indication of a new program to be registered to the program execution service e.g. to a system manager module . The indication may include a copy of the program or an instruction of how to obtain the program. If the request is instead determined in step to be related to the execution of a program the routine proceeds to step to send a request to the program execution service e.g. to a system manager module to execute one or more instances of a program to be executed. For example the routine may use an indication previously received from the program execution service to identify the program and or the user on whose behalf the program instance s will be executed. If it is instead determined in step that some other type of request was received the routine proceeds to step and performs other indicated operations as appropriate. For example the routine may send a request to the program execution service to reserve computing resources at a future time to execute one or more indicated program instances send a status query to the program execution service regarding current or prior execution of one or more programs provide or update user related information e.g. as part of registering the user with the program execution service de register or otherwise remove previously registered programs suspend or terminate execution of one or more program instances etc.

After steps or the routine continues to step and optionally performs additional housekeeping tasks such as to update display information store information received back from the program execution service not shown in response to steps or make periodic status queries of the program execution service etc. After step the routine proceeds to step to determine whether to continue processing. If so the routine returns to step and if not proceeds to step and returns.

Those skilled in the art will also appreciate that in some embodiments the functionality provided by the routines discussed above may be provided in alternative ways such as being split among more routines or consolidated into fewer routines. Similarly in some embodiments illustrated routines may provide more or less functionality than is described such as when other illustrated routines instead lack or include such functionality respectively or when the amount of functionality that is provided is altered. In addition while various operations may be illustrated as being performed in a particular manner e.g. in serial or in parallel and or in a particular order those skilled in the art will appreciate that in other embodiments the operations may be performed in other orders and in other manners. Those skilled in the art will also appreciate that the data structures discussed above may be structured in different manners such as by having a single data structure split into multiple data structures or by having multiple data structures consolidated into a single data structure. Similarly in some embodiments illustrated data structures may store more or less information than is described such as when other illustrated data structures instead lack or include such information respectively or when the amount or types of information that is stored is altered.

As previously noted various embodiments will organize computing systems of the program execution service into one or more groups in order to facilitate the implementation of policies related to the execution of programs. Additionally computing systems may be organized in other manners such as with a hierarchy of groups. For example the smallest groups may each contain a single computing system and each computing system will be assigned to its own group. The single machine groups connected by a single network switch may then further be contained in a switch level group that contains all of the computing systems physically connected by a single network switch. The switch level groups may then further be contained in a data center level group that contains all of the computing systems in a given data center. The data center level groups may then be further contained in a universal group that contains all of the computing systems in multiple data centers. In such an organization the groups at each level generally have successively slower access to copies of programs located on other computing systems in the group with the single machine groups providing the fastest access and the universal group providing the slowest access. Such an organization may enable the efficient implementation of the application of various policies that guide the optimum placement of executing programs as the program execution service may search for the smallest group that has both stored a copy of a particular program to be executed and has the requisite resource availability to execute the program. Alternatively other embodiments may not model the computing systems in the program execution service by way of groups at all. Such embodiments may for example distribute copies of some or all of the programs to dedicated data storage computing or other systems connected to some or all of the network switches or located on some or all hardware racks and then simply assign programs to be executed to computing systems selected at random.

As previously noted various embodiments may implement different policies with respect to the selection of computing systems and or groups as candidates to execute programs and or receive distribution of program copies. In many cases various program placement policies may entail tradeoffs between factors such as reliability and efficiency e.g. startup latency network latency or throughput etc. . Placement policies may take into account factors such as the preferences of the user requesting the execution of one or more programs the number identity and location of programs currently executing the number and identity of programs currently being requested for execution the number and identity of programs scheduled for execution in the future the location of previously stored copies of programs network architecture geographic location etc. In addition default application of policies may in some cases be overridden or modified based on user requests or other factors in some embodiments. For example a particular embodiment may provide a set of default policies that can be overridden by user preferences as expressed in their requests for the execution of one or more programs.

In embodiments in which the computing systems being managed by a program execution service span multiple data centers the program execution service may prefer to execute multiple instances of a single program within the same data center and or to execute instances of multiple distinct programs for the same user within the same data center. Such a policy will tend to allow such programs to take advantage of relatively higher bandwidth intra data center data exchange for communications between the program instances. On the other hand some embodiments may prefer to distribute such program instances over multiple data centers in order to assure reliability in cases of power network or other large scale outages that could disable an entire data center such as for program instances that perform little or no communication with other such program instances. Such preferences to distribute or consolidate such program instances may similarly be applied at various other levels of computing system organization such as for physical sub networks groups and individual computing systems. In addition some embodiments may employ policies that may be used to choose between multiple candidate computing systems that are otherwise indistinguishable under the placement policies of the program execution service. For example one embodiment may randomly select a computing system from a set of equally good candidate computing systems whereas another embodiment may select the computing system with the lowest resource utilization while a different embodiment may select such computing systems in a round robin order.

In addition various embodiments may implement different policies for the storing of copies of programs in local program storage repositories with respect to the execution of programs. For example some embodiments may always store a local copy of a program on a local program storage repository prior to or during or after its execution on the computing system that houses the local program storage repository. Alternatively in other embodiments only some programs will be stored in such local program storage repositories. Furthermore various embodiments may take different approaches when program storage repositories do not have sufficient capacity to store a local copy of a given program. For example some embodiments will opt to evict or otherwise remove one or more copies of programs that have been stored in the program repository in order to make space for storing the new program such as to evict the least recently used copy the oldest copy a random copy a copy selected in a different manner a copy of a program that is still stored in some other related program repository such as that of one or more other computing systems in a common group etc. In other embodiments no eviction will be performed when a given program repository is full e.g. such as by instead periodically removing all programs from the program repository such as daily on reboot etc. or by removing a program only when it is de registered from the program execution service .

In some embodiments programs may be decomposed into multiple possibly fixed size blocks of data. By decomposing a program in this manner a computing system that is acquiring a copy of the program may distribute requests to multiple other computing systems that have stored the required program blocks in their program repositories. As some of the other multiple computing systems respond to requests for program blocks the acquiring computing system may request additional program blocks from those responding computing systems. Accordingly computing systems that have sufficient resource availability will be favored to provide program blocks over less responsive or unresponsive computing systems.

Some embodiments may make optimizations to improve the transfer efficiency of programs such as by only transferring portions of programs that differ from other programs that are possibly already stored in a local program repository. Such approaches may be advantageous given multiple incremental versions of the same program or different programs that share significant portions of code or data. For example if programs are decomposed into multiple possibly fixed sized blocks checksums may be computed for each block and stored when the program is initially registered with the program execution service. Later when the program is to be obtained for execution a computing system may compare the program block checksums against checksums associated with blocks of programs resident in one or more program repositories and then only obtain program blocks that have not already been stored. Alternatively some embodiments may represent the program as a collection of one or more files such as executables data files and library files. In such a case two programs may have one or more files e.g. library files in common and a given computing system may elect only to obtain the files of a program to be obtained for execution that differ from files that have already been stored in the computing system s program repository.

Some embodiments will provide for programs that are all of a fixed size whereas others will allow programs of various sizes. Fixed size programs may simplify the handling of programs in the context of calculating program utilization of system resources such as memory or program repositories. In embodiments that provide for programs of various sizes various algorithms may be applied to optimize the utilization of fixed size resources such as memory or disk space to limit fragmentation when storing local copies of programs and or when executing program instances including various bin packing algorithms such as best fit first fit etc.

In addition some embodiments may provide functionality for seeding or otherwise distributing copies of programs to various of the managed computing systems in advance of requests to execute the programs. While some embodiments will provide at least one universal program repository for storing programs when they are first registered these embodiments may suffer from high latency when the program is first executed since the program will not be found in any program repository that is relatively local to the computing system on which it is to be executed. If such an embodiment is configured to store local copies of executed programs in local program repositories then subsequent executions will incur relatively smaller startup latencies when compared to the initial execution. The problem of relatively long start up latencies for the initial execution of programs can be addressed by seeding or otherwise distributing copies of programs in advance of requests to execute the program. Such embodiments may distribute one or more copies of the program to program repositories that are local to the one or more data centers that provide the program execution service. In that manner when a program is requested to be executed for the first time it will generally be found in a program repository that is relatively local e.g. at least in the same data center to the computing system or computing systems that are chosen to execute the program.

In addition some embodiments may make optimizations in the case of the simultaneous or overlapping initiation of execution of multiple instances of a single program. In such circumstances it may be the case that a copy of the program to be executed will need to be obtained by multiple distinct computing systems at roughly the same time. If each computing system independently obtains a copy of the program from a remote program repository over utilization of network and other resources may result as each computing system initiates transfers of identical data over the network simultaneously. In some circumstances it may be beneficial for the multiple computing systems to synchronize or otherwise order their acquisition of one or more copies of the program to better utilize system resources e.g. by minimizing unnecessary network usage . For example when multiple computing systems selected to execute a program are part of the same group and are to acquire program copies from one or more computing systems outside of the group it may be beneficial for a first computing system of the multiple computing systems to initially obtain and store in a local program repository a copy of the program from the computing systems outside of the group. After the first computing system has obtained a copy of the program the remainder of the multiple computing systems may obtain copies from the first computing system via the common data exchange medium for the group.

In addition various additional techniques may be used to efficiently utilize network and or other computing resources when multiple computing systems are each to acquire a copy of a program. For example a first of the multiple computing systems may be selected to manage the distribution of copies of the program to the other of the multiple computing systems. If none of the multiple computing systems has a stored copy of the program in a local program repository the selected computing system may initiate the transfer of at least portions e.g. blocks of the program from a remote location. As portions of the program are received by the selected computing system the selected computing system may multicast the received portions to the other of the multiple computing systems. Such multicasting may result in improved network utilization compared to other network communication mechanisms e.g. a TCP based transfer by each of the multiple computing systems because fewer redundant data packets will be sent to the network connecting the multiple computing systems. Alternatively if one or more of the multiple computing systems has a stored copy of the program in a local program repository the selected computing system may direct at least some of the one or more computing systems that have a stored copy of the program to multicast at least portions e.g. blocks of the program to other of the multiple computing systems thereby distributing the load of transferring blocks and minimizing impact on other computing systems and or portions of the network. After such a multicast based distribution of the program one or more of the multiple computing systems may then utilize an alternative communications mechanism e.g. TCP in order to obtain any portions of the program that were not received e.g. because of dropped network packets . The alternative distribution mechanisms may include distributing requests for portions in a round robin or other manner that distributes load on the other of the multiple computing systems and or portions of the network .

In some embodiments additional techniques may further be used. For example if a multicast based distribution mechanism is used to distribute portions of a program to computing systems of a group from another computing system in the group various techniques may be used to prevent or limit any network traffic outside of the group due to the multicast. For example a short time to live may be specified for the multicast packets and or using packet addressing techniques so that a switch does not transmit the multicast packets to computing systems that are not attached to the switch. Furthermore some embodiments may implement various policies in order to minimize network resource usage minimize load on computing systems that are not involved in the transfer or execution of copies of programs for execution and or provide predictable performance of network and or computing resources. For example some embodiments may limit the rate at which computing systems may transfer copies of programs to other computing systems whether for multicast and or point to point transmissions. In addition some embodiments may limit the transfer rate of and or restrict the proportion of network bandwidth that may be utilized by intermediate network devices e.g. switches routers etc. as they transfer data packets carrying portions of copies of programs between sub networks. Such data packets may be identified by intermediate network devices based on for example being of a specific type and or being destined for particular addresses e.g. multicast IP addresses in a particular range and or ports. In some embodiments multiple mechanisms such as those described above may be combined to implement various network utilization policies.

In some embodiments various techniques may also be used to migrate one or more executing program instances from one or more computing systems to one or more other computing systems. In one aspect the migration may reflect problems related to the initial computing systems on which the program instances are executing e.g. failure of the computing systems and or of network access to the computing systems . In another aspect the migration may accommodate other program instances to be executed on the initial computing systems such as for higher priority program executions or to consolidate the execution of program instances on a limited number of computing systems such as to enable the original computing systems executing the program instances to be shut down for reasons such as maintenance energy conservation etc. As one specific example if the one or more program instances executing on a computing system need more resources than are available from that computing system one or more of the program instances may need to be migrated to one or more other computing systems will additional resources. Overuse of available resources may occur for various reasons such as one or more computing systems having less resources than expected one or more of the computing systems using more resources than expected or allowed or in embodiments in which available resources of one or more computing systems are intentionally over committed relative to possible resources needs of one or more reserved or executing program instances. For example if the expected resources needs of the program instances are within the available resources the maximum resource needs may exceed the available resources. Overuse of available resources may also occur if the actual resources needed for program instance execution exceed the available resources. Migration of programs may be performed in various manners such as to transfer copies of programs locally stored on the initial computing systems to the target destination computing systems and or to begin executing new instances on the target destination computing systems of the programs executing on the initial computing systems. The migration may occur before the initially executing program instances terminate if possible such as to allow current execution state information to be transferred to the new executing program instances and or to allow other coordination between the initial and new program instances.

Some embodiments may provide a program execution service to multiple customers in exchange for a fee. In such circumstances customers may register or otherwise provide programs to the program execution service and request the execution of such programs in exchange for a fee. Various billing models may be used such as for customers to purchase access to various configurations of program execution service resources e.g. network bandwidth memory storage processor on a time basis e.g. minutes hours days etc. to purchase access to one or more predetermined virtual or physical hardware configurations to purchase premium services for additional fees e.g. to provide priority execution such as to initiate execution of a premium customer s program prior to that of a non premium customer to provide priority program repository placement such as to evict programs belonging to non premium customers prior to those of a premium customer etc. to purchase the ability to execute a program instance for a specified period of time on a per instance execution basis etc.

As previously noted some embodiments may employ virtual computing system and if so the programs to be executed by the program execution service may include entire virtual computing machine images. In such embodiments a program to be executed may comprise an entire operating system a file system and or other data and possibly one or more user level processes. In other embodiments a program to be executed may comprise one or more other types of executables that interoperate to provide some functionality. In still other embodiments a program to be executed may comprise a physical or logical collection of instructions and data that may be executed natively on the provided computing system or indirectly by means of virtual computing systems interpreters or other software implemented hardware abstractions. More generally in some embodiments a program to be executed may include one or more application programs application frameworks libraries archives class files scripts configuration files data files etc.

Although embodiments have been described that utilize a combination of intercommunicating system manager modules and machine manager modules to manage the execution of programs within the program execution service other implementations and allocations of responsibility between the various program execution service modules are also contemplated. For example in some embodiments a single module or component may be responsible for managing the execution of programs on some or all of the managed physical computing systems or virtual machines. For example programs may be directly executed on target computing systems by way of various remote execution techniques e.g. rexec rsh etc. 

Those skilled in the art will also realize that although the example embodiment described above was employed in the context of a data center used to provide a program execution service other implementation scenarios are possible as well. For example the described facility could be employed in the context an organization wide intranet operated by a business or other institution e.g. university for the benefit of its employees and or other members. Alternatively the described techniques could be employed by a distributed computing system comprising nodes that are individually managed and operated by various third parties for the purpose of performing large scale e.g. scientific computing tasks in a distributed manner.

Those skilled in the art will also realize that although in some embodiments the described techniques are employed in the context of a data center housing multiple intercommunicating nodes other implementation scenarios are also possible. For example the described techniques may be employed in the context an organization wide intranet operated by a business or other institution e.g. university for the benefit of its employees and or members. Alternatively the described techniques could be employed by a network service provider to improve network security availability and isolation. In addition example embodiments may be employed within a data center or other context for a variety of purposes. For example data center operators or users that sell access to hosted applications to customers may in some embodiments use the described techniques to provide network isolation between their customers applications and data software development teams may in some embodiments use the described techniques to provide network isolation between various environments that they use e.g. development build test deployment production etc. organizations may in some embodiments use the described techniques to isolate the computing resources utilized by one personnel group or department e.g. human resources from the computing resources utilized by another personnel group or department e.g. accounting or data center operators or users that are deploying a multi component application e.g. a multi tiered business application may in some embodiments use the described techniques to provide functional decomposition and or isolation for the various component types e.g. Web front ends database servers business rules engines etc. . More generally the described techniques may be used to partition virtual machines to reflect almost any situation that would conventionally necessitate physical partitioning of distinct computing systems.

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims and the elements recited therein. In addition while certain aspects of the invention are presented below in certain claim forms the inventors contemplate the various aspects of the invention in any available claim form. For example while only some aspects of the invention may currently be recited as being embodied in a computer readable medium other aspects may likewise be so embodied.

