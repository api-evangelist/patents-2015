---

title: System and method for correlating cloud-based big data in real-time for intelligent analytics and multiple end uses
abstract: A processing platform integrates ETL (extract, transform, and load), real time stream processing, and “big data” data stores into a high performance analytic system that runs in a public or private cloud. The platform performs real time pre-storage enrichment of data records to form a single comprehensive record usable for analytics, searching and alerting. The platform further supports sharing of components and plug-ins and performs automatic scaling of resources based on real time resource monitoring and analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501535&OS=09501535&RS=09501535
owner: Leidos, Inc.
number: 09501535
owner_city: Reston
owner_country: US
publication_date: 20150727
---
The present application is a continuation of U.S. patent application Ser. No. 13 776 112 filed Feb. 25 2013 titled System and Method For Correlating Cloud Based Big Data in Real Time For Intelligent Analytics and Multiple End Uses which is incorporated herein by reference in its entirety.

The embodiments relate in general to system and methods for correlating volumes of disparate data and enriching in real time. More particularly the embodiments are directed to a system and process for enriching incoming big data within the cloud to add dimensional data in order to enable post cloud relating and use by different applications.

The problem to be solved generally is how to manage and analyze big data e.g. on the order of petabytes of data. Big data is broadly defined as data sets with sizes beyond the ability of commonly used software tools to capture curate manage and process the data within a reasonable amount of time. The world s information doubles approximately every two years. This information or data includes critical intelligence but the mining of such intelligence becomes cost prohibitive and takes too long for many end users and applications. Whereas traditional data sets include narrow subsets of historical structured static data populating relational databases big data presents a particularly difficult problem for end users as it is unlimited may be both structured and unstructured is frequently available in real time and may be iterative. Such big data is simply too much for the present relational database management systems without significant processing which is time consuming and ultimately renders much of the data outdated and of limited value.

A number of existing data warehousing techniques address the backend correlation changes of scenarios such as depicted in Dimensional modeling has been used to organize data in a data warehouse to increase its analytical value and support end user queries by adding dimension data to fact data to provide context. This is described in multiple papers by Ralph Kimball see for example A Dimensional Modeling Manifesto Aug. 2 1997 Kimball Group www.kimballgroup.com which is incorporate herein by reference in its entirety. While the dimensional modeling technique is available to structure the data after it is saved in DBto DBto support end user queries this is a backend technique.

Accordingly there is a need in the art for an improved system and method for front end processing of big data for near real time availability for alerting query and analysis by one or more users.

In a first exemplary embodiments a process for data collection and conditioning is described. The process includes receiving multiple data records from multiple data sources at a processing engine wherein the multiple data records have different formats from each other and from a pre established internal data format parsing in near real time by at least one parser each of the multiple data records into multiple constituent parts translating in near real time by at least one translator each of the multiple data records using their parsed multiple constituent parts into a pre established internal data format comparing in near real time by the processing engine each of the multiple translated internal data records with at least a first enrichment rule to determine if the at least a first enrichment rule is applicable to the translated internal data record if applicable enriching in near real time by the processing engine the translated internal data record with additional data pursuant to the at least a first enrichment rule to form an enriched translated internal data record and transmitting in near real time the enriched translated internal data record to at least one data sink for storage therein wherein the enriched translated internal data record is available for use by multiple applications.

In a second exemplary embodiment a process for data collection and conditioning is described. The process includes receiving multiple data records from multiple data sources at a processing engine holding the received multiple data records in a first queue to await processing pulling the received multiple data records off of the first queue by a designated number of ingest nodes for processing monitoring continuously during the process at least one of first queue size and a rate at which received multiple data records are pulled off of the first queue determining that the first queue size or rate are outside of an acceptable range allocating or deallocating ingest nodes to or from the designated number of ingest nodes automatically during the process in accordance with the determination transmitting from the designated number of ingest nodes in near real time the processed multiple data records to a second queue holding the received processed multiple data records in the second queue pulling the received processing multiple data records off of the second queue by a designated number of data sink nodes for processing monitoring continuously during the process at least one of second queue size and a rate at which received processed multiple data records are pulled off of the second queue determining that the second queue size or rate are outside of an acceptable range allocating or deallocating data sink nodes to or from the designated number of data sink nodes automatically during the process in accordance with the determination and transmitting in near real time each of the processed multiple data records to at least one of the multiple data sinks for storage therein wherein the processed multiple data record are available for use by multiple applications.

In a third exemplary embodiment a system for data collection and conditioning is described. The system includes multiple data transports for receiving multiple data records from multiple data sources and delivering to a first queue for processing wherein the multiple data records have different formats from each other and from a pre established internal data format multiple ingest nodes for accessing the multiple data records and facilitating parsing in near real time by at least one parser each of the multiple data records into multiple constituent parts translating in near real time by at least one translator each of the multiple data records using their parsed multiple constituent parts into a pre established internal data format comparing in near real time by a processing engine each of the multiple translated internal data records with at least a first enrichment rule to determine if the at least a first enrichment rule is applicable to the translated internal data record if applicable enriching in near real time by the processing engine the translated internal data record with additional data pursuant to the at least a first enrichment rule to form an enriched translated internal data record a second queue for receiving translated and enriched internal data records from the multiple ingest nodes and multiple data sink nodes for accessing the translated and enriched internal data records and transmitting in near real time each of the translated and enriched internal data records to at least one data sink for storage therein wherein the translated and enriched internal data records are available for use by multiple applications.

Referring to the present embodiments include a platform that integrates ETL extract transform and load real time stream processing big data data sources i.e. Dto D and enrichment data sources i.e. Dand D into a high performance analytic system that runs in a public or private cloud. The platform supports sharing of components and plug ins.

As described herein real time means responding to the incoming high velocity streaming and likely disparate data within seconds. As such the platform is provisioned for peak load as compared to average daily load. Since peak load is often several times the average and spikes occasionally occur that are hard to predict when running in a virtualized environment the present embodiments are designed to scale to meet virtually any load and can do so automatically. More particularly running in a public or private cloud computing environment platform dynamically provisions compute storage and network resources to run the system that has been configured. There are two aspects to this. First is simplifying the process of running a system itself. In a traditional environment you must decide physically where everything runs which server what storage etc. and be sure to set things up that way. However when running in a cloud environment platform automatically starts virtual machines allocates and attaches virtual storage and establishes the network parameters so the system operates correctly.

The automated scaling is responsive to a platform configuration that monitors processing load and adds or removes resources as load changes. For example the platform can be configured such that it maintains the throughput rate required to maintain the data flow rate sent by input sources. The platform can also be configured to add storage when required. This means that if load spikes occur the system can respond without human intervention.

Referring to the mechanism for automated scaling relies upon the monitoring of key processes involving the system JMS messaging and disk usage for the data sinks described below in detail . As shown the system transport processes accept external data in native format and convert the data into JMS messages for the external JMS instance to receive and add to the message queue. The ingest nodes then pull messages off the queue for processing. If a condition occurs such that the allocated ingest nodes cannot work the messages off the queue at a sufficient rate the queue size increases. When this happens the platform automatically starts additional ingest nodes to provide additional capability to keep up with the pace of the incoming data. Eventually the ingest processors stabilize relative to the throughput of incoming data and the messages in the JMS queue are decrease as the extra ingest nodes work them off. In a similar fashion if the allocated ingest nodes sufficiently process the incoming messages traffic the system will deallocate ingest nodes reducing down to a sufficient quantity. The process represents a continual feedback loop that adds or subtracts system ingest instances as required. The trigger point for adding additional nodes is user configurable allowing for optimization and tuning of the ingest flow process for each particular configures platform.

A similar mechanism also exists for the internal JMS node. Referring to the ingest processors output enriched data records to the internal JMS node from which the allocated system data sinks can read and act upon typically storing the data records within the messages. The automated scaling monitoring process observes the messaging throughput of the internal JMS node to see if the consuming data sinks are sufficient to maintain pace with the output from the collective ingest nodes. As with the case described for the external JMS node the automated scaling process spawns additional data sink nodes if needed to maintain pace with message traffic. An additional factor within the automated scaling of data sink nodes is disk space utilization. Several of the platform data sink components persist the data in storage therefore the available disk space imposes a limit to the number of additional storage based data sink nodes that may be added.

Another important feature of the automated scaling process is protection of the system from oversubscribing of resources. Two distinct features fall within this area of system protection. The first is a choke of ingest node allocation. In the event that the internal JMS node memory utilization exceeds a user defined capacity the system will invoke a choke mechanism in which allocation of new ingest nodes will be suspended. This has the effect of limiting the rate at which new messages will be added to the internal JMS queue. Note that autoscaling of the data sink node continues and in fact should eventually clear the condition. While the choke is engaged data may begin to back up into the external JMS system causing its input queue to grow. At some point the external JMS system invokes its flow control mechanism which blocks the transport from adding additional data. Ideally the system would be allocated enough processing resources such that the choke condition would be unnecessary but it does exist to maintain the running state of the system. The configuration for removing the choke is also user configurable and based upon the internal JMS node memory utilization. It will typically be set below the choke activation point to prevent the choke feature to continually toggle on and off.

The other protection feature of the system addresses conditions that trigger the adding of additional ingest or data sink instances but for which no improvement gains are achieved by the system. This would occur for example if resources outside the visibility of the system such as the network became a bottleneck. In those cases adding more processing capability will not alleviate the problem and in fact would exacerbate the problem. This is because these new nodes would attempt to consume resources that are already at capacity. The automated scaling method in the system measures response to messaging throughput as it adds new instances as part of the feedback control loop. When the condition occurs where new instances do not increase system throughput the automated scaling mechanism stops adding resources however resources can be removed for a user defined period of time. This system circuit breaker prevents a runaway condition of constantly adding new resources to no avail.

The platform uses shared reusable components. There are two types of components plug ins and data components. Plug ins are written in Java and add functionality to the platform. There are three types of plug ins as follows parsers which convert a specific data format into name value pairs exemplary formats include CSV XML JSON JPEG etc. enrichment which add context to the raw data from input data streams for example there is an enrichment that correlates dimension records to the input stream though a simple key matching strategy and data sinks which consume the final enriched record for some purpose generally speaking this usually means storing or indexing the data but a data sink can perform other functions such as alert filtering .

Data components include data models and dimension data. Currently data components and plug ins are public or private. A public component is available to all and can be reused. A private component only applies to the current tenant. The platform facilitates and allows for the development of a set of data components for a particular purpose or vertical market and sharing of components among peers. For example a set of standard data components can be developed specifically for cyber security threats. This standard set can then be extended to add additional functionality.

In order to achieve a rapid response and situational awareness from real time alerts they need to be understandable and actionable. This would not be the case if for example the data feed is full of codes or magic numbers or if critical pieces of information were missing but available from another data source. Accordingly referring to the platform includes a correlation and enrichment engine hereafter processing engine which adds context and meaning so that real time alerts are meaningful. This makes the alert understandable and actionable.

Data correlation is achieved by taking diverse data feeds e.g. Dto D and normalizing them to a common data model. However data models in a SQL database are very rigid in that only one data model can be in force at any given moment and changing them requires data migrations and other fixes that limit data agility. But there is still value in having a common model upon which application and algorithms can rely. For example if you have a dozen algorithms and applications that depend on a common data model if you add a new data source none of those algorithms and applications needs to change. Platform takes a unique approach to addressing this issue by allowing data models to change more easily. To accomplish this data models are dynamic and versioned and a new or updated model can be deployed quickly as needs arise. No data migrations are necessary because the system allows different versions of the same data model to exist in the data store at the same time. The new data model is deployed and it takes effect. Each record is tagged with its data model and version if needed.

Enrichment is the process of adding meaningful information to data feed records before they are stored or alerted upon. This is similar to the idea of dimensions in dimensional modeling. In dimensional modeling a dimension is often a separate data source that is correlated with the input feed. By way of example think of a point of sales POS transactions and a customer database. Each sale is correlated with a customer record in a customer dimension table. This adds additional information to the sale about that customer to the POS data record.

To effectively use the NoSQL databases to support big data in certain embodiments the platform pre joins the input feed to dimensions at ingest time. Continuing the POS example above this means that all the fields from the customer record from the customer table that matches the customer referenced in the sale is merged with the sales record. Now when the record is queried no joins are required the data is already in the record. Pre joining is just an example of a way to add meaning and context to the data. Generally any algorithm that runs on the data and adds something to it is enrichment. Data that comes from dimension tables is one kind of enrichment. Others include for example an algorithm that takes an IP address and figures out the CIDR network it is part of or examines an email feed to see if it is a phishing attack or an algorithm that converts a latitude longitude pair to a grid reference. The dimension tables and algorithms that add to the data are generally referred to as enrichment sources . After correlation and enrichment a single comprehensive and fully expanded record exists for use in alerting querying analysis and other applications within seconds.

The processes and functionality discussed above are discussed below in detail with reference to along with description of configuration specifications. The functionality and implementing components and subcomponents i.e. software and or hardware are singularly referenced in the figures but one skilled in the art recognizes that such components and subcomponents may be implemented through recognized processing software hardware or a combination thereof. Further the various components and subcomponents need not necessarily be co located in a single location or in some instances be under the direct control of the same entity. Further still it is recognized that certain of the various components and subcomponents may be located on a public infrastructure while others may be located on a private infrastructure. Some or all of the configurations of the processing pipeline described below may be performed by a user through for example a series of web based application programming interfaces APIs .

A data model is the foundation for defining and managing data in accordance with the embodiments described herein. The data model defines the input sources the internal normalized data model or format that the embodiments use to organize data the parsing techniques used to translate incoming data into the internal format and the sources and types of dimensional data that will be used to enrich i.e. enhance or further describe the data e.g. replacing a ProductiD with a ProductName from a supporting relational table and any additional algorithmic processing on the data resulting in appending the computed results to the data. The data model specifies three components Input model which is a JSON based model that specifies how the data will look when it enters the system and is mapped into a normalized model this is the data model for the internal format data sources which are specifications for parsing the incoming data and mapping translating each field to the input model and enrichment processing which are rules for enhancing the data with dimensional data for additional context and meaning.

The input model is defined to include a name for the input model a name for each field in the input model the data type of each field e.g. String Number Date Time Object and Array. The input model includes fields that are common to all data sources and it may also include fields that are specific to just one or more data sources. Common fields provide a data provenance mechanism to embed the data information source to the data record. This can be important for applications requiring auditing of data and forensic analysis. Similarly common fields include a data labeling mechanism that can assign data classifications. This feature can be used to restrict access to data records to only individuals or groups having permission to access data based upon its label.

Data sources Dto Dcan originate from virtually any data store or format a data stream feeding real time transactional records multiple relational databases web sites RSS feeds SIEM files email archives etc. The primary data feeds will contain the fact records that are central to the input model. Configured input data sources include name and location of each incoming data source that will provide data. Additionally file format and the parser type required to extract data fields for input are defined for example 

Binary a user configurable parser that is used to extract fixed fields from byte strings in binary files 

CEF a parser that uses the Common Event Format from ArcSight an open standard for logging security related information in a common event log format 

CSV a commonly used parser to extract comma separated values from plain text files this parser is user configurable 

Email a parser that works with the RFC 822 ARPA email text format which specifies the structure of email messages including attachments to and from fields etc. 

EXIF a configurable parser that works with the Exchangeable Image File format used for handling image and sound files from digital cameras 

JSON a configurable parser that extracts data from text formatted in the JavaScript Open Notation standard 

A Field delimiter type is defined and includes Comma Pipe or New line. For each incoming data field the original source specifications for the parser are required and include Field name Field data type String Number Date Time Object Array Translation rules for mapping a field into the input model JSON representation Conversion requirements date conversions Constant value Processing rules could be specified in a script that you run on the data source If a field should be enhanced with data from another table or source identify the dimension table name and column s that will provide the enrichment data and Input date format.

Each data source must be associated with a transport mode. Ingest supports several secure automated transport mechanisms including file based transfer protocols streaming TCP and UDP connections external database queries and unstructured documents. For example the TCP transport establishes a TCP socket listening to a port converts it to JMS messages and pushes the data into the JMS external node. Each parser can be assigned to a different transport type. Exemplary transports include polling services. One exemplary service watches local file system. Another exemplary service retrieves data from a database and pulls it into the platform by running an SQL select query against any database. The database can be queried regularly starting at the point where the query last left off. An S3 bucket is used to store a backup copy of the data file. Yet another service copies data directly from a JMS server to the platform server without a transport. The JMS Bridge Service pushes data directly onto a JMS queue without a transport. For example there could be two JMS servers in play a corporate JMS server and the platform JMS server the bridge pushes data from enterprise queue to platform.

For static files such as legacy data the S3 transport service may be used. The S3 transport can be configured two ways as a one shot event it pulls data from an Amazon s S3 Simple Storage Service file and pushes it to the platform JMS queue or it can be configured to poll an S3 bucket regularly at a set time interval. Additional transport services can be used to read data in a TCP stream wherein the TCP socket listens to a port converts the data to a JMS message and puts it on the JMS external queue. There is also a transport service that captures network packets in a UDP stream converts the data to JMS messages and sends them to the JMS external node. Finally transport service is available to read the contents of a URL and put it on the JMS input queue. This transport may be used to pull data from an RSS feed or from any service that pulls resources from another organization or data source.

As discussed briefly above the platform performs various data enrichment functions during front end data processing . For example dimensional enrichment associates a secondary data table with a primary data source to add data to each record that better describes a data element. For example returning to the previous from a POS example POS transaction stream data records could be enhanced with the product names replacing product IDs customer names to replace customer IDs mailing addresses etc. The enhancement data comes from dimension data tables specified by the end user as part of the configuration of the platform data model discussed above. For each dimension table end users identify the fields in the input model that will be enhanced with the dimensional data. Additionally the platform may also implement generalized or algorithmic enrichments that do not require dimension tables as the source for enhancement data. Generalized enrichments use data from proprietary or public sources. For example to add the geographic location of an airport the platform converts standard 3 letter airport codes to latitude longitude coordinates.

By way of example for dimension table specifications end users inventory each enrichment source dimension table for its content format and structure. It should be noted how each enrichment source correlates to the main data feed in order to specify translation rules for the data fusion engine. The following information is used to configure each dimension table Name of dimension table Primary key Column Field name to extract Data type i.e. Varchar Decimal Date and if Nulls are allowed in the field.

Dimensional enrichments require the specification of dimension tables which store the enhancement data that a user wants to add to native input data in the platform input model. Users can define a dimension table at any time but it is most logical to define the tables before specifying enrichments. In other words when possible users should define source data including dimension tables before configuring data use within the platform. Defined data tables populate the dimension table enrichments specified by the user. There are three types of keys considered. Every data table has a master key which aids in read write performance and with data integrity. This is the primary key. The primary key defines one or more columns which uniquely identify a row within a table. The primary key can be either a natural or a surrogate key with industry best practices dictating that the primary key would be a surrogate key. Most database systems only allow a single key in a table the primary key. However you can have uniqueness indexes which identify secondary keys which can either be natural or surrogate keys.

A natural key defines one or more columns that uniquely identify each row in the table. The columns used in a natural key must be part of the original data set. For example a unique customer key may be built with the C NAME and the CSSN columns. Or a table of airport codes may only need one field the3 letter airport code as a natural key that is unique for each record. Natural keys are most often defined with two or more columns. This key is used to index the records in the dimension table and to search the table for a matching row. Indexes are used when the enrichment engine has to do a full look up on the dimension records.

A surrogate key is a single column added to the original data set to uniquely identify each record. Any column type string number alpha numeric can be used as a surrogate key as long as it is unique. However a sequential numeric column is usually used for performance and simplicity. A surrogate key is required to insert a record into the platform. An exception to this requirement is made if a user sets an enrichment cache to ignore an unknown record and not add it to the database see below .

There are no default dimension tables or pre defined enrichment tables. A dimension table may originate from an SQL table located in a corporate data warehouse. It may be a simple CSV file linked to other systems. Or it may be an XML file in a custom application. Once the dimension tables are defined the source enrichment data is imported therein via e.g. a CSV file or a ZIP file.

Once columns have been specified for a dimension table and indexes and keys have been defined for the records the dimension fields can be mapped to the input model fields that will be enriched with data from the particular dimension table. Pre assigned enrichment field names are referenced when dimension table enrichment models are specified. Working with one field at a time dimension table columns are mapped to input model fields using assigned enrichment roles. The assigned enrichment roles indicate if a dimensional column is used to enrich input records or if it is a key for enrichment look ups. Prior to mapping a role is chosen for each column in the dimension table. Values in the surrogate key dimensional column are unique sequential numbers used to insert a record into the platform and need to be defined if the enrichment cache is set to Add Record to DB. The natural key dimensional column represent a unique key indexed for enrichment look ups. Values in the data dimensional column will be used to enrich input model records to enhance data sources with additional clarifying information. Any not used dimensional column is ignored for enrichment purposes. Enrichment field details map dimension data columns to enrichment fields in the input model. This is where the enrichment field names that are used to enrich the input model are assigned. These field names are stored in JSON in the preferred embodiment.

Now it would be too slow to do full look ups to match every transactional record against the dimension records so the platform uses a configured enrichment cache for faster processing. When configuring the enrichment cache there are several specifications to be defined. First the size of the cache is defined by specifying how many dimensional records should be held in memory for matching against input records default 15 000 rows . This number will depend on the size of each dimension table. Additionally it must be determined which resources are available on the ingest node for dedication to the enrichment cache. There is a trade off between resources and performance that you should be tested prior to implementation of the platform. Further a load strategy is selected for the enrichment cache to specify how the cache is initialized. Speed of cache startup versus potential cache misses if the cache has not yet reached its maximum size should be considered. Load strategy options include completely filling the cache as soon as the system starts up the ingest node for smaller dimension tables creating the cache only as data comes in e.g. for dimension records that are used infrequently for example customer names for a big box store where customers make purchases infrequently or creating the cache when the system starts up the ingest node by loading dimension records into the cache in the background or on demand when a record needs to be processed.

While performance could decrease if look ups occur too frequently the cache learns as processing continues keeping the most recently used dimension records in memory and dropping the least frequently matched records out of the cache.

Referring to once configuration is complete when the platform ingests data source records the enrichment processor checks input records for matches S against the dimension table records . The enrichment cache can hold dimension records in memory but if no match is made between an incoming record and the cache the enrichment engine does a full look up on the dimension data using the user specified indexes for a particular table. When matching records are found as a result of the comparison S the transaction records are enriched with dimensional data from the dimension table S and the enriched records are stored in one or more platform databases S.

Alternatively when the enrichment engine attempts to match input model records with dimension tables S the system may occasionally locate an unknown record. For example a new customer may not be in the CUSTOMER database yet so when a transaction comes in with a newly created CUSTOMER ID that does not match a key in the CUSTOMER dimension table the system will fail to match the record to the CUSTOMER dimension table. When this occurs the platform needs instructions for handling the unknown record S. These instructions may include one of the following.

The instructions may be to ignore the record i.e. stop processing the record entirely S. The record will not be added to the platform database and the platform will take no further action on the record.

The instructions may be to add the incoming record into the platform database under a new surrogate key S. The natural key and data values identified in the enrichment configuration will be stored in the table. Using the sales transaction example a new transaction record is added to the platform database with a CUSTOMER ID that does not match a record in the CUSTOMER dimension table.

Further still the instructions may be to look up a default row in the dimension table and use it to enrich the record S. Using the sales example if a new customer has not yet been added to a dimension table the CUSTOMER ID column in the sales transaction record may not find a match in the CUSTOMER dimension table. In that the platform is instructed to add a value such as unknown or UNK to the enrichment field of the transaction record and continue processing other records. The output records from S or S are stored in one or more platform databases .

In addition to the dimension table enrichment described above the embodiments also support generalized algorithmic enrichment. Some non exhaustive examples of generalized algorithmic enrichment are discussed herein.

Flag local network which determines if a given IP address is local or private. It sets the isPrivate and isLocal tags to yes or no based on that determination.

IP network with creates the classless inter domain routing CIDR formatted IP notation that corresponds to a given IP address.

Math enrichment which runs a mathematical expression that you create against the data. User specifies the formula with the enrichment parameters. For example user could calculate the time between two date stamps or the distance between two locations.

Postal location which computes the nearest zip code city state or country from a given latitude longitude pair.

Record history which adds an array of records that recently passed through the platform and that match a specified field may use e.g. MongoDB data sink for storing and matching transaction records .

Yet another enrichment may be anonymization of certain data so that the data may pass securely through the public cloud or other public environment and be reverse anonymized at the secure user. For example when dealing with personal health information PHI the confidentiality of such information is critical. Accordingly various fields containing PHI could be searched and replaced with tokens and then reversed tokenized once the data reaches the appropriately secure destination.

Further to configuring the enrichment process flow the destination or output field can be selected to be the input field overwritten with enriched data or a newly created field solely for enrichment data. Further still the enrichment data may be filtered prior to saving. Enrichment data often comes in as multiple fields in an object assigned to a destination output field. However there are times when you don t need to save all the enrichment fields but you just need to keep one column in the output field. For example when you define a postal location enrichment the algorithm converts latitude longitude data and returns three enriched fields city state and zip code. If you want to filter the enrichment record and exclude state and zip code information you could filter the enrichment and just save the city field.

To complete configuration of the processing pipeline and system architecture data sinks and user applications are also identified.

Data sinks are queues servers or databases that receive data from the processing engine and store or process data for future use. For example data stores are used to index data for queries to store historical data or to process data for alerts. Selection of data sinks should be determined in accordance with intended use of received data. Some exemplary data sinks are described herein.

External HBase data sink stores data in an existing Hadoop HBase cluster that is external to and not managed by the platform. For end user organizations already using applications that use HBase platform processed data can be sent to that cluster with this data sink.

External HDFS data sink stores data in an existing Hadoop cluster that is not managed by platform compatible with Cloudera CDH3uX releases . For end user organizations already using Hadoop clusters platform processed data can be sent to that cluster by configuring a communication connection with this data sink.

External Hive data sink is similar to the Hive data sink but stores data in an existing Hadoop Hive cluster that is not managed by the platform. For end user organizations already using Hive clusters platform processed data can be sent to that cluster by configuring a communication connection with this data sink.

HBase data sink stores processed data in an HBase database that is managed internally by the platform. HBase was originally created to handle petabytes of data.

Hive data sink stores processed data in the Hadoop Hive environment and is managed internally by the platform. Hive was originally created to interface SQL databases with Hadoop so organizations that were relational based could continue to work in an SQL like environment while interfacing to Hadoop MapReduce technology. This data sink is used to create a Hive cluster that is managed by the platform.

Lucene indexing data sink is used if end user organization intends to have data searchable with the Search or SearchAPI web applications. The Lucene data sink uses a copy of the processed platform data and builds an inverted index for real time and near real time search.

MongoDB data sink is a general all purpose data sink that stores processed platform data in a MongoDB database which is managed by the platform and can scale automatically.

Alerting data sink filters processed records for alert triggers and sends out alert messages either as email messages or as messages in a JMS topic. The data sink does not store processed records. This data sink is used to implement end user data systems that are configured to identify possible cybersecurity breaches situational anomalies or potential fraud.

A primary reason for doing complex configuration of a platform data model is to make information available to users in real time for analysis. To that end the platform provides several user applications as plug ins hereafter Plug in apps or processed platform records can be fed into particular applications of an organization hereafter User apps for additional reporting and analyses. User apps are configured as specific Web Apps in the platform. Web Apps include two types applications that end users will use to search for and analyze data and REST APIs.

Plug in apps may include Alert Controller to manage alert criteria notifications and subscriptions Alerts API to manage alert criteria used to generate notifications of potential threats or fraud Metrics API to collect statistics on system performance Search for real time and near real time full text queries Search API to build a custom search capability for your system.

To feed platform data into a User app an externally facing data sink such as the Scripting Data Sink or the JMS Data Sink may be configured see above .

As referenced above a particularly useful feature of the platform is the ability to generate real time alerts notifications to users about a potential threat or fraud in progress. The platform can place actionable intelligence in the hands of decision makers within seconds of an anomalous event occurring not days or even hours after the fact. Alerting aids in the detection of fraud and threats and facilitates rapid response to an unfolding situation. There are three phases to configuration and implementation of the platform alerting mechanism. Initially alert criteria are defined to specify business rules to define what a threat would be to the organization. For example a Systems Administrator may want to know when an individual attempts to access a company intranet from an outside IP address. Or a bank may want to know if an employee is frequently servicing transactions on his own account.

Next the platform alert engine analyzes data for potential threats by attempting to match the alert criteria filter rules against processed records.

Finally notifications are sent in real time of a threat in progress. That is if a match is found between a record and the alert filter a notification can be generated and sent to one or more email addresses as text messages to the console or on a JMS queue.

Exemplary scenarios where one or more of the combinations of functionality of the platform described herein may be particularly useful are described below.

The platform may help prevent check fraud. Financial services firms face explosive growth in cyber attacks and bank fraud. For example a large financial institution wants to detect scenarios in which a check cashing transaction occurs in one account at two separate branches simultaneously or in close sequence. This so called branch hopping can indicate potential fraud. In this case the platform provides increased threat awareness by detecting fraud as it occurs and mitigating it through a combination of hardware software and services. The platform provides an immediate return on investment by detecting fraud as it occurs rather than after the fact and attempting to retrieve stolen funds.

The platform may be particularly useful in the healthcare industry. The platform can collect volumes of patient information which is controlled by compliance regulations. The platform can be used for rapid diagnoses when there is a limited amount of time.

The platform may be particularly useful in the telecommunications industry. The platform can protect against customer identity data guard against security hacks and analyze geospatial data for suspicious activity. For example the platform may be used to perform deep analytics of DNS communications to identify complex attack trends and store historical archives of DNS transactions. The system can deliver capabilities such as enrich data flow pipeline store data for archive and a basis for distributed queries process data through analytics algorithms and visualize threat vectors for broader posture of the DNS defense environment.

The platform may be particularly useful in the transportation industry. The platform can take advantage of the geospatial analytics to track vehicles and packages to analyze patterns in pathways and to flag abnormal behavioral states.

The platform may be particularly useful in mining and analyzing for privacy breaches and insightful business intelligence.

The platform may be particularly useful in e commerce applications to safeguard customer records and protect against credit card fraud and hackers.

One skilled in the art recognizes that the examples provided in the present disclosure are not limited as such. There are numerous variations to components and functionality described as part of the overall architecture and processes of the platform that are known and would readily be considered to be within the scope of the invention.

