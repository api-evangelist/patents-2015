---

title: System, method, and computer-readable medium for dynamic device discovery for servers binding to multiple masters
abstract: A system that facilitate broadcast of a device discovery beacon by a dynamic physical device wishing to bind to one or more control systems are provided. If the dynamic physical device comprises a server that is configured to bind to multiple master controllers, the dynamic physical device may include a device Type Flag and set the value of the device Type Flag to indicate the dynamic physical device comprises a server. On detection of the beacon, a master controller evaluates the device Type Flag if it is present in the device discovery beacon. If the device Type Flag is present and indicates the dynamic physical device comprise a server which may bind to multiple master controllers, the master controller may automatically load a device Module for the dynamic physical device and commence communications with the dynamic physical device with no manual intervention.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09432262&OS=09432262&RS=09432262
owner: AMX, LLC
number: 09432262
owner_city: Richardson
owner_country: US
publication_date: 20151013
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 14 611 590 entitled SYSTEM METHOD AND COMPUTER READABLE MEDIUM FOR DYNAMIC DEVICE DISCOVERY FOR SERVERS BINDING TO MULTIPLE MASTERS filed Feb. 2 2015 now issued U.S Pat. No. 9 160 625 issued on Oct. 13 2015 which is a continuation of U.S. patent application Ser. No. 14 162 512 entitled METHOD AND COMPUTER READABLE MEDIUM FOR DYNAMIC DEVICE DISCOVERY FOR SERVERS BINDING TO MULTIPLE MASTERS filed Jan. 23 2014 now issued U.S Pat. No. 8 948 172 issued on Feb. 3 2015 which is a continuation of U.S. patent application Ser. No. 13 487 345 entitled SYSTEM METHOD AND COMPUTER READABLE MEDIUM FOR DYNAMIC DEVICE DISCOVERY FOR SERVERS BINDING TO MULTIPLE MASTERS filed Jun. 4 2012 now issued U.S. Pat. No. 8 644 312 issued on Feb. 4 2014 which is a continuation of U.S. patent application Ser. No. 12 344 732 entitled SYSTEM METHOD AND COMPUTER READABLE MEDIUM FOR DYNAMIC DEVICE DISCOVERY FOR SERVERS BINDING TO MULTIPLE MASTERS filed Mar. 2 2009 now issued U.S. Pat. No. 8 194 660 issued on Jun. 5 2012 which in turn is a continuation in part of patent application Ser. No. 11 636 918 entitled METHOD SYSTEM AND COMPUTER PROGRAM USING STANDARD INTERFACES FOR INDEPENDENT DEVICE CONTROLLERS filed Dec. 11 2006 which is a continuation of patent application Ser. No. 11 222 885 entitled METHOD SYSTEM AND COMPUTER PROGRAM USING STANDARD INTERFACES FOR INDEPENDENT DEVICE CONTROLLERS filed Sep. 9 2005 which claims the benefit of the earlier filing date of U.S. provisional patent application Ser. No. 60 608 439 filed Sep. 9 2004. This application is also related to U.S. provisional patent application Ser. No. 61 017 628 entitled Dynamic Device Discovery for Servers Binding to Multiple Masters filed Dec. 29 2007 and U.S. provisional patent application Ser. No. 61 017 620 entitled Server Enabled Device Description filed Dec. 29 2007 the disclosures of which are incorporated in its entirety herein by reference.

The present invention is generally related to control systems and more particularly to mechanisms for dynamic device discovery for servers binding to multiple master controllers.

Many systems such as control systems monitoring systems and the like collectively referred to herein as control systems exist that allow the discovery of devices in the control system. However contemporary mechanisms utilize discovery protocols that allow a device to bind to only a single master.

Conventional discovery and static binding routines require an administrator to make an explicit manual choice of which master controller a device is bound. Some mechanisms provide an auto bind option that facilitates a master controller to automatically bind to any device which matches a dynamic application device maintained by the master controller. However contemporary auto bind mechanisms may cause catastrophic undefined results when multiple master controllers attempt to bind to the same physical device e.g. physical devices that are not configured to be bound to multiple master controllers. Accordingly static binding mechanisms are preferred in conventional systems when multiple master controllers are listening to the same multicast address for a common device type.

Numerous systems exist such as Remote Monitoring Systems RMSs which include servers that must bind to multiple master controllers. Static binding mechanisms are typically employed if multiple masters monitor a common multicast address to avoid binding of devices to multiple controllers even if servers are deployed that must bind to multiple masters. Consequently an administrator must disadvantageously manually bind the servers to each of the master controllers.

Therefore what is needed is a device discovery mechanism that allows servers to automatically bind to multiple master controllers without collisions thereby overcoming the need to manually bind each master controller.

The present invention provides a system method and computer readable medium for dynamic device discovery and binding of servers to multiple master controllers. A device discovery beacon that includes a device Type Flag may be broadcast by a dynamic physical device. If the dynamic physical device comprises a server that is configured to bind to multiple master controllers the dynamic physical device sets the value of the device Type Flag to indicate the dynamic physical device comprises a server. On detection of the beacon a master controller configured according to disclosed embodiments may evaluate the device Type Flag. Upon determining the device Type Flag indicates the dynamic physical device comprise a server the master controller may load a device Module for the dynamic physical device and commence communications with the dynamic physical device. In this instance the master controller advantageously does not broadcast a binding notification thereby allowing other master controllers to bind with the same dynamic physical device.

In one embodiment of the disclosure a method of binding a system server device to a controller is provided. The method includes receiving by a first master controller a first device discovery beacon from a first system server device evaluating the beacon for inclusion of a device type flag determining the beacon includes the device type flag evaluating a value of the device type flag determining the value indicates the first system server device comprises a server configured to bind to multiple master controllers and loading by the first master controller an instance of a device module associated with the first system server device responsive to determining the value indicates the device comprises a server configured to bind to multiple master controllers.

In a further embodiment of the disclosure a computer readable medium having computer executable instructions for execution by a processing system the computer executable instructions for binding a system server device to a controller is provided. The computer readable medium comprises instructions that when executed cause the processing system to receive by a first master controller a first device discovery beacon from a first system server device evaluate the beacon for inclusion of a device type flag determine the beacon includes the device type flag evaluate a value of the device type flag determine the value indicates the system server device comprises a server configured to bind to multiple master controllers load by the first master controller an instance of a device module associated with the first system server device responsive to determining the value indicates the device comprises a server configured to bind to multiple master controllers and commence communication and control of the first system server device by the first master controller responsive to loading the instance of the device module.

In a further embodiment of the disclosure a system for binding a control system device to a controller is provided. The system comprises a first dynamic physical device comprising a server configured to bind to multiple master controllers a first master controller communicatively coupled with the first dynamic physical device and having a first instance of a dynamic application device corresponding to the first dynamic physical device and a second master controller communicatively coupled with the first dynamic physical device and having a second instance of the dynamic application device corresponding to the first dynamic physical device. The first dynamic physical device broadcasts a first device discovery beacon including a device type flag having a value that indicates the first dynamic physical device comprises a server. The first master controller and the second master controller receive the first device discovery beacon and respectively evaluate the device type flag value. The first master controller loads a first instance of a device module associated with the first dynamic physical device responsive to determining the value indicates the first dynamic physical device comprises a server and the second master controller loads a second instance of the device module responsive to determining the value indicates the first dynamic physical device comprises a server.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of various embodiments. Specific examples of components and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

Referring to a simplified top level block diagram of a control system configuration according to an embodiment of the present invention is shown. One or more devices in the control system can send control commands to and or receive control messages from a master controller on one or more control area networks and . The present invention includes common application programming interfaces APIs that are used to represent the one or more devices . The one or more devices may be wholly unrelated in technology. Therefore the common APIs represent the one or more devices by defining a structure whereby different device technologies are grouped together into classes by common operation and or functionality from the general to the specific. Thus different classes are used to represent different groups and subgroups of technology for the one or more devices . For instance a class may represent all home entertainment devices such as VCR television CD and DVD. Another class may represent specifically all brands of VCRs and another class may represent a particular brand vendor of the VCR. The present invention recognizes that even devices that are wholly unrelated in technology may share common functionality. For instance a DVD TIVO VCR LD and Cassette Deck each share the functional ability of playing some form of media. Thus common APIs are used to abstract the operational and or functional capabilities of the one or more devices such that applications may communicate with the one or more devices without concern for the underlying technology and or proprietary protocols of the devices.

Control system includes one or more control area networks CAN and . Control area networks and are local area networks used to interconnect a variety of devices user interface device and master controller . Optionally the control area network may be used to interconnect other networks and such as a proprietary network local area network an Intranet or the Internet. Control area networks and may be used to interconnect multiple disparate protocols. For instance a Microsoft UPnP Universal Plug and Play network may be interconnected to a Sun Microsystems JINI network via control area networks and . Devices include but are not limited to physical and logical devices equipment and appliances. The underlying network may be wired wireless power line carriers or any suitable transmission medium. Some devices may be coupled to control area networks and via additional intermediate communications devices such as an RS 232 controller not shown .

User interface device is any device that is capable of receiving user input and displaying or indicating control network status. For example a touch panel a computer terminal with a monitor keyboard and pointing device and any device with similar functionalities may serve as user interface device . In addition a user interface is any device that is capable of receiving user input such as a simple push button keypad which may not have indicators for feedback or an Infra red remote control.

Master controller generally includes a CPU based controller that controls the communications among user interface device and devices . It is operable to receive user inputs received by user interface devices such as commands and instruct the appropriate device to act according to the command. Master controller may also poll each device in control area network periodically to monitor its status. The system status and or the status of each device may be sent to user interface device for display. The devices user interface devices and master controllers may also be configured to handle dynamic device discovery within control system .

Devices are configured to receive commands from master controller and operate or act according to the command. Devices may include equipment that affect or monitor the various parameters of the premises. For example devices may include heating and air conditioning lighting video equipment audio equipment sprinklers security cameras infrared sensors smoke detectors or other similar device in a residential or commercial control area network . Devices may also be household appliances such as a hot tub fireplace microwave oven coffee maker or other similar device that are capable of providing a current status of its operational state to master controller such as on off temperature settings current ambient temperature light intensity settings volume settings threshold settings and predetermined alphanumeric strings reflective of operational states. Further devices may represent a logical device such as another control system or a virtual device. In one embodiment a virtual device may be configured to represent multiple physical devices.

Referring to a block diagram illustrating the components of a master controller according to an embodiment of the present invention is shown. Master controller includes but is not limited to device control firmware a NetLinx interpreter executing a NetLinx program memory area one or more control ports and a Java virtual machine . One or more devices and user interface device are connected to master controller via control ports or other input means not shown . Memory Area includes a NetLinx program that is executed as NetLinx program by NetLinx interpreter and one or more Java libraries and that are used by the Java virtual machine . The one or more Java libraries and may be dynamically loaded and or updated with new methods while the Java virtual machine is executing. The Java libraries and may be either a standard Java Archive JAR file or an Open Service Gateway Initiative OSGi bundle. An OSGi bundle is a JAR .jar file with a manifest file .mf listing the services that are exported by the bundle via a package name as well as any service that the bundle itself requires for execution. Within the OSGi framework every bundle has a pre defined lifecycle.

Referring to a block diagram illustrating a standard interface device controller configuration according to an embodiment of the present invention is shown. The Java virtual machine includes a firmware event module a router referred to as a SNAPI object DUET object and optionally one or more other Java objects . In one embodiment the DUET object is dynamically loaded and or updated from one or more Java libraries and . In this case the one or more Java libraries and are referred to as DUET modules since they represent the uninstantiated DUET objects .

Generally the DUET object provides services to translate between a set of device specific API calls and a device s proprietary protocol thereby hiding the proprietary protocol from the service user. For example a DUET object that is communicating with a VCR that uses a proprietary serial protocol might provide PLAY STOP PAUSE FFW and REWIND services via the DUET API . The DUET object generates the necessary serial protocol data and communicates with the VCR. Any object having access to the DUET object could invoke a DUET API method to affect change on the physical VCR with no knowledge of the underlying protocol.

The DUET object contains a majority of the translation between a standard API and the proprietary protocol of the one or more devices . For instance the DUET object contains a majority of the translation between the standard API and the proprietary protocol for a manufacturer s brand of a particular physical device. The DUET object may include one or more NetLinx device class objects each having a NetLinx API and a standard DUET API grouped into device categories. The DUET API device categories include but are not limited to a switcher an A V receiver a plasma monitor a video projector a television a digital satellite system DSS a set top box a disk device a DVR PVR a digital media player a VCR a video conferencer an audio conferencer an audio tuner a cassette deck a level controller a pre amplifier a audio processor a camera a document camera a slide projector lights an HVAC a security system a weather device a pool or spa and a lift screen shade window door. Each DUET API device category includes a standard API that is specific to that device category. For instance the DUET API may include play stop pause fw and rewind methods that correspond to VCR devices.

The DUET object communicates with the SNAPI object the FW event module and optionally one or more other Java objects . The DUET object implements a standard DUET API . The SNAPI object communicates with the DUET object by invoking methods specific to device categories in the standard DUET API of the DUET object . One or more NetLinx device class objects will then execute the necessary device specific processing for a specific task. The NetLinx device class encapsulates the communication protocols necessary to communicate with a specific device or equipment controlling device e.g. a single DPS device port system . The NetLinx device class API includes but is not limited to on off send level and send string methods. For example a play method on an IR controlled VCR would request the underlying physical device IR emitter to send IR pulses to a VCR thereby resulting in a play operation on the VCR. However not all DUET objects will have a NetLinx device class . Access to one or more devices may also be through some other Java enabled transport e.g. TCP IP sockets instead of a NetLinx device class .

The one or more devices indirectly communicate with the DUET object using event handlers. In particular the one or more devices communicate with the device control firmware the device control firmware routes any communication to the FW event module and the FW event module posts events to pass this communication to a NetLinx device class of the DUET object . The DUET NetLinx device class includes but is not limited to a IChannelListener interface a IButtonListener interface a ILevelListener interface a IDataListener interface and a ICustomListener interface each having one or more corresponding event handler methods to catch the event posted by the FW event module . The IButtonListener handles button push and release events. The IChannelListener handles channel on and off events. The ILevelListener handles level events. The IDataListener handles string command online and offline events. The ICustomListener is a catch all for all other types of events. A DUET NetLinx device class only implements those interfaces that it needs. The DUET object processes device events by translating proprietary event data into a status object that is understood by the SNAPI object along with any other entity such as other Java objects listening for events from one or more devices . Entities that wish to receive device events register as a listener with the DUET object . When an event occurs the event data is packaged into a status object and a predefined handler routine is called for each of the registered listeners.

A DUET object does not necessarily have its own processing thread. For instance a DUET object utilizing a NetLinx device class object as its connect to one or more devices will most likely not have its own thread. Instead its receive thread is provided by an underlying event router thread that is receiving data from the firmware event module . Whereas a DUET object that communicates with one or more devices via a TCP IP socket must provide a separate thread of execution as a listener to the TCP IP socket.

A SNAPI object is the inverse of a DUET object . The SNAPI object processes data coming into the JVM in a proprietary format and translates it into calls made into a DUET object . The SNAPI object is configured to indirectly communicate with a NetLinx program . The SNAPI object may include one or more NetLinx device class objects each having a NetLinx API and a standard DUET feedback API . The SNAPI object communicates with both the DUET object and the FW event module . The NetLinx program indirectly communicates with the SNAPI object using event handlers. In particular the NetLinx program communicates with the device control firmware the device control firmware routes any communication to the FW event module and the FW event module posts events to pass this communication to a NetLinx device class of the SNAPI object . Similar to the DUET NetLinx device class the SNAPI NetLinx device class includes but is not limited to a IChannelListener interface a IButtonListener interface a ILevelListener interface a IDataListener interface and a ICustomListener interface each having one or more corresponding event handler methods to catch the event thrown by the FW event module .

Optionally a DUET object may expose multiple DUET APIs in order to represent a device having combination functionality. For example if a DUET object controls a combination VCR DVD player device the DUET object could expose a VCR DUET API and a DVD DUET API . Thereby Java objects would have access to the VCR functionality of the combination VCR DVD player device by invoking methods in the VCR DUET API and access to the DVD functionality of the combination VCR DVD player device through the DVD DUET API .

Optionally a single DUET object may also serve as a controller for multiple physical devices thereby creating a new abstract device. For example a DUET object could represent a matrix or library of VCR devices by having multiple NetLinx device class objects each controlling a different physical VCR device 

Referring to a block diagram illustrating another standard interface device controller configuration according to an embodiment of the present invention is shown. In this embodiment one or more of the other Java objects is a router object that may include a NetLinx device class having a NetLinx API . The router object has similar functionality as the SNAPI object previously described but is configured to communicate directly with Java programs using Java methods.

As shown in multiple Java objects or may communicate with a single DUET object and its associated one or more devices by invoking methods in the standard DUET API of the DUET object . For example a Java object that controls a touchpanel and a Java object that controls a keypad may both communicate with a particular VCR device which is controlled through a single DUET object . In this instance both Java objects and could invoke DUET API method s to affect changes on the physical VCR device . Similarly both Java objects and would be notified of changes on the VCR device through their respective DUET feedback APIs .

The configuration as shown in may be used to communicate with a NetLinx program whereas the configuration as shown in may be used to communicate with existing and future generations of Java enabled devices. Optionally the configurations shown as in may co exist simultaneously in the same control system such that Java programs and NetLinx programs may co exist within the same control system .

Referring to a flow chart illustrating command processing using a standard interface device controller according to an embodiment of the present invention is shown. As shown at block data is generated from a user interface device that will be communicated to one or more devices . Data may be generated from the user interface device by the user entering an alphanumeric string clicking on a button icon on a graphical user interface pushing a button on a touch panel or other suitable input. The user interface device then forms a control system message including but not limited to a channel associated with the data and or the sender of the message as shown at block . Each of the one or more devices both sender and recipient devices are uniquely identified by a DPS device port system value. A channel is a number uniquely identifying each addressable operation component or graphical element of each device and . For instance each button icon on a graphical user interface of the user interface device is assigned a unique channel number. Further the play stop and rewind operation on a VCR device are each assigned unique channel numbers. The message is then sent onto the control area network as shown at block . As shown at block the master controller on that network receives the message via one or more control ports . Control ports include but are not limited to Infrared IR ports serial ports relays and digital I O.

A channel state associated with the origin of the data e.g. a particular button pressed on user interface device is turned ON by the device control FW to indicate that the channel is on as shown at block . A message incorporating the channel number and the sender of the message is then sent to a NetLinx program executed by a NetLinx interpreter as shown at block . As shown at block the NetLinx program determines the appropriate action based on the channel number. Based on that action the NetLinx program forms a message including the appropriate recipient and a channel number uniquely identifying an operation on the recipient device . The message is sent via device control firmware to FW event module within the Java virtual machine as shown at block . As shown at block based on the recipient and channel number an appropriate event handler method is invoked within a NetLinx device class of the SNAPI object . The event handler method invokes one or more DUET APIs having standard API methods that correspond to one or more operations on the recipient device as shown at block . An appropriate method within a DUET NetLinx device class is then invoked by the DUET API as shown at block . The DUET NetLinx device class method then communicates the requested operation to the recipient device using the recipient s device protocol as shown at block . As shown at block the requested operation is thereby performed on the recipient device 

Depending on the recipient device and the requested operation the recipient device may or may not send a response message onto control area network . If the recipient device does send a response message then the response message is sent onto the control area network as shown at block . As shown at block the master controller on that network receives the message via one or more control ports and then processes the message. A channel associated with the operation on the device is turned ON by the device control FW as shown at block . A message incorporating the channel number and the sender of the message is then sent via device control firmware to FW event module within the Java virtual machine as shown at block .

As shown at block based on the sender and channel number an appropriate event handler method is invoked within a NetLinx device class of the DUET object . The event handler method invokes one or more DUET feedback API standard API methods that correspond to one or more operations in the SNAPI router as shown at block . An appropriate method within the SNAPI NetLinx device class is then invoked by the DUET API as shown at block . As shown at block the SNAPI NetLinx device class method then determines the appropriate recipient based on the channel number and forms a message including the appropriate recipient and a channel number uniquely identifying a SNAPI router notification . The message is sent via device control firmware to the NetLinx program and executed by a NetLinx interpreter as shown at block .

As shown at block the NetLinx program determines the appropriate action based on the channel number. Based on that action NetLinx program forms a message including the appropriate recipient and a channel number uniquely identifying a component on user interface . The message is sent via device control firmware to user interface device as shown at block . A channel associated with the origin of the data e.g. a particular button pressed on user interface device is updated by the device control FW as shown at block . The ON state of the channel of the origin of the data e.g. a particular button pressed on user interface device is conveyed to the user interface device such that the user interface device may provide feedback to the user. For instance highlighting a particular button as shown at block .

For example referring to as shown at block a user may have selected a play button on a touch panel of a user interface device that corresponds to a particular VCR . Assuming that the play button is identified as channel 40 and the user interface device is identified as sender 128 1 1 a message will be formed containing at least the sender channel pair e.g. the message contains 128 1 1 and 40 . The user interface device may send the message to the master controller via a serial control port on the master controller . A channel state e.g. 40 associated with the play button on user interface device is turned ON by the master controller to indicate that the channel is on as shown at block . A message incorporating the channel number the sender of the message and the recipient of the message is then sent to a NetLinx program executed by a NetLinx interpreter as shown at block .

As shown at block the NetLinx program determines the particular VCR device based on the channel number of the play button of the user interface and forms a message including the VCR and a channel number uniquely identifying an operation on the VCR . Assuming that the play operation on the VCR is identified as channel 60 and the SNAPI NetLinx device class representing VCR is identified as recipient 4000 1 1 a message will be formed containing at least the recipient channel pair e.g. the message contains 4000 1 1 and 60 .

The message is sent via device control firmware to FW event module within the Java virtual machine as shown at block . As shown at block based on the recipient and channel number a channel event handler method is invoked within a NetLinx device class of the SNAPI object . The event handler method invokes the play method of the DUET API standard API that correspond to the play operation on the VCR as shown at block . The sendString method within the DUET NetLinx device class is then invoked by the DUET API as shown at block . The DUET NetLinx device class method then communicates the requested operation to the VCR using the VCR s proprietary protocol as shown at block . As shown at block the play operation is thereby performed on the VCR

Referring to a block diagram illustrating a control system configuration interconnecting two disparate protocols according to an embodiment of the present invention is shown. In this configuration one or more devices in a UPnP network communicate with a UPnP router having similar functionality as the SNAPI object previously described. Further one or more devices in a JINI network communicate with a JINI router also having similar functionality as the SNAPI object previously described. Devices on the UPnP network are interconnected to devices on the JINI network via DUET object . Additionally devices such as VCR on a control area network may communicate with one or more devices on either the UPnP network or the JINI network

According to the present invention one or more devices user interface devices and or master controllers may be configured to handle dynamic device discovery within control system . The present invention provides for one or more devices to be dynamically added updated or removed within control system prior to or during its operation. As an example a developer using the present invention may write or utilize generic code to control any brand of VCR. Although the underlying control mechanisms for the different types and brands of VCRs may be fundamentally different the functionality e.g. play stop pause is generally common between VCRs. Thus the actual underlying control mechanisms for the physical device may be abstracted functionally through the use of the generic code. According to one embodiment of the present invention a physical device is associated with an application device. The underlying application device is dynamically associated upon the detection of a new physical device based on the characteristics of that device. This association may be accomplished without underlying changes to the generic code. The generic code is also referred to as the glue code. In another embodiment application device is dynamically associated a virtual device which represents one or more physical devices 

Referring to a control program development application provides user interfaces for the development of a control program. In one embodiment the control program is a NetLinx program. Within the NetLinx program the user defines invocations to the Load Duet Module method. The method parameters include an application device identifier a physical device identifier and a list of properties name value pairs . The control program utilizes an application device to direct all control requests for a device . The physical device identifier is used by DUET Object to create NetLinx device class objects to communicate with device . The list of properties name value pairs describe the module to be loaded. These properties include but are not limited to Device Make Device Model Device SDKClass and Device Revision. The control program development application may transfer NetLinx program to master controller . The control program development application may also transfer any corresponding DUET and SNAPI modules to one or more Java libraries and . In one embodiment such transfers are stored on a flash disk of master controller .

During run time execution of master controller NetLinx interpreter invokes one or more Load Duet Module methods within NetLinx program using Java native interface JNI within device access . Device Access searches one or more Java libraries and for an OSGi bundle which best matches the properties supplied as a parameter to the Load Duet Module method. If a match is found device access instantiates the corresponding DUET object and SNAPI object using the matching OSGi bundle. The DUET object then creates NetLinx device class object based on the physical device identifier supplied as a parameter to the Load Duet Module method. The NetLinx device class object communicates via communication paths and as shown in with physical device using an appropriate protocol for that device. The SNAPI object creates one or more NetLinx device class objects based on the virtual device identifier supplied as a parameter to the Load Duet Module method. NetLinx device class object communicates via communication paths and as shown in with the NetLinx Interpreter running NetLinx program

Referring to a block diagram illustrating the components of a dynamic device detection application according to an embodiment of the present invention is shown. As previously mentioned control program development application provides user interfaces for the development of a control program. In one embodiment within a NetLinx program the user defines invocations to the Dynamic Polled Port method to specify one or more serial ports to be polled for dynamic serial devices . The user may also define invocations to the Dynamic Application Device method to specify any device interfaces to be used within the control application for each application interface. For serial devices in which the user knows what serial port on master controller the serial device will be connected to the user can define an invocation to the Static Port Binding method to specify binding an application device to the physical device via the specified serial port. The control program development application may transfer NetLinx program to master controller . In one embodiment NetLinx program is stored on a flash disk of master controller .

During run time execution of master controller NetLinx interpreter invokes one or more Dynamic Polled Port methods within NetLinx program using JNI within dynamic device detection application . This results in the serial port being added to polled serial devices database . NetLinx Interpreter invokes one or more Dynamic Application Device methods within NetLinx program using JNI within device access . This results in the creation of one or more dynamic application device objects which are then added to application device database . The dynamic application device objects may include the parameter information provided as a parameter to the Dynamic Application Device method. NetLinx Interpreter invokes one or more Static Port Binding methods within NetLinx program using JNI within device access . This results in the creation of a dynamic application device object which is added to application device database . A corresponding shell dynamic physical device is also added to device database . The shell dynamic physical device includes the physical device identifier provided as a parameter to the Static Port Binding method and acts as a placeholder for the binding.

Serial device detector may be configured to periodically loop through polled serial device database transmit a poll request to the polled serial devices and to listen for poll responses. IP device detector may similarly be configured to listen for IP devices discovered on IP sockets. In one embodiment this is accomplished using a Multicast UDP address.

Binding Application provides user interfaces for managing bindings between dynamic application devices and physical devices . Binding application may be configured to request that dynamic device detection application retrieve information from application device database and device database .

Binding registry is a persistent disk storage of the current binding information. In one embodiment the binding registry contains which dynamic application devices that are bound to dynamic physical devices. Thereby upon the reboot of master controller the binding settings provided by the user through the binding application will not be lost.

Transfer application provides an interface for users to upload DUET modules onto master controller delete modules from master controller and to retrieve existing modules from master controller. An unbound portion of the Java Libraries may be used to prevent conflicts with any running bound DUET modules and their associated DUET objects .

When a physical device is discovered by the dynamic device detection application its beacon information along with the physical device discovery location e.g. the IP address or the serial port are used to add the dynamic physical device to device database . Based on the current binding settings dynamic device detection application determines whether a DUET Object should be instantiated.

When dynamic device detection application determines that a DUET object should be instantiated either by user interaction from binding application or by discovery of a new dynamic physical device having a pre existing binding provided by binding registry the information contained within the bound dynamic application device and dynamic physical device are used to invoke methods within the device access object to create a DUET Object and its associated SNAPI object . If a pre existing DUET module was destroyed then a method is invoked within device access to destroy the existing the DUET object and its associated SNAPI object .

Upon the request to create a DUET Object from dynamic device detection application device access searches one or more Java libraries and for an appropriate DUET module which best matches the properties originating from the dynamic application device and dynamic physical device objects. If a matching DUET module is found device access instantiates a corresponding DUET object based on the DUET module. Device Access may omit the search step if the user has specified a specific DUET module to be used via the binding application. In this case the search process is ignored and device access instantiates a DUET object based on the specified DUET module.

Referring to a flow chart illustrating dynamic device processing according to one possible embodiment of the present invention is shown. As shown at block dynamic device detection occurs within control system . Device detection is discussed in detail with respect to below. As generally shown at blocks upon detection of a new device within control system an application device is associated with device 

The information contained in an application device is used to instantiate a SNAPI object . All control requests are then made to the SNAPI object rather than the physical device . A DUET module is used to instantiate a DUET object which provides services to translate between a set of device specific API calls and the proprietary protocol of the device thereby hiding the proprietary protocol from the user.

DUET object represents the detected device . Optionally the application device and DUET module may be used to instantiate SNAPI object and DUET object after the application device is associated. Associating an application device with a physical device is also known as binding. As shown at blocks and the newly detected device may either be manually or automatically bound.

SNAPI objects are used as control interfaces for devices . Control requests for devices are processed by its corresponding SNAPI objects . Thereby a device e.g. the physical device is abstracted by its corresponding SNAPI objects . Any technique may be used to dynamically associate application device with new devices . According to the present invention binding may include but is not limited to static binding and run time binding. Static binding is known as program defined binding and dynamic binding is known as run time defined binding. The control program may be any program capable of controlling the new device in a dynamic device environment. According to the present invention the control program for a new device may include but is not limited to a DUET module.

Under static binding the port e.g. a serial or IR port to be used for device is predefined. The device actually to be connected to that port is not required to be specified. Instead the device on that port is dynamically detected at run time and then bound to the appropriate application device. Static binding may be used to hardcode the port to be used for a device without having to specify the actual manufacturer or brand of the device.

Under dynamic binding an application device and its associated classes are predefined. The port that the device is bound to is not required to be specified. Instead new devices are bound to the appropriate application devices at run time. Devices may be bound either manually or automatically as they are detected on the control system . Any user interface may be used to manually bind an application device with a new device . In one embodiment binding is manually specified using a web browser in communication with a web server application hosted on master controller as generally shown in . Manual binding may be used in addition to automated binding. For instance manual binding may be used to modify a device that was automatically bound upon detection. Additionally some devices may be automatically bound while other devices may be manually bound. For certain devices dynamic binding may be preferable over manual binding. For instance dynamic binding is the preferred binding option for IP devices due to the dynamic nature of their IP addresses.

Numerous methods of detection may be used to detect devices that are added to control system . According to the present invention the methods of detection include but are not limited to dynamic device discovery protocol DDDP and user defined methods. A user defined method may be defined by a user using any means including the use of a user interface. Any user interface may be used to manually define a method of detection. In one embodiment a method of detection is manually specified using a web browser in communication with a web server application e.g. a Java servlet hosted on master controller as generally shown in . According to the present invention new device detection may use but is not limited to an external discovery protocol manager e.g. UPNP a multicast reception of a dynamic device beacon or receipt of a beacon response on an application specified list of serial devices.

Any communication protocol or interface may be used within the scope of the present invention for device detection. In one embodiment dynamic physical devices are detected over serial interfaces and IP interfaces using DDDP. Dynamic device detection over IP interfaces may be configured to utilize the network s higher layers of multicast to broadcast the existence of a new device . Serial devices may be configured to utilize DDDP or any other protocol such as fixed protocol that may be incompatible with DDDP. Dynamic device detection over serial interfaces may utilize periodic polling of devices. In response to a poll request devices may be configured to broadcast their existence upon their addition to control system . According to the present invention the interfaces or ports e.g. a NetLinx interface or a serial port to be polled may be predefined or variable.

An application device may be associated with a particular device type using various techniques. In one possible embodiment each device type corresponds to a Java interface within a DUET device software development kit SDK . A user specifies the device type of a particular application device by providing a particular SDK class name.

According to the present invention dynamic IP device detection may utilize sockets for communication between devices and master controllers . In one possible embodiment a multicast UDP socket having a predefined multicast group and port e.g. port 9131 is utilized. A listener is used to listen for dynamic device beacons that are sent by devices and dynamic device bindings that are sent by master controller to notify other masters controllers in a control area network of the ownership of a dynamic device that has previously entered the system. Upon the dynamic binding of device to an application device a dynamic device binding is transmitted on the multicast group to notify all other master controllers in control system that the device has been bound. Conversely when device is unbound a notification is transmitted on the multicast group to notify all other master controllers in control system that the device has been unbound.

Referring to a flow chart illustrating dynamic IP device processing according to one possible embodiment of the present invention is shown. As shown at block a dynamic device beacon datagram packet is received. According to the present invention devices are configured to transmit one or more device beacon messages. Transmission of device beacon message may be configured to occur without limitation i when the device initially starts up such as when the device is initially booted or rebooted ii upon a determination that the device connection has been lost such as upon the reboot of the master control the device being unbound or a network communication failure iii at periodic predefined or variable intervals or iv by any other reasonable means. The device beacon message may include but is not limited to i information that is useful to connect the device such as the dynamic or static IP address and the port ii a universal unique identifier for the device UUID and or iii information specific to the type of device. The device UUID is a unique identifier to distinguish one device from every other device. In one embodiment the UUID for IP devices is the MAC ID and the UUID for serial devices is uniquely assigned by the manufacturer of the device. If a UUID is not supplied by the manufacturer of a serial device then the physical NetLinx device address of the associated serial port to which the device is connected may be used as the UUID e.g. 5001 1 0 . Information specific to the type of device includes but is not limited to the SDK interface class name the DUET module match criteria and or the make model and revision number of the device 

As shown at block a search is performed for the new device within device database . The new device is compared against the existing entries in device database at block . As shown at block the new device identifier and the IP address of the new device may not exist in device database . For instance when a new device is added to a control area network for the first time an entry will not exist in device database . If this occurs the device is added to device database as an unbound device.

As shown at blocks and the new device identifier may not exist in device database but another device may already exist with the new device s IP address. For instance restarting the DHCP server may result in a previously assigned IP address being reassigned to another device. Use of static IP addresses may similarly result in an IP address conflict. If this occurs the device entry is removed and the new device is added to device database . Additionally if the conflicting device was bound the DUET objects and SNAPI objects corresponding to the conflicting device are destroyed.

As shown at blocks and the new device identifier and the IP address of the new device may exist in device database . If the device information in device database does not match then the device information is updated in device database . For instance an update to the firmware of the new device may result in its device information having a new revision number. In this situation the new device information is updated in device database and DUET object and SNAPI object are instantiated.

As shown in block it is possible that the new device is bound and no DUET objects and SNAPI objects have been created for the new device. In one embodiment at startup DUET objects and SNAPI objects are not automatically instantiated for bound IP devices. Instead it is assumed that a device beacon message will be received from the new device to initiate the creation of DUET objects and SNAPI objects corresponding to the new device. For instance when a master controller is rebooted it may take several minutes for the new device to timeout on its socket connection. When a device beacon message is received by the master controller a DUET object and SNAPI object are created for the new device. If the new device is bound and DUET objects and SNAPI objects already exist for the new device then it is assumed that the DUET object will re connect to device if it looses a connection.

As shown at blocks and the new device identifier may exist in device database but the new device s IP address does not match the device database entry. For instance restarting the DHCP server may cause the new device to be reassigned a new IP address. The new IP address is updated in device database if it does not conflict with any other entry.

Embodiments of the present invention may include but art not limited to i updating existing device database entries based on the device beacon message content to dynamically update the IP address and other device information ii preventing IP address conflicts by destroying old device information when a new device beacon message is received that matches an existing IP address and iii preventing thrashing of DUET module loads and unloads where two or more devices have conflicting IP addresses.

Referring to a flow chart illustrating dynamic serial device processing according to one possible embodiment of the present invention is shown. Serial ports are polled for new serial device connections which upon reply are added to device database . The present invention may be configured to poll all serial ports in control area network or a subset thereof. In one embodiment the serial ports to be polled are defined using a NetLinx language subroutine DYNAMIC POLLED PORT DEV netlinxDevice . A SerialDevice object is then created for each device that is defined by the NetLinx language subroutine. The default communication settings for each serial port is predefined as 9600 baud 8 bits no parity and 1 stop bit. However other possible communication settings are possible within the scope of the present invention.

As shown at block serial devices are periodically polled for any new devices by transmitting a poll message over the corresponding serial ports. The period between such polling may be predefined. New devices respond by sending a new device beacon message which is received by master controller as shown at block . The device beacon message contains device specific information such as the device ID and other information relating to the device s DUET module e.g. SDK class and match criteria . As shown at block device database is then searched for the new device. The new device is compared against the existing entries in device database at block . As shown at block the new device identifier and the serial port of the new device may not exist in device database . For instance when a new serial device is added to a control area network for the first time an entry will not exist in device database . If this occurs the device is added to device database as an unbound device.

As shown at blocks and the new device identifier may already exist in device database for another device. If this occurs the device entry is removed and the new device is added to device database . Additionally if the conflicting device was bound the DUET objects and SNAPI objects associated with the conflicting device are destroyed.

As shown at blocks and the new device identifier and serial port of the new device may exist in device database . If the device information in device database does not match then the device information is updated in device database . For instance an update to the firmware of the new device may result in its device information having a new revision number. In this situation the new device information is updated in device database and DUET object and SNAPI object are created from an appropriate DUET module.

As shown in block it is possible that the new device is bound and a corresponding DUET object and SNAPI object have not been instantiated for the new device. If the new device is bound and DUET object and SNAPI object already exist for the new device then it is assumed that DUET object will re connect to a device if it looses a connection.

As shown at blocks and the new device identifier may exist in device database but the new device s serial port does not match the device database entry. If this occurs the new serial port is updated in device database .

The present invention provides APIs to access both the runtime application device and device database as well as binding information. These APIs may be used by a binding application. In one embodiment the binding application is a Java servlet. The APIs include but are not limited to retrieving application device information including the current binding state and if a DUET object and SNAPI object are instantiated for the binding retrieving the list of devices that are not yet bound to application devices i.e. orphaned devices binding an application device to a physical device and unbinding an application device from its physical device.

Referring to an exemplary user interface and computer program for managing dynamic devices is shown. As shown in the Manage Other Devices user interface may be used by a user to manually manage devices in control area network . The Manage Other Devices user interface is displayed by selecting button .

Enable Auto Bind checkbox allows a user to specify whether new devices will be automatically bound. When auto binding is enabled master controller will automatically attempt to connect newly discovered physical devices with associated application devices. In one non limiting embodiment a newly discovered device and a single entry in application device database is bound where there is a one to one correlation therebetween. For example if the application has only one VCR defined and a VCR is detected in the system auto bind will automatically bind the VCR device to the VCR application device. When Enable Auto Bind checkbox is not selected no auto bind activity will take place and the binding of newly discovered devices may be manually configured. Enable Subnet Match checkbox allows a user to specify whether IP devices should only be detected or discovered if they are on the same IP subnet as the master controller . Purge Bound Modules on Reset checkbox allows a user to specify whether all modules should be deleted from the bound directory upon the next reboot. During the binding process the associated DUET modules for a device are copied from the unbound directory into a protected bound area. Due to the dynamic nature of Java class loading it is not safe to delete a running jar file. Purge Bound Modules on Reset checkbox is provided to allow a user with the capability to remove existing modules upon reboot thereby forcing a re acquisition of the module at bind time. Optionally upon reboot the Purge Bound Modules on Reset checkbox selection will be cleared. The Save Settings button allows a user to save the current selected checkbox values to master controller .

Textarea displays the DUET modules currently loaded on master controller . The Manage Other Devices user interface may be used to delete add and retrieve DUET modules. For instance buttons and may be selected to add and delete DUET modules respectively.

As shown in the Manage Device Bindings user interface may be used by a user to configure application defined SNAPI objects with discovered devices in control area network . The Manage Device Bindings user interface is displayed by selecting button . A list of all application defined devices including the defined Friendly Name the DUET virtual DPS device port system and the associated DUET Device SDK class indicating the type of the device.

Application devices include but are not limited to static application devices and dynamic application devices. Static application devices specify an application device and its associated Device SDK class type as well as a NetLinx physical device port that the application device is associated with i.e. statically bound . Dynamic application devices simply specify the application device and its associated Device SDK with no association to a physical port. Binding of an application device to a physical device port will occur at run time either via auto bind or manual binding. Application devices that have a bound physical device will display the physical device ID in the Physical Device column of table . If a corresponding DUET object has been instantiated to communicate with the device property information of device will be displayed in a mouse over dialog when the cursor hovers over the physical device ID.

The entries in table may have a button associated with it. Static application devices may have an associated Release button . Dynamic application devices may have an associated Bind button or Unbind button not shown . A static application device that has not detected a physical device attached to the predefined port will not have a button associated with its entry. If a physical device has been detected and the SNAPI object and DUET object have been instantiated then Release button is displayed. Upon selection of Release button the corresponding SNAPI object and DUET object are destroyed and the firmware will return to detecting physical devices attached to the port.

Dynamic application devices that have been bound will display an Unbind button not shown . Upon selection of the Unbind button any corresponding SNAPI object and DUET object will be destroyed and the association between the application device and the physical device is removed. Dynamic application devices that have not been bound to a physical device will display Bind button . Upon selection of Bind button a second level Manage Device Bindings user interface is displayed as shown in . The second level Manage Device Bindings user interface displays the available unbound physical devices that match the application device s Device SDK class type.

A user may select one of the available physical devices shown in user interface to bind with an application device. Upon selection of Save button a binding is created and the master controller locates the appropriate DUET module driver. Once a driver is found the DUET module is used to instantiate DUET object and the physical device is associated with the specified application device. Upon selection of Cancel button the binding activity will be aborted. A mouse over dialog is provided to display the properties in popup dialog that are associated with a discovered physical device.

As shown in the User Defined Device user interface may be used by a user to provide dynamic device support for devices that do not natively support dynamic device processing. The User Defined Device user interface is displayed by selecting button . Devices may be added or removed. Devices that have been previously defined are shown in area and may be removed by selecting button . Area includes dynamic device properties as defined in the table below.

Upon selection of Add button the user defined device is added to physical device database and is displayed in area . Upon selection of Cancel button the creation of a user defined device is aborted.

As shown in the View Discovered Devices user interface may be used by a user to display all of the dynamic devices that have been discovered in the control system . The View Discovered Devices user interface is displayed by selecting button . A mouse over display area displays properties associated with a device . If the device is bound to an application device the associated application device s friendly name will be displayed under the Binding column of table . The Module Available column of table indicates if a DUET module is available on the system for the physical device.

For each device Search button is provided to initiate a search for compatible modules. Optionally if Module Search via Internet button has been previously selected the search will include querying an online database e.g. an AMX online database for a compatible module based on the device s properties. If the device specified a URL in its dynamic device discovery beacon a file will be retrieved from the URL either over the Internet or from the physical device itself provided the device has an onboard HTTP or FTP server. If Module Search via Internet button has not previously been selected then modules will be retrieved from the manufacturer s device. Modules that are retrieved from the Internet or from the manufacturer s device will be placed into an unbound directory and will automatically overwrite any existing module of the same name.

As shown in the Select Device Module user interface may be used by a user to display each module along with a calculated match value. The Manage Device Bindings user interface is displayed by selecting Search button after a list of all compatible modules is compiled. The higher the match value the better the match between the DUET module s properties and the physical device s properties. A mouse over display area for each module lists the properties associated with the module. A user may select the DUET module to be associated with device from the list of compatible modules displayed in area . Upon selection of Save button the selected DUET module is associated with device . In one embodiment the association does not affect any currently running DUET module associated with device but instead will become effective after the next system reboot. Upon selection of Cancel button the association of a DUET module with device is aborted.

Referring to the exemplary user interface and computer program for managing dynamic devices as shown manages the application devices in the system along with their binding state. This includes the current application defined application devices as well as any pre existing application devices that were bound but no longer exist in the application s list. The user interface may be used to bind application devices to unbound physical devices. The user interface provides a user with the ability to manage bindings. Management of bindings includes but is not limited to initiating a binding and unbinding existing bindings. If an existing binding is unbound and the associated application device is no longer in the list of valid application devices then the application device will be automatically removed from the system. If an existing binding is deleted the associated physical device will not automatically be deleted. Unbound physical devices are lost on reboot as it is expected that they will be re acquired. The user interface to delete a physical device allows for re acquisition of an application device for a serial device based on the polling model.

The DYNAMIC APPLICATION DEVICE NetLinx API causes an application device 41000 42000 to be added to the application device database . The duetVirtualDevice values will be displayed to the user on a user interface of the binding application. The deviceType will be used to ensure a valid link between an application device and a physical device. The friendlyName string is used for display purposes by the binding application.

The DYNAMIC POLLED PORT NetLinx API causes a NetLinx serial device to be added to the polled serial devices that are polled listened for new dynamic devices.

The STATIC PORT BINDING NetLinx API causes a permanent binding to be established between the designated DUET virtual device and the designated NetLinx Device and entries to be added to the application device database and physical device database shell placeholder . The deviceType field may be used to ensure a valid device type is attached to the physical port on the master. The polled variable specifies if the designated netlinxDevice must be polled for devices e.g. serial devices or not e.g. IR devices . Valid values are DUET DEV NOT POLLED 0 and DUET DEV POLLED 1 .

As previously mentioned serial ports are polled for new serial devices to control system . According to the present invention the serial poll request message may be of any form or content. In one embodiment the serial poll request message is an ASCII string consisting of 

Serial ports attached to the polled serial ports are configured to respond to a poll request message with a dynamic device beacon message. According to the present invention the dynamic device beacon message may be of any form or content.

In one embodiment the dynamic device beacon message is an ASCII string containing information specific to the attached serial physical device. The content of the ASCII string is packed together to minimize the data size to support devices with minimum memory or processing. The ASCII string includes a prefix e.g. AMXB and one or more non order dependent name value pairs separated by 

Certain name value pairs may be required. In one embodiment Device UUID and Device SDKClass name value pairs are required. The Device UUID is a unique identifier to distinguish the physical device from every other device. For IP devices this will most likely be the MAC address. For serial devices it is the responsibility of the manufacturer to create a unique value for example a combination of the manufacturer name and serial number. The Device SDKClass is the class name that the associated DUET module extends. This is a fully qualified class name including package name. For example a fully qualified VCR class name may be com.amx.duet.devicesdk.VCR. 

Dynamic IP devices are configured to report the IP address and IP port value which will be used for communication between the DUET object the dynamic IP device. A combination of either Device GUID or Device Make and Device Model may also be supplied. These Device GUID Device Make and Device Model name value pairs may be used to determine the proper DUET Module driver that should be used to service the physical device. The Device GUID is a unique identifier designating a specific manufacturers device. For example the Device GUID may identify a particular type of Sony VCR. All Sony VCRs of this type would have the same Device GUID. Similarly the Device Make and Device Model values delineate a particular manufacturer s device.

The dynamic device beacon message may also include but is not limited to a Device Revision and Bundle Version. Device Revision specifies a particular firmware version that is running in the physical device. Bundle Version specifies DUET Module version number required to interface with the physical device.

In one embodiment the end of the device beacon message ASCII string is designated with a carriage return r . For example dynamic device beacon message may resemble the following without limitation 

The name value pairs contained within the beacon string may be added to the Java Properties object that is associated with the Java NetLinxDevice object and ultimately the DUET object that controls the device.

A dynamic device binding notify message may be transmitted by any means. In one embodiment a dynamic device binding notify message is sent via UDP to multicast address 239.255.250.250 on port 9131 by a master controller when an IP physical device is bound and the master controller takes ownership of the device. According to the present invention the dynamic device binding notify message may be of any form or content. In one embodiment the dynamic device binding notify message is an ASCII string that is identical to the beacon with the exception of the prefix which is AMXL indicating a device is bound or locked .

The present invention thus includes a computer program which may be hosted on a storage medium and includes instructions which perform the processes set forth in the present specification. The storage medium can include but is not limited to any type of disk including floppy disks optical disks CD ROMs magneto optical disks ROMs RAMs EPROMs EEPROMs flash memory magnetic or optical cards or any type of media suitable for storing electronic instructions.

Obviously many other modifications and variations of the present invention are possible in light of the above teachings. The specific embodiments discussed herein are merely illustrative and are not meant to limit the scope of the present invention in any manner. It is therefore to be understood that within the scope of the disclosed concept the invention may be practiced otherwise than as specifically described.

In accordance with disclosed embodiments a discovery protocol mechanism is provided that allows a control system device such as a server to dynamically bind to multiple master controllers. The disclosed discovery protocol mechanism includes a dynamic application device DAD a dynamic physical device DPD and a master controller. The DAD is defined in a controller program as a virtual device. The DPD comprises a physical device transmitting a discovery protocol beacon. A master controller comprises a control system master that has a DAD defined as a certain device type e.g. a camera. A master controller may be implemented such that various control system devices and controlled devices may be communicatively coupled thereto.

Contemporary discovery protocols provide mechanisms for a dynamic physical device to be automatically detected and bound to a master controller . For example depicts a diagrammatic representation of a contemporary discovery and binding mechanism. Dynamic physical devices may multicast a respective beacon that facilitates discovery of the DPDs by a respective master controller . To successfully discover the DPDs and bind the DPDs to the master controllers a master controller must have a dynamic application device that matches the device type of the DPD. For example assuming master controller is configured with a DAD that matches the device type of DPD master controller will recognize DPD on receipt of the DPD s beacon . The master controller may then dynamically bind DPD thereto. In a similar manner assuming master controller is configured with a DAD that matches the device type of DPD the master controller will recognize DPD on receipt of the DPD s beacon and DPD is then dynamically bound to the master controller .

Once a DPD is bound to a master controller the master controller will load the DPD s Module and establish communication with the DPD. The master controller then broadcasts a discovery protocol binding notification message notifying all other master controller that the DPD is no longer unbound. All master controllers receiving the discovery protocol binding notification message must remove the DPD from their unbound DPD List.

A system integrator may access a master controller e.g. master controller via a web interface or other suitable communication interface to explicitly bind DPD to the correct master controller step e.g. master controller in the illustrative example. The master controller may then load DPD s Module step and thereafter initiate control and communication of the DPD step . The master controller then broadcasts a DPD binding notification on a multicast address step which is then detected by the master controller step . The master controller then removes DPD from the unbound DPD list maintained thereby step .

The discovery and static binding routine of requires an administrator to make an explicit manual choice of which master controller a DPD is bound. Some mechanisms provide an auto bind option that facilitates a master controller to automatically bind to any DPD which matches a DAD maintained by the master controller. However contemporary auto bind mechanisms may cause catastrophic undefined results when multiple master controllers attempt to bind to the same DPD. Accordingly static bind mechanisms are preferred in conventional systems when multiple master controllers are listening to the same multicast address for a common DPD device type.

Conventional device discovery mechanisms are suitable for devices that can only bind to one master. However numerous devices exist such as control system servers including RMS servers that must bind to multiple master controllers.

In accordance with an embodiment a discovery protocol beacon is extended with an optional DPD device Type flag that indicates if the DPD is a discovery protocol compatible DP server. Thus on receipt of the beacon a master controller may evaluate the beacon for the presence of the DPD device Type flag. If the device Type Flag is present in the beacon the value of the flag indicates if the DPD is a DP server. In the event the DPD is a DP server the DP server may be advantageously allowed to bind to multiple master controllers. In the event that the device Type Flag is not included in the beacon the device is assumed to be a DP Device and binding of the DPD is performed according to the above described mechanisms.

In the illustrative example assume beacon transmitted by DPD is an extended beacon including a device Type Flag. Further assume that DPD comprises a DP server such as an RMS server. Accordingly DPD may set the beacon s device Type flag to indicate DPD is a DP server. Further assume that each of master controllers have a DAD that matches the device type of DPD . In this instance DPD is allowed to bind to each of master controllers that receive DPD s beacon .

To facilitate binding a server to multiple master controllers a master controller does not broadcast a binding notification notifying other master controllers the DPD is no longer unbound in the event a DP server is successfully bound to the mater controller. Thus multiple master controllers are allowed to bind to the same DP server .

A master controller s discovery protocol firmware may be extended to allow an alternative auto bind option for DP devices and DP servers thereby allowing master controllers to auto bind to DP servers while still requiring a static bind procedure to be performed with DP devices.

A DPD comprising a DP server transmits a DDDP beacon that includes a device Type DT Flag to a multicast address step . In the present example the device Type Flag is set to a value that indicates the DPD comprises a DP server. Conventionally configured master controller detects the DDDP beacon at the multicast address step and adds the DPD to an unbound DPD list maintained by master controller step . Likewise conventionally configured master controller detects the DDDP beacon at the multicast address step and adds the DPD to an unbound DPD list maintained by master controller step .

Master controller detects the DDDP beacon at the multicast address step . Master controller is configured to recognize the DDDP device Type Flag of the DDDP beacon and thus evaluates the DDDP beacon for the device Type Flag. On detection of the DDDP device Type Flag master controller evaluates the value of the device Type Flag and determines the device Type Flag indicates the DPD device comprises a DP server. Accordingly master controller then loads a device Module for the DPD step and may thereafter commence communication and control of the DPD step . Likewise master controller detects the DDDP beacon at the multicast address step . Master controller is configured to recognize the DDDP device Type Flag of the DDDP beacon and thus evaluates the DDDP beacon for the device Type Flag. On detection of the DDDP device Type Flag master controller evaluates the value of the device Type Flag and determines the device Type Flag indicates the DPD device comprises a DP server. Accordingly master controller then loads a device Module for the DPD step and may thereafter commence communication and control of the DPD step .

A system integrator may access a master controller e.g. master controller via a web interface or other suitable communication interface to explicitly bind the DP server to the correct conventionally configured master controller step e.g. master controller in the illustrative example. The master controller may then load the DPD s Module step and thereafter initiate control and communication of the DPD step . The master controller then multicasts a DPD binding notification step which is then detected by the conventionally configured master controller step . The master controller may then remove DPD from the unbound DPD list maintained thereby step .

Thus conventionally configured master controllers add the DPD server to their unbound DPD list as they would for any other DPD and thus still require a system integrator to explicitly select the master controller to bind the DPD to a particular master controller. Master controllers implemented in accordance with disclosed embodiments are advantageously able to automatically load a DPD module for a DP server and initiate communication with the server without administrator intervention.

The discovery and binding routine is invoked step and the master controller monitors the multicast address on which DDDP beacons are broadcast step . On detection of a DDDP beacon step the master controller adds the DPD to the unbound DPD list step . An evaluation is then made to determine if the beacon includes a Device Type Flag step in accordance with the disclosed embodiments. If no device Type Flag is included in the beacon processing may then continue to monitor the multicast address step . Returning again to step if the beacon includes a Device Type Flag an evaluation is then made to determine if the Device Type Flag indicates a DP server step . If so the master controller may then load the DPD s Module and remove the DPD from the unbound list step and may then commence communication with the DPD and control thereof step according to the disclosed embodiments. An evaluation may then be made to determine if the Device Type Flag indicates a DP server step . If not a binding notification is then broadcast step that indicates the DPD is bound thereto and the device discovery and binding routine cycle may then end step . If the Device Type Flag indicates a DP server at step the device discovery and binding routine cycle may then end according to step .

Returning again to step if the Device Type Flag does not indicate a DP server the multicast address may continue to be monitored step and an evaluation of whether the DAD is bound to a DPD by an administrator may be made step . If the DAD is bound to a DPD the DPD s module may then be loaded according to step . If the DAD is not bound to the DPD the master controller may evaluate whether a binding notification has been broadcast on the multicast address indicating the DPD has been bound to another master controller step . If the DPD has not been bound to another master controller the master controller may continue monitoring the broadcast address according to step until the DAD is bound to the DPD. In the event that a binding notification is detected at step the master controller then removes the DPD from the unbound DPD list maintained by the master controller step and the device discovery and binding routine cycle may then end according to step .

Servers may be deployed in large installations such as universities or large multiple dwelling units with many installed master controllers system. Inclusion of the device Type Flag in the device discovery beacon provides for automatic discovery of a server and loading of the server s module at the master controller for communication and control of the server without intervention by an administrator.

As described mechanisms for dynamic device discovery and binding of servers to multiple master controllers are provided. In one implementation a device discovery beacon that includes a device Type Flag may be broadcast by a dynamic physical device. If the dynamic physical device comprises a server that is configured to bind to multiple master controllers the dynamic physical device may set the value of the device Type Flag to indicate the dynamic physical device comprises a server. On detection of the beacon a master controller configured according to disclosed embodiments may evaluate the device Type Flag. Upon determining the device Type Flag indicates the dynamic physical device comprise a server the master controller may load a device Module for the dynamic physical device and commence communications with the dynamic physical device. In this instance the master controller advantageously does not broadcast a binding notification thereby allowing other master controllers to bind with the dynamic physical device.

The flowcharts of depict process serialization to facilitate an understanding of disclosed embodiments and are not necessarily indicative of the serialization of the operations being performed. In various embodiments the processing steps described in may be performed in varying order and one or more depicted steps may be performed in parallel with other steps. Additionally execution of some processing steps of may be excluded without departing from embodiments disclosed herein.

The illustrative block diagrams depict process steps or blocks that may represent modules segments or portions of code that include one or more executable instructions for implementing specific logical functions or steps in the process. Although the particular examples illustrate specific process steps or procedures many alternative implementations are possible and may be made by simple design choice. Some process steps may be executed in different order from the specific description herein based on for example considerations of function purpose conformance to standard legacy structure user interface design and the like.

Aspects of the present invention may be implemented in software hardware firmware or a combination thereof. The various elements of the system either individually or in combination may be implemented as a computer program product tangibly embodied in a machine readable storage device for execution by a processing unit. Various steps of embodiments of the invention may be performed by a computer processor executing a program tangibly embodied on a computer readable medium to perform functions by operating on input and generating output. The computer readable medium may be for example a memory a transportable medium such as a compact disk a floppy disk or a diskette such that a computer program embodying the aspects of the present invention can be loaded onto a computer. The computer program is not limited to any particular embodiment and may for example be implemented in an operating system application program foreground or background process driver network stack or any combination thereof executing on a single processor or multiple processors. Additionally various steps of embodiments of the invention may provide one or more data structures generated produced received or otherwise implemented on a computer readable medium such as a memory.

Although embodiments of the present invention have been illustrated in the accompanied drawings and described in the foregoing description it will be understood that the invention is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the spirit of the invention as set forth and defined by the following claims. For example the capabilities of the invention can be performed fully and or partially by one or more of the blocks modules processors or memories. Also these capabilities may be performed in the current manner or in a distributed manner and on or via any device able to provide and or receive information. Further although depicted in a particular manner various modules or blocks may be repositioned without departing from the scope of the current invention. Still further although depicted in a particular manner a greater or lesser number of modules and connections can be utilized with the present invention in order to accomplish the present invention to provide additional known features to the present invention and or to make the present invention more efficient. Also the information sent between various modules can be sent between the modules via at least one of a data network the Internet an Internet Protocol network a wireless source and a wired source and via plurality of protocols.

