---

title: Modified huffman decoding
abstract: A plurality of bits is retrieved from a bitstream that comprises encoded media content. The plurality of bits may include at least a portion of a codeword. An integer value of the plurality of bits is used to determine an index into a first table. Based on the index, an extra bits field is retrieved from the first table. If the extra bits field includes a predetermined value, then a first plurality of values is retrieved from the first table. If the extra bits field does not include the predetermined value, then a second plurality of values is retrieved from a second table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09413388&OS=09413388&RS=09413388
owner: Dell Products L.P.
number: 09413388
owner_city: Round Rock
owner_country: US
publication_date: 20150130
---
As the value and use of information continues to increase individuals and businesses seek additional ways to process and store information. One option available to users is information handling systems. An information handling system generally processes compiles stores and or communicates information or data for business personal or other purposes thereby allowing users to take advantage of the value of the information. Because technology and information handling needs and requirements vary between different users or applications information handling systems may also vary regarding what information is handled how the information is handled how much information is processed stored or communicated and how quickly and efficiently the information may be processed stored or communicated. The variations in information handling systems allow for information handling systems to be general or configured for a specific user or specific use such as financial transaction processing airline reservations enterprise data storage or global communications. In addition information handling systems may include a variety of hardware and software components that may be configured to process store and communicate information and may include one or more computer systems data storage systems and networking systems.

Many techniques for decoding a bitstream such as an encoded audio bitstream use a Huffman decoding table. For example Motion Picture Experts Group MPEG 2 layer 3 audio encoding often referred to as MP3 encoding uses a Huffman table to decode the bitstream to playback the encoded audio. However decoding an encoded audio bitstream such as MP3 using a Huffman table is very inefficient and expensive in terms of resource e.g. processor utilization. Typically the Huffman decoding for an MP3 bitstream consumes between 30 to 50 of the processing resources used during the decoding process. One of the reasons is the Huffman decoding consumes so many computing resources is due to the large number of table searches that are performed during decoding. Existing Huffman coding tables do not enable fast e.g. direct access to entries.

This Summary provides a simplified form of concepts that are further described below in the Detailed Description. This Summary is not intended to identify key or essential features and should therefore not be used for determining or limiting the scope of the claimed subject matter.

A plurality of bits are retrieved from a bitstream that comprises encoded media content. The plurality of bits may include at least a portion of a codeword. An integer value of the plurality of bits is used to determine an index into a first table. Based on the index an extra bits field is retrieved from the first table. If the extra bits field includes a predetermined value then a first plurality of values is retrieved from the first table. If the extra bits field does not include the predetermined value then a second plurality of values is retrieved from a second table.

For purposes of this disclosure an information handling system may include any instrumentality or aggregate of instrumentalities operable to compute calculate determine classify process transmit receive retrieve originate switch store display communicate manifest detect record reproduce handle or utilize any form of information intelligence or data for business scientific control or other purposes. For example an information handling system may be a personal computer e.g. desktop or laptop tablet computer mobile device e.g. personal digital assistant PDA or smart phone server e.g. blade server or rack server a network storage device or any other suitable device and may vary in size shape performance functionality and price. The information handling system may include random access memory RAM one or more processing resources such as a central processing unit CPU or hardware or software control logic ROM and or other types of nonvolatile memory. Additional components of the information handling system may include one or more disk drives one or more network ports for communicating with external devices as well as various input and output I O devices such as a keyboard a mouse touchscreen and or video display. The information handling system may also include one or more buses operable to transmit communications between the various hardware components.

Systems and techniques are described herein for creating Huffman codebooks to significantly improve the resource usage e.g. processor utilization of Huffman decoding. For example Huffman decoding of an MP3 bitstream using the systems and techniques described herein may be approximately five times faster as compared to using conventional Huffman decoding. Purely for illustration purposes the systems and techniques are described using decoding an MP3 bitstream as an example. However the systems and techniques described herein may be applied to improving the performance of any bitstream decoder that uses Huffman encoding including multichannel audio bitstreams other types of encoded audio bitstreams or any combination thereof.

The techniques include creating two new tables from one or more existing Huffman codebooks e.g. table . For example in MP3 decoding thirty four Huffman codebooks are used. In some embodiments e.g. where fast MP3 decoding is desired and there are no memory constraints two new tables may be created from each of the thirty four Huffman codebooks. In other embodiments e.g. where memory is constrained two new tables may be created from at least one of the thirty four Huffman codebooks. For example larger tables e.g. tables having greater than a predetermined threshold number of rows of the thirty four Huffman codebooks may each be split into two new tables to provide faster lookup while smaller tables may not be split into two tables. Instead the smaller tables may be used in a conventional manner without modification.

The two new tables may then be used to decode an audio bitstream such as an MP3 audio bitstream. For example for each entry in an existing e.g. conventional or old Huffman codebook two new codewords are created and added to create a new Huffman codebook. The two new codewords include a new binary codeword that is derived from an existing e.g. conventional codeword and a new integer codeword corresponding to the binary codeword. The new binary codeword may be derived by determining a length of the longest codeword in the Huffman codebook and then appending e.g. padding each binary codeword in the Huffman codebook with sufficient zeros such that the length of each padded binary codeword is equal to the length of the longest codeword. The new Huffman codebook is sorted in ascending order according the value of the new codewords. After being sorted the new Huffman codebook is split into two tables e.g. a first new table and a second new table. The two tables are then used to decode a bitstream such as an MP3 bitstream. If M is the number of bits in the largest codeword in the Huffman codebook the two tables may be created based on N number of bits where N is less than M. For example in a Huffman codebook where the largest codeword is M 7 bits in length the first new table may be used for codewords that are N 5 bits or less in length while the second table may be used for codewords having a length greater than 5 bits e.g. a length of 6 bits or 7 bits. As another example in a Huffman codebook where the largest codeword is M 10 bits in length the first new table may be used for codewords that are N 7 bits or less in length while the second table may be used for codewords having a length greater than 7 bits e.g. a length of 8 9 or 10 bits. Because the first new table is derived from a new Huffman codebook that is sorted in ascending order of an integer value of each codeword N bits can be retrieved from the bitstream and the integer value of the N bits used to directly access a particular row of the first new table. If a flag indicates that the N bits have a corresponding entry in the first new table then the spectral values are directly read from the first new table. If the flag indicates that the N bits have a corresponding entry in the second new table then one or more extra bits are retrieved from the bitstream an offset is read from the first new table and the offset used to access an entry in the second new table. In contrast when using a conventional Huffman codebook one bit at a time is retrieved from the bitstream and each time a search of the Huffman codebook is performed to determine if the retrieved bits match one of the entries of the Huffman codebook. Thus using the two new tables enables spectral values to be retrieved using one or at most two table lookups rather than using multiple table searches enabling much faster Huffman decoding.

The two new tables may be created from each of one or more existing Huffman codebooks. For example the new tables may be created at a particular time such as offline during bootup or the like. After the new tables have been created they may be stored and used whenever an MP3 bitstream is to be decoded. For example the new tables may be created and included in a media decoder that is embedded in a a logic of an integrated circuit b a firmware of a device e.g. a computing device a camera a phone a media playback device or the like c an operating system d a device driver e a software application etc. As another example the new tables may be included in a media decoder that is embedded into a multimedia file. When the audio file is selected for playback the media decoder may use the new tables to decode the audio of the multimedia file. Of course the new tables for Huffman decoding may be distributed and used in any number of other ways.

As illustrated in the decoder may be capable of decoding MPEG encoded bitstreams or files such as MP3 bitstreams or files . The decoder may include various software modules for decoding the bitstream . The decoder may include a synchronization and error checking module a side information decoder a Huffman decoder using a first set of new table s and a second set of new table s a scale factor decoder a re quantization module and a channel decoder . The channel decoder may decode the bitstream into multiple channels by performing for each channel reordering alias reduction inverse modified discrete cosine transform IMDCT frequency inversion 132 and synthesis filterbank . The first set of new table s and the second set of new table s may be derived from one or more of the 34 Huffman codebooks.

The synchronization and error checking module receives the incoming bitstream and identifies each frame within the bitstream by searching for a synchronization word. This enables each frame of the bitstream to be identified and processed. Each frame includes i a header ii a cyclic redundancy check CRC iii side information iv main data and v ancillary data.

The side information decoder decodes the side information of each frame of the bitstream . The side information includes information used to decode the main data of the frame.

Huffman coding is a variable length coding method. The Huffman decoder uses the new tables that may be derived from a conventional Huffman codebook to decode the bitstream . The new tables may enable fast lookup compared to a conventional Huffman codebook. In Huffman coding codewords are assigned to spectral values based on how often the spectral values occur with short codewords being assigned to the most probable values. Each codeword is an n bit integer. For example for MP3 the compressed data in the bitstream may include frequency domain samples. Each logical frame has up to four chunks with each chunk including up to 576 frequency samples. For a 44100 Hertz Hz audio signal the first frequency sample index 0 represents a frequency at approximately 0 Hz while the last sample index 575 represents a frequency at approximately 22050 Hz. In MP3 the samples are divided into five different regions of variable length. The first three regions are referred to as the big value regions the fourth region is referred to as the quad region and the fifth region is referred to as the zero region. The samples in the zero region are all zero and are therefore not Huffman coded. If the big value regions and the quad region decode to 400 samples then the remaining 176 are padded with 0. The three big values regions represent the important lower frequencies in audio and when decoded may include integers in the range 8206 to 8206. The three big values regions are coded with three different Huffman tables that are defined in the MP3 standard. The MP3 standard defines 15 large tables for the three big regions where each table outputs two frequency samples for a given codeword. The Huffman codebook tables are designed to compress the most common content of the frequency regions as much as possible. To increase compression the 15 tables are paired with an additional parameter for a total of 29 different ways in which each of the three regions can be compressed. The side information include information at to which of the 29 is being used for compression.

The scale factor decoder decodes scale factors used to scale the de quantization. For example for MP3 decoding each frequency band may have a corresponding scale factor.

Quantization involves converting a real number into an integer using an encoding process. In the decoding process the quantization process is reversed to obtain frequency lines. The decoded scaled and quantized frequency lines output from the Huffman decoder are re quantized by the re quantization module using the scale factors to restore the frequency lines. For example raw integer sample values for 576 frequency lines that are obtained after Huffman decoding may be re quantized and scaled. The re quantization module may re quantize and then perform scaling by multiplying the re quantized values with the corresponding scale factors. The scaled frequencies may be stored for the channel decoder to process.

The channel decoder may decode each of the N channels using the scaled frequencies provided by the re quantization module . The frequency lines generated by the re quantization module may not be correctly ordered. For example to increase the efficiency of the Huffman coding the frequency lines in the bitstream may have been reordered and may not be in the correct order for outputting. For each of N outputs the reordering module to N may re order at least a portion of the frequency lines.

Aliasing refers to a distortion e.g. artifact that may result when a signal is reconstructed from samples. The aliasing may include temporal aliasing for an audio signal. The alias reduction module may use various techniques to reduce the aliasing resulting from reconstructing the analog outputs from the digital bitstream .

The inverse modified discrete cosine transform IMDCT is a lapped transform that is performed on consecutive blocks of a larger dataset where subsequent blocks are overlapped so that the last half of one block coincides with the first half of the next block. This overlapping helps to avoid artifacts stemming from the block boundaries. The frequency lines from the alias reduction modules to N may be mapped to 32 polyphase filter sub bands. The IMDC modules to N may output 18 time domain samples for each of the 32 sub bands.

The frequency inversion modules to N may compensate for frequency inversions in the synthesis polyphase filterbank to N by for example multiplying every odd time sample of every odd sub band by 1.

The synthesis filterbanks to N may transform the 32 sub bands of 18 time domain samples in each granule of the bitstream into 18 blocks of 32 PCM samples which are provided as the decoding result via the N outputs to .

Thus the decoder may decode the digital bitstream to create the analog N outputs to . The digital bitstream may include encoded content such as audio content including MPEG compliant content. For example the decoder may decode an MP3 bitstream to create two or more analog outputs to . The Huffman decoder may use the new tables to decode the bitstream significantly faster e.g. up to five times faster than a decoder that uses a Huffman decoder with a conventional Huffman codebook.

A decoder using a conventional Huffman codebook may retrieve multiple bits one bit at a time from the bitstream and perform multiple searches of the conventional Huffman codebook to determine whether the retrieved bit sequence matches a codeword in the conventional Huffman codebook. In contrast the decoder may perform a lookup in the first new table and if the bit sequence matches a codeword in the first new table the appropriate values are retrieved from the first new table . If the bit sequence does not match a codeword in the first new table data for retrieving the codeword from the second table are retrieved from the first new table and the appropriate values are retrieved from the second new table . Thus the Huffman decoder may use one or at most two table lookups as compared to a conventional Huffman decoder in which three four or more table lookups e.g. table searches may be performed for each bit sequence. In this way the decoder using the new tables may be up to five times faster as compared to a conventional decoder that uses a conventional Huffman decoder with a conventional Huffman codebook.

In a conventional Huffman decoder a first bit is retrieved from a bitstream and a search is done to determine if the first bit matches the binary codeword with an hlen of one in one of the rows of the original Huffman codebook . If the first bit matches the binary codeword of one of the entries then the X value and the Y value spectral values are read from the original Huffman codebook . If the first bit does not match any of the binary codewords a second bit is retrieved and a search is done to determine if the first bit and the second bit matches the binary codeword e.g. hlen 2 of one of the entries in the original Huffman codebook . In this manner bits are repeatedly retrieved from the bitstream concatenated to the previously retrieved bit s and a search of the table done until the concatenated bits match one of the binary codewords in the original Huffman codebook .

For example if 0 is the first bit retrieved then 0 does not match any of the binary codewords with hlen 1 and so a second bit is retrieved from the bitstream. If the second bit is 1 then a search of the original Huffman codebook is done to determine if 01 with hlen 2 matches one of the binary codewords . Because 01 with hlen 2 does not match any of the binary codewords a third bit is retrieved from the bitstream. If the third bit is 1 then a search of the original Huffman codebook is performed to determine if 011 with hlen 3 matches any of the codewords . In this example 011 matches the binary codeword of the second row in the original Huffman codebook and the spectral values 0 corresponding to X value and 1 corresponding to Y value are retrieved from the original Huffman codebook . This process of retrieving bits and searching the original Huffman codebook until a match is found is repeated to extract all the codewords and decode the codewords to their corresponding X values and Y values .

The new binary codeword is created by first determining a longest codeword e.g. a largest hlen in the original Huffman codebook . The largest hlen in the original Huffman codebook is referred to herein as maxhlen. Next each binary codeword may be padded e.g. appended with a sufficient number of trailing zeros such that each new binary codeword has a total length in bits of maxhlen. In the original Huffman codebook the largest hlen is seven and thus maxhlen is seven. Therefore each new binary codeword in the Huffman codebook is padded to have a length in bits of seven e.g. maxhlen . For example each new binary codeword in the Huffman codebook is padded using maxhlen hlen trailing zeros. The new integer codeword is the integer value of the corresponding new binary codeword . Note that if hlen maxhlen then no zeros are added. For example when maxhlen 7 codewords with an hlen 7 are not padded.

To illustrate the binary codeword of 111 is padded with maxhlen hlen 7 3 4 zeros to create the new binary codeword 1110000 and the corresponding new integer codeword 112. The binary codeword of 011 is padded with maxhlen hlen 7 3 4 zeros to create the new binary codeword 0110000 and the corresponding new integer codeword 48. The binary codeword of 00101 is padded with maxhlen hlen 7 5 2 zeros to create the new binary codeword 0010100 and the corresponding new integer codeword 20. Similarly each entry where hlen

The first new table may be indexed using a binary codeword retrieved from the bitstream . The binary codeword is illustrated as a column of the first new table purely for ease of understanding e.g. to illustrate how the binary codeword is used to lookup X and Y e.g. spectral values in the first new table and the second new table . In some implementations the first new table may be indexed using the binary codeword without the binary codeword being a column of the first new table . For example in N 5 so the first new table has 2 32 rows. Thus the integer value i of the 5 bits that are retrieved from a bitstream may be used to directly access a corresponding row i of the first new table . For example 00000 integer value 0 is used to directly access row 0 00001 integer value 1 is used to directly access row 1 00010 integer value 2 is used to directly access row 2 etc.

When retrieving bits from the bitstream N bits in this example N 5 at a time are retrieved from the bitstream and a lookup is performed in the first table using the integer value of the N bits . The extra bits field indicates whether the codeword is to be looked up in the first table or the second table . For example when the extra bits field is non zero e.g. one or two then the second table is used. When the extra bits field is zero then the first table is used.

When the extra bits field is non zero then the offset of the corresponding row is retrieved from the first new table e.g. the X value the Y value and the hlen may be ignored . The extra bits field indicates how many additional bits to retrieve from the bitstream and append to the N bits for lookup in the second new table . The offset is used to identify a portion of the second table in which to perform the lookup.

When the extra bits field is zero then the X value the Y value and the hlen of the corresponding row are directly retrieved from the first new table based on the integer value of the bits e.g. the offset may be ignored . The hlen indicates the length of the original e.g. before being padded with zeros codeword. The hlen may be used to determine whether to discard any of the trailing zeros of the binary codeword . The X value and the Y value are used to reconstruct content encoded in the bitstream. For an MP3 bitstream the X value and the Y value are the spectral e.g. audio data used to reconstruct the audio output.

In the following examples the first row is considered row zero to enable the integer value of the 5 bits to directly access the corresponding row of the first new table . As a first example of using the first new table when N 5 the Huffman decoder may retrieve the 5 bit string 00011 integer value 3 from the bitstream and retrieve X 3 and Y 1 from row three. As another example the Huffman decoder may retrieve the 5 bit string 00111 integer value seven from the bitstream and retrieve values X 2 and Y 1 from the seventh row.

In some implementations the extra bits field may be split into two separate columns e.g. a one bit flag to indicate which table to access the values of X and Y e.g. when flag 0 use the first new table and when flag 1 use the second new table and an extra bits column that specifies how many additional bits to retrieve when using the second new table .

Thus decoding performance using the first new table and the second new table is much faster e.g. compared to decoding using the conventional Huffman codebook because i N bits at a time are retrieved from the bitstream and ii one table lookup or at most two table lookups are performed. In contrast decoding using the conventional Huffman codebook involves retrieving one bit at a time and performing a table search each time a bit is retrieved. Thus when N 5 the Huffman decoder of may decode nearly 5 times faster e.g. using the first new table and the second new table by retrieving 5 bits at a time and doing a table search for every 5 bits that are retrieved rather for every bit that is retrieved.

Because N bits are retrieved at a time the first new table includes 2rows. In N 5 so the first new table includes 32 rows. Thus while decoding performance is faster more memory may be used to store the first new table as compared to the conventional Huffman codebook .

When the bitstream of includes a 6 bit codeword the Huffman decoder of may retrieve a 5 bit string 00001. The Huffman decoder access row 1 of the first new table of and determines that one extra bit e.g. extra bits field one is to be retrieved from the bitstream and concatenated to the 5 bit string to create a 6 bit string. The offset corresponding to the 5 bit string 00001 is three indicating that the search of the second table is to be performed starting with the row having an index 3. The new Huffman codebook indicates that there are two codewords e.g. 0000100 and 0000110 that start with 00001 and have hlen 6. Therefore the extra bit will either be 0 or 1. If the extra bit is 0 then a lookup of 0000100 or 0000110 is performed. For 0000100 X 2 and Y 3 are retrieved from the second new table . For 0000110 X 3 and Y 2 are retrieved from the second new table . If the extra bit is 1 then the offset is modified by adding the extra bit 1 to the offset 3 to create the value 4 of the modified offset . The modified offset may then be used to perform the lookup in the second new table starting at index 4. In this particular example there are no codewords in the new Huffman codebook with an hlen 6 and sixth bit of 1. However this example is provided to understand how the modified offset may be created and used in larger tables with N 5.

When the bitstream includes a 7 bit codeword the Huffman decoder may retrieve a 5 bit string 00000 from the bitstream . The Huffman decoder may access row 0 of the first new table and determine that two extra bits e.g. extra bits two are to be retrieved from the bitstream and concatenated to the 5 bit string to create a 7 bit string. The offset corresponding to the 5 bit string 0000 is retrieved in this example offset 0. The new Huffman codebook indicates that there are two codewords with hlen 7 e.g. 0000000 and 0000001. Therefore the two extra bits will either be 00 or 01. If the two extra bits are 00 then the modified offset is the integer value of 0 offset 00 extra bits 0 and a lookup is performed to retrieve X 3 and Y 3 from the second new table using modified offset 0 e.g. indexing row 0 . If the two extra bits are 01 then the modified offset is the integer value of 0 offset 01 extra bits 1 and a lookup of 0000001 is performed to retrieve X 0 and Y 3 from the second new table using modified offset 1 e.g. indexing row 1 .

Thus of the sixteen codewords in the new Huffman codebook twelve of the codewords e.g. hlen less than of equal to five are decoded using a single access of the first new table e.g. teach row is directly access based on the integer value of the N bits retrieved from the bitstream without having to perform a search of a table. Four of the codewords e.g. hlen greater than five are decoded using one access of the first new table and a search in a specified portion of the second new table using the offset . The use of the offset results in a faster lookup compared to searching all of the second new table because they offset specifies where in the second new table to begin the search. In this way the Huffman decoder may use the first new table and the second new table to retrieve the spectral values X and Y significantly faster e.g. up to five times faster compared to using the original Huffman codebook .

In the flow diagrams of each block represents one or more operations that can be implemented in hardware software or a combination thereof. In the context of software the blocks represent computer executable instructions that when executed by one or more processors cause the processors to perform the recited operations. Generally computer executable instructions include routines programs objects modules components data structures and the like that perform particular functions or implement particular abstract data types. The order in which the blocks are described is not intended to be construed as a limitation and any number of the described operations can be combined in any order and or in parallel to implement the processes. For discussion purposes the processes and are described with reference to as described above although other models frameworks systems and environments may implement these processes.

At the largest codeword length in the original Huffman codebook is determined. For example in the computing device may determine that the largest hlen is seven in the original Huffman codebook . The largest codeword length is referred to as maxhlen.

At for each entry e.g. row i in the original Huffman codebook a number of zeros NumZero i is determined by subtracting the length of the codeword hlen i from the largest codeword length maxhlen . At for each entry e.g. row i in the original Huffman codebook the number of zeros NumZero i that were previously determined are appended to a binary codeword binary codeword i to create a new binary codeword new binary codeword i to create a modified Huffman codebook. For example in the computing device may append four zeros 7 3 4 to binary codeword 111 to create new binary codeword 111000 append four zeros 7 3 4 to binary codeword 011 to create new binary codeword 011000 append two zeros 7 5 2 to binary codeword 10100 to create the new binary codeword 1010000 append no zeros 7 7 0 to binary codeword 1000000 and so on.

At the modified Huffman codebook is sorted based on the new binary codeword to create the new Huffman codebook. For example the computing device may sort the modified Huffman codebook of in ascending order of the new binary codeword to create the new Huffman codebook of .

At a first new table and a second new table are created based on the new Huffman codebook. For example the computing device may use the new Huffman codebook of to create the first new table and the second new table based on the new Huffman codebook. For example the computing device may select an integer N where N

At N bits are retrieved from a bitstream. At an integer value of the N bits is used as an index into the first table to retrieve a value of an extra bits field. For example in the decoder may retrieve N bits from the bitstream and use the integer value i of the N bits to access row i of the first new table .

At a determination is made as to whether the extra bits field equals zero. If the extra bits field is zero at then the process proceeds to and values e.g. X value Y value and hlen are retrieved from the first table. At the values that are retrieved are used to create decoded content e.g. analog audio content that corresponds to the data encoded in the bitstream. For example in the decoder may access row i of the first new table and determine whether the extra bits field is zero. If the extra bits field is zero then the decoder retrieves the X value the Y value and in some cases the hlen from row i of the first new table . The X value and the Y value are used to create decoded media content that corresponds to the media content that is encoded in the bitstream.

If the extra bits field is non zero at then the process proceeds to and the offset is retrieved from the first table at . At the offset may be modified based on a value of the extra bits field to create a modified offset. At the appropriate values are retrieved from the second table using the modified offset. At the values that are retrieved are used to create decoded content e.g. analog audio content that corresponds to the data encoded in the bitstream. For example in if the extra bits field is non zero the offset is retrieved from the first new table and modified to create the modified offset . To illustrate the integer value of the extra bits field may be added to the offset to create the modified offset . In the modified offset is used to retrieve the X value the Y value and in some cases the hlen from the second new table . The X value and the Y value are used to create decoded media content that corresponds to the media content that is encoded in the bitstream.

The processor may be a single processing unit or a number of processing units all of which may include single or multiple computing units or multiple cores. The processor can be implemented as one or more microprocessors microcomputers microcontrollers digital signal processors central processing units state machines logic circuitries and or any devices that manipulate signals based on operational instructions. Among other capabilities the processor can be configured to fetch and execute computer readable instructions stored in the memory mass storage devices or other computer readable media.

Memory and mass storage devices are examples of computer storage media for storing instructions which are executed by the processor to perform the various functions described above. For example memory may generally include both volatile memory and non volatile memory e.g. RAM ROM or the like . Further mass storage devices may generally include hard disk drives solid state drives removable media including external and removable drives memory cards flash memory floppy disks optical disks e.g. CD DVD a storage array a network attached storage a storage area network or the like. Both memory and mass storage devices may be collectively referred to as memory or computer storage media herein and may be a non transitory media capable of storing computer readable processor executable program instructions as computer program code that can be executed by the processor as a particular machine configured for carrying out the operations and functions described in the implementations herein.

The computer storage media such as memory and mass storage devices may be used to store software and data. The software may include software applications an operating system and the decoder . The decoder includes the Huffman decoder that uses the first new table and the second new table to decode the bitstream .

The computing device may be coupled to additional computing devices via a network . The computing device may provide content to the additional computing devices . In some implementations the content may include audio content that the computing device streams to the additional computing devices . In other implementations the content may include Huffman encoded content along with the new tables the Huffman decoder or the decoder . In additional implementations the content may include the operating system the applications or both in which case the operating system or the applications may include the new tables the Huffman decoder or the decoder .

The computing device may also include one or more communication interfaces for exchanging data with the additional computing devices such as via the network direct connection or the like as discussed above. The communication interfaces can facilitate communications within a wide variety of networks and protocol types including wired networks e.g. Ethernet DOCSIS DSL Fiber USB etc. and wireless networks e.g. WLAN GSM CDMA 802.11 bluetooth Wireless USB cellular satellite etc. the Internet and the like. Communication interfaces can also provide communication with external storage not shown such as in a storage array network attached storage storage area network or the like.

A display device such as a monitor may be included in some implementations for displaying information and images to users. Other I O devices may be devices that receive various inputs from a user and provide various outputs to the user and may include a keyboard a remote controller a mouse a printer audio input output devices and so forth.

Memory may include modules and components for improved Huffman decoding according to the implementations herein. Memory may also include other data and data structures described herein such as the bitstream and the new tables . Memory may further include one or more other modules such as the operating system drivers communication software or the like. Memory may also include other data such as data stored while performing the functions described above and data used by the other modules.

The example systems and computing devices described herein are merely examples suitable for some implementations and are not intended to suggest any limitation as to the scope of use or functionality of the environments architectures and frameworks that can implement the processes components and features described herein. Thus implementations herein are operational with numerous environments or architectures and may be implemented in general purpose and special purpose computing systems or other devices having processing capability. Generally any of the functions described with reference to the figures can be implemented using software hardware e.g. fixed logic circuitry or a combination of these implementations. The term module mechanism or component as used herein generally represents software hardware or a combination of software and hardware that can be configured to implement prescribed functions. For instance in the case of a software implementation the term module mechanism or component can represent program code and or declarative type instructions that performs specified tasks or operations when executed on a processing device or devices e.g. CPUs or processors . The program code can be stored in one or more computer readable memory devices or other computer storage devices. Thus the processes components and modules described herein may be implemented by a computer program product.

Furthermore this disclosure provides various example implementations as described and as illustrated in the drawings. However this disclosure is not limited to the implementations described and illustrated herein but can extend to other implementations as would be known or as would become known to those skilled in the art. Reference in the specification to one implementation this implementation these implementations or some implementations means that a particular feature structure or characteristic described is included in at least one implementation and the appearances of these phrases in various places in the specification are not necessarily all referring to the same implementation.

Software modules include one or more of applications bytecode computer programs executable files computer executable instructions program modules code expressed as source code in a high level programming language such as C C Perl or other a low level programming code such as machine code etc. An example software module is a basic input output system BIOS file. A software module may include an application programming interface API a dynamic link library DLL file an executable e.g. .exe file firmware and so forth.

Processes described herein may be illustrated as a collection of blocks in a logical flow graph which represent a sequence of operations that can be implemented in hardware software or a combination thereof. In the context of software the blocks represent computer executable instructions that are executable by one or more processors to perform the recited operations. The order in which the operations are described or depicted in the flow graph is not intended to be construed as a limitation. Also one or more of the described blocks may be omitted without departing from the scope of the present disclosure.

Although various embodiments of the method and apparatus of the present invention have been illustrated herein in the Drawings and described in the Detailed Description it will be understood that the invention is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the scope of the present disclosure.

