---

title: Method and apparatus for providing provably secure user input/output
abstract: A method, non-transitory computer readable medium and apparatus for securing user input and/or output on a mobile endpoint device. For example, the method receives an input on the mobile endpoint device, encrypts and authenticates the input in a trusted domain of the mobile endpoint device executing an application and sends the input that is encrypted and authenticated to an untrusted domain of the mobile endpoint device over a secure channel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09524394&OS=09524394&RS=09524394
owner: AT&T Intellectual Property I, L.P.
number: 09524394
owner_city: Atlanta
owner_country: US
publication_date: 20151123
---
This application is a continuation of U.S. patent application Ser. No. 13 540 073 filed Jul. 2 2012 now U.S. Pat. No. 9 195 838 which is herein incorporated by reference in its entirety.

The present disclosure relates generally to mobile device security and more particularly to a method and apparatus for providing provably secure user input output.

Modern smartphones are frequently compromised by malware potentially accessing sensitive information stored on the device. Evidence has shown that the traditional approach to securing systems where attackers find vulnerabilities and then security engineers fix them is inadequate and provides an opportunity for attackers to cause significant damage before the vulnerability is fixed.

Attackers have become more sophisticated. An attacker can manage to completely compromise an operating system of a device by installing a kernel level rootkit. By monitoring user input an attacker with complete control of a device can easily obtain user credentials for sensitive applications such as mobile banking.

In one embodiment the present disclosure provides a method for securing user input and or output on a mobile endpoint device. For example the method receives an input on the mobile endpoint device encrypts and authenticates the input in a trusted domain of the mobile endpoint device executing an application and sends the input that is encrypted and authenticated to an untrusted domain of the mobile endpoint device over a secure channel.

In another embodiment the method receives data in an untrusted domain of the mobile endpoint device that is executing an application sends the data to a trusted domain of the mobile endpoint device executing the application over a secure channel decrypts and authenticates the data in the trusted domain of the application and displays the data as the user output on a display of the mobile endpoint device.

To facilitate understanding identical reference numerals have been used where possible to designate identical elements that are common to the figures.

The present disclosure broadly discloses a method non transitory computer readable medium and apparatus for securing user input and output on a mobile endpoint device. Attackers have become more sophisticated. An attacker can manage to completely compromise an operating system of a device by installing a kernel level rootkit. By monitoring user input an attacker with complete control of a device can easily obtain user credentials for sensitive applications such as mobile banking. One embodiment of the present disclosure attempts to secure a user s input and output on a mobile endpoint device by separating the mobile endpoint device that executes an application into a trusted domain containing a user interface portion of the application and an untrusted domain containing a logic portion of the application.

In one embodiment the network may comprise a core network . The core network may be in communication with one or more access networks and . The access networks and may include a wireless access network e.g. a WiFi network and the like a cellular access network a PSTN access network a cable access network a wired access network and the like. In one embodiment the access networks and may all be different types of access networks may all be the same type of access network or some access networks may be the same type of access network and other may be different types of access networks. The core network and the access networks and may be operated by different service providers the same service provider or a combination thereof.

In one embodiment the core network may include an application server AS and a database DB . Although only a single AS and a single DB are illustrated it should be noted that any number of application servers or databases may be deployed.

In one embodiment the access network may be in communication with one or more mobile endpoint devices also referred to as endpoint devices and . In one embodiment the endpoint device may be a mobile endpoint device such as a cellular telephone a smart phone a tablet computer a laptop computer a netbook a portable media device e.g. an iPod touch or MP3 player and the like. Although only two mobile endpoint devices and are illustrated it should be noted that any number of mobile endpoint devices may be deployed.

In one embodiment the access network may be in communication with one or more third party servers and . In one embodiment the third party servers and may be servers of third party service providers that may send and receive sensitive information to and from the mobile endpoint devices and . For example the third party service providers may be banks financial institutions online retailers and the like. Although only two third party servers and are illustrated it should be noted that any number of third party servers may be deployed.

It should be noted that the network has been simplified. For example the network may include other network elements not shown such as border elements routers switches policy servers security devices gateways a content distribution network CDN and the like.

In one embodiment each application that is installed on the mobile endpoint device may be split into different domains namely a trusted domain and an untrusted domain . The mobile endpoint device may also include a controller domain . In one embodiment the trusted domain may also be referred to as a user interface UI domain. In one embodiment the untrusted domain may also be referred to as a user domain or a logical domain.

In one embodiment by separating each application into these different domains the input and outputs received by the UI in the trusted domain is protected from potential attackers with the control of the untrusted domain . To guarantee integrity of the system the trusted domain has no communication with any external sources except through a formally verified secure channel.

In one embodiment the trusted domain includes a secure home screen and a secure installer . In one embodiment the untrusted domain includes a storage medium e.g. memory and the like that includes one or more applications . In one embodiment the controller domain includes a secure storage medium e.g. memory and the like that includes one or more secured application resources .

In one embodiment execution of the application in different domains does not require application programmers to change the way that the applications are conventionally developed. The application may be parsed to separate the application into the trusted domain containing the UI portions of the application and the untrusted domain containing the logic portions of the application. For example a library of wrapper functions can be used to translate normal UI related calls within the untrusted domain to their secure equivalent. Application layout files and resources can be automatically extracted from an application and used to display the UI within the trusted domain .

In one embodiment any virtualization platform e.g. open source or non open source may be used to isolate the application into the different domains. One example of an open source virtualization platform that may be used is Xen hypervisor. In one embodiment the trusted domain and the untrusted domain may be considered as two separate Xen virtual machines each running a full fledge version of the operating system e.g. Android of the mobile endpoint device. The controller domain may operate to control and manage both the trusted domain and the untrusted domain .

In one embodiment at step the method receives an install action from a user. For example the user may initiate the mobile endpoint device to install a new application. The new application may be located on an external storage device for example such as secure digital SD memory card or an app store on a third party server. A hardware isolation layer such as ARM TrustZone can also be used to securely isolate each domain.

At step the secure home screen may initialize a secure installer . For example a controller physical home button may be pressed to get to the secure home screen and terminate operation of any other applications that are executing in the background to prepare for installation of the new application.

At step the secure installer may request a package list of the application from the controller domain . At step the controller domain may request the package list from the storage medium in the untrusted domain . At step the storage medium in the untrusted domain may provide the package list for the application back to the controller domain . At step the controller domain may provide the package list for the application to the secure installer in the trusted domain .

At step the user may select an application from a list of apps. The secure installer may receive the application that is selected from the user.

At step the secure installer in the trusted domain may request the application resources for the selected application from the controller domain . In one embodiment specifically in an Android implementation the application resources may include an application package file APK file associated with the application and public keys associated with the application. In one embodiment the APK file and the public key may be used during the launch and execution of the application as discussed in further detail below in .

At step the controller domain may request the application resources for the selected application from the storage medium in the untrusted domain . At step the storage medium in the untrusted domain may send the application resources for the selected application to the controller domain . In one embodiment a copy of the application resources may be stored in the secure storage medium of the controller domain as illustrated by the secured application resources . At this point the secure installer may install the requested application using the secured application resources from the controller domain and the method ends.

It should be noted that the untrusted domain does not participate in the installation process. Rather the controller domain directly accesses a memory containing the installation instructions e.g. a secure digital SD card without relying on the integrity of the untrusted domain . Thus assuming that the user is attempting to install a secure application i.e. the user is not attempting to hack their own mobile endpoint device the installation of the application on the mobile endpoint device is likely to be secure.

Once the application is installed onto the mobile endpoint device the application may attempt to communicate with a third party server for example a server of a banking web site. Sensitive information for example bank account balances bank account numbers passwords usernames and the like may be exchanged between the mobile endpoint device and the third party server during communications. As discussed above if a hacker obtains complete control of the mobile endpoint device the hacker may easily monitor the input at the user interface of the mobile endpoint device to capture sensitive inputs and outputs exchanged between the mobile endpoint device and the third party server . The method described and illustrated in provides one method of ensuring secure user input and output on the mobile endpoint device .

The method begins at step where a user presses a home button or initiates a reset action on the mobile endpoint device . At step the controller domain resets the UI environment located in the trusted domain . For example any applications that may be running in the background in the trusted domain of the mobile endpoint device may be terminated. In one embodiment this ensures that if another application on the mobile endpoint device is hacked that the hacked application cannot obtain control of or access to any other secured application. At step the controller domain initializes the secure home screen of UI environment in the trusted domain .

At step the user selects an application. At step the secure home screen sends a user application initialization request to the controller domain . The controller domain may then send the application UI initialization information to the application UI component in the UI environment in the trusted domain at step . At step the controller domain initializes the application logic component such that it may be ready to communicate.

At step the controller domain may send the secured application resources to the application UI component to run the UI of the selected application. In one embodiment the application UI component may be executed by an application that copies the UI of the application in the trusted domain . For example one type of such application that can be used is the Mimic application.

In one embodiment all application code and logic besides the UI of the application may execute in the untrusted domain within the normal instance of the application. For example the secured application resources may include a package name and a layout of the application the Mimic application will be mimicking. The Mimic application may then exchange messages through a formally verified secure channel with the logic portion of the application in the untrusted domain whenever a command is received from a user.

In one embodiment the secured application resources may include the public key and the application layout stored from the method described in . In one embodiment session keys may include a message authentication code MAC key and an encryption key. The MAC key may be used to generate and verify MACs to authenticate that data being sent between the mobile endpoint device and the third party server are from the correct source. The encryption key may be used to encrypt and decrypt encrypted data that is sent between the mobile endpoint device and the third party server .

At step the application UI component may send a graphical user interface GUI prompt to the user. For example the GUI may prompt the user to enter a username and password for accessing the sensitive information stored on the third party server . At step the user provides an input to the application UI component e.g. the user s username and password.

At step the application UI component may encrypt and authenticate e.g. via the MAC the input received from the user at step and transmit the input over a secured communication channel to the application logic component in the untrusted domain . In one embodiment the secure communication channel is created using a single shared memory page.

In one embodiment the isolation layer may provide built in support for inter domain communication. This can be used to establish a secure communication channel between the UI domain and the untrusted domain . In a Xen specific implementation a grant table can be used to obtain a shared 4 kilobyte KB page of memory. When the UI component of an application first starts it can initiate the creation of the secure channel. In the case of Xen the shared memory page must be initialized through Xen s grant table application programming interface API . Xen identifies this shared memory page using a grant reference number which must be passed to the untrusted domain in order to map this shared page for communication.

In one embodiment the grant reference number is passed to the untrusted domain using a normal user datagram protocol UDP socket. No response is received from the untrusted domain in order to maintain security of the system. Once the untrusted domain receives the grant reference number using the same API it maps the shared memory page into its own address space. At this point the secure communication channel is established and all information passing between the untrusted domain and the trusted domain occurs over this channel.

In one embodiment a formally verified library written in C for example may be used to interact with the shared memory page for secure communications between the trusted domain and the untrusted domain . The library may contain functions used to read and write to the shared channel both from the trusted domain and the untrusted domain . The write function may write some specified data to the shared memory page and set various flags to notify the opposite side that there is data to read. After the data is read the flags and the data may be cleared and the channel can be used again. In this way only one message can be sent between each side at a time and a message must be read before another message can be sent. In one embodiment a spinlock mechanism may be used on the shared memory page to ensure that every read and write is a truly atomic operation.

Due to control data only a fixed number of bytes can fit on a shared page. In other words each message that is sent over the secure channel must fit within a fixed amount of memory. In one embodiment the message must fit within approximately 3096 bytes of memory. To ensure that no application can write past this boundary the bounds are checked for every write. In addition reads are placed into a properly sized buffer.

In one embodiment the input may be encrypted and signed using the encryption key and the signature key for the session before being transmitted over the secure communication channel . In one embodiment encryption may be done via piping the secure user input directly from the UI environment in the trusted domain into the secured communication channel . For example the application may issue a command of the form write to tunnel Password get secure field value PASSWORD 

In the example above PASSWORD is a unique identifier of the password field in the UI environment . The function get secure field value never returns the field value to the caller. Instead it returns a handle that the function write to tunnel executed in the trusted domain can use to retrieve the value of the user entered password. Consequently the result of the above call is that the string Password pass is written to the secure communication channel where pass is the user entered password. Since the secure communication channel end point is in the trusted domain the password never passes unencrypted through the untrusted domain .

At step the encrypted and signed user input is sent from the application logic component in the untrusted domain to the third party server . The third party server may then decrypt the user input using a session key. In one embodiment the session key may include a block cipher key and a message authentication code MAC key.

At step the third party server may then send a response back to the mobile endpoint device for example requested bank account information. In one embodiment the encrypted and signed response is received at the mobile endpoint device by the application logic component in the untrusted domain .

The third party server may encrypt and sign the response before transmitting the response to the mobile endpoint device . In one embodiment the encrypted and unencrypted parts of the response from the third party server may be separated by a delimiter. Each application may define a delimiter DELIM which may be specified as part of the installation procedure described in above and signed by the public key of the application. Any information sent from the third party server may be split according to the specified delimiter and content between every two delimiters may be considered to be sensitive. For example if the delimiter is and the response is bank account information such as a password and account balance then in the transmission Login Alice Password 12345 Account balance 100 the strings 12345 and 100 would be identified as being sensitive while the rest of the data may be considered as being non sensitive. The trusted domain may then process the incoming data from the third party server by storing each sensitive string locally and replacing it with a handle before forwarding it to the untrusted domain . In the above example the application running in the untrusted domain would receive the following text Login Alice Password handle 1 Account balance handle 2 The application may then use handle 1 and handle 2 in future calls to the trusted domain .

At step the application logic component may send the encrypted and signed response over the secure communication channel to the application UI component in the trusted domain . The application UI component may then decrypt the encrypted and signed response using the appropriate handles discussed above and appropriate session keys. At step the results may be displayed to the user in the secure UI environment in the trusted domain .

It should be noted that in the method described above in reference to that the untrusted domain and the trusted domain only communicate over the secured communication channel . In addition no data from the trusted domain goes to the untrusted domain without encryption. As a result a hacker who may have gained control over the mobile endpoint device may still not be able to obtain sensitive information by monitoring the user s inputs and outputs. The logical component of an application is separated from the user interface components of the application and all user inputs and outputs are encrypted before being passed to the logical component of the application. As a result the embodiments of the present disclosure secure a user s inputs and outputs on a mobile endpoint device.

It should be noted that although not explicitly specified one or more steps of the methods described above may include a storing displaying and or outputting step as required for a particular application. In other words any data records fields and or intermediate results discussed in the methods can be stored displayed and or outputted to another device as required for a particular application. Furthermore operations steps or blocks in that recite a determining operation or involve a decision do not necessarily require that both branches of the determining operation be practiced. In other words one of the branches of the determining operation can be deemed as an optional step. Furthermore operations steps or blocks of the above described methods can be combined separated and or performed in a different order from that described above without departing from the example embodiments of the present disclosure.

It should be noted that the present disclosure can be implemented in software and or in a combination of software and hardware e.g. using application specific integrated circuits ASIC a general purpose computer or any other hardware equivalents e.g. computer readable instructions pertaining to the method s discussed above can be used to configure a hardware processor to perform the operations or steps of the above disclosed method. In one embodiment the present module or process for securing user input and output on a mobile endpoint device can be implemented as computer executable instructions e.g. a software program comprising computer executable instructions and loaded into memory and executed by hardware processor to implement the functions as discussed above. As such the present method for providing security on a mobile endpoint device as discussed above in the various methods including associated data structures of the present disclosure can be stored on a non transitory e.g. tangible or physical computer readable storage medium e.g. RAM memory magnetic or optical drive or diskette and the like.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

