---

title: Container and image scanning for a platform-as-a-service system
abstract: Implementations provide for container and image scanning for a Platform-as-a-Service (PaaS) system. A method of the disclosure includes initiating, by a processing device executing a node of a multi-tenant Platform-as-a-Service (PaaS) system, a scan process at the node to scan containers executing on the node, the containers executing functionality of multiple applications that are owned by multiple owners. The method further includes, for each container of the containers, scanning, by the processing device in accordance with the scan process, a top layer of application image instance used to launch the container in the node without scanning remaining layers of the application image instance, and terminating, by the processing device, the scan process for the container when the scanning generates a clean result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355248&OS=09355248&RS=09355248
owner: Red Hat, Inc.
number: 09355248
owner_city: Raleigh
owner_country: US
publication_date: 20150126
---
The implementations of the disclosure relate generally to Platform as a Service PaaS systems and more specifically relate to container and image scanning for a PaaS system.

A variety of Platform as a Service PaaS system offerings exists that include software and or hardware facilities for facilitating the execution of web applications in a cloud computing environment the cloud . Cloud computing is a computing paradigm in which a customer pays a cloud provider to execute a program on computer hardware owned and or controlled by the cloud provider. It is common for cloud providers to make virtual machines VMs hosted on its computer hardware available to customers for this purpose.

The cloud provider typically provides an interface that a customer can use to requisition virtual machines and associated resources such as processors storage and network services etc. as well as an interface a customer can use to install and execute the customer s program on the virtual machines that the customer requisitions together with additional software on which the customer s program depends. For some such programs this additional software can include software components such as a kernel and an operating system and or middleware and a framework. Customers that have installed and are executing their programs in the cloud typically communicate with the executing program from remote geographic locations using Internet protocols.

PaaS offerings facilitate deployment of web applications without the cost and complexity of buying and managing the underlying hardware and software and provisioning hosting capabilities providing the facilities to support the complete life cycle of building and delivering web applications and services entirely available from the Internet. Typically these facilities operate as one or more VMs running on top of a hypervisor in a host server.

Implementations of the disclosure provide container and image scanning for a Platform as a Service PaaS system. Implementations provide scan components located at multiple locations in the PaaS system including at nodes at an image repository and at an image build system. The scan components may include one or more pluggable scanning processes installed to provide pattern detection in order to identify threats e.g. viruses malware other unwanted processes etc. existing in the PaaS system. Implementations of the disclosure optimize scanning performed by scan component of images and runtime environments of applications of the PaaS. The multiple scan components are distributed throughout the PaaS system to provide for separate build time runtime and image repository scans.

The multiple scan components are optimized to take advantage of the image based model for application deployment utilized by the PaaS. Full application image scans may be performed by a scan component residing at the image build system. Each time an application image is built scan component analyzes the output of the build to determine whether the application image is clean. A result of the built application image scan process is stored in a central scan data store maintained by the PaaS system controller. Similarly when new scan definitions are released a scan component residing in the image repository scans all existing application images and updates central scan data store with the results.

Furthermore scan components at each node in the system are configured to scan the running e.g. top most layer of each application image instance on the node while ignoring all other layers of the application image. Each application image includes multiple layers of files with the top most layer of an application image instance running in a node being configurable while the remaining lower layer are immutable or unchangeable. As a result of running a scan of the built application image at build time the lower layer of an application image instance running on a node is assumed to be clean in terms of scanning. Consequently the scan components at nodes scan just the top most configurable layer of the running application components on the node thus saving resources in the PaaS system that were previously consumed in running full image scans at the nodes.

Previous solutions for providing image and container scanning for a PaaS system would run scans on entire images and application files maintained at the nodes in the PaaS system. Even when the previous scanning solutions provided for scanning of those application files that had not been modified or had been scanned recently the previous solutions still had to perform full system scans of the application files at the nodes periodically to ensure security of the PaaS system. Implementations of the disclosure provide for efficient and optimized scanning of application images in a PaaS system by scanning a portion of an application image at a node without having to perform a full scan of the application image at any point in time at the node thus conserving and reducing PaaS system resource usage.

In some implementations the host machines are often located in a data center. Users can interact with applications executing on the cloud based nodes using client computer systems such as clients and via corresponding client software . Client software may include an application such as a web browser. In other implementations the applications may be hosted directly on hosts through N without the use of VMs e.g. a bare metal implementation and in such an implementation the hosts themselves are referred to as nodes .

Clients and are connected to hosts in cloud and the cloud provider system via a network which may be a private network e.g. a local area network LAN a wide area network WAN intranet or other similar private networks or a public network e.g. the Internet . Each client may be a mobile device a PDA a laptop a desktop computer a tablet computing device a server device or any other computing device. Each host may be a server computer system a desktop computer or any other computing device. The cloud provider system may include one or more machines such as server computers desktop computers etc.

In one implementation the cloud provider system is coupled to a cloud controller via the network . The cloud controller may reside on one or more machines e.g. server computers desktop computers etc. and may manage the execution of applications in the cloud . In some implementations cloud controller receives commands from PaaS system controller . Based on these commands the cloud controller provides data e.g. such as pre generated images associated with different applications to the cloud provider system . In some implementations the data may be provided to the cloud provider and stored in an image repository in an image repository not shown located on each host or in an image repository not shown located on each VM . This data may be used for the execution of applications for a multi tenant PaaS system managed by the PaaS provider controller .

In one implementation the data used for execution of applications includes application images built from preexisting application components and source code of users managing the application. As discussed above an image refers to data representing executables and files of the application used to deploy functionality for a runtime instance of the application. In one implementation the image is built using a Docker tool and is referred to as a Docker image. An application image may be built in the PaaS system using an image build system of the PaaS system. The image build system may be provided on components hosted by cloud on a server device external to the cloud or even run on nodes not shown . The image build system generates an application image for an application by combining preexisting ready to run application image corresponding to core functional components of the application e.g. a web framework database etc. with source code specific to the application provided by the user. The resulting application image may be pushed to image repository for subsequent use in launching instances of the application images for execution in the PaaS system.

Upon receiving a command identifying specific data e.g. application data and files such as application images used to initialize an application on the cloud from the PaaS provider controller the cloud provider retrieves the corresponding data from the image repository creates an instance of it and loads it to the hosts to run on nodes . In addition a command may identify specific data to be executed on one or more of the nodes and . The command may be received from the cloud controller from the PaaS system controller or a user e.g. a system administrator via a console computer or a client machine. The image repository may be local or remote and may represent a single data structure or multiple data structures databases repositories files etc. residing on one or more mass storage devices such as magnetic or optical storage based discs solid state drives SSDs or hard drives.

In one implementation multiple scan components are located at nodes image repository and an image build system . Scan component may include one or more pluggable scanning processes installed to provide pattern detection in order to identify threats e.g. viruses malware other unwanted processes etc. existing in the PaaS system. Implementations of the disclosure optimize scanning performed by scan component of images and runtime environments of applications of the PaaS. Multiple scan components are distributed throughout the PaaS system to provide for separate build time runtime and image repository scans. The multiple scan components are optimized to take advantage of the image based model for application deployment utilized by the PaaS. Full application image scans may be performed by a scan component residing at the image build system . Each time an application image is built scan component analyzes the output of the build to determine whether the application image is clean. A result of the built application image scan process is stored in a central scan data store maintained by the PaaS system controller . Similarly when new scan definitions are released a scan component residing in the image repository scans all existing application images and updates central scan data store with the results.

Scan components at each of nodes are configured to scan the running e.g. top most layer of each application image instance on the node while ignoring all other layers of the application image. Each application image includes multiple layers of files with the top most layer of an application image instance running in a node being configurable while the remaining lower layer are immutable or unchangeable. As a result of running a scan of the built application image at build time the lower layers of an application image instance running on a node are assumed to be clean in terms of scanning. Consequently the scan components at nodes scan just the top most configurable layer of running application components on the node thus saving resources in the PaaS system that were previously consumed in running full image scans at the nodes . Further details of scan components and its related workflows can be found below with respect to .

While various implementations are described in terms of the environment described above those skilled in the art will appreciate that the facility may be implemented in a variety of other environments including a single monolithic computer system as well as various other combinations of computer systems or similar devices connected in various ways. For example the data from the image repository may run directly on a physical host instead of being instantiated on nodes . In some implementations an environment other than a VM may be used to execute functionality of PaaS applications. As such in some implementations a node providing computing functionality may provide the execution environment for an application of the PaaS system. The node may refer to a VM or any other type of computing environment.

In one implementation the components of the PaaS system architecture are in communication with each other via a network not shown . The network may include for example the Internet in one implementation. In other implementations other networks wired and wireless such as an intranet local area network LAN wide area network WAN or broadcast network may be used.

In one implementation the client layer resides on a client machine such as a workstation of a software developer and provides an interface to a user of the client machine to the PaaS master layer of the PaaS system . In one implementation the client machine can be a client described with respect to . The PaaS master layer may facilitate the creation and deployment on the cloud via node layer of software applications being developed by an end user at client layer .

In one implementation the client layer includes a source code management system sometimes referred to as SCM or revision control system. One example of such an SCM or revision control system is Git available as open source software. Another example of an SCM or revision control system is Mercurial also available as open source software. Git Mercurial and other such distributed SCM systems typically include a working directory for making changes and a local software repository for storing the changes for each application associated with the end user of the PaaS system . The packaged software application can then be pushed from the local SCM repository to a remote SCM repository such as repositories at the node s running the associated application. From the remote SCM repository the code may be edited by others with access or the application may be executed by a machine. Other SCM systems work in a similar manner.

The client layer in one implementation also includes a set of command line tools that a user can utilize to create launch and manage applications. In one implementation the command line tools can be downloaded and installed on the user s client machine and can be accessed via a command line interface or a graphical user interface or some other type of interface. In one implementation the command line tools expose an application programming interface API of the PaaS master layer and perform other applications management tasks in an automated fashion using other interfaces as will be described in more detail further below in accordance with some implementations.

In one implementation the PaaS master layer acts as middleware between the client layer and the node layer . The node layer includes the nodes on which applications are provisioned and executed. In one implementation each node is a VM. In some implementations the VMs are provisioned by an Infrastructure as a Service IaaS provider. In other implementations the nodes may be physical machines or VMs residing on a single physical machine. In one implementation the PaaS master layer is implemented on one or more machines such as server computers desktop computers etc. In some implementations the PaaS master layer may be implemented on one or more machines separate from machines implementing each of the client layer and the node layer or may be implemented together with the client layer and or the node layer on one or more machines or some combination of the above.

In one implementation the PaaS master layer includes a PaaS master component that coordinates requests from the client layer with actions to be performed at the node layer . Examples of the requests can include a request to create an application a request to perform an action on a container e.g. creating removing and or managing a container a request to deploy source code of an application a request to designate a system to host a remote SCM repository e.g. an indication that a system has been designated by a user to host a remote SCM repository etc.

In one implementation a user using the command line tools at client layer can request the creation of a new application deployment of source code of the application the designation of a system that hosts a remote SCM repository etc. In response to receiving such a request the PaaS master component may first authenticate the user using an authentication service . In one implementation the authentication service may comprise custom authentication methods or standard protocols such as SAML Oauth etc. Once the user has been authenticated and allowed access to the system by authentication service the PaaS master component uses a server orchestration system to collect information and configuration information about the nodes 

In one implementation the PaaS master component uses the ETCD service available from CoreOS as the server orchestration system but other server orchestration systems may also be used. The server orchestration system in one implementation functions to coordinate server client interaction between multiple sometimes a large number of servers. In one implementation the servers being orchestrated are nodes which are acting as application servers and web servers.

In one implementation the PaaS master component manages the business logic and model representing the nodes and the applications residing on the nodes and acts as a controller that generates the actions requested by users via an API of the command line tools . The server orchestration system then takes the actions generated by the PaaS master component and orchestrates their execution on the many nodes managed by the system.

In one implementation the information collected about the nodes can be stored in a data store . In one implementation the data store can be a locally hosted database or file store or it can be a cloud based storage service provided by a Software as a Service SaaS provider. The PaaS master component uses the information about the nodes and their applications to model the application hosting service and to maintain records about the nodes. In one implementation data of a node is stored in the form of a JavaScript Object Notation JSON blob or string that maintains key value pairs to associate a unique identifier a hostname a list of applications and other such attributes with the node.

In implementations of the disclosure the PaaS system architecture of is a multi tenant PaaS environment. In a multi tenant PaaS environment each node runs multiple applications that may be owned or managed by different users and or organizations. As such a first customer s deployed applications may co exist with any other customer s deployed applications on the same node that is hosting the first customer s deployed applications . In some implementations portions of an application execute on multiple different nodes . For example as shown in components of application run in both node and node . Similarly components of application may run in node and node while components of application may run in node and

In one implementation each node is implemented as a VM and has an operating system that can execute applications using the repositories that are resident on the nodes . Each node also includes a server orchestration system agent not shown configured to track and collect information about the node and to perform management actions on the node . The server orchestration system agent may operate in tandem with the server orchestration system to send requests queries and commands between the node and the PaaS master layer .

As discussed above node runs multiple applications . A node runs an application by launching an instance of an application image as a container in the node . An application image includes the underlying support software that implements the functionality of applications . An application image for an application may be built by build system which may be separate from or part of node layer . Build system may be the same as image build system described with respect to .

As discussed above build system may generate an application image from a combination of preexisting ready to run application images related to core functionality of the application and source code provided by a user of the application. For example the preexisting ready to run application images may include support software providing functionality e.g. configuration templates scripts dependencies etc. used to run the application and or add a feature to the application . For example the images may support languages such as but not limited to Java PHP Ruby Python Perl and so on. In addition application images may be generated that support databases such as MySQL PostgreSQL Mongo and others. Preexisting ready to run application images may also include those that support the build and continuous integration environments such as a Jenkins based image. Lastly preexisting ready to run application images may be used to support management capabilities and or tools such as PHPmyadmin RockMongo 10gen mms agent cron scheduler HAProxy Maven and Gradle for example.

Each application image built by build system may map to a functional component of the application . As such an application may have more than one application image associated with the application. Built application images may be pushed to image repository for storage and accessibility for subsequent use in launching instances of the application images at containers in nodes . Image repository may be the same image repository described with respect to .

A container is a resource constrained process space on the node to execute functionality of an application . In some implementations a container is established by the node with resource boundaries including a limit and or designation of the amount of memory amount of storage and security types and or labels to be applied to any functions executed by the container . In one implementation containers may be established using the Linux Containers LXC method. In further implementations containers may also be established using cgroups SELinux and kernel namespaces to name a few examples.

Application image instances for an application may be launched in containers dispersed over more than one node . In other implementations application image instances for an application may run in one or more containers on the same node . Furthermore an application may use more than one application image as part of providing functionality for the application . One example of this is a JavaEE application that uses a JBoss application server based application image with a supporting MySQL database provided by a MySQL based application image.

In one implementation multiple scan components are located at nodes image build system and image repository . Scan components may be the same as scan component described with respect to . Each scan component may include one or more pluggable scanning processes e.g. clamav rkhunter malware finder etc. installed to provide pattern detection in order to identify threats e.g. viruses malware other unwanted processes etc. existing in the PaaS system . Implementations of the disclosure optimize scanning by scan components of images and runtime environments of applications of the PaaS system .

Multiple scan components are distributed throughout the PaaS system to provide for separate build time runtime and image repository scans. The multiple scan components are optimized to take advantage of the image based model for application deployment utilized by the PaaS. Full application image scans may be performed by a scan component residing at the image build system . Each time an application image is built by build system scan component analyzes the output of the build to determine whether the application image is clean. For example the scan component may run pattern detection according to a definition file configured at the scan component on each layer of the built application image.

A result of the built application image scan process is stored in a central scan database maintained by the PaaS master layer for example in data store . Central scan database may be the same as central scan data store described with respect to . In one implementation the information maintained in central scan database includes but is not limited to a unique identifier of the layer of the image being scanned e.g. a checksum of the layer the scan process e.g. clamav rkhunter etc. a definition version of the scan process run against the image layer and a result of the scan e.g. clean failed etc. .

In some implementations the scan component at the build system may utilize previous scan results to streamline the scan process of a built application image by skipping a scan of the layers of the built application image that have already been scanned in previous scans as documented in the central scan database . For example previous scans of the application image layers corresponding to the previously existing ready to run application images used to build the new application image may be used to skip the scan process for those layers in the newly built image. In one implementation a diff process may be utilized between the previously existing ready to run image and the newly built image in order to identify the differences that should be scanned by scan component .

In one implementation if an application image layer fails the scan process e.g. a defined pattern is detected by the scan component then the scan component alerts a monitoring component of the PaaS master component . The monitoring component may begin a takedown process to remove the application image from the PaaS system.

When new scan definitions are released a scan component residing in the image repository scans all existing application images and updates central scan database with the scan results. If a pattern is detected in any of the application images maintained at image repository then the scan component provides a list of images affected by the failed scan to the monitoring component . The monitoring component then determines which running containers include any of the images in the list and initiates a takedown process for those containers as well as the affected images in the image repository .

Scan components at each of nodes are configured to scan the running e.g. top most layer of each application image instance on containers of the node while ignoring all other layers of the application image. Each application image includes multiple layers of files with the top most layer of an application image instance running as a container being configurable while the remaining lower layers are immutable or unchangeable. As a result of running a scan of the built application image at build time as described above the lower layer of an application image instance running on a node is assumed to be clean in terms of scanning. Consequently the scan components at nodes scan just the top most configurable layer of running application components on the node thus saving resources in the PaaS system that were previously consumed in running full image scans at the nodes . The scan components at each node may be configured to run on an iterative time period e.g. once a day etc. to examine all running containers on the node.

Method begins at block where an indication of a completion of a build process for a new application image is received. Then at block a scan process is invoked on the new application image. At block the portions of the new application image corresponding to previously scanned and clean application image layers are identified. In one implementation the previously scanned and clean application image layers may correspond to core functionality base image s of the PaaS system used to build the application in combination with source code provided by an owner of the application. A central scan data store of the PaaS system may include information indicating which application images have been scanned with a clean result.

At block the remaining portions of the new application image that are not part of the identified portions are scanned. In some implementations a diff process between the previously scanned and clean application images and the new application image may be used to determine the remaining portions of the new application image for scanning. The scanning process may detect patterns in the remaining portions of the new application image that are defined in a configured definition file for the scan process.

At block information pertaining to the scan results is stored in a central scan data store maintained by the PaaS system. In one implementation the information may include but is not limited to a unique ID for the application image layer scanned e.g. a checksum of the application layer a scan process run against the application image layer a definition file version run against the application image layer and result of the scan e.g. clean failed etc. . At decision block it is determined whether the scan results were clean. If so method ends. On the other hand if the scan results failed then method continues to block where the failed scan results are reported to a monitoring component of the PaaS system in order to initiate a takedown process for the new application image. Then method ends.

Method begins at block where an indication is received to begin a scan process at a node of the PaaS system. In one implementation the scan process is configured to run on the node on a recurring and iterative basis e.g. once a day etc. . At block for each running container on the node a top most configurable layer of an instance of the application image used to launch the container is scanned. The scanning process may detect patterns in the remaining portions of the new application image that are defined in a configured definition file for the scan process.

At decision block it is determined whether the scan results are clean. If so then at block the scan process for each of the running containers with clean scans is terminated. On the other hand if the scan results failed at decision block then at block the failed scan results are reported to a monitoring component of the PaaS system. The monitoring component may then initiate a takedown process for any of the containers with failed scan results.

Method begins at block where a new definition file is received for a scan process of a scan component installed at an image repository of a PaaS system. At block the scan process is configured with the new definition file. Then at block the scan process is invoked for each application image stored in the image repository. In one implementation the invoked scan process detects patterns defined in the new configured definition file for the scan process.

At block information pertaining to the scan results is stored in a central scan data store maintained by the PaaS system. In one implementation the information may include but is not limited to a unique ID for the application image layer scanned e.g. a checksum of the application layer a scan process run against the application image layer a definition file version run against the application image layer and result of the scan e.g. clean failed etc. .

Then at decision block it is determined whether the scan results are clean. If so method ends. Other the other hand if the scan results failed then method continues to block where the failed scan results and a list of affected application images are reported to a monitoring component of the PaaS system. In one implementation the monitoring component uses the reporting information to identify running containers utilizing the affected application images and to initiate a takedown process for the running containers at their nodes. In addition the monitoring component initiates a takedown process for the affected application images themselves. Then method ends.

The computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device communicably coupled to a network . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine readable or machine accessible storage medium on which is stored software embodying any one or more of the methodologies of functions described herein. The software may also reside completely or at least partially within the main memory as instructions and or within the processing device as processing logic during execution thereof by the computer system the main memory and the processing device also constituting machine readble storage media.

The machine readable storage medium may also be used to store instructions to implement a scan component to provide image and container scanning for a PaaS system in a computer system such as the computer system described with respect to and or a software library containing methods that call the above applications. While the machine readable storage medium is shown in an example implementation to be a single medium the term machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the disclosure. The term machine readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

In the foregoing description numerous details are set forth. It will be apparent however that the disclosure may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the disclosure.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as sending receiving attaching forwarding caching referencing determining initiating scanning terminating or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition the disclosure is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the disclosure as described herein.

The disclosure may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the disclosure. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc.

The terms first second third fourth etc. as used herein are meant as labels to distinguish among different elements and may not necessarily have an ordinal meaning according to their numerical designation.

Whereas many alterations and modifications of the disclosure will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular implementation shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various implementations are not intended to limit the scope of the claims which in themselves recite only those features regarded as the disclosure.

