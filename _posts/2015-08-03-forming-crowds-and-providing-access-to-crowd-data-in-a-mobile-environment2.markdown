---

title: Forming crowds and providing access to crowd data in a mobile environment
abstract: A system and method are provided for forming crowds of users and providing access to corresponding crowd data. In one embodiment, a central system, which includes one or more servers, operates to obtain current locations for users of mobile devices. The system forms a crowd including a number of users based on the current locations of the number of users using a spatial crowd formation process based on an optimal inclusion distance that is a function of density of users of the plurality of users within a bounding region. The central system then generates crowd data for the crowd and provides access to the crowd data for the crowd. In one embodiment, the crowd data for the crowd includes an aggregate profile for the crowd. In another embodiment, the crowd data includes data characterizing the crowd. The central system provides access to the crowd data by serving crowd data requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09641393&OS=09641393&RS=09641393
owner: WALDECK TECHNOLOGY, LLC
number: 09641393
owner_city: Wilmington
owner_country: US
publication_date: 20150803
---
This application is a continuation of U.S. patent application Ser. No. 12 654 532 which was filed Dec. 23 2009 which claims the benefit of provisional patent application Ser. No. 61 149 205 filed Feb. 2 2009 provisional patent application Ser. No. 61 227 192 filed Jul. 21 2009 and provisional patent application Ser. No. 61 236 296 filed Aug. 24 2009 the disclosures of which are hereby incorporated by reference in their entireties.

The present disclosure relates to forming crowds of users in a mobile environment and providing access to crowd data for those crowds.

With the growing popularity of mobile smart phones such as the Apple iPhone mobile social networking applications are becoming extremely popular. However a major concern with current mobile social networking applications is user privacy. What is needed is a mobile social networking application that operates within a strict privacy framework.

The present disclosure provides a system and method for forming crowds of users and providing access to corresponding crowd data. In one embodiment a central system which includes one or more servers operates to obtain current locations for users of mobile devices. The central system forms a crowd including a number of users based on the current locations of the number of users using a spatial crowd formation process based on an optimal inclusion distance that is a function of density of users of the plurality of users within a bounding region for the spatial crowd formation process. The optimal inclusion distance is subject to change as the crowd is formed. The central system then generates crowd data for the crowd and provides access to the crowd data for the crowd in response to receiving a request for the crowd data. In one embodiment the crowd data for the crowd includes an aggregate profile for the crowd generated based on user profiles of the users in the crowd and in some embodiments a user profile or select subset of the user profile of a requestor or a target user profile. In another embodiment the crowd data includes data characterizing the crowd such as but not limited to data identifying a degree of fragmentation of the crowd a best case average degree of separation DOS for one or more crowd fragments in the crowd a worst case average DOS for one or more crowd fragments in the crowd a best case average DOS for the crowd a worst case average DOS for the crowd a degree of bidirectionality of friend relationships in one or more crowd fragments in the crowd and or a degree of bidirectionality of friend relationships in the crowd.

Those skilled in the art will appreciate the scope of the present invention and realize additional aspects thereof after reading the following detailed description in association with the accompanying drawings.

The embodiments set forth below represent the necessary information to enable those skilled in the art to practice the invention and illustrate the best mode of practicing the invention. Upon reading the following description in light of the accompanying drawings those skilled in the art will understand the concepts of the invention and will recognize applications of these concepts not particularly addressed herein. It should be understood that these concepts and applications fall within the scope of the disclosure and the accompanying claims.

As discussed below in detail the MAP server operates to obtain current locations including location updates and user profiles of the users through N of the mobile devices through N. The current locations of the users through N can be expressed as positional geographic coordinates such as latitude longitude pairs and a height vector if applicable or any other similar information capable of identifying a given physical point in space in a two dimensional or three dimensional coordinate system. Using the current locations and user profiles of the users through N the MAP server is enabled to provide a number of features such as but not limited to maintaining a historical record of anonymized user profile data by location generating aggregate profile data over time for a Point of Interest POI or Area of Interest AOI using the historical record of anonymized user profile data identifying crowds of users using current locations and or user profiles of the users through N generating aggregate profiles for crowds of users at a POI or in an AOI using the current user profiles of users in the crowds and crowd tracking. Note that while the MAP server is illustrated as a single server for simplicity and ease of discussion it should be appreciated that the MAP server may be implemented as a single physical server or multiple physical servers operating in a collaborative manner for purposes of redundancy and or load sharing.

In general the one or more profile servers operate to store user profiles for a number of persons including the users through N of the mobile devices through N. For example the one or more profile servers may be servers providing social network services such the Facebook social networking service the MySpace social networking service the LinkedIN social networking service and or the like. As discussed below using the one or more profile servers the MAP server is enabled to directly or indirectly obtain the user profiles of the users through N of the mobile devices through N. The location server generally operates to receive location updates from the mobile devices through N and make the location updates available to entities such as for instance the MAP server . In one exemplary embodiment the location server is a server operating to provide Yahoo s FireEagle service.

The mobile devices through N may be mobile smart phones portable media player devices mobile gaming devices or the like. Some exemplary mobile devices that may be programmed or otherwise configured to operate as the mobile devices through N are the Apple iPhone the Palm Pre the Samsung Rogue the Blackberry Storm and the Apple iPod Touch device. However this list of exemplary mobile devices is not exhaustive and is not intended to limit the scope of the present disclosure.

The mobile devices through N include MAP clients through N MAP applications through N third party applications through N and location functions through N respectively. Using the mobile device as an example the MAP client is preferably implemented in software. In general in the preferred embodiment the MAP client is a middleware layer operating to interface an application layer i.e. the MAP application and the third party applications to the MAP server . More specifically the MAP client enables the MAP application and the third party applications to request and receive data from the MAP server . In addition the MAP client enables applications such as the MAP application and the third party applications to access data from the MAP server . For example as discussed below in detail the MAP client enables the MAP application to request anonymized aggregate profiles for crowds of users located at a POI or within an AOI and or request anonymized historical user profile data for a POI or AOI.

The MAP application is also preferably implemented in software. The MAP application generally provides a user interface component between the user and the MAP server . More specifically among other things the MAP application enables the user to initiate historical requests for historical data or crowd requests for crowd data e.g. aggregate profile data and or crowd characteristics data from the MAP server for a POI or AOI. The MAP application also enables the user to configure various settings. For example the MAP application may enable the user to select a desired social networking service e.g. Facebook MySpace LinkedIN etc. from which to obtain the user profile of the user and provide any necessary credentials e.g. username and password needed to access the user profile from the social networking service.

The third party applications are preferably implemented in software. The third party applications operate to access the MAP server via the MAP client . The third party applications may utilize data obtained from the MAP server in any desired manner. As an example one of the third party applications may be a gaming application that utilizes historical aggregate profile data to notify the user of POIs or AOIs where persons having an interest in the game have historically congregated.

The location function may be implemented in hardware software or a combination thereof. In general the location function operates to determine or otherwise obtain the location of the mobile device . For example the location function may be or include a Global Positioning System GPS receiver.

The subscriber device is a physical device such as a personal computer a mobile computer e.g. a notebook computer a netbook computer a tablet computer etc. a mobile smart phone or the like. The subscriber associated with the subscriber device is a person or entity. In general the subscriber device enables the subscriber to access the MAP server via a web browser to obtain various types of data preferably for a fee. For example the subscriber may pay a fee to have access to historical aggregate profile data for one or more POIs and or one or more AOIs pay a fee to have access to crowd data such as aggregate profiles for crowds located at one or more POIs and or located in one or more AOIs pay a fee to track crowds or the like. Note that the web browser is exemplary. In another embodiment the subscriber device is enabled to access the MAP server via a custom application.

Lastly the third party service is a service that has access to data from the MAP server such as a historical aggregate profile data for one or more POIs or one or more AOIs crowd data such as aggregate profiles for one or more crowds at one or more POIs or within one or more AOIs or crowd tracking data. Based on the data from the MAP server the third party service operates to provide a service such as for example targeted advertising. For example the third party service may obtain anonymous aggregate profile data for one or more crowds located at a POI and then provide targeted advertising to known users located at the POI based on the anonymous aggregate profile data. Note that while targeted advertising is mentioned as an exemplary third party service other types of third party services may additionally or alternatively be provided. Other types of third party services that may be provided will be apparent to one of ordinary skill in the art upon reading this disclosure.

Before proceeding it should be noted that while the system of illustrates an embodiment where the one or more profile servers and the location server are separate from the MAP server the present disclosure is not limited thereto. In an alternative embodiment the functionality of the one or more profile servers and or the location server may be implemented within the MAP server .

The business logic layer includes a profile manager a location manager a history manager a crowd analyzer and an aggregation engine each of which is preferably implemented in software. The profile manager generally operates to obtain the user profiles of the users through N directly or indirectly from the one or more profile servers and store the user profiles in the persistence layer . The location manager operates to obtain the current locations of the users through N including location updates. As discussed below the current locations of the users through N may be obtained directly from the mobile devices through N and or obtained from the location server .

The history manager generally operates to maintain a historical record of anonymized user profile data by location. The crowd analyzer operates to form crowds of users. In one embodiment the crowd analyzer utilizes a spatial crowd formation algorithm. However the present disclosure is not limited thereto. In addition the crowd analyzer may further characterize crowds to reflect degree of fragmentation best case and worst case degree of separation DOS and or degree of bi directionality as discussed below in more detail. Still further the crowd analyzer may also operate to track crowds. The aggregation engine generally operates to provide aggregate profile data in response to requests from the mobile devices through N the subscriber device and the third party service . The aggregate profile data may be historical aggregate profile data for one or more POIs or one or more AOIs or aggregate profile data for crowd s currently at one or more POIs or within one or more AOIs.

The persistence layer includes an object mapping layer and a datastore . The object mapping layer is preferably implemented in software. The datastore is preferably a relational database which is implemented in a combination of hardware i.e. physical data storage hardware and software i.e. relational database software . In this embodiment the business logic layer is implemented in an object oriented programming language such as for example Java. As such the object mapping layer operates to map objects used in the business logic layer to relational database entities stored in the datastore . Note that in one embodiment data is stored in the datastore in a Resource Description Framework RDF compatible format.

In an alternative embodiment rather than being a relational database the datastore may be implemented as an RDF datastore. More specifically the RDF datastore may be compatible with RDF technology adopted by Semantic Web activities. Namely the RDF datastore may use the Friend Of A Friend FOAF vocabulary for describing people their social networks and their interests. In this embodiment the MAP server may be designed to accept raw FOAF files describing persons their friends and their interests. These FOAF files are currently output by some social networking services such as Livejournal and Facebook. The MAP server may then persist RDF descriptions of the users through N as a proprietary extension of the FOAF vocabulary that includes additional properties desired for the MAP system .

At some point after authentication is complete a user profile process is performed such that a user profile of the user is obtained from the profile server and delivered to the MAP server step . In this embodiment the MAP client of the mobile device sends a profile request to the profile server step A . In response the profile server returns the user profile of the user to the mobile device step B . The MAP client of the mobile device then sends the user profile of the user to the MAP server step C . Note that while in this embodiment the MAP client sends the complete user profile of the user to the MAP server in an alternative embodiment the MAP client may filter the user profile of the user according to criteria specified by the user . For example the user profile of the user may include demographic information general interests music interests and movie interests and the user may specify that the demographic information or some subset thereof is to be filtered or removed before sending the user profile to the MAP server .

Upon receiving the user profile of the user from the MAP client of the mobile device the profile manager of the MAP server processes the user profile step D . More specifically in the preferred embodiment the profile manager includes social network handlers for the social network services supported by the MAP server . Thus for example if the MAP server supports user profiles from Facebook MySpace and LinkedIN the profile manager may include a Facebook handler a MySpace handler and a LinkedIN handler. The social network handlers process user profiles to generate user profiles for the MAP server that include lists of keywords for each of a number of profile categories. The profile categories may be the same for each of the social network handlers or different for each of the social network handlers. Thus for this example assume that the user profile of the user is from Facebook. The profile manager uses a Facebook handler to process the user profile of the user to map the user profile of the user from Facebook to a user profile for the MAP server including lists of keywords for a number of predefined profile categories. For example for the Facebook handler the profile categories may be a demographic profile category a social interaction profile category a general interests profile category a music interests profile category and a movie interests profile category. As such the user profile of the user from Facebook may be processed by the Facebook handler of the profile manager to create a list of keywords such as for example liberal High School Graduate 35 44 College Graduate etc. for the demographic profile category a list of keywords such as Seeking Friendship for the social interaction profile category a list of keywords such as politics technology photography books etc. for the general interests profile category a list of keywords including music genres artist names album names or the like for the music interests profile category and a list of keywords including movie titles actor or actress names director names move genres or the like for the movie interests profile category. In one embodiment the profile manager may use natural language processing or semantic analysis. For example if the Facebook user profile of the user states that the user is 20 years old semantic analysis may result in the keyword of 18 24 years old being stored in the user profile of the user for the MAP server .

After processing the user profile of the user the profile manager of the MAP server stores the resulting user profile for the user step E . More specifically in one embodiment the MAP server stores user records for the users through N in the datastore . The user profile of the user is stored in the user record of the user . The user record of the user includes a unique identifier of the user the user profile of the user and as discussed below a current location of the user . Note that the user profile of the user may be updated as desired. For example in one embodiment the user profile of the user is updated by repeating step each time the user activates the MAP application .

Note that while the discussion herein focuses on an embodiment where the user profiles of the users through N are obtained from the one or more profile servers the user profiles of the users through N may be obtained in any desired manner. For example in one alternative embodiment the user may identify one or more favorite websites. The profile manager of the MAP server may then crawl the one or more favorite websites of the user to obtain keywords appearing in the one or more favorite websites of the user . These keywords may then be stored as the user profile of the user .

At some point a process is performed such that a current location of the mobile device and thus a current location of the user is obtained by the MAP server step . In this embodiment the MAP application of the mobile device obtains the current location of the mobile device from the location function of the mobile device . The MAP application then provides the current location of the mobile device to the MAP client and the MAP client then provides the current location of the mobile device to the MAP server step A . Note that step A may be repeated periodically or in response to a change in the current location of the mobile device in order for the MAP application to provide location updates for the user to the MAP server .

In response to receiving the current location of the mobile device the location manager of the MAP server stores the current location of the mobile device as the current location of the user step B . More specifically in one embodiment the current location of the user is stored in the user record of the user maintained in the datastore of the MAP server . Note that only the current location of the user is stored in the user record of the user . In this manner the MAP server maintains privacy for the user since the MAP server does not maintain a historical record of the location of the user . As discussed below in detail historical data maintained by the MAP server is anonymized in order to maintain the privacy of the users through N.

In addition to storing the current location of the user the location manager sends the current location of the user to the location server step C . In this embodiment by providing location updates to the location server the MAP server in return receives location updates for the user from the location server . This is particularly beneficial when the mobile device does not permit background processes which is the case for the Apple iPhone. As such if the mobile device is an Apple iPhone or similar device that does not permit background processes the MAP application will not be able to provide location updates for the user to the MAP server unless the MAP application is active.

Therefore when the MAP application is not active other applications running on the mobile device or some other device of the user may directly or indirectly provide location updates to the location server for the user . This is illustrated in step where the location server receives a location update for the user directly or indirectly from another application running on the mobile device or an application running on another device of the user step A . The location server then provides the location update for the user to the MAP server step B . In response the location manager updates and stores the current location of the user in the user record of the user step C . In this manner the MAP server is enabled to obtain location updates for the user even when the MAP application is not active at the mobile device .

At some point after authentication is complete a user profile process is performed such that a user profile of the user is obtained from the profile server and delivered to the MAP server step . In this embodiment the profile manager of the MAP server sends a profile request to the profile server step A . In response the profile server returns the user profile of the user to the profile manager of the MAP server step B . Note that while in this embodiment the profile server returns the complete user profile of the user to the MAP server in an alternative embodiment the profile server may return a filtered version of the user profile of the user to the MAP server . The profile server may filter the user profile of the user according to criteria specified by the user . For example the user profile of the user may include demographic information general interests music interests and movie interests and the user may specify that the demographic information or some subset thereof is to be filtered or removed before sending the user profile to the MAP server .

Upon receiving the user profile of the user the profile manager of the MAP server processes to the user profile step C . More specifically as discussed above in the preferred embodiment the profile manager includes social network handlers for the social network services supported by the MAP server . The social network handlers process user profiles to generate user profiles for the MAP server that include lists of keywords for each of a number of profile categories. The profile categories may be the same for each of the social network handlers or different for each of the social network handlers.

After processing the user profile of the user the profile manager of the MAP server stores the resulting user profile for the user step D . More specifically in one embodiment the MAP server stores user records for the users through N in the datastore . The user profile of the user is stored in the user record of the user . The user record of the user includes a unique identifier of the user the user profile of the user and as discussed below a current location of the user . Note that the user profile of the user may be updated as desired. For example in one embodiment the user profile of the user is updated by repeating step each time the user activates the MAP application .

Note that the while the discussion herein focuses on an embodiment where the user profiles of the users through N are obtained from the one or more profile servers the user profiles of the users through N may be obtained in any desired manner. For example in one alternative embodiment the user may identify one or more favorite websites. The profile manager of the MAP server may then crawl the one or more favorite websites of the user to obtain keywords appearing in the one or more favorite websites of the user . These keywords may then be stored as the user profile of the user .

At some point a process is performed such that a current location of the mobile device and thus a current location of the user is obtained by the MAP server step . In this embodiment the MAP application of the mobile device obtains the current location of the mobile device from the location function of the mobile device . The MAP application then provides the current location of the user of the mobile device to the location server step A . Note that step A may be repeated periodically or in response to changes in the location of the mobile device in order to provide location updates for the user to the MAP server . The location server then provides the current location of the user to the MAP server step B . The location server may provide the current location of the user to the MAP server automatically in response to receiving the current location of the user from the mobile device or in response to a request from the MAP server .

In response to receiving the current location of the mobile device the location manager of the MAP server stores the current location of the mobile device as the current location of the user step C . More specifically in one embodiment the current location of the user is stored in the user record of the user maintained in the datastore of the MAP server . Note that only the current location of the user is stored in the user record of the user . In this manner the MAP server maintains privacy for the user since the MAP server does not maintain a historical record of the location of the user . As discussed below in detail historical data maintained by the MAP server is anonymized in order to maintain the privacy of the users through N.

As discussed above the use of the location server is particularly beneficial when the mobile device does not permit background processes which is the case for the Apple iPhone. As such if the mobile device is an Apple iPhone or similar device that does not permit background processes the MAP application will not provide location updates for the user to the location server unless the MAP application is active. However other applications running on the mobile device or some other device of the user may provide location updates to the location server for the user when the MAP application is not active. This is illustrated in step where the location server receives a location update for the user from another application running on the mobile device or an application running on another device of the user step A . The location server then provides the location update for the user to the MAP server step B . In response the location manager updates and stores the current location of the user in the user record of the user step C . In this manner the MAP server is enabled to obtain location updates for the user even when the MAP application is not active at the mobile device .

Using the current locations of the users through N and the user profiles of the users through N the MAP server can provide a number of features. A first feature that may be provided by the MAP server is historical storage of anonymized user profile data by location. This historical storage of anonymized user profile data by location is performed by the history manager of the MAP server . More specifically as illustrated in in the preferred embodiment the history manager maintains lists of users located in a number of geographic regions or location buckets. Preferably the location buckets are defined by floor latitude longitude to a desired resolution. The higher the resolution the smaller the size of the location buckets. For example in one embodiment the location buckets are defined by floor latitude longitude to a resolution of 1 10 000of a degree such that the lower left hand corners of the squares illustrated in are defined by the floor latitude longitude values at a resolution of 1 10 000of a degree. In the example of users are represented as dots and location buckets through have lists of 1 3 2 1 1 2 1 2 and 3 users respectively.

As discussed below in detail at a predetermined time interval such as for example 15 minutes the history manager makes a copy of the lists of users in the location buckets anonymizes the user profiles of the users in the lists to provide anonymized user profile data for the corresponding location buckets and stores the anonymized user profile data in a number of history objects. In one embodiment a history object is stored for each location bucket having at least one user. In another embodiment a quadtree algorithm is used to efficiently create history objects for geographic regions i.e. groups of one or more adjoining location buckets .

After determining the location bucket for the location of the user the history manager determines whether the user is new to the location bucket step . In other words the history manager determines whether the user is already on the list of users for the location bucket. If the user is new to the location bucket the history manager creates an entry for the user in the list of users for the location bucket step . Returning to step if the user is not new to the location bucket the history manager updates the entry for the user in the list of users for the location bucket step . At this point whether proceeding from step or the user is flagged as active in the list of users for the location bucket step .

The history manager then determines whether the user has moved from another location bucket step . More specifically the history manager determines whether the user is included in the list of users for another location bucket and is currently flagged as active in that list. If the user has not moved from another location bucket the process proceeds to step . If the user has moved from another location bucket the history manager flags the user as inactive in the list of users for the other location bucket from which the user has moved step .

At this point whether proceeding from step or the history manager determines whether it is time to persist step . More specifically as mentioned above the history manager operates to persist history objects at a predetermined time interval such as for example every 15 minutes. Thus the history manager determines that it is time to persist if the predetermined time interval has expired. If it is not time to persist the process returns to step and is repeated for a next received location update which will typically be for another user. If it is time to persist the history manager creates a copy of the lists of users for the location buckets and passes the copy of the lists to an anonymization and storage process step . In this embodiment the anonymization and storage process is a separate process performed by the history manager . The history manager then removes inactive users from the lists of users for the location buckets step . The process then returns to step and is repeated for a next received location update which will typically be for another user.

For anonymization an anonymous user record is created from the user record . In the anonymous user record the user ID is replaced with a new user ID that is not connected back to the user which is also referred to herein as an anonymous user ID. This new user ID is different than any other user ID used for anonymous user records created from the user record of the user for any previous or subsequent time periods. In this manner anonymous user records for a single user created over time cannot be linked to one another.

In addition anonymous profile category records through M are created for the profile category records through M. In the anonymous profile category records through M the user ID is replaced with a new user ID which may be the same new user ID included in the anonymous user record . The anonymous profile category records through M include the same category IDs and lists of keywords as the corresponding profile category records through M. Note that the location of the user is not stored in the anonymous user record . With respect to location it is sufficient that the anonymous user record is linked to a location bucket.

In another embodiment the history manager performs anonymization in a manner similar to that described above with respect to . However in this embodiment the profile category records for the group of users in a location bucket or the group of users in a number of location buckets representing a node in a quadtree data structure see below may be selectively randomized among the anonymous user records of those users. In other words each anonymous user record would have a user profile including a selectively randomized set of profile category records including keywords from a cumulative list of profile category records for all of the users in the group.

In yet another embodiment rather than creating anonymous user records for the users in the lists maintained for the location buckets the history manager may perform anonymization by storing an aggregate user profile for each location bucket or each group of location buckets representing a node in a quadtree data structure see below . The aggregate user profile may include a list of all keywords and potentially the number of occurrences of each keyword in the user profiles of the corresponding group of users. In this manner the data stored by the history manager is not connected back to the users through N.

Each history object includes location information timing information data and quadtree data structure information. The location information included in the history object defines a combined geographic area of the location bucket s forming the corresponding node of the quadtree data structure. For example the location information may be latitude and longitude coordinates for a northeast corner of the combined geographic area of the node of the quadtree data structure and a southwest corner of the combined geographic area for the node of the quadtree data structure. The timing information includes information defining a time window for the history object which may be for example a start time for the corresponding time interval and an end time for the corresponding time interval. The data includes the anonymized user profile data for the users in the list s maintained for the location bucket s forming the node of the quadtree data structure for which the history object is stored. In addition the data may include a total number of users in the location bucket s forming the node of the quadtree data structure. Lastly the quadtree data structure information includes information defining a quadtree depth of the node in the quadtree data structure.

In order to form the quadtree data structure the history manager determines whether there are any more base quadtree regions to process step . If there are more base quadtree regions to process the history manager sets a current node to the next base quadtree region to process which for the first iteration is the first base quadtree region step . The history manager then determines whether the number of users in the current node is greater than a predefined maximum number of users and whether a current quadtree depth is less than a maximum quadtree depth step . In one embodiment the maximum quadtree depth may be reached when the current node corresponds to a single location bucket. However the maximum quadtree depth may be set such that the maximum quadtree depth is reached before the current node reaches a single location bucket.

If the number of users in the current node is greater than the predefined maximum number of users and the current quadtree depth is less than a maximum quadtree depth the history manager creates a number of child nodes for the current node step . More specifically the history manager creates a child node for each quadrant of the current node. The users in the current node are then assigned to the appropriate child nodes based on the location buckets in which the users are located step and the current node is then set to the first child node step . At this point the process returns to step and is repeated.

Once the number of users in the current node is not greater than the predefined maximum number of users or the maximum quadtree depth has been reached the history manager determines whether the current node has any more sibling nodes step . Sibling nodes are child nodes of the same parent node. If so the history manager sets the current node to the next sibling node of the current node step and the process returns to step and is repeated. Once there are no more sibling nodes to process the history manager determines whether the current node has a parent node step . If so since the parent node has already been processed the history manager determines whether the parent node has any sibling nodes that need to be processed step . If the parent node has any sibling nodes that need to be processed the history manager sets the next sibling node of the parent node to be processed as the current node step . From this point the process returns to step and is repeated. Returning to step if the current node does not have a parent node the process returns to step and is repeated until there are no more base quadtree regions to process. Once there are no more base quadtree regions to process the finished quadtree data structure is returned to the process of such that the history manager can then store the history objects for nodes in the quadtree data structure having at least one user step .

Next the history manager determines whether the number of users in the child node is greater than the predetermined maximum which again for this example is 3. Since the number of users in the child node is greater than 3 the history manager divides the child node into four child nodes through as illustrated in . The child nodes through are children of the child node . The history manager then determines whether the number of users in the child node is greater than the predetermined maximum number of users which again is 3. Since there are more than 3 users in the child node the history manager further divides the child node into four child nodes through N as illustrated in .

The history manager then determines whether the number of users in the child node is greater than the predetermined maximum number of users which again is 3. Since the number of users in the child node is not greater than the predetermined maximum number of users the child node is identified as a node for the finished quadtree data structure and the history manager proceeds to process the sibling nodes of the child node which are the child nodes through . Since the number of users in each of the child nodes through is less than the predetermined maximum number of users the child nodes through are also identified as nodes for the finished quadtree data structure.

Once the history manager has finished processing the child nodes through the history manager identifies the parent node of the child nodes through which in this case is the child node . The history manager then processes the sibling nodes of the child node which are the child nodes through . In this example the number of users in each of the child nodes through is less than the predetermined maximum number of users. As such the child nodes through are identified as nodes for the finished quadtree data structure.

Once the history manager has finished processing the child nodes through the history manager identifies the parent node of the child nodes through which in this case is the child node . The history manager then processes the sibling nodes of the child node which are the child nodes through . More specifically the history manager determines that the child node includes more than the predetermined maximum number of users and as such divides the child node into four child nodes through as illustrated in . Because the number of users in each of the child nodes through is not greater than the predetermined maximum number of users the child nodes through are identified as nodes for the finished quadtree data structure. Then the history manager proceeds to process the child nodes and . Since the number of users in each of the child nodes and is not greater than the predetermined maximum number of users the child nodes and are identified as nodes for the finished quadtree data structure. Thus at completion the quadtree data structure for the base quadtree region includes the child nodes through the child nodes through the child nodes through and the child nodes and as illustrated in .

As discussed above the history manager stores a history object for each of the nodes in the quadtree data structure including at least one user. As such in this example the history manager stores history objects for the child nodes and the child nodes and the child nodes and and the child node . However no history objects are stored for the nodes that do not have any users i.e. the child nodes and the child node the child nodes and and the child node .

In another embodiment the historical request is for an AOI and a time window where the AOI may be an AOI of a geographic area of a predefined shape and size centered at the current location of the user an AOI selected from a list of AOIs defined by the user an AOI selected from a list of AOIs defined by the MAP application or the MAP server an AOI selected by the user from a map an AOI implicitly defined via a separate application e.g. AOI is implicitly defined as an area of a predefined shape and size centered at the location of the nearest Starbucks coffee house in response to the user performing a Google search for Starbucks or the like. If the AOI is selected from a list of AOIs the list of AOIs may include static AOIs dynamic AOIs which may be defined as areas of a predefined shape and size centered at the current locations of one or more friends of the user or both. Note that the POI or AOI of the historical request may be selected by the user via the MAP application . In yet another embodiment the MAP application automatically uses the current location of the user as the POI or as a center point for an AOI of a predefined shape and size.

The time window for the historical request may be relative to the current time. For example the time window may be the last hour the last day the last week the last month or the like. Alternatively the time window may be an arbitrary time window selected by the user such as for example yesterday from 7 pm 9 pm last Friday last week or the like. Note that while in this example the historical request includes a single POI or AOI and a single time window the historical request may include multiple POIs or AOIs and or multiple time windows.

In one embodiment the historical request is made in response to user input from the user of the mobile device . For instance in one embodiment the user selects either a POI or an AOI and a time window and then instructs the MAP application to make the historical request by for example selecting a corresponding button on a graphical user interface. In another embodiment the historical request is made automatically in response to some event such as for example opening the MAP application .

Upon receiving the historical request from the MAP application the MAP client forwards the historical request to the MAP server step . Note that the MAP client may in some cases process the historical request from the MAP application before forwarding the historical request to the MAP server . For example if the historical request from the MAP application is for multiple POIs AOIs and or for multiple time windows the MAP client may process the historical request from the MAP application to produce multiple historical requests to be sent to the MAP server . For instance a separate historical request may be produced for each POI AOI and time window combination. However for this discussion the historical request is for a single POI or AOI for a single time window.

Upon receiving the historical request from the MAP client the MAP server processes the historical request step . More specifically the historical request is processed by the history manager of the MAP server . First the history manager obtains history objects that are relevant to the historical request from the datastore of the MAP server . The relevant history objects are those recorded for locations relevant to the POI or AOI and the time window for the historical request. The history manager then processes the relevant history objects to provide historical aggregate profile data for the POI or AOI in a time context and or a geographic context. In this embodiment the historical aggregate profile data is based on the user profiles of the anonymous user records in the relevant history objects as compared to the user profile of the user or a select subset thereof. In another embodiment the historical aggregate profile data is based on the user profiles of the anonymous user records in the relevant history objects as compared to a target user profile defined or otherwise specified by the user .

As discussed below in detail for the time context the history manager divides the time window for the historical request into a number of time bands. Each time band is a fragment of the time window. Then for each time band the history manager identifies a subset of the relevant history objects that are relevant to the time band i.e. history objects recorded for time periods within the time band or that overlap the time band and generates an aggregate profile for each of those history objects based on the user profiles of the anonymous user records in the history objects and the user profile or a select subset of the user profile of the user . Then the history manager averages or otherwise combines the aggregate profiles for the history objects relevant to the time band. The resulting data for the time bands forms historical aggregate profile data that is to be returned to the MAP client as discussed below.

For the geographic context the history manager generates an average aggregate profile for each of a number of grids surrounding the POI or within the AOI. More specifically history objects relevant to the POI or the AOI and the time window of the historical request are obtained. Then the user profiles of the anonymous users in the relevant history objects are used to generate average aggregate profiles for a number of grids or geographic regions at or surrounding the POI or the AOI. These average aggregate profiles for the grids form historical aggregate profile data that is to be returned to the MAP client as discussed below.

Once the MAP server has processed the historical request the MAP server returns the resulting historical aggregate profile data to the MAP client step . As discussed above the historical aggregate profile data may be in a time context or a geographic context. In an alternative embodiment the data returned to the MAP client may be raw historical data. The raw historical data may be the relevant history objects or data from the relevant history objects such as for example the user records in the relevant history objects the user profiles of the anonymous user records in the relevant history objects or the like.

Upon receiving the historical aggregate profile data the MAP client passes the historical aggregate profile data to the MAP application step . Note that in an alternative embodiment where the data returned by the MAP server is raw historical data the MAP client may process the raw historical data to provide desired data. For example the MAP client may process the raw historical data in order to generate average aggregate profiles for time bands within the time window of the historical request and or to generate average aggregate profiles for regions near the POI or within the AOI of the historical request in a manner similar to that described above. The MAP application then presents the historical aggregate profile data to the user step .

Next the history manager obtains history objects relevant to the bounding box and the time window for the historical request from the datastore of the MAP server step . The relevant history objects are history objects recorded for time periods within or intersecting the time window and for locations or geographic areas within or intersecting the bounding box for the historical request. The history manager also determines an output time band size step . In one exemplary embodiment the output time band size is 1 100of the amount of time from the start of the time window to the end of the time window for the historical request. For example if the amount of time in the time window for the historical request is one week the output time band size may be set to 1 100of a week which is 1.68 hours or 1 hour and 41 minutes.

The history manager then sorts the relevant history objects into the appropriate output time bands of the time window for the historical request. More specifically in this embodiment the history manager creates an empty list for each of output time band of the time window step . Then the history manager gets the next history object from the history objects identified in step as being relevant to the historical request step and adds that history object to the list s for the appropriate output time band s step . Note that if the history object is recorded for a time period that overlaps two or more of the output time bands then the history object may be added to all of the output time bands to which the history object is relevant. The history manager then determines whether there are more relevant history objects to sort into the output time bands step . If so the process returns to step and is repeated until all of the relevant history objects have been sorted into the appropriate output time bands.

Once sorting is complete the history manager determines an equivalent depth of the bounding box D within the quadtree data structures used to store the history objects step . More specifically the area of the base quadtree region e.g. the base quadtree region is referred to as A. Then at each depth of the quadtree the area of the corresponding quadtree nodes is A. In other words the area of a child node is of the area of the parent node of that child node. The history manager determines the equivalent depth of the bounding box D by determining a quadtree depth at which the area of the corresponding quadtree nodes most closely matches an area of the bounding box A .

Note that equivalent quadtree depth of the bounding box D determined in step is used below in order to efficiently determine the ratios of the area of the bounding box A to areas of the relevant history objects A . However in an alternative embodiment the ratios of the area of the bounding box A to the areas of the relevant history objects A may be otherwise computed in which case step would not be needed.

At this point the process proceeds to where the history manager gets the list for the next output time band of the time window for the historical request step . The history manager then gets the next history object in the list for the output time band step . Next the history manager sets a relevancy weight for the history object where the relevancy weight is indicative of a relevancy of the history object to the bounding box step . For instance a history object includes anonymized user profile data for a corresponding geographic area. If that geographic area is within or significantly overlaps the bounding box then the history object will have a high relevancy weight. However if the geographic area only overlaps the bounding box slightly then the history object will have a low relevancy weight. In this embodiment the relevancy weight for the history object is set to an approximate ratio of the area of the bounding box A to an area of the history object A computed based on a difference between the quadtree depth of the history object D and the equivalent quadtree depth of the bounding box D . The quadtree depth of the history object D is stored in the history object. More specifically in one embodiment the relevancy weight of the history object is set according to the following 

Next the history manager generates an aggregate profile for the history object using the user profile of the requesting user which for this example is the user or a select subset thereof step . Note that the requesting user may be enabled to select a subset of his user profile to be compared to the user profiles of the anonymous user records in the history objects by for example selecting one or more desired profile categories. In order to generate the aggregate profile for the history object the history manager compares the user profile of the user or the select subset thereof to the user profiles of the anonymous user records stored in the history object. The resulting aggregate profile for the history object includes a number of user matches and a total number of users. In the embodiment where user profiles include lists of keywords for a number of profile categories the number of user matches is the number of anonymous user records in the history object having user profiles that include at least one keyword that matches at least one keyword in the user profile of the user or at least one keyword in the select subset of the user profile of the user . The total number of users is the total number of anonymous user records in the history object. In addition or alternatively the aggregate profile for the history object may include a list of keywords from the user profile of the user or the select subset of the user profile of the user having at least one user match. Still further the aggregate profile for the history object may include the number of user matches for each of the keywords from the user profile of the user or the select subset of the user profile of the user having at least one user match.

The history manager then determines whether there are more history objects in the list for the output time band step . If so the process returns to step and is repeated until all of the history objects in the list for the output time band have been processed. Once all of the history objects in the list for the output time band have been processed the history manager combines the aggregate profiles of the history objects in the output time band to provide a combined aggregate profile for the output time band. More specifically in this embodiment the history manager computes a weighted average of the aggregate profiles for the history objects in the output time band using the relevancy weights of the history objects step . In one embodiment the aggregate profile of each of the history objects includes the number of user matches for the history object and the total number of users for the history object. In this embodiment the weighted average of the aggregate profiles of the history objects in the output time band i.e. the average aggregate profile for the output time band includes the weighted average of the number of user matches for all of the history objects in the output time band which may be computed as 

In addition or alternatively if the aggregate profiles for the history objects in the output time band include the number of user matches for each keyword in the user profile of the user or the select subset thereof having at least one user match the average aggregate profile for the output time band may include a weighted average of the number of user matches for each of those keywords which may be computed as 

Next the history manager determines whether there are more output time bands to process step . If so the process returns to step and is repeated until the lists for all output time bands have been processed. Once all of the output time bands have been processed the history manager outputs the combined aggregate profiles for the output time bands. More specifically in this embodiment the history manager outputs the weighted average aggregate profiles computed in step for the output time bands as the historical aggregate profile data to be returned to the mobile device step .

Using the average aggregate profiles for the output time bands included in the historical aggregate profile data the MAP application generates a timeline for the time window of the historical request. The timeline is a graphical illustration of the average aggregate profiles for the output time bands. For example if the average aggregate profile for each of the output time bands includes a weighted average of the number of user matches and a weighted average of the number of total users for the output time band the timeline may be indicative of the ratio of the weighted average of user matches to the weighted average of total users for each of the output time bands. In this example the output time bands having a ratio of weighted average of user matches to weighted average of total users that is less than 0.25 are represented as having a low similarity the output time bands having a ratio of weighted average of user matches to weighted average of total users that is in the range of 0.25 0.75 are represented as having varying degrees of intermediate similarity and the output time bands having a ratio of weighted average of user matches to weighted average of total users that is greater than 0.75 are represented as having a high similarity. Note that output time bands for which there are no history objects may be grayed out or otherwise indicated.

In addition in this example the GUI also includes a second timeline that zooms in on an area of the timeline that includes the most activity or that includes the greatest number of output time bands having a high or medium similarity. Lastly in this example the GUI includes an aggregate profile for a crowd that is currently at the POI. Note that crowds and aggregate profiles for the crowds are discussed below in detail.

Next the history manager obtains history objects relevant to the bounding box and the time window of the historical request from the datastore of the MAP server step . The relevant history objects are history objects recorded for time periods within or intersecting the time window and for locations or geographic areas within or intersecting the bounding box for the historical request. The history manager then sorts the relevant history objects into base quadtree regions. More specifically in this embodiment the history manager creates an empty list for each relevant base quadtree region step . A relevant base quadtree region is a base quadtree region within which all or at least a portion of the bounding box is located. Therefore for example if a bounding box is located at the intersection of four base quadtree regions such that the bounding box overlaps a portion of each of the four base quadtree regions then all four of the bounding boxes would be identified as relevant base quadtree regions. In contrast if the bounding box is contained within a single base quadtree region then that base quadtree region is the only relevant base quadtree region.

The history manager then gets the next history object from the history objects identified in step as being relevant to the historical request step and adds that history object to the list for the appropriate base quadtree region step . The history manager then determines whether there are more relevant history objects to sort step . If so the process returns to step and is repeated until all of the relevant history objects have been sorted into the appropriate base quadtree regions.

Once sorting is complete the process proceeds to . The following steps generally operate to divide each base quadtree region into a grid where a size of each grid location is set to a smallest history record size of all the history objects sorted into the list for that base quadtree region. Using the history objects in the base quadtree region aggregate profiles are generated for each of the grid locations covered by the history object. Then a combined aggregate profile is generated for each grid location based on the aggregate profiles generated using the corresponding history objects.

More specifically the history manager gets the list for the next base quadtree region step . The history manager then gets the next history object in the list for the base quadtree region step . Next the history manager creates an aggregate profile for the history object using the user profile of the requesting user which in this example is the user or a select subset of the user profile of the requesting user step . Note that the user may be enabled to select a subset of his user profile to be used for aggregate profile creation by for example selecting one or more profile categories. In order to generate the aggregate profile for the history object the history manager compares the user profile of the user or the select subset thereof to the user profiles of the anonymous user records stored in the history object. The resulting aggregate profile for the history object includes a number of user matches and a total number of users. In the embodiment where user profiles include lists of keywords for a number of profile categories the number of user matches is the number of anonymous user records in the history object having user profiles that include at least one keyword that matches at least one keyword in the user profile of the user or at least one keyword in the select subset of the user profile of the user . The total number of users is the total number of anonymous user records in the history object.

Next the history manager determines whether a size of the history object is greater than the smallest history object size in the list of history objects for the base quadtree region step . If not the aggregate profile for the history object is added to an output list for the corresponding grid location for the base quadtree region step and the process proceeds to step . If the size of the history object is greater than the smallest history object size the history manager splits the geographic area or location of the history object into a number of grid locations each of the smallest history object size of all the history objects in the list for the base quadtree region step . The history manager then divides the aggregate profile of the history object evenly over the grid locations for the history object step and adds resulting aggregate profiles for the grid locations to output lists for those grid locations step . For example if the geographic area of the history object is split into four grid locations and the aggregate profile for the history object includes eight user matches and sixteen total users then the aggregate profile is divided evenly over the four grid locations such that each of the four grid locations is given an aggregate profile of two user matches and four total users.

The history manager then determines whether there are more history objects to process for the base quadtree region step . If so the process returns to step and is repeated until all of the history objects for the base quadtree region are processed. At that point for each grid location in the base quadtree region having at least one aggregate profile in its output list the history manager combines the aggregate profiles in the output list for the grid location to provide a combined aggregate profile for the grid location. More specifically in this embodiment the history manager computes average aggregate profiles for the grid locations for the base quadtree region step . In one embodiment for each grid location the average aggregate profile for the grid location includes an average number of user matches and an average total number of users for all of the aggregate profiles in the output list for that grid location.

Next the history manager determines whether there are more relevant base quadtree regions to process step . If so the process returns to step and is repeated until all of the relevant base quadtree regions have been processed. At that point the history manager outputs the grid locations and the average aggregate profiles for the grid locations in each of the relevant base quadtree regions step . The grid locations and their corresponding average aggregate profiles form the historical aggregate profile data that is returned to the mobile device of the user in response to the historical request.

It should be noted that while the aggregate profiles in are generated based on the user profile of the user or a select subset of the user profile of the user the aggregate profiles may alternatively be generated based on a target user profile defined or otherwise specified by the user . For example the user may define a target profile for a type of person with which the user would like to interact. Then by making a historical request with the target profile the user can learn whether people matching the target profile are historically located at a POI or an AOI.

Upon receiving the historical request the MAP server processes the historical request step . More specifically as discussed above the historical request is processed by the history manager of the MAP server . First the history manager obtains history objects that are relevant to the historical request from the datastore of the MAP server . The relevant history objects are those relevant to the POI or the AOI and the time window for the historical request. The history manager then processes the relevant history objects to provide historical aggregate profile data for the POI or the AOI in a time context and or a geographic context. In this embodiment the historical aggregate profile data is based on comparisons of the user profiles of the anonymous user records in the relevant history objects to one another. In another embodiment the aggregate profile data is based on comparisons of the user profiles of the anonymous user records in the relevant history objects and a target user profile.

Once the MAP server has processed the historical request the MAP server returns the resulting historical aggregate profile data to the subscriber device step . The historical aggregate profile data may be in the time context or the geographic context. In this embodiment where the historical aggregate profile data is to be presented via the web browser of the subscriber device the MAP server formats the historical aggregate profile data in a suitable format before sending the historical aggregate profile data to the web browser of the subscriber device . Upon receiving the historical aggregate profile data the web browser of the subscriber device presents the historical aggregate profile data to the user step .

More specifically in this embodiment since the historical request is from the subscriber the aggregate profile for the history object is generated by comparing the user profiles of the anonymous user records in the history object to one another. In this embodiment the aggregate profile for the history object includes an aggregate list of keywords from the user profiles of the anonymous user records the number of occurrences of each of those keywords in the user profiles of the anonymous user records and the total number of anonymous user records in the history object. As such in step the weighted average of the aggregate profiles for the history objects in the output time band may provide an average aggregate profile including for each keyword occurring in the aggregate profile of at least one of the history objects a weighted average of the number of occurrences of the keyword. In addition the average aggregate profile may include a weighted average of the total number of anonymous user records in the history objects. In addition or alternatively the average aggregate profile may include for each keyword a weighted average of the number of occurrences of the keyword to the total number of anonymous user records.

More specifically in this embodiment since the historical request is from the subscriber the aggregate profile for the history object is generated by comparing the user profiles of the anonymous user records in the history object to one another. In this embodiment the aggregate profile for the history object includes an aggregate list of keywords from the user profiles of the anonymous user records the number of occurrences of each of those keywords in the user profiles of the anonymous user records and the total number of anonymous user records in the history object. As such in step the weighted average of the aggregate profiles for the each of the grid locations may provide an average aggregate profile including for each keyword a weighted average of the number of occurrences of the keyword. In addition the average aggregate profile for each grid location may include a weighted average of the total number of anonymous user records. In addition or alternatively the average aggregate profile for each grid location may include for each keyword a weighted average of the number of occurrences of the keyword to the total number of anonymous user records.

First the crowd analyzer establishes a bounding box for the crowd formation process step . Note that while a bounding box is used in this example other geographic shapes may be used to define a bounding region for the crowd formation process e.g. a bounding circle . In one embodiment if crowd formation is performed in response to a specific request the bounding box is established based on the POI or the AOI of the request. If the request is for a POI then the bounding box is a geographic area of a predetermined size centered at the POI. If the request is for an AOI the bounding box is the AOI. Alternatively if the crowd formation process is performed proactively the bounding box is a bounding box of a predefined size.

The crowd analyzer then creates a crowd for each individual user in the bounding box step . More specifically the crowd analyzer queries the datastore of the MAP server to identify users currently located within the bounding box. Then a crowd of one user is created for each user currently located within the bounding box. Next the crowd analyzer determines the two closest crowds in the bounding box step and determines a distance between the two crowds step . The distance between the two crowds is a distance between crowd centers of the two crowds. Note that the crowd center of a crowd of one is the current location of the user in the crowd. The crowd analyzer then determines whether the distance between the two crowds is less than an optimal inclusion distance step . In this embodiment the optimal inclusion distance is a predefined static distance. If the distance between the two crowds is less than the optimal inclusion distance the crowd analyzer combines the two crowds step and computes a new crowd center for the resulting crowd step . The crowd center may be computed based on the current locations of the users in the crowd using a center of mass algorithm. At this point the process returns to step and is repeated until the distance between the two closest crowds is not less than the optimal inclusion distance. At that point the crowd analyzer discards any crowds with less than three users step . Note that throughout this disclosure crowds are only maintained if the crowds include three or more users. However while three users is the preferred minimum number of users in a crowd the present disclosure is not limited thereto. The minimum number of users in a crowd may be defined as any number greater than or equal to two users.

Next the crowd analyzer determines whether the new and old bounding boxes overlap step . If so the crowd analyzer creates a bounding box encompassing the new and old bounding boxes step . For example if the new and old bounding boxes are 40 40 meter regions and a 1 1 meter square at the northeast corner of the new bounding box overlaps a 1 1 meter square at the southwest corner of the old bounding box the crowd analyzer may create a 79 79 meter square bounding box encompassing both the new and old bounding boxes.

The crowd analyzer then determines the individual users and crowds relevant to the bounding box created in step step . The crowds relevant to the bounding box are crowds that are within or overlap the bounding box e.g. have at least one user located within the bounding box . The individual users relevant to the bounding box are users that are currently located within the bounding box and not already part of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . More specifically in one embodiment the optimal inclusion distance for individuals which is also referred to herein as an initial optimal inclusion distance is set according to the following equation 

The crowd analyzer then creates a crowd for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . At this point the process proceeds to where the crowd analyzer analyzes the crowds relevant to the bounding box to determine whether any of the crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd step . The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds for the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is less than the optimal inclusion distance the two closest crowds are combined or merged step and a new crowd center for the resulting crowd is computed step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the resulting crowd is computed step . In one embodiment the new optimal inclusion distance for the resulting crowd is computed as 

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . The maximum number of iterations is a predefined number that ensures that the crowd formation process does not indefinitely loop over steps through or loop over steps through more than a desired maximum number of times. If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer discards crowds with less than three users or members step and the process ends.

Returning to step in if the new and old bounding boxes do not overlap the process proceeds to and the bounding box to be processed is set to the old bounding box step . In general the crowd analyzer then processes the old bounding box in much the same manner as described above with respect to steps through . More specifically the crowd analyzer determines the individual users and crowds relevant to the bounding box step . The crowds relevant to the bounding box are crowds that are within or overlap the bounding box e.g. have at least one user located within the bounding box . The individual users relevant to the bounding box are users that are currently located within the bounding box and not already part of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . More specifically in one embodiment the optimal inclusion distance for individuals which is also referred to herein as an initial optimal inclusion distance is set according to the following equation 

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . At this point the crowd analyzer analyzes the crowds for the bounding box to determine whether any crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd step . The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is less than the optimal inclusion distance the two closest crowds are combined or merged step and a new crowd center for the resulting crowd is computed step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the resulting crowd is computed step . As discussed above in one embodiment the new optimal inclusion distance for the resulting crowd is computed as 

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer discards crowds with less than three users or members step . The crowd analyzer then determines whether the crowd formation process for the new and old bounding boxes is done step . In other words the crowd analyzer determines whether both the new and old bounding boxes have been processed. If not the bounding box is set to the new bounding box step and the process returns to step and is repeated for the new bounding box. Once both the new and old bounding box have been processed the crowd formation process ends.

The crowd analyzer then identifies the two closest crowds and in the bounding box and determines a distance between the two closest crowds and . In this example the distance between the two closest crowds and is less than the optimal inclusion distance. As such the two closest crowds and are merged and a new crowd center and new optimal inclusion distance are computed as illustrated in . The crowd analyzer then repeats the process such that the two closest crowds and in the bounding box are again merged as illustrated in . At this point the distance between the two closest crowds and is greater than the appropriate optimal inclusion distance. As such the crowd formation process is complete.

Since the old bounding box and the new bounding box overlap the crowd analyzer creates a bounding box that encompasses both the old bounding box and the new bounding box as illustrated in . In addition the crowd analyzer creates crowds through for individual users currently located within the bounding box . The optimal inclusion distances of the crowds through are set to the initial optimal inclusion distance computed by the crowd analyzer based on the density of users in the bounding box .

Next the crowd analyzer analyzes the crowds and through to determine whether any members of the crowds and through violate the optimal inclusion distances of the crowds and through . In this example as a result of the user leaving the crowd and moving to his new location both of the remaining members of the crowd violate the optimal inclusion distance of the crowd . As such the crowd analyzer removes the remaining users from the crowd and creates crowds and of one user each for those users as illustrated in .

The crowd analyzer then identifies the two closest crowds in the bounding box which in this example are the crowds and . Next the crowd analyzer computes a distance between the two crowds and . In this example the distance between the two crowds and is less than the initial optimal inclusion distance and as such the two crowds and are combined. In this example crowds are combined by merging the smaller crowd into the larger crowd. Since the two crowds and are of the same size the crowd analyzer merges the crowd into the crowd as illustrated in . A new crowd center and new optimal inclusion distance are then computed for the crowd .

At this point the crowd analyzer repeats the process and determines that the crowds and are now the two closest crowds. In this example the distance between the two crowds and is less than the optimal inclusion distance of the larger of the two crowds and which is the crowd . As such the crowd is merged into the crowd and a new crowd center and optimal inclusion distance are computed for the crowd as illustrated in . At this point there are no two crowds closer than the optimal inclusion distance of the larger of the two crowds. As such the crowd analyzer discards any crowds having less than three members as illustrated in . In this example the crowds and have less than three members and are therefore removed. The crowd has three or more members and as such is not removed. At this point the crowd formation process is complete.

More specifically as illustrated in as a result of the movement of the user from the old location to the new location the remaining users in the crowd no longer satisfy the optimal inclusion distance for the crowd . As such the remaining users in the crowd are removed from the crowd and crowds and of one user each are created for the removed users as shown in . In this example no two crowds in the old bounding box are close enough to be combined. As such processing of the old bounding box is complete and the crowd analyzer proceeds to process the new bounding box .

As illustrated in processing of the new bounding box begins by the crowd analyzer creating a crowd of one user for the user. The crowd analyzer then identifies the crowds and as the two closest crowds in the new bounding box and determines a distance between the two crowds and . In this example the distance between the two crowds and is less than the optimal inclusion distance of the larger crowd which is the crowd . As such the crowd analyzer combines the crowds and by merging the crowd into the crowd as illustrated in . A new crowd center and new optimal inclusion distance are then computed for the crowd . At this point the crowd formation process is complete.

Before proceeding a variation of the spatial formation process discussed above with respect to will be described. In this alternative embodiment a location accuracy of the location update from the user received in step is considered. More specifically in step the location update received by the MAP server includes the updated location of the user as well as a location accuracy for the location of the user which may be expressed as for example a radius in meters from the location of the user . In the embodiment where the location of the user is obtained from a GPS receiver of the mobile device the location accuracy of the location of the user may be provided by the GPS receiver or derived from data from the GPS receiver as well be appreciated by one having ordinary skill in the art.

Then in steps and sizes of the new and old bounding boxes centered at the new and old locations of the user are set as a function of the location accuracy of the new and old locations of the user . If the new location of the user is inaccurate then the new bounding box will be large. If the new location of the user is accurate then the new bounding box will be small. For example the length and width of the new bounding box may be set to M times the location accuracy of the new location of the user where the location accuracy is expressed as a radius in meters from the new location of the user . The number M may be any desired number. For example the number M may be 5. In a similar manner the location accuracy of the old location of the user may be used to set the length and width of the old bounding box.

In addition the location accuracy may be considered when computing the initial optimal inclusion distances used for crowds of one user in steps and . As discussed above the initial optimal inclusion distance is computed based on the following equation 

Likewise when new optimal inclusion distances for crowds are recomputed in steps and location accuracy may also be considered. As discussed above the new optimal inclusion distance may first be computed based on the following equation 

First the MAP application sends a crowd request to the MAP client step . The crowd request is a request for crowd data for crowds currently formed near a specified POI or within a specified AOI. The crowd request may be initiated by the user of the mobile device via the MAP application or may be initiated automatically by the MAP application in response to an event such as for example start up of the MAP application movement of the user or the like. In one embodiment the crowd request is for a POI where the POI is a POI corresponding to the current location of the user a POI selected from a list of POIs defined by the user a POI selected from a list of POIs defined by the MAP application or the MAP server a POI selected by the user from a map a POI implicitly defined via a separate application e.g. POI is implicitly defined as the location of the nearest Starbucks coffee house in response to the user performing a Google search for Starbucks or the like. If the POI is selected from a list of POIs the list of POIs may include static POIs which may be defined by street addresses or latitude and longitude coordinates dynamic POIs which may be defined as the current locations of one or more friends of the user or both. Note that in some embodiments the user may be enabled to define a POI by selecting a crowd center of a crowd as a POI where the POI would thereafter remain static at that point and would not follow the crowd.

In another embodiment the crowd request is for an AOI where the AOI may be an AOI of a predefined shape and size centered at the current location of the user an AOI selected from a list of AOIs defined by the user an AOI selected from a list of AOIs defined by the MAP application or the MAP server an AOI selected by the user from a map an AOI implicitly defined via a separate application e.g. AOI is implicitly defined as an area of a predefined shape and size centered at the location of the nearest Starbucks coffee house in response to the user performing a Google search for Starbucks or the like. If the AOI is selected from a list of AOIs the list of AOIs may include static AOIs dynamic AOIs which may be defined as areas of a predefined shape and size centered at the current locations of one or more friends of the user or both. Note that in some embodiments the user may be enabled to define an AOI by selecting a crowd such that an AOI is created of a predefined shape and size centered at the crowd center of the selected crowd. The AOI would thereafter remain static and would not follow the crowd. The POI or the AOI of the crowd request may be selected by the user via the MAP application . In yet another embodiment the MAP application automatically uses the current location of the user as the POI or as a center point for an AOI of a predefined shape and size.

Upon receiving the crowd request the MAP client forwards the crowd request to the MAP server step . Note that in some embodiments the MAP client may process the crowd request before forwarding the crowd request to the MAP server . For example in some embodiments the crowd request may include more than one POI or more than one AOI. As such the MAP client may generate a separate crowd request for each POI or each AOI.

In response to receiving the crowd request from the MAP client the MAP server identifies one or more crowds relevant to the crowd request step . More specifically in one embodiment the crowd analyzer performs a crowd formation process such as that described above in to form one or more crowds relevant to the POI or the AOI of the crowd request. In another embodiment the crowd analyzer proactively forms crowds using a process such as that described above in and stores corresponding crowd records in the datastore of the MAP server . Then rather than forming the relevant crowds in response to the crowd request the crowd analyzer queries the datastore to identify the crowds that are relevant to the crowd request. The crowds relevant to the crowd request may be those crowds within or intersecting a bounding region such as a bounding box for the crowd request. If the crowd request is for a POI the bounding region is a geographic region of a predefined shape and size centered at the POI. If the crowd request is for an AOI the bounding region is the AOI.

Once the crowd analyzer has identified the crowds relevant to the crowd request the MAP server generates crowd data for the identified crowds step . As discussed below in detail the crowd data for the identified crowds may include aggregate profiles for the crowds information characterizing the crowds or both. In addition the crowd data may include spatial information defining the locations of the crowds the number of users in the crowds the amount of time the crowds have been located at or near the POI or within the AOI of the crowd request or the like. The MAP server then returns the crowd data to the MAP client step .

Upon receiving the crowd data the MAP client forwards the crowd data to the MAP application step . Note that in some embodiments the MAP client may process the crowd data before sending the crowd data to the MAP application . The MAP application then presents the crowd data to the user step . The manner in which the crowd data is presented depends on the particular implementation of the MAP application . In one embodiment the crowd data is overlaid upon a map. For example the crowds may be represented by corresponding indicators overlaid on a map. The user may then select a crowd in order to view additional crowd data regarding that crowd such as for example the aggregate profile of that crowd characteristics of that crowd or the like.

Note that in one embodiment the MAP application may operate to roll up the aggregate profiles for multiple crowds into a rolled up aggregate profile for those crowds. The rolled up aggregate profile may be the average of the aggregate profiles of the crowds. For example the MAP application may roll up the aggregate profiles for multiple crowds at a POI and present the rolled up aggregate profile for the multiple crowds at the POI to the user . In a similar manner the MAP application may provide a rolled up aggregate profile for an AOI. In another embodiment the MAP server may roll up crowds for a POI or an AOI and provide the rolled up aggregate profile in addition to or as an alternative to the aggregate profiles for the individual crowds.

More specifically after the crowd analyzer has identified the crowds relevant to the current request the identified crowds are passed to the aggregation engine . The aggregation engine selects a next crowd to process which for the first iteration is the first crowd step A . The aggregation engine then selects the next user in the crowd step A . Next the aggregation engine compares the user profile of the user in the crowd to the user profile of the requesting user which for this example is the user of the mobile device or a select subset of the user profile of the requesting user step A . In some embodiments the user may be enabled to select a subset of his user profile to be used for generation of the aggregate profile. For example in the embodiment where user profiles are expressed as keywords in a number of profile categories the user may select one or more of the profile categories to be used for aggregate profile generation. When comparing the user profile of the user in the crowd to the user profile of the user the aggregation engine identifies matches between the user profile of the user in the crowd and the user profile of the user or the select subset of the user profile of the user . In one embodiment the user profiles are expressed as keywords in a number of profile categories. The aggregation engine may then make a list of keywords from the user profile of the user in the crowd that match keywords in user profile of the user or the select subset of the user profile of the user .

Next the aggregation engine determines whether there are more users in the crowd step A . If so the process returns to step A and is repeated for the next user in the crowd. Once all of the users in the crowd have been processed the aggregation engine generates an aggregate profile for the crowd based on data resulting from the comparisons of the user profiles of the users in the crowd to the user profile of the user or the select subset of the user profile of the user step A . In an alternative embodiment the aggregation engine generates an aggregate profile for the crowd based on data resulting from the comparisons of the user profiles of the users in the crowd to a target user profile defined or otherwise specified by the user . In one embodiment the data resulting from the comparisons is a list of matching keywords for each of the users in the crowd. The aggregate profile may then include a number of user matches over all keywords and or a ratio of the number of user matches over all keywords to the number of users in the crowd. The number of user matches over all keywords is a number of users in the crowd having at least one keyword in their user profile that matches a keyword in the user profile of the user or the select subset of the user profile of the user . The aggregate profile may additionally or alternatively include for each keyword in the user profile of the user or the select subset of the user profile of the user a number of user matches for the keyword or a ratio of the number of user matches for the keyword to the number of users in the crowd. Note that keywords in the user profile of the user or the select subset of the user profile of the user that have no user matches may be excluded from the aggregate profile. In addition the aggregate profile for the crowd may include a total number of users in the crowd.

The aggregate profile for the crowd may additionally or alternatively include a match strength that is indicative of a degree of similarity between the user profiles of the users in the crowd and the user profile of the user . The match strength may be computed as a ratio of the number of user matches to the total number of users in the crowd. Alternatively the match strength may be computed as a function of the number of user matches per keyword and keyword weights assigned to the keywords. The keyword weights may be assigned by the user .

Once the aggregate profile of the crowd is generated the aggregation engine determines whether there are more crowds to process step A . If so the process returns to step A and is repeated for the next crowd. Once aggregate profiles have been generated for all of the crowds relevant to the current request the aggregate profiles for the crowds are returned step A . More specifically the aggregate profiles are included in the crowd data returned to the MAP client in response to the current request.

Note that in some embodiments the user is enabled to activate a nearby POIs feature. If this feature is enabled the crowds identified by the crowd analyzer and processed by the aggregation engine to produce corresponding aggregate profiles may also include crowds located at or near any nearby POIs. The nearby POIs may be POIs predefined by the user the MAP application and or the MAP server that are within a predefined distance from the POI or the AOI of the current request.

More specifically after the crowd analyzer has identified the crowds relevant to the current request the identified crowds are passed to the aggregation engine . The aggregation engine selects a next crowd to process which for the first iteration is the first crowd step B . The aggregation engine then selects the next user in the crowd step B . Next the aggregation engine compares the user profile of the user in the crowd to the user profile of the requesting user which for this example is the user of the mobile device or a select subset of the user profile of the requesting user step B . In some embodiments the user may be enabled to select a subset of his user profile to be used for generation of the aggregate profile. For example in the embodiment where user profiles are expressed as keywords in a number of profile categories the user may select one or more of the profile categories to be used for aggregate profile generation. When comparing the user profile of the user in the crowd to the user profile of the user the aggregation engine identifies matches between the user profile of the user in the crowd and the user profile of the user or the select subset of the user profile of the user . In this embodiment the user profiles are expressed as keywords in a number of profile categories. The aggregation engine may then make a list of keywords from the user profile of the user in the crowd that match keywords in user profile of the user or the select subset of the user profile of the user .

Next the aggregation engine determines whether there are more users in the crowd step B . If so the process returns to step B and is repeated for the next user in the crowd. Once all of the users in the crowd have been processed the aggregation engine generates an aggregate profile for the crowd based on data resulting from the comparisons of the user profiles of the users in the crowd to the user profile of the user or the select subset of the user profile of the user step B . In an alternative embodiment the aggregation engine generates an aggregate profile for the crowd based on data resulting from the comparisons of the user profiles of the users in the crowd to a target user profile defined or otherwise specified by the user . In this embodiment the data resulting from the comparisons is a list of matching keywords for each of the users in the crowd. The aggregate profile may then include a number of user matches over all keywords and or a ratio of the number of user matches over all keywords to the number of users in the crowd. The number of user matches over all keywords is a number of users in the crowd having at least one keyword in their user profile that matches a keyword in the user profile of the user or the select subset of the user profile of the user . The aggregate profile may additionally or alternatively include for each keyword in the user profile of the user or the select subset of the user profile of the user a number of user matches for the keyword or a ratio of the number of user matches for the keyword to the number of users in the crowd. Note that keywords in the user profile of the user or the select subset of the user profile of the user that have no user matches may be excluded from the aggregate profile. In addition the aggregate profile for the crowd may include a total number of users in the crowd.

The aggregate profile for the crowd may additionally or alternatively include a match strength that is indicative of a degree of similarity between the user profiles of the users in the crowd and the user profile of the user . The match strength may be computed as a ratio of the number of user matches to the total number of users in the crowd. Alternatively the match strength may be computed as a function of the number of user matches per keyword and keyword weights assigned to the keywords. The keyword weights may be assigned by the user .

Once the aggregate profile of the crowd is generated in this embodiment the aggregation engine compares the user profiles of the users in the crowd to one another to determine N keywords having the highest number of user matches among the users in the crowd step B . Here N may be for example five. The aggregation engine then adds any of the N keywords that are not already in the aggregate profile to the aggregate profile and flags those keywords as non matching keywords step B . These keywords are flagged as non matching because they do not match any of the keywords in the user profile or select subset thereof of the user . The non matching keywords are preferably differentiated from the matching keywords in the aggregate profile when presented to the user . The non matching keywords are particularly beneficial where there are few or no matching keywords between the user profile of the user and the user profiles of the users in the crowd. In this situation the non matching keywords would allow the user to gain some understanding of the interests of the users in the crowd.

Next the aggregation engine determines whether there are more crowds to process step B . If so the process returns to step B and is repeated for the next crowd. Once aggregate profiles have been generated for all of the crowds relevant to the current request the aggregate profiles for the crowds are returned step B . More specifically the aggregate profiles are included in the crowd data returned to the MAP client in response to the current request.

Note that in some embodiments the user is enabled to activate a nearby POIs feature. If this feature is enabled the crowds identified by the crowd analyzer and processed by the aggregation engine to produce corresponding aggregate profiles may also include crowds located at or near any nearby POIs. The nearby POIs may be POIs predefined by the user the MAP application and or the MAP server that are within a predefined distance from the POI or the AOI of the current request.

In response to receiving the crowd request from the subscriber device the MAP server identifies one or more crowds relevant to the crowd request step . More specifically in one embodiment the crowd analyzer performs a crowd formation process such as that described above in to form one or more crowds relevant to the POI or the AOI of the crowd request. In another embodiment the crowd analyzer proactively forms crowds using a process such as that described above in and stores corresponding crowd records in the datastore of the MAP server . Then rather than forming the relevant crowds in response to the crowd request the crowd analyzer queries the datastore to identify the crowds that are relevant to the crowd request. The crowds relevant to the crowd request may be those crowds within or overlapping a bounding region such as a bounding box for the crowd request. If the crowd request is for a POI the bounding region is a geographic region of a predefined shape and size centered at the POI. If the crowd request is for an AOI the bounding region is the AOI.

Once the crowd analyzer has identified the crowds relevant to the crowd request the MAP server generates crowd data for the identified crowds step . The crowd data for the identified crowds may include aggregate profiles for the crowds information characterizing the crowds or both. In addition the crowd data may include the locations of the crowds the number of users in the crowds the amount of time the crowds have been located at or near the POI or within the AOI or the like. The MAP server then returns the crowd data to the MAP client step . In the embodiment where the subscriber accesses the MAP server via the web browser at the subscriber device the MAP server formats the crowd data into a suitable web format before sending the crowd data to the subscriber device . The manner in which the crowd data is formatted depends on the particular implementation. In one embodiment the crowd data is overlaid upon a map. For example in one embodiment the MAP server may provide the crowd data to the subscriber device via one or more web pages. Using the one or more web pages crowd indicators representative of the locations of the crowds may be overlaid on a map. The subscriber may then select a crowd in order to view additional crowd data regarding that crowd such as for example the aggregate profile of that crowd characteristics of that crowd or the like. Upon receiving the crowd data the subscriber device presents the crowd data to the subscriber step . Note that in one embodiment the MAP server may roll up the aggregate profiles for multiple crowds at a POI or in an AOI to provide a rolled up aggregate profile that may be returned in addition to or as an alternative to the aggregate profiles of the individual crowds.

It should be noted that in some embodiments the subscriber may be enabled to specify filtering criteria via the web browser or a custom application for interacting with the MAP server . For example the subscriber may specify filtering criteria regarding types of crowds in which the subscriber is or is not interested. For instance the crowd data may be presented to the subscriber via one or more web pages that enable the subscriber to select a filtering feature. In response a list of keywords appearing in the user profiles of the crowds identified as being relevant to the current request may be presented to the subscriber . The subscriber may then specify one or more keywords from the list such that crowds having users with user profiles that do not include any of the specified keywords are filtered or removed and are therefore not considered when generating the crowd data in response to a crowd request.

More specifically after the crowd analyzer has identified the crowds relevant to the crowd request the identified crowds are passed to the aggregation engine . The aggregation engine selects a next crowd to process which for the first iteration is the first crowd step . The aggregation engine then generates an aggregate profile for the crowd based on a comparison of the user profiles of the users in the crowd to one another step . Note that in an alternative embodiment the aggregation engine then generates an aggregate profile for the crowd based on a comparison of the user profiles of the users in the crowd to a target user profile defined by the subscriber .

In one embodiment in order to generate the aggregate profile for the crowd the user profiles are expressed as keywords for each of a number of profile categories. Then the aggregation engine may determine an aggregate list of keywords for the crowd. The aggregate list of keywords is a list of all keywords appearing in the user profiles of the users in the crowd. The aggregate profile for the crowd may then include a number of user matches for each keyword in the aggregate list of keywords for the crowd. The number of user matches for a keyword is the number of users in the crowd having a user profile that includes that keyword. The aggregate profile may include the number of user matches for all keywords in the aggregate list of keywords for the crowd or the number of user matches for keywords in the aggregate list of keywords for the crowd having more than a predefined number of user matches e.g. more than 1 user match . The aggregate profile may also include the number of users in the crowd. In addition or alternatively the aggregate profile may include for each keyword in the aggregate list or each keyword in the aggregate list having more than a predefined number of user matches a ratio of the number of user matches for the keyword to the number of users in the crowd.

Once the aggregate profile of the crowd is generated the aggregation engine determines whether there are more crowds to process step . If so the process returns to step and is repeated for the next crowd. Once aggregate profiles have been generated for all of the crowds relevant to the crowd request the aggregate profiles for the crowds are returned step . Note that in some embodiments the subscriber is enabled to activate a nearby POIs feature. If this feature is enabled the crowds identified by the crowd analyzer and processed by the aggregation engine to produce corresponding aggregate profiles may also include crowds located at or near any nearby POIs. The nearby POIs may be POIs predefined by the subscriber and or the MAP server that are within a predefined distance from the POI or the AOI of the crowd request.

The settings screen also enables the user to configure a number of privacy settings. Namely the settings screen enables the user to set a stealth mode switch to either an on position or an off position. When the stealth mode switch is in the on position the location of the user is not reported to the friends of the user . However the location of the user is still reported for use by the MAP server . The privacy settings also include a location refresh setting that enables the user to configure how often location updates are to be sent by the MAP application . Lastly the settings screen includes an alerts setting that enables the user to configure one or more alerts. As discussed below an alert can be tied to a particular POI or AOI such that the user is alerted or notified when a crowd at the particular POI or AOI satisfies one or more specified criteria. Alternatively an alert can be tied to a particular crowd such that the user is alerted or notified when the crowd satisfies one or more specified criteria.

Returning to the profile setting if the user selects the profile setting a user profile screen is presented to the user via the GUI as illustrated in . The user profile screen shows a number of profile categories A through E and corresponding lists of keywords A through E which form the user profile of the user . The user is enabled to select one or more of the profile categories A through E to be used for aggregate profile generation i.e. comparison to user profiles for history objects and crowds to create corresponding aggregate profiles for the user . In this example the user has selected his My Interests profile category C where the corresponding list of keywords C define general interests of the user . In the user profile screen the user can return to the settings screen by selecting a settings button .

In this example the user has selected the all button . As such the list screen presents an AOI list that includes a number of AOIs previously defined by the user . Note that each of the AOIs may be a static AOI defining a static geographic area or a dynamic AOI that is defined relative to a dynamic location such as a location of a friend of the user . For instance in this example the Near Jack Shephard AOI is a geographic area of a defined shape and size that is centered at the current location of the user s friend Jack Shephard. Note that in one embodiment persons whose current locations may be used for dynamic AOIs are limited to the friends of the user . The user may select an AOI from the AOI list in order to view crowd data for the AOI. For example by selecting the My Neighborhood AOI the GUI may present a map including the My Neighborhood AOI. Crowds relevant to the My Neighborhood AOI are presented on the map. The user may then select a desired crowd in order to view detailed information regarding that crowd such as for example the aggregate profile of the crowd characteristics of the crowd or both.

The list screen also presents a crowds list that includes a number of crowds that are at the POIs or within the AOIs of the user . In this example there are twelve crowds. The GUI enables the user to select a crowd from the crowds list in order to view additional information regarding the crowd. For example by selecting the Crowd of 6 the user may be presented with a map showing the current location of the Crowd of 6 and detailed information regarding the Crowd of 6 such as for example the aggregate profile of the Crowd of 6 characteristics of the Crowd of 6 or both.

The list screen also includes a friends list as illustrated in . The user may select a friend from the friends list in order to view crowds nearby that friend. In other words the current locations of the friends of the user are treated as temporary or dynamic POIs such that crowd data for current locations of the friends of the user is obtained from the MAP server . In addition the user may choose to define an AOI centered at the current location of a friend to create a dynamic AOI as discussed above. The friends list also presents the current location of the friends of the user relative to the current location of the user .

The list screen also includes a POI list that includes a number of POIs of the user . The user may select a POI from the POI list in order to view crowd data for the POI. For example by selecting the Steve s house POI the GUI may present a map including the Steve s house POI. Crowds at or near the Steve s house POI are presented on the map. The user may then select a desired crowd in order to view detailed information regarding that crowd such as for example the aggregate profile of the crowd characteristics of the crowd or both. Lastly returning to the list screen includes a You item that may be selected by the user to access the user profile screen .

Using the GUI the user is enabled to select a particular crowd in the map area to view more detailed information for that crowd in a crowd detail area of the crowd data display screen . In this example the user has selected the crowd indicator . As a result more detailed information for the crowd represented by the crowd indicator is presented in the crowd detail area . The more detailed information for the crowd is from the crowd data for the crowd or derived from the crowd data for the crowd. In this example the aggregate profile of the crowd is used to derive the match strength for the crowd and the match strength is presented in the crowd detail area . In addition the crowd size and number of user matches over all keywords are obtained from the aggregate profile for the crowd and presented in the crowd detail area . In this example a quality factor for the crowd is also presented. As discussed below in detail the quality factor of the crowd may be an average of a quality or confidence of the current locations of the users in the crowd. Still further the crowd data display screen includes a keyword matches area for presenting keyword matches for the selected crowd. In this example a font size of the keywords in the keyword matches area reflects the number of user matches for that keyword. Therefore in this example the number of user matches for the keyword technology is greater than the number of user matches for the keyword books. 

More specifically illustrates the web interface when the realtime tab has been selected by the subscriber . When the realtime tab is selected the web interface presents a map area that shows an AOI and a number of crowds through currently located within the AOI . In addition in this exemplary embodiment crowds and that are outside the AOI are also illustrated. The crowds and are crowds located at other POIs or within other AOIs of the subscriber that are not currently being viewed by the subscriber . The subscriber may view another POI or AOI by selecting the desired POI or AOI from a list presented in response to selection of a button . In this example POIs and AOIs are generically referred to as watch zones.

In this example the subscriber selects the crowd . In response the web interface presents an aggregate profile window to the subscriber as illustrated in . The aggregate profile window presents an aggregate profile of the crowd where in this embodiment the aggregate profile is in the form of an interest histogram showing the number of user matches in the crowd for each of a number of keywords. The subscriber may be enabled to create an alert for the crowd by selecting a create an alert button . In response the subscriber may be enabled to utilize the keywords in the aggregate profile window to create an alert. For example the subscriber may create an alert such that the subscriber is notified when the number of user matches for the keyword Sushi in the crowd reaches one hundred. The subscriber may also be enabled to create a report for the crowd by selecting a create a report button . The report may for example include details about the crowd such as for example the location of the crowd the size of the crowd the aggregate profile of the crowd the current time and date or the like where the report may be saved or printed by the subscriber .

In addition the subscriber may be enabled to create a filter by selecting a create a filter button . In response to selecting the create a filter button a new filter screen is presented to the subscriber as illustrated in . The subscriber may then select keywords from the interest histogram for the crowd to be used for the filter. In addition the subscriber may be enabled to add new keywords to the filter by selecting an add keywords button . Once the subscriber has configured the filter the subscriber is enabled to create the filter by selecting a create button . Once the filter is created the filter may be used to filter crowds for any AOI or POI of the subscriber .

The crowd analyzer then determines whether the distance between the two closest crowd fragments is less than an optimal inclusion distance for a crowd fragment step . In one embodiment the optimal inclusion distance for a crowd fragment is a predefined static value. In another embodiment the optimal inclusion distance of the crowd may vary. For example if the spatial crowd formation process of is used for proactive crowd formation then the optimal inclusion distance for the crowd may vary. As such the optimal inclusion distance for a crowd fragment within the crowd may be defined as a fraction of the optimal inclusion distance of the crowd such that the optimal inclusion distance for a crowd fragment within the crowd varies along with the optimal inclusion distance for the crowd itself.

If the distance between the two closest crowd fragments is less than the optimal inclusion distance for a crowd fragment then the two closest crowd fragments are combined step and a new crowd fragment center is computed for the resulting crowd fragment step . The crowd fragment center may be computed using for example a center of mass algorithm. At this point the process returns to step and is repeated. Once the two closest crowd fragments in the crowd are separated by more than the optimal inclusion distance for a crowd fragment the process ends. At this point the crowd analyzer has created the crowd fragments or defined the crowd fragments for the crowd. The crowd analyzer may then represent the degree of fragmentation of the crowd based on the number of crowd fragments in the crowd and optionally an average number of users per crowd fragment. The degree of fragmentation of the crowd may be included in the crowd data returned to the requesting device in response to a crowd request for a POI or an AOI to which the crowd is relevant.

The crowd analyzer then determines whether the DOS between the two users is less than a predefined maximum DOS for a crowd fragment step . For example the predefined maximum DOS may be three. However other maximum DOS values may be used to achieve the desired crowd fragmentation. If the DOS between the two users is not less than the predefined maximum DOS the process proceeds to step . If the DOS between the two users is less than the predefined maximum DOS the crowd analyzer determines whether a bidirectionality requirement is satisfied step . The bidirectionality requirement specifies whether the relationship between the two users must be bidirectional i.e. the first user must directly or indirectly know the second user and the second user must directly or indirectly know the first user . Bidirectionality may or may not be required depending on the particular embodiment. If the two users satisfy the bidirectionality requirement the crowd analyzer combines the pair of crowd fragments step and computes a new crowd fragment center for the resulting crowd fragment step . The process then returns to step and is repeated for a next pair of crowd fragments. If the two users do not satisfy the bidirectionality requirement the process proceeds to step .

At this point whether proceeding from step or step the crowd analyzer determines whether all user pairs from the two crowd fragments have been processed step . If not the process returns to step and is repeated for a new pair of users from the two crowd fragments. If all user pairs from the two crowd fragments have been processed the crowd analyzer then determines whether all crowd fragments have been processed step . If not the process returns to step and is repeated until all crowd fragments have been processed. Once this process is complete the crowd analyzer has determined the number of crowd fragments in the crowd. The degree of fragmentation of the crowd may then be provided as the number of crowd fragments and the average number of users per crowd fragment.

The crowd analyzer then computes a best case average DOS for the crowd fragment using a best case DOS for the user pairs in the crowd fragment for which explicit relationships are not defined step . In this embodiment the best case average DOS is 1. The best case average DOS may computed as 

The crowd analyzer also computes the worst case average DOS for the crowd fragment using a worst case DOS for the user pairs in the crowd fragment for which explicit relationships are not defined step . In this embodiment the worst case DOS is a greatest possible DOS that the crowd analyzer considers which may be for example a DOS of greater than or equal to 7. For instance the worst case DOS may be 10. However other values for the worst case DOS may be used. The worst case average DOS may computed as 

Once all of the friends of the user have been processed the crowd analyzer performs steps through recursively for each newly found friend incrementing the current DOS for each recursion up to a maximum number of recursions step . Newly found friends are friends added to the found member list in the iteration or recursion of steps through just completed. In more general terms steps through operate to find friends of the user selected in step that are also members of the crowd fragment and increment the found count for a DOS of 1 for each of the found friends of the user. Then for each friend of the user that was found to also be a member of the crowd fragment the crowd analyzer finds friends of that friend of the user that are also members of the crowd fragment and increments the found count for a DOS of 2 for each of the found friends of the friend of the user. The process continues in this manner to count the number of user relationships between the user selected in step and other members in the crowd fragment up to the Mth DOS.

Next the crowd analyzer determines a count of users in the crowd fragment that were not found as being directly or indirectly related to the user selected in step step . More specifically by looking at the found member list and the total number of users in the crowd fragment the crowd analyzer is enabled to determine the count of users in the crowd fragment that were not found as being directly or indirectly related to the user.

At this point the crowd analyzer determines whether there are more users in the crowd fragment to process step . If so the process returns to step and is repeated for the next user in the crowd fragment. Once all of the users in the crowd fragment have been processed the crowd analyzer computes a best case average DOS for the crowd fragment step . Again in one embodiment the best case average DOS for the crowd fragment is computed as 

In addition the crowd analyzer computes a worst case average DOS for the crowd fragment step . Again in one embodiment the worst case average DOS for the crowd fragment is computed as 

At this point whether proceeding from step step or step the crowd analyzer determines whether the user has more friends to process step . If so the process returns to step and is repeated for the next friend of the user. Once all of the friends of the user have been processed the crowd analyzer determines whether there are more users in the crowd fragment step . If so the process returns to step and is repeated for the next user in the crowd fragment. Once steps through have been performed for all of the users in the crowd fragment the crowd analyzer computes a ratio of the bidirectional count i.e. the number of bidirectional friend relationships over the connection count i.e. the number of unidirectional and bidirectional friend relationships for the crowd fragment step . At this point the process ends. In this embodiment the ratio of the bidirectionality count to the connection count reflects the degree of bidirectionality of friendship relationships for the crowd fragment and may be returned to the requesting user or subscriber in the crowd data for the corresponding crowd.

First the crowd analyzer of the MAP server computes confidence levels for the current locations of the users in the crowd step . In one embodiment the confidence level for the current location of a user ranges from 0 to 1 where the confidence level is set to 1 when the current location is updated and then linearly decreases to 0 over some desired period of time. As such the confidence level of the current location of a user may be computed based on the following equation where CLis the confidence level of the current location of the user t is an amount of time that has elapsed since the confidence level of the current location of the user was last computed DR is a predefined decrease rate or rate at which the confidence level is to decrease over time and CLis the previous confidence level of the current location of the user. The decrease rate DR is preferably selected such that the confidence level CL of the current location of the user will decrease from 1 to 0 over a desired amount of time. Note that the decrease rate DR may be defined separately for each user or may be the same for all users. If defined separately the decrease rate DR for a user may be defined once and re used or defined on a case by case basis based on the user s current and past locations profile history or the like. The desired amount of time may be any desired amount of time such as but not limited to a desired number of hours. As an example the desired amount of time may be 12 hours and the corresponding decrease rate DR is 1 12 if time is measured in hours and 1 12 60 60 1000 if time is measures in milliseconds. Note that the MAP server stores the confidence level CL of the user a timestamp indicating when the confidence level CL was computed and optionally a timestamp indicating when the current location of the user was last updated. This information may be stored in the user record for the user. Alternatively only the timestamp of the last location update is stored in the user record for the user. If the initial confidence level CL varies per user the initial confidence level CL is also stored in the user record. The current confidence level CL is determined whenever it is needed by retrieving the last location update timestamp from the user record determining an amount of elapsed time between the current time and the time of the last location update and calculating the new confidence level based on the decrease rate DR and the initial confidence level CL . Also note that while the confidence levels of the current locations of the users in the crowd are computed using a linear algorithm in the exemplary embodiment described above nonlinear algorithms may alternatively be used.

When computing the confidence levels for the current locations of the users in the crowds the crowd analyzer may also consider location confidence events. Note that timestamps of such location confidence events and the location confidence events themselves may also be stored to enable correct calculation of the confidence levels. The location confidence events may include negative location confidence events such as but not limited to the passing of a known closing time of a business e.g. restaurant bar shopping mall etc. at which a user is located or movement of a crowd with which a user has a high affinity. The location confidence events may additionally or alternatively include positive location confidence events such as but not limited to frequent interaction with the corresponding MAP application by the user. Frequent interaction with the MAP application by the user may be indicated by reception of frequent location updates for the user. Note that in addition to or as an alternative to using location confidence events other information such as location profiles event information e.g. live music event open mic night etc. current as past crowd histories or the like may be used when computing the confidence levels for the current locations of the users in the crowds.

The manner in which the crowd analyzer handles positive and or negative location confidence events when computing the confidence levels of the users in the crowd may vary. In one embodiment in response to detecting a negative location confidence event with respect to a user the crowd analyzer may increase the decrease rate DR used to compute the confidence level CL of the current location of the user. Similarly in response to detecting a positive location confidence event with respect to a user the crowd analyzer may decrease the decrease rate DR used to compute the confidence level CL of the current location of the user or replace the decrease rate DR with an increase rate such that the confidence level of the user increases in response to the location confidence event or while the location confidence event continues e.g. increase while the user frequently interacts with the MAP application .

In another embodiment in response to detecting a negative location confidence event with respect to a user the crowd analyzer may decrease the confidence level CL of the current location of the user by a predefined amount. For example if the negative location event is the passing of a closing time of a business at which the user is located the crowd analyzer may decrease the confidence level CL of the user to zero. Similarly in response to detecting a positive location confidence event with respect to a user the crowd analyzer may increase the confidence level CL of the current location of the user by a predefined amount. For example in response to detecting that the user is frequently interacting with the MAP application at his mobile device the crowd analyzer may increase the confidence level CL of the current location of the user by 0.1.

Once the confidence levels of the current locations of the users in the crowd are computed the crowd analyzer determines a quality level for the aggregate profile of the crowd step . In one embodiment the quality level for the crowd is computed as an average of the confidence levels of the current locations of the users in the crowd. The quality level of the aggregate profile may then be provided along with the aggregate profile in the crowd data for the crowd returned to the requestor.

In order to generate confidence factors for each keyword in an aggregate profile for a crowd the crowd analyzer of the MAP server computes confidence levels for the current locations of the users in the crowd step . The confidence levels for the current locations of the users may be computed as discussed above with respect to step of . In general the confidence levels for the current locations of the users may be computed based on an amount of time since the current location of the user was last updated location confidence events or both. Once the confidence levels of the current locations of the users in the crowd are computed the crowd analyzer determines a confidence level for each keyword in the aggregate profile of the crowd based on the confidence levels for the current locations of the corresponding users step . In one embodiment for each keyword the confidence level for the keyword is computed as an average of the confidence levels of the current locations of the users in the crowd having user profiles including the keyword. In other words for each keyword there are a number of user matches. The confidence levels of the current locations of the users corresponding to the user matches for the keyword are averaged to provide the confidence level for the keyword.

At time 3 the confidence level of the current location of the user is updated. The confidence level of the current location of the user may be updated by the crowd analyzer before generating an aggregate profile for a crowd in which the user is included. In this example since a location confidence event is not detected at time 3 the confidence level for the current location of the user is computed based on the previous confidence level computed at time 3 and a predefined decrease rate. As such the confidence level for the current location of the user at time 3 is less than the confidence level for the current location of the user at time 2.

At time 4 a negative location confidence event is detected. As a result in this example the decrease rate is increased and the confidence level for the current location of the user at time 4 is computed based on the new decrease rate. As such the confidence level for the current location of the user at time 4 is less than the confidence level for the current location of the user at time 3. Based on the new decrease rate the confidence level for the current location of the user continues to decrease until reaching 0 at approximately 4.5 hours after time 0. Alternatively in response to the negative location confidence event the confidence level for the current location of the user at time 4 may be decreased by a predefined amount in addition to or as an alternative to decreasing the confidence level by an amount determined by the amount of time that has elapsed between time 3 and time 4 and the decrease rate.

The MAP server and more specifically the crowd analyzer then determines whether a size of the bounding box is greater than a predefined maximum size step . While not illustrated if the size of the bounding box is not greater than the predefined maximum size the crowd analyzer identifies crowds relevant to the bounding box obtains crowd data for the crowds and returns the crowd data to the MAP client in the manner described above. However in this embodiment the size of the bounding box is greater than the predefined maximum size. As such the crowd analyzer identifies one or more hotspots within the bounding box step . More specifically the MAP server maintains a list of hotspots and the one or more hotspots within the bounding box are selected from the list of hotspots. In general a hotspot is a geographic point e.g. latitude and longitude coordinates a physical address or the like where a significant number of crowds have historically been located and or where a significant number of crowds are currently located.

In one embodiment the MAP server and more specifically the crowd analyzer monitors crowds over time and identifies geographic points near which a significant number of crowds are typically located as hotspots. In another embodiment hotspots may be defined by the users through N in a collaborative process. For example the users through N may be enabled to nominate geographic points e.g. POIs latitude and longitude coordinates a street address or the like as hotspots. Once a geographic point or substantially the same geographic point receives a predefined minimum number of nominations the geographic point is defined as a hotspot. The geographic point may remain a hotspot permanently. Alternatively the geographic point may be removed as a hotspot if one or more removal criteria are satisfied such as for example receiving a predefined threshold number of nominations for removal as a hotspot over a defined amount of time. In yet another embodiment persons or entities may pay a fee to have desired geographic points listed as hotspots. For example a business owner may pay a fee to have the MAP server list the physical location of his or her business as a hotspot.

Once the hotspots within the bounding box for the request are identified the crowd analyzer obtains crowd data for the hotspots step . More specifically in one embodiment the crowd analyzer establishes initial request regions of a predefined shape and size centered at the hotspots. The initial request regions are preferably an optimal shape and size. Using the initial request regions centered at the hotspots the crowd analyzer identifies crowds relevant to the initial request regions centered at the hotspots. As discussed above the crowd analyzer may identify the crowds by performing a spatial crowd formation process in response to the request. Alternatively the crowds may be formed proactively and corresponding crowd records may be stored in the datastore of the MAP server . In this case the crowd analyzer identifies the crowds relevant to the initial request regions centered at the hotspots by querying the datastore of the MAP server . The crowd analyzer then obtains crowd data for the identified crowds. As discussed above the identified crowds may be passed to the aggregation engine which may then generate aggregate profiles for the crowds. In addition or alternatively the crowd analyzer may determine characteristics of the crowds such as for example degree of fragmentation best case and worst case average DOS degree of bidirectionality or the like.

In addition the crowd analyzer determines a needed number of follow up requests to be performed by the MAP client in order to obtain crowd data for the rest of the bounding box established for the crowd request step . In one embodiment follow up requests are used to obtain crowd data for a series of one or more outwardly radiating concentric request regions around each of the hotspots. Each request region is a geographic region. Each follow up request is for a corresponding one of the series of outwardly radiating concentric request regions around the hotspots. The number of needed follow up requests depends on the number of hotspots in the bounding box the size of the outwardly radiating concentric request regions for the follow up requests and the size of the bounding box. The crowd analyzer of the MAP server then sends the crowd data for the hotspots and the needed number of follow up requests to the MAP client step . The MAP client then sends the crowd data for the hotspots to the MAP application step and the MAP application presents the crowd data for the hotspots to the user step .

In addition to providing the crowd data for the hotspots to the MAP application the MAP client sends a follow up request to the MAP server step . In response the crowd analyzer of the MAP server obtains crowd data for the follow up request step . More specifically the crowd analyzer identifies the request regions for the follow up request. The crowd analyzer then identifies crowds relevant to the request regions for the follow up request and obtains crowd data for the identified crowds. Note that any redundant crowd data may be eliminated by carefully structuring the request regions to prevent overlapping of bounding regions from the same follow up request. Alternatively either the crowds or the resulting crowd data may be filtered at the MAP server or the MAP client to remove redundant crowds or crowd data. The crowd analyzer of the MAP server then sends the crowd data for the follow up request to the MAP client step . The MAP client then sends the crowd data for the follow up request to the MAP application step and the MAP application presents the crowd data to the user step .

In this embodiment the needed number of follow up requests is greater than one. As such the MAP client sends a second follow up request to the MAP server step . In response the crowd analyzer of the MAP server obtains crowd data for the second follow up request step . More specifically the crowd analyzer identifies the request regions for the follow up request. The crowd analyzer then identifies crowds that are relevant to the request regions for the follow up request and obtains crowd data for the identified crowds. Again note that any redundant crowd data may be eliminated by carefully structuring the request regions to prevent overlapping of request regions from the same follow up request or previous follow up requests. Alternatively either the crowds or the resulting crowd data may be filtered at the MAP server or the MAP client to remove redundant crowds or crowd data. The crowd analyzer of the MAP server then sends the crowd data for the follow up request to the MAP client step . The MAP client then sends the crowd data for the follow up request to the MAP application step and the MAP application presents the crowd data to the user step . This process continues until crowd data for all of the follow up requests has been obtained or until the process is otherwise terminated. For example the process may be otherwise terminated if the user initiates a crowd request for a different POI or AOI if the user deactivates the MAP application or the like.

The discussion above with respect to provides a process for handling a request for crowd data for a large geographic area by first focusing on hotspots within the large geographic area and then progressing outwardly from those hotspots to progressively provide crowd data for the large geographic area to the requestor. In another embodiment a request for a large geographic area may be handled by first focusing on locations within the large geographic area such as locations of friends of the requestor and or POIs previously defined or selected by the requestor and then progressing outwardly from those locations until crowd data for the large geographic area is returned to the requestor. These other locations may be used in addition to or as an alternative to hotspots. These other locations may be used in the same manner described above with respect to hotspots in order to divide a request for a large geographic area into an initial request and a number of follow up requests.

In yet another embodiment when a request for crowd data for a large geographic area is received by the MAP server crowds within the large geographic area may be identified and corresponding crowd data is obtained. The MAP server may then first return the crowd data for crowds satisfying predefined criteria. For example the MAP server may return the crowd data for the crowds according to match strength between the user profiles of the users in the crowd and the user profile of the requesting user a select portion of the user profile of the requesting user or a target profile defined or otherwise specified by the requesting user. In this manner the most relevant crowd data may be returned to the requesting user first.

It should be noted that while the process described above with respect to focuses on a request from one of the mobile devices through N a similar process may be used internally at the MAP server to process requests for crowd data for large geographic areas from the subscriber device and or the third party service . For example upon receiving a request for crowd data for a large geographic area from the subscriber device via the web browser the MAP server may first obtain and return crowd data for one or more hotspots within the large geographic area and then progressively return crowd data for outwardly radiating concentric areas around the hotspots.

Each of the user records includes an ID field a location field a profile field a crowd field and a previous crowd field. The ID field stores a unique ID for one of the users through N for which the user record is stored. The location field stores the current location of the user which may be defined by latitude and longitude coordinates and optionally an altitude. The profile field stores the user profile of the user which may be defined as a list of keywords for one or more profile categories. The crowd field is used to store a reference to a crowd record of a crowd of which the user is currently a member. The previous crowd field may be used to store a reference to a crowd record of a crowd of which the user was previously a member.

Each of the crowd snapshot records includes an anonymous users field a NE corner field a SW corner field a center field a sample time field and a vertices field. The anonymous users field stores a set or list of anonymous user records which are anonymized versions of user records for the users that are in the crowd at a time the crowd snapshot was created. The NE corner field stores a location corresponding to a NE corner of a bounding box for the crowd at the time the crowd snapshot was created. The NE corner may be defined by latitude and longitude coordinates and optionally an altitude. Similarly the SW corner field stores a location of a SW corner of the bounding box for the crowd at the time the crowd snapshot was created. Like the NE corner the SW corner may be defined by latitude and longitude coordinates and optionally an altitude. The center field stores a location corresponding to a center of the crowd at the time the crowd snapshot was created. The center of the crowd may be defined by latitude and longitude coordinates and optionally an altitude. Together the NE corner the SW corner and the center of the crowd form spatial information defining the location of the crowd at the time the crowd snapshot was created. Note however that the spatial information defining the location of the crowd at the time the crowd snapshot was created may include additional or alternative information depending on the particular implementation. The sample time field stores a timestamp indicating a time at which the crowd snapshot was created. The timestamp preferably includes a date and a time of day at which the crowd snapshot was created. The vertices field stores locations of users in the crowd at the time the crowd snapshot was created that define an actual outer boundary of the crowd e.g. as a polygon at the time the crowd snapshot was created. Note that the actual outer boundary of a crowd may be used to show the location of the crowd when displayed to a user.

Each of the anonymous user records includes an anonymous ID field and a profile field. The anonymous ID field stores an anonymous user ID which is preferably a unique user ID that is not tied or linked back to any of the users through N and particularly not tied back to the user or the user record for which the anonymous user record has been created. In one embodiment the anonymous user records for a crowd snapshot record are anonymized versions of the user records of the users in the crowd at the time the crowd snapshot was created. The manner in which the user records are anonymized to create the anonymous user records may be the same as that described above with respect to maintaining a historical record of anonymized user profile data according to location. The profile field stores the anonymized user profile of the anonymous user which may be defined as a list of keywords for one or more profile categories.

Next the crowd analyzer determines whether the new and old bounding boxes overlap step . If so the crowd analyzer creates a bounding box encompassing the new and old bounding boxes step . For example if the new and old bounding boxes are 40 40 meter regions and a 1 1 meter square at the northeast corner of the new bounding box overlaps a 1 1 meter square at the southwest corner of the old bounding box the crowd analyzer may create a 79 79 meter square bounding box encompassing both the new and old bounding boxes.

The crowd analyzer then determines the individual users and crowds relevant to the bounding box created in step step . Note that the crowds relevant to the bounding box are pre existing crowds resulting from previous iterations of the spatial crowd formation process. In this embodiment the crowds relevant to the bounding box are crowds having crowd bounding boxes that are within or overlap the bounding box established in step . In order to determine the relevant crowds the crowd analyzer queries the datastore of the MAP server to obtain crowd records for crowds that are within or overlap the bounding box established in step . The individual users relevant to the bounding box are users that are currently located within the bounding box and are not already members of a crowd. In order to identify the relevant individual users the crowd analyzer queries the datastore of the MAP server for user records of users that are currently located in the bounding box created in step and are not already members of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . The optimal inclusion distance may be computed as described above with respect to step of .

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box established in step that is not already included in a crowd and sets the optimal inclusion distance for those crowds to the initial optimal inclusion distance step . The crowds created for the individual users are temporary crowds created for purposes of performing the crowd formation process. At this point the process proceeds to where the crowd analyzer analyzes the crowds in the bounding box established in step to determine whether any of the crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd and the previous crowd fields in the corresponding user records are set step . More specifically in this embodiment a member is removed from a crowd by removing the user record of the member from the set or list of user records in the crowd record of the crowd and setting the previous crowd stored in the user record of the user to the crowd from which the member has been removed. The crowd analyzer then creates a crowd of one user for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds which are stored in the crowd records for the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two crowds.

If the distance between the two closest crowds is greater than the optimal inclusion distance the process proceeds to step . However if the distance between the two closest crowds is less than the optimal inclusion distance the two crowds are merged step . The manner in which the two crowds are merged differs depending on whether the two crowds are pre existing crowds or temporary crowds created for the spatial crowd formation process. If both crowds are pre existing crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd and setting the merged into field of the non surviving crowd to a reference to the crowd record of the surviving crowd. In addition the crowd analyzer sets the previous crowd fields of the user records in the set or list of user records from the non surviving crowd to a reference to the crowd record of the non surviving crowd.

If one of the crowds is a temporary crowd and the other crowd is a pre existing crowd the temporary crowd is selected as the non surviving crowd and the pre existing crowd is selected as the surviving crowd. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records from the crowd record of the non surviving crowd to the set or list of user records in the crowd record of the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

If both the crowds are temporary crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

Next the crowd analyzer removes the non surviving crowd step . In this embodiment the manner in which the non surviving crowd is removed depends on whether the non surviving crowd is a pre existing crowd or a temporary crowd. If the non surviving crowd is a pre existing crowd the removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the non surviving crowd. In this manner the spatial information for the non surviving crowd is removed from the corresponding crowd record such that the non surviving or removed crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the non surviving crowd are still available via the crowd record for the non surviving crowd. In contrast if the non surviving crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record.

The crowd analyzer also computes a new crowd center for the surviving crowd step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the surviving crowd is computed step . In one embodiment the new optimal inclusion distance for the surviving crowd is computed in the manner described above with respect to step of .

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . The maximum number of iterations is a predefined number that ensures that the crowd formation process does not indefinitely loop over steps through or loop over steps through more than a desired maximum number of times. If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer removes crowds with less than three users or members step and the process ends. As discussed above in this embodiment the manner in which a crowd is removed depends on whether the crowd is a pre existing crowd or a temporary crowd. If the crowd is a pre existing crowd a removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the crowd. In this manner the spatial information for the crowd is removed from the corresponding crowd record such that the crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the crowd are still available via the crowd record for the crowd. In contrast if the crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record. In this manner crowds having less than three members are removed in order to maintain privacy of individuals as well as groups of two users e.g. a couple .

Returning to step in if the new and old bounding boxes do not overlap the process proceeds to and the bounding box to be processed is set to the old bounding box step . In general the crowd analyzer then processes the old bounding box in much that same manner as described above with respect to steps through . More specifically the crowd analyzer determines the individual users and crowds relevant to the bounding box step . Again note that the crowds relevant to the bounding box are pre existing crowds resulting from previous iterations of the spatial crowd formation process. In this embodiment the crowds relevant to the bounding box are crowds having crowd bounding boxes that are within or overlap the bounding box. The individual users relevant to the bounding box are users that are currently located within the bounding box and are not already members of a crowd. Next the crowd analyzer computes an optimal inclusion distance for individual users based on user density within the bounding box step . The optimal inclusion distance may be computed as described above with respect to step of .

The crowd analyzer then creates a crowd of one user for each individual user within the bounding box that is not already included in a crowd and sets the optimal inclusion distance for the crowds to the initial optimal inclusion distance step . The crowds created for the individual users are temporary crowds created for purposes of performing the crowd formation process. At this point the crowd analyzer analyzes the crowds in the bounding box to determine whether any crowd members i.e. users in the crowds violate the optimal inclusion distance of their crowds step . Any crowd member that violates the optimal inclusion distance of his or her crowd is then removed from that crowd and the previous crowd fields in the corresponding user records are set step . More specifically in this embodiment a member is removed from a crowd by removing the user record of the member from the set or list of user records in the crowd record of the crowd and setting the previous crowd stored in the user record of the user to the crowd from which the member has been removed. The crowd analyzer then creates a crowd for each of the users removed from their crowds in step and sets the optimal inclusion distance for the newly created crowds to the initial optimal inclusion distance step .

Next the crowd analyzer determines the two closest crowds in the bounding box step and a distance between the two closest crowds step . The distance between the two closest crowds is the distance between the crowd centers of the two closest crowds. The crowd analyzer then determines whether the distance between the two closest crowds is less than the optimal inclusion distance of a larger of the two closest crowds step . If the two closest crowds are of the same size i.e. have the same number of users then the optimal inclusion distance of either of the two closest crowds may be used. Alternatively if the two closest crowds are of the same size the optimal inclusion distances of both of the two closest crowds may be used such that the crowd analyzer determines whether the distance between the two closest crowds is less than the optimal inclusion distances of both of the two closest crowds. As another alternative if the two closest crowds are of the same size the crowd analyzer may compare the distance between the two closest crowds to an average of the optimal inclusion distances of the two closest crowds.

If the distance between the two closest crowds is greater than the optimal inclusion distance the process proceeds to step . However if the distance between the two closest crowds is less than the optimal inclusion distance the two crowds are merged step . The manner in which the two crowds are merged differs depending on whether the two crowds are pre existing crowds or temporary crowds created for the spatial crowd formation process. If both crowds are pre existing crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd and setting the merged into field of the non surviving crowd to a reference to the crowd record of the surviving crowd. In addition the crowd analyzer sets the previous crowd fields of the set or list of user records from the non surviving crowd to a reference to the crowd record of the non surviving crowd.

If one of the crowds is a temporary crowd and the other crowd is a pre existing crowd the temporary crowd is selected as the non surviving crowd and the pre existing crowd is selected as the surviving crowd. The non surviving crowd is then merged into the surviving crowd by adding the user records from the set or list of user records from the crowd record of the non surviving crowd to the set or list of user records in the crowd record of the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

If both the crowds are temporary crowds one of the two crowds is selected as a non surviving crowd and the other is selected as a surviving crowd. If one crowd is larger than the other the smaller crowd is selected as the non surviving crowd and the larger crowd is selected as a surviving crowd. If the two crowds are of the same size one of the crowds is selected as the surviving crowd and the other crowd is selected as the non surviving crowd using any desired technique. The non surviving crowd is then merged into the surviving crowd by adding the set or list of user records for the non surviving crowd to the set or list of user records for the surviving crowd. However since the non surviving crowd is a temporary crowd the previous crowd field s of the user record s of the user s in the non surviving crowd are not set to a reference to the crowd record of the non surviving crowd. Similarly the crowd record of the temporary record may not have a merged into field but if it does the merged into field is not set to a reference to the surviving crowd.

Next the crowd analyzer removes the non surviving crowd step . In this embodiment the manner in which the non surviving crowd is removed depends on whether the non surviving crowd is a pre existing crowd or a temporary crowd. If the non surviving crowd is a pre existing crowd the removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the non surviving crowd. In this manner the spatial information for the non surviving crowd is removed from the corresponding crowd record such that the non surviving or removed crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the non surviving crowd are still available via the crowd record for the non surviving crowd. In contrast if the non surviving crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record.

The crowd analyzer also computes a new crowd center for the surviving crowd step . Again a center of mass algorithm may be used to compute the crowd center of a crowd. In addition a new optimal inclusion distance for the surviving crowd is computed step . In one embodiment the new optimal inclusion distance for the surviving crowd is computed in the manner described above with respect to step of .

At this point the crowd analyzer determines whether a maximum number of iterations have been performed step . If the maximum number of iterations has not been reached the process returns to step and is repeated until either the distance between the two closest crowds is not less than the optimal inclusion distance of the larger crowd or the maximum number of iterations has been reached. At that point the crowd analyzer removes crowds with less than three users or members step . As discussed above in this embodiment the manner in which a crowd is removed depends on whether the crowd is a pre existing crowd or a temporary crowd. If the crowd is a pre existing crowd a removal process is performed by removing or nulling the users field the NE corner field the SW corner field and the center field of the crowd record of the crowd. In this manner the spatial information for the crowd is removed from the corresponding crowd record such that the crowd will no longer be found in response to spatial based queries on the datastore . However the crowd snapshots for the crowd are still available via the crowd record for the crowd. In contrast if the crowd is a temporary crowd the crowd analyzer may remove the crowd by deleting the corresponding crowd record. In this manner crowds having less than three members are removed in order to maintain privacy of individuals as well as groups of two users e.g. a couple .

The crowd analyzer then determines whether the crowd formation process for the new and old bounding boxes is done step . In other words the crowd analyzer determines whether both the new and old bounding boxes have been processed. If not the bounding box is set to the new bounding box step and the process returns to step and is repeated for the new bounding box. Once both the new and old bounding boxes have been processed the crowd formation process ends.

Next the crowd analyzer determines whether there are any crowd change events step . If not the process ends. Otherwise the crowd analyzer gets the next crowd change event step and generates a crowd snapshot for a corresponding crowd step . More specifically the crowd change event identifies a crowd record stored for a crowd for which the crowd change event was detected. A crowd snapshot is then created for that crowd by creating a new crowd snapshot record for the crowd and adding the new crowd snapshot to the list of crowd snapshots stored in the crowd record for the crowd. The crowd snapshot record includes a set or list of anonymized user records which are an anonymized version of the user records for the users in the crowd at the current time. In addition the crowd snapshot record includes the NE corner the SW corner and the center of the crowd at the current time as well as a timestamp defining the current time as the sample time at which the crowd snapshot record was created. Lastly locations of users in the crowd that define the outer boundary of the crowd at the current time are stored in the crowd snapshot record as the vertices of the crowd. After creating the crowd snapshot the crowd analyzer determines whether there are any more crowd change events step . If so the process returns to step and is repeated for the next crowd change event. Once all of the crowd change events are processed the process ends.

Accordingly in this embodiment the spatial crowd formation process of is performed in response to a location update for a user. The crowd analyzer then gets a next relevant crowd step . The relevant crowds are pre existing and new crowds that are within the bounding region s processed during the spatial crowd formation process in response to the location update for the user. Note that for the first iteration the next relevant crowd is the first relevant crowd. The crowd analyzer then determines a maximum number of users in the crowd from a common previous crowd step . More specifically the crowd analyzer examines the previous crowd fields of the user records of all of the users in the crowd to identify users from a common previous crowd. For each previous crowd found in the user records of the users in the crowd the crowd analyzer counts the number of users in the crowd that are from that previous crowd. The crowd analyzer then selects the previous crowd having the highest number of users and determines that the number of users counted for the selected previous crowd is the maximum number of users in the crowd from a common previous crowd.

The crowd analyzer then determines whether the maximum number of users in the crowd from a common previous crowd is greater than a predefined threshold number of users step . In an alternative embodiment rather than determining the maximum number of users from a common previous crowd and comparing that number to a predefined threshold number of users a maximum percentage of users in the crowd from a common previous crowd may be determined and compared to a predefined threshold percentage. If the maximum number of users in the crowd from a common previous crowd is not greater than the predefined threshold number of users the process proceeds to step . Otherwise the crowd analyzer determines whether the common previous crowd has been removed step . If so then the crowd is re established as the common previous crowd step . More specifically in this embodiment the crowd is re established as the common previous crowd by storing the set or list of user records the NE corner the SW corner and the center from the crowd record of the crowd in the crowd record of the common previous crowd. The crowd record for the crowd may then deleted. In addition the previous crowd fields of the users from the common previous crowd may be set to null or otherwise cleared. Once the common previous crowd is re established the crowd analyzer determines whether there are more relevant crowds to process step . If so the process returns to step and is repeated until all relevant crowds are processed.

Returning to step if the common previous crowd has not been removed the crowd analyzer identifies the crowd as being split from the common previous crowd step . More specifically in this embodiment the crowd analyzer stores a reference to the crowd record of the common previous crowd in the split from field of the crowd record of the crowd. At this point the crowd analyzer then determines whether there are more relevant crowds to process step . If so the process returns to step and is repeated until all relevant crowds are processed at which time the process ends.

In response to receiving the crowd tracking data request the MAP server and more specifically the crowd analyzer obtains relevant crowd snapshots for the crowd step . In one embodiment the crowd tracking data request is a general crowd tracking data request for the crowd. As such the relevant crowd snapshots are all crowd snapshots for the crowd. In another embodiment the crowd tracking data request may include one or more criteria to be used to identify the relevant crowd snapshots. The one or more criteria may include time based criteria such that only those crowd snapshots for the crowd that satisfy the time based criteria are identified as the relevant crowd snapshots. For example the time based criteria may define a range of dates such as Oct. 1 2009 through Oct. 8 2009 or define a range of times within a particular day such as 5 pm through 9 pm on Oct. 1 2009. The one or more criteria may additionally or alternatively include user based criteria such that only those crowd snapshots including anonymous users satisfying the user based criteria are identified as the relevant crowd snapshots. For example the user based criteria may include one or more interests and a minimum number or percentage of users such that only those crowd snapshots including at least the minimum number or percentage of anonymous users having the one or more interests are identified as the relevant crowd snapshots. Note that by using user based criteria the subscriber is enabled to track sub crowds within a crowd.

Next the crowd analyzer of the MAP server generates crowd tracking data for the crowd based on the relevant crowd snapshots step . The crowd tracking data includes data indicative of the location of the crowd over time which can be determined based on the spatial information and sample times from the relevant crowd snapshots. In addition the crowd tracking data may include an aggregate profile for the crowd for each of the relevant crowd snapshots or at least some of the relevant crowd snapshots an average aggregate profile for all of the relevant crowd snapshots an average aggregate profile for a subset of the relevant crowd snapshots or average aggregate profiles for a number of subsets of the relevant crowd snapshots. For example the relevant crowd snapshots may be divided into a number of time bands such that at least some of the time bands include multiple relevant crowd snapshots. An average crowd snapshot may then be created for each of the time bands. The crowd analyzer may utilize the aggregation engine to obtain an aggregate profile for a crowd snapshot based on the interests of the anonymous users in the crowd snapshot. More specifically in a manner similar to that described above an aggregate profile for a crowd snapshot may be computed by comparing the interests of the anonymous users to one another or by comparing the interests of the anonymous users to a target profile. The crowd tracking data may also contain other information derived from the relevant crowd snapshots such as for example the number of users in the relevant crowd snapshots crowd characteristics for the crowd for the relevant crowd snapshots or the like.

The crowd analyzer returns the crowd tracking data for the crowd to the subscriber device step . Note that in the embodiment where the subscriber device interacts with the MAP server via the web browser the MAP server returns the crowd tracking data to the subscriber device in a format suitable for use by the web browser . For example the crowd tracking data may be returned via a web page including a map wherein indicators of the location of the crowd over time as defined by the relevant crowd snapshots may be overlaid upon the map. The subscriber may then be enabled to select one of those indicators to view additional information regarding the crowd at that time such as for example an aggregate profile of a corresponding crowd snapshot of the crowd. Once the crowd tracking data is received at the subscriber device the crowd tracking data is presented to the subscriber step .

In addition to enabling an entity such as the subscriber to track crowds the crowd snapshots of crowds may also be used to provide additional metrics about the crowds. These metrics may be included in the crowd data generated for the crowds and returned to the users through N the subscriber or the third party service . For example a quality factor for a crowd may be provided as a function of a duration of time that the crowd has existed. The duration of time that the crowd has existed can be determined from the crowd snapshots for the crowd. For instance a crowd may have a high quality if the crowd has existed not been removed for a duration of two or more hours a low quality if the crowd has existed for a duration of less than five minutes or one of various intermediate degrees of quality if the crowd has existed for a duration of between five minutes and two hours. Note that when determining whether to remove a user from a crowd the quality of the crowd may be used to relax or stretch the optimal inclusion distance for the crowd with respect to user removal. This relaxation or stretching of the optimal inclusion distance with respect to user removal may then retract to its original value after or over a desired period of time. The retracting period may also be a function of the quality of the crowd. In this manner if a crowd has existed for a long period of time the MAP server will be more lenient when determining whether to remove a user from that crowd because the crowd is stable and the user will likely move back to within the optimal inclusion distance from the center of the crowd.

As another example the crowd snapshots of a crowd may be used to compute a motility of the crowd based on how much area the crowd covers over time. For instance the distance that the crowd has traveled over a period of time may be determined based on the crowd centers stored in the crowd snapshots for the crowd during that period of time. The total distance traveled over the period of time can be provided as the motility of the crowd. The motility of the crowd may additionally or alternatively consider a speed at which the crowd moves over a period of time.

Once the alert is configured the MAP server monitors the crowd specified for the alert or crowds relevant to the POI or the AOI specified for the alert to detect when the one or more criteria for the alert are satisfied step . Once the one or more criteria for the alert are satisfied the alert is triggered such that the MAP server sends the alert to the MAP client which in turn sends the alert to the MAP application steps and . The MAP application then presents the alert to the user step . The alert may be presented as for example a visual alert or an audible alert.

Those skilled in the art will recognize improvements and modifications to the embodiments of the present invention. All such improvements and modifications are considered within the scope of the concepts disclosed herein and the claims that follow.

