---

title: System and method for creating a development and operational platform for mobile applications
abstract: The present invention provides a system and method for constructing a complete definition of a backend requirements model that can be automatically accessed and interpreted, and generated into a mobile consumable API for creation of, and use with, mobile applications. The mobile consumable API can be provided and made available to mobile app developers on a separate, stand-alone platform, and may act as an intermediary between the mobile app and the primary mainframe/enterprise/back end system. The method may include identification and definition of one or more of information providers, integration providers, and system behaviors, and creating a domain model. The domain model may be automatically codified into an API based solution as the app/mainframe interface, and stored on a development and operational platform for use.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274763&OS=09274763&RS=09274763
owner: Clearblade, Inc.
number: 09274763
owner_city: Austin
owner_country: US
publication_date: 20150506
---
This application is a continuation of U.S. application Ser. No. 14 256 667 titled System and Method for Creating a Development and Operational Platform for Mobile Applications filed on Apr. 18 2014 due to issue on May 19 2015 as U.S. Pat. No. 9 038 015 which claims priority to U.S. Provisional Application Ser. No. 61 815 085 titled Method for Developing Mobile Applications Integrating with a Mainframe or Large Computing System filed on Apr. 23 2013 the entire contents of all of which are herein incorporated by reference.

The invention relates generally to a system and method for creating a development and operational platform for mobile applications e.g. computer software applications that can run on mobile devices including but not limited to a smart phone or tablet.

Many companies have existing enterprise or backend systems sometimes also referred to as mainframe systems. Generally speaking these enterprise systems represent the complex computer environment necessary to perform large scale enterprise computing. The environment may be represented by an individual large scale computer or groups of smaller networked computers networked together to create a single instance of powerful computing capability. The enterprise systems often run large scale application software packages that may support any number of analytics processes data reporting and other functions in the business organization including as examples enterprise resource planning ERP systems inventory systems or customer relationship management CRM software. The hardware for the enterprise systems often utilize various servers and storage media and associated software to manage large volumes of critical data while maintaining high levels of data security and performance.

As technology has continued to develop the market has continued to shift toward a desire for more mobile applications that can be integrated with existing such legacy systems but utilized directly on mobile devices like a smart phone tablet or other mobile device. Unfortunately enterprise systems that organizations have traditionally relied upon are not easily integrated with mobile applications. Organizations that want mobile device software applications or apps that can tap into read to from and or interact with such systems have to invest significant time and resources to build the necessary software and application programming interfaces APIs to access such systems for a single mobile app. Such development can take months and in some cases years of complex developer work to connect mobile devices to legacy systems.

Specific mobile apps require extensive software development to implement the various functionality and features of a particular desired app. For example an app may want to interact with Facebook interact with one or more databases of a mainframe enterprise back end system each having individual drivers and protocols require specific user authentication and follow certain security protocols. All of these features and functionalities must be individually developed configured and integrated. These same difficulties may exist even if not accessing or interacting with mainframe enterprise backend systems.

Development of the mobile app often includes defining the desired functionality of the app capturing points of information capturing points of integration capturing system behaviors each discussed in more detail below. This is traditionally done through a manual review and analysis by the app developer and often in conjunction with the owner operator of the mainframe enterprise back end system. Once the functionality points of information points of integration and system behaviors are understood an app developer can start the actual software development which can be a very time intensive and expensive process. The eventually developed app will reside on the mobile devices but often interacts with the mainframe enterprise back end system through code residing on the same mainframe enterprise back end systems. Alternatively the app may interact through an intermediary system or middleware i.e. a server application stored in a server farm which interacts with the mainframe enterprise back end system.

The one off project based solutions that have traditionally be implemented have become unsustainable for many users. The industry does not currently have systems or methods for cost effectively defining such mainframe enterprise backend systems comprised of disparate data sources that results in a single consumable standard API complying with open specifications.

In one embodiment the present invention relates to a method for creating a development platform for mobile device applications interacting with a mainframe computer system comprising a providing a preconstructed computer code set of connectors for a first set of information providers first set of integration providers and a first set of system behaviors b defining a second set of information providers with which the mobile device application will interact c defining a second set of integration providers with which the mobile device application will interact d defining a second set of system behaviors of the mobile device application e creating a machine readable domain model from the second set of information providers second set of integration providers and second set of integration providers f processing the domain model using a domain model processor to generate a mobile device application mainframe interface having app specific connectors associated the second set of information providers second set of integration providers and second set of system behaviors and wherein said app specific connectors are derived from the first set of information providers first set of integration providers and first set of system behaviors and g storing the mobile device application mainframe interface on a development and operational computer system platform.

In another embodiment the present invention relates to a method for interfacing mobile device applications with a mainframe computer system comprising a creating a machine readable domain model defining at least one information provider with which the mobile device application will interact at least one integration provider with which the mobile device application will interact and at least one system behavior of the mobile device application b processing the domain model using a domain model processor to automatically generate a mobile device application mainframe interface having at least one app specific connector associated the at least one information provider at least one integration provider and at least one system behavior and wherein said at least one app specific connector is derived from a preconstructed computer code set of generic connectors associated with said at least one information provider at least one integration provider and at least one system behavior and c storing the mobile device application mainframe interface on a development and operational computer system platform.

In another embodiment the present invention relates to a computer system for generating a mobile software application mainframe computer system interface comprising a memory storing a preconstructed computer code set of connectors for a first set of information providers first set of integration providers and a first set of system behaviors b logic configured to process a preconstructed machine readable domain model defining a second set of at least one information provider with which the mobile software application with interact a second set of at least one integration provider with which the mobile software application will interact and a second set of at least one system behavior of the mobile software application to generate the mobile software application mainframe computer system interface having app specific connectors associated with the second set of at least one information provider second set of integration provider and second set of system behavior and wherein said app specific connectors are derived from the first set of information providers first set of integration providers and first set of system behaviors.

In some aspects the invention relates to a system and method that automatically generates the necessary APIs connections and specific code base for defined mobile applications and mainframe enterprise backend systems.

In other aspects the invention relates to a system and method that connects mobile devices to legacy systems of record effortlessly and securely.

In other aspects the invention relates to a mediator system between mobile devices and existing systems of record allowing them an unbroken line of communication in real time.

In other aspects the invention relates to a system and method and software framework for a coherent assembly of components to compose a functional system of mobile devices that interface to a mainframe enterprise backend system.

In other aspects the invention relates to a platform designed for heavy duty enterprise environments and can be deployed on premise behind the firewall integrating tightly with security policies or live in the cloud to eliminate onsite infrastructure needs.

In other aspects the invention relates to APIs that are immediately usable so there is no need to remove and replace the middleware technologies that are already in place or disrupt the stable environment of existing systems of record.

In other aspects the invention relates to a development platform that is owned and controlled by the enterprise so they can retain complete control and not solely rely on vendors.

Other aspects and advantages of the invention will be apparent from the following description and the appended claims.

While the invention has been described with respect to a limited number of embodiments those skilled in the art having benefit of this disclosure will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed here. Accordingly the scope of the invention should be limited only by the attached claims. Additionally while much of the description herein relates to mobile apps that interact with mainframe enterprise back end systems the invention is equally applicable to mobile apps that do not interact with such systems.

The present invention provides a system and method for constructing a complete definition of a backend requirements model that can be automatically accessed and interpreted and generated into a mobile consumable API for creation of mobile applications. The mobile consumable API can be provided and made available to mobile app developers on a separate stand alone platform and may act as an intermediary between the mobile app and the primary mainframe enterprise back end system.

Referring to in one of the most basic embodiments the method comprises identifying capturing and defining the information providers integration providers and system behaviors defining creating an domain model and automatically codifying the domain model into an API based solution as the app mainframe interface . The app mainframe interface can be stored on a development and operational platform which allows further development by the app developer and or the necessary interface between the mobile app and mainframe enterprise back end system during operation. In one embodiment the development and operational platform is comprised of one or more computer systems that may act as a web server message broker database and perform other process and may be as an example running a LINUX AMD64 instance but can be any similar type of infrastructure known to those of skill in the art. The development and operational platform contains memory for storage of the app mainframe interface optional databases which may be created or used by the app mainframe interface and optional custom developed code as discussed below as well as the necessary processors and logic for implementation. To create the app mainframe interface the method can reuse computer code from a preconstructed code set comprised of specific computer code bases or libraries designed to provide the necessary connections features and functionality identified captured defined from the information providers integration providers and system behaviors to allow interaction between the mobile application and mainframe enterprise back end system .

Depending on the implementation and the needed connections features and functionality from the preconstructed code set the app mainframe interface may use computer code from the preconstructed code set in unaltered form and or the preconstructed code set may be modified and or used to create the specific connection feature and or functionality for the app mainframe interface . For example some code in the preconstructed code set may be application agnostic and can be used by a variety of apps as is without any additional configuration changes or modifications. Alternatively some of the computer code in the preconstructed code set is more generic in nature and must be configured or modified in order for them to be used in the app mainframe interface for a particular app.

The preconstructed code set for example may include computer code for a generic connector for a particular type of database e.g. an Oracle database but without specific information about the location of the database the credentials needed to access it etc. As the app mainframe interface is created from the domain model the generic connector in the preconstructed code set may be automatically configured or modified to create the code set for a specific connector needed for the app referred to herein as app specific connector . In this example the generic Oracle database connector from the preconstructed code set is converted to an app specific connector to a specific database for example one having a particular IP address credentials and target data name as defined by the domain model . As used herein the term app specific connector refers to the specifically configured modified computer code for use in the app mainframe interface and generated from the preconstructed code set based on the information provided in the domain model . While the term connector is used as part of the phrase app specific connector it will be recognized by those of skill in the art that such specifically configured modified computer code may not be limited to a connector e.g. it also applies to the various features functionality etc. referred to herein. Thus in some embodiments the app mainframe interface may comprise computer code directly from the preconstructed code set in unaltered form and or app specific connectors. Thus in some embodiments the preconstructed computer code set may provide unmodified or generic connectors related to a first set of information providers a first set of integration providers and a first set of system behaviors while the app specific connectors provide a second set of connectors related to a second set of information providers second set of integration providers and a second set of system behaviors . In this context the first set and second set do not normally represent different information providers integration providers and system behaviors but rather represent unmodified generic connectors v. app specific connectors derived from the domain model .

In some instances a particular portion of the preconstructed code set will be used to create one or more app specific connectors. For example a particular implementation may include 3 separate Oracle databases. Thus the computer code for a generic connector to the Oracle database can be used from preconstructed code set to create an app specific connector for each particular Oracle database. The app specific connector for each database will normally have different IP addresses but may or may not have the same credentials target data name etc. all of which can be defined by the domain model .

Additionally and again depending on the implementation the development and operational platform may contain all the computer code from the preconstructed code set and or app specific connectors or it may contain only those portions of the preconstructed code sets and or app specific connectors for those connections features and functionality needed for the app mainframe interface for a particular app . For example in one implementation if only Oracle databases are used the non Oracle data source connections may be excluded from the development and operational platform . Alternatively in another implementation the entirety of the preconstructed code set and or app specific connectors may be made available to the app developer on the development and operational platform . In this latter case portions of the preconstructed code set may reside on the development and operational platform but may simply be unused by the specific app .

The preconstructed code sets the app specific connectors and the app mainframe interface are preferably stored on the development and operational platform in compiled computer code format but can also be provided in other formats as desired.

With continuing reference to identifying capturing and defining the information providers may include a capturing points of data source b capturing points of messaging and c capturing points of logic execution. Identifying capturing and defining integration providers may include a capturing points of advertising b capturing points of commerce and or c capturing points of social. Identifying capturing and defining system behaviors may include may include a capturing points of performance b capturing points of analytics c capturing points of security and d capturing points of quality.

The steps involving identifying capturing and defining information providers integration providers and system behaviors are discussed in more detail below and generally refer to the process of identifying the necessary components features functionality and requirements to allow a mobile device running a mobile app to properly interface with a defined mainframe enterprise backend system . It should be recognized that while each category e.g. information providers integration providers and system behaviors is discussed with various subcategories the various subcategories are not necessarily tied to the primary categories and an individual developer may include one or more of the subcategories with a different primary category. Additionally depending on the particular mobile app being developed and the mainframe enterprise back end system with which it will interact if at all one or more of the categories or subcategories may not be relevant to a particular development effort. Moreover app developers may include one or more categories or subcategories not specifically discussed herein but that are known to those of skill in the art and the example categories and associated subcategories discussed in more detail below are not intended to be limiting.

Referring to identifying capturing and defining information providers may include a identifying capturing and defining points of data source b identifying capturing and defining points of messaging and c identifying capturing and defining points of logic execution . Each is discussed in more detail below.

Among other aspects app developers seeking to interface a mobile device to a backend system must identify capture and define the various sources of backend or mainframe enterprise system data sources that the mobile application will interact with for example to query receive data from and or create modify delete or store data. An example of this may be the data store in a product inventory that must be viewed added to modified or removed to manage the live state of a warehouse. Many possible data sources exist but may include but is not limited to 

Each data source may have specific drivers and or protocols that must be followed to interact with the data source . For example Oracle provides a driver and the protocol to use an Oracle database. Developers then have to write a specific code base to use the driver using Oracle s protocol. Even for data sources that do not use a specific driver app developers will normally have to write specific code to read from write to a particular data source often with each different data source having its own specific implementation.

In the present invention specific computer code or logic is written to create read update delete etc. each specific type of data source or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . Thus there can be a specific software implementation to interact with an Oracle database using the Oracle driver protocol a specific computer code base to interact with a Microsoft SQLServer database using the Microsoft driver protocol etc. Preferably the preconstructed code set contains the necessary code to interact with all of the industry standard data sources and associated protocols. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

Though each data source may require slightly different input parameters the metadata for interacting with a particular data source may include 1 destination server inputs such as IP address listening port s 2 credentials to access 3 target data name such as table name id or filename and 4 internal settings such as access keys and secrets. Other input parameters may be required depending on the nature of the data source and would be known and understood to those of skill in the art.

Another aspect that developers must account for is messaging utilized in a mobile app and or mainframe enterprise back end system with which it will interact e.g. the types of messaging and associated message sources . Messaging includes any provider that can conceptually send a message to recipients enrolled in a software infrastructure and may include 

For example to utilize Apple IOS Push Notification as the messaging for a particular app Apple will provide an API that specifies how to implement and use that functionality. Thus an app developer seeking to implement a mobile app that utilizes Apple IOS Push Notification will use the Apple API to do so. Other vendors may likewise have specialized APIs to interact with their messaging systems. Other messaging functionality may implement or utilize other industry standard APIs.

It is not uncommon for a particular mobile app to use a particular messaging specification for example MQTT. However older mainframe enterprise back end systems may use more traditional middleware that uses something like JAVA Messaging Service JMS API. In this circumstance app developers have to write a specific code base to convert messages using one protocol to another e.g. provide the ability for the mainframe enterprise back end messaging protocol to interpret the message. For example the app may send a message following the MQTT specification which must then be converted to JMS which can then be sent received and interpreted by the mainframe enterprise back end system be processed and then sent back in JMS and converted to MQTT specification so it can be properly received interpreted and used by the mobile app .

In the present invention specific computer code or libraries are written to use each specific type of messaging message source or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . The preconstructed code set can also be populated with specific libraries bases to interpret and convert messages using different specifications e.g. MQTT JMS. Preferably the preconstructed code set contains the necessary code to implement all of the industry standard messaging specifications. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model . It should be noted that throughout the specification applicant generally uses the term computer code to refer to the logic designed to be run interpreted and executed on computer systems. In various places additional terms like library or connector are also used in the context of the particular aspects of the invention all of which are computer code.

Though each message source require slightly different input parameters the metadata for each may include 1 destination server inputs such as IP address listening port s 2 credentials to access 3 messaging protocol details and 4 internal settings such as access keys and secrets.

With continuing reference to in addition to identifying capturing and defining data sources and points of messaging app developers must also identify capture and define desired logic execution . The logic execution generally refers to the processes and procedures that are implemented by the mainframe enterprise back end system . For example it may be a product inventory system for a warehouse or a medical application that helps doctors diagnose medical conditions based on certain patient symptoms. Logic execution includes the ability to provide inputs to a remote process running on the mainframe enterprise back end system allow time for the inputs to be understood and provide a set of outputs unique to the logic executed. This logic can possible maintain state from execution or can be stateless. This logic has the ability to maintain state across multiple calls from the mobile devices e.g. the logic is able to store and recall the username from previous calls when attempting to get the users checking account balance so that login steps are not required each time.

Execution of logic can be achieved through software protocols standards and framework like but not limited to 

Particular logic execution that may be desired may not reside in the mainframe enterprise back end system but rather may be included as part of the app mainframe interface on the development and operational platform . For example the mainframe enterprise back end system may include databases in a financial institution that separately house customer savings account balances and checking account balances. An app developer may want to allow a customer to query the databases to return an overall balance savings account plus checking account . A developer can either design and code logic execution to add the savings account balance and checking account balance and return a total balance figure to the customer in the mainframe enterprise back end system as part of the app or as in the present invention it can be included in the development and operational platform . By including in the development and operational platform it can minimize the chances of disrupting the functionality of the mainframe enterprise back end system and decrease the amount of data sent to and processing by the mobile application .

In the present invention specific computer code bases are written for commonly used logic execution or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . Preferably the preconstructed code set contains the necessary code to implement industry standard logic execution . As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model . While the preconstructed code set preferably contains extensive options for logic execution it should be understood that each individual mobile app and mainframe enterprise back end system may still require custom developed code for desired logic execution . Such custom development can be implemented on the development and operational platform either as part of the app mainframe interface or as separate code and functionality but run on the development and operational platform .

Referring to in addition to identifying information providers for particular mobile apps a developer may have to identify capture and define integration providers which may include a advertising b financial transactions c social interaction each of which is discussed further below.

Developers need to understand and account for what aspects are needed for the mobile app to incorporate the desired content for advertising if any. Depending on the nature of the app no advertising content may be desired or needed. For other apps however the developer may want to include various types of advertising media known in the industry including by not limited to banner ads popup ads or audio visual ads that may interrupt the functionality of the app while being played etc. The developer may also want to comply with the content management interoperability services CMIS standard and or to include sensory or contextual information that may consist of geolocation functionality i.e. the location of the mobile device time of day e.g. the time of day that a mobile device interacted with the backend system and or response to content. The advertising functionality may also include but is not limited to the ability to interrupt interaction flow insert advertising material to existing communication and or provide behavior information to third party entities e.g. what advertisements were viewed what separate content may have been accessed by the user etc. .

In the present invention specific computer code bases are written for commonly used advertising advertising functionality and standards or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . Preferably the preconstructed code set contains the necessary code to implement industry standard advertising advertising functionality and standards e.g. code for banner ads pop up ads audio visual ads APIs to advertising content providers user behavior information etc. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

Some apps may need the ability to register financial transactions . Thus a developer will need to identify if functionality is needed to register financial transactions for example between one or more of business es government and or consumers and if so capture and define the needed components features functionality and requirements. Typical types of financial transactions may include monetary exchange bill of lading contract signature work order change request statement of work financial currency exchange and investment profile. Apps that include the ability to register financial transactions may also trigger additional security requirements. For example an app that includes monetary exchange may require more security requirements e.g. encryption where apps that do not include any monetary exchange can utilize less stringent security requirements.

In the present invention specific computer code libraries are written to implement and complete commonly used financial transactions or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . This could include the mobile app s ability to interact with a check clearing system to appropriately transfer currency between account holders. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

Mobile app developers may also want to incorporate functionality for social interaction . This may include the ability to both gather data from and post information to social networks for example Facebook LinkedIn Google or a variety of other social platforms. Possible social interaction points include user authentication and profile data system interaction posts to social profiles and social data to drive end user presentation. For example a particular app may provide for a user s Facebook ID to log on to the app .

As another example a particular app may be designed for a large retailer for use by its customers. The retailer wants to allow its customers to post messages to their social network page when they went shopping at the retailer and what they bought. Thus the app may provide the ability for the users to log on to the app using their Facebook ID and password. The app may also include geolocation functionality to determine what store location the user is in when they log on to automatically determine what the user purchased to allow the user to post a message to their social profile perhaps with something like I just purchased 2 pillows from XYZ on Main Street . In this example the app must not only have the specific code base for the desired user interface and functionality but it must also properly access and utilize the social network API for interacting with the social network.

In the present invention specific computer code bases are written to implement commonly used social interaction or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . For example the Facebook API can be provided as well as specific computer code bases for using a social network log in and password as the log in and password for the app geolocation functionality and allowing users to post comments to their social network pages. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

While the foregoing disclosure has focused on advertising financial transactions and social there are other points of integration known to those of skill in the art and the present invention is equally applicable and usable in other implementations. Without limitation other points of integration can include but is not limited to analytics services e.g. Google s analytics services healthcare frameworks e.g. healthcare applications and healthcare specific implementations and security requirements supply chain systems inventory management systems and energy grid platforms just to name a few.

Referring now to in addition to information providers and integration providers mobile app developers need to identify capture and define system behaviors which may include a performance b analytics c security and d quality testing . Each of the foregoing is discussed in further detail below.

For each point of information logic and integration required performance is preferably identified captured and defined. This information can be used to measure and possibly enforce Service Level Agreements SLAs or if possible affect the instantiation of the resulting model. The performance criteria may include any of the standard performance criteria known to those of skill in the art including but not limited to a expected response times by system endpoint s b concurrent access requirements by system endpoint s and c expected downtimes or windows when system endpoint s are expected and or allowed to be unavailable.

In the present invention specific computer code bases are written to implement track store and report commonly used performance criteria or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . This might include the ability for an app to make 500 calls per second and get a guaranteed response time of 500 ms when requesting a current inventory. As discussed further below having the preconstructed code set allows the app mainframe interface having these features and functionality to be automatically generated from the domain model .

The mobile app developer also needs to identify capture and define desired analytics for the mobile app . The analytics represent possible information valuable to an entity which can lead to better user experience high user interaction higher revenue generation better device performance better back end performance and defect identification. The various analytics desired by a particular app will be dependent on the type of app being developed and are well understood by those of skill in the art.

Examples of optional analytics for a particular mobile app to track store and or report may include a identifying criteria of end users e.g. end users profile name and address current GPS location device type iPhone 4s and average usage time b data accessed and modified by end users e.g. end users accessed the inventory for part no. XXXXX and reduced the inventory by 1 c messages received and sent by end users e.g. end user sent a request to the enterprise system at 10 50 AM on Mar. 13 2014 and received a response at 10 51 AM on Mar. 13 2014 d logic executed and reviewed by end users e.g. end users types of financial transactions performed like 56 withdrawals and 12 deposits e location of interaction e.g. transaction HELO executed on IBM zOS CICS 4.3 f timestamp of interaction e.g. interaction occurred at 10 58 AM on Mar. 14 2014 g speed of interaction e.g. interaction took 1.24 sec h system state at time of interaction e.g. system was batch processing end of day inventory i frequency of interactions e.g. there were 50 interactions over a 24 hour period j device interaction points of touch e.g. the user tapped the search button 72 times and used the advanced query icon 23 times for performance of the product lookup action .

The various analytics monitoring can produce alerts notices triggers and or changes in system accessibility or functionality that can be sent via any of the optional points of messaging listed above. These analytics can also be stored in one or more databases in the mainframe enterprise back end systems or the development and operational platform for review and analysis. These alerts notices triggers and or changes can include things like usage limitations reached e.g. only 10 users are permitted to access the system at any one time specific user access and suspicious activity.

In the present invention specific computer code bases are written to implement track store and report commonly used analytics or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . For example specific computer code bases can include functionality to track and report when a data source was accessed where the interaction occurred and the messages sent received by users. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model . The specific computer code bases can also include functionality to define and create separate databases for tracking and storing the analytics.

The mobile app developer also needs to identify capture and define desired security requirements for the mobile app . Some apps may be accessing reading to from or interacting with backend systems that are and need to remain secure while other apps may not have high levels of security needed. Security requirements may include further subcategories of transmission of information storage of information end user authentication end user authorization access external data source authorization control and network gateway interaction each of which are discussed further below.

Transmission. One aspect of this step is to identify the transmission protocol for data to from mobile applications and mainframe enterprise back end systems . The transmission protocol is often driven by the integration points available function but can also be influenced to use the best available when considering security. For example a telnet based integration may use secure shell 5514 Simple Authentication and Security LayerSASL or Transport Layer Security TLS.

For mobile devices this step may include identifying and understanding the transport process for sending receiving data from the defined backend to the mobile smart device or connected device. This can include no encryption or a common standard for SSL. Additional optional security models could include using a centralized approach e.g. SSL DNSSEC Convergence or TLS or a de centralized approach e.g. PGP Open PGP or GnuPGP.

Storage. The identification capture and definitions relating to the storage of information is another step often utilized by mobile app developers. Backend systems and passthrough mobile devices will often store data for two types of categories namely metadata and intermediate storage and for each category the security requirements will preferably be documented. As for metadata the data about the system is preferably secure. This is often persistent data which may be stored in a file system or database. Potential metadata may include as examples definition of a data structures used b end user registries c security models d code logic and e integrations to third party systems. Options for securing this data include as examples file system data encryption and or read write privilege management of the file system.

As for intermediate storage this preferably includes the ability to store data of the file system persistently as flat files database files memory options or other methods to those known to those of skill in the art. For security this data preferably includes the ability to encrypt and or manage access permissions.

End User Authentication. End user authentication is another feature functionality that may be important to a particular mobile app . For any data to be exposed to mobile devices and sensors an authentication model is preferably established. This user registry can be captured and defined for integration and implementation purposes. Different categories of authentication can exist to support disparate usage models. These different authentication models include but are not limited to a system b device c application and d user. Optional solutions for authentication models include but are not limited to a flat file b custom user registry c operating system d LDAP MS Active Directory e social registries e.g. Facebook f RACF g single sign on SSO h OAuth and i Security Assertion Markup Language.

End User Authorization Access. End user authorization access is another feature functionality that may be important to a particular mobile app . Each available function and data source within the defined mainframe to mobile app system has the potential for specific authorization. These authorizations could be set specifically for a user or can generically be defined in a set sometimes called a role e.g. an administrator role has broader access than a specifically defined user role. When identifying capturing and defining end user authorization access information that can be captured and defined includes but is not limited to a available roles b role accesses and authorities to information and integrations c static defined users d static user accesses and authorities to information and integrations e default role assignments for users and f management process for roles and users authorization.

External Data Source Authentication Control. Another step for a mobile app developer may include analysis of external data source authentication control. With each defined integration data source and software middleware there is the possibility for a credential requirement. This credential must be understood and defined. The authorities associated with that credential should be captured ensured and stored. The security of the credential can be addressed by using those processes and procedures known to those of skill in the art including but not limited to a encryption b obfuscation or c protected by intermediate server side authority like the development and operational platform or user registry.

Network Gateway Interaction. Yet another step a mobile app developer may include is analysis of the network gateway interaction. The network gateway interaction includes a capture and definition of the data being secured as it travels between different levels of network trust. Network trust levels to an organization can include but are limited to a private infrastructure not connected to internet b private infrastructure connected to internet behind a firewall c private infrastructure connected to the internet in a DMZ demilitarized zone d private infrastructure connected to the internet outside a firewall e private cloud infrastructure connected to the internet provisioned behind a firewall f public cloud infrastructure connected to the internet outside the firewall g general network h mobile device or sensor connected to a network behind a firewall i mobile device or sensor connected to a network in a DMZ and j mobile device or sensor connected to a network outside a firewall. Other network trust levels are known to those of skill in the art.

A mobile app developer may also need to understand and identify the asset location within the different levels of network trust. Each asset involved in the defined mobile system should have its relevant information identified and defined. Types of assets include but are not limited to a data sources location level b message sources c logic source d integration source e security registry sources and f mainframe or backend system to mobile implementation locations e.g. development and operational platform . The information to be understood includes but is not limited to a level of confidence can be defined by relevant industry standards like HIPAA PCI and b permanence of storage disk in memory in application session wire .

A mobile app developer may also need to understand and define the transfer between different levels of trust. This process may include identifying whether the mobile app needs the ability to work with VPN and other mobile tunneling strategies. Possible points of integration include but are not limited to a Virtual Private Network client b Mobile Application Management client c Mobile Device Management client and d Mobile Service Management client.

In the present invention specific computer code bases are written to implement commonly used security requirements e.g. for transmission storage end user authentication end user authorization access external data source authentication control and network gateway interaction discussed above although other aspects may be included or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . As one example a medical device has permission to write data to a backend database but not modify it the data is sent over SSL and when it is stored on the server it is encrypted on the local filesystem. In this example writing but not editing is handled using the security rules housed in the tools described under End User Authentication e.g. RACF Active Directory etc. For other examples specific computer code bases can include functionality defining available user roles read write privileges encryption and implementing various security protocols. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

The mobile app developer also needs to identify capture and define desired points of quality testing for the mobile app . For example for each tool feature or function that can be enabled by the mobile app interacting with the mainframe or backend system the developer may also want to provide testing functionality. For example an app developer may provide an automated unit test that can be run at any time for example using open source technology like Karma . These tests can be run on multiple devices after every change to the app is made. This concurrent testing method means the mobile app is tested frequently and will provide reassurance that the core functions of the app will not fail. In addition to the core unit tests a test runner can be used to run end to end tests to make sure the user will not experience any trouble using all the functions of the app as a whole. These tests can be partially generated automatically for common scenarios but also users or developers can record scenarios. This can be done by actually interacting with the app on the device and carrying out a set of tasks functionality. The automated test would fail if these recorded tasks are not able to be completed on newer versions of the app. If any other custom tests need to be written they can be done using the record method or by manually scripting the scenario into a test case. The quality measures can be captured and executed in the following order 1 information providers a data sources b messaging c logic execution 2 integration points including social context and 3 system behaviors . While other sequences are available the foregoing sequence was found to be optimal. In this sequence they build in functionality there is no need to run subsequent tests if the prior ones do not succeed.

In the present invention specific computer code bases are written to implement commonly used quality testing requirements or if available pre existing computer code sets already created can be used and populated in the preconstructed code set . For example a preconstruted test case can be written to ensure that an android application can read and update data contained in an external MySQL database when authorized as a general users. As discussed further below having the preconstructed code set allows the app mainframe interface to be automatically generated from the domain model .

While the foregoing analysis of information providers integration providers and system behaviors can be done through a manual process e.g. simply taking notes about the various features functionality and requirements of the app and interaction between the app and the mainframe enterprise back end system the foregoing analysis can also be automated through a computer interface where an particular app developer can select from a number of menus and screens to choose and enter information about the app developer s desired features and functionality and interaction between the app and the mainframe enterprise backend system . For example there may be a menu to select one or more data sources that can be pre populated with the possible data sources discussed above and for each data source the app developer may be able to specify the various input parameters as discussed above . Similar menus and capture screens can be used for the other features and functionality discussed above including but not limited to messaging logic execution advertising commerce financial transactions social performance analytics security including information storage end user authentication end user authorization access external data source authentication network gateway interaction and quality testing . The user selections can be stored in any standard computer readable format and when processed by a specific processors and predesigned logic can automatically generate the domain model for further processing. Doing so would allow the result of such analysis to be automatically converted into the domain model discussed further below.

The specific computer code bases in the preconstructed code set are preferably associated with a particular category or subcategory of the information providers integration providers and system behaviors . For example one specific computer code base to interact with the Oracle database using the Oracle driver protocol is associated with Oracle databases another specific computer code base to implement banner ads is associated with banner ads another specific computer code base to make posts to Facebook are associated with Facebook posts etc. Thus as the domain model is read and analyzed by the domain model processor discussed further below and the various features and functionality as defined by the domain model are interpreted associated specific computer code bases can automatically be identified and populated into the development and operational platform if only portions of the preconstructed code set are used as part of the app mainframe interface .

The preconstructed code set may also have internally defined associations relationships where if one specific computer code base is requested or needed for the development and operational platform as defined by the domain model other specific computer code bases are also populated to the development and operational platform and or app specific components created. For example if the domain model identified monetary exchange functionality as part of a financial transaction but the domain model did not separately identify any security requirements the financial transaction specific computer code base may be associated with one or more security specific computer code bases and those security specific computer codes bases including app specific connectors as appropriate may be automatically be identified and populated into the development and operational platform as part of the app mainframe interface .

While the preconstructed code set preferably contains extensive options for industry standard connections interfaces interaction features and functionality with the information providers integration providers and system behaviors as applicable it should be understood that each individual mobile app and mainframe enterprise back end system may still require custom developed code for desired connections interfaces interaction features and functionality as was discussed above with respect to logic execution . Such custom development can be implemented and stored on the development and operational platform either as part of the app mainframe interface or as separate computer code that interacts with the app mainframe interface .

Traditionally after software app developers understood the information providers integration providers and system behaviors they would undertake the time intensive process of actually writing the serverside and client side computer code for the app and the necessary features functionality and interaction between the mobile app and the mainframe enterprise back end system . This laborious process included writing the various computer code to access a particular data source to implement a particular messaging protocol to provide certain security functions etc.

In one aspect of the present invention once the information providers integration providers and system behaviors are captured and defined the domain model is created. As discussed above the domain model can be manually generated or automatically generated. Preferably the domain model is created in a computer readable format like but not limited to markup languages. This can include XML and with a well defined Document Type Definition DTD . The structure of the domain model will preferably follow the hierarchical path to understand and maintain the points of the information and integration. The domain model preferably contains relevant information to the entirety of the backend solution such that document renderers can provide rich editing and software infrastructure that are capable of consuming and implementing as discussed above. The domain model is in a machine readable format that can be processed and analyzed using separate computer logic.

Without limiting the foregoing the domain model could include one or more of the following information for each data source 1 destination server inputs such as IP address listening port s 2 credentials to access 3 target data name such as table name id or filename and 4 internal settings such as connection information or appkey app secret. Similarly the domain model could include one or more of the following information for message sources 1 destination server inputs such as IP address listening port s 2 credentials to access 3 messaging protocol details and 4 internal settings such as appkey appsecret. The domain model can similarly include the details for the other categories and subcategories described above.

The domain model preferably provides the configuration information to create an instance of connection for the app that is being built. As discussed above with regard to Oracle database connections the configuration information in the domain model allows creation of the app specific connectors. As another example of an optional app specific connector the domain model can include configuration information for analytics . For example if a user wanted to track how often the name John Doe was searched on a particular social network the domain model can provide the necessary configuration information to generate an app specific connector to track flag and report that essentially creating a new analytic rule or filter to be included as part of the app mainframe interface .

In the example shown in Appendix 1 SampleMobileSystem refers to the development and operational platform having key connection information and an access keys and secrets information e.g. user IDs and passwords . There are two separate apps designed to interface with the development and operational platform SampleMobileApp1 and SampleMobileApp2 each having key connection information and an access keys and secret information. For example SampleMobileApp1 might be designed to employees of an organization while SampleMobileApp2 might be for customers. This example also provides for three users Bob Sarah and Frank for different apps and an administrator each with IDs. The example also defined read write privileges for the various users. The example further provides for two attributes for cloud data source namely a user ID and a DOB. The example also provides for some data populated into the employee database related to Aaron and Charlie. For the inventory data source the example provides the necessary information for the app to interact with the data source. Obviously for each app and mainframe enterprise back end system the domain model will be different.

The domain model can be rendered for end user review in multiple ways including UML based domain model raw XML an HTML based webpage and or implementation model via a middleware provider known to those in the industry.

After the domain model is created either manually or automatically the domain model is processed and analyzed by a domain model processor to generate the app mainframe interface . In one embodiment the domain model processor reads the domain model and based on its content automatically accesses the applicable specific computer code bases from the preconstructed code set creates any app specific connectors and populates them to a predefined development and operational platform . In another embodiment the predefined development and operational platform contains the preconstructed code set the domain model processor reads the domain model and based on its content creates any app specific connectors and populates the app specific connectors to the predefined development and operational platform since the preconstructed code set already resides there . The compilation of specific computer code bases from the preconstructed code set and app specific connectors create a mobile consumable API consisting of the necessary connections interfaces interaction features functionality and requirements for the mobile app developer to interact with the mainframe enterprise back end systems and is depicted in as the app mainframe interface .

The app developer may then build the mobile app for example the user interface that interacts and interfaces with the app mainframe interface on the development and operational platform . The actual mobile app development can follow those standards know to those of skill in the art. The mobile app will eventually reside on user mobile devices. The app mainframe interface may have computer code i.e. logic to implement any of the features functionality and requirements discussed above including the following 

The app mainframe interface may also have computer code i.e. logic to implement the following capabilities 

The present invention may also involve the step of producing a complete specification document. The specification document may be created and stored by domain model processor or by separate logic and is preferably viewable and printable. The specification document describes the complete list of the available functions available to end consumer of the defined system via the API and SDKs and can be helpful to the app developer. SDKs are well understood to those of skill in the art but generally is a tool that developers use to access the API. An example of this documentation is shown in Appendix .

Implementation of the mobile app may involve using any number of native client rendering technologies known to those of skill in the art. Any of these technologies may consume the APIs provided or they may use the base app mainframe interface API. Such clients can include but are not limited to iOS Android Windows Mobile Blackberry Raspberry Pi Web Browsers Windows clients Linux Client MacOS client Cloud clients and iBeacon devices.

The navigation models used by these clients are expected to be mobile standard interactions and can include but is not limited to smart phone devices with tap swipe double tap edge pull multiple finger tap and fast scroll. The user interfaces for these devices and for the mobile app can include but is not limited to list select and finger drag and release. Other navigation models and user interfaces are known to those of skill in the art and are included within the scope of the present invention.

The present invention may also utilize input and interactions from remote sensors that may be separately provided for example from the mobile app the mobile device or some other input. These include but are not limited to temperature location altitude acceleration velocity photoluminescence infrared Bluetooth bluetooth low energy ibeacon radio frequencies moisture humidity time of day gravity specific gravity density geological composition molecular analysis flux electromagnetism gamma cell counts xray sonar tilt voltage resistance electrical current BTU air pressure and tank liquid level. In the present invention specific computer code bases are written to implement and provide interactions with the remote sensors and can be populated in the preconstructed code set . As discussed above if interactions are desired with one or more of the remote sensors for the mobile app having the preconstructed code set allows the app mainframe interface including this functionality to be automatically generated from the domain model . For particular sensors app specific connectors for these sensors may also be generated and used as discussed above. The remote sensors can be included as a category of a data source .

Referring to the exemplary embodiment of the development and operational platform may include one or more databases and memory storing the following executable computer code or logic server and reverse proxy web consol web sockets data access router analytics logic messaging database connectors and remote procedure caller . Other features and functionality can be included or excluded as described herein. The executable computer code or logic can be processed by a processing unit not shown of the development and operational platform . The processing unit may be a digital processor or other type of circuitry configured to run the various logic stored on the development and operational platform by processing and executing the instructions of the various logic. The processing unit communicates to and drives the other elements within the development and operational platform .

When stored in memory the various logic can be stored and transported on any computer readable medium for use by or in connection with an instruction execution system apparatus or device such as a computer based system processor containing system or other system that can fetch the instructions from the instruction execution system apparatus or device and execute the instructions. In the context of this document a computer readable medium can be any means that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The computer readable medium can be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. The memory can also be used to store any custom developed code generated by the app developer which can also be processed by the processing unit .

With continuing reference to traffic from the public interne e.g. from the mobile app may be first received by a server and reverse proxy . The server and reverse proxy provides the logic to route packets of data within the development and operational platform . In a preferred embodiment this can be an open source NGINX server and reverse proxy although other options are known and understood to those of skill in the art. Depending on the nature of the information received and processed information can be transmitted and processed by other logic as shown in . The database can be used among other things to locally store data that may be desired by the user. In a preferred embodiment the database is the open source database Cassandra.

The web console provides the logic for a user interface for the mobile app developer and or platform administrator to access the development and operational platform . The web console may interface and interact with various input devices for example a keyboard a switch a mouse and or other type of interface and various display devices used to display data to the user. The web console can be used to input data from a user generate and view reports analytics and other aspects of the development and operational platform .

The web sockets provides the logic to establish communication between the server and reverse proxy and the messaging and is well understood by those of skill in the art. For example if a message is being sent from a mobile smartphone to a sensor the web socket can translate the web traffic to a native messaging traffic for receipt and interpretation by the messaging logic.

As shown in in some instances traffic from the public internet e.g. from the mobile app may also be provided directly to messaging rather than routed through the server and reverse proxy .

The data access router provides the logic to determine among other things where to access data for example from the local database or from the mainframe enterprise backend system databases and is well understood by those of skill in the art.

The analytics logic and messaging provides the computer software code for implementing the logic for the analytics logic and messaging respectively discussed at length above. As an example the messaging logic can convert various messages to their base common denominator for further distribution and or processing. In this exemplary embodiment advertising financial transactions social performance security quality testing are not specifically shown but can obviously be included as would be understood to those of skill in the art. As discussed above some of skill in the art might include such logic in one or more of the categories disclosed in . As also discussed other features and functionality that are known to skill in the art could also be included in accordance with the concepts shown in .

The database connectors provide the logic to connect to the mainframe enterprise back end system databases which can also be a data source . The remote procedure caller is well understood by those of skill in the art and essentially acts as a traffic cop to instruct the system where to get certain data.

In this exemplary embodiment shown in the web console web sockets data access router analytics logic messaging database connectors and remote procedure caller which collectively constitutes the app mainframe interface are automatically generated from the domain model according to the present invention. The web console web sockets data access router analytic logic messaging database connectors and remote procedure caller are preferably in executable computer code format and provide all web assets including HTML javascript necessary to allow interaction between the mobile app and mainframe enterprise backend systems . In making the development and operational platform available to the mobile application developer the development and operational platform can also include the server and reverse proxy and optional databases .

The server and reverse proxy web consol web sockets data access router analytics logic messaging database connectors remote procedure caller or other connectors as described above and database may be provided on a single computer system or node e.g. a single LINUX box or deployed across multiple nodes. With regard to clustering like functional nodes most operate independently e.g. they know of each other s existence but do not require communication amongst the cluster. However in some embodiments for example if separate nodes include instances of the database and messaging internal synchronization mechanisms are preferably enabled. Thus a first node may include the server and reverse proxy web consol web sockets data access router analytics logic messaging database connectors remote procedure caller and database and a second node may include only messaging and database . In this example the remote procedure caller can connect to both messaging instances and both database instances web sockets can connect to both messaging instances the two messaging instances can be connected and the two database instances can be connected. In other embodiments a separate node can include a mirror instance of the configuration on the first node for example as a backup system.

As discussed above the web console web sockets data access router analytics logic messaging database connectors and remote procedure caller or other connectors as described above can include all the computer code from the preconstructed code set and or app specific connectors associated with that logic or it may contain only those portions of the preconstructed code sets and or app specific connectors for those connections features and functionality needed for the app mainframe interface for a particular app . As discussed above the phrase app specific connectors refers to the specifically configured modified computer code generated from the domain model and may be included within the web console web sockets data access router analytics logic messaging database connectors and remote procedure caller shown in and any other features and functionality described herein. Thus the analytics logic may include portions of the preconstructed code set and app specific connectors messaging logic may include portions of the preconstructed code set and app specific connectors and web console logic may have only those portions of the preconstructed code set associated with the web console e.g. no app specific connectors were generated for the web console logic .

Thus in one aspect the invention provides a process to construct a complete definition of backend requirements exposed in a standards way such they can be generically accessed and referenced from mobile device interfaces. These mobile device interfaces may include native smartphone UI based languages implemented as cross platform hybrid based applications or via pure autonomous based sensor applications. The method may include the some traditional steps undertaken by an app developer including identifying information providers and associated tasks discussed above and identifying integration providers and associated tasks discussed above and identifying system behaviors and associated tasks discussed above . The foregoing steps are then used to create a domain model which can be processed and analyzed by specifically programmed computer logic to automatically generate the app mainframe interface stored on and made available to developers on a development and operational platform . Thus in some ways the system and method can provide a tool kit of the necessary software tools connectors protocols and drivers to automatically create the necessary interface between the mobile app and the mainframe enterprise back end system .

Many of these concepts are best explained via a simple example. Take for instance a mobile app developer considering development of a mobile application that would use some contextual information from the mobile device require some data collections accessible from the device and also expect to interact with a sequence of systems of record within a corporate environment. For this illustrative example the app developer knows that following features functionality and requirements are desired 1 the mobile application senses where app users are in the store either through GPS or other geo fencing technologies 2 the system knows where a manager is in the store 3 the system knows the number of customers in a particular area of the store and the stockroom inventory related to that particular area of the store 4 authentication of the manager access to the stockroom inventory 5 ability of the manager to check available inventory and 6 if inventory is insufficient ability to submit a new PO to their supplier for more TVs.

For this illustrative example the mobile device requires knowledge of information providers and specifically data sources for database interaction integration providers for interaction with the procurement system and system behaviors for interaction with the GPS or geo location devices. After capturing each point s necessary configuration the domain model can be created either manually or automatically as described . For this example the domain model may be as depicted in Appendix 3. As discussed above after the domain model is created the domain model is processed and analyzed by a domain model processor to generate the app mainframe interface . The domain model processor reads the domain model and based on its content in this embodiment automatically pulls the applicable specific computer code bases from the preconstructed code set generates the app specific connectors and populates them to the development and operational platform for the app developer access.

As depicted in the examples of various embodiments the present invention may be implemented by a computer system to process the information and data gathered during the process. The volume of information processed combined with the speed at which the information must be processed makes the use of a computer system advantageous. The computer system will typically have a processor such as central processing unit CPU where the processor is linked to a memory an input and an output. A network computer may include several other components as well. For example the memory components may include a hard disc for non transitory or non volatile storage of information as well as random access memory RAM . Non transitory computer readable media in the present invention comprise all computer readable media except for a transitory propagating signal. The input components may include a keyboard a touchscreen a mouse and a modem for electronic communication with other devices. The output components may include a modem which may be the same modem used for the input or a different one as well as a monitor or speakers. Many of the different components may have varying physical locations but they are still considered a computer for purposes of this description. For example the memory may be on a hard drive in the same physical device as the processor or the memory component may be remotely located and accessed as needed using the input and output. The memory may also have one more programs to carry out the functions described previously. The memory components may also have one more databases along with related data.

