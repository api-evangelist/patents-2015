---

title: Network-layer application-specific trust model
abstract: A data verification system facilitates verifying whether a CCN Content Object is authentic or trustworthy on behalf of an application. During operation, the system can obtain a stack requirement for a custom transport stack, which specifies at least a description for a verifier stack component that verifies a Content Object using a key identifier (KeyID) associated with a publisher. The system instantiates the verifier stack component in the custom stack, and can use the custom stack to obtain a verified Content Object. While using the custom stack, the system can push, to the custom stack, an Interest that includes a name for a piece of content and includes a KeyID associated with a content producer. The system then receives, from the custom stack, a Content Object which the verifier stack component has verified is signed by the content producer associated with the KeyID.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09462006&OS=09462006&RS=09462006
owner: PALO ALTO RESEARCH CENTER INCORPORATED
number: 09462006
owner_city: Palo Alto
owner_country: US
publication_date: 20150121
---
The subject matter of this application is related to the subject matter of the following applications 

This disclosure is generally related to Content Centric Networks. More specifically this disclosure is related to a security component of a transport stack that verifies a Content Object on behalf of an application.

The proliferation of mobile computing and cellular networks is making digital content more mobile than ever before. People can use their smartphones to generate content to consume content or even to provide Internet access to other computing devices that generate or consume content. Oftentimes a device s network location can change as a person takes this device to a new physical location. This can make it difficult to communicate with this device under a traditional computer network e.g. the Internet when the device s new network location is not known.

To solve this problem information centric network ICN architectures have been designed to facilitate accessing digital content based on its name regardless of the content s physical or network location. Content centric networking CCN is one example of an ICN. Unlike traditional networking such as Internet Protocol IP networks where packets are forwarded based on an address for an end point the CCN architecture assigns a routable name to content itself so the that content can be retrieved from any device that hosts the content.

A typical CCN architecture forwards two types of packets Interests and Content Objects. Interests include a name for a piece of named data and serve as a request for the piece of named data. Content Objects on the other hand typically include a payload and are only forwarded along a network path that has been traversed by an Interest with a matching name and traverse this path in the reverse direction taken by the Interest packet. Typical CCN architectures only send Content Objects as a response to an Interest packet Content Objects are not sent unsolicited.

CCN architectures can ensure content authenticity by allowing publishers to sign content which allows consumers to verify content signatures. However typical CCN routers do not perform content signature verification on Content Objects to avoid incurring additional network latency. Some CCN routers also maintain a Content Store that caches content to minimize the round trip delay by returning a cached Content Object whenever possible. However content caching in routers opens the door for denial of service DoS attacks.

One such DoS attack involves content poisoning where an adversary injects fake content into a router s cache to flood the CCN network with fake content that blocks access to legitimate content of the same name. Applications can avoid becoming victim to content poisoning attacks by enforcing the use of self certifying content names or by verifying that the returned Content Objects is signed by a trusted entity. However this is only possible if the application knows the content s hash value ahead of time or has access to a set of digital certificates that bind the Content Object to a trusted entity. Implementing client applications that enforce CCN security measures can increase the complexity of client applications which can require the application s developer or local user to maintain an up to date set of trusted root certificates that can be used to verify Content Objects. Hence implementing client applications that enforce CCN security measures can require significant development costs and on going maintenance costs for the developer and the user.

One embodiment provides a data verification system that facilitates verifying on behalf of an application whether a CCN Content Object is authentic or trustworthy. During operation the system can obtain a stack requirement for a custom transport stack which specifies at least a description for a verifier stack component that verifies Content Objects using publisher key identifiers KeyIDs . The system instantiates the verifier stack component in the custom stack based on the stack requirement and can use the custom stack to obtain a verified Content Object that has been verified by the verifier stack component. While using the custom stack the system can push to the custom stack an Interest that includes a name for a piece of content and includes a KeyID associated with a content producer. The system then receives from the custom stack a Content Object which the verifier stack component has verified to be signed by the content producer associated with the KeyID.

In some embodiments the verifier stack component can verify Content Objects or Named Data Objects NDO s received over an Information Centric Network ICN or a Content Centric Network CCN . In ICNs each piece of content is individually named and each piece of data is bound to a unique name that distinguishes the data from any other piece of data such as other versions of the same data or data from other sources. This unique name allows a network device to request the data by disseminating a request or an Interest that indicates the unique name and can obtain the data independent from the data s storage location network location application and means of transportation. Named data networks NDN or content centric networks CCN are examples of an ICN architecture the following terms describe elements of an NDN or CCN architecture 

A single piece of named data which is bound to a unique name. Content Objects are persistent which means that a Content Object can move around within a computing device or across different computing devices but does not change. If any component of the Content Object changes the entity that made the change creates a new Content Object that includes the updated content and binds the new Content Object to a new unique name.

A name in a CCN is typically location independent and uniquely identifies a Content Object. A data forwarding device can use the name or name prefix to forward a packet toward a network node that generates or stores the Content Object regardless of a network address or physical location for the Content Object. In some embodiments the name may be a hierarchically structured variable length identifier HSVLI . The HSVLI can be divided into several hierarchical components which can be structured in various ways. For example the individual name components parc home ndn and test.txt can be structured in a left oriented prefix major fashion to form the name parc home ndn test.txt. Thus the name parc home ndn can be a parent or prefix of parc home ndn test.txt. Additional components can be used to distinguish between different versions of the content item such as a collaborative document.

In some embodiments the name can include an identifier such as a hash value that is derived from the Content Object s data e.g. a checksum value and or from elements of the Content Object s name. A description of a hash based name is described in U.S. patent application Ser. No. 13 847 814 entitled ORDERED ELEMENT NAMING FOR NAME BASED PACKET FORWARDING by inventor Ignacio Solis filed 20 Mar. 2013 which is hereby incorporated by reference. A name can also be a flat label. Hereinafter name is used to refer to any name for a piece of data in a name data network such as a hierarchical name or name prefix a flat name a fixed length name an arbitrary length name or a label e.g. a Multiprotocol Label Switching MPLS label .

A packet that indicates a request for a piece of data and includes a name or a name prefix for the piece of data. A data consumer can disseminate a request or Interest across an information centric network which CCN NDN routers can propagate toward a storage device e.g. a cache server or a data producer that can provide the requested data to satisfy the request or Interest.

In some embodiments the ICN system can include a content centric networking CCN architecture. However the methods disclosed herein are also applicable to other ICN architectures as well. A description of a CCN architecture is described in U.S. patent application Ser. No. 12 338 175 entitled CONTROLLING THE SPREAD OF INTERESTS AND CONTENT IN A CONTENT CENTRIC NETWORK by inventors Van L. Jacobson and Diana K. Smetters filed 18 Dec. 2008 which is hereby incorporated by reference.

In some embodiments the system can process a Content Object using the verifier stack component of the custom stack. While processing the Content Object the system can use a verifier module to verify whether Content Object is signed by the content producer associated with the KeyID. Then responsive to determining that the verifier module does not validate or invalidate the Content Object the system processes the Content Object using one or more trust checkers to determine whether the Content Object is trustworthy.

In some variations to these embodiments the system accepts the Content Object responsive to determining that at least one trust checker has determined the Content Object to be trustworthy.

In some variations to these embodiments the system rejects the Content Object responsive to determining that at least one trust checker has determined the Content Object to not be trustworthy.

In some embodiments the description of the verifier stack component includes a list of trusted certificate authorities.

In some embodiments the description of the verifier stack component includes a listing of one or more trust checkers to instantiate in the verifier stack component. A respective trust checker can analyze a Content Object to accept the Content Object reject the Content Object or defer verification of the Content Object to another trust checker.

In some embodiments the description of the verifier stack component includes an ordering for the one or more trust checkers in the verifier stack component.

In some embodiments the description of the verifier stack component includes an implementation for a respective trust checker.

In some variations to these embodiments the set of trust checkers can include a trust checker that rejects Content Objects with stale data.

In some variations to these embodiments the set of trust checkers can include a trust checker that rejects a public key which is not published under a white list name prefix.

In some variations to these embodiments the set of trust checkers can include a trust checker which verifies a Content Object using a Pretty Good Privacy PGP web of trust.

In some embodiments the system can receive from an application a control statement for the custom stack. The control statement includes a set of trust checkers to enable in the verifier stack component. The system then enables the set of trust checkers responsive to receiving the control statement.

In some embodiments the system can receive from an application a control statement for the custom stack. The control statement can include a set of trust checkers to disable in the verifier stack component. The system then disables the set of trust checkers responsive to receiving the control statement.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Embodiments of the present invention provide a security stack component that solves the problem of verifying on behalf of an application whether a CCN Content Object is authentic or trustworthy. The verifier stack component can be instantiated within a stack of the transport framework and performs transparent enforcement of the trust on behalf of the application or operating environment without requiring the application or operating environment to be involved in verifying the Content Object.

For example an Interest message can facilitate verifying a Content Object by specifying a public key of a content producer or specifying a self certifying name for the Content Object. The self certifying name can include an exact hash digest of the Content Object and can be obtained for example from a Content Object Manifest that references a collection of data. Any entity that disseminates or forwards the Interest can use the public key or the self certifying name to determine a trustworthiness of a Content Object received as a response to the Interest. If the entity knows the self certifying name of the Content Object this entity may not need to verify the signature of their corresponding Content Object the entity may just compute and compare the Content Object s hash value to the self certifying name.

In some embodiments if the client wants to obtain a secure Content Object the client can disseminate an Interest that includes a key identifier KeyID associated with the Content Object s content producer and or includes a ContentObjectHash field with the Content Object s hash. The KeyID is a hash of a public key for the content producer. When the network stack receives such an Interest the verifier component of the network stack can use the KeyID and or the ContentObjectHash fields to verify the authenticity and legitimacy of Content Objects with.

An application can use a transport stack on the local computer to disseminate the Interest for the Content Object and expects to receive a verified Content Object that was indeed published by the content producer associated with the KeyID. The transport stack disseminates the Interest and the verifier component can use the Interest s KeyID to verify the signature of the Content Object it receives to make sure the Content Object was signed by the trusted content producer.

To verify the Content Object the verifier component needs to have access to the public key required to verify the Content Object either from a local keychain or from a trusted third party e.g. a certificate authority . Also to make sure the public key is valid the verifier component computes the hash of the public key and compares this hash to the KeyID. The public key is valid if the public key s hash matches the KeyID.

Hence the verifier component of the transport stack implements a generalized trust model that can be bootstrapped or configured at runtime to implement any application specific trust model. This verifier component allows application developers to implement any robust and unique trust models that satisfy their application s need can leverage absolute trust anchors e.g. a certification authority identity and public key .

In CCN a forwarder maintains a forwarder information base FIB to control how Interests are forwarded across the CCN maintains a pending Interest table PIT to return Content Objects along a return path established by the corresponding Interest and maintains a content store CS to cache Content Objects. With the addition of content restriction fields such as the KeyID and the ContentObjectHash values the forwarder can operate on upstream Interests as follows 

For downstream Content Objects the forwarder uses information in the PIT and CS to determine if the Content Object can be satisfied by any entry in the PIT. With the addition of fields such as KeyID and ContentObjectHash in interest messages the forwarder limits objects which can be returned by the following rules 

The CCN architecture also supports Manifest objects to encapsulate metadata for large chunks of content as well as security and access control information. Manifest Content Objects have names that match the Interest and can include a list of self certifying Interest names SCNs for other pieces of content e.g. for chunks of a large content file . Since the Manifest object is itself a Content Object and carries a signature the list of SCNs can be trusted and used to issue a large number of interests with SCNs in parallel thereby increasing throughput and removing the need for signature verification. A description of Manifests is described in U.S. patent application Ser. No. 14 337 026 entitled System for Distributing Nameless Objects using Self Certifying Names by inventor Marc E. Mosko filed 21 Jul. 2014 which is hereby incorporated by reference.

Any device that disseminates an Interest for a Content Object can use the KeyID and or the ContentObjectHash value. In embodiments of the present invention the transport framework can verify a Content Object on behalf of an application that disseminated the corresponding Interest.

In the traditional IP architecture a forwarder is an IP based forwarder that looks at a packet s header to determine the source and the destination for the packet and forwards the packet to the destination. The conventional stack performs TCP UDP and an application interacts with the stack via a socket. In contrast device of the present invention doesn t use such a conventional stack. Rather device implements a transport framework which can dynamically configure a custom stack to satisfy an application s custom environment execution context. 

Specifically device can include a transport framework which can automatically create and or update a custom stack for a local application or the local operating environment e.g. without intervention of a local user the local operating environment and or any applications running on device . Device can also include a forwarder e.g. a network interface card or a router in a local area network which can transfer packets between custom stacks of transport framework and network . Custom stack can process packets to and or from forwarder or any application running on device and the stack s components can include any available components that can be organized in any order to satisfy the application s requirements.

In some embodiments transport framework can include a set of stack configuring agents that can dynamically configure a stack on demand. For example transport framework can include a set of transport API components that implement functions accessible via a library and or an API. An application can access an API implemented by transport framework by issuing a call to transport framework . Transport framework then maps the API call to a corresponding API component of components that implements this specific function and forwards the API call to this API component.

If a stack doesn t exist for processing the API call the API component can configure or instantiates a custom stack that can perform the application s API call. For example the API component can issue a request to transport framework with a request describing the functionality of the custom stack. This functionality description can be high level such as to specify a pre defined behavior or operation that is to be performed on data packets. Transport framework then realizes this behavior or operation by organizing the necessary components into a custom stack e.g. in custom stack components in an order that achieves the desired behavior or operation.

Alternatively the functionality description can be low level such as to specify the specific stack components that are to be used and can specify an order in which the stack components are to be arranged. Moreover the functionality description can also be specific or generic with respect to the individual components for example to request a specific security component e.g. a PKI verification component or to request any verification component. 

Each component in custom stack has a tuple of input and output queues such as an OutputQueueDown queue and an InputQueueDown queue for sending and receiving messages to from the next lower component in the stack respectively. The input and output queues also include an OutputQueueUp queue and an InputQueueUp queue for sending and receiving messages to from the next higher component in the stack respectively. Egress messages flow through components of tack one at a time through the downward queues e.g. from component toward component where each component reads processes and forwards the messages as needed. Ingress messages on the other hand flow through the stack upward from component toward component . The top stack component in stack interfaces with transport API components and the bottom stack component interfaces with forwarder .

In some embodiments stack can include a security component that performs transparent enforcement of the trust on behalf of the application or operating environment without requiring the application or operating environment to be involved in verifying the Content Object. For example security component can include a signer component and a verifier component . When security component receives an Interest from an application signer can store the Interest in a local repository to make the Interest s KeyID or ContentObjectHash value accessible by the verifier .

Verifier performs the operations to obtain the necessary public key associated with an Interest s KeyID verifying the public key and verifying the Content Object whose name prefix matches the Interest s name. Verifier can perform a remedial action when a public key fails verification e.g. by requesting another public key and can perform a remedial action when a Content Object fails verification e.g. by disseminating the Interest to request another Content Object that may pass verification .

In some embodiments the Content Object can include a Manifest. Manifests include a listing of one or more Content Objects that are part of a larger collection such as a movie file. The Manifest itself can also include a signature that can be used to verify the Manifest against a publisher s public key or KeyID. Also the Manifest includes any other information that is necessary for verifying the Manifest such as a reference to a certificate that includes the public key that was used to sign the Manifest. Verifier can perform PKI verification by using this reference to fetch the certificate from a trusted third party and determining whether security component can trust the certificate e.g. by following a chain of trust from a trusted root certificate to the Manifest s certificate .

If verification of the Manifest s certificate is successful verifier obtains the public key from the certificate and verifies the public key using the KeyID. If verification of the public key is successful verifier uses the public key to verify the Manifest s signature. If the Manifest s signature is successful verifier proceeds to send the Manifest to a higher stack component in transport stack e.g. to a Manifest handling stack component or to the application or operating environment that requested the Manifest .

Verifier also includes a trust circuit that can verify the Content Object based on additional attributes of the Content Object. For example if PKI verification cannot be used to accept or reject the Content Object e.g. if verifier cannot obtain the KeyID the public key or a certificate verifier can defer verification to the trust circuit. This trust circuit implements more complex trust verification techniques that are beyond the standard PKI verification framework. For example the trust circuit can include a sequence of trust checkers that can be defined by the application or the operating environment via the transport framework API.

In some embodiments the application or the operating environment can provide the instructions that implement a trust checker to the API of Transport Framework when instantiating security component in custom stack . The application can also provide a list of pre defined checkers to instantiate for the trust circuit and can provide an order in which these trust checkers are to be instantiated in security component .

Verifier can include a Control Point Interface CPI agent which accepts control statements from the application at runtime. The application can use the CPI to select at runtime which subset of trust checkers the application wants to enable or disable for a given Interest and the matching Content Object or for any future Interests and Content Objects. Hence when a trust checker is turned off the trust circuit can bypass the trust checker to forward all checks onto the next trust checker in the sequence of trust checkers.

On the other hand if the API call includes a CCN message the transport framework identifies a transport stack associated with the API call operation and forwards the CCN message to the identified transport stack operation . Also recall that a CCN message may include an Interest that serves as a request for a piece of data or may include a data object that carries data for the local application e.g. a CCN Content Object that includes data requested via an Interest . Hence the transport framework may analyze the CCN message to determine whether the message includes an Interest operation . If so the transport framework may receive a verified Content Object from the transport stack operation which was verified by the verifier component of the transport stack. The transport framework then returns the verified Content Object to the application operation .

During operation when instantiating the transport stack the application or the transport framework can bootstrap the verifier component to uphold a desired trust model. For example a local web browser can be preconfigured with a set of root Certificate Authority CA certificates which the browser can use to validate the signed data it receives. The web browser can instantiate a custom transport stack that includes the verifier component and bootstraps the verifier component to include this set of root CA certificates. Then when establishing TLS sessions over HTTPS the verifier can traverse the certificate chain starting at the target server and ending with a trusted CA certificate which validates the legitimacy of the public key used to encrypt and or sign the data. If the target server s certificate chain is not rooted in one of the default root CA certificates then the public key is not trusted and the user is typically alarmed. The browser application no longer needs to traverse the certificate chain itself to validate signed or encrypted data packets.

Recall that the stack components can include a Control Plane Interface CPI that serves to configure components in the transport stack. In some embodiments the local application can use the CPI to issue a CPI call directly to the security component or verifier component to send configuration information that reconfigures or updates the trust model of the verifier component. The CPI call can include a CCN message can encapsulate JSON encoded commands and is sent asynchronously from the CPI to the target stack component e.g. the security component or the verifier component to modify the stack component s internal state.

The command in the CCN message includes an object with a command identifier string and payload options for the command. For example to cancel a flow controller session for a particular namespace prefix a JSON encoded command wrapped in a CCN Message is sent to the FlowController component. An exemplary JSON encoded CPI command is presented in Table 1.

When the transport framework receives a CPI call the transport framework can asynchronously invoke the CPI event handler CPI agent that parses the CCN Message instance extracts the command identifier and associated options payload from the JSON object and performs a lookup to identify a stack component that has registered itself with the command identifier. The CPI event handler then forwards the CCN Message instance to the matching stack component that performs the command s operation e.g. to cancel the flow session .

In some embodiments the verifier component can register CPI commands with the CPI event handler. Two exemplary commands include a whitelist modification command and a blacklist modification command. The whitelist command or blacklist command can add remove a whitelist source and remove add a blacklist source from the trust circuit gate in the verifier component of the stack. The options payload for a whitelist command or a blacklist command can include a set of keys and has for each key a list of namespace prefixes that are to be added or removed to from the whitelist source or blacklist source.

In some embodiments the default behavior for the last gate in the trust circuit may be set to automatically reject messages since they have not been verified by any of the prior gates. However application developers may wish to negate this behavior to be more trustworthy. Another exemplary CPI command registered by the verifier component can include a set trust circuit end gate defer action command that configures the default behavior of the last trust checker in the verifier component s trust circuit.

Yet another exemplary command registered by the verifier component can include a toggle advanced trust circuit gates that enables or disables the trust circuit in the verifier component. When enabled the verifier component forwards incoming messages into the test circuit if they pass the basic trust policy test. If disabled only the basic trust policy test will be enforced and the verifier component does not forward messages to the trust circuit.

Recall that an application can disseminate an Interest that includes a KeyID to request a Content Object which has been signed by an entity associated with the KeyID. For this reason the security component stores Interest messages so that the security component can access their KeyID when verifying their matching Content Objects. Hence while analyzing the message the signer determines whether the message includes an Interest operation and if so the signer can store the Interest in association with the application operation . The signer then forwards the message to another component of the transport stack operation .

On the other hand if the message does not includes an Interest e.g. the message include Content Object or any other data object that needs to be transmitted over the computer network the signer determines whether the message needs to be signed operation . If the message does not need to be signed the signer proceeds to forward the message to the next component of the transport stack operation . Otherwise the signer proceeds to sign the message operation before forwarding the message to the next component of the transport stack operation .

Recall that the security component enforces trust management on pairs of Interests and Content Objects. For example an ingress Content Object received by the verifier component needs to be associated with an egress Interest that was issued by an application. Because of this packet analyzer analyzes messages to detect Interests and caches these Interests in an Interest repository e.g. a queue as they flow through signer component . The verifier component can access Interest repository to find a matching Interest to the Content Objects it receives.

In normal operation Interest messages bypass packet signer . Hence packet analyzer forwards Interests to lower stack component input queue . On the other hand when packet analyzer detects a Content Object packet analyzer forwards the Content Object to packet signer that signs the Content Object as it passes through signer component .

If a KeyID was found the verifier component verifies whether the Content Object was signed by a content producer associated with the KeyID operation . Also if verification was successful the verifier accepts the Content Object operation and proceeds to forward the verified Content Object to the application which disseminated the corresponding Interest operation .

On the other hand if a KeyID was not found operation or if verification was not conclusive operation the verifier can process the Content Object using one or more trust checkers to determine whether the Content Object is trustworthy operation . Some example trust checks can include 

The verifier then determines whether the trustworthy checks determined that the Content Object is trustworthy operation . If the Content Object is trustworthy the verifier accepts the Content Object and forwards the Content Object to the application operation . Otherwise the verifier rejects the Content Object operation and may perform a remedial action. The remedial action can include for example writing the failed verification operation in a log file informing the application of the failed verification check and providing the Content Object to the application and storing the Content Object in a repository of rejected Content Objects.

Another remedial action may include blacklisting the content producer which returned the Content Object and or re submitting the Interest to obtain another matching Content Object from another content producer. This allows the verifier component to initiate additional attempts at obtaining a verifiable Content Object on behalf of the application.

Recall that the security component enforces trust management on pairs of Interests and Content Objects. When verifier component receives an ingress Content Object verifier component performs a lookup operation in an Interest repository to search for the corresponding egress Interest message that was issued by a local application. Verification checker uses the KeyID and the ContentObjectHash of the egress Interest message to verify the Content Object.

Test circuit can perform advanced trust policy enforcement on the Content Objects which involves processing the Content Object using one or more trust checkers .

For example a key namespace checker . can check whether the public key used to verify the signature of a Content Object was generated by a key belonging to a trusted namespace. For example content published under the pax namespace can be signed by a key belonging to the xerox namespace such that the xerox namespace is a whitelisted namespace to trust any keys published under the xerox namespace.

In some embodiments verification checker can use a flat trust model which is a special case of a hierarchical PKI trust model. Specifically in the flat trust model an application explicitly identifies the certificates of Content Objects the application trust. Verification checker only accepts Content Objects signed using these identified certificates and as a result does not need to perform certificate chain traversal.

A stale data checker . can check whether the signature of a Content Object is not older than a predetermined time range such as a week month a year etc.

A tail checker .can perform a preconfigured operation such as to accept messages by default or reject messages by default. An application can configure the default operation via the CLI for verifier component .

A web of Trust WOT checker not shown in can maintain a cache of self signed trusted identities e.g. public key hashes and uses this identities cache to enforce a web of trust model. Content Objects are deemed trusted if they are signed by a trusted key. When a new identity Content Object is received and passed into trust circuit the WOT checker can check whether the verification key was signed by one of the already trusted identities in the trusted identity cache. If so the verification key is accepted and a reference count associated with the new identity is incremented. In some embodiments the WOT checker can grow the set of trusted keys organically. For example if a reference count for a new identity exceeds a predetermined threshold e.g. three valid references then the WOT checker can add this new identity to the trusted identity cache.

The web of trust model is a decentralized alternative to the more centralized PKI model. The fundamental idea of the web of trust model is that nodes can independently elect to trust an identity and public key binding certificate without the presence of a trusted CA. More specifically nodes can vouch for the trustworthiness of certificates individually or as a group. Nodes can either be partially trusted or fully trusted. Fully trusted nodes which vouch for a certificate binding automatically extend the web of trust. Conversely a group of nodes e.g. three or more must vouch for the same certificate binding before the web of trust is expanded.

For example a movie streaming service running on CCN can categorize content hierarchically based on content type e.g. movie television genre e.g. action comedy romance and year. To simplify key management a hierarchy of keys for each name prefix may also be used. For example the named data object NDO with name netflix movie action 2013 TheAvengers may be signed by a key named netflix movie action 2013 key which is in turn signed by a key named netflix movie action key and so on up to the root key named netflix key which is signed by a trusted CA. With this type of trust model the Content Object associated with the name netflix movie action 2013 TheAvengers is trusted if the key chain from netflix movie action 2013 key to netflix key is verified successfully.

To implement and enforce this particular trust model in CCN an application developer would only be required to complete the following two steps 

As a further optimization to avoid lengthy certificate chain traversal the application developer could acquire and cache certificates associated with sub namespaces within the Netflix naming hierarchy and add them to the trusted whitelist within the stack. For example the certificates associated with the name prefix netflix key netflix movie key and netflix movie action key could all be added in the trusted whitelist to circumvent certificate chain traversal for Content Objects belonging to the netflix movie action namespace.

As an alternate example consider an application that implements a PGP like web of trust model. As previously described the set of trusted identities e.g. public keys and self signed certificates expands in a user based collaborative manner. Specifically if more than three identities vouch for the trustworthiness of another previously untrusted identity then the application can deem the identity to be trusted by consensus. In this example we assume all identities are self signed which means that the organic growth of the set of trusted identities grows only by user group consensus.

To implement and abide by this particular type of trust model an application developer need only instantiate verifier component with a trust circuit that contains a web of trust WOT checker. Then the application can use the CPI to specify a preliminary set of trusted identities in the WOT checker. The WOT checker caches these trusted identities for future operation which are each specified as hashes of their public keys.

In some embodiments stack interfacing module can obtain a stack requirement for a custom stack and can forward packets between an application and the custom stack. Stack configuring module can instantiate or configure a stack to satisfy the stack requirements.

Verifier module can process a Content Object for the custom stack to verify whether the Content Object is signed by the content producer associated with a given KeyID. Forwarder module can forward CCN Messages between a local stack and a computer network e.g. a content centric network .

Data verification system can include instructions which when executed by computer system can cause computer system to perform methods and or processes described in this disclosure. Specifically data verification system may include instructions for obtaining a stack requirement for a custom stack and for forwarding packets between an application and the custom stack stack interfacing module . Further data verification system can include instructions for instantiating or configuring a stack to satisfy the stack requirements stack configuring module .

Data verification system can include instructions for processing a Content Object for the custom stack to verify whether the Content Object is signed by the content producer associated with a given KeyID verifier module . Data verification system can also include instructions for forwarding CCN Messages between a local stack and a computer network e.g. a content centric network forwarder module .

Data can include any data that is required as input or that is generated as output by the methods and or processes described in this disclosure.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore the methods and processes described above can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

