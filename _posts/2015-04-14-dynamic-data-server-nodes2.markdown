---

title: Dynamic data server nodes
abstract: A system of dynamically-instantiated data server components provides access to a data repository. Different data server components are assigned to different data collections in the repository. A distribution component receives messages and, based on data collection identifiers associated with the messages, routes the messages to corresponding data server components. Based on the messages, the data server components perform data operations with respect to their corresponding data collections. Data server components may be terminated when their assigned data collections are not in use. When an incoming message is associated with a data collection for which no data server component exists, the distribution component dynamically instantiates a new data server component for the data collection. In an embodiment, data server components make working copies of their respectively assigned data collections in a high-speed memory. By terminating inactive data server components, the system makes room in the memory for active data collections.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09660930&OS=09660930&RS=09660930
owner: Splunk Inc.
number: 09660930
owner_city: San Francisco
owner_country: US
publication_date: 20150414
---
The present application claims benefit as a Continuation of U.S. application Ser. No. 14 217 454 filed Mar. 17 2014 the entire contents of which is hereby incorporated by reference as if fully set forth herein. The applicant s hereby rescind any disclaimer of claim scope in the parent application s or the prosecution history thereof and advise the USPTO that the claims in this application may be broader than any claim in the parent application s .

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

Generally a data server system is a system that performs data operations with respect to data stored in one or more repositories of data. Depending on the type of data server system the data operations may range from simple operations such as storing and retrieving the data to more complex operations such as calculating statistics based on the data and or arranging or formatting the data. One example of a data server system is a relational database system in which data is stored in highly structured tables and accessed through rigid schemas. Another example of a data server system is a file system such as a Network File System server. Yet another example of a data server system is a web application server.

Another example of a data server system is an event based system such as the SPLUNK Enterprise software produced and sold for on premise and cloud use by Splunk Inc. of San Francisco Calif. In some event based systems data is derived from lines or rows of unstructured time series data. Some of the many examples of such data include web logs and machine logs. Each row or a group of rows is generally associated with a timestamp and a series of one or more associated data points or parameter value pairs. Based on the timestamps data structures known as events are derived from the associated data and include a portion of the associated data. A variety of event types may be derived from such data. For example in the context of web logs events may be derived for errors specific user inputs navigation events and so forth. Some event based systems feature flexible schemas that may be redefined as needed or even at the time that a request to perform an operation is received. Such a schema indicates how to extract one or more pieces of data from the associated data included in an event.

In these and other types of data server systems it can be difficult to optimally perform data operations particularly as the size and or complexity of a data repository grows. System administrators may add additional system resources to improve performance but often these resources may not achieve the desired results and or the added expense and overhead for the additional system resources is undesirable.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

According to embodiments a system of isolated dynamically instantiated data server components provides efficient access to a repository of data that has been subdivided into data collections. Each of the data collections may comprise for instance time series event logs database table s and or other type s of data structures. The data server components hereinafter referred to as data server nodes provide access to the repository by performing read and write operations on the data within the repository in response to messages from the clients. Each data server node provides access to only some or even just one of the data collections within the data repository. A data server node that provides access to a particular data collection is said to be assigned to that particular data collection. One or more distribution nodes receive messages from clients and based on data collection identifiers associated with the messages route the messages to the assigned data server nodes. In an embodiment among other effects because each data server node operates on only a limited collection of data the data server nodes execute more efficiently by avoiding unnecessary overhead for managing and interpreting the other data collections found within the repository.

Furthermore because each data server node operates on only a portion of the repository data server nodes may be terminated after a certain period of time when the data collections to which they are assigned are not in use. The distribution node s keeps track of the existing data server nodes and their assigned data collections. When a distribution node receives a message that is associated with a data collection for which no data server node exists either because the data collection has not yet been accessed or because the data server node previously assigned to the data collection was terminated the distribution node dynamically instantiates a new data server node and assigns the data collection to the new server node. The distribution node s will then route messages associated with the data collection to the new data server node until the new data server node is terminated. In this manner among other effects system resources allocated to inactive data server nodes are freed up for other data server nodes. Thus the system avoids unnecessarily wasting processing resources with dormant data server processes.

Moreover in an embodiment the system may be configured such that some or all of the data server nodes copy their respectively assigned data collections in whole or in part from a slower storage in which the data collections are persistently stored to a random access memory RAM or another high speed memory. The data server nodes then operate entirely with respect to this copy the working copy of its data collection though other processes may copy the working copy back to the persistent storage as needed. While it would typically be impractical to store an entire data repository within a high speed memory it is much more practical to store only the data collections that are actively being used in a high speed memory. By terminating inactive data server nodes when they are not needed their corresponding data collections are consequently removed from the higher speed memory making room for data collections that are actively being used. Thus this embodiment allows for among other advantages data server nodes that store working copies of their assigned data collection s entirely within a higher speed memory without requiring that the higher speed memory be large enough to store the entire repository. Consequently the speed with which the data server nodes operate is typically greatly increased.

In an embodiment different data collections in such a data server system are assigned to different software applications. A developer of a software application is assigned a unique identifier referred to as an application key and instructed to embed the application key in any requests that the software application makes to the data server system. In this manner when end users run the software application on their devices the software application may access the same data collection regardless of on which devices the software application executes. The software application may then utilize the data collection for a variety of purposes such as tracking application usage and performance logging error messages maintaining user records and so forth.

In an embodiment the operator of the data server system may further provide developers with software libraries and or application programming interfaces that when called from within the software application automatically cause the software application to send event messages related to the foregoing along with the assigned application key to the data server system. The data server system logs the event messages to the corresponding data collection and then provides analytics with respect to the event messages as requested by the developer. For instance a mobile software developer may utilize such functionality to track how many devices have installed the developer s software the types of devices on which the software is installed how frequently the software is accessed how frequently certain types of errors occur and so forth. In other embodiments however data collections do not necessarily correspond to specific software applications and or a software application may access multiple data collections independently of any software libraries or application programming interfaces provided by the operator of the data server system.

According to an embodiment a data server system provides an enhanced interface for requesting performance of time related data operations. The data server system is configured to receive and recognize one or more constructs that define a time context in which the data server system should operate. The time context is an arbitrary time period relative to which certain data operations should be performed. Once such a construct is received the data server system receives commands to perform a plurality of operations within the time context until the time context is terminated and or a new time context is defined. The commands need not each redefine the time context greatly simplifying the statements needed to instruct the data server system to perform certain operations and or algorithms. According to an embodiment another construct defines an embedded time context which overrides an existing time context until the embedded time context is terminated.

In an embodiment the above constructs are provided in the context of a scripting language supported by the interface and interpretable by data server nodes such as described herein. Other aspects of the scripting language are described herein. In yet other embodiments a data server system is configured to perform data operations on incoming messages or requested by incoming messages by processing data within the messages and or within a data collection using scripts written in a scripting language such as already stated. The scripts enable the data server system to receive and process requests to perform data operations that are based on complex customizable algorithms in addition to requests that include more traditional query statements. In an embodiment the scripts are not compiled but rather interpreted in real time and thus may be added or changed dynamically without restarting the data server system.

According to an embodiment a data server system supports the generation of view modules based on a data collection. View modules comprise data visualizations such as described herein. Each view module including its data and corresponding visualization technique is described by a script such as already stated. The data server system returns the view modules alone or in a group via a web page image or other data to a web browser or other suitable client application.

Other embodiments include without limitation a non transitory computer readable medium that includes processor executable instructions that enable a processing unit to implement one or more aspects of the disclosed methods as well as a system configured to implement one or more aspects of the disclosed methods.

The data processing techniques described herein are suitable for use by systems deployed in a variety of operating environments. For example illustrates an example network based system of computing devices in which the described techniques may be practiced according to an embodiment.

System comprises one or more data storage devices that collectively store among other data one or more data repositories . The data storage devices may be for instance non volatile computer readable media such as hard disk drives flash SSD drives RAM and so forth. Additionally or instead the data storage devices may be devices that comprise non volatile computer readable media such as disk arrays storage area network devices networked attached storage devices file server devices or any other suitable data storage apparatus. Storage devices may store the one or more repositories in any suitable underlying form s such as disk blocks file structures and or database tables. Where multiple storage devices are used different portions of a data repository may be stored on different storage devices . Optionally certain storage devices may be configured to store some or all portions of a data repository redundantly using any suitable backup and or synchronization mechanism s .

System further comprises one or more client devices that directly or indirectly require read and or write access to the one or more data repositories . Client devices are general or special purpose computers such as personal computers mobile phones tablet computers laptop computers web servers application servers and so forth. Depending on the embodiment client devices may all be a same type of computing device or client devices may include a number of different types of computing devices. Generally client devices comprise one or more processors and or other suitable components configured to execute computer readable instructions.

The computer readable instructions executed by client devices implement logic for one or more client applications. These client applications may be for instance standalone applications whose instructions are found in software packages that have been installed on the executing computing devices browser based applications that are downloaded and executed transiently within the context of a web browser web applications whose instructions are executed by a web application server in response to requests from other client applications plug in modules of code whose instructions are called in response to various triggering events within the context of other applications or the operating system itself and so forth. Each client device may execute any number of client applications that require access to data repositories .

System further comprises one or more data server devices . Data server devices may be general or special purpose computers comprising one or more processors and or other suitable components configured to execute instructions for processing and manipulating data within the data repositories . Data server devices may be coupled to data storage devices using any suitable mechanism such as a Fiber Channel network a Serial ATA link a Universal Serial Bus connection an Infiniband link an Ethernet connection and so forth. Data server devices send input output requests to storage devices . These input output requests may be communicated via messages in any suitable protocol s depending on the environment including without limitation Server Message Block protocol Network File System protocol Small Computer System Interface protocol and or Fibre Channel Protocol. In response data server devices receive data structures such as data blocks files tables result sets and so forth. In an embodiment the data server devices may actually comprise some or all of the storage devices .

The instructions for processing and manipulating data that are executed by the data server devices generally implement data server processes. These processes provide client devices with read and or write access to the one or more data repositories by performing data operations in response to requests from the client devices . These processes may also or instead perform data operations with respect to the one or more data repositories that are triggered by messages from the client devices rather than explicitly requested by client devices . The data operations supported by these processes may include relatively simple operations such as adding or retrieving lines or rows of data from the data storage devices. In some embodiments the supported data operations may further include without limitation operations such as filtering the contents of retrieved data or performing aggregations or other calculations based on the retrieved data.

In an embodiment these data server processes generally constitute one or more event streaming engines optionally offering data semantics and processing during the data input phase and or data analysis phase. In another embodiment these data server processes generally constitute one or more conventional database servers such as a relational database server. However in other embodiments these processes need not necessarily support the entire functionality of an event streaming engine or database server or even operate on conventional database or event structures. Moreover in at least one embodiment the data server processes provide support for data operations hitherto not found in any conventional database server or event streaming engine.

In an embodiment each of storage devices are equally accessible to each of the data server devices and thus any data server device may perform operations on any data stored within the data repository . In other embodiments each data server device is assigned to only some or even one of the data storage devices and is only configured to perform operations on the storage device s to which it is assigned.

The data server devices comprise network interface components that receive messages from client devices over one or more networks . The data server devices further utilize these network interface components to reply to client devices with data resulting from at least some of these data operations. The one or more networks may include any combination of wide area networks such as the Internet virtual networks and or local networks. Different client devices may send requests to different data server devices or the client devices may be configured to send requests to only one of the data server devices . In the former embodiment different client devices may be configured to send requests directly to different ones of data server devices or all client devices may be configured to send requests to a load balancer within the network s . The load balancer then determines to which of data server devices a given request should be sent based on factors such as server load and latency.

In an embodiment the data server devices collectively implement a data server system for accessing a data repository . A client device may access the data repository through any of the data server devices . The data server devices may further communicate amongst themselves to request that different data server devices perform certain operations or portions thereof. For example the data server devices may support algorithms and or frameworks for parallelizing certain operations such as the MapReduce framework. As another example a data server device may be configured to ship operations to other data server devices if the data server device is unable to access a data storage device upon which necessary data is stored. In an embodiment additional data server devices may be added to the data server system on demand.

System is only one example of the many types of operating environments in which the techniques described herein may be practiced. Other suitable operating environments may include additional or fewer elements in varying arrangements. For instance in an embodiment some or all of the data server devices are replaced by virtual server devices some or all of which may execute on a single computing device. In another embodiment some or all of the client applications may execute on the same computing device as some or all of the data server processes.

System utilizes data repository implemented upon the one or more storage devices depicted in . The data repository comprises a plurality of data collections . Each data collection may be a collection of data structures having a variety of forms depending on the embodiment. For example in an embodiment each data collection comprises a collection of event data structures. In another embodiment each data collection comprises a group of lines of tab delimited data. As further examples in other embodiments each of data collections is a relational database relational database table set of eXtended Markup Language XML elements or one or more files. In yet other embodiments data collections may comprise data structures of any other suitable structure type. In an embodiment different data collections within the same repository may support different data structure types. In an embodiment a data collection comprised of any of the foregoing data structures is augmented with system defined and or user defined variables that can be updated to describe certain characteristics of the data stored in the data collection . Examples of such variables may include counters or metrics.

Each data collection is associated with collection configuration data . Collection configuration data may itself be stored in the data repository or collection configuration data may be stored outside of the data repository . Collection configuration data describes various aspects of its associated collection such as one or more identifiers for the collection a number of fields found within the collection a maximum collection size and so forth.

In an embodiment each data collection is associated with a unique collection identifier that is assigned when the collection is created. In an embodiment the collection identifier is the name of a software application or an application key assigned to a software applications or applications for which the data collection is maintained. In an embodiment the collection identifier is a name or other identifier for a user or user group. In an embodiment any other suitable collection identifier is used. While only eight data collections are depicted data repository may in fact comprise many more data collections.

In an embodiment each data collection is stored redundantly on multiple data storage devices and synchronized there between. In an embodiment each data collection is found on only some or even one of storage devices .

Data server system comprises data server nodes . Each data server node is a set of one or more processes executed by processors or other suitable components within data server system that performs data operations with respect to one or more data collections along with associated in memory data structures that support the data operations. A data server node is said to be assigned to the collection s with respect to which it performs data operations. While only three data server nodes are depicted system may comprise many more data server nodes . Each data server node operates entirely on a single data server device although a data server device may execute any number of data server nodes as resources permit.

A data server node performs data operations in response to requests received by data server system . Requests may take any suitable form depending on the embodiment. For instance in an embodiment requests may be formatted as Hyper Text Protocol HTTP GET requests or POST requests. In another embodiment requests may take the form of statements in a query language such as Structured Query Language SQL . Depending on the embodiment a request may command a data server node to perform any type of data operation that is applicable to the data collection s to which the data server node is assigned including without limitation those data operations described in other sections. In an embodiment a request may simply be a message such as an event message or log message that implicitly instructs the data server node to process the message by performing one or more data operations with respect to data found within the message.

As a result of the performed operations the data server node may cause data within an assigned data collection to be updated and or return response data that comprises data retrieved from the assigned data collection or derived based thereon. Response data may be of any suitable structure including without limitation the same structures in which the retrieved data is stored within the corresponding data collection converted structures such as SQL result sets or XML documents or derived structures such as web pages or images analyzing or visualizing the retrieved data. In an embodiment certain returned structures in response data are generated by applying the retrieved data to templates and or formatting instructions.

System comprises a collection to node mapping that lists each existing data server node within system e.g. by a combination of device address and port number or any other suitable addressing scheme along with identifier s for the data collection s to which the data server node is assigned. For each data collection there is at any given point in time no more than one data server node assigned to the collection . A data server node remains assigned to the same collection s until the data server node is terminated. In an embodiment each data server node is assigned to only one of collections . In an embodiment on account of other components described in other sections there is not always an existing data server node assigned to a given collection even if a data server node has previously performed operations with respect to the given collection .

In an embodiment each data server node executes in an isolated mode meaning that each data server node operates independently of other data server nodes even if co located on the same computing device. Thus if one data server node crashes the remaining data server nodes will be unaffected. In an embodiment one technique for ensuring isolation is to execute each data server node within a separate system runtime although any other suitable isolation technique may be utilized.

In an embodiment each data server node is an instantiation of the same execution logic meaning that each data server node operates in essentially the same manner but with respect to a different data collection. In other embodiments some data server nodes may execute different execution logic than other data server nodes . For instance collection configuration data may include parameters that impact how a data server node processes a collection . As another example system may support different pre defined types of data server nodes each type supporting different data operation sets and or outputting data in different manners. The type of data server node used for a collection may be assigned for instance by collection configuration data . In an embodiment configuration data may specify that certain data server nodes use certain data processing instructions for certain operations while other data server nodes utilize other data processing instructions for the certain operations. For instance certain collections may optionally be linked to files that contain custom instructions for processing certain types of commands.

As depicted data server nodes operate on working copies of collections instead of directly on collections . In an embodiment each working copy is a complete copy of its corresponding collection although in other embodiments the working copy may be of only a most recent segment of the corresponding collection . Data server system comprises one or more collection loading components that generate these working copies as needed.

The working copies are stored within memory which is a collection of one or more memory components within the data server system . The one or more memory components are generally of higher speed than the storage devices upon which data repository is stored. The one or more memory components may be for example random access memories flash memories combinations thereof and so forth. While often volatile the one or more memory components may also or instead include non volatile components. For convenience any memory component that is on average faster in response time than the storage devices at which data repository is stored are referred to herein as high speed or higher speed memories. For systems that are distributed amongst multiple data server devices each data server node will store its working cop ies within components of memory that are local to the data server device upon which the data server node executes.

The working copies are in an embodiment stored within memory for the entire lifetime of their respective data server nodes . Thus collection loader only needs to load the working copy into memory when the data server node is first instantiated regardless of how many operations the data server node performs. Accordingly any operation requested subsequent to instantiation of a data server node benefits greatly from having a working copy of the assigned data collection already resident within memory .

Data server system further comprises one or more collection saving components . In a process sometimes referred to herein as dumping collection saver copies working copies back to the repository to ensure that the changes to working copies are not lost if their corresponding data server nodes crash or are terminated. In an embodiment collection saver operates asynchronously relative to data operations so as to ensure that the data operations are not required to wait for data to be copied back to the repository .

In an embodiment collection saver saves working copies to repository in response to detecting triggering conditions such as detecting a certain number of changes and or the elapsing of a certain amount of time. For instance collection saver may be configured to dump a working copy every five minutes or after every one hundred write operations. In an embodiment the exact triggering conditions may vary from collection to collection . An amount of time to wait before dumping a working copy to repository may be defined for instance in collection configuration data . In an embodiment a collection saver comprises a priority based scheduling component by which working copies are assigned priorities based on factors such as number of changes recency of changes and application specific weights. Collection saver then dumps working collections based on their priorities as resources permit. In an embodiment collection saver is configured to dump a working copy before or in response to termination of a data server node that is assigned to the corresponding collection .

In an embodiment each data node may comprise its own collection loader component and or collection saver component . In an embodiment a single collection loader and or collection saver may execute on each device within data server system and each data server node may be configured to call the collection loader and or collection saver as needed. In an embodiment the collection saver may be configured to monitor and optionally even maintain working copies independently of their corresponding data server nodes .

In other embodiments some or all of data server nodes may instead be configured to perform operations with respect to a collection without maintaining an in memory working copy of the collection . While in some of these embodiments portions of the collection may still be loaded into memory the portions will typically be loaded into memory solely for the purpose of performing an operation and may be removed from memory at any time after the operation is concluded.

Data server system further comprises one or more message routers . Message routers comprise processes configured to distribute incoming requests to different data server nodes . Each data server device may comprise a message router component or data server system may comprise a single message router component assigned to a single data server device that is designated to handle all incoming requests .

A request is initially directed to a message router which then determines which of collections is targeted by the request . For instance request may include a collection identifier for one of collections . Using collection to node mapping data the message router may determine which data server node is assigned to the collection identified by the identifier. The message router may then forward the request to the corresponding data server node . In embodiments with multiple data server devices a message router may forward requests to data server nodes on other devices .

In some embodiments a data server node sends any response data back to the message router which then forwards the response data back to the original requestor. In other embodiments a data server node sends response data directly back to original requestor.

In an embodiment the message router instead sends a new request to the assigned data server node . For instance the message router may be configured to translate an incoming message to a different protocol that is more efficient or otherwise desirable and or to generate specific data commands based on an incoming message. Similarly a message router may be configured to translate result data into a response message in a more desirable response protocol or even embed result data in other data structures such as web pages or documents.

As a consequence of various mechanisms described herein a message router may find that an incoming request is targeted to a collection that according to collection to node mapping data is not currently assigned to an existing data server node . Data server system thus comprises one or more node instantiation components . When an incoming message request or implies a data operation that is targeted to a collection that is not currently assigned to an existing data server node message router instructs a node instantiation component to instantiate a new data server node for the targeted collection . Based on collection configuration data associated with the targeted collection node instantiation component will create a new data server node for the targeted collection and update the collection to node mapping data accordingly.

In an embodiment each message router comprises its own node instantiation component . In an embodiment there is a separate node instantiation component on each data server device that is capable of hosting data server nodes . In an embodiment the node instantiation component monitors system resources in data server system and or accesses data supplied by node monitor to determine where to instantiate a data server node . In other embodiments node instantiation component may determine where to instantiate a data server node in part based on which data server device s actually have access to and or are assigned to data storage devices that actually store the data collection s to which the data server node is assigned.

Data server system further comprises one or more node monitors . A node monitor monitors existing data server nodes to determine whether the data server nodes are active or inactive. Node monitor instructs or otherwise causes inactive data server nodes to terminate. Node monitor also updates the collection to node mapping to remove any mappings to terminated data server nodes . In an embodiment node monitor further instructs or causes collection saver to dump corresponding working copies of the nodes that are terminated if necessary.

Depending on the embodiment different criteria may be used to determine when a data server node has become inactive. In an embodiment for example a data server node becomes inactive when it has not received a request within a certain period of time. Node monitor may have access to request logs and or may communicate with message routers and or data server nodes to make this determination. The certain period may be of a global value or the certain period may be set per collection based on factors such as the importance of the collection size of the collection expected usage patterns and so forth.

In an embodiment the period of time is predefined in for instance the collection configuration data . In an embodiment the period of time may be adjusted dynamically through various learning processes. For instance if within a relatively quick period of time after a data server node for a certain collection has been terminated a new data server node must be instantiated to operate on the certain collection the learning process may adjust the predefined period to be longer. In an embodiment the period of time after which a data server node becomes inactive may be a function of how busy the data server system is. Hence under heavy server loads a data server node may become inactive more quickly than under lighter server loads.

In an embodiment inactive data server nodes are terminated immediately. In another embodiment node monitor maintains a prioritized queue of inactive data server nodes . When utilization of memory reaches a certain threshold e.g. a threshold amount or percentage and or when more room is needed in memory for storing working copies or other structures node monitor may select one or more of the inactive data server nodes to terminate from the queue. The queue may be prioritized based on a variety of factors such as for how long a data server node has been inactive usage trends for corresponding collections working copy sizes predefined weights indicating how important each collection is and so forth. In such embodiments if an inactive data server node receives a new request the data server node becomes active and is removed from the queue. In an embodiment once a node is added to the queue the node may be instructed to dump its working copy so that the node may be terminated more quickly if needed. In yet other embodiments node monitor maintains a prioritized list of active data server nodes based on the above factors. When memory is needed a certain number of lowest priority data server nodes are designated as inactive and thus terminated.

In an embodiment each data server node comprises its own node monitor . Hence each data server node is configured to register itself in the collection to node mapping and or to terminate itself after a certain period of inactivity. In other embodiments each message router may comprise a node monitor . In yet other embodiments there is a separate and distinct node monitor per data server device that monitors each data server node on the data server device . In yet other embodiments there is a single node monitor that monitors each node within data server system .

System illustrates only one of many possible arrangements of components configured to provide the functionality described herein. Other arrangements may include fewer additional or different components and the division of work between the components may vary depending on the arrangement. For example in other embodiments there may be no working copies and hence no collection loader or collection saver . In yet other embodiments certain techniques described herein may be practiced in a data server system that comprises no message router node instantiation component or node monitor . In fact at least some of the techniques described herein may be practiced in substantially conventional data server systems.

The techniques described in this section are performed by a system of one or more computing devices such as data server system depicted in or other data server systems. In an embodiment the techniques described in this section are performed by a system having features such as those described in U.S. patent application Ser. No. 14 046 767 titled Multi Lane Time Synced Visualization of Machine Data Events by Cary Noel and John Coates filed Oct. 4 2013 the entire contents of which are hereby incorporated by reference for all purposes as if set forth herein. In an embodiment each of the processes described in connection with the functional blocks described below may be implemented using one or more computer programs other software elements and or digital logic in any of a general purpose computer or a special purpose computer while performing data retrieval transformation and storage operations that involve interacting with and transforming the physical state of memory of the computer.

Block comprises monitoring data server nodes that perform data operations with respect to data collections in a data repository. The data operations may range from simple data insertion and retrieval operations to complex operations such as filtering joins aggregations statistical analyses and or formatting. The data server nodes include different nodes that are assigned to different collections of the data collections. The data collections may be any type of collection of data as described in other sections. Examples of suitable data server nodes are also described in other sections. However flow may also be performed with respect to any type of data server node and is not limited to any specific examples described herein. Block may be performed at any number of times relative to the remaining blocks of flow and in an embodiment is performed continually throughout the remainder of flow .

Block comprises receiving from a client a message that is to be processed by performing one or more data operations. The message may have been sent from any type of client such as from a web browser or other application over a network or from a locally running process. The message may be any type of request that includes instructions that require performance of one or more data operations. For example the message may be a data command that specifies a data operation such as a query statement or other suitable instruction. Or the message may simply imply a request to perform a data operation. For instance the message may be an event message that on account of how the data server system is configured implicitly requires the data server system to record details about the event in a data collection and or make other modifications to a data collection based on the event. As another example the message may be a request for a web page or document that includes dynamic content that must be retrieved through one or more data operations.

Block comprises identifying a data collection associated with the message. The data collection is associated with the message because the one or more data operations are to be performed with respect to the data collection. In an embodiment the data collection is determined based on a collection identifier found in or associated with the message. For instance the collection identifier may be appended as a parameter to the message such as a parameter in a query string of an HTTP request. Or as another example the collection identifier may be found in or derived from metadata associated with the message. For instance the collection identifier may be derived from HTTP header data such as a requestor address referrer address or user agent string or in an HTTP cookie. In an embodiment a session identifier or user identifier associated with the message may be used to look up the collection identifier in server side session data and or user account data. In other embodiments the data collection is discernable from a data command in the message. For instance the data command may request data from a unique table field or database that is only found in a certain data collection. In an embodiment a collection identifier is an application key that is assigned to a certain software application.

Block comprises determining whether the monitored data server nodes include a data server node that is assigned to the identified data collection. For instance as part of the monitoring in block a map of collection identifiers to data server node identifiers may be maintained. If the map associates a collection identifier for the identified data collection with an identifier for an existing data server node then it is determined that the existing data server node is currently assigned to the data collection.

If the determination of block is that there is a data server node that is currently assigned to the data collection then flow proceeds to block . Block comprises sending to the data server node assigned to the identified data collection a message that directly or indirectly requests that the data server node perform the one or more data operations. Depending on the embodiment the message may be the same as the message received in block or the message may be different. For instance the message sent in block may be a binary representation or other converted representation of the message from block . Or the message of block may be a streamlined version of the message of block removing extraneous metadata and or other information. Or if the message of block implied rather than specified a data operation the message of block may actually specify the data operation s to perform.

If on the other hand the determination of block is that none of the monitored data server nodes is assigned to the data collection then flow proceeds to block . Block comprises instantiating a new data server node. Instantiating a new data server node may comprise for instance loading instructions for listening for messages such as sent in block and performing data operations based thereon. Instantiating a new data server node may further comprise for instance loading configuration data associated with the data collection. Instantiating a new data server node may further comprise for instance launching one or more computer processes or threads that execute the loaded instructions based on the configuration data. Instantiating a new data server node may further comprise for instance allocating portions of volatile or otherwise high speed system memory to store data structures required by the loaded instructions.

Flow then proceeds to block which comprises assigning the new data server node to the identified data collection. For instance block may comprise updating a map of collection identifiers to data server nodes to include a mapping between the new data server node and the identified collection. In an embodiment block may further comprise the new data server node loading some or all of the data collection from a slower storage device into the allocated portions of the higher speed memory. From block flow then proceeds to block since there is now a data server node that is assigned to the data collection.

From block flow proceeds to block . Block comprises processing the message thus resulting in the performance of the one or more data operations at the assigned data server node. For instance if the message contains database commands or otherwise references the data operations to perform the data operations are performed as instructed. Or if the message comprises data structures such as events or logs the appropriate data operations for processing those events or logs are executed. The data operations may be performed in any suitable manner. In an embodiment block may comprise loading instructions for performing certain types of data operations from various script files or in memory copies thereof. In other embodiments instructions for performing certain types of data operations are hard coded into the instructions based upon which the data server node was instantiated. If the data collection has been loaded into system memory the data operations are performed directly on the in memory data structures. Otherwise block may involve retrieving some or all of the data collection from storage.

Block optionally comprises responsive to performing the one or more data operations sending the client a response message with results from the one or more data operations. The data server node may send the response message directly or via a message distribution component from which it received the message of block .

In an embodiment flow is repeated any number of times. If a second message is received in association with a data collection for which a server node was instantiated in block of a previous iteration of flow the second message will also be processed by that server node assuming the server node still exists. Thus block often need not be performed for the subsequent iterations of flow that involve a same data collection. Multiple iterations of flow may furthermore be performed concurrently with respect to different data server nodes assigned to different data collections such that certain messages are distributed to already existing data server nodes at the same time as new data server nodes are being created for other messages.

Block comprises receiving messages that are to be processed by performing data operations as would occur in among other contexts multiple iterations of block . Block comprises dynamically instantiating different data server nodes for different data collections in a data repository in response to at least some of those messages as would occur in among other contexts multiple iterations of blocks above.

Block which is optional comprises copying data collections assigned to the data server nodes from a lower speed storage on which they are persistently stored to a higher speed memory thus forming a working copy of the data collections in the higher speed memory as described in other sections. Block comprises sending messages to the data server nodes to cause the data server nodes to perform the data operations indicated by the messages of block as would occur in among other contexts multiple iterations of block above.

While for simplification blocks are described with respect to elements of flow above it should be noted that performance of blocks is not limited to the embodiments described with respect to flow but rather may be performed in any suitable manner.

Block which is optional comprises periodically or in response to certain triggers saving i.e. dumping the working copies of the data collections from the higher speed memory back to the lower speed storage. Thus changes to the working copies are synchronized back to the data repository. Block is of course not performed if no working copy is maintained for a data collection. Block is optional if a working copy will be saved in block below. Block may be performed multiple times for each data collection for instance at intervals of five minutes or an hour. The exact interval may be different for each collection based on collection specific configuration data. The interval may be a function of a variety of factors as described in other sections. Additionally or instead block may be performed responsive to certain types of triggers such as the occurrence of certain types and or quantities of changes as described in other sections.

In an embodiment the entire working copy is dumped. In other embodiments only a most recent segment of the working copy is dumped. For instance the data collection may be a collection of time based events segmented by the time periods in which the events are received. Under many usage patterns only the most recent data collection segment s include any changes and thus only the most recent segment s need to be synchronized back to the repository.

Block comprises determining that a particular data server node of the dynamically instantiated data server nodes has not processed any of the messages within a certain period of time. For instance a component responsible for distributing messages to the node such as message router may log the times at which it last sent one of the messages of block to each of the data server nodes. Based thereon the message distribution component may periodically or in response to certain triggers identify all nodes that have not processed one of the messages of block within the certain period of time.

As another example one or more system monitoring components separate from any message distribution component may monitor activity at the data server nodes. Based on logs kept by message distribution component s and or the data server nodes or based on messages exchanged with the distribution component s and or the data server nodes the one or more system monitoring components may identify when each node last processed one of the messages of block and thus determine whether the nodes have processed any of the messages within a certain period of time. In yet another embodiment data server nodes may run their own processes or threads that perform block in similar manner.

In an embodiment the certain period of time may be predefined for all nodes specified in node specific configuration data. In an embodiment the certain period of time is a function one or more parameters such as server load a target amount of memory to reallocate a time of day statistics derived from previous node specific and or global message histories node specific weights and so forth. In an embodiment the certain period of time is a threshold determined based on how long it has been since each of the other data server nodes processed one of the messages of block . For instance the certain period of time may be chosen such that only a specific number of nodes are determined to not have processed one of the messages of within the certain period of time.

In an embodiment instead of actually determining whether a node has processed a message within a certain period of time a priority score is assigned to each data server node based on the amount of time since the node processed one of the messages of block a node specific inactivity timeout and or other parameters such as described above. Instead of determining that the particular data server node has not processed a message within a certain period of time block may comprise determining that the particular data server node has a priority score above or below a threshold or that the particular data server node has a priority score that is higher or lower than other data server nodes.

In an embodiment block may further comprise determining that the particular data server node is inactive and or not still performing a data operation per criteria such as explained in this and other sections. In an embodiment instead of determining whether a node has processed any messages within a certain period of time block may instead comprise determining whether the node has begun and or completed any data operations within the certain period of time as may be revealed by for instance operation logs maintained by each data server node.

Block comprises responsive to the determination s of block beginning termination of the particular data server node. For instance if block is performed by a message distribution component or system monitoring component the message distribution component or system monitoring component may send a termination message to the particular data server node. Or the message distribution component or system monitoring component may instruct an operating system process management component or similar component to terminate the processes and or threads executed by the particular data server node.

Block which is optional depending on the embodiment comprises dumping a working copy of the data collection s associated with the data server node from high speed memory to lower speed storage media at which the data collections are persistently stored. Of course block need not be performed in embodiments where working copies are not maintained. In an embodiment block may not be performed even when working copies are maintained. For instance in systems where some data loss is acceptable the system implementer may decide that under some or all circumstances it is more important to immediately free up the high speed memory than to preserve any changes that have occurred since the data collection was last saved to the lower speed storage media.

In an embodiment block is performed by the data server node directly. In other embodiments block is performed by an external collection saving component upon request by the data server node or another component that has instructed the data server node to terminate. In yet other embodiments block is performed responsive to an external collection saving component determining via triggers and or monitoring processes that termination of the particular data server node has begun and or has already occurred.

In some embodiments block is not necessary if it can be determined that the working copy has not been changed since the working copy was loaded and or last copied back to the storage media. For instance there may be a dirty indicator for each data collection working copy. If the dirty indicator is set block is performed. A dirty indicator is initially unset when the corresponding data collection is loaded and whenever the corresponding data collection is saved. Whenever a data server node performs an operation that changes a working copy the corresponding dirty indicator is set. Alternatively rather than maintaining an actual indicator an indication of whether a working copy is dirty may be derived by comparing a timestamp that reflects when the working copy was last modified to a timestamp that reflects when the data collection was last modified and or when the working copy was last loaded. The same principle applies to the optional periodic dumping process described in block .

Block comprises deallocating any memory used by the particular data server node including any memory used to store working copies. Block should be performed after block has concluded at least with respect to the portions of the memory that are used to store the working copy. In an embodiment block may be performed at least partially by the data server node. In an embodiment block may be performed at least partially by an operating system or runtime memory management component. In some embodiments depending on how the working copies assigned to the particular data server node are managed deallocation of the memory portions that store the working copy may instead be performed by an external collection saving component.

Block comprises terminating the particular data server node. In some embodiments block may be completed before block has concluded if an external component is capable of managing and saving the working copy. The particular data server node may shut down its processes and or threads gracefully or the processes and or threads may be forcefully terminated by the operating system or system runtime.

Flow may be repeated any number of times. For instance after the particular data server node has terminated a new message indicating a data operation to perform with respect to a particular data collection that had been assigned to the particular data server node may be received. A new data server node may then be instantiated for the particular data collection. That new data server node might also at some point be terminated in accordance with flow . Multiple iterations of flow may furthermore be performed concurrently such that for example multiple data server nodes are being terminated at the same time that messages are being distributed to other data server nodes.

Block comprises receiving a construct that indicates that the data server system is to establish a time context. The construct may be received via any suitable interface such as a command line interface or an API. In an embodiment the construct is a statement within a script or other set of computer readable instructions. The construct includes or is otherwise associated with a parameter that defines an arbitrary period of time for which the time context should be established. For instance the construct may define a range of timestamps. Specific examples of such constructs are given without limitation in other sections.

In an embodiment the data server system is configured to recognize pre defined values within the parameter for defining the time period such as day week or month. The data server system automatically determines a time or range of times for the time context based on an algorithm associated with the pre defined value. For instance by specifying a time context of a day a user may in essence specify to the data server system that the time period is a range of timestamps beginning at the start of the current day. In an embodiment certain pre defined values such as day are relative to the current system time so that processing the same construct results in establishing a different time context depending on when the construct is processed.

In an embodiment a second parameter may specify that the time period for the time context is actually a certain number of time periods prior to the time period defined by the first parameter. For instance the first parameter value may be month and the second parameter value may be 3. Accordingly the data server system will establish a time context of three months ago.

Block comprises receiving a first instruction within the time context that specifies a first operation to perform with respect to a first set of data. The first instruction may specify for instance to retrieve data perform a calculation or generate a view. The set of data may be for instance a set of events a group of data rows a data collection as set forth herein or any other suitable set of data. The first instruction need not specify the time context again nor need the first instruction specify any time based filter. Rather the first instruction is received in such a manner that the data server system recognizes that it belongs to the established time context.

For instance the construct of block may be specified in a certain script or other set of instructions. The first instruction may also be specified in the instruction set at some point following the construct of block without any intervening constructs that specify a new time context or that terminate the established time context. As another example the first instruction may appear in an indented block of instructions following the construct. As another example the first instruction may be received in a same communication session or command line session as the construct of block again without any intervening constructs that specify a new time context or that terminate the established time context.

Block comprises responsive to the first instruction performing the first operation with respect to only those items e.g. rows events objects etc. in the first set of data that are associated with timestamps that occur within the time period defined for the time context. In an embodiment a data item is determined to be associated with a time that occurs within the defined time period if the value of a designated column field or other parameter is a timestamp within the defined time period. However other types of associations are possible.

In an embodiment block comprises retrieving only the relevant data items. In another embodiment if the first set of data has already been retrieved block comprises filtering the first set of data to include only the relevant data items. For certain types of data sets that are already sorted the filtering may be a relatively straightforward segmentation operation. In an embodiment the first set of data is already partitioned into time based segments thus allowing the data server system to easily retrieve or filter some or all of the first set of data on a segment by segment basis.

In an embodiment the relevant data may already have been filtered or retrieved at a time prior to block . For example in an embodiment each data server node processes only one data collection. Thus the first data set is known to be the data collection assigned to the data server node and may be filtered to the time context as soon as the construct of block is recognized. As another example another construct may define a data context which specifies that all following instructions are to be performed with respect to the first data set. The data context construct may have been received prior to block or even prior to block . Responsive to having received both the data context construct and the time context construct the data server system may automatically retrieve and or generate a filtered data set.

Block comprises optionally creating or updating a time context variable to store a calculation that results from block as necessary. For instance block may comprise creating a counter variable. The counter variable is automatically created within the time context. The counter variable may be stored permanently within a corresponding collection. If the time context is ever entered again e.g. when processing a message in the future the variable may be accessed simply by referring to the variable by name. However in other time contexts the variable name refers to an entirely different variable. In an embodiment the variable may be accessed outside of the time context by referencing a combination of the variable name and a time context identifier.

In an embodiment blocks may be repeated any number of times before block and then again any number of times after block but before block . Thus for instance the data server system may process multiple instructions to perform multiple operations within the time context without the user having to repeatedly specify the time context.

Blocks are optional. Block comprises receiving an embedded time construct that defines an embedded time context. The embedded time construct is similar to that described with respect to block except that it does not terminate the time context established as a result of block the original time context but rather simply suspends the time context while an embedded time context is established. The embedded time context is associated with a different time period than is the original time context.

Block comprises receiving a second instruction within the embedded time context that specifies a second operation to perform with respect to the first set of data in similar manner to block . Block comprises responsive to the second instruction performing the second operation with respect to only those items in the first set of data that are associated with timestamps that occur within the time period defined for the embedded time context in similar manner to block . Hence the second operation is performed on a different set of filtered data from the first set of data than the first operation.

Block comprises receiving a construct that terminates the embedded time context. Thus the data server system terminates the embedded time context and resumes the original time context. The construct may be any suitable construct designated for terminating a time context.

Block comprises receiving a construct that terminates the original time context. Thus the data server system terminates the original time context. Again the construct may be any suitable construct designated for terminating a time context. Or in an embodiment the terminating construct may be another time context construct thus returning flow back to block .

In an embodiment data collection is a collection of time based events. In an embodiment collection is furthermore constrained in size. For instance collection may only store events for a most recent period of time only a certain number of events and or only a certain size of data. To this end node or an external process may monitor collection and delete old events as needed. In yet other embodiments collection may take any form and is not necessarily constrained in size.

In an embodiment data collection is stored as a series of segments . Segments may be for example files partitions directories or any other suitable structure for containing data lines events rows or other items. In an embodiment each segment corresponds to a distinct period of time. For instance in an embodiment each segment corresponds to a different hour of time and contains items that were added to the collection during the corresponding hour of time. Each segment is stored as a separate file within a directory named after the collection and each file is named after the hour for which it was created. In other embodiments other segmentation schemes may be utilized. In yet other embodiments there are no segments .

Data server node comprises processing components such as components and . These processing components may be for instance threads and or processes executing using certain processing resources of system processing resources . In an embodiment the processing components of node run within an isolated environment such as an Erlang C Node. In other embodiments the threads and or processes used by node may be any arbitrary group of threads and or processes. In an embodiment the processing resources utilized by each node include for each node a different set of one or more processors or processor cores in system processing resources . However such a configuration is not essential.

Data server node further comprises in memory components such as components and implemented upon an allocated portion of memory resources . For instance memory resources may be random access memories or any other memory components such as described with respect to memory of . A portion of memory is allocated to node when node is instantiated and or at the request of processing components in node . Each of the in memory components is a data structure within the allocated portion of memory to or from which the processing components of node may write or read data as needed for performing the functions described herein. Depending on the embodiment the allocated portion may change in size over time according to the needs of the node .

Data server node operates in accordance with configuration settings . Configuration settings may be loaded from a configuration file associated with collection . In an embodiment the configuration settings are part of configuration data from . In an embodiment the configuration settings include some or all of the name of the collection assigned to the node the maximum number of counters that may be hosted by the collection the maximum number of data segments that the collection may store the maximum number of unique items each of those segments can store a time period after which the node becomes inactive a time period after which the node should dump its working copy and so forth.

Data loading component is configured to load data collection into the allocated portion of memory thereby storing working copy of collection . Depending on the embodiment data loader may load only the most recent segment s or all segments . In an embodiment data loader is called upon instantiating the node .

Communication component monitors one or more communication channels such as ports for messages such as messages . For instance communication component may be an Erlang port driver or other suitable mechanism for receiving and responding to communications over a communications interface. Messages may be received in any suitable format. In an embodiment for instance a message distribution component such as message router receives a request to perform data operations as a parameterized URL within an HTTP requests. The message distribution component translates the requests into binary encoded messages and sends binary encoded messages to the communication component of the node assigned to handle the request. Of course many other forms of messages are possible.

Communication component may receive among other messages input messages . Input messages specify data item s such as events or rows that are to be inserted into the collection . In response communication component adds the input messages to a message queue and sends an acknowledgement message to the message distribution component and or original requester. Communication component may further receive among other messages view requests . View requests specify data to be returned from the data collection . In response communication component adds the view requests to the message queue . After data operation processor has generated a specified view communication component sends a view message containing the view to the message distribution component and or original requester.

Depending on the embodiment message queue may be a simple first in first out queue or message queue may be organized according to a prioritization mechanism that gives priority to certain messages or based at least on one or more factors other than when the messages or were received. For instance messages may be prioritized ahead of messages or messages from certain clients may be prioritized higher than all other messages. In any event data operation processor monitors message queue . Whenever there are messages in message queue and whenever sufficient processing resources and or memory resources are available data operation processor pops the highest priority message or from the queue and performs the data operation s indicated by the message or .

For messages data operation processing component utilizes input processing instructions to create a new data item. Depending on the data in a message the input processing instructions for creating a new data item may be relatively straightforward in that the data in the message is simply copied to new data item. Or the input processing instructions may need to instruct data operation processor in applying semantics to the data in the message performing calculations based thereon and or determining how to create or update counters or other elements within the collection . Data operation processor then saves the new data item to the working copy of collection or more particularly to the currently active segment in the working copy . Asynchronously a data saver component dumps the working copy or at least the currently active segment back to the collection in storage as described in other sections.

For messages data operation processor utilizes view processing instructions to determine what data is required for the specified view. View processing instructions may depending on the view instruct data operation processor to do any or all of assign semantics to the data identify which data from working copy to process based on the semantics filter the data by based on filtering criteria specified in the request perform aggregations or calculations based on the data arrange the data into tables or other structures defined for the requested view generate visualizations based on the data or perform any other data processing tasks. Data operation processor then generates and returns the requested view.

In an embodiment input processing instructions and view processing instructions are hard coded into the execution logic for running the data operation processing component . In other embodiments input processing instructions and view processing instructions are encapsulated in flexible script files such as in the example scripting language described in other sections. For instance a script interpreter within the data operations processor may process input messages with a process.lql script that is loaded from a script file. The process.lql script gives semantics to the data found in the message creates and or updates counters based on the message creates the data item to insert and saves the new data item to the working copy . As another example there may be separate view script files for different named views. When a particular view is requested the script interpreter loads the view script file having the requested view name and creates the view based on the instructions within the view script file. In an embodiment view script files are easily added to a data server system allowing analysts to create and define new views as needed. In an embodiment different script files may be stored for different collections and or there may be a default set of script files.

In an embodiment communication component further receives termination requests from for instance a message distribution component or an external node monitoring component. In response node gracefully and atomically stops. Before stopping however data saver component saves working copy back to collection . The processes and threads that utilize processing resources cease to exist and the allocated memory is freed for use by other applications.

According to an embodiment as previously stated the instructions used by a data server system for performing data operations may be provided in script based files that conform to scripting languages. A data server system may access different files to perform different operations. For example as stated a process.lql file may contain instructions for processing incoming events log messages or other request messages. That is every time a message is received the process.lql file with the message loaded into a designated input parameter for the script. Similarly each view provided by the data server system may be defined by a script based file. For example the name of the requested view may correspond to the name of a .lql file. In an embodiment the files are interpreted at execution time rather than compiled and thus may be changed dynamically without having to restart the data server system.

Although the exact format of the scripting language may vary from embodiment to embodiment in one embodiment an example scripting language supports instructions such as set forth in following examples. As depicted the scripting language is a Scheme based Lisp 1 language without macros.

Table 1 depicts an instruction for creating and or updating a counter named datalines to store a count of all items within a collection.

Table 2 depicts a set of instructions that parses each item in a data collection extracts different pieces of information assigns those pieces of information to different fields and then stores a user ids variable reflecting the number of unique users

Table 3 depicts a set of instructions that establish a time context and create a counter within the time context. As depicted the name of the construct that establishes the time context is timespace. The counter will store a count of all items within the collection that are received in the current day.

Table 4 depicts a set of instructions that creates and stores two counters one daily counter and one monthly counter.

While the instructions appear to only specify one datalines counter the two timespace constructs actually establish two different time contexts and a separate datalines counter is maintained for each time context. Internally for example each counter may have a prefix of datalines followed by a name derived from the context such as datalines January2013. When the script is first processed in a new time period i.e. when a new day and or new month begins based on the time contexts in which the instructions of Table 4 are processed a new counter will automatically be created for the new time period. Thus processing incoming messages with the above script over time will result in separate counter variables for each day and each month in which a message is received.

Table 5 depicts a set of instructions that accesses a counter in a non current time period. The timewarp construct permits access to a previous time period and includes a parameter to specify an offset from the current time period in which to establish the time context. In the depicted example the time context is one day ago.

Table 6 depicts a set of instructions that establishes an embedded time context within another time context. The initial timespace construct establishes a time context within the current day. The timebubble construct instructs the data server system to temporarily suspend the original timespace construct in favor of the non current time context specified by the immediately following timewarp construct.

Table 7 depicts a set of instructions that parses incoming messages into various fields of data and then for messages that are tagged as erroneous creates or updates daily counters for tabulating how many unique errors occurred and how many users were affected from these errors.

The foregoing scripts are given by way of example of the types of operations that may be supported by the example scripting language and or by performing data operations based on script based files in general. There are of course many other types of operations that may be performed and many different languages and arrangements of instructions suitable for instructing a data server system to perform those operations. Moreover in embodiments a data server system need not necessarily support the types of constructs and data operations found in the foregoing scripts.

Note that although separate embodiments are discussed herein any combination of embodiments and or partial embodiments discussed herein may be combined to form further embodiments.

According to an embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk optical disk or solid state drive is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operate in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical disks magnetic disks or solid state drives such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In an embodiment a system comprises one or more computer readable storage devices storing a data repository the data repository comprising different data collections one or more computing devices comprising at least one or more memories and one or more processors data server nodes implemented at least partially by the one or more processors configured to perform data operations on the data collections each particular data server node assigned to one or more of the data collections and configured to process messages by performing particular data operations on the one or more data collections to which the particular data server node is assigned a message distribution component implemented at least partially by the one or more processors configured to receive particular messages that are associated with particular data collections of the data collections and distribute the particular messages to particular data server nodes that are assigned to the associated particular data collections a node instantiation component implemented at least partially by the one or more processors configured to when certain messages of the particular messages are associated with certain data collections to which none of the existing data server nodes are assigned dynamically instantiate new data server nodes and assign those new data server nodes to corresponding ones of the certain data collections.

In an embodiment the system further comprises a collection loading component configured to generate in memory working copies of the data collections by copying data collections from the data repository to the one or more memories wherein the data server nodes are configured to perform the data operations with respect to the in memory working copies a collection saving component configured to periodically and or in response to certain triggers save changes to the in memory working copies to the data repository.

In an embodiment the system further comprises a node monitoring component configured to cause certain less active data server nodes to terminate. In an embodiment the system further comprises a node monitoring component configured to cause certain data server nodes to terminate wherein the node monitoring component is configured to determine whether different data server nodes should be terminated based on different node specific criteria associated with those different data server nodes.

In an embodiment the system further comprises a collection loading component configured to generate in memory working copies of the data collections by copying data collections from the data repository to the one or more memories wherein the data server nodes are configured to perform the data operations with respect to the in memory working copies a node monitoring component configured to cause certain less active data server nodes to terminate a collection saving component configured to save changes to the in memory working copies to the data repository prior to termination of less active data server nodes.

In an embodiment the data collections store time based events wherein at least some of the particular messages are requests to record new time based events and the data server nodes comprise data operation processing components configured to execute instructions for adding the new time based events to the data collections. In an embodiment the data collections store time based events wherein at least some of the particular messages are requests to generate data views derived from the time based events and the data server nodes comprise data operation processing components configured to in response to the requests execute instructions for generating pre defined data views based on the time based events.

In an embodiment each data server node is a different set of one or more computer processes that executes within a different allocated memory space in the one or more memories each different allocated memory space storing at least one different data collection to which the corresponding data server node has been assigned.

In an embodiment a method comprises monitoring data server nodes that perform data operations with respect to data collections the data server nodes including different nodes that are assigned to different collections of the data collections receiving a first request that indicates a first data operation to perform the first request being associated with a first data collection identifier for a first data collection of the data collections with respect to which to perform the first data operation responsive to the first request determining whether the monitored data server nodes currently include any data server node assigned to the first data collection responsive to determining that none of the monitored data server nodes is currently assigned to the first data collection instantiating a first data server node sending a second request to the first data server node that indicates the first data operation to perform.

In an embodiment the data collections are sets of time series based events and the first request is a message comprising information about a new event. In an embodiment the second request is the first request. In an embodiment instantiating the first data server node comprises allocating at least a portion of memory to the first data server node loading a working copy of the first data collection from one or more storage devices into the portion of the memory wherein the memory supports higher speed access than the one or more storage devices instantiating one or more data server processes including at least a first process that listens for communications including the request.

In an embodiment the method further comprises determining a period of time since the first data server node last processed a request that indicated a data operation to perform based at least partially on the period of time exceeding a threshold period of time terminating the first data server node. In an embodiment the method further comprises loading a working copy of the first data collection from one or more storage devices into a memory that supports higher speed access than the one or more storage devices at the first data server node performing data operations including the first data operation with respect to the working copy resulting in changes to the working copy periodically and or in response to one or more triggers copying at least the changes in the working copy of the first data collection from the memory to the one or more storage devices subsequent to performing the data operations terminating the first data server node.

In an embodiment the method further comprises loading a working copy of the first data collection from one or more storage devices into a memory that supports higher speed access than the one or more storage devices at the first data server node performing the first data operation with respect to the working copy resulting in a change to the working copy subsequent to performing the first data operation determining that the data server node is inactive based at least partially upon determining that the first data server node is inactive copying at least the change to the working copy of the first data collection from the memory to the one or more storage devices and terminating the first data server node.

In an embodiment the method further comprises determining a period of time since the first data server node last processed a request that indicated a data operation to perform based at least partially on the period of time exceeding a threshold period of time terminating the first data server node wherein terminating the first data server node comprises writing the first data collection from the portion of the volatile memory to the non volatile memory deallocating the portion of the volatile memory terminating one or more data server processes.

In an embodiment the method further comprises receiving a third request that indicates a second data operation to perform the third request being associated with the first data collection identifier responsive to the third request determining whether the monitored data server nodes include any data server node assigned to the first data collection responsive to determining that the first data server node is currently assigned to the first data collection sending a fourth request to the first data server node to perform the second data operation.

In an embodiment the method further comprises at the first data server node processing a plurality of requests including the second request subsequent to processing the plurality of requests terminating the first data server node subsequent to terminating the first data server node receiving a third request that indicates a second data operation to perform the third request being associated with the first data collection identifier responsive to the third request determining whether the monitored data server nodes currently include any data server node assigned to the first data collection responsive to determining that none of the monitored data server nodes is currently assigned to the first data collection instantiating a second data server node sending a fourth request to the second data server node to perform the second data operation.

In an embodiment the method further comprises receiving a third request that indicates a second data operation to perform the third request being associated with the second data collection identifier for a second data collection of the data collections with respect to which to perform the second data operation responsive to the third request determining whether the monitored data server nodes currently include any data server node assigned to the second data collection responsive to determining that a second data server node is currently assigned to the first data collection sending a fourth request to the second data server node to perform the second data operation.

In the foregoing specification embodiments have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the embodiments and what is intended by the applicants to be the scope of the embodiments is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

In drawings various system components are depicted as being communicatively coupled to various other components by arrows. These arrows illustrate only certain examples of information flows between the components of the depicted systems. Neither the direction of the arrows nor the lack of arrow lines between certain components should be interpreted as indicating the absence of communication between the certain components. Indeed each component of the depicted systems may feature an open port API or other suitable communication interface by which the component may become communicatively coupled to other components of the depicted systems as needed to accomplish any of the functions of the systems described herein.

