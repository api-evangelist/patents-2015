---

title: Method of hosting a first application in a second application
abstract: A method of hosting a first application (e.g., a virtual application) inside a second application (e.g., a control displayed by a web browser). The method includes executing the first application inside a runtime environment generated at least in part by a runtime engine. The executing first application calls user interface functions that when executed inside the runtime environment generate a first user interface. The runtime engine captures these calls, generates messages comprising information associated with the captured calls, and forwards the messages to a user interface manager that is a separate application from the runtime engine. The user interface manager receives the messages, translates the information associated with the captured calls into instructions for the second application, and sends the instructions to the second application. The control receives the instructions sent by the user interface manager, and displays a second user interface for the first application based on the instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626237&OS=09626237&RS=09626237
owner: CODE SYSTEMS CORPORATION
number: 09626237
owner_city: Seattle
owner_country: US
publication_date: 20151204
---
This application is a continuation of U.S. application Ser. No. 14 297 506 filed on Jun. 5 2014 now U.S. Pat. No. 9 208 004 which is a continuation of U.S. application Ser. No. 13 088 265 filed Apr. 15 2011 now U.S. Pat. No. 8 763 009 which claims the benefit of U.S. Provisional Application No. 61 325 315 filed Apr. 17 2010 and U.S. Provisional Application No. 61 325 798 filed Apr. 19 2010 which are incorporated herein by reference in their entireties.

The present invention is directed generally to a method of displaying a user interface of a first application within a user interface of a second application.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information. When the virtual application is executed the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

Presently separate applications must be developed for local execution e.g. within Microsoft Windows and execution over the Internet e.g. inside a web browser such as Internet Explorer . In particular different interfaces must be created for the separate applications. Therefore a need exists for a method of hosting a first application e.g. an application designed to execute within a local operating system such as Microsoft Windows within a second application e.g. a web browser such that an interface developed for one environment e.g. Microsoft Windows may be implemented or hosted in a second different environment e.g. a web browser . The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

As is apparent to those of ordinary skill in the art most natively installed Microsoft Windows applications display a user interface by calling functions exposed in the Microsoft Windows Software Development Kit hereafter SDK exposed functions . Generally using these functions each windows application creates its own unique windows in a customized order. Further these windows may have predetermined behaviors.

To instead display an interface inside another application e.g. a Web Browser calls to the SDK exposed functions must be captured translated into commands the other application will understand and sent to that application.

The present disclosure describes a system and method for displaying the user interface windows of a first application e.g. a virtual application in a second application e.g. a Web Browser .

In the embodiment illustrated the Client Application communicates with the Sandbox Manager over a communication link that may be implemented as a Transmission Control Protocol TCP connection using TCP protocol. A cache may be stored on the filesystem A for use by the Sandbox Manager .

As explained above a virtualized application file is transferred to the client computing device from the server computing device . Likewise the UI configuration file may be transferred to the client computing device from the server computing device . The virtualized application file is illustrated in dashed lines to indicate that the virtualized application file is stored in the cache during and after the download. However before the download begins the virtualized application file is not stored in the cache . The UI configuration file may be stored in the cache in a manner similar to that described with respect to the virtualized application file . As will be explained below the virtualized application file may be an executable file or a file configured to execute within a virtualized environment provided by a virtual machine.

The system memory A stores one or more files implementing one or more virtual machines. By way of a non limiting example the system memory A may include a plurality of virtual machine executable files that when executed each implement a different virtual machine. For example each of the virtual machine executable files may implement a different version of the same virtual machine. The virtual machine executable files may be executed individually. When executed a virtual machine executable file implements a virtualized environment. Execution of a virtual machine executable file may be initiated by the Sandbox Manager using a command including a parameter e.g. a file path identifying a virtualized application file to execute. In response to receiving the parameter the virtual machine executable file executes the identified virtualized application file inside the virtualized environment implemented by the virtual machine executable file. The virtual machine may execute within an operating system shell process. Optionally the virtual machine executable files may be stored in the cache .

The virtualized application file includes a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file .

In the embodiment illustrated the system memory B stores web server components configured to implement a web server. The web server components may be configured to provide a web page having one or more links to virtualized application files using standard http protocol. By way of non limiting examples the web server components may include Internet Information Services IIS provided by Microsoft Corporation Apache and the like. While illustrated as being outside the filesystem B those of ordinary skill in the art appreciate that the virtualized application file and web server components may be conceptualized as being within the filesystem B.

The virtualized application file may include components necessary to implement a virtual runtime environment including a virtual operating system configured to execute in the operating system A see of the client computing device illustrated in . Alternatively the virtual runtime environment may be implemented by one of the virtual machine executable files see . The virtualized application file includes components necessary to implement a virtual application configured to execute in the virtual runtime environment. In particular embodiments a single virtualized application file is used to implement both the virtual operating system and the virtual application . However those of ordinary skill in the art appreciate that more than one virtualized application file may be used to implement the virtual operating system and the virtual application . For example the components implementing the virtual runtime environment may be stored in one of the virtual machine executable files see and the components implementing the virtual application may be stored in the virtualized application file . Further one or more of the files used to implement the virtual application may be other than an executable file having the exe file extension.

The virtual operating system includes a virtual filesystem a virtual registry and a virtual process environment and threading subsystems component . When executing the virtual application interacts with the virtual filesystem virtual registry and virtual process environment and threading subsystems component instead of interacting directly with the filesystem A the registry A and the process environment and threading subsystems component A of the operating system A illustrated in . The virtual operating system is configured to communicate with the operating system A illustrated in as required to execute the virtual application .

The virtual application executes inside a virtual runtime environment provided at least in part by the virtual operating system . Some virtual applications require one or more additional runtime environments to execute. For example to execute a Flash application the Flash runtime engine must also be installed. Therefore to virtualize a Flash application both the Flash application and Flash runtime engine must be included in the virtualized application file and configured to execute in the portions of the virtual runtime environment provided by the virtual operating system . Collectively all runtime components necessary to execute the virtual application will be referred to as a virtual runtime engine. When executed the virtual runtime engine generates at least in part the virtual runtime environment in which the virtual application executes.

The virtualized application file includes a configuration data block . The configuration data block may include virtual application files A C corresponding to each of the application files of a natively installed version of the same application. The virtualized application file identifies one or more of the virtual application files A C as a startup executable that executes when the virtual application is first executed. The startup executable may be identified in the configuration data block .

When the virtualized application file is executed the configuration data block configures the virtual operating system to execute the virtual application . For example the configuration data block may contain configuration information related to files and directories in the virtual filesystem keys and values in the virtual registry environment variables services and the like.

The configuration data block may also include basic application metadata and settings such as the application name application version and sandbox location. Further the configuration data block may provide isolation information to the virtual operating system . This information indicates which directories virtual application files A C virtual registry entries environment variables and services are to be isolated from the operating system A see of the client computing device see . While illustrated as being outside the virtual filesystem those of ordinary skill in the art appreciate that the application files A C may be conceptualized as being within the virtual filesystem when the virtual application is executing.

To execute the virtual application an initialization process is first performed. During this process the virtual operation system is launched and configured by the configuration data block . After the initialization process has completed the appropriate startup executable s is are launched inside the virtual operating system . The virtual operating system intercepts calls to the operating system A and routes them to corresponding components of the virtual operating system . For example when the virtual application requests access an application file that corresponds to the virtual application file A using a path of a natively installed version of the application the virtual operating system intercepts the request and routes the request to one of the virtual application file A. The virtual operating system may also route some requests and actions to the operating system A see of the client computing device see for processing.

U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 the virtualized application file may be created by a virtual application executable constructor or authoring tool using an application template that includes copies of files such as a configuration file application files A C and the like used to configure the virtualized application file . However the template is not a requirement. Instead to build the virtualized application file the authoring tool needs only the configuration file and copies of any applications files A C necessary for a natively installed version of the application to execute. The applications files A C and the configuration file are referred to collectively as an application configuration . In some embodiments the authoring tool combines the application configuration and the components of the virtual runtime engine e.g. the virtual operating system into an executable virtualized application file. However in other embodiments the authoring tool omits the components of the virtual runtime engine from the virtualized application file to create a virtualized application file for execution by a virtual machine implemented by a virtual machine executable file such as one of the virtual machine executable files .

For ease of illustration the authoring tool and the application configuration have been illustrated as being stored in the system memory B of the server computing device see . However this is not a requirement. As is apparent to those of ordinary skill in the art the virtualized application file may be created on a computing device other than the server computing device such as the computing device illustrated in and transferred to the server computing device illustrated in for storage thereon.

The authoring tool may also be used to create a user interface UI configuration file . The UI configuration file may be a separate file or included in the application configuration . The UI configuration file may be downloaded along with the virtualized application file or incorporate therein.

Returning to as mentioned above the system memory A of the client computing device see stores the Client Application and the Sandbox Manager .

The Client Application translates user commands button clicks etc into requests for operations that the Sandbox Manager performs. In embodiments in which the Client Application is implemented as a web browser the browser plug in or other type of translation application may be installed on the client computing device see . Together the browser and browser plug in perform the functions of the Client Application .

By way of a non limiting example the browser plug in may be installed on the client computing device see by placing a dynamic link library dll implementing the plug in in a predetermined installation directory and registering the dll i.e. an assembly in the registry A e.g. a Windows registry of the client computing device see . An Assembly Registration tool e.g. Regasm.exe may be used to register the dll in the registry A.

Once the plug in has been installed the plug in can be used by a website implemented by the web server components see of the server computing device illustrated in via client scripting technologies such as client side javascript code executing in the Client Application . To access the plug in from the server computing device illustrated in a plug in object reference is created and sent to the Client Application .

In response to receiving the reference to the plug in the Client Application loads the plug in by mime type ProgID class GUID and the like depending on the implementation details of the Client Application which in this embodiment is implemented as a web browser . The plug in exposes methods which can be used to send requests to the Sandbox Manager .

The Client Application has a user interface module see that generates a user interface see . In the embodiment illustrated the user interface displays a web page. The user interface may include one or more conventional windows. A control may be displayed in the Client Application . For example in embodiments in which the Client Application is a web browser a window of the web browser may display a web page displaying the control displayed as a rectangular region. The control may be implemented by the plug in see .

The requests include commands and optionally one or more parameters. The requests may be implemented as strings each including a command. If the request also includes parameters the parameters may be separated from one another and the command by a predetermined character such as a semi colon comma and the like. In other words the request may be implemented as a semi colon delimitated string or a string delimited in another manner. The following Table A provides a list of commands that my be included in a request.

As mentioned above the Client Application communicates with the Sandbox Manager over the communication link which may be implemented as a TCP connection. By way of a non limiting example the Client Application may send the requests as text messages using TCP protocol to the Sandbox Manager over the TCP connection. As described above each of the requests includes a command and may include one or more parameters e.g. a parameter list . These commands may be characterized as a communication protocol between the Client Application and the Sandbox Manager .

In block the Client Application receives a command from the user via a conventional user interface e.g. a mouse keyboard and the like . The user command instructs the Client Application to download the virtualized application file and or execute the virtualized application file .

The plug in is configured to request a different session for each virtualized application file being transferred and or executed. Thus each virtualized application file being transferred and or executed may be identified by a unique session identifier.

In decision block the plug in determines whether a session identifier is associated with the virtualized application file . The decision in decision block is YES when a session identifier is associated with the virtualized application file . The decision in decision block is NO when a session identifier is not associated with the virtualized application file .

When the decision in decision block is NO in block the plug in requests a new communication session having a unique session identifier with the Sandbox Manager over the communication link . Then the Client Application advances to block .

In block the Client Application translates the user command received in block into a request to be sent to the Sandbox Manager over the communication link . For example in embodiments in which the Client Application is a web browser in which the plug in is loaded in block the web browser receives the user command e.g. the user clicks on a hyperlink presses a button and the like and in block the plug in translates the user command into a request including a command e.g. one of the commands listed in Table A above and optionally one or more parameters e.g. the session identifier associated with the virtualized application file . The user command may be an instruction to download the virtualized application file see an instruction to execute the virtualized application file and the like. As mentioned above the request may be a string including the command and parameters if any.

Returning to in block the Client Application transmits the request to the Sandbox Manager over the communication link e.g. a TCP connection illustrated in . Optionally in block the Client Application may receive information from the Sandbox Manager . The information received may be a response to the command e.g. a response to a ping command a result of performing the command status and or progress information related to performing a command an error message and the like. Then the method terminates.

Returning to the Sandbox Manager receives requests from the Client Application and performs the commands included in the requests. The Sandbox Manager manages the transfer of the virtualized application file see from the server computing device to the client computing device illustrated in . The Sandbox Manager also manages execution of the virtual application see on the client computing device see . Turning to the Sandbox Manager includes a communications server e.g. a TCP server one or more predefined Client Request object types a Client Request Manager a Downloader an Executer and a UI manager referred to as a Surface. is a diagram illustrating some of the structural components of an exemplary implementation of the Surface .

Returning to as mentioned above in block the plug in requests a different communication session having a unique session identifier for each virtualized application file being transferred and or executed. Referring to in response to each request for a new communication session the communications server establishes a communication session between the Client Application and the Sandbox Manager and generates a unique session identifier for the new communication session. In this manner each virtualized application file being transferred and or executed may be identified by a unique session identifier.

Each of the predefined Client Request object types is associated with a particular type of virtualized application file. For example the Client Request object types include a Client Request object type associated with the virtualized application file . The types are used to create a Client Request object for each virtualized application file to be downloaded and or executed by the Sandbox Manager . An object of the Client Request object type associated with the virtualized application file is responsible for managing transfer and execution of the virtualized application file including determining status managing the cache see stored on the filesystem A etc.

The Client Request Manager determines whether a Client Request object has been created for a particular virtualized application file associated with a session identifier. If a Client Request object has not been created for a virtualized application file the Client Request Manager see identifies which of the predefined Client Request object type is configured to manage details about the virtualized application file creates a Client Request object of the type identified and associates the Client Request object with the session identifier associated with the virtualized application file. By way of a non limiting example a Client Request object may need to be created when the Sandbox Manager receives a start command for the first time to start downloading the virtualized application file . The Client Request Manager may include a dictionary configured to store Client Request objects for use in performing commands included in requests. The dictionary may be stored in the cache see of the filesystem A see .

Each of the Client Request objects includes a status field indicating a status related to the transfer and or execution of the virtualized application file. Table B below provides non limiting examples of status values or codes that may be stored in the status field.

The status field may be set to Canceled when user exits the web page e.g. browses to another page closes the browser window and the like on which the link to the virtualized application file being downloaded is displayed. By way of a non limiting example when the user exits the web page a cancel call may be created automatically e.g. by script code executing in the Client Application and sent to the plug in . In response the plug in sends a cancel message including the session identifier e.g. cancel to the Sandbox Manager over the communication link . If the status value of the status field of the Client Request object including the session identifier in the cancel message is In Progress the transfer is cancelled by the Sandbox Manager .

By way of a non limiting example the status value of the status field may be determined in the following manner. If the transfer of the virtualized application file has not yet started the current status is Not Started. If the transfer has started and is in progress the current status is In Progress. If the transfer has started is not in progress and has completed the current status is Complete. If the transfer has started is not in progress has not completed and has been canceled the current status is Canceled. If the transfer has started is not in progress has not completed has not been canceled and has encountered an error the current status is Error. Table C below provides a non limiting example of error codes that may used by the Sandbox Manager .

Each of the Client Request objects includes a progress field indicating an amount e.g. a percentage from 0 to 100 of the virtualized application file stored in the cache see of the filesystem A see .

Each of the Client Request objects may include a path to the transferred virtualized application file stored on the cache see of the filesystem A see .

The Downloader downloads a particular virtualized application file identified by a session identifier.

The virtual runtime engine is configured to capture user interface messages or API calls made by an executing virtual application e.g. the virtual application and forward them to the Surface . The Surface processes or translates these messages into user interface commands sent to the Client Application . For example the virtual runtime engine may capture a message to create a new window and display particular content therein made by an executing virtual application e.g. the virtual application and instead of generating a new window the virtual runtime engine forwards the message to the Surface . The Surface may render the particular content inside the control see . By way of non limiting examples the messages may include modifications to previously created windows e.g. hide change style etc .

The Surface may use the region occupied by the control as a desktop area that will host the application s user interface e.g. windows . The control may be used by any window in the current window desktop session.

The Surface includes one or more Listeners. Listeners are objects or procedures that are used to process events generated by the virtual application . Each Listener has one or more conditions that indicate which messages the Listener will process. For example if the virtual application makes a call to a SDK exposed function to open a new window i.e. calls a window procedure the virtual runtime engine forwards the request to the Surface . The Surface determines whether it has loaded a Listener configured to process a new windowing message. In other words the Surface determines whether the new message request satisfies the condition s of any of the Listeners. By way of a non limiting example Table D below provides a list of Listeners that may be implemented by the Surface . Some of the Listeners in Table D are configured to receive data e.g. a Windows Message ID value as defined in winuser.h in the Windows SDK .

As mentioned above the Surface may use a UI configuration file to generate the UI in the control . The UI configuration file does not describe how to render the control . Instead the UI configuration file defines rules for how the Surface should render an entire window. For example the UI configuration file may indicate that a particular window should be rendered inside the Surface or outside the Surface . By way of another non limiting example the UI configuration file may indicate whether to show or hide a window s title bar. The UI configuration file may have been downloaded by the Downloader along with a particular virtualized application file identified by a session identifier.

An import object type identifies one or more extension code assemblies that include additional objects to be loaded by the Surface during initialization. In this way developers may extend the information directly embedded in the UI configuration file by writing extension code assemblies e.g. dlls and identifying them in the UI configuration file using import type objects. For each import type object the Surface will automatically load the extension code assembly identified and resolve custom conditions data objects or actions specified in the extension code assembly.

An import type object has the following four properties AssemblyName Namespace LoadType and ResolveReferences. The AssemblyName property specifies the name of an extension code assembly including developer specified or custom conditions data objects or actions. The Namespace property specifies the namespace of the extension code assembly. The LoadType property specifies assembly load behavior. Load behaviors may include Never Auto and Lazy types. Never indicates the extension code assembly will never be loaded. Auto indicates loading will be performed when the extension code assembly identified by the import type object is needed. Lazy indicates loading will be performed when the UI configuration file is resolved.

As is apparent to those of ordinary skill in the art extension code assemblies identified in an import type object may include references to additional extension code assemblies. Thus a tree structure of extension code assemblies a extension code assembly dependency tree may be specified by the UI configuration file . The ResolveReferences property of an import type object indicates how extension code assemblies referenced by a particular or parent extension code assembly will be resolved. The value specified may be None All and OneMoreStep. The value None indicates none of the referenced extension code assemblies will be resolved. The value All indicates all of the referenced extension code assemblies i.e. the entire extension code assembly dependency tree will be resolved. OneMoreStep indicates only referenced extension code assemblies of the current assembly will be loaded any extension code assemblies identified in the referenced extension code assemblies will be ignored.

The following example XML code may be used to define an import type object in the UI configuration file .

The UI configuration file can be linked to other UI configuration files to support reusability of existing UI configuration files. An inherited file type object is used to identify the linked UI configuration files. Listeners actions packs and condition packs defined in inherited UI configuration files may be loaded by the Surface session.

Like the import object types the inherited configuration files may also define a tree structure an inheritance dependency tree because an inherited file type object may include one or more inherited file type objects. The surface configuration inheritance is deep tree. In other words all of the UI configuration files in the inheritance dependency tree may be loaded. The following example XML code may be used to define an inherited file type object in the UI configuration file .

The same inherited UI configuration file can be linked to the UI configuration file more than once to create multiple instances of the same inherited UI configuration file. The following example XML code demonstrates the inclusion of a first reference included in a first inherited file type object and a second reference included in a second inherited file type object to the same inherited UI configuration file in the UI configuration file .

Information and or objects included in an inherited UI configuration file may be accessed by using the name of the inherited file type object and the name of the item to be accessed. For example the XML code below includes an inherited file type object named default that includes a condition named ValidateIsModalDialog. The condition ValidateIsModalDialog is accessed in the XML below as Default.ValidateIsModalDialog. All members of an inherited file type object such as inherited file type objects Variables Listeners Actions Packs and Condition Packs and the like can be accessed by this way.

A variable collection object is a collection of variables. Variables are data storage objects used to store data. Depending upon the implementation details it may be desirable for each of the variables to have a unique name. However the same name may be given to two or more different variables in the different UI configuration files even if they are linked together as described above. Any type of data may be stored in a variable. Further an initial value may be specified for a variable.

The variable collection object may include a Locked property. If the Locked property is set to FALSE the Surface can add variables to or remove variables from the variable collection object during runtime. Otherwise if the Locked property is set to TRUE the Surface cannot add variables to or remove variables from the variable collection object during runtime.

Each variable may include a ReadOnly attribute. If the ReadOnly attribute is set to TRUE the data stored in the variable cannot be modified. Otherwise if the ReadOnly attribute is set to FALSE the data stored in the variable can be modified. The variables need not be strongly typed. Therefore the data type of a variable may be changed so that any data may be stored in any variable. The following example XML code may be used to define a variable collection object and the variables in the collection in the UI configuration file .

A variable may be accessed using a Data type object discussed in more detail below of the type DataVariable. The XML code below illustrates how a Data type object having the type DataVariable accesses a variable named SurfaceHandle. In the XML code the name attribute of the DataVariable type object is set to the name SurfaceHandle of the variable. The DataVariable type object may be used to change the value of the variable SurfaceHandle. 

As demonstrated in the XML code below variables may be accessed in inherited UI configuration files using the name of the inherited file type objects.

Depending upon the implementation details there may be no visibility limitations for the variables. In such implementations the variables may be characterized as public members of the UI configuration file.

As mentioned above the Surface includes one or more Listeners that process events generated by the virtual application . The UI configuration file may include one or more Listener type objects used to configure the Listener s of the Surface . Table D below provides non limiting examples of types of Listener type objects.

The Windows Message ID listed in Table D above is defined in winuser.h in Windows SDK ex WM SHOWWINDOW WM WINDOWPOSCHANGED etc. .

Each Listener type object is associated with one or more conditions that indicate which messages the Listener configured by the Listener type object will process. A Listener type object may include one or more Data attributes that are used to determine which events and messages will be handled by the Listener configured by the Listener type object. For example Listener type objects of the type WindowMessage include the Data attribute Windows Message ID. A MainWindow is the window whose properties can be shared between the Listeners during the lifetime of the Surface.

Depending upon the implementation details the UI configuration file may not define any Listener type objects. The UI configuration file may include one or more Listener type objects of the same type. In such situations the Surface may invoke the Listeners defined by the Listener type objects in the order they are listed in the UI configuration file .

As demonstrated in the following XML code each of the Listener type objects may include an Enabled attribute that indicates whether the Listener defined by the Listener type object is enabled or disabled at that moment. If the Listener is disabled the Surface will ignore the Listener and not trigger it.

Each of the Listener type objects may be associated with a Condition object and or an Action object. The Condition object specifies one or more conditions to be satisfied. The Action object specifies one or more actions to be performed. If a Condition object and an Action object are associated with the Listener type object and the one or more conditions of the Condition object are satisfied the one or more actions of the Action object are performed. If a Condition object and an Action object are associated with the Listener type object but the one or more conditions of the Condition object are not satisfied the Listener defined by the Listener type object is ignored and the one or more actions of the Action object are not performed. If an Action object is associated with the Listener type object but no Condition objects are associated with the Listener type object the one or more actions of the Action object are performed.

The process of determining whether the one or more conditions of the Condition object are satisfied is referred to as validation. Condition objects may return TRUE or FALSE as the result of the validation. Each Condition object may have its own validation method s .

The following XML code provides two non limiting examples of Condition objects. Both Condition objects are type BooleanCondition. Each Condition object specifies a Left value a Right value and an Operator. Table E below provides a non limiting list of operators that may be used by the Condition objects. In the XML code below the first Condition object returns TRUE if the Left and Right values are equal. Thus the first Condition object returns TRUE if the data window is the main window. The second Condition object returns TRUE if the Left value is smaller than the Right value. Thus the second Condition object returns TRUE if the x component of the location of the data window is less than five.

Depending upon the implementation details the Surface may have an automatic type resolution system that converts data to a target type before using the data. Therefore when comparing values having two different data types the Surface may convert the data type of one of the values e.g. the Right value into the data type of other values e.g. the Left value .

A ConditionGroup type object may be used to associate multiple Condition objects with a Listener type object. For example the XML code below includes two ConditionGroup type objects. The first ConditionGroup type object returns TRUE when both the first Condition object and the second Condition object embedded in the first ConditionGroup type object return TRUE. The second ConditionGroup type object returns TRUE when either the first Condition object or the second Condition object embedded in the second ConditionGroup type object return TRUE.

Table E below provides non limiting examples of Condition object types that may be included in the UI configuration file .

In addition to the Condition object types listed in Table E the Surface may also include one or more abstract base classes. Custom Condition objects may be implemented by inheriting from these abstract base classes.

Data type objects are used to define DataObjects that are used to retrieve set and or modify data values. The following XML code provides a non limiting example of a Data type object. The Data type object has a type DataSurface and stores the WindowHistories.SaveState. The Data type object defines two parameters a constant DataConstant and a DataWindow parameter and sets the value of a parameter type DataConstant to First State. The DataWindow parameter stores the value of the Handle of the DataSurface named WindowHistories.SaveState. 

The following XML code provides additional non limiting examples of Data type objects. As is apparent to those of ordinary skill in the art the XML code below defines only portions of Condition type objects and are not complete definitions thereof.

The Surface may change the type of data to match the data type of a DataObject. The Surface may use simple and or complex data types. Data type objects may be used to access a DataObject itself or any member method constructor field property of that DataObject.

Data type objects are generally used in Condition parameters Action parameters DataObject parameters etc. in the Surface. Table H below lists non limiting examples of types of Data type objects.

The Data type objects listed in Table H above may have different structures. For example a DataVariable type discussed above is a reference to a variable and a DataWindow type allows access to a current ProxyWindow object i.e. the window that triggered the current Listener .

ProxyWindow is a proxy class that can be used to access properties and methods of a Window. These methods and properties are generally sets of windowing message operations that together perform a group or single operation on the window. ex. BorderVisible CaptionVisible Location Bounds etc. 

As mention above a Listener type object may be associated with one or more Condition objects and or one or more Action objects. Each Condition object specifies one or more conditions to be satisfied. Each Action object specifies one or more actions that will be performed by the Surface .

If the Listener type object is associated with one or more Condition objects the one or more actions specified by the one or more Action objects associated with the Listener type object will be performed by the Surface only if the conditions specified by the one or more Condition objects are satisfied. Otherwise if the Listener type object is not associated with one or more Condition objects the one or more actions specified by the one or more Action objects associated with the Listener type object will be performed by the Surface .

However as demonstrated in the following XML code Action objects may also be associated with one or more Condition object. Therefore before the one or more actions specified by the Action object are performed the conditions specified by the one or more Condition objects associated the Action object must be satisfied or validated .

When a new Listener event is triggered by the Surface a ListenerContext object is created. The ListenerContext object contains the data objects that are available during the Listener session. For example when a new WindowMessage Listener has been triggered the Surface prepares a ListenerContext object that contains the Message structure and Window instance to which the windowing message that triggered the new WindowMessage Listener belongs.

When a new Listener invocation is triggered the Surface creates the ListenerContext object which contains two pieces of information ListenerType and FilterData. When the Surface enters the Listeners loop see discussion below of a method the Surface first checks to see that the current Listener has the same ListenerType as the ListenerContext object. If not the Listener will be ignored otherwise the Surface will try to compare the Data object s of the Listener with the FilterData of the ListenerContext object.

ListenerContext objects also manage tracing operations. If an EnableTrace property of the ListenerContext object is TRUE the Surface will write trace messages to the ListenerContext object during all condition validations and action processing.

ListenerContext objects also have an IsAlive property. This property indicates whether the Surface should continue to run the remaining Listeners. If this value is set to FALSE while a Listener is running the Surface will stop running the remaining Listeners.

As demonstrated by the XLM code below the members of the ListenerContext object may be accessed by a Data type object having the type DataContext. 

When the UI configuration file includes inherited file type object the Surface runs the Listener s of the UI configuration file first. Then the Surface runs the Listeners of the inherited configurations.

An ActionPack object is a collection or set of Action objects packaged together to form a single action. An ActionPack object may be called by different Listeners. Thus instead of including the same set of actions in the Action objects e.g. action tags of multiple Listener type objects a single set of actions can be included in an ActionPack object and called as a unit by different Listener type objects.

Depending upon the implementation details it may be desirable for each ActionPack object to have a unique name in the UI configuration file . An ActionPack object is executed by an Action object of the type PackedActionCaller. In particular implementations an ActionPack object may be limited to having a single Action object. In such embodiments an ActionGroup object may be used to include multiple Action objects.

The following XML code provides a non limiting example of an ActionPack object having an embedded Condition object and Data type object.

The following XML code provides a non limiting example of a Listener type object having an embedded Action object of type PackedActionCaller that calls an ActionPack object named CaptureWindow. 

A ConditionPack object is a collection or set of Condition objects packaged together to form a single reusable set of conditions for validation by the Surface . The ConditionPack object may be called from different objects e.g. Listener type objects Action objects ActionPack objects ActionGroup objects and the like .

Depending upon the implementation details it may be desirable for each ConditionPack object to have a unique name in the UI configuration file . A ConditionPack object is executed by an Action object of the type PackedConditionCaller. In particular implementations a ConditionPack object may be limited to having a single Condition object. In such embodiments a ConditionGroup object may be used to include multiple Condition objects.

The following XML code provides a non limiting example of a ConditionPack object named IsTargetWindow having an embedded ConditionGroup object and Data type object.

The following XML code provides two non limiting examples of Condition objects both of type PackedConditionCaller. The first one calls a ConditionPack object named IsShowWindowMessage. The second one calls a ConditionPack object named IsTargetWindow. 

Next in decision block the parameters are validated. By way of a non limiting example the parameters may be validated by determining whether the number of parameters matches the number that were expected. The decision in decision block is YES when the parameter are valid e.g. the number of parameters matches the number that were expected . Thus if a particular command does not include parameters e.g. the ping command the decision in decision block is YES if the request does not include any parameters. The decision in decision block is NO when the parameter are invalid e.g. the number of parameters does not match the number that were expected .

When the decision in decision block is NO in block an error message is sent to the Client Application . Then the method terminates.

When the decision in decision block is YES the Sandbox Manager advances to decision block . In decision block the Sandbox Manager determines whether the request includes a session identifier. The decision in decision block is YES when the request includes a session identifier. The decision in decision block is NO when the request does not include a session identifier.

When the decision in decision block is YES in block the session identifier is used to identify or locate a Client Request object associated with the session identifier and responsible for downloading and or executing the virtualized application file identified by the session identifier. The dictionary of the Client Request Manager may be used to lookup the Client Request object associated with the session identifier.

In decision block the Sandbox Manager determines whether a Client Request object associated with the session identifier has been identified. The decision in decision block is YES when a Client Request object associated with the session identifier has been identified. The decision in decision block is NO when a Client Request object associated with the session identifier has not been identified in block .

When the decision in decision block is NO in block the Sandbox Manager sends an error message to the Client Application . The error message may include the error indicator Invalid Session Id see Table C above . Then the method terminates. Thus if a command is sent to the Sandbox Manager with a session identifier that is not in the dictionary an error is returned to the Client Application and a new request must be sent to the Sandbox Manager . For example if a status progress or exec command was received in block including a session identifier not associated with a Client Request object for the Sandbox Manager to perform the command the transfer must be started again with a new request including the start command.

When the decision in decision block is NO the Sandbox Manager advances to decision block to determine whether the Sandbox Manager should create a new Client Request object. Referring to Table A above only two commands listed do not include the session identifier the start command and the ping command. The decision in decision block is YES when the command in the request is the start command. Otherwise the decision in decision block is NO. Thus the decision in decision block is NO when the request includes the ping command.

When the decision in decision block is YES in block the Sandbox Manager creates a new Client Request object and associates the new Client Request object with a session identifier. By way of a non limiting example a method call may be made to the Client Request Manager see to create the new Client Request object. In response to the method call the Client Request Manager identifies the Client Request object type that manages details about the particular virtualized application file being transferred to and or executed on the client computing device see . Then a new Client Request object having the type identified by the Client Request Manager is created.

The Client Request Manager includes a Client Request object for each virtualized application file the Sandbox Manager is transferring and or executing. The Client Request object may be cached in the dictionary of the Client Request Manager which may be configured to provide fast lookup of the Client Request object in response to subsequent requests including the session identifier involving the cached Client Request object. The Client Request object is responsible for managing the transfer of the virtualized application file status of the transfer progress of the transfer execution of the virtualized application file management of the cache see etc. Thus when a transfer is started a unique session identifier is generated a Client Request object is created the Client Request object is associated with the unique session identifier and the Client Request object is stored in the dictionary for future lookups. The status field of the new Client Request object is set to Not Started and the progress field is set to 0 . 

Then the Sandbox Manager advances to block from block . When the decision in decision block is NO the Sandbox Manager also advances to block .

In block Sandbox Manager performs the command. If applicable the command is executed on the Client Request object identified in block or created in block . Then in optional block Sandbox Manager sends information back to the Client Application . For example as discussed below with respect to the method see some commands instruct the Sandbox Manager to perform operations that return values to the Client Application . Then the method terminates.

If the command is a ping command in blocks and the Sandbox Manager sends a response to the Client Application . If the command is a start command in block the Downloader downloads the virtualized application file . If the command is a status command in blocks and the Sandbox Manager obtains the status value from the status field of the Client Request object identified in block or created in block and sends the status value to the Client Application . If the command is a progress command in blocks and the Sandbox Manager obtains the progress value from the progress field of the Client Request object identified in block or created in block and sends the progress value to the Client Application . If the command is a exec command in block the Executer executes the virtualized application file .

In first block the Client Application receives a new user command to download and execute the virtualized application file . In block the Client Application sends a request including the ping command to the Sandbox Manager . The ping command is sent by the Client Application to determine whether the Sandbox Manager is in a state to service commands e.g. available and functioning and capable of responding to requests. If the Sandbox Manager is running and in a state to service commands the Sandbox Manager will send a response to the Client Application .

In decision block the Client Application determines whether it has received a response from the Sandbox Manager to the request sent in block . The decision in the decision block is YES when the Client Application has received a response from the Sandbox Manager indicating that the Sandbox Manager is in a state to service commands and is capable of responding to requests. The decision in the decision block is NO when the Client Application has not received a response from the Sandbox Manager or receives a response indicating the Sandbox Manager is not in a state to service commands e.g. available and functioning or is incapable of responding to requests.

When the decision in the decision block is NO the Client Application returns to block . Alternatively when the decision in the decision block is NO the method may terminate. Optionally the Client Application may display a message to the user indicating the virtualized application file is not available to download.

When the decision in the decision block is YES in block the Client Application establishes a new communication session with the Sandbox Manager and sends a request including a start command to the Sandbox Manager . As mentioned above when the communications server see of the Sandbox Manager initiates a new session the communications server generates a new and unique session identifier. The start command commands the Sandbox Manager to begin transferring the virtualized application file .

In block when the Sandbox Manager receives the start command the Client Request Manager identifies a Client Request object type for the virtualized application file creates a Client Request object of the type identified and associates the session identifier with the new Client Request object. Then the Sandbox Manager determines whether at least a portion of the virtualized application file is stored in the cache see of the filesystem A see . The decision in the decision block is YES when at least a portion of the virtualized application file is stored in the cache see . Otherwise the decision in the decision block is NO. 

When the decision in decision block is YES in decision block the Sandbox Manager determines whether the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is YES when the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is NO when less than the entire virtualized application file is stored in the cache see .

When the decision in decision block is YES the virtualized application file need not be transferred to the client computing device because the virtualized application file is already stored in the cache see of the filesystem A see . In block the Sandbox Manager updates the status field of the Client Request object to Complete and the progress field to 100 . Then the Sandbox Manager advances to block .

When the decision in decision block or decision block is NO the Sandbox Manager begins transferring the virtualized application file. If the decision block was NO in block the Sandbox Manager adds the virtualized application file to the cache see of the filesystem A see . The Sandbox Manager sets the status field of the Client Request object to Not Started and the progress field to 0 . Then in block the Sandbox Manager begins transferring the virtualized application file from its beginning.

If the decision block was YES but the decision block was NO in block the Sandbox Manager sets the status field of the Client Request object to In Progress calculates the progress value and sets the progress field to the calculated progress value. Then the Sandbox Manager begins transferring the virtualized application file from wherever the previous transfer activities left off. The transfer may be started in a new thread using http protocol. In block the progress field of the Client Request object is updated occasionally e.g. periodically to indicate the percentage of the virtualized application file transferred. Then the Sandbox Manager advances to block .

In block the Sandbox Manager returns the session identifier associated with the virtualized application file to the Client Application .

In block the Client Application sends a request to the Sandbox Manager including the status command. In response to the status command in block the Sandbox Manager sends the status value e.g. in progress or complete of the status field of the Client Request object to the Client Application . In block the Client Application receives the status value sent by the Sandbox Manager . Optionally the Client Application may display the status value of the transfer to the user.

In decision block the Client Application determines whether the entire virtualized application file has been downloaded. The decision in decision block is YES if the status field of the Client Request object indicates the entire virtualized application file has been downloaded e.g. the status field has the value Complete . The decision in decision block is NO if the status field of the Client Request object indicates the virtualized application file has not been completely downloaded e.g. status field has the value In Progress .

If the decision in decision block is NO in block the Client Application sends a request to the Sandbox Manager including the progress command to determine the progress value of the transfer of the virtualized application file . In response to the progress command in block the Sandbox Manager sends the progress value in the progress field of the Client Request object e.g. 10 25 etc. to the Client Application . In block the Client Application receives the progress value sent by the Sandbox Manager . Optionally the Client Application may display the progress value to the user. Then the Client Application returns to block .

If the decision in decision block is YES in block the Client Application sends a request to the Sandbox Manager including an exec command. In response to the exec command in block the Executer see of the Sandbox Manager executes the virtual application at least partially implemented by the virtualized application file that the Sandbox Manager has just transferred. Then the method terminates.

As mentioned above the parameters of the exec command includes the session identifier identifying the virtualized application file transferred and optional command line arguments. The session identifier is used to identify the Client Request Object storing the path to the transferred virtualized application file stored on the cache see of the filesystem A see . The path is then used to execute the transferred virtualized application file. The transferred virtualized application file may be executed via an operating system programming interface function call e.g. ShellExecute CreateProcess and the like .

In block if the virtualized application file is configured to be executed inside a virtualized environment provided a virtual machine executable file e.g. the virtualized application file is not an executable file having the .exe extension the Sandbox Manager executes the virtual machine executable file and instructs the executing virtual machine to execute the virtualized application file . The Sandbox Manager may send a command to the operating system A to execute the virtual machine inside an operating system shell process. The command may include the path to the virtualized application file as a parameter that the virtual machine uses to locate and execute the virtualized application file .

If more than one virtual machine executable file e.g. virtual machine executable files are stored in the system memory A the Sandbox Manager identifies which of the virtual machine executable files is configured to execute the virtualized application file . As explained above the virtualized application file may include a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file . Each of the virtual machine executable files may also include a version identifier that may be matched to the version identifier of a particular virtualized application file to determine whether the virtual machine executable file is configured to execute the particular virtualized application file.

By way of a non limiting example blocks and of the method may be implemented in accordance with the following block of pseudo code.

By way of a non limiting example the function named StartDownload used in the above block of pseudo code may be implemented as follows 

By way of a non limiting example the function named FindFullSize used in the first block of pseudo code may be implemented as follows 

Referring to the method is performed as the Executer initiates execution of the virtual application in block of the method illustrated in or block of the method illustrated in . When the virtual application is executed by the Executer and its user interface displayed by the Client Application the virtual application may be characterized as being hosted inside the Surface .

To host the virtual application inside the Surface in block a new instance of the Surface class is created. Then in block the UI configuration file for the virtual application is loaded by the Surface . When the instance is being created the handle of the hosting panel or control is forwarded to the Surface.

The following pseudo code provides an example of how the new instance of the Surface class may be created and how the handle of the control may be provided to the new instance of the Surface class. As is apparent to those of ordinary skill in the art the handle of the control may have been passed to the Sandbox Manager by the plug in . The Sandbox Manager may then provide the handle of the control to the Surface .

After the UI configuration file is loaded in block the Surface waits for notification messages from the virtual runtime engine. In block the Surface receives a notification message from the virtual runtime engine. After receiving the message in block the Surface triggers a new Listener event and creates a new ListenerContext object. As mentioned above ListenerContext objects have a ListenerType value FilterData and an IsAlive property. The ListenerContext object may also include one or more Data type objects.

In block the Surface sets the values of Data type objects in the ListenerContext object sets the ListenerType value and sets the FilterData values based at least in part on the event that invoked the notification message received in block .

Starting in block the Surface loops through the Listeners. In other words the Surface analyzes each of the Listener type objects in the UI configuration file or Listener objects defined thereby to determine which if any are associated with the event that invoked the notification message. By way of a non limiting example in block the Surface may set the execution stack to the current UI configuration file e.g. the UI configuration file . In other words the Surface may loop through Listeners in the stack frame. In the method the Surface may examine each of the Listener type objects in the order they are defined in the UI configuration file .

In decision block the Surface determines whether the UI configuration file includes one or more Listener type objects.

If the UI configuration file does not include one or more Listener type objects the decision in decision block is NO and the Surface advances to block .

If the UI configuration file includes one or more Listener type objects the decision in decision block is YES and in block the Surface selects a Listener type object to evaluate.

Then in decision block the Surface determines whether the IsAlive property of the ListenerContext indicates it is alive. If the IsAlive property of the ListenerContext indicates it is not alive the decision in decision block is NO and in block the Surface terminates the loop.

If the IsAlive property of the ListenerContext indicates it is alive the decision in decision block is YES. When the decision in decision block is YES in decision block the Surface validates that the Type of the Listener selected in block is same as the ListenerType value of the ListenerContext object. If the type is not the same the decision in decision block is NO and in decision block the Surface determines whether there is a next Listener. If there is a next Listener the decision in decision block is YES and the Surface returns to in block and selects another Listener. If there are no more Listeners the decision in decision block is NO and the Surface advances to block to terminate the loop.

If the Type of the Listener is the same as the ListenerType value of the ListenerContext object the decision in decision block is YES. When the decision in decision block is YES the Surface advances to decision block whereat the Surface determines whether the Listener is validated in view of the ListenerContext object. In decision block the Surface compares the Data of the Listener with the data of the FilterData of the ListenerContext object to determine whether the Listener should be processed further. In other words in decision block the Surface determines whether the notification message received by the Surface applies to the Listener.

On the other hand if the validation is successful the decision in decision block is YES and in decision block the Surface determines whether the Listener type object is associated with one or more conditions. If the Listener type object is associated with one or more Condition objects the decision in decision block is YES and in decision block the Surface determines whether the conditions specified by the Condition object s is are satisfied.

If the conditions are not satisfied the decision in decision block is NO the Surface returns to decision block to determine whether there is a next Listener.

If the conditions are satisfied the decision in decision block is YES in block the Surface identifies any Action objects associated with the Listener.

If the Listener type object is not associated with one or more Condition objects the decision in decision block is NO and the Surface advances to block .

In decision block for each Action objects associated with the Listener the Surface determines whether the Action object is associated with one or more conditions. If the Action object is associated with one or more Condition objects the decision in decision block is YES and in decision block the Surface determines whether the conditions specified by the Condition object s is are satisfied.

If the conditions are satisfied the decision in decision block is YES and in block the Surface performs the action s specified by the Action object. Then the Surface returns to decision block to determine whether there is at least one more Listener to evaluate.

If the Action object is not associated with one or more Condition objects the decision in decision block is NO and in block the Surface performs the action s specified by the Action object.

If the conditions are not satisfied the decision in decision block is NO and the Surface returns to decision block to determine whether there is at least one more Listener to evaluate.

After the loop through the Listeners is ended in block in decision block the Surface determines whether the UI configuration file includes one or more inherited file type objects i.e. links to inherited UI configuration files that have not been processed.

If the UI configuration file includes one or more inherited file type objects that have not been processed the decision in decision block is YES and in block the Surface selects an inherited file type object that has not been processed. Then in block the Surface increases the stack level. Then the Surface returns to block to start to loop through the Listener type objects of the inherited UI configuration file.

If the UI configuration file does not include one or more inherited file type objects that have not been processed the decision in decision block is NO and the method terminates.

After the new instance of the Surface class is created in block of the method the Surface class initiates execution of the user interface of the virtual application inside the Surface . However the virtual runtime engine actually executes the virtual application .

By way of a non limiting example the Surface class may include a Start method that when executed initiates execution of a target process e.g. the virtual application . The following pseudo code is a non limiting example of an implementation of the Start method of the Surface class.

In the pseudo code above a Start method of a ProcessCreator class object named creator is responsible for starting the virtual application . By way of a non limiting example the following pseudo code may be used to implement the Start method of the ProcessCreator class.

In the pseudo code above if the virtual application is not to be executed in an operating system shell the virtual application is started in a suspended state so that the Surface can be completely initialized before any windowing messages are sent by the virtual application . For example execution of the virtual application may be suspended until the UI configuration file has been loaded in block of the method . On the other hand if the virtual application is to be executed in a shell execution is initiated directly in an unsuspended state. By way of a non limiting example the Surface may determine the virtual application is to be executed in a shell when the UseShellExecute flag of the ProcessStartInfo object is set to TRUE. In that case the virtual application will start directly without being suspended initially.

Thus referring to the Surface may perform a method when initiating execution of the virtual application inside the Surface . In decision block the Surface determines whether the virtual application is to be executed in a shell. If the virtual application is to be executed in a shell the decision in decision block is YES and in block the Surface executes the virtual application directly. Optionally the user interface of the virtual application may be displayed inside the control .

If the virtual application is not to be executed in a shell the decision in decision block is NO in block the Surface executes the virtual application in a suspended state until the Surface has finished its initialization process. Then in block the suspension is ended and the virtual application is executed in an unsuspended state. Then the method terminates.

As mentioned above the virtual application is actually executed at least in part by the virtual runtime engine. Further the virtual runtime engine monitors the windowing messages generated by the virtual application and forwards at least some of them to the Surface for processing. By way of a non limiting example one or more hooks may be used to perform the monitoring.

As is appreciated by those of ordinary skill in the art a hook may be used to monitor an operating system for certain events e.g. to monitor a message handling mechanism . For example Microsoft Windows Operating System provides WH CALLWNDPROC and WH CALLWNDPROCRET hook types that may be used to monitor messages sent to window procedures e.g. calls to the SDK exposed functions . The WH CALLWNDPROC hook type monitors messages sent to window procedures. The WH CALLWNDPROCRET hook type monitors the window procedures and determines when the procedures have finished processing messages. The events monitored by a hook may be associated with a particular thread or with all of the threads in the same desktop as the calling thread.

Custom procedures referred to as hook procedures may be specified for a particular hook type. For example a hook procedure may be specified for the WH CALLWNDPROC hook type by calling a SetWindowsHookEx method and identifying the WH CALLWNDPROC hook type as a parameter. The thread to be monitored may also be specified as a parameter.

When an event occurs that is monitored by the particular hook the hook calls hook procedures specified for the particular hook type. The Windows Operating System allows the hook procedures specified for the WH CALLWNDPROC hook to be called before the windowing messages are sent to receiving window procedures.

The virtual runtime engine may set up a hook procedure for each of the threads used by the target application at the moment. The virtual runtime engine may also set up a hook procedure for threads created later by calling SetWindowsHookEx method with the WH CALLWNDPROC parameter.

Referring to a method may be performed by the virtual runtime engine. The method sets up a hook procedure for the thread s created by the virtual application as it executes.

In first block the virtual runtime engine begins executing the virtual application . When the virtual application is started in block the virtual runtime engine sets up one or more hook procedures to monitor one or more threads used by the virtual application . The virtual runtime engine sets a hook procedure for each thread initiated by the virtual application . By way of a non limiting example this may be accomplished by establishing one or more hook procedures on a hook configured to detect the creation of a new thread. For example a hook configured to detect a call to the CreateRemoteThread function may be used. In such an embodiment whenever the virtual application creates a new thread the virtual application calls the CreateRemoteThread function.

The CreateRemoteThread function has two main parameters 1 a pointer to a thread start routine and 2 a pointer to application defined context data i.e. a context pointer . The virtual runtime engine populates a data structure configured to store the values of these two parameters. The following code is an example of a data structure named SThreadStartInfo configured to store the parameters of the CreateRemoteThread function.

After the data structure is populated the virtual runtime engine calls the real implementation of the CreateRemoteThread function in the host operating system passing 1 a pointer to a substitute thread start function and 2 a pointer to the data structure instead of the application provided parameter values i.e. pointer values .

The substitute thread start routine extracts the SThreadStartInfo data structure from the context pointer which as described above has been overridden . Then per thread initialization actions are performed that include setting up one or more SetWindowsHookEx callback functions. Lastly control is passed to the application defined thread start function along with the application defined thread context data pointer. Both of which were cached in the SThreadStartInfo structure.

In block the hook procedures triggered by the hook monitoring the creation of new threads set up the one or more hook procedures that will be executed when the virtual application calls a windowing function within the thread. Thus the method establishes one or more hook procedures that are executed when a windowing message is generated or a function call is sent to a windowing function .

Then in block the virtual runtime engine waits for the virtual application to create a new thread e.g. by calling the CreateRemoteThread function . While the virtual runtime engine waits the user may be interacting with the virtual application causing new threads to be created.

In block the virtual runtime engine receives an indication that a new thread has been created. The indication may be provided by the virtual operating system after it detects that a call has been made to the CreateRemoteThread function. Then in block the virtual runtime engine sets up one or more new hook procedures for the new thread. In block the virtual runtime engine may set up the new hook procedures for the new thread in substantially the same manner the virtual runtime engine set up the hook procedures in the block described above. Then the virtual runtime engine returns to block .

By way of a non limiting example in blocks and the virtual runtime engine may specify one or more hook procedures for the WH CALLWNDPROC hook that listen for windowing messages generated by a particular thread. The hook procedure or function is executed whenever a windowing message is generated that will be passed to a window procedure of the operating system e.g. the virtual operating system . The following pseudo code is a non limiting example of an implementation of a hook procedure or function configured to listen for windowing messages.

Then in block the virtual runtime engine enters a Surface Callback Mode. In block the virtual runtime engine sends the message to the Surface . Then in block the virtual runtime engine waits for a response from the Surface .

A response is received in block . In decision block the virtual runtime engine determines whether the response has been mapped to an operating system API function call e.g. a WindowsAPI function call a SDK exposed function and the like .

If the response has been mapped the decision in decision block is YES and in block the API function call is made. Then the virtual runtime engine advances to decision block .

If the response has not been mapped the decision in decision block is NO and the virtual runtime engine advances to decision block .

In decision block the virtual runtime engine determines whether any more responses will be sent. For example when the Surface sends a response having the type eNoMoreResponse the virtual runtime engine determines no more responses will be sent. In such cases the decision in decision block is YES. Otherwise the decision in decision block is NO. 

When the decision in decision block is YES in block the virtual runtime engine exists Surface Callback Mode. Then in block the virtual runtime engine executes the next hook procedure if any. For example in block the virtual runtime engine may call the CallNextHookEx function. Thus the method may be repeated for each hook procedure associated with a particular windowing message. Then the method terminates.

As discussed above to improve performance the virtual runtime engine may receive a list of the windowing messages in which the Surface is interested during initialization of the Surface session. The list of the messages in which the Surface indicates that it is interested may be generated by the Surface by searching its UI configuration file s for Listener type objects of the WindowMessage type. Thus before entering Surface CallBack Mode in block the virtual runtime engine may decide whether to send the windowing message to the Surface .

As discussed above hook procedures are established for one or more hooks. The hook procedures may be associated with one or more specific threads created by the virtual application as it executes. Thus a hook procedure is executed by a hook when a particular event occurs within a particular thread. Further the virtual runtime engine may be in Surface Callback Mode with respect to a particular thread but not with respect to other threads.

When a hook identifies an event of the type monitored by the hook has occurred e.g. a windowing message has been generated the hook triggers or executes any hook procedures associated therewith.

Optionally in the method each of the hook procedures triggered determines whether the virtual runtime engine is operating in Surface Callback Mode with respect to the relevant thread. The virtual runtime engine may determine the virtual runtime engine is operating in Surface Callback Mode with respect to the relevant thread s when an InSurfaceCallback flag stored in the Thread Local Storage is TRUE.

If the virtual runtime engine is operating in Surface Callback Mode with respect to the relevant thread s the windowing message detected in block is passed on to the default message handler. Thus the windowing message may be processed by the virtual runtime engine and displayed by the virtual operating system .

If the virtual runtime engine is not operating in Surface Callback Mode with respect to the relevant thread s optionally before sending the windowing message to the Surface in block the virtual runtime engine may determine whether the windowing message is one in which the Surface is interested by searching the list.

If the windowing message is on the list the virtual runtime engine sets the InSurfaceCallback flag to TRUE and sends a notification to the Surface about the windowing message. The message is sent using a communication object configured to effect communication between the Surface and virtual runtime engine. Then in block the Surface waits for a response from the Surface .

When the Surface receives the notification it performs the method described above. The method analyzes the UI configuration file to identify any Listeners for the windowing message and perform any actions associated therewith for which any associated conditions are satisfied.

The virtual runtime engine executing the virtual application and the Surface are separate applications both executing within a host operating system e.g. the operating system A or B . While running the Listeners and performing their associated actions the Surface may generate or trigger one or more new windowing messages. When this occurs the Surface may need to call an operating system API function. However instead of calling an API function of the windowing system of the host operating system an API function call may be made to the virtual operating system . Thus such messages may be sent to the target application e.g. the virtual application executing inside the virtual operating system .

In other words the Surface does not call the required API function directly. Instead the Surface calls an API function in an IWindowsAPI interface implementation. IWindowsAPI is an interface that contains some shadow methods of the original Windows API functions which the Surface uses within the ProxyWindow. When the Surface needs to call a Windows API function in the ProxyWindow class instead of calling that method directly the ProxyWindow object uses the IWindowsApi instance to call the required method. When a method is called in the IWindowsApi interface implementation a response object is created that identifies the API method to be called and its parameters values. Then the data of this response object is serialized and transferred to the virtual runtime engine e.g. via a named pipe connection .

Because the Surface and the virtual runtime engine are different applications e.g. different Microsoft Windows applications it may be beneficial to use a synchronized named pipe connection to communicate between the two applications. However those of ordinary skill in the art appreciate that other communication methods may be used.

When virtual runtime engine receives the serialized response message the virtual runtime engine de serializes the response message. The  OnSetParent function in the pseudo code above provides an example of a deserialization process.

Then the virtual runtime engine calls the API function within the virtual operating system identified in the response message with the information included in the response. Alternatively the virtual runtime engine could send the message to the Surface to be processed.

This serialized response message has a message type value that indicates the type of the response message. By way of non limiting examples the response message type may include the values listed in Table J below.

As mentioned above in addition to a type value the serialized response message also includes the values of any arguments or parameters required to call the appropriate windowing API function.

Then in blocks the virtual runtime engine waits for additional response messages from the Surface until the virtual runtime engine receives a response message of the type eNoMoreResponses. When the virtual runtime engine receives response message of the type eNoMoreResponses the virtual runtime engine exits Surface Callback Mode in block .

The following pseudo code provides a non limiting example of a method that may be used by the Surface to prepare the serialized message.

The SurfaceSession class receives the windowing messages from the application s virtual environment and calls the appropriate Listeners for the windowing message. In particular embodiments the virtual runtime engine may redirect all windowing messages to the Surface . However as discussed above in alternate implementations the virtual runtime engine may send only messages included on list to the Surface .

At this point the APIProxy of the ProxyWindow is assigned to the APIProxy member of the ProcessSurfaceMessage. This APIProxy is the IWindowsApi interface implementation responsible for sending the called function information to the virtual runtime engine as the serialized response message. When the virtual runtime engine receives the response message the virtual runtime engine calls the API function identified. Therefore the function calls performed by the Surface are executed in the thread of the virtual application .

The following pseudo code provides a non limiting example of a function named RunListener that may be used by the Surface to implement a Listener.

A ListenerContext object may be validated by a method of a Condition object. For example the Condition objects may include a method named Validate that receives a ListenerContext object as an argument. The Validate function determines whether the ListenerContext object is valid. Different types of Condition objects may have different Validate functions. The following pseudo code provides a non limiting example of a Validate function that may be used by a Condition object of type BooleanCondition. 

In the above pseudo code the left and right Boolean variable values are assigned the Left and Right values of a DataObject. Left and Right of the BooleanCondition are derived from DataBase class and are Data Objects. All data objects have a GetValue method to get the stored data and SetValue to store the data.

As mentioned above Data type object of different types may have different working procedures. The following pseudo code provides non limiting examples of GetValue and SetValue methods that may be included in Data type objects of type DataVariable. 

Condition objects and Action objects of different types may also have different working methods. Further each UI configuration file may include a unique configuration for Condition objects and or Action objects. For example the following pseudo code provides non limiting examples of a DoOperation method of an Action object having the type BreakAction. 

For example the following pseudo code provides non limiting examples of a DoOperation method of an Action object having the type Assignment. 

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the client computing device and the server computing device may be implemented in accordance with the computing device . By way of non limiting example the Client Application the Sandbox Manager the virtual machine executable files the transferred virtualized application file and the UI configuration file may be implemented on a first computing device like the computing device . The web server components and the authoring tool may be implemented on a second computing device like the computing device configured to store the virtualized application file and the UI configuration file and generate a web page displaying a link e.g. a hyperlink to the virtualized application file a link to the UI configuration file and providing a reference to the plug in .

The computing device includes the system memory . Each of the system memory A see and the system memory B see may be constructed in accordance with the system memory .

The computing device also includes a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. The network may include any of the aforementioned networking environments.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the operating system A the Client Application the Sandbox Manager the virtual machine executable files the transferred virtualized application file and the UI configuration file may be stored as computer executable components on the system memory A. Each of the operating system A the Client Application the Sandbox Manager the virtual machine executable files the transferred virtualized application file and the UI configuration file may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

Returning to the virtualized application file the UI configuration file the web server components and the authoring tool may be stored as computer executable components on the system memory B. Each of the virtualized application file the UI configuration file the web server components and the authoring tool may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

The memory A may store computer executable instructions that when executed by one or more processors cause the one or more processors to perform all or portions of the methods described above. Further such instructions may be stored on one or more non transitory computer readable media.

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

