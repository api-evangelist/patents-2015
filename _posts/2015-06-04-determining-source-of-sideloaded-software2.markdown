---

title: Determining source of side-loaded software
abstract: A source of side-loaded software is determined. An action may be performed in response to the determination of the source. In one case, the handling of an application on a mobile device may be based on whether the source of the application is trusted or untrusted. If a software application being newly-installed on a mobile device of a user is determined to be untrusted, installation or execution is blocked. In one approach, the determination of the source includes: determining whether a first source identifier of a first application matches a white list of source identifiers or a black list of source identifiers; and sending the first source identifier and a first application identifier for the first application to a different computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09589129&OS=09589129&RS=09589129
owner: LOOKOUT, INC.
number: 09589129
owner_city: San Francisco
owner_country: US
publication_date: 20150604
---
This application claims priority to U.S. Provisional Application Ser. No. 62 156 026 filed May 1 2015 entitled DETERMINING SOURCE OF SIDE LOADED SOFTWARE by Richardson et al. the entire contents of which application is incorporated by reference as if fully set forth herein.

The present application is related to U.S. Non Provisional application Ser. No. 14 105 950 filed Dec. 13 2013 entitled ASSESSING APPLICATION AUTHENTICITY AND PERFORMING AN ACTION IN RESPONSE TO AN EVALUATION RESULT the entire contents of which application is hereby incorporated by reference as if fully set forth herein.

The present application is related to U.S. Non Provisional application Ser. No. 14 301 007 filed Jun. 10 2014 entitled MONITORING FOR FRAUDULENT OR HARMFUL BEHAVIOR IN APPLICATIONS BEING INSTALLED ON USER DEVICES the entire contents of which application is hereby incorporated by reference as if fully set forth herein.

The present application is related to U.S. Non Provisional application Ser. No. 14 253 702 filed Apr. 15 2014 entitled MONITORING INSTALLED APPLICATIONS ON USER DEVICES the entire contents of which application is hereby incorporated by reference as if fully set forth herein.

The present application is related to U.S. Non Provisional application Ser. No. 14 253 739 filed Apr. 15 2014 entitled IDENTIFYING MANNER OF USAGE FOR SOFTWARE ASSETS IN APPLICATIONS ON USER DEVICES the entire contents of which application is hereby incorporated by reference as if fully set forth herein.

The present application is related to U.S. Non Provisional application Ser. No. 13 786 210 filed Mar. 5 2013 entitled EXPRESSING INTENT TO CONTROL BEHAVIOR OF APPLICATION COMPONENTS by Wyatt et al. U.S. Non Provisional application Ser. No. 13 692 806 filed Dec. 3 2012 entitled COMPONENT ANALYSIS OF SOFTWARE APPLICATIONS ON COMPUTING DEVICES by Wyatt et al. and U.S. Provisional Application Ser. No. 61 655 822 filed Jun. 5 2012 entitled EXPRESSING INTENT TO CONTROL BEHAVIOR OF APPLICATION COMPONENTS by Halliday et al. the entire contents of which applications are hereby incorporated by reference as if fully set forth herein.

At least some embodiments disclosed herein relate to determining a source of software in general e.g. software that is loaded onto or otherwise provided to a computing device and more particularly but not limited to determining a source of applications or other software obtained by a computing device e.g. an Android mobile device over a network via a connection to another device or otherwise.

Mobile application management MAM relates to software and services for provisioning and controlling access to internally developed and commercially available mobile apps used in business settings on both company provided and bring your own smartphones and tablet computers.

Enterprise mobile application management is increasingly important due to the widespread adoption and use of mobile applications in business settings. The bring your own device BYOD phenomenon makes mobile application management more important with personal PC smartphone and tablet use in business settings vs. business owned devices significantly increasing. Mobile application management enables corporate IT staff to download required applications control access to business data and remove locally cached business data from the device if it is lost or when its owner no longer works with the company. A growing demand for mobile apps from employees is prompting organizations to broaden beyond mobile device management to managing a growing number of mobile applications.

An end to end MAM solution can provide the ability to control the provisioning updating and removal of mobile applications via an enterprise app store monitor application performance and usage and remotely wipe data from managed applications.

Mobile device management MDM is an industry term for the administration of mobile devices such as smartphones tablets laptops and desktop computers. MDM is usually implemented with the use of a third party product that has management features for particular vendors of mobile devices. For example Good Technology provides MDM software.

MDM functionality can include over the air distribution of applications data and configuration settings for all types of mobile devices including mobile phones smartphones tablet computers mobile printers mobile POS devices etc. Most recently laptops and desktops have been added to the list of systems supported. MDM tools are used for both company owned and employee owned BYOD devices across the enterprise or mobile devices owned by consumers. Consumer demand for BYOD is now requiring a greater effort for MDM and increased security for both the devices and the enterprise to which they connect. By controlling and protecting the data and configuration settings for all mobile devices in a network MDM can reduce support costs and business risks.

With mobile devices becoming commonplace and increased numbers of applications becoming available for mobile devices mobile monitoring is growing in importance. Numerous vendors help mobile device manufacturers content portals and developers test and monitor the delivery of their mobile applications. This testing is done in real time by simulating the action of thousands of customers and detecting and correcting bugs in the applications.

Typical solutions include a server component which sends out the management commands to the mobile devices and a client component which runs on the mobile device and implements the management commands.

Central remote management uses commands sent over the air to mobile device handsets. An administrator at a mobile operator an enterprise IT data center or a handset OEM can use an administrative console to update or configure any one handset group or groups of handsets. The Open Mobile Alliance OMA has specified a platform independent device management protocol called OMA Device Management. It is supported by several mobile devices such as PDAs and mobile phones.

Over the air programming OTA capabilities are a component of mobile network operator and enterprise grade mobile device management software. These include the ability to remotely configure a single mobile device an entire fleet of mobile devices or any IT defined set of mobile devices send software and OS updates remotely lock and wipe a device and do remote troubleshooting. OTA commands are sent as binary messages which are messages including binary data.

Mobile device management software enables corporate IT departments to manage the many mobile devices used across the enterprise consequently over the air capabilities are in high demand. Enterprises using OTA as part of their MDM infrastructure demand high quality in the sending of OTA messages. Present day MDM solutions offer both Software as a Service SaaS and on premises models.

As mentioned above one example of mobile device management software is provided by Good Technology which provides some degree of control and visibility for an administrator of mobile devices. IT managers ensure that mobile devices comply with their organization specific IT policies and that the correct configuration is pushed to devices. Good s mobile device management software permits users to self enroll over the air. In addition to automatically configuring corporate policies and controls IT can automatically setup WiFi VPN and Exchange ActiveSync configurations on mobile devices.

An administrator admin defines and deploys policies for an organization. The admin may choose from a set of policy controls over password device encryption camera Wi Fi VPN etc. If a device is lost stolen retired or replaced the admin can wipe data from the device to reduce the chance of data loss.

The admin can control and manage various devices from a single console. Good s MDM supports a wide array of mobile devices operating systems and technologies including Apple iOS Apple Watch Android Windows Pro Window Phone and Samsung KNOX. Whether Bring Your Own Device BYOD Corporate Owned Personally Enabled COPE devices or a combination of both are utilized customizable policies ensure the right policies are applied to the right device.

Good s MDM supports use cases including business users remote workers highly sensitive users shared devices and kiosks. Good s MDM can be deployed using a fully cloud based deployment. Good s MDM can be fully integrated with Good Technology s Dynamics Secure Mobility Platform.

As users of mobile devices desire to and are able to install applications from numerous various sources that are beyond the control of an administrator there is an increased risk that malware or other undesirable software may be installed. One source of software available to users that may be beyond the control of or monitoring by administrators is peer to peer file sharing e.g. using the BitTorrent protocol . In some cases certain file sharing sources may be untrusted or even a known bad source of software loaded onto mobile devices.

BitTorrent is a protocol for peer to peer file sharing used to distribute large amounts of data over the Internet. BitTorrent is one of the most common protocols for transferring large files. To send or receive files a user must have a BitTorrent client a computer program that implements the BitTorrent protocol .

Some popular BitTorrent clients include Xunlei Transmission Torrent MediaGet Vuze and BitComet. BitTorrent trackers provide a list of files available for transfer and assist in transferring and reconstructing the files. BitTorrent clients are available for a variety of computing platforms and operating systems including an official client released by BitTorrent Inc. As of January 2012 BitTorrent is utilized by 150 million active users according to BitTorrent Inc.

The BitTorrent protocol provides no way to index torrent files. As a result a comparatively small number of websites have hosted a large majority of torrents many linking to copyrighted material without the authorization of copyright holders. There is controversy over the use of BitTorrent. BitTorrent metafiles themselves do not store file contents. Whether the publishers of BitTorrent metafiles violate copyrights by linking to copyrighted material without the authorization of copyright holders is controversial.

Several studies of BitTorrent indicate that a large portion of files available for download via BitTorrent contain malware. In particular one small sample indicated that 18 of all executable programs available for download contained malware. Another study claims that as much as 14.5 of BitTorrent downloads contain zero day malware.

In contrast to potentially untrusted or risky sources such as BitTorrent above in other cases applications may be installed on mobile devices by users from known good sources. For example a common source of applications installed on mobile devices using the Android system is the Google Play store.

The Android system requires that all installed applications be digitally signed with a certificate whose private key is held by the application s developer. The Android system uses the certificate as a means of identifying the author of an application and establishing trust relationships between applications. The certificate does not need to be signed by a certificate authority. Rather it is typical for Android applications to use self signed certificates.

Android applications that are not signed will not be installed on an emulator or a device. When a developer is ready to release an application for end users the developer signs it with a suitable private key. The developer can use self signed certificates to sign the developer s applications. No certificate authority is needed.

The Android system tests a signer certificate s expiration date only at install time. If an application s signer certificate expires after the application is installed the application will continue to function normally. The developer can use standard tools e.g. Keytool and Jarsigner to generate keys and sign the developer s application .apk files.

The Android system will not install or run an application that is not signed appropriately. This applies wherever the Android system is run whether on an actual device or on the emulator.

When a developer builds in release mode the developer uses its own private key to sign the application. When the developer compiles the application in release mode a build tools uses the developer s private key along with a Jarsigner utility to sign the application s .apk file. Because the certificate and private key used are owned by the developer the developer provides the password for the keystore and key alias. Some aspects of application signing may affect how the developer approaches the development of its application especially if the developer is planning to release multiple applications.

In general the recommended strategy for all developers is to sign all of the developer s applications with the same certificate throughout the expected lifespan of these applications. As the developer releases updates to its application the developer must continue to sign the updates with the same certificate or set of certificates if the developer wants users to be able to upgrade seamlessly to the new version. When the system is installing an update to an application it compares the certificate s in the new version with those in the existing version. If the certificates match exactly including both the certificate data and order then the system allows the update. If the developer signs the new version without using matching certificates the developer must also assign a different package name to the application in this case the user installs the new version as a completely new application.

When the developer has an application package that is ready to be signed the developer can sign it using the Jarsigner tool. To sign the application the developer runs Jarsigner referencing both the application s APK and the keystore containing the private key with which to sign the APK.

Maintaining the security of a private key is of critical importance both to the developer and to the user. If the developer allows someone to use the developer s key or if the developer leaves its keystore and passwords in an unsecured location such that a third party could find and use them the developer s authoring identity and the trust of the user are compromised.

If a third party should manage to take a developer s key without the developer s knowledge or permission that person could sign and distribute applications that maliciously replace the developer s authentic applications or corrupt them. Such a person could also sign and distribute applications under the developer s identity that attack other applications or the system itself or corrupt or steal user data. A developer s reputation depends on the developer securing its private key properly at all times until the key is expired.

Systems and methods for determining a source of software that is loaded onto or otherwise sourced by a computing device are described herein. Various embodiments described below relate to determining a source of applications or other software obtained over a network e.g. applications downloaded to a mobile device from an application store such as the Google Play store or the Apple App Store via a connection to another device e.g. such as when a wearable implantable or ingestible device may be provisioned with an application via a connection to a user s phone or other mobile device or otherwise obtained.

In various embodiments an action may optionally be performed in response to the determination of the source of software e.g. the handling of an application on the mobile device may be based on whether the source of the application is trusted or untrusted if untrusted installation of the software can be blocked or the software can be disabled or removed from the device . In another example a software application being newly installed on a mobile device of a user may be determined to be a fraudulent or tampered version in which case installation is blocked and an administrator server that manages the device via mobile device management MDM is notified that the source of the application is untrusted. Some embodiments are summarized below.

In one embodiment a method includes determining by a first computing device e.g. a mobile device whether a first source identifier source ID of a first application matches a white list of source identifiers determining whether the first source identifier matches a black list of source identifiers and sending by the first computing device to a second computing device e.g. a side load server at least one message comprising the first source identifier and a first application identifier for the first application.

In some embodiments the first computing device stores a device state that can be set to a value of trusted or untrusted and the first computing device stores data for a plurality of applications of the first computing device. The data includes an application state and a source identifier for each of the applications and each application state can be set to a value of known or unknown.

In one embodiment a method includes storing by a first computing device e.g. a side load server data for a plurality of applications associated with a second computing device e.g. a mobile device the data comprising a state designation for each of the applications wherein the state designation can be set to values including trusted and untrusted receiving by the first computing device from the second computing device a first application identifier and a first source identifier each for a first application setting by the first computing device a first state designation for the first application wherein the first state designation is to be used for setting a state on the second computing device and sending by the first computing device the first state designation to the second computing device.

In one embodiment a system e.g. a side load server includes at least one processor and memory storing instructions configured to instruct the at least one processor to receive from a first computing device e.g. a mobile device a first application identifier and a first source identifier each for a first application of the first computing device determine whether the first source identifier matches a white list of source identifiers e.g. a list of trusted channel identifiers and determine whether the first source identifier matches a black list of source identifiers e.g. a list of untrusted channel identifiers send the first application identifier and the first source identifier over a network to a second computing device e.g. an administrator server receive from the second computing device a first state designation for the first application set a second state designation based on the first state designation and send the second state designation to the first computing device.

In one example the side load server stores numerous state designations for applications of the mobile device and the administrator server also stores numerous state designations for the applications of the mobile device. These state designations are not necessarily identical e.g. a state designation for a given application may be different on each computing device . The state designations are used in various embodiments for setting an application state and or a mobile device state on the mobile device.

Also in another example the side load server the administrator server and the mobile device may each store black and white lists of source identifiers. These lists may be different on each of these computing devices.

In one embodiment a method includes receiving by a first computing device from at least one of plurality of computing devices a first application identifier and a first source identifier each for a first application setting by the first computing device a first state designation for the first application wherein the first state designation is to be used for setting a state on a second computing device and sending by the first computing device the first state designation to the second computing device.

In one embodiment a system includes at least one processor and memory storing instructions configured to instruct the at least one processor to receive from a first computing device a first application identifier and a first source identifier each for a first application of the first computing device determine whether the first source identifier matches at least one of a white list of source identifiers or a black list of source identifiers send the first application identifier and the first source identifier over a network to a second computing device receive from the second computing device a first state designation for the first application set a second state designation based on the first state designation and send the second state designation to the first computing device.

In one embodiment a system includes at least one processor and memory storing instructions configured to instruct the at least one processor to determine whether a first source identifier of a first application matches at least one of a white list of source identifiers or a black list e.g. in some cases only one type of list such as only a white list may be used in other cases both a white list and black list are used of source identifiers and send to a computing device the first source identifier and a first application identifier for the first application.

The disclosure includes various methods and devices which perform the above methods and systems including data processing systems which perform these methods and computer readable media containing instructions which when executed on data processing systems cause the systems to perform these methods.

Other features will be apparent from the accompanying drawings and from the detailed description which follows.

The following description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding. However in certain instances well known or conventional details are not described in order to avoid obscuring the description. References to one or an embodiment in the present disclosure are not necessarily references to the same embodiment and such references mean at least one.

Reference in this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the disclosure. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover various features are described which may be exhibited by some embodiments and not by others. Similarly various requirements are described which may be requirements for some embodiments but not other embodiments.

As used herein side loading or side loaded as used to characterize an application or other software indicates obtaining or obtained from a source that is not the default authorized channel for obtaining applications for the type of device e.g. the default channel may be set by the administrator of the device such as by using an administrator server or be set by any computing device different than the device onto which the application is to be installed . Examples of a source that is not the default authorized channel include a source that is not trusted not known or not authorized.

A source may be trusted for various reasons including for example that the source is an authorized Google Play store or Apple App Store. Other examples include a source identified by an administrator of mobile devices e.g. for a large corporation with thousands of employees for use by users in downloading new software. In another example a source may be trusted based on a prior history with that source e.g. extensive prior downloads without negative incidents . Also a source of prior copies of software may have been previously trusted but at the time of sourcing a particular software file or component the source is untrusted so that the software is considered as being side loaded.

Other examples of a side loaded application include an application obtained from a source that is not known and thus is untrusted for example because there is no prior history of interaction with the source or there is no independent confirmation or information that the source can be trusted. In another example when referring to Android apps an application is side loaded if it is installed using an application package in APK format onto an Android device after downloading the application package from a website other than Google Play. This side loading is possible if the user has allowed Unknown Sources in her security settings on her computing device this setting allows the installation of non market apps .

The embodiments set forth herein are implemented using a wide variety of different types of computing devices. As used herein examples of a computing device include but are not limited to a server a centralized computing platform a system of multiple computing processors and or components a mobile device a user terminal a vehicle a personal communications device a wearable digital device an electronic kiosk a general purpose computer an electronic document reader a tablet a laptop computer a smartphone a digital camera a residential domestic appliance a television or a digital music player.

As mentioned above an admin defines and deploys policies for an organization. In some embodiments the organization may be a family or other social group and the administrator role may be performed by a parent or guardian or may be performed by a third party service provider. Such a third party service provider may be a provider of security services or the network operator or a provider of content services. The additional levels of protection and control that organizations such as enterprises desire can also be advantageous for consumers but consumers are typically not knowledgeable enough to perform administrator roles. Thus there is often a need for third party service providers to act as technically oriented admins. The consumer or parent or guardian as an admin may specify preferences corresponding to high level policy decisions and a technical admin can configure underlying services to meet these high level policy decisions. As used in this disclosure the term administrator or admin includes but is not limited to all such administrators e.g. technical admin consumer parent guardian service provider etc. as described in this paragraph.

As mentioned above users of mobile devices install applications from numerous various sources that are beyond the control of an administrator. In some embodiments within a mobile network the network operator can perform various admin functions as described in this disclosure. Also the embodiments described herein are not limited to use solely in enterprise BYOD situations but are also useful for example in other cases such as where a consumer wishes to administer all devices for the members of her family or all of her personal devices e.g. phone watch laptop desktop computer etc. .

As used herein a component means a part of an application e.g. an application that is installed by a user from an Android or other software application marketplace and then executes on a mobile device . In one example a component is provided by the application s creator or by a third party. In another example the component may be code provided by an ad network or an analytics network.

In yet another example components are linked libraries SDKs that are packaged within an application. This is code that is within the application but the code is developed by a third party and provides the ability for an application developer to integrate certain behaviors of that component into the developer s application e.g. displaying a certain type of ads from a certain ad network such as LeadBolt . In another example a set of data e.g. in a file or a database that is used by an application may be considered as a component of that application. Also in some examples data used by an application can be considered as known or unknown or trusted or untrusted.

In one embodiment a component e.g. a component associated with an ad network may have multiple behaviors associated with it e.g. notification display settings changes and or information collection . For example the behaviors of the BTController application discussed further below is the summation of the behaviors of its constituent components. In some cases components may provide the ability to selectively opt out of individual behaviors. However in other cases this is not possible and in order to opt out of any set of behaviors a user must opt out of the entire component.

Various embodiments described below for side load protection relate to determining a source of software that is loaded on or otherwise transferred to a computing device. It is typically desired to determine the source in order to assess the risk of the software and make a determination or decision whether further action should be taken with respect to the software such as for example blocking installation of the software onto the computing device.

Sources of software e.g. software loaded by user onto her laptop computer or mobile device may include various numerous non limiting examples. For example sources may include various channels of distribution for software applications. These channels may include the Google play store or the Apple App Store other websites various file sharing or transfer servers peer to peer file sharing systems e.g. BitTorrent and other network or computer system transfer sources for software. In addition to the foregoing types of sources other sources include software accessed are installed locally such as by user inserting a USB memory drive into a computing device or pairing two mobile devices using a Bluetooth connection.

There are various ways that a source of an application can be determined. In one embodiment the source of an app on Android can be determined by calling getInstallerPackageName . In another embodiment a source of software may be for example the default and or normal channel for an operating system OS or other software such as defined by an administrator server that manages computing devices for an enterprise.

In various embodiments channels can be considered or deemed to be white listed or black listed. White listed channels are trusted and black listed channels are untrusted. For example applications from white listed channels are generally considered as being trusted software and applications from black listed channels are generally considered as being untrusted software.

The software itself that is side loaded includes various examples. For example the software may be an application a widget an executable file binary code firmware operating system components or updates and other forms of executable software. Examples further include other files such as office documents or PDF files that may contain components like scripts or macros which are themselves executable. In some cases such an embedded executable component may have associated with it identifiers or signing key information which can be used to separately determine the source of that executable component. An application itself may contain another application for example where an application for a mobile device which contains within it another related application which is intended for installation on a wearable or other personal or external device.

In various embodiments the source of side loaded software may be determined in various ways. For example channel identifiers channel IDs associated with an application may be compared to various white lists and black lists. In another example prior experience with the same or similar software on other computing devices may be used to make an assessment of the source of software being currently installed on a particular device. For example various components of a currently sourced software application can be identified and compared to components of software previously analyzed for prior installations made on other computing devices.

In another example characteristics e.g. a signing certificate or other signature of an application associated with the developer of the software may be used to determine the source. In another example the behavior of software either as installed on a mobile device or as determined by execution in a controlled environment may be used for making an identification of the source of the software. For example the behavior of software newly being installed may be the same or similar as prior known malware.

In various embodiments as each software application is assessed for making a determination of source a source identifier is associated with the software. The source identifier is used by a mobile device or other computing device on which the software is being installed. The mobile device can communicate with a side load server using the source identifier as a basis for side load protection activities as discussed below. An application identifier is also associated with the software for tracking data related to the application. In one embodiment an application identifier is an identifier used to identify a particular application. Examples of such identifiers include an application package name an application title and version or an arbitrary identification number binary or otherwise .

In some embodiments even a trusted source e.g. the Google Play Store may provide certain applications that are unauthorized or undesirable in at least one aspect. For example a banking enterprise may authorize obtaining of a banking application from a designated enterprise website e.g. a Bank of America website to which a user or a mobile device authenticates itself . An administrator of the enterprise desires that users download the banking application from this designated website which the administrator considers to be a trusted source. However a user might download the same or similar banking application from another source. This other source may be trusted for most applications. For example the Google Play Store may be considered by an administrator server to be a trusted source for most applications downloaded to a device.

However for the above particular banking application the enterprise administrator only considers the application to be obtained from a trusted source if that source is the designated website. Any banking application obtained from the Google Play Store is considered to have been obtained from an untrusted source.

A source such as previously identified and assigned to a source identifier from which an undesirable application has been obtained can be set to or marked as being untrusted either generally for all software obtained from that source or untrusted but only with respect to certain defined software . For the example of the banking application above the Google Play Store can be deemed to be untrusted source for this application.

In one embodiment side load server stores data that associates source identifiers with application identifiers of those applications for which the respective source is considered untrusted e.g. the banking application from the Google Play Store above . This stored data is used in later comparisons of source identifiers for new applications being installed on a computing device. The source identifier for a new application is compared to such previously associated source identifier application identifier records. If the new application is determined to be the same as or similar to the previous application e.g. a previous application obtained in an unauthorized manner from the Google Play Store than the new application is likewise considered to have been obtained from an untrusted source. For example the similarity of the new application to the previous application can be determined by component analysis as described herein. In one case a new same or similar banking application obtained from the Google Play Store has an application state or a state designation set to untrusted in response to this determination.

In various embodiments a mobile device on which an application is being installed stores state data. The state data includes a mobile device state and an application state for each application stored on or installed on the mobile device. The mobile device state may have values including trusted untrusted and unknown. The state of unknown indicates that a determination has not yet been made whether the mobile device is trusted or untrusted or that an event has occurred on the device which could require re assessment and could change the mobile device state. The application state may have values including trusted and untrusted. An application having a state of untrusted will for example not be executed.

Various embodiments described below also discuss state designations. A state designation is generally an indication by a computing device to be used by another computing device for setting a state. The state designation may have values of trusted and untrusted. The state may be the mobile device state or an application state. For example the mobile device may receive a state designation from a side load server and then set the mobile device state or alternatively an application state based on the state designation. An application identifier will be associated with the state designation in order to identify the applicable application.

In some cases the side load server communicates with an administrator server which itself may make determinations of state designations that are sent to the side load server. The side load server uses a state designation from the administrator server in order to make a decision at the side load server regarding a state designation to send to the mobile device. The state designations may be selected based on various factors including the source of software its source identifier component or behavior analysis of software etc. as discussed herein.

In various embodiments based on the mobile device state and or the application state various actions may be performed with respect to the mobile device. For example the mobile device may be denied access to a corporate network or an application may be disabled.

In some embodiments the source of the application may be determined during the process of assessing authenticity of the application as discussed herein. For example an application that is determined as not being authentic can have its source added to a blacklist.

In some embodiments an application can be monitored for fraudulent behavior. If fraudulent behavior is identified the source of the application can be added to a blacklist.

In some embodiments installation of an application onto a computer device can be monitored. The signature associated with the application or other characteristics of the signer of the application can be used to assess the source.

In some embodiments the manner of usage of an application on a computing device can be monitored. The usage or behavior of components of the application on the device that are inconsistent with a user or administrator designated policy can be identified. In such event the source and or the application can be deemed as untrusted.

There are various examples of policies that may be used on mobile or other computing devices. For example a user policy may define the handling of components and on mobile device . A policy may be defined by behavioral preferences established by a user and or an administrator and this policy is enforced on new applications installed on the mobile device. In another example a policy may apply to a particular identified application.

In other examples policies may be defined and applied to control or restrict the behavior of applications and their components. This can include the identification of advertising networks and defining policies to permit various opt out actions for these advertising networks.

In some embodiments a component analysis of an application can be used to relate components of a new application to a database of characteristics for known bad components. If the component in the new application corresponds to a known bad component the source of the software can be identified as untrusted.

In various embodiments side load protection services are used by an administrator of numerous mobile devices for example for a company having thousands of employees. Mobile device management software is executed on an administrator server that provides a console for the administrator. The console provides information to the administrator regarding source information and statistics for side loaded applications of managed devices. The administrator server communicates with the side load server as part of the side load protection services.

Additional examples of mobile devices include devices that are part of what is called the Internet of things IOT . In the internet of things there are multiple devices which operate on their own without accompanying and attendant users. Such devices may be mobile or sessile they may have various sensors and computing and communication capabilities and may run applications schematically they can be considered substantially similar to a mobile device. Such things may have occasional interactions with their owners or administrators who may monitor the things or modify settings on these things. Such owners or administrators play the role of users with respect to the thing devices. In some examples the primary mobile device of a user may be an administrator server with respect to a paired thing device that is worn by the user e.g. an Apple watch . In an embodiment a thing or a device e.g. one intended for use as a health or medical device may have an embedded white list defining trusted sources for applications or may have an administrator associated with that device e.g. an administrator working for the medical device manufacturer or distributor who can control the side loading policies for that device.

More specifically in the user terminals e.g. . . . and or mobile devices e.g. are used to access and or communicate with side load server application marketplace e.g. an Android or Google Play store or marketplace or an enterprise application store and or developer server over a communication network e.g. the Internet a wide area network a local network or other wired or wireless communications network .

Network may be used to download and remotely install applications selected from marketplace e.g. using Google Play or the Android Market . Marketplace may include one or more web servers or other types of data communication servers to communicate with the user terminals e.g. . . . and mobile devices .

Specifically mobile device may download a new application from application marketplace or developer server . An application obtained from developer server is signed using a signing certificate . New application has components and .

In an alternative embodiment an application or other software has been preloaded onto mobile device . In this case assessment of this application alone or assessment of this application along with a set of or all applications installed on mobile device can be performed. In one embodiment this preloaded application includes components that are assessed and handled such as described herein for new applications being installed on a mobile or other computing device.

Mobile device stores a user policy . The new application may be compared to user policy during or after installation. Side loaded server includes a data repository of user policies . User policy of mobile device may be compared to user policies . An administrator server not shown may provide some policies in user policies e.g. as regards usage of or installation of applications onto mobile device .

In one example an owner of an Android phone e.g. mobile device may visit a web site hosted by marketplace and select a free poker game application for remote installation on mobile device . The user may authenticate itself to marketplace by its email address e.g. Gmail address and password.

The marketplace is connected to respective data storage facilities to store applications messaging account data for users user preference data and other data. A messaging server not shown may be connected to communication network to deliver messages e.g. email or text to user terminals or one of a user s mobile devices .

In one embodiment a software server not shown may be coupled to communicate with application marketplace and or mobile devices by communication network . The software server stores for example an application e.g. the Ad Network Detector discussed below in memory. The application stored on the software server is sent to application marketplace where it is stored for later download and installation by a user. For example the user of mobile device may access marketplace to download and install the application. In another embodiment the software server is developer server or another computing device and may be used to upload an application to marketplace .

In one embodiment the software server communicates with the application now executing on mobile device after installation by the user . The application is configured to identify at least one behavior on mobile device as discussed herein. The at least one behavior is associated with each of a plurality of components of a plurality of other applications installed on the mobile device e.g. other applications previously downloaded by the user from the Google Play service and the at least one behavior includes a first behavior associated with a first component.

Side load server may receive at least one behavioral preference of the user e.g. from mobile device and or from an administrator of the mobile device . The at least one behavioral preference may be determined by the application based on input from the user e.g. a user selection from a menu or results list or the administrator.

The side load server stores the at least one behavioral preference e.g. stores in a memory of the server for later uses such as responding to queries from other computing devices regarding the intent of the user of mobile device . In one embodiment the Ad Network Detector discussed below may manage these behavioral preferences on behalf of a user for these networks.

Although not illustrated in the figures an identity server may be coupled to communication network . The identity server may communicate with for example side load server . For example side load server may obtain information from the identity server regarding one or more software components for a side loaded application being analyzed to determine its source.

In an alternative embodiment the identity server includes a database which stores component identities and optionally some or all of user policies . Mobile device may include applications that have been previously installed on mobile device . These applications may be installed from application marketplace or developer server .

The user policy is stored locally in a memory of mobile device . In one embodiment during operation as discussed in more detail below user policy may be used to define the handling of components and on mobile device .

In one embodiment a user policy for mobile device may alternatively or in addition to user policy be stored as one of user policies on the side load server and or the identity server. A user or administrator policy may be enforced on mobile device using either a local user policy or a remote user policy or a combination thereof.

As discussed in more detail below after an application is installed on mobile device components and may be identified and behaviors exhibited on mobile device may be attributed to one or more of components and . Any given component e.g. component may be present in several different applications on mobile device and or may be common to numerous copies or versions of an application that have been installed on mobile or other computing devices for large numbers of other users. In one embodiment this commonality of component presence permits observing and collecting structural and behavioral data associated with the component e.g. how the component behaves on other mobile devices . This known component data may be stored in a database not shown of side load server and the component data may be associated with a particular component identity. Thus a data repository of prior component data can be used to compare to data more recently obtained for new components such as those identified in newly installed applications on mobile device . The results of the component comparison can also be used when determining a source of an application.

More specifically as characteristics and behaviors associated with components on mobile device are identified and attributed these characteristics and behaviors may be compared with known characteristics and behaviors stored either locally on mobile device or stored remotely on the identity server which was discussed above as data associated with component identities these identities may also be associated with previously determined sources of the corresponding applications . The results from such comparisons in combination with determination of source and or mobile device state or application state may be used for making decisions regarding configuration and or disabling of one or more particular components on the mobile device or other computing device e.g. user terminal as discussed in greater detail below.

Although illustrates an exemplary system implemented in client server architecture embodiments of the disclosure can be implemented in various alternative architectures. For example the side load server may be implemented via a peer to peer network of user terminals in some embodiments where applications and data information from mobile devices are shared via peer to peer communication connections.

In some embodiments a combination of client server architecture and peer to peer architecture can be used in which one or more centralized servers may be used to provide some of the information and or services and the peer to peer network is used to provide other information and or services. Thus embodiments of the disclosure are not limited to a particular architecture.

An example of an application available for download from the Google Play Store is an application known as BTController . Some user reviews for this application have included complaints about excessive advertisements on the user s mobile device after installation. Thus this may be considered an undesirable application e.g. Google Play could be defined as untrusted with respect to this particular application . For example side load server can store a record associating a source identifier for the Google Play Store with an application identifier for this undesirable application. In response to a request from a mobile device requesting a state designation for a new application being installed on the mobile device that has been determined to be similar to this undesirable application side load server sends a state designation having a value of untrusted.

Administrator server and side load server communicate during side load protection using network . This communication includes sharing of data regarding applications associated with mobile device and the providing of state designations from administrator server to side load server . The provided state designations may be based on data repositories and analysis of an application and or its source as performed by administrator server .

Mobile device stores state data and mobile application data . State data includes a mobile device state and an application state for each of the applications installed or stored on mobile device . The mobile device state and the application state may be set based on communications received from side load server .

The mobile application data includes an application identifier for each application of mobile device and a source identifier for each such application. This source identifier identifies the source from which the application has been obtained. In one example this source is a channel identifier provided in a field of data for an application package downloaded from an application marketplace. In other cases the application does not contain any identification of source but a source is determined and assigned to the application based on analysis of the application or by observation of how an application file is provisioned to a computing device as described herein.

The application identifier and source identifier are received from mobile device for example in one or more messages. In reply to these messages side load server sends a message with one or more state designations for each application identifier. Side load server compares source identifiers from mobile device with source identifiers in white list and black list of source database . White list contains a list of source identifiers that have been previously determined to be trusted. Black list includes a list of source identifiers that have been previously determined to be untrusted.

In some cases side load server determines and sends state designations to mobile device without any interaction with administrator server . However in other cases side load server sends a message to administrator server providing an application identifier and source identifier along with the requests that administrator server determine a state designation.

Administrator server stores administrator application data which includes application identifiers and source identifiers received from side load server . Administrator server determines an administrator state designation for an application as was mentioned above. This administrator state designation is sent to side load server which uses the administrator state designation to set a state designation of the side load server for sending to mobile device . The state designation sent to mobile device may be different than the administrator state designation that was received by side load server .

Various non limiting embodiments for side load source assessment and protection are now described below. In one embodiment a non transitory computer readable storage medium stores computer readable instructions which when executed cause a first computing device to determine by the first computing device whether a first source identifier of a first application matches a white list of source identifiers determine whether the first source identifier matches a black list of source identifiers and send by the first computing device to a second computing device at least one message comprising the first source identifier and a first application identifier for the first application.

In one embodiment the determining whether the first source identifier matches the black list is performed in response to the first source identifier not matching the white list. In one embodiment the determining whether the first source identifier matches the white list is performed in response to the first source identifier not matching the black list. In one embodiment the determining whether the first source identifier matches the white list is performed simultaneously with the determining whether the first source identifier matches the black list.

In one embodiment the computer readable instructions further cause the first computing device to in response to the first source identifier matching the black list set a device state of the first computing device to untrusted and send the at least one message to the second computing device the at least one message further comprising the device state. The computer readable instructions may further cause the first computing device to store the device state wherein the device state can be set to values including trusted and untrusted.

In one embodiment the computer readable instructions further cause the first computing device to in response to the first source identifier not matching the black list set a first application state for the first application to unknown and send the at least one message to the second computing device the at least one message further comprising the first application state. The computer readable instructions may further cause the first computing device to store data for a plurality of applications the data comprising an application state and a source identifier for each of the applications wherein each application state can be set to values including known and unknown.

In one embodiment the computer readable instructions further cause the first computing device to receive a message from the second computing device the message comprising a first state designation for the first application. In one embodiment the computer readable instructions further cause the first computing device to set the device state to the first state designation. In one embodiment the device state is set to the first state designation only if a device state of the first computing device is not set to untrusted.

In one embodiment the computer readable instructions further cause the first computing device to prior to determining whether the first source identifier matches the white list receive the white list from the second computing device. In one embodiment the first computing device is a vehicle a personal communications device a wearable digital device an electronic kiosk a general purpose computer an electronic document reader a tablet a laptop computer a smartphone a digital camera a residential domestic appliance a television a digital music player or a computing device that is embedded in a vehicle or other piece of machinery.

In one embodiment a method includes storing by a first computing device data for a plurality of applications associated with a second computing device the data comprising a state designation for each of the applications wherein the state designation can be set to values including trusted and untrusted receiving by the first computing device from the second computing device a first application identifier and a first source identifier each for a first application setting by the first computing device a first state designation for the first application wherein the first state designation is to be used for setting a state on the second computing device and sending by the first computing device the first state designation to the second computing device. The state to be set may be a device state or an application state for an application stored on the second computing device.

In one embodiment the setting the first state designation comprises sending by the first computing device over a network the first application identifier and the first source identifier to a third computing device receiving from the third computing device a second state designation for the first application and setting the first state designation based on the second state designation.

In one embodiment the setting the first state designation comprises determining whether the first source identifier matches a white list of source identifiers and in response to the first source identifier matching the white list setting the first state designation to trusted.

In one embodiment the setting the first state designation comprises determining whether the first source identifier matches a white list of source identifiers and in response to the first source identifier not matching the white list determining whether the first source identifier matches a black list of source identifiers.

In one embodiment the setting the first state designation further comprises in response to the first source identifier matching the black list setting the first state designation to untrusted. In one embodiment the setting the first state designation further comprises in response to the first source identifier not matching the black list sending the first application identifier and the first source identifier to a third computing device and setting the first state designation based on a second state designation received from the third computing device. In one embodiment the method further comprises updating the black list based on the second state designation.

In one embodiment a system includes at least one processor and memory storing instructions configured to instruct the at least one processor to receive from a first computing device a first application identifier and a first source identifier each for a first application of the first computing device determine whether the first source identifier matches a white list of source identifiers and determine whether the first source identifier matches a black list of source identifiers send the first application identifier and the first source identifier over a network to a second computing device receive from the second computing device a first state designation for the first application set a second state designation based on the first state designation and send the second state designation to the first computing device.

In one embodiment the determining whether the first source identifier matches the black list is performed in response to the first source identifier not matching the white list. In one embodiment the sending the first application identifier and the first source identifier to the second computing device is performed in response to the first source identifier not matching the black list. In one embodiment the instructions are further configured to instruct the at least one processor to update the white list based on the first state designation.

In one embodiment the system further comprises a database storing data for a plurality of applications associated with the first computing device the data comprising a source identifier and a state designation for each of the applications wherein each state designation can be set to values including trusted and untrusted.

In one embodiment the first source identifier is based on a signature of the first application. In one embodiment the instructions are further configured to instruct the at least one processor to receive a trusted source identifier from the second computing device and update the white list based on the trusted source identifier. In one embodiment the instructions are further configured to instruct the at least one processor to receive a trusted source identifier from the second computing device and update the black list based on the trusted source identifier.

Authenticity server includes a database which stores component data and a repository . Repository contains package identifiers and signing identifiers for applications being installed on mobile device . Various embodiments relating to authenticity server are discussed in greater detail below.

In computing device includes an inter connect e.g. bus and system core logic which interconnects a microprocessor s and memory . The microprocessor is coupled to cache memory in the example of .

The inter connect interconnects the microprocessor s and the memory together and also interconnects them to a display controller and display device and to peripheral devices such as input output I O devices through an input output controller s . Typical I O devices include mice keyboards modems network interfaces printers scanners video cameras and other devices which are well known in the art.

The inter connect may include one or more buses connected to one another through various bridges controllers and or adapters. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals and or an IEEE 1394 bus adapter for controlling IEEE 1394 peripherals.

The memory may include ROM Read Only Memory and volatile RAM Random Access Memory and non volatile memory such as hard drive flash memory etc.

Volatile RAM is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory. Non volatile memory is typically a magnetic hard drive a magnetic optical drive or an optical drive e.g. a DVD RAM or other type of memory system which maintains data even after power is removed from the system. The non volatile memory may also be a random access memory.

The non volatile memory can be a local device coupled directly to the rest of the components in the computing device. A non volatile memory that is remote from the computing device such as a network storage device coupled to the computing device through a network interface such as a modem or Ethernet interface can also be used.

In one embodiment a computing device as illustrated in is used to implement side load server application marketplace developer server administrator server and or other servers.

In another embodiment a computing device as illustrated in is used to implement a user terminal or a mobile device on which an application is installed or being installed. A user terminal may be in the form for example of a notebook computer or a personal desktop computer.

In some embodiments one or more servers can be replaced with the service of a peer to peer network of a plurality of data processing systems or a network of distributed computing systems. The peer to peer network or a distributed computing system can be collectively viewed as a computing device.

Embodiments of the disclosure can be implemented via the microprocessor s and or the memory . For example the functionalities described can be partially implemented via hardware logic in the microprocessor s and partially using the instructions stored in the memory . Some embodiments are implemented using the microprocessor s without additional instructions stored in the memory . Some embodiments are implemented using the instructions stored in the memory for execution by one or more general purpose microprocessor s . Thus the disclosure is not limited to a specific configuration of hardware and or software.

In the position identification unit is used to identify a geographic location. The position identification unit may include a satellite positioning system receiver such as a Global Positioning System GPS receiver to automatically identify the current position of the computing device.

In the communication device is configured to communicate with a server to provide data including application data e.g. an application identifier and a source identifier for a newly sourced application . In one embodiment the user input device is configured to receive or generate user data or content. The user input device may include a text input device a still image camera a video camera and or a sound recorder etc.

Various non limiting embodiments and examples related to side load protection and or determination of a source of side loaded software are now discussed below. The embodiments and examples of this section i.e. Side Load Protection Variations do not limit the generality of the foregoing discussion.

In a first embodiment an application has been installed or in other cases will be or is planned to be installed on a mobile device e.g. mobile device and a determination is made whether the source of the application is from an untrusted channel. For example for an application on an Android mobile device the application has been obtained from a source other than the Google Play Store.

Various use cases 1.1 1.6 are described below pseudocode is used in portions of the discussion below for ease of explanation . These use cases relate to various situations in which one or more applications sometimes referred to simply as an app are to be installed on are already installed on or otherwise interact with or are intended for use on or with a mobile device. These applications may be tested in various ways as described below. In particular use cases 1.5 1.6 relate to allowing or disallowing a side loaded application. In some cases this allowing or disallowing may relate to permitting or preventing installation of the application or execution of an application that has already been installed. The Server and or server mentioned in the use cases below can be for example side load server .

Various acronyms and terms used in the use cases below have the following meanings with possible values indicated for some terms 

In one variation the order for the above as regards at the mobile device is that the channel IDs are sent to the mobile device and then at the device the channel IDs associated with the app are tested against a previously received list of good bad channel IDs e.g. white list and black list of .

Regarding the above at the server a channel ID associated with an individual app is sent from MCD to the server where it is tested.

In one example if the App State of the app on the MCD is unknown which will be the case if the app is not from Google Play or an Amazon store these are the only app stores currently filling out the value retrieved by the Android getInstallerPackageName method then an identifier can be sent for the app e.g. package name or hash of the app to the server e.g. side load server which may have other information about the origin and channel ID of the app and the app identifier is used at the server to determine whether the app should be trusted or not.

In the case in which the channel ID is determined by monitoring file system or network activity somewhere else e.g. on this particular mobile device or on a different device for the same app e.g. having the same application identifier or on a server e.g. in a VM or emulator monitoring behavior of the application then a channel ID could be available at the server and thus sending an app identifier to the server can resolve the appropriate channel ID and the designation of it as trusted or untrusted.

Also there is an optional variation in which the app may have been delivered by a good channel ID but the app is no longer available from that good channel e.g. it has been pulled by the operator of that channel or the version of the app being analyzed has been replaced by a newer version of the app e.g. an update or a vulnerability fix in either case the app may be considered as having an App State of untrusted or in an alternative approach as having a state of out of date .

In yet other variations of the above a previously GOOD channel ID is now known or determined to be BAD e.g. by side load server or admin server and a re evaluation of apps from that channel is performed.

In another variation a previously BAD channel ID is now known to be GOOD and a re evaluation of apps from that channel is performed.

In another variation a previously UNKNOWN channel ID is now known to be GOOD or BAD and a re evaluation of apps from that channel is performed.

In another variation an app from a channel ID previously considered to be GOOD has been determined to be undesirable e.g. due to malware discovered in the channel or for other behavioral reasons and as a result the designation of that channel ID as GOOD is changed to BAD or UNKNOWN.

Use case 1.4 Testing all apps on the mobile device white listed channels but no black listed channels 

Use case 1.5 Allowing disallowing a single side loaded app white listed channels and white listed app authors 

In one variation of the above the app has not been installed yet and the MCD is downloading the app in order to do the next step of Retrieve the channel ID via the getInstallerPackageName method the app is first installed. In an alternative approach this processing is done before the installation proceeds e.g. because the download is intercepted to determine a channel ID or because there is logic in the InstallerPackage that is will determine a channel ID .

In one variation the actions taken above are to set App State being allowed disallowed means if allowed then permitting installation to proceed and if disallowed then either uninstalling the app if it has already been installed or blocking the app from executing if the app has already been installed. In an embodiment the signed application installation package contains a directive that the application is only intended for distribution from one or more specific channels and if the application has been provided via a channel that was not listed then the application will not be installed.

Various different situations associated with the above use cases may exist. In some cases a channel is white for all apps or black for all apps or sometimes an admin e.g. admin server may configure a more complicated combination. For example a particular channel ID may be predominantly GOOD e.g. Google Play Store but there may be certain known BAD apps available from that channel. In this case the channel ID has a default designation as GOOD but there is a black list for that channel of specific apps known to be BAD and this channel specific list is also consulted during any decision processes e.g. by the admin server and or the side load server .

In another example an enterprise e.g. admin server may not only store a list of GOOD channel IDs but may also choose to have a channel specific list of white listed apps which are the only ones from that channel that are to be allowed as trusted. An example of this is that only enterprise approved apps are allowed from that channel and not any other channels.

Another variation involves there being multiple destinations or install locations on a single mobile or other computing device. Specifically each container on a mobile device can represent a separate install location e.g. the personal container and the work container as with the Google at Work product or other container solutions like those available from Good Technology. In this case the designation of a channel as GOOD or BAD depends on the install location for the app that is in one case the only GOOD channel ID for the Work container on the device is the enterprise version of the Google Play app store the general consumer version of the Google Play app store is not considered as a GOOD channel ID for the Work container. This variation may apply for example to any of the use cases above.

In some cases an app appears to be available from both trusted and untrusted channels e.g. the app is determined to be the same app based on a hash of each app . In these cases if the app is identical to the app that is available from the trusted channel then the app state is set to trusted otherwise it is set to untrusted. Also side load server may or may not know where the actual app installed on the device was sourced from e.g. whether from the trusted channel or the untrusted channel . Thus the side load server may choose to determine that the app is untrusted or unknown because the actual source of the app is not known.

Some embodiments relate to wearable apps. These are apps which run on a wearable device e.g. Android Wear but these apps are packaged inside a handheld app because users cannot browse and install apps directly on the wearable itself. If packaged properly when users download the handheld app a system automatically pushes the wearable app to the paired wearable. For example see https developer.android.com training wearables apps packaging.html Also see https developer.android.com training building wearables.html

There are cases of wearable apps being packaged inside the APK for the handheld device for subsequent installation onto a wearable device. With respect to detection of malware or determination of whether the app is undesired the wearable app may be scanned using a whitelist or a blacklist or a decision component. Also there are cases in which wearable apps do not run on the mobile device but instead run on a paired or connected wearable and which are provisioned via a connection through the mobile device. Here the source identifier for the embedded wearable app consists of the source identifier of the containing app plus the fact that the wearable app was contained within that wearable app. The side load protection system may distinguish between the containing app for installation or running on the mobile device and the embedded app for installation or running on the wearable device e.g. one may be allowed while the other may not the decisions of the system can be independent of each other for these two apps and devices.

In one example for an app that was preloaded on the device the result from getInstallerPackageName can be null. If this value returned cannot be used to distinguish pre loaded from non pre loaded apps the system can determine by other attributes if the app had originally been pre loaded e.g. such as if the app is installed in location system app or system priv app Android 4.4 or greater .

In another example an app s install channel is detected on the device or is detected in a piece of code that operates somewhere in the network path from the install download network source to the device e.g. in a network appliance router firewall etc. . For example by observing that an application is being downloaded to the device from a particular network location a channel ID can be determined for that application as being an identifier for the source of the download e.g. a network IP address or domain name or URL or other network identifier. In such a variation the system may choose to not allow a network connection to a network location known to be a source of bad channel IDs for applications based on user preference user policy or enterprise policy e.g. as set by the admin server or may choose to not allow an application to be downloaded from such a network source other communications with this network source might be allowed .

In various cases one detects a trusted untrusted channel BEFORE the install DURING the install or AFTER the install. The URL http developer.android.com reference android content pm PackageInfo.html describes the PackageInfo class on Android. This may be obtained from the getInstallerPackageName String packageName method in the PackageManager class. See http developer.android.com reference android content pm PackageManager.html getInstallerPackageName java.lang.String 

This stackoverflow article http stackoverflow.com questions 13289748 can packagemanager getinstallerpackagename tell me that my app was installed f says that 

If the source of the information of channel ID is calling getInstallerPackageName then there will typically be a non null answer only for Google Play or the Amazon store or the Samsung store. A null value means an unknown channel ID and thus is determined at least initially to be an untrusted channel ID. If the actual source of the app can be determined as the network location or URL used to download the app than that network location is the source ID or channel ID for the application.

In another embodiment enterprise resources are protected when an application on a mobile device associated with the enterprise has been determined to have an application installed from an untrusted channel. In one example a use case 2.1 relates to applying an enterprise policy in many variations .

In another embodiment trust is restored between an enterprise admin server and a mobile device that hosts an app that was installed from an untrusted channel. In one example a use case 3.1 relates to managed restoration of suspended functionality.

In another embodiment a determination is made as to whether any high risk activities occurred while a mobile device was in an untrusted state due to a side loaded application. In one example a use case 4.1 relates to an access usage log and report.

In one variation of the above data has been sent that should not have been sent and the amount of data and or the frequency of such activity was unusual or inappropriate. The actual data that is sent is captured or inspected or received . When inspecting such data the administrator is notified of the findings.

In another embodiment a population is managed in which the population includes mobile devices associated with an enterprise. The mobile devices have multiple diverse apps installed from multiple diverse channels and some of those apps are determined to be side loaded apps e.g. determined using side load server . In one example a use case 5.1 relates to comparing a population of interest with a control population.

In another embodiment a determination is made of the channel or other source for an application. In one example a use case 6.1 relates to a value obtained from an operating system OS for determining a channel ID if the ID is available. If a channel ID is not available a channel is determined from network and or file system activity by monitoring file system changes.

In another example a use case 6.2 relates to determining a channel ID by monitoring network activity.

In one embodiment previous behavior associated with a side loaded app on another phone is used to predict the same behavior based on the early indications on the subject phone.

In other embodiments side loaded apps are identified in various ways. In one embodiment an origin of the app is identified and a determination is made e.g. by side load server whether the app is still available in the version that is currently being assessed e.g. when being considered for installation on mobile device .

For origin detection some things can be done in advance for applications that are still available a server checks corpus or a known App Store to see if the app still available there or if a more recent version of the same app e.g. as determined by similarity analysis as discussed herein is now available or if the version currently being analyzed is no longer available.

In some embodiments regarding origin detection when a channel ID is not otherwise obtainable a system may determine a source or channel ID by observing activity in a device s network connections or browser activity or file system operations. E.g. code that executes within a browser such as a browser extension or plugin or a built in browser function or code that is observing the browser s activity e.g. via monitoring of Android intents or IOS protocol handlers or via a network intercept on a device such as for example a network shim or adapter or VPN or in a network appliance . Such code can detect that an app e.g. an .apk or .ipa or other app packaging file format is being downloaded e.g. looking at a URL for source or looking at HTTP header Content type e.g. application vnd.android.package archive for an Android APK or application octet stream for an iOS IPA file or seeing how the file name is represented in headers if present to see that a .apk or .ipa application file type is being downloaded . An app whose download is detected in this manner can be determined to be from a source or channel ID of the network location or URL used for the download.

In one embodiment it may be detected whether an app download is via a client pull request or a web App Store push request or an MDM app push request.

In one embodiment an app has the same hash as a version from a known source but is not delivered via that source. For example an app is delivered via USB or Bluetooth BT or another peripheral form of communication e.g. an Android USB ADB interface . Or an app is or was delivered by some other app e.g. a third party App Store app .

In one embodiment regarding post installation detection for an application a server or other computing device determines a source of the application by visiting going to a plurality of well known app stores and seeing if an app with the same hash is available for download there e.g. this can include an enterprise App Store or an MDM controlled store . Alternatively one can use a cache of such info obtained previously from these source s e.g. at a security company server and determine that i an app with this hash is available there now or ii an app with this hash is not available there now but was available there in the past and or iii a newer version of the app e.g. as determined by component analysis and or similarity analysis as described herein is now available there. Also in some cases the same app can have been available from multiple sources.

In one embodiment for reports to administrators or other enterprise reports it is determined whether this app is present on any other devices for the enterprise e.g. mobile devices managed by admin server plus numbers of devices and or details of device activity including present and or historical. The prevalence of this app on any worldwide devices may be determined including details of app or history or statistics of usage or behavior and optionally determination of the prevalence among other enterprises devices anonymized with optional classification of enterprise size and IR type e.g. SAIC Code .

In one embodiment high confidence e.g. confidence determined to be above a threshold findings can be reported to an admin server including support for a correlation of the app presence with any of network endpoints visited other apps present on the mobile device or any other metadata related to device or networks connected to the mobile device or user or other metadata. Also a server can track the origin as to what network s device the mobile device was connected to at the time of download or the specific computing device network through which the download to the mobile device was made.

In some cases an app is preloaded on a device. It can be determined whether the app has been updated since the preload time e.g. updated by an automatic update and or a user initiated update and or whether a firmware flash or OTA OS UPDATE has occurred.

In one variation an indication is put inside the app e.g. inserted by the developer such as by a developer server into or with the code of the application of an intended channel for delivery. The app should not show up with a different channel ID having been determined after analysis e.g. by side load server . Otherwise the app is considered to be from a bad source or untrusted.

In one embodiment a change in the assessment of an app e.g. as being benign or malware or other may trigger a change in the assessment of a channel e.g. the channel through which the app was distributed . For example if a channel had been hitherto determined to be unknown vs. trusted or untrusted then the channel assessment may be altered to trusted or untrusted.

As described in more detail below a user may express an intent as to how the user desires its computing device e.g. mobile device to behave. The intent may be explicitly provided by the user or may be otherwise determined e.g. by reference to a database on a remote server . In one embodiment the user s intent defines how the user wants to control receiving of certain types of messages e.g. advertisements . The type of control desired by the user in its various forms of experience on a computing device e.g. a mobile device is expressed in the user s intent. This intent may be used to determine various behaviors of the computing device. For example some undesired behaviors may be stopped by disabling various components of one or more applications that have been previously installed on the user s mobile device.

In one embodiment the system of may be used for control of behavior on computing devices or for analysis of software components each as described herein in which user terminals and mobile devices or other computing devices communicate with a messaging server and or application marketplace or with an identity server not shown some examples of the identity server were discussed above according to various embodiments as described below. In the user terminals e.g. . . . and or mobile devices are used to access and or communicate with side load server an identity server not shown application marketplace e.g. an Android or Google Play marketplace and or a messaging server e.g. an email server not shown over communication network .

A server e.g. side load server or administrator server receives at least one behavioral preference of the user from mobile device and the at least one behavioral preference is determined by the application based on input from the user. The server stores the at least one behavioral preference for later uses such as responding to queries from other computing devices regarding the intent of the user of mobile device . In one embodiment the server is independently maintained by each of many ad networks. The Ad Network Detector as discussed herein may manage these behavioral preferences on behalf of a user for these networks. In an alternative embodiment an identity server e.g. such as was discussed above includes a database which stores component identities and user policies.

In one embodiment an application referred to herein as Ad Network Detector may be downloaded from the Google Play service onto a user s mobile device . The expressing of user intent and control of behavior for mobile device as described below may be incorporated into or otherwise work in conjunction with the Ad Network Detector application.

The Ad Network Detector application scans a user s phone or tablet for the presence of ad networks used in mobile apps giving the user information about what types of ads can be displayed and what information is gathered by the ad networks. With access to this information the user is able to decide whether to keep the application that has a particular ad network on the user s phone.

Mobile device e.g. smartphone or tablet usage has increased dramatically and some advertisers have begun to experiment with aggressive new techniques to display ads on mobile devices. These techniques include pushing ads to the standard Android notification bar dropping generically designed icons on the mobile desktop and modifying browser settings like bookmarks or the default homepage. Because each of these techniques can display an advertisement outside the context of a specific application it s difficult for users to know exactly which app is responsible for any given ad. The Ad Network Detector application provides a method for users to determine which ad network and application are the source for such ads.

Some ad networks also collect information that identifies a specific device or user for use in targeted marketing campaigns. Much like for browser based ads this practice allows users to see more personalized or relevant ads. It is sometimes difficult for a user to know what aspects of the user s information are collected by ad networks. The capabilities and information collection methods specific to each ad network may be determined from investigation. The Ad Network Detector application informs the user what data is being collected and by which ad network application.

In this embodiment the Ad Network Detector application provides information to the user to about practices supporting mobile advertising. The application may detect many ad networks. Some of the ad networks detected may include the following examples 

Regarding ad network capabilities and privacy in this embodiment the capabilities and information collection methods specific to each ad network may be investigated. Based on this investigation the Ad Network Detector application details what identifying information is collected by each ad network and how it is collected. This may include personal information directly linkable to an individual user such as an email address and device and network information that is specific to an individual device or network rather than to the user.

In one embodiment a screen is presented by an installed application e.g. the Ad Network Detector application after installation from application marketplace to a user on a display of mobile device . In this embodiment a user expresses his or her intent to control behavior of application components on mobile device .

In one example a BTController application has previously been installed on the mobile device by the user among numerous other user installed applications. The BTController includes an advertisement network component having several behaviors. A first behavior is the display of advertisements in the notification bar of mobile device .

In this embodiment the components of each application e.g. BTController previously installed on mobile device are determined e.g. determined by an application or another tool installed on the mobile device for that purpose . For example a scan to determine these components may be initiated by the user by her clicking on or touching a start scan button of a user interface.

An example of a component to be identified is the Lead Bolt advertising network included in the BTController application. In addition at least one behavior e.g. displaying of ads in the notification bar associated with each of the components for an installed application is identified.

The identified behaviors are presented to the user e.g. in a list of scan results . At least one behavioral preference expressing the intent of the user is determined e.g. a desire of the user to opt out of a particular behavior . This intent is then implemented on the mobile device by reconfiguring the identified components of various applications on the mobile device as necessary to conform to the user s expressed intent.

In one embodiment a status display presented to the user by the installed application that indicates the status of analyzing applications on the mobile device i.e. other applications that are installed on the mobile device to identify their respective components according to one embodiment. An extent of progress of the analysis or scan is indicated by a bar.

In one embodiment a set of results is presented to the user from the analyzing of the applications on the mobile device . The results include a list of behaviors identified. For example one behavior is the display of ads in the notification bar of the mobile device. The number of applications identified that include a component exhibiting the listed behavior is indicated in vertical arrangement or column.

For example only one application was identified that includes a component exhibiting this behavior. Two applications were identified that include a component exhibiting a different behavior. In contrast zero applications were identified including a component that exhibits yet another behavior. It should be noted that the count in this implementation refers to the number of components that exhibit a particular behavior. This count or an additional count in other implementations could reflect the number of applications that exhibit the behavior. Any given component may be present in several different applications so these two counts are not necessarily equal.

In one embodiment a screen presents information about an advertisement network LeadBolt incorporated in an application BTController installed on mobile device . The screen includes a description of the behavior associated with the application.

In one embodiment a screen presents an opt out button for the user to opt out of the advertisement network. The screen includes a description describing an opt out option for the advertisement network. The user expresses her intent by clicking on or touching e.g. on a touch screen opt out button.

In one embodiment the user s intent may be stored locally in a memory of mobile device . Alternatively this intent may be stored remotely on a different computing device such as a server e.g. a server operated by the software developer of the Ad Network Detector discussed above accessible via communication network . This server may also be accessible by third party application developers in order to conform behaviors to intents previously expressed by respective users. In another embodiment this server is operated by the owner of the component.

Various other embodiments are now described below. In a first embodiment a computer readable storage medium stores computer readable instructions e.g. instructions of an Ad Network Detector which when executed cause a computing device e.g. a mobile device of a user to for an application installed on the mobile device of the user determine components of the application identify via at least one processor of the mobile device at least one behavior associated with each of the components including a first behavior e.g. ad display in a notification bar associated with a first component present results from the identifying to the user the results to include a list of behaviors including the first behavior and receive a selection from the user of at least one behavioral preference. Further information regarding determining the components of an application is discussed in greater detail below in the section titled Analyzing Components of an Application .

In one embodiment the at least one behavioral preference is selected from the group consisting of opting out of the first behavior opting out of one or more of the components including the first component a set of user preferences for specifically identified behaviors and a policy. In one embodiment the at least one behavioral preference is a policy and the policy is enforced on new applications installed on the mobile device. In one embodiment the first component enables the user to selectively opt out of individual behaviors of the first component.

In one embodiment the selection from the user of at least one behavioral preference is to opt out of the first behavior and the instructions further cause after the opting out running the first component to determine whether the first behavior is active. In one embodiment the determining whether the first behavior is active comprises at least one activity selected from the group consisting of running the first component in an emulated environment on a different computing device e.g. a developer server and monitoring behavior on the mobile device after receiving the selection from the user.

In one embodiment the selection from the user of at least one behavioral preference is to opt out of the first behavior and the instructions further cause after the opting out determining a status of the opting out using an application programming interface of the first component. In one embodiment the instructions further cause the mobile device to in response to the selection from the user reconfigure execution of the first component so that the first behavior no longer occurs on the mobile device.

In one embodiment the instructions further cause in response to the selection from the user uninstalling the application from the mobile computing device. In one embodiment the instructions further cause in response to the selection from the user disabling further execution of the first component on the mobile device. In one embodiment the first component is shared by the application and an additional application and the disabling affects both the application and the additional application.

In one embodiment the first behavior is a presentation of messages to the user. In one embodiment the messages include at least one advertisement presented in a notification area of the mobile device. In one embodiment the presentation of messages is outside of a context of the application presented to the user during normal operation of the application. In one embodiment the first component is a part of the application.

In one embodiment the instructions further cause displaying opt out options to the user wherein the opt out options are solely for applications already installed on the mobile device. In one embodiment the instructions further cause displaying opt out options to the user the opt out options comprising all possible opt out flows for the user on the mobile device as determined from a database. In one embodiment the first component is a linked library packaged with the application prior to installation of the application on the mobile device.

In one embodiment the mobile device is for example a tablet device or an Android phone device. In one embodiment the first component is a portion of the executable code of the application and the executable code enables the application to interact with an advertising network or an analytics network. In one embodiment interaction with the advertising network comprises display of advertisements provided from the advertising network.

In one embodiment a non transitory computer readable storage medium stores computer readable instructions which when executed cause a computing device to for an application installed on a computing device of a user determine components of the application identify via at least one processor at least one behavior associated with each of the components including a first behavior associated with a first component and determine at least one behavioral preference of the user.

In one embodiment the instructions further cause storing the at least one behavioral preference on the computing device so that the application can locally determine the at least one behavioral preference. In one embodiment the instructions further cause the first component to evaluate the at least on behavioral preference to determine how the first component is to behave on the computing device.

In one embodiment the instructions further cause storing the at least one behavioral preference on a different computing device so that an advertisement network associated with the first component can query the different computing device e.g. a developer server in order to determine the at least one behavioral preference of the user. In one embodiment the instructions further cause the first component to execute in conformance with results from the query of the different computing device wherein the query includes a user identifier of the user.

In one embodiment the instructions further cause in response to downloading or installing the application scanning the application to confirm compliance with the at least one behavioral preference of the user and if the application violates the at least one behavioral preference alerting the user of the violation or blocking installation of the application.

In one embodiment a system comprises a display at least one processor and memory storing instructions configured to instruct the at least one processor to determine components of an installed application identify at least one behavior associated with each of the components including a first behavior associated with a first component present on the display at least one component of the installed application for which a user can opt out and receive a selection from the user of an opt out for a first component of the at least one component.

In one embodiment the instructions are further configured to instruct the at least one processor to present an opt out status to the user for components for which the user has previously opted out.

In one embodiment a method includes for an application installed on a computing device of a user determining components of the application identifying via at least one processor of the computing device at least one behavior associated with each of the components including a first behavior associated with a first component presenting on a display of the computing device results from the identifying to the user the results to include a list of behaviors including the first behavior and receiving via a user interface of the computing device a selection from the user of at least one behavioral preference.

In one embodiment a method includes storing in a memory e.g. a memory of the developer server a first application e.g. the Ad Network Detector application comprising computer readable instructions which when executed cause a mobile device of a user to determine components of a second application e.g. BTController application installed on the mobile device identify at least one behavior associated with each of the components including a first behavior associated with a first component e.g. LeadBolt component and determine at least one behavioral preference of the user and sending via at least one processor e.g. microprocessor s of the developer server over a communication network the first application for storage in a data processing system e.g. application marketplace for subsequent installation from the data processing system onto the mobile device.

In one embodiment the method further comprises communicating via the at least one processor with the first application after installation of the first application on the mobile device. In one embodiment the data processing system comprises an application marketplace. In one embodiment a network operator e.g. Verizon or AT T controls the data processing system and the mobile device is configured to operate with a cellular network operated by the network operator.

In one embodiment a system e.g. a developer server comprises at least one processor and memory storing a first application which when executed on a mobile device of a user causes the mobile device to determine components of a second application installed on the mobile device identify at least one behavior associated with each of the components including a first behavior associated with a first component and determine at least one behavioral preference of the user and the memory further storing instructions configured to instruct the at least one processor to send the first application to a data processing system e.g. application marketplace so that the first application can be later installed over a communication network on the mobile device from the data processing system.

In one embodiment the instructions are further configured to instruct the at least one processor to communicate with the first application after installation of the first application on the mobile device.

In one embodiment a method includes communicating via at least one processor e.g. a processor of a software server with an application e.g. the Ad Network Detector application executing on a mobile device of a user the application identifying at least one behavior on the mobile device the at least one behavior associated with each of a plurality of components of a plurality of other applications installed on the mobile device and the at least one behavior including a first behavior associated with a first component receiving at least one behavioral preference of the user from the mobile device the at least one behavioral preference determined by the application based on input from the user and storing in a memory e.g. storing in a database distributed among multiple database servers the at least one behavioral preference.

In one embodiment the method further comprises storing the at least one behavior. In one embodiment the method further comprises receiving a query from an advertisement network associated with the first component the query requesting the at least one behavioral preference of the user. In one embodiment the method further comprises receiving from the mobile device an identification of the first component and running via the at least one processor the first component in an emulated environment to determine whether the first behavior is active.

In one embodiment the method further comprises receiving a query regarding the at least one behavioral preference in order to determine conformance of a new application with the at least one behavioral preference. In one embodiment the method further comprises providing information in response to a request received over a communication network in order to evaluate the at least one behavioral preference and determine how the first component is to behave on the mobile device.

Additional exemplary non limiting details regarding various implementations of the above embodiments are now described here below. In one example a user may opt out of specific components e.g. as determined using the approaches described herein . The user is presented a list of components that the user can opt out of. The user may perform opt out actions or these may be done automatically upon user request or selection. Then the user may see e.g. on a display of a mobile device a status indication that the user has opted out of identified components.

In one embodiment there are various types of opt out options. For example a user may opt out entirely of a component opt out of particular behaviors of a component opt in entirely to a component opt in to particular behaviors of a component purge some or all data collected by a component reset an identifier used to identify the user or device to a component or otherwise modify the component s behavior on the device or the data transferred to or from the component on the device.

In one embodiment opt out options may be displayed to a user e.g. on a display of a mobile device using various approaches. In a first approach this is done by detecting which components are present in installed applications on a mobile device and then only displaying opt out flows for the applications are installed on the mobile device. In a second approach input is received from a user as to which behaviors the user wishes to opt out of. In a third approach all possible opt out flows as determined from a database are presented to the user.

In one embodiment a user selects a degree of functionality within a range from minimum optional functionality to maximum optional functionality and a mobile device automatically translates that into actions to opt in and or out of automatically selected behaviors.

In one embodiment a status for opt out may be determined in various ways. A first way uses an API provided by the vendor or developer of the component to determine the opt out status. A second way determines whether behavior is still active by running the corresponding component e.g. in an emulated environment on a server or by monitoring behavior on the user s mobile device .

In one embodiment a user declares preferences for specific behaviors desired on the user s mobile device. The components themselves evaluate these declared preferences in order to determine how the components should behave on the user s mobile device.

For example the user may set its preferences and then these preferences are stored locally or on a remote server e.g. a developer server . A component queries these preferences e.g. by sending a query in order to determine how the component should behave or is required to behave by the mobile device or another computing device .

In one embodiment various types of preferences that can be set by the user relate to the following location collection for targeted ads notifications in a notification area of the user s device planting of bookmarks or icons on a device and app tracking used to deliver targeted ads e.g. related to determining what apps a user has installed .

In one embodiment various methods may be used for storing the users preferences. In a first approach a local service on a device is used whereby applications can query the local service to determine what preferences a user has set.

In a second approach a server side service permits ad networks to query a user s preferences based on a user identifier e.g. phone number IMEI Android ID Apple UDID or hashed salted hashed versions of them .

In another embodiment preferences are declared for which behaviors a user desires. Automatic scanning or alerting is performed when an application that violates these preferences is downloaded or installed.

For example upon installation the mobile device detects which components are in an application and determines the behaviors that are associated with components of the application. If any of these behaviors are disallowed or require an alert the mobile device may either block the application from installing or notify the user to uninstall the application or may alert the user that the application contains a disallowed behavior in one of its components.

Now discussing additional non limiting examples there are various mechanisms that a user can use to express his or her intent. One example is an affirmative opt in or opt out for specific behaviors. For example a user may say she does not want a specific component to track her location or she does not want Google analytics to know certain information about her. Another might be that the user sets a preference indicating the desire that the user does not want any third party components to have access to or view the user s location data.

In another example an application policy may be implemented. For any app that has a component that performs an unidentified behavior the Ad Network Detector will block the app from being installed on the user s phone or other device. These are behavior based preferences that are manifested in the prevention of installation for any applications that may contain components that express such behaviors.

In one example when an application is running on a user s phone it should ask a preference service or a preference store e.g. implemented on a software developer server what the preference is for the user and then respect that preference during execution. Information about user preferences for many users may be made available in a single online location so that a component can query and respect the preferences.

Regarding determining the components that are present in an application the application can be identified and broken into components. After identification there are various techniques that may be used to determine the behavior of those identified components. In some cases structural comparisons of the call graphs of components in an application may be examined e.g. determining which component is talking to the operating system of the mobile device and which aspects of the operating system are involved . Other forms of static analysis may also be used that involve analyzing the code inside of a component. By analyzing the code it can be determined whether the component can obtain a user s location for example or perform other functions. In one example a knowledge base may be maintained that includes a list of components that are commonly distributed online and the corresponding behaviors of those components.

Also dynamic analysis may be used which is essentially running the application component in an emulated environment or on an actual device and detecting what is occurring e.g. what services the component connects to or communicates with on a computing device to determine whether a component has a particular behavior. Additional details regarding determination of components and component attribution are provided in the section below titled Analyzing Components of an Application .

In one example the user may be presented with a screen that shows the applications installed on the user s device or the behaviors on the device or even the full set of all behaviors that are possible on the device even outside of the apps that the user has already installed on the device and what applications components the behaviors are attributed to.

In one example a user can opt out of specific components. The user may be shown which components are on already her phone or the user can say she does not want a certain type of behavior and the Ad Network Detector only shows the user the specific network opt outs that involve that behavior.

In another example the user has expressed her preferences regarding behavior. An online preference service stores these preferences and components are required to query the service prior to installation on a mobile device of the user. The service may be implemented on the mobile device or on a separate server.

Additional information regarding various non limiting examples of mobile devices and their usage more generally including the presenting of information regarding a mobile device to a user is described in U.S. Pat. No. 8 538 815 issued Sep. 17 2013 entitled SYSTEM AND METHOD FOR MOBILE DEVICE REPLACEMENT by Mahaffey et al. U.S. patent application Ser. No. 13 960 585 filed 2013 Aug. 6 which is a continuation of U.S. Pat. No. 8 538 815 and is entitled SYSTEM AND METHOD FOR PROVIDING OFFERS FOR MOBILE DEVICES and U.S. patent application Ser. No. 14 098 473 filed 2013 Dec. 5 which is a continuation of U.S. patent application Ser. No. 13 960 585 and is entitled SYSTEM AND METHOD FOR GENERATING EFFECTIVE OFFERS TO REPLACE MOBILE DEVICES the entire contents of which applications are incorporated by reference as if fully set forth herein.

Various additional embodiments related to component analysis and attribution e.g. identifying and determining components of an application are now set forth below. The embodiments below do not limit the generality of any embodiments in the foregoing description.

In one embodiment an application is a mobile application which contains one or more components e.g. a library ad network or analytics software development kit SDK or other set of code designed to work together . A component identity is information about a component. Examples of component identities include the following a category e.g. ad network analytics and malware SDK authorship e.g. Acme Inc. John Smith name of a component e.g. AdMob a range of versions or all versions of a component e.g. AdMob 6.x AdMob zlib and a particular version of a component e.g. zlib 1.2.7 AdMob SDK 6.0.1 . The data associated with a given component may be stored in a database.

In one embodiment a component s behavior is generally that behavior existing or occurring e.g. functions performed when a component is functioning on a computing device e.g. functioning in an application running on mobile device . One example of a behavior is the sending of certain types of data to a server e.g. sending browser history to a server at www1.adcompany.com or sending a location to a server at tracking.analyticscompany.net . Other examples include the following accessing data on a computing device e.g. contacts call history and performing certain functions on a device e.g. changing brightness of a screen sending a text message making a phone call pushing advertisements into a notification bar .

In one embodiment a component s structure is how a component is implemented in code. This structure may include a code package and or a code module structure. Also a component s structure may include characteristics of the executable code of the component such as for example cross references in a control flow call graph references to static data and machine instructions used.

Various further embodiments related to component analysis are now described below. In a first embodiment a non transitory computer readable storage medium stores computer readable instructions which when executed cause a system to for an application installed on a computing device e.g. mobile device of a user determine components e.g. components and of the application and identify via at least one processor at least one behavior e.g. sending device location to an ad server associated with each of the components including a first behavior associated with a first component. The instructions may cause the system to present on a user display of the computing device an identification of the components. The instructions may cause the system to determine at least one behavioral preference of the user.

In one embodiment the instructions cause the system to store a user policy e.g. user policy or one of user policies based at least in part on the at least one behavioral preference e.g. user intents expressed by the user on a mobile device and to enforce the user policy on new applications installed on the computing device.

In one embodiment the instructions cause the first component to execute in conformance with results from a query of an identity server e.g. the identity server as described earlier above or another computing device . The instructions may cause the system to in response to installing the application scan the application to confirm compliance with a user policy of the user where the user policy is stored on the identity server. In one embodiment the instructions may cause the system to enforce based on identified behaviors associated with the components a user policy for each of the components.

The instructions may cause the system to compare permissible behaviors in the user policy for the components with the identified behaviors. In one example the comparing of the permissible behaviors comprises determining behaviors observed for the components on other computing devices from a data repository e.g. a database . The instructions may cause the computing device to in response to the determining the behaviors from the data repository configure or disable execution of one or more of the components on the computing device.

In one embodiment a system includes a data repository e.g. a database storing component data for known components the component data including data for a first known component at least one processor and memory storing instructions which when executed on a computing device cause the computing device to for a new component in a first application for a computing device of a user perform a comparison of the new component to the component data and based on the comparison make a determination that the new component corresponds to the first known component.

In one embodiment the instructions further cause the computing device to in response to the determination perform at least one of comparing a first known behavior of the first known component to a user policy of the user and comparing an observed behavior of the new component to the user policy. In one embodiment the component data includes component identities each component identity corresponding to respective identifying information for a known component. In one embodiment the determination is made prior to installing the new component on the computing device.

In one embodiment the instructions further cause the computing device to associate a similarity value e.g. a value within an arbitrary range of zero to one with the comparison and wherein the determination is made in response to the similarity value being greater than a threshold value. In alternative embodiments other forms of comparison of the similarity value to a threshold may be done e.g. where the similarity value is lower than the threshold . In one embodiment the comparison is based at least in part on a structure of the new component the structure selected from the group consisting of a packaging structure a module structure and an executable code structure.

In one embodiment the component data includes known structural characteristics and known behavioral characteristics. In one embodiment the performing the comparison comprises comparing the known structural characteristics and the known behavioral characteristics to identified characteristics of the new component.

In one embodiment the instructions further cause the computing device to generate a notification when the identified characteristics are determined to differ from at least one of the known structural characteristics and the known behavioral characteristics. In one embodiment the generating the notification comprises sending an alert to the computing device.

In one embodiment a method includes storing in memory component data for known components the component data including data for a first known component for a new component in a first application for a computing device of a user perform via at least one processor a comparison of the new component to the component data and based on the comparison make a determination that the new component corresponds to the first known component.

In one embodiment the new component is selected from the group consisting of code from the first application and a library in the first application. In one embodiment each of a plurality of different applications includes the new component the new component corresponds to a set of behaviors when executed on a computing device and the component data comprises behavioral data including the set of behaviors.

In one embodiment the method further comprises associating the set of behaviors with the new component. In one embodiment each of a plurality of computing devices has been observed when running a respective one of the different applications and each of the plurality of computing devices exhibits the set of behaviors. In one embodiment the determination is based in part on a context of operation of the new component on the computing device.

In one embodiment the context is an accessing during execution of the first application of location information while the first application has a visible presence to a user e.g. the first application is presenting location information to the user on a user display and the set of behaviors includes determining a location of the computing device. In one embodiment the component data includes a plurality of contexts each associated with at least one acceptable behavior. In one embodiment the component data includes risk scores for known components and the method further comprises providing a risk score in response to a query regarding an application installed or to be installed on the computing device of the user.

In one embodiment a method comprises storing in memory a first application comprising computer readable instructions which when executed cause a mobile device of a user to for a new component of a second application installed on the mobile device perform a comparison of the new component to component data for known components the component data including data for a first known component and based on the comparison make a determination that the new component corresponds to the first known component and sending via at least one processor over a communication network the first application for storage in a data processing system for subsequent installation from the data processing system onto the mobile device.

In one embodiment a system includes at least one processor and memory storing a first application which when executed on a mobile device of a user causes the mobile device to for a new component of a second application installed on the mobile device perform a comparison of the new component to component data for known components the component data including data for a first known component and based on the comparison make a determination that the new component corresponds to the first known component and the memory further storing instructions configured to instruct the at least one processor to send the first application to a data processing system so that the first application can be later installed over a communication network on the mobile device from the data processing system.

Now discussing a component analysis process for one particular embodiment a new application may be decomposed into identifiable components. An identity of each component may be displayed to the user. Behavioral and or structural characteristics attributable to each component identity may be identified. The behavior for a given component may be displayed to the user.

A user policy e.g. user policy based on component behavior may be enforced on the user s computing device. For example the user policy may require that there be no applications that send location to an advertising network. In another example the user policy may require that no applications send identifiers to an advertising network.

Behavioral and or structural characteristics of a component present in the new application may be identified. This may be for example an application that has been installed on mobile device .

A comparison is made between the characteristics attributable to the component identity and the characteristics that have been identified in the new application. In one embodiment if the identified characteristics are different from the characteristics attributable to the component identity then an alert is generated to indicate that the behavior of the component has changed. The characteristics attributable to the component identity may be stored in a database of the identity server which was discussed above and may be accessed when making this comparison. For example these attributable characteristics may be stored as component data associated with respective component identities i.e. known data regarding component behavior or other characteristics of a component may be stored for each component identity .

Now further detail regarding how component analysis is performed is described below. As mentioned above an application is decomposed into identifiable components. In particular a data repository stores a set of component identities in a database.

Each component identity has identifying information for a given component that if present in an application indicates that the given component is present in the application. Examples of identifying information include the following a package name prefix for a set of one or more classes a class name or a code fingerprint of a code block method class package etc.

When used fingerprinting can be performed in a variety of ways. A first way is the creating of an abstract representation of an instruction set. Another way is to from an abstract representation create a set of n gram indices that can create a fingerprint identifier for a set of code e.g. a hash of indices or that can be compared to another set of indices to perform a fuzzy match. In yet another way asset or resource fingerprinting may be used. As a final way fingerprinting may be done by analyzing the network traffic generated by an application on a device or in a dynamic analysis system. Server communication network traffic destined to a server may be used to associate a component with a particular network service. Some examples of network traffic include traffic to server with name server1.somewhere.com traffic to server with IP 8.8.8.8 or 2001 4860 4860 8888 HTTP request with header User Agent MyHttpLibrary 1.1 HTTP request with a particular URI or URI pattern and traffic that matches a SNORT or YARA rule.

Analysis of a new application can be used to determine if identifying information for a given component identity matches the new application. If it matches then the given component is present in the new application. This analysis can be done at the client e.g. mobile device the server e.g. the identity server discussed above or using a combination thereof.

In one embodiment the analysis is done at one computing device e.g. either on the client or the server . The database of identifying information is stored locally on the computing device. The new application is also present locally e.g. the new application itself has been previously sent to the identity server from mobile device or from application marketplace or developer server prior to installation on mobile device .

In this embodiment there are multiple options for analysis. In a first option for each item of identifying information in the database the new application is searched to determine if the identifying information matches the new application. Alternatively information can be extracted from the new application and then a check or comparison done to see if that information matches any of the identifying information stored in the database.

In another embodiment a client submits information to a server to determine components that are present in an application. The database of component identifying information known component data is stored on the server. The application is present on the client. The client extracts information e.g. component identifying information from the application and then sends this extracted information to the server.

The server checks to see if the extracted information matches any of the identifying information in the database e.g. the extracted information may be received as a query from mobile device . If so the server sends back information about component identities to the client e.g. the server sends results from the query to mobile device .

In a different embodiment the client submits an identifier for the new application to a server. This identifier may be for example a hash of the application binary code a package name a title of the application or another form of application identifier. This server stores data regarding previously analyzed applications. This data includes a list of components for each of the previously analyzed applications. In yet other embodiments the application information is gathered from an application store or marketplace or from another device different from the client e.g. where the application is not installed on a client but is stored within an application store for downloading and installation or is being staged for placement into an application store . Information from or about the application may be gathered from the application store or marketplace or such other device. U.S. Publication No. 2012 0240236 filed 2010 Aug. 25 entitled Crawling Multiple Markets and Correlating is incorporated by reference as if fully set forth herein. U.S. Publication No. 2012 0240236 is a continuation in part of U.S. Pat. No. 8 533 844 entitled System and Method for Security Data Collection and Analysis. 

The server of the different embodiment above uses the identifier received from the client and compares this identifier to the data regarding previously analyzed applications. If there is a match between the identifier and a previously analyzed application then the components for that matched application obtained from the stored list of components above are determined to be in the new application and this result may be sent to the client . This matching to the database may be done similarly as was described earlier for the component analysis above. The server of the different embodiment above sends information about these identified component identities back to the client.

After a component has been identified as being present in an application the identity of the component may be displayed to the user. For example identification and display of components present in an application may be done similarly as was described above for the Ad Network Detector. Behavioral and or structural characteristics that are attributable to a given component as stored in the database for various component identities may be sent from the server to the client for those components that have been identified as being present in an application.

In one embodiment there are various ways to identify characteristics that are actually present in a component of an application. For example U.S. Pat. No. 8 533 844 issued Sep. 10 2013 and entitled System and Method for Security Data Collection and Analysis by Mahaffey et al. U.S. patent application Ser. No. 13 958 434 filed 2013 Aug. 2 entitled ASSESSING A DATA OBJECT BASED ON APPLICATION DATA ASSOCIATED WITH THE DATA OBJECT and U.S. patent application Ser. No. 14 688 292 filed 2015 Apr. 16 entitled System and Method for Assessing an Application Based on Data From Multiple Devices which applications are incorporated by reference as if fully set forth herein provide a general discussion about the gathering of information from an application on a mobile device for further processing at a server. According to this embodiment information that has been gathered as described by Mahaffey et al. in U.S. Pat. No. 8 533 844 is then used for component analysis at the identity server discussed above in order to identify characteristics of a component.

In another embodiment behavioral characteristics may be determined or collected using other approaches. For example behavior may be determined based on network traffic e.g. SMS IP data or based on the code source of a given behavior e.g. a class name or a package name responsible for geo locating or a fingerprint of a code segment responsible for sending SMS traffic .

In one embodiment component identity attributable characteristics are compared to actually present characteristics e.g. as gathered for a new application just installed on a mobile device . For example if behavior is part of the known data for a component identity and a new application s component behavior matches this known behavior then it is assumed that information about the component identity applies to the new application. Information about the component identity may include for example a text description risk scoring and data whether an application is malware or is not malware. For example this information may be provided as a result or response to a query from a mobile device.

If the actual behavior and the known behavior for the component identity are different this may indicate that the component in the new application is a newer version or a tampered version and that the component needs to be reviewed again in order to update the database. Also an alert may be generated based on the component information determined above. For example an email may be sent to an analyst to do further analysis of a component or an entry may be created in a work queue regarding further component analysis to be done.

In various other embodiments the results from component identification for applications on a device are presented to the user. The user may provide input in a user interface to define or update a user policy based on this component identification. For example the user may opt out of an identified component.

In another embodiment a component review process is provided for reviewing potentially undesirable code at scale where manual review is not practical . The component analysis as described above is automated so that a human is not required to do component analysis manually. Characterizing components that have been previously reviewed e.g. stored as data for a component identity with a risk score and determining when that component has changed behavior i.e. the actual behavior is different from the known behavior stored in the component identity can create an automated process where humans only need to re review component code when its behavior has changed. A behavior change may also be associated with a code fingerprint having changed slightly e.g. if doing a fuzzy match there is a threshold for which it is considered that there is no change and another threshold for which it is considered that that there is a sufficient change in behavior . In various embodiments a comparison to a threshold may be done to see if a value is lower or greater than the threshold which may include the cases of equal to or lower or equal to or higher than the threshold . Similarly other characteristics disclosed can be used to determine if the component in the new application exactly matches the known component or if it partially matches in a way that merits re analysis.

Yet another embodiment relates to behavioral risk analysis of applications. In this embodiment the component analysis involves separating identified components that have already been reviewed i.e. components that have known component data stored in a database and that are common across numerous different applications or across copies of the same application as installed on many computing devices from components that are unique e.g. an associated behavior has not been observed before to a particular new application e.g. behavior unique to a single most recent installation on mobile device . These unique behaviors are specifically audited within the context of the new application e.g. application .

As an example of context it is common for ad networks to ask for location data. This is a well accepted behavior. If a user is looking for example at a game like Angry Birds an application that asks for a location may be exhibiting acceptable behavior if this behavior is associated with an ad network that has been previously observed as being acceptable e.g. as determined from data stored in a database . However in other cases actual game code that is itself asking for location may be inappropriate behavior.

The amount of code that is unique to any given application is typically fairly small. Most applications e.g. for mobile devices predominantly use code that is in at least one or many other applications the majority of code in an application is typically not unique and there is a lot of commonality in code between applications .

Sometimes when a behavior is analyzed in the context of a known SDK the behavior is a repeatable behavior that has previously been determined to be acceptable or to have a low risk score . Thus for example if a library has already been reviewed then further analysis can be skipped.

In an embodiment regarding similarity of known and new applications fuzzy matching and fingerprinting may be used as was discussed above . For example a similarity score of zero to one may be used. A similarity score is returned from the server after analysis of a new application. The code in the new application is compared to code that is already in the identified component library e.g. a library in a database on the identity server that was discussed above .

Typically there is not an exact code similarity match because there are many changes that a compiler can make to a particular application installation to make it different than other installations. Similarities are defined so that if the differences are over a similarity threshold then a determination is made that a known component is present in the newly installed application. For example the new application may include a slightly customized version of a component that was previously determined to be acceptable . In alternative embodiments other forms of comparison to a threshold may be done e.g. where a value is lower than the threshold . In other cases the new application may include a new version of a component that has not been previously analyzed. In one embodiment unacceptable code that has been only slightly modified to defeat similarity protection mechanisms is instead detected as unacceptable based on behavioral observation and component analysis as discussed above.

In one embodiment components are analyzed with respect to similarity of previously known components. Behaviors can include use of personal identifying information or device information or any actions that can be taken by applications on the device including user interface displays notifications network communications and file reading or writing actions. Policies to control or restrict the behavior of applications and their components may be defined and applied. This can include the identification of advertising networks and defining policies to permit various opt out actions for these advertising networks.

Various embodiments related to assessing application authenticity are now set forth below. In one embodiment a method includes evaluating e.g. by a server or a mobile device authenticity of a first application e.g. software being downloaded to a mobile device to provide a result where the evaluating uses a plurality of inputs. In response to the result an action is performed on the computing device.

In one embodiment the result is a determination of a source of software. In another embodiment the result is a state designation that is sent to side load server for use similarly as described above for the administrator state designation. State designations from the authenticity server and the administrator server may both be used by side load server in its determination of the state designation to send to mobile device .

In one example the evaluating may be done by a server for an application that a user of a mobile device desires to install from an application marketplace. In one embodiment the computing device is a server and the action is sending a notification from the server to the mobile device the notification including an assessment of authenticity of the first application.

In one embodiment the computing device is a mobile device on which the first application is being or has been installed and the action is providing of a notification in a user interface of the mobile device relating to an assessment of authenticity of the first application. In an alternative embodiment the application may have been previously installed on the mobile device but the user desires an evaluation of authenticity e.g. to consider whether to remove the application from the mobile device .

In one embodiment one or more of the plurality of inputs may be received from a distributor of the first application an online application store a carrier operator device manufacturer e.g. for preloaded software on a mobile device and or from a computing device within an enterprise or an organization s internal network.

In one embodiment the computing device is a server e.g. authenticity server and the first application has a first package identifier and a first signing identifier the method further comprising receiving the first package identifier and the first signing identifier from a mobile device on which the first application is being or has been installed. The first package identifier may be for example an Android package name an Apple iOS bundle identifier or a hash of such name or identifier etc. The first signing identifier may be for example a certificate e.g. a signing certificate digital certificate etc. a certificate thumbprint or a public key or a hash of a certificate a hash of a public key or other data which can be used to identify the signer. In one embodiment the method further comprises receiving the first application itself from the mobile device e.g. for testing or other operation for evaluation by the server .

In one embodiment the plurality of inputs comprises receipt e.g. from a computing device of a developer of the first application of a developer signing certificate for the first application and the evaluating comprises comparing the developer signing certificate to the first signing identifier.

In one embodiment the plurality of inputs comprises one or more of the following receipt from a computing device of an indication of ownership in the first application by a developer e.g. a developer of known or assumed credibility simply makes an assertion or claim to ownership in an electronic communication a prevalence of the first application e.g. the application is the most popular version that has been distributed and this version is assumed to be authentic and a model e.g. a model to predict expected characteristics associated with a first application and or to assess observed behavior or characteristics for the first application . In one embodiment the first application has a first signing identifier and the plurality of inputs comprises a history of the first signing identifier.

In one embodiment the method further comprises comparing a first signing identifier of the first application to a signing key in a registry of known signing keys. In one embodiment the registry comprises a plurality of package identifiers each identifier associated with a respective one of the known signing keys and the method further comprises comparing a first package identifier of the first application to the plurality of package identifiers.

In one embodiment the result from the evaluating is a score and the performing of the action is conditional on the score exceeding a threshold or other alternative forms of comparison to the threshold .

In one embodiment the evaluating comprises identifying a plurality of applications that are similar to the first application e.g. using component analysis as discussed above classifying the similar applications based on a respective signing identifier for each application and identifying based on the classifying applications having a signing identifier of a developer and applications having a signing identifier that is different from the signing identifier of the developer.

In one embodiment the method further comprises sending a notification to a computing device of the developer that identifies the applications having the signing identifier that is different from the signing identifier of the developer.

In one embodiment the identifying the plurality of applications that are similar to the first application comprises identifying applications having at least one of an identical package identifier code similarity identical strings similar strings identical media assets and similar media assets. In one embodiment a server determines the similarity of newly observed applications to a previously known to be authentic application e.g. stored in a database at the server . In one example this determination includes component analysis e.g. comparison of known and new components and or application component code similarity assessment as was discussed earlier above. In another example the server can notify the developer of the authentic application or challenge the developer to authenticate itself as the actual application signer for the newly observed application s .

In one embodiment the method further comprises receiving the signing identifier of the developer sending data to the developer to be signed by the developer with a private key receiving the signed data from the developer and confirming the signed data corresponds to the signing identifier of the developer. For example the data sent to the developer may be an archive or a nonce or the data may be for the issuing of a crypto based challenge to the developer.

In yet another embodiment the first application may be examined in the context of known business entity databases e.g. Equifax database Dun Bradstreet database etc. or other information sources and information obtained from such sources may be used as one or more of the plurality of inputs in the evaluating of the first application. For example these inputs may include the company name as determined from a WHOIS response the name of an owner of the IP space that the first application talks to e.g. an inquiry can be made as to who owns the application server that the first application communicates with the response to an inquiry as to whether the package name for the first application corresponds to a valid organizational domain name and further whether that domain name s WHOIS name shows up in a business database and the developer name as determined in an online application store such as Google Play.

In one embodiment authenticity is assessed by a method in which mobile device of a user communicates with authenticity server to evaluate the authenticity of new application for example which is being newly installed on the mobile device or alternatively has already been installed according to one embodiment. In other embodiments some or all of the authenticity functions described for authenticity server may be performed by an identity server not shown which was discussed above with respect to component analysis.

Authenticity server receives from mobile device a package identifier and a signing identifier associated with new application . Authenticity server uses a plurality of inputs such as are described herein to evaluate the authenticity of new application . This evaluation provides a result for example a score indicating the risk of the new application being inauthentic. Based on this result an action is performed by authenticity server . If the score is above a threshold the application may be deemed as being untrusted or a state designation of untrusted may be sent to side load server .

In one example this action is the sending of a notification to a mobile device in order to alert the user that the new application may be fraudulent or a tampered version. New application may have been provided for example to application marketplace or directly to mobile device by developer server along with a signing certificate . Developer server also provides a package identifier for new application . Signing certificate is one form of signing identifier that may be provided to authenticity server for evaluation of new application .

Authenticity server has a database for storing information and data regarding applications such as previously known or identified applications that are considered to be authentic. The authentic developer or other source of the application is stored in database . Database further may include component data which corresponds to information about software components as was discussed earlier above. Database further may include repository which stores package identifiers and corresponding signing identifiers for example such as collected or identified for previously authentic known good or deemed good applications.

The evaluation of authenticity may alternatively be performed in part or fully on mobile device . If an inauthentic application is discovered then the user of mobile device may be notified on a display of a user interface. This notification may include an assessment of the authenticity of the new application .

In one embodiment authenticity server compares signing certificate to an existing signing identifier contained in repository . Authenticity server in one example compares signing certificate to a known good signing key stored in repository .

Various other non limiting embodiments are now described below. In a first embodiment authenticity server has a registry of known application signing keys and the package names they are registered for. If an application pretends to own one of those package names with a different signing key a user is alerted that the application is likely tampered with. In some cases authenticity server may also use similarity detection e.g. similarity analysis as was discussed earlier above to determine that even if an application has a different package name it is highly similar to another previously known application but has a different signer.

In one embodiment all applications are identified that are similar to a given application e.g. where the given application is being newly installed on a mobile device . One or more of the following inputs may be used in evaluating the new application whether applications have the same package name code similarity between the applications similar or identical strings especially strings that occur infrequently between new and known applications and similar or identical media assets e.g. images sounds video etc. between new and known applications. In some embodiments similarity and or component analysis as was discussed above may be used.

In one embodiment applications that have been determined to be similar e.g. as described above are classified based on signing certificates which are used to classify applications into two groups applications with a given developer signing certificate and applications with a different signing certificate. This classification is used for one or more of the following identifying potentially pirated applications e.g. for copyright enforcement identifying potentially malicious applications optimizing a sales strategy e.g. such as identifying additional markets where an application could be sold and managing release processes e.g. identifying versions of an application that are sold in different markets .

In one embodiment a workflow for establishing ownership of a signing certificate includes a developer or other user uploads the certificate then receives download of a jar or Java archive which the developer must sign to prove that it has the private key corresponding to the certificate. In one embodiment the workflow is extended to allow a developer to manage multiple signing certificates.

In one embodiment a workflow for discovering applications based on proof of certificate ownership includes a developer or other user proves certificate ownership then authenticity server finds all packages signed with the same certificate and also identifies similar applications signed both by the same certificate and other certificates. In one embodiment the workflow is extended to allow a developer to manage multiple signing certificates.

In an alternative embodiment authenticity server provides monitoring and security services to Android or other system developers. These services determine developer identification to confirm that the developer is who it purports to be . The services may include monitoring tools and or anti piracy functions. If the developer s application has been pirated and is being distributed in different markets authenticity server notifies the developer.

The services may also include brand protection. For example a bank may want to know if a version of its application has been pirated and is being misused for phishing. In one embodiment the services include looking at actual software assets being used in applications e.g. logos images etc. to determine if they are being used in non sanctioned manners. Application assessments and or reports for the above services may be provided to a brand owner developer or other entity. In another example a vendor of application components e.g. such as advertising SDKs sensor activity SDKs etc. may want to know if a version of its components are being used in an application. In one embodiment the services include looking at application components being used in applications libraries SDKs components etc. to determine that they are being used in sanctioned or non sanctioned manners. Application assessments and or reports for the above services may be provided to a vendor or developer or distributor of such application components or other entity.

In one embodiment an assessment of privacy is provided by the services. This includes analyzing potential privacy issues in the application. Authenticity server may generate a privacy policy for the developer based on permissions provided by the developer. In one embodiment a security assessment is provided by the services. Authenticity server analyzes potential security vulnerabilities and provides recommendations to the developer or other entity.

In one embodiment the services above permit a developer to develop a good reputation. For example an application developer certification may be provided to a user after an evaluating of authenticity of an application. For example a seal of approval or other visual indication may be provided in a user interface display for this purpose to indicate to a user that an application is authentic. The services above may be supported by analysis of application components as described above e.g. when providing piracy or brand protection .

Additional information regarding various non limiting examples of analyzing characterizing and or scoring applications with respect to security is described in previously published U.S. Patent Publication No. 2011 0047594 published Feb. 24 2011 entitled System and Method for Mobile Communication Device Application Advisement by Mahaffey et al. and also in previously published U.S. Patent Publication No. 2013 0263260 published Oct. 3 2013 entitled System and Method for Assessing an Application to be Installed on a Mobile Communication Device by Mahaffey et al. the entire contents of which applications are incorporated by reference as if fully set forth herein.

In particular U.S. Patent Publication No. 2013 0263260 describes a system that checks for harmful behavior of an application to be installed on a mobile device. A server computer receives from the mobile device data pertaining to the application to be installed and information pertaining to the mobile device. The server processes the data and information to determine an assessment for the application to be installed. The assessment is provided to the mobile device and the assessment is displayed on the device if the assessment is one of dangerous and potentially dangerous. The data and information received from the mobile device may be used for example as one or more inputs in the plurality of inputs for evaluating the first application as described herein.

Also in particular U.S. Patent Publication No. 2011 0047594 describes a system for providing advisement about applications on mobile devices such as smartphones netbooks and tablets. A server gathers data about mobile applications analyzes the applications and produces an assessment that may advise users on a variety of factors including security privacy battery impact performance impact and network usage. The disclosure helps users understand the impact of applications to improve the experience in using their mobile device. The disclosure also enables a server to feed information about applications to other protection systems such as application policy systems and network infrastructure. The disclosure also enables advisement about applications to be presented in a variety of forms such as through a mobile application as part of a web application or integrated into other services via an API. The data gathered by the server may be used for example as one or more inputs in the plurality of inputs for evaluating the first application as described herein. Also some of the forms of advisement discussed may be used for example in providing notifications to the user and or to developers or others regarding evaluations of software authenticity.

Additional information regarding various non limiting examples of some analytic methods for determining application behavior is described in U.S. patent application Ser. No. 14 063 342 filed Oct. 25 2013 entitled System and Method for Creating and Assigning a Policy for a Mobile Communications Device Based on Personal Data by Timothy Micheal Wyatt the entire contents of which application is incorporated by reference as if fully set forth herein. For example one or more of the methods for determining behavior may be used when evaluating application authenticity as described herein.

Additional information regarding various non limiting examples of security evaluation and scoring relating to a plurality of trust factors is described in U.S. patent application Ser. No. 14 072 718 filed Nov. 5 2013 entitled Method and System for Evaluating Security for an Interactive Service Operation by a Mobile Device by Derek Halliday the entire contents of which application is incorporated by reference as if fully set forth herein. For example some of the trust factors may be used as inputs when evaluating application authenticity.

In one specific example the context in which a signing certificate or other signing identifier or signing is observed is assessed using factors which may include one or more trust factors as described in U.S. patent application Ser. No. 14 072 718 above. These factors may for example be used in formulating a score that is compared to a threshold that is used to make a decision whether to perform an action in response to evaluating an application e.g. various forms of comparison to the threshold may be used as described previously .

In particular U.S. patent application Ser. No. 14 072 718 describes a method for evaluating security during an interactive service operation by a mobile device that includes launching by a mobile device an interactive service configured to access a server over a network during an interactive service operation and generating a security evaluation based on a plurality of trust factors related to a current state of the mobile device to a security feature of the application and or to a security feature of the network. When the security evaluation is generated an action is performed based on the security evaluation. In some examples these actions may be performed in response to the result from an evaluation of application authenticity.

In another embodiment the first application is evaluated to determine its components and or to identify behaviors associated with each of the components. This evaluation may provide some or all of the plurality of inputs used in the evaluating of the first application as was discussed above. In one embodiment the components of the first application can be analyzed regarding similarity to previously known components when assessing authenticity of the first application.

Behaviors associated with one or more components of the first application may include for example use of personal identifying information or device information or any actions that can be taken by applications on the device including user interface displays notifications network communications and file reading or writing actions. In one embodiment the evaluating of the first application may include analysis of components of the first application as described in the section above titled Analyzing Components of an Application and also further optionally include analysis of components in other applications being compared to the first application .

In one embodiment the first application above is a mobile application which contains one or more components such as were discussed previously above. The source of the components is indicated by a component identity. In one example the component identity is an authorship e.g. an identification of a developer of the first application or the name of a component. Previously collected data associated with a given component may be stored in a database e.g. as was discussed above .

In one embodiment as discussed in more detail below for a first application being installed on mobile device components are identified and behaviors exhibited on mobile device are attributed to one or more of the components. Any given component may be present in several different applications on mobile device and or may be common to numerous copies or versions of an application that have been installed on computing devices for large numbers of other users. In one embodiment this commonality of component presence permits observing and collecting structural and behavioral data associated with the component. This known component data is stored in a database e.g. database discussed above and the component data is associated with a particular component identity. Thus a data repository of prior component data can be used to compare to data more recently obtained for new components such as those identified in newly installed applications on a mobile device when evaluating authenticity of the first application being installed.

More specifically as characteristics and behaviors associated with components on mobile device are identified and attributed these characteristics and behaviors may be compared with known characteristics and behaviors stored either locally on mobile device or stored remotely on authenticity server in database . The results from such comparisons may be used as inputs for the evaluating of the first application being installed e.g. for making decisions regarding disabling of one or more particular components that are being considered for a new installation on the mobile device .

In one embodiment behavioral and or structural characteristics of a component present in the first application may be identified e.g. as was discussed in the section titled Analyzing Components of an Application above . This may be for example an application that is being installed on mobile device and for which the user desires to determine if the application is from an authentic source e.g. a known developer of an earlier or related version of the new application .

A comparison is made between the characteristics attributable to a component associated with the first package identifier and characteristics that have been identified in the new application. In one embodiment if the identified characteristics are different from the characteristics associated with the first package identifier then an alert is generated to indicate that the new application is not authentic. The characteristics associated with the first package identifier may be stored in a database of authenticity server and may be accessed when making this comparison alternatively the characteristics may be stored in a database and or the comparison made or supported by an identity server . For example these attributable characteristics may be stored as component data associated with respective component identities.

Each component identity has identifying information for a given component that if present in an application indicates that the given component is present in the application. Examples of identifying information include the following a package name prefix for a set of one or more classes a class name or a code fingerprint of a code block method class package etc.

Analysis of a new application being installed can be used to determine if identifying information for a given component identity matches the new application. If it matches then the given component is present in the new application. This analysis can be done at the client e.g. mobile device the server e.g. authenticity server or an identity server or using a combination thereof. This match that determines presence of the component in the new application can be used as an input in evaluating authenticity of the new application.

In a different embodiment the client submits an identifier for the new application to a server e.g. authenticity server . This identifier may be for example a hash of the application binary code a package name a title of the application or another form of application identifier. This server stores data regarding previously analyzed applications. This data includes data associated with each component of a set of components for each of the previously analyzed applications.

The server uses the identifier received from the client and compares this identifier to the data regarding previously analyzed applications. If there is a match between the identifier and a previously analyzed application then the components for that matched application obtained from the stored set of component data above are determined to be in the new application. This result may be sent to the client. Also this result may be used as one of the plurality of inputs in evaluating the application. In one example this matching is done similarly as was described earlier above for the component analysis on a single device. The server sends information about these identified component identities back to the client e.g. a notification that a new application is not authentic or a score indicating the risk of a fraudulent application .

If the actual behavior and the known behavior for the component identity are different this may indicate that the component in the new application is either a newer version or a tampered version i.e. is not authentic and that the component needs to be reviewed again in order to update the database. Also an alert may be generated based on the component information determined above. For example an email may be sent to an analyst to do further analysis of a component or an entry may be created in a work queue regarding further component analysis to be done. In another example a notification is sent to the developer of a prior known good version of an application e.g. to alert the developer that a fraudulent version of the application was identified .

Yet further additional non limiting embodiments and examples are now discussed below. In a first embodiment a developer registers through a website and provides its signing key. The developer claims authorship of a given application. An application that is signed with this key is considered to be authored by the developer. If the same application is signed by a different person or entity then authenticity server alerts the developer that another entity is potentially illegitimate.

In one embodiment authenticity server implements an authenticity component and a response component. An application is evaluated by the authenticity component and the result from the authenticity component is acted upon by the response component.

The authenticity component is a data set that may include a plurality of inputs used for evaluating an application. For example these inputs may include that a developer signs an application the prevalence of an application the context or environment in which the application is observed and a history of the signing key or certificate associated with an application.

The output from this evaluation may be a score such as for example 0.4 or 0.6 on a scale of 0.0 1.0. This multi input authenticity component model provides a result that is acted upon by the response component. In one embodiment the score is used to make a decision to set a state designation for an application to trusted or untrusted.

Another embodiment is based on probability in which it is assumed that the most popular version of a given application is the legitimate one. Another embodiment assumes that the application that is published in Google Play or another legitimate application store is the legitimate or authentic one.

If another version of that same application is signed by a different person then one of the applications is authoritative and the other is not. Authenticity server alerts the user the mobile device as to whether a version being installed is authentic.

In one embodiment there are various ways to determine the authentic version of several versions of an application being distributed. In some cases the most popular version of an application may not be the authentic version of the application. Thus a collection of factors are used from the exemplary inputs provided above e.g. whether the application is published in the Google Play store what is the context of the observation of the application does the application have good online reviews over an extended predetermined time period such as for example more than 6 months etc. .

In one embodiment the history of usage of a signature is considered as an input. For example if a signing key is used to sign an application that authenticity server knows is bad then if that same key signs other applications those applications can also be assumed to be bad. This is like a signer reputation. If the signer is connected to prior suspicious activity then the signer itself can be flagged as suspicious and this fact considered in evaluating authenticity.

Another input may be the signing of different applications that authenticity server knows are provided from different developers. Another input is that the applications may communicate with different servers in different parts of the world this indicates that one of the applications is not authentic and or that there are potentially different developers.

In one embodiment the first appearance of a signed application indicates authenticity. For example the first person to sign and package that application is considered or assumed to be the authentic author. Authenticity server may have a huge network of devices e.g. greater than 10 000 or 1 million devices that report all the applications that they see. Therefore presumably the legitimate application appears first as stored in database . For example the first time that the server sees an application it will take the signature on that application and consider it to be the authentic signature.

In one embodiment another input is the number of stars or other rating level that an application gets in Google Play or another store. For example the application may have been in a store for at least a predetermined time period e.g. at least one or two years and have a good rating. If the application has at least a predetermined number of ratings for example 300 000 ratings and a star value over a given level then the application is likely a legitimate version of the application.

In one embodiment the longevity of the key is an input. The longevity may be a weighted user distribution based on time period and number of users. For example if the application is observed for a year but with very little users that is a negative input. However in contrast having a million users over a year is a positive sign.

In one embodiment various inputs are provided into a black box model used in authenticity evaluation. The inputs may include for example the signing key as registered by the developer itself the usage history of a signing key a history weighted time of first appearance an appearance in certain reputable application stores a signing key used to sign applications that are substantially different applications that talk to substantially different servers applications that have substantially different code bases and two applications that are signed and appear under different developer names in an authoritative marketplace such as Google Play.

In one embodiment there are different interfaces provided for different users to provide information from authenticity server about the result from the evaluation of the authenticity. For the user e.g. user of a mobile device there may just be a warning provided e.g. a popup that states that an application is not authentic . An alternative is a notice that indicates e.g. an authentication seal that appears in the lower right hand corner of a window to the user that this is an authentic application. As one example a user is presented and sees an authentication seal when a banking application is being installed by the user on its mobile device.

In this description various functions and operations may be described as being performed by or caused by software code to simplify description. However those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor such as a microprocessor. Alternatively or in combination the functions and operations can be implemented using special purpose circuitry with or without software instructions such as using an Application Specific Integrated Circuit ASIC or a Field Programmable Gate Array FPGA . Embodiments can be implemented using hardwired circuitry without software instructions or in combination with software instructions. Thus the techniques are limited neither to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by a computing device.

While some embodiments can be implemented in fully functioning computers and computer systems various embodiments are capable of being distributed as a computing product in a variety of forms and are capable of being applied regardless of the particular type of machine or computer readable media used to actually effect the distribution.

At least some aspects disclosed can be embodied at least in part in software. That is the techniques may be carried out in a computing device or other system in response to its processor such as a microprocessor executing sequences of instructions contained in a memory such as ROM volatile RAM non volatile memory cache or a remote storage device.

Routines executed to implement the embodiments may be implemented as part of an operating system middleware service delivery platform SDK Software Development Kit component web services or other specific application component program object module or sequence of instructions referred to as computer programs. Invocation interfaces to these routines can be exposed to a software development community as an API Application Programming Interface . The computer programs typically comprise one or more instructions set at various times in various memory and storage devices in a computer and that when read and executed by one or more processors in a computer cause the computer to perform operations necessary to execute elements involving the various aspects.

A machine readable medium can be used to store software and data which when executed by a computing device causes the device to perform various methods. The executable software and data may be stored in various places including for example ROM volatile RAM non volatile memory and or cache. Portions of this software and or data may be stored in any one of these storage devices. Further the data and instructions can be obtained from centralized servers or peer to peer networks. Different portions of the data and instructions can be obtained from different centralized servers and or peer to peer networks at different times and in different communication sessions or in a same communication session. The data and instructions can be obtained in entirety prior to the execution of the applications. Alternatively portions of the data and instructions can be obtained dynamically just in time when needed for execution. Thus it is not required that the data and instructions be on a machine readable medium in entirety at a particular instance of time.

Examples of computer readable media include but are not limited to recordable and non recordable type media such as volatile and non volatile memory devices read only memory ROM random access memory RAM flash memory devices removable disks magnetic disk storage media optical storage media e.g. Compact Disk Read Only Memory CD ROMS Digital Versatile Disks DVDs etc. among others. The computer readable media may store the instructions.

The instructions may also be embodied in digital and analog communication links for electrical optical acoustical or other forms of propagated signals such as carrier waves infrared signals digital signals etc. However propagated signals such as carrier waves infrared signals digital signals etc. are not tangible machine readable medium and are not configured to store instructions.

In general a tangible machine readable medium includes any mechanism that provides e.g. stores information in a form accessible by a machine e.g. a computer network device personal digital assistant manufacturing tool any device with a set of one or more processors etc. .

In various embodiments hardwired circuitry may be used in combination with software instructions to implement the techniques. Thus the techniques are neither limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by a computing device.

Although some of the drawings illustrate a number of operations in a particular order operations which are not order dependent may be reordered and other operations may be combined or broken out. While some reordering or other groupings are specifically mentioned others will be apparent to those of ordinary skill in the art and so do not present an exhaustive list of alternatives. Moreover it should be recognized that the stages could be implemented in hardware firmware software or any combination thereof.

In the foregoing specification the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

