---

title: Systems and methods for computing applications
abstract: Systems and methods for dynamic development and/or deployment of computing applications including a development framework, a visual design subsystem, and a deployment subsystem, where at runtime the deployment subsystem is operable to dynamically deploy a computing application realized by a blueprint by sending a request at runtime for graphs and components instantiated by the blueprint.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535669&OS=09535669&RS=09535669
owner: IMAGINE COMMUNICATIONS CORP.
number: 09535669
owner_city: Frisco
owner_country: US
publication_date: 20150827
---
This application is a continuation of U.S. patent application Ser. No. 14 343 299 filed Apr. 24 2014 which is a National Phase Entry of PCT application PCT CA2012 000820 filed Sep. 6 2012 which claims the benefit of U.S. Provisional Patent Application No. 61 531 953 filed Sep. 7 2011 and U.S. Provisional Patent Application No. 61 598 670 filed Feb. 14 2012 all of which are hereby incorporated by reference in their entireties.

The described embodiments relate to systems and methods for computing applications and in particular to systems and methods for dynamic development and deployment of computing applications.

Computing applications generally involve processing data performing operations on the data to carry out specific functions completing tasks controlling components and so on. An example computing application is a media application. Media applications generally involve producing transforming or delivering media data or a combination thereof. New devices and technology increase the use of computing applications and data. New network capabilities and improved data access further increase the use of computing applications and data. The availability of multiple computing languages protocols and platforms increase options available to computing application providers developers and users but may make it difficult to use a combination of multiple computing applications or combine a new computing application with an existing system or architecture due to integration interoperability and connectivity problems. There exists a need for improved methods and systems for the development and deployment of computing applications or at least alternatives.

In a first aspect embodiments described herein provide a system for dynamic development of computing applications comprising a development framework one or more processors and a memory coupled to the one or more processor and configured to store instructions executable by the one or more processors to configure the development framework to define components and graphs wherein each component defines a computing processing mechanism for processing data containers of computing data at application runtime wherein each graph identifies components connections between the components and properties for the components wherein a graph is an instantiation of a corresponding blueprint at application runtime wherein the development framework enables components to be embedded within other components. Additional and alternative functionality is described herein.

In accordance with some embodiments a graph may deliver functionality defined by the components identified by the graph and wherein a blueprint connects the functionality to a running environment. The blueprint may provide business logic for the corresponding graph.

In accordance with some embodiments the system may further comprise a visual design subsystem for realizing computing applications wherein the visual design subsystem is operable to arrange components into functional blocks define specific orders of operation for the functional blocks and define connections between the functional blocks to instantiate the computing applications. Additional and alternative functionality is described herein.

In accordance with some embodiments each component may be associated with one or more versions wherein at least one of a graph and a blueprint comprises a reference to a solution set of components wherein the solution set identifies a version for each component.

In accordance with some embodiments at least one component may be associated with one or more versions and wherein the development framework enables loading of an appropriate version of the at least one component at application runtime.

In accordance with some embodiments a first component may be in a first language and a second component may be in a second different language wherein the first and second components comprise data and are operable to access the memory and data structures and wherein the system further comprises a translation module operable to translate multiple languages into a common language by translating the first and second component data and how the first and second component re operable to access the memory and the data structures.

In another aspect embodiments described herein may provide a method for dynamic development of computing applications providing a dynamic development of computing applications comprising a development framework one or more processors and a memory coupled to the one or more processor and configured to store instructions executable by the one or more processors to configure the development framework to define components and graphs wherein each component defines a computing processing mechanism for processing data containers of computing data at application runtime wherein each graph identifies components connections between the components and properties for the components wherein a graph is instantiated by a corresponding blueprint at application runtime wherein the development framework enables components to be embedded within other components developing components and graphs for a blueprint and storing the components and the graphs for the blueprint in the repository for loading at application runtime.

In another aspect embodiments described herein may provide a system for dynamic deployment of computing applications comprising a deployment subsystem for deploying computing applications at runtime one or more processors and a memory coupled to the one or more processor and configured to store instructions executable by the one or more processors to configure the deployment subsystem with a repository cloud agent cloud engine wherein the computing applications are realized by blueprints wherein each blueprint may be used to instantiate a graph at application runtime wherein a graph identifies components connections between the components and properties for the components wherein each component defines a computing processing mechanism for processing data containers of computing data at application runtime wherein each graph identifies components wherein the repository stores the graphs and the components for loading at application runtime wherein the cloud agent controls at least one cloud engine wherein the cloud engine provides a running environment for the computing application by using blueprints to instantiate graphs at application runtime wherein at runtime the deployment subsystem dynamically constructs and deploys a computing application by sending a request at runtime to the repository for the graphs instantiate by corresponding blueprints and components identified therein. Additional and alternative functionality is described herein.

In accordance with some embodiments each component may be associated with one or more versions wherein at least one of a blueprint and a graph comprises a reference to a solution set of components wherein the solution set identifies a version for each component.

In accordance with some embodiments the system may further comprise a license server wherein the license server may dynamically manage licenses and associates licenses with components and graphs wherein use of components and graphs at application runtime requires the appropriate license.

In accordance with some embodiments the system may further comprise a job manager wherein the job manager dispatches blueprints and graphs to cloud agents based on available licenses managed by the license server. The job manager may also be configured to provide job and cloud engine dispatch failover tracking and reporting.

In accordance with some embodiments the system may further comprise a security manager wherein the security manager provides for secure connections and communications between system components. Additional and alternative functionality is described herein.

In accordance with some embodiments each graph identifies components connections between the components and properties for the components wherein components are connected by different types of pins.

In accordance with some embodiments a data container defines a data type and a data object wherein the data type is metadata describing the data container and the data object maintains raw data.

In accordance with some embodiments the repository manages versioning of components and graphs to keep track of updates made thereto wherein the repository serves the components and graphs at application runtime using appropriate versions of the graphs and components. Additional and alternative functionality is described herein.

In accordance with some embodiments the cloud agent is provided to each user system to manage the local resources of the user system wherein the cloud agents interact with cloud engines to instantiate graphs using blueprints. Additional and alternative functionality is described herein.

In accordance with some embodiments the system may further comprise a normalization module operable to receive input data files and convert and parse the input data files into data containers for processing by a graph.

In accordance with some embodiments the system may further comprise code signing module operable to digitally sign each component to associate a developer license or both with at least one component. Additional and alternative functionality is described herein.

In accordance with some embodiments the system may further comprise a digital certificate associated with a component provider subsystem wherein the component provider subsystem provides one or more components a digital certificate associated with a user computing subsystem wherein the user computing subsystem is associated with a computing application wherein the computing application involves a component provided by the component provider computing system a license server configured to digitally sign a component by linking the component to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem to indicate that the user computing system and the component provider subsystem accept performance of the digitally signed component wherein at runtime prior to deploying each component the deployment subsystem queries the license server to determine whether the component is linked to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem.

In accordance with some embodiments the deployment subsystem may be further configured to partition a graph into two or more subgraphs and handle interprocess communications between the two or more subgraphs.

In another aspect embodiments described herein may provide a method for dynamic deployment of computing applications providing a deployment subsystem for deploying computing applications at runtime one or more processors and a memory coupled to the one or more processor and configured to store instructions executable by the one or more processors to configure the deployment subsystem to comprise a repository cloud agent cloud engine wherein the computing applications identify blueprints wherein each blueprint may be used to instantiate a graph at application runtime wherein a graph identifies components connections between the components and properties for the components wherein each component defines a computing processing mechanism for processing data containers of computing data at application runtime wherein each graph identifies components storing components and graphs in the repository for loading at application runtime providing by the cloud engine a running environment for the computing application by using blueprints to instantiate graphs at application runtime controlling by the cloud agent the cloud engine at application runtime dynamically deploying a computing application by sending a request at runtime to the repository for the graphs and components identified in the blueprint.

In accordance with some embodiments the method may further comprise providing a digital certificate associated with a component provider subsystem wherein the component provider subsystem provides one or more components providing a digital certificate associated with a user computing subsystem wherein the user computing subsystem is associated with a computing application wherein the computing application involves a component provided by the component provider computing system providing a license server configured to digitally sign a component by linking the component to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem to indicate that the user computing system and the component provider subsystem accept performance of the digitally signed component receiving at a license server acceptance of the component provided by the component provider subsystem in the computing application associated with user computing system by receiving the digital certificate from the user computing subsystem and the digital certificate from the component provider computing system linking at the license server the component provided by the component provider subsystem in the computing application associated with user computing system to the digital certificate from the user computing subsystem and the digital certificate from the component provider computing system and at application runtime prior to deploying each component querying the license server to determine whether the component is linked to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem.

In another aspect some embodiments described herein provide a system for dynamic development and deployment of computing applications such as e.g. a media application comprising a development framework comprising a software development kit components data containers pins and graphs wherein the software development kit is used to define components graphs data containers and blueprints. Each component may define a computer processing mechanism for processing data containers at application runtime. Each graph may be a template of a set of components and each blueprint may be an embodiment of a graph a visual design subsystem configured to output graphs and blueprints to develop computing applications using components compound components and other graphs wherein the visual design subsystem is operable to arrange components into functional blocks and define specific orders of operation for the functional blocks a deployment subsystem for deploying computing applications at runtime comprising a repository cloud agent and cloud engine. The computing applications identify graphs blueprints compound components and components. The repository is configured to store graphs and components for loading at application runtime. The cloud engine provides a running environment for graphs and executes graphs at application runtime to instantiate computing applications. The cloud agent may control and manage the cloud engine. At runtime the deployment subsystem may dynamically construct and deploy a computing application by sending a request at runtime to the repository for the graphs compound components and components identified in the computing application. The deployment subsystem is operable to deploy a computing application by at runtime retrieving transferring downloading and so on the graphs blueprints etc. from the repository. The components graphs blueprints may not be present in the computing application and they may be pulled dynamically to create the computing application at runtime. They may also pre exist locally due to previous availability cache or through user intent e.g. a job manager persists the availability because the job is going to repeat .

In accordance with some embodiments the deployment subsystem may further comprise a license server which may dynamically manage licenses and associate licenses with components and graphs. Use of components and graphs identified in a computing application requires the appropriate license.

In accordance with some embodiments the deployment subsystem may further comprise a job manager which dispatches cloud engines based on available licenses managed by the license server.

In accordance with some embodiments the deployment subsystem may further comprise a security manager which provides for secure connections and communications between system components.

In accordance with some embodiments the deployment subsystem may further comprise a job manager configured to provide job and engine dispatch failover tracking and reporting. The job manager may also be configured to provide the highest level of access to the running cloud engines and provide centralized access to the cloud engines regardless of state running or not . The job manager may further self extend interfaces e.g. web services based on the graph blueprint that is loaded on the cloud engine to provide a namespace similar to the web which may allow the developer to discover which graphs components are used in that particular application query set parameters and so on.

In accordance with some embodiments a graph may define a set of components where components in the set are connected by different types of pins.

In accordance with some embodiments a data container may define a data type and a data object wherein the data type is metadata describing the container and the data object maintains raw data.

In accordance with some embodiments the repository is operable to manage versioning of components and graphs to keep track of updates made thereto. The repository serves the components and graphs at application runtime using appropriate versions of the graphs and components.

In accordance with some embodiments the cloud agent is provided to each user system to manage the local resources of the user system. The cloud agents interact with cloud engines to execute graphs in order to run computing applications.

In accordance with some embodiments the system may further comprise a normalization module operable to receive input files and convert and parse the input files into data containers to be processed by a graph.

In accordance with some embodiments the system may further comprise a code signing module operable to digitally sign each component to associate a developer license with each component.

In accordance with some embodiments the system may further comprise a translation module operable to translate multiple languages into a common language for system.

In accordance with another aspect embodiments may provide a method for dynamic development and deployment of computing applications such as media applications for example comprising providing a development framework comprising a software development kit components data containers pins and graphs. The software development kit may be used to define the components graphs and data containers. Each component may define a computer processing mechanism for processing data containers of media data at application runtime. Each graph may define a set of components along with specific connections between the components and properties for the components providing a visual design subsystem to define and output graphs wherein graphs may be used to realize and create computing applications using the visual design subsystem to arrange components into functional blocks and define specific orders of operation for the functional blocks including connections between the functional blocks providing a deployment subsystem for deploying computing applications at runtime comprising a repository cloud agent and a cloud engine. The computing applications may identify graphs compound components and components. The cloud engine may provide a running environment for graphs and executes graphs at application runtime to instantiate computing applications. The cloud agent controls the cloud engine storing components and graphs output by the visual design subsystem in the repository for loading at application runtime and at application runtime dynamically constructing and deploying a computing application by sending a request at runtime to the repository for the graphs compound components and components identified in the computing applications.

In another aspect embodiments described herein provide a system for dynamic development and deployment of computing applications comprising a development framework comprising a software development kit components data containers pins and graphs. The software development kit may be used for defining the components graphs blue prints and data containers. Each component may define a media processing mechanism for processing data containers of computing data at application runtime. Each component may be associated with one or more versions. Each graph may be a template identifying components and used to generate a corresponding blueprint. A blueprint may be a final embodiment of the graph and may comprise a reference to a solution set of components where the solution set of components may identify a version for each component a visual design subsystem configured to define and output graphs in order to realize and create computing applications. The visual design subsystem may be operable to arrange components into functional blocks and define specific orders of operation for the functional blocks including connections between the functional blocks. The visual design subsystem may be further configured to define a solution set of components by identifying a version of each component a deployment subsystem for deploying computing applications at runtime comprising a repository one or more cloud agents and one or more cloud engines. The computing applications identify graphs compound components and components. The repository may be configured to store graphs blueprints and components for loading at application runtime. The cloud engine may provide a running environment for graphs and may execute blueprints of the graphs at application runtime to instantiate computing applications. The cloud agent may be operable to control the cloud engine wherein at runtime the deployment subsystem dynamically constructs and deploys a computing application by sending a request at runtime to the repository for the graphs blueprints compound components and components including appropriate versions thereof identified in the computing applications.

In a further aspect embodiments described herein provide method for dynamic development and deployment of computing applications providing a development framework comprising a software development kit components data containers pins and graphs. The software development kit may define components graphs blueprints and data containers. Each component may define a computer processing mechanism for processing data containers of computing data at application runtime. Each component is associated with one or more versions. Each graph may be a template identifying components and may be used to generate a corresponding blueprint. A blueprint may be a final embodiment of the graph and may comprise a reference to a solution set of components where the solution set of components identifies a version for each component providing a visual design subsystem for defining and outputting graphs in order to develop media applications and for defining a solution set of components by identifying a version of each component using the visual design subsystem to define a graph by arranging components into functional blocks and defining specific orders of operation for the functional blocks including connections between the functional blocks where the graph references a solution set of components using the visual design subsystem to define a solution set of components referenced by the graph by receiving a selected version for each component in the solution set of components providing a deployment subsystem for deploying computing applications at runtime comprising a repository one or more cloud agents and one or more cloud engines. The media applications identify graphs compound components and components. The cloud engine provides a running environment for graph and executes blueprints of the graphs at application runtime to instantiate computing applications The cloud agent may be operable to control the cloud engine storing components and graphs output by the visual design subsystem in the repository for loading at application runtime and at application runtime dynamically constructing and deploying a computing application by sending a request at runtime to the repository for the graphs compound components and components including appropriate versions thereof identified in the computing application.

In another aspect embodiments described herein provide a system for dynamic development and deployment of computing applications comprising a development framework comprising a software development kit components data containers pins and graphs. The software development kit may be for defining the components graphs blue prints data containers. Each component may define a media processing mechanism for processing data containers of computing data at application runtime. Each graph may be a template identifying components and may be used to generate a corresponding blueprint. A blueprint may be a final embodiment of a graph and a graph is the instantiation of a corresponding blueprint at application runtime a digital certificate associated with a component provider subsystem where the component provider subsystem provides one or more components of the development framework 

a digital certificate associated with user computing subsystem where the user computing subsystem is associated with a computing application where the computing application involves a component provided by the component provider computing system a visual design subsystem configured to define and output graphs in order to develop computing applications where the visual design subsystem is operable to arrange components into functional blocks and define specific orders of operation for the functional blocks a deployment subsystem for deploying computing applications at runtime comprising a repository one or more cloud agents and one or more cloud engines. The computing applications identify graphs compound components and components. The repository may be configured to store graphs and components for loading at application runtime. The cloud engine may provide a running environment for graph and may execute blueprints of the graphs at application runtime to instantiate computing applications. The cloud agent is operable to control one or more cloud engines. The deployment subsystem may further comprise a license server configured to digitally sign a component by linking the component to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem to indicate that the user computing system and the component provider subsystem accept performance or conformity of the digitally signed component where performance may relate to runtime performance service level agreement and other measures of performance wherein at runtime the deployment subsystem dynamically constructs and deploys a computing application by sending a request at runtime to the repository for the graphs blueprints compound components and components identified in the computing applications. Prior to deploying each component the deployment subsystem may query the license server to determine whether a component is linked to a digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem.

In a further aspect embodiments described herein provide a method for dynamic development and deployment of computing applications comprising providing a development framework comprising a software development kit components data containers pins and graphs. The software development kit may define components graphs blueprints and data containers. Each component may define a computing processing mechanism for processing data containers of computing data at application runtime. Each component may be associated with one or more versions and each graph may be a template identifying components and may be used to generate a corresponding blueprint. A blueprint may be a final embodiment of a graph and a blueprint may be used to instantiate a graph at application runtime providing a digital certificate to a component provider computing system where the component provider computing system provides one or more components to the development framework providing a digital certificate to a user computing subsystem where the user computing subsystem is associated with a media application and where the computing application involves a component provided by the component provider computing system providing a visual design subsystem for defining and outputting graphs in order to develop computing applications and for defining a solution set of components by identifying a version of each component using the visual design subsystem to define a graph by arranging components into functional blocks and defining specific orders of operation for the functional blocks where the graph may reference a solution set of components providing a deployment subsystem for deploying computing applications at runtime comprising a repository one or more cloud agents and one or more cloud engines. The computing applications may identify graphs compound components and components. The cloud engine may provide a running environment for graphs and may execute blueprints of the graphs at application runtime to instantiate computing applications. The cloud agent is operable to control the cloud engine receiving at a license server acceptance of the component provided by the component provider subsystem in the computing application associated with the user computing system by receiving the digital certificate from the user computing subsystem and the digital certificate from the component provider computing system linking at the license server the component provided by the component provider subsystem in the computing application associated with user computing system to the digital certificate from the user computing subsystem and the digital certificate from the component provider computing system storing components and graphs output by the visual design subsystem in the repository for loading at application runtime and at application runtime dynamically constructing and deploying the computing application associated with the user computing subsystem by sending a request at runtime to the repository for the graphs compound components and components identified in the computing application and prior to deploying the component provided by the component provider computing system querying the license server to determine whether the component is linked to the digital certificate associated with the user computing subsystem and the digital certificate associated with the component provider subsystem.

Variations and combinations may also be provided by the embodiments described herein. Additional aspects of various example embodiments are identified and described in the following description.

The drawings described below are provided for purposes of illustration and not of limitation of the aspects and features of various examples of embodiments described herein. The drawings are not intended to limit the scope of the teachings in any way. For simplicity and clarity of illustration elements shown in the figures have not necessarily been drawn to scale. The dimensions of some of the elements may be exaggerated relative to other elements for clarity. Further where considered appropriate reference numerals may be repeated among the figures to indicate corresponding or analogous elements.

It will be appreciated that numerous specific details are set forth in order to provide a thorough understanding of the exemplary embodiments described herein. However it will be understood by those of ordinary skill in the art that the embodiments described herein may be practiced without these specific details. In other instances well known methods procedures and components have not been described in detail so as not to obscure the embodiments described herein. Furthermore this description is not to be considered as limiting the scope of the embodiments described herein in any way but rather as merely describing implementation of the various example embodiments described herein.

The embodiments of the systems and methods described herein may be implemented in hardware or software or a combination of both. However these embodiments may be implemented in computer programs executing on programmable computers each computer including at least one processor a data storage system including volatile and non volatile memory and or storage elements and at least one communication interface. For example the programmable computers may be a server network appliance set top box embedded device computer expansion module personal computer laptop personal data assistant cloud computing system or mobile device. A cloud computing system is operable to deliver computing service through shared resources software and data over a network. Program code is applied to input data to perform the functions described herein and to generate output information. The output information is applied to one or more output devices to generate a discernible effect. In some embodiments the communication interface may be a network communication interface. In embodiments in which elements are combined the communication interface may be a software communication interface such as those for inter process communication. In still other embodiments there may be a combination of communication interfaces.

Each program may be implemented in a high level procedural or object oriented programming or scripting language or both to communicate with a computer system. However alternatively the programs may be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language. Each such computer program may be stored on a storage media or a device e.g. ROM or magnetic diskette readable by a general or special purpose programmable computer for configuring and operating the computer when the storage media or device is read by the computer to perform the procedures described herein. Embodiments of the system may also be considered to be implemented as a non transitory computer readable storage medium configured with a computer program where the storage medium so configured causes a computer to operate in a specific and predefined manner to perform the functions described herein.

Furthermore the system processes and methods of the described embodiments are capable of being distributed in a computer program product including a physical non transitory computer readable medium that bears computer usable instructions for one or more processors. The medium may be provided in various forms including one or more diskettes compact disks tapes chips magnetic and electronic storage media and the like. The computer useable instructions may also be in various forms including compiled and non compiled code.

Embodiments described herein may relate to various types of computing applications such as media applications resource related applications voting applications user registration applications integrity management applications and so on. By way of illustrative example embodiments may be described herein in relation to media applications.

Referring now to there is shown a block diagram of a system for dynamic development and or deployment of computing applications in accordance with an example embodiment. By way of example a computing application may be a media application. A media application may be a computing application designed to perform specific tasks and activities for manipulating media data using a combination of hardware and software computing components. For example the media application may involve processing media data performing operations on the data to carry out specific functions completing tasks controlling components producing transforming or delivering media data or a combination thereof. The media application may generate a deliverable or transform a deliverable for provision to output devices and for generation of a discernable effect such as by transforming received input media data into a deliverable for example. The media application may process transform and manipulate input data streams to generate a complete media program for display broadcasting distribution and so on. For example playback of the input data stream may be discernably different from playback of the deliverable generated or transformed by the media application.

The system may scale from simple media applications run on a local computer to complex media applications deployed on a cloud computing system. A cloud computing system is operable to deliver computing services through shared resources software and information over a network. The system may be operable for multiple platforms e.g. Windows Linux OS X and multiple languages e.g. C Java Scripting and may use standards based interfaces e.g. SOAP XML .

The system may be implemented as a cloud computing system and may be accessible to users through an external interfaces layer which may allow integration with existing processes applications and systems. The system may include a development framework and a visual design subsystem to define and output graphs in order to develop media applications. The system may include a deployment subsystem for dynamically deploying media applications at runtime. The system may provide a platform for building developing and deploying professional workflow applications for desktop networked and cloud based systems.

By way overview the development framework may be used for the development of component and workflow e.g. graphs blueprints technologies. The repository may provide a centralized pool of component technologies and workflow blueprints and may act as both the warehouse and supply chain for syncing upstream downstream repositories . The visual designer may be used to design and test workflow graphs and blueprints . A license server may control authorization of component technologies. The system may provide one or more of the following features multi platform support through the framework SDK multi language support allows native development in multiple languages such as C Java and scripting languages support for flexible workflow models with inline parallel and staged execution of individual processes consistent management interfaces through standards based web services regardless of workflow complexity or scope dynamic scalability allows for simple and complex solutions to easily scale to large volume processing capabilities with low provision and deployment costs. Other features may also be provided by system as described herein.

The system may enable decomposition of hardware and software problems into their core elements. These core elements may be referred to as components . By breaking down multiple problems a catalog of components may be developed that can be brought together in different ways e.g. by graphs blueprints to solve new problems. For example a user may want to perform video compression and send email notification upon completion. These two problems are very different but by combining elements of the video compression problems that is components for video codec multiplexer and file writer and the email problem that is components for database lookup report generator and email engine system can combine the two into a complete solution that not only performs the core video compression but may also sends out notification emails to the users who need to be notified of the project completion.

The system may enable registration of the components into a repository of technology used to store manage and access these technologies in a controlled environment that may be centralized or distributed. The system may allow these repositories to be chained together into managed supply chains where downstream repositories can be synced with upstream repositories .

The system may control access to components using a floating license server which may check out licenses when components are being used.

The system may provide a communication management bridge between a higher level application and the cloud engines which run jobs. The cloud agents may provide that bridge. The cloud agents may provide a consistent web services integration and management point regardless of the complexity of the solution.

The system may provide a method for creating workflow solutions graphs blueprints from components . The visual designer may be implemented as a visual design tool which allows new solutions to be created tested and saved as graphs or blueprints that can be referenced by an application. Blueprints can also be stored in the repository becoming part of the managed supply chain.

The system may run cloud engines to execute jobs. When the application sends a command to the cloud agent to run a job the cloud agent determines which components are required to start running the solution and acquires those components from the repository . For example the cloud agent creates the cloud engine the cloud engine loads the graph or blueprint acquires the required licenses from the license server and runs the job. The cloud engine may dynamically acquire new component licenses on the fly as required by the currently running workflow. When the job is complete the licenses are returned to the pool of licenses managed by the license server .

The development framework may include components compound components components embedded within other components data containers graphs and blueprints . The development framework may be accessible through a software development kit SDK web services or by using the visual design subsystem . Both the SDK and the visual design subsystem may be used to develop components compound components and graphs and to define new data types to define new data containers . System may provide a graph based processing engine where graphs are made up of reusable components with discrete processing functions. The system may also provide the framework for development and deployment of graphs and components . As noted above the development framework may be accessible through web services where a user may create graphs and components using the web services application programming interface.

As noted the SDK may be used to define components graphs data containers and other features of the system . The SDK may be language independent. An example of the SDK in Java is 

The framework API may be used to create the graphs used by an application to control loading and executing graphs and to provide status to the application.

Separating the component API from the framework API may allow component developers to focus on the development of a component without requiring knowledge about the logistics of the whole environment.

The SDK may include application programming interface in multiple languages such as java C for example to create components. Components may be created using one or more languages.

Components are building blocks of the system . A component is an object plug in or set of software code that defines a processing mechanism and uses the SDK to interact with the development framework . At application runtime a component is configured to process data flowing through the component as a data container . Each component may be a single component or a compound component built up of multiple embedded components . A component may contain plug in files and other files such as jar files dlls and so on.

Referring now to there is shown a block diagram of example components in accordance with an example embodiment. Examples of components for a media application context include video input video process file sink logic branch decisioning and routing based on criteria such as for example video format strip letterbox and aspect ratio . Other examples of components are shown in such as file source interlace detector film removal deinterlacer noise reduction buffer file sink YUV to RGB image converter flow control file input color space converter scaler and AVC encoder

Components may have properties and values for those properties. A component s properties configure its behavior. The properties provide runtime information transient information results and so on. Referring now to there is shown a table representing example properties and values of an example component file source in accordance with an example embodiment. Examples of properties include description configuration warning default input pin default output pin description file name last error log progress read buffer size and so on. Each property may have an associated value . A component s properties may be set and modified through the visual design subsystem or other interface.

Properties modify the way a component behaves such as how it processes data or the type of output it produces. For instance properties can be used to change the format of a component s output or provide scaling information. Properties can be thought of as instance variables for components . Properties can be exposed to other components through pins.

Property attributes may change the way a property is used exposed and saved. They may be set in the property declaration in the plugin.xml file. For example properties may have one or more of the following attributes transient when a graph is saved to file property values may be saved with it by default however if a property is transient its value may not be saved and the default value may be used when the graph is loaded from file required the property must be set for the component to run hidden the property is used internally by a component and may not be visible to a user advanced the property generally does not need to be modified by the user but may be of interest to experienced users interprocess the property may be accessible to processes that are spawned by its graph and so on.

Properties can be exposed on pins. A property exposed on a pin can be written to or read by another component. The name of a property pin is the same as the name of the property defined in the property declaration. The property pin s display name in the visual designer may be the same as the property name unless a pin display name is provided. Properties may be declared within component definitions in the plugin file such as a plugin .xml file for example.

Example attributes of properties may include property name display name description required advanced hidden transient interprocess value type and initial value. A property may be defined as advanced if it generally does not need to be modified but may be of interest to experienced users. For example setting the attribute advanced true may hide the property in the visual designer . The property may become visible when an advanced box is selected in the visual designer . Setting hidden true may hide the property in the visual designer . The property may become visible when a hidden box is selected in the visual designer . When a graph is saved to file the property values of its components may also be saved. Setting transient true may result in the property value not being saved. The default property value may be used when the graph is loaded from file. Setting interprocess true may make a property accessible to processes spawned by its graph. A property initial value may be the default value of the property when the component is initially instantiated.

Property values may be restricted. For example property values may be restricted to strings numbers integers range of numbers defined by a minimum and a maximum and so on. Property value restriction attributes may include a minimum value a maximum value a list of enumerated values data type for values and so on.

An attribute property initial value may set the initial value of a property that has been declared elsewhere for example if a property has been declared in an inherited component in the component s source code or in the framework itself . An example use of property initial value may be for instructing a C or dual Java C component how to construct its native peer.

Components may be language independent and may be developed by different developers in different languages and used together to create a graph blueprint or compound component .

Each component may have one or more versions. A version is a specific form or state of the component and may reflect new developments or implementations of the component . Each version of a component may be referenced using a version name or number. For example each version may be assigned a number in increasing order. As will be explained herein in relation to the system maintains versioning to keep track of and use different versions of components in graphs blueprints and compound components . This may result in more flexible system as different versions of the same component may be usable by graphs media applications and users and each are not required to use the same component and version thereof.

Components may be written for different architectures or contexts such as 32 bit and 64 bit architectures. As will be explained herein system is operable to develop and deploy an application instance which combines components written for both 32 bit and 64 bit architectures. For example system is operable to detect whether a particular media application has been developed using both components for 32 bit architectures and components for 64 bit architectures. If so system is operable to create a separate process space or instance for each context and handle inter process communications using mapping and a shared memory. For example the system is operable to create a 32 bit architecture process instance and a 64 bit architecture process instance and manage communications between the process instances.

Further components may be self contained and isolated from a dependency point of view. The entire dependency set of a component may be self contained being specified and packaged in the component distribution unit e.g. plugin . The component dependencies may also be isolated referring exclusively to the specific component and version s they depend on. This may enable the system to realize complex workflows while resolving components dependencies without user intervention. Further the dependency isolation may allow the system to provide distinct behavior while executing blueprints built with the same components by isolating the different versions of these components and their dependencies.

Components may have pins. Pins connect to pins on other components . Pins may be referenced by name. Pins may connect to multiple components which may be referred to as branching. In accordance with some embodiments described herein components do not have to be of the same type to connect to the same pin.

There may be different types of pins. There may be input pins such as an input push and input pull which can be used to decouple components with different fundamental architectures. A push pin pushes its output to the next pin and a pull pin calls for data on its input pin. The pin model controls the flow of data between components. There are output pins. There are control pins including event out property in out and command in pins.

Pins may be used to pass data between components . Pins may expose properties and events and may be used to trigger commands. Static pins may be defined within the component definition in the plugin.xml file and may be created every time a component is instantiated. Dynamic pins may be defined within the component source code and may be added after the component has been instantiated.

Input and output pins may be defined as default pins. A default pin may not need to be referred to by name in the component source code. There may be only one default input pin and only one default output pin per component.

As noted herein there may be different types of pins. For example an OUTPUT PUSH pin is a type of output pin. Data may be sent through an output pin to the next component s input pin. INPUT PUSH and INPUT PULL are two different types of input pins. When using a push input pin a component may process data as it arrives on the pin. When using a pull input pin a component may request data from the pin blocking until data arrives. Pull input pins may be used in situations where there is more than one input pin on a component and the data coming in through each pin needs to be controlled and coordinated. OUTPUT IO and INPUT IO pins are further examples. I O pins act as both input and output pins and are typically used to pass data between graphs or as output and input pins in compound components . A PROPERTY pin may expose a component s property so that it can be read or modified by other components . There may also be EVENT pins. When an event occurs the data object generated by the event may be encapsulated in a Data Container that may be pushed onto the event pin. If the event generates a null object an empty Data Container may be placed on the pin. The propagation of a Data Container on an event pin signals that the event has occurred. COMMAND pins act as triggers to call commands on components. When a data container is placed on a command pin the command is executed. The data on the data container may be used by the command but it does not need to be.

Pins may set data types. For example a data type feature may provide information to the end user about a component s expected input and output types. This may be useful at graph design time to ensure the compatibility of connected components. Once the graph starts data types describing the actual data passing between components may be used. A warning may be generated when incompatible pins are connected. The data type of a static pin may be set in the pin declaration using a data type definition name. The data type definition name may take the name of a data type definition which is a set of key value pairs that describe features such as image dimensions audio format and encoding format. For example a pins data type for an input push pin may be set to integer.

The data type definition may be the default data type of an unconnected input pin. When components are connected the input pin may acquire the data type of the output pin it is connected to. A component s default output pin may acquire the data type of the component s default input pin unless the pins have been decorrelated. All other output pins may use their own data type definition names to set their data types.

A data type transform may be used to change the default output pin s data type. A data type transform may add or remove data type definitions from the output pin s acquired data type. Consider the following example where the default input pin is defined with a data type of integer. When the component is instantiated the default input pin and the default output pin may both have the same data type namely the integer data type. To change the default output pin s data type to string a data type transform may be used to remove the number data type definition of which Integer is a subtype and add the string data type definition.

Data type restrictions may be used to provide more detail about what types of input a pin can accept. While setting a data type on a pin may act a simple data type restriction setting a formal data type restriction on the pin can narrow down the type of data that is acceptable. Explicit data type restrictions may override the restriction implied by the pin s data type. Data type restrictions may be nested using logic operators AND OR NOT . The syntax for data type restrictions may follow prefix notation. For example say you want your pin to accept all numbers that are not integers numbers AND NOT integer and in prefix notation this may be AND number NOT integer .

There may be a pin definition schema. A component s static pins may be declared in its definition. Static input output event command and property pins may be declared in the component definition. In the case of event command and property pins the name of the pin may need to match the name of the event command or property respectively. A pin s data type may be defined in the plugin.xml file using a data type definition name data type restrictions and data type transforms can also be set within the plugin.xml file.

A pin definition may include a name type default data type and display name. For a pin name upon compiling the plugin.xml a constant of the form PIN  may be generated. The pin may be referenced in source code using this constant. For example the constant PIN file may be generated for a pin named file . Input output event and command pins may be displayed on the component with this name in the visual designer . Property pins may have a different display name. The alternate display name may be set in the property declaration. Pins can be of type INPUT PUSH INPUT PULL OUTPUT PUSH COMMAND PROPERTY OUTPUT IO INPUT IO or EVENT. A default may be used with input or output pins. There may be only one default output pin and only one default input pin per component. Setting default to true may indicate that this pin is the default pin to use when referring to this type of pin. The data type definition may define the expected input or output data type. The pin data type may act as a data type restriction on an input pin. The display name may be the pin name displayed in the visual designer . If the display name is set on a property pin for which the defined property also has a display name the pin display name may appear on the component and the property display name may appear as the property name.

A data type restriction may be used to restrict the type of input a pin can accept. When an output pin with a data type that does not meet the restriction conditions is connected to the pin a warning may be generated. Data type restrictions may override restrictions based on the pin s defined data type. Data type restrictions may be combined using logic operators to create complex restrictions. The syntax of the data type restriction may follow prefix notation. Example restrictions include string number integer and so on. Logic operators AND OR and NOT may be used to create complex data type restrictions.

A data type transform of a default output pin may be set by the default input pin s data type. If the default output pin will be producing output which is different than the input pin s data type a data type transform may be used to change its data type. The data type transform may remove parts of a data type definition or entire definitions. It can also add data type definitions to a pin data type

The set of components that represent a workflow may be saved as a graph . Data is encapsulated in data containers that may be passed between connected components in a graph . Data containers may consist of raw data as well as meta information about the data.

Graphs can be created saved and loaded programmatically or with the visual designer . The visual designer is a visual design tool for creating testing and saving workflows.

Workflows can be saved as graphs or as blueprints . Blueprints are graphs with attached meta data. Graphs blueprints and components may be registered into a repository that is used to store manage and access components and blueprints in a controlled environment that may be centralized or distributed. Repositories may be chained together into managed supply chains where downstream repositories can be synced with upstream repositories .

Access to components may be controlled through a floating license server . A component s license may be checked out when it is being used.

Applications that use graphs may submit their jobs to an agent which may be a web service interface. The agent may acquire the graph s components from the repository and launch engines to run the jobs. The engines may load the graphs or blueprints and may acquire the licenses needed to run the job. Once the job is complete the licenses may be returned to the license server .

A component development steps may include one or more of the following designing the component and its interface including a determination of which features and elements the component may need saving the design that defines the component in a file for use in graph such as in a plugin.xml file where the design of the component may also include the features and elements of the component writing and storing the component s source code. Component definitions may be used to instantiate components as a component definition may contain all the information required to instantiate a component including declarations for properties commands events and static pins.

Examples of properties may include a name class name unique identifier such as a GUID for example a description and a category. A component may be declared with a name and an example of which is may be a Java class name and a unique GUID. Upon compiling the plugin.xml a constant of the form NAME  may be generated. The component s name may be referenced in source code using this constant. For example the constant NAME AudioMixer may be generated for a component named AudioMixer .

The class name property may reference the component constructor class. For example when writing a Java or Dual component the component s Java class may be used or when writing a C component may use uniform NativeComponent class.

Each component may have a unique identifier which may be referred to as a GUID. The unique identifier may be for component licensing. For example upon compiling the plugin.xml a constant of the form GUID  may be generated. The component s GUID may be referenced in source code using this constant.

The category property may reference the categories to which the component belongs. Categories may be used for grouping components in a display such as in the visual designer . Each category may be defined within its own element. You may create subcategories by separating the category names with forward slashes. For example if you defined the category as Company X Audio the component would appear in the Audio subcategory of the Company X category.

A component s definition may declare pins dynamic and static properties events commands and capabilities. These elements can be used modified and managed in the component source code. When a component s plugin.xml file is compiled header and jar files may be generated. These files declare string constants that correspond to the component elements.

A data container holds the media data that flows between components . The data container may define a data type and data object. The data type may be metadata describing the data container and may include key value pairs of information e.g. width height . The data types may be configured to implement inherency and hierarchies. Examples of data types include image dimension width height and pixel format color space bits per sample . The data object may be the raw data such as in the form of a buffer string and so on. Examples of data objects include file name string audio sample buffer video frame buffer asset XML and so on.

A data container may include a timestamp in relation to the media data stored therein as the data object. Media data packets typically need to be associated with a timeline as they are received and processed to maintain sequencing and timing. Including a timestamp for the media data stored in the data container enables non linearity of processing and decouples the processing of the media data from the timeline typically associated with media data. A data container may define a normal form for the input data to be processed by graphs and blueprints . A data container may associate raw data with a data type so that both the raw data and data type flow as a unit to provide concurrency multiprocessing which may enable the context to switch at the data container boundaries and so on. Data containers may include an individual timestamp with reference to the raw data to decouple the raw media data from its state dependent on a timeline. Data container properties may include read only write only and read write. This may be useful if for example a data container reaches a branch and needs to be duplicated. One data container may be marked read only so that the contents cannot be modified while a separate operation is processing the contents of the duplicate data container for example.

Referring now to there is shown a block diagram of example data container metadata raw buffer that flows between two components video process and strip letterbox

Data may be passed between components as data container objects. A data container may include a raw data object and a data type object describing the contents of the raw data. A data type object may be a collection of key value pairs. Its keys may be defined in one or more data type definitions defined in plugin.xml files for example. Data type definitions may describe features such as image dimensions audio format and encoding format. Data type definitions may be inherited and extended.

Data types may consist of a set of keys that accept values of a certain type. The values of the keys can be of either simple or complex types. A simple type may be a primitive type such as INTEGER BOOLEAN or STRING while a complex type may be a type where the key s value is itself a data type. Data type definitions may be defined in plugin.xml files for example. A data type definition may include keys and their value types and inherited data type definitions. Data type definitions may be defined using the data type definition schema. A data type definition may have attributes or properties such a name used to reference the data type definition comments which may include information about what the data type definition refers to and how and when it should be use which may appear in the Data Type frame of the visual designer help interface inherits a data type definition can inherit and extend other data type definitions and so on.

Data type definitions should be decoupled from component definitions. As such separate plugin.xml files may be used for data type definitions and for your component definitions. If you have defined your own data type definition you may need to compile its plugin.xml file before using it. Compiling its plugin.xml may generate a header and class file for each defined data type. These may automatically be exported to an SDK installation.

Data type definitions declare a set of keys used to describe raw data. Key value types are specified in the key definitions. Acceptable values for the keys can be specified explicitly in the declaration. Examples definitions include channel configurations language and so on.

Key definitions may have attributes or properties. Examples include simple type complex type which indicates whether the key s type is a simple type the value is a primitive type or a complex type the value is a data type key name which may be used to reference the key definition key comments which may include a description of what property of the raw data the key refers to the key s value type which may be simple primitive type for example INTEGER STRING BOOLEAN or complex a DataTypeDefinition where this type should agree with the simpleType complexType tag multivalued which indicates that the key may accept a list of 0 or more values such as for example the audio channel details key may have as many values as there are audio channels and enumeration value which enumerates all possible values for the key. If a key can only have certain acceptable values these can be listed as enumerationValues. EnumerationValues may be referenced in the source code using string constants of the form VAL  . For example the ISO639 1 value of the language standard key may be referred to by the constant VAL language standard ISO639 1.

A plugin package may be a grouping of data type definitions and component definitions defined in a plugin.xml file for example. A plugin package can consist of more than one component or data type definition. The plugin may also contain libraries header files and Java files that may be used to load and support its components or data types.

Data type definitions and components may be distributed in plugin packages. The framework may be shipped with plugin packages. Additional functionality can be added to the framework by purchasing or developing additional plugin packages. Licenses for the framework and its components may be included in a license package. A properties file may be included in the SDK package and may be edited to point to the license server .

Components data type definitions and plugin packages can be created using the SDK . Each component created may have a unique GUID and each plugin created may need to be signed. A license package may include GUIDs and a signing key.

Plugin package attributes may be defined within plugin.xml files. Component definitions and data type definitions may be defined within the plugin package definition in the plugin.xml file. The plugin package definition may require a name a unique pluginID a plugin version and optionally a provider and description. The name is the name of the plugin the plugin ID is a name that is unique to each plugin to guarantee uniqueness the pluginID may be structured using a reverse domain name for example a pluginVersion refers to the plugin version a provider refers to the organization providing the plugin and description provides a description of the plugin. This should include the type of components or data type definitions that are distributed in the plugin package.

All plugin packages may be signed. Signing guarantees authorship and prevents unauthorized modification of the plugin package. Signing may happen automatically when the plugin.xml file is compiled. At compile time a private key is requested from the license server. A signature is then generated using this private key. A public key the plugin certificate is also generated. When the plugin package is loaded the certificate is used to verify that the plugin package has not been modified from build time. If the plugin package has been modified or if it has not been signed it will not load.

Plugin packages may be compiled using a gradle tool. Plugin packages even those which do not contain source code may be compiled to generate header files and files that are used to instantiate their components and data type definitions. Compiling the plugin package automatically signs your plugin package and installs it in the SDK installation. The framework may use gradle to build plugin packages. A SDK installation may come with template gradle build files build.gradle for different types of projects.

A graph may be a template describing a set of components including compound components other graphs the parameter values for the components and the connections between the pins of the components . A graph may define a set of components having specific connections and have specific properties with values . A graph may define a set of components having specific connections and having specific properties. A graph may be referenced within another graph by a label to dereference from the underlying graph . This may be useful for versioning as described herein.

A blueprint may be a final embodiment of a graph and may reference a solution set of components using a label. A blueprint may be used to instantiate a graph at application runtime and may also meta data such as include business logic about the graph . A blueprint may connect the functionality of a graph to a running environment. A solution set of components may be a set of specific versions of components. A blueprint may form part of the repository . Blueprints may be viewed as a business level container of graphs . A blueprint may include one or more graphs as part of a single life cycle of the application which may be executed nested or in parallel or multiple graph stages may be executed in serial form one after the other. A blueprint may be a container of one or more graphs . A graph can contain other graphs but all run in one lifecycle whereas the graphs contained at the blueprint level may run simultaneously or sequentially.

A graph can be represented as a file e.g. XML file in its blueprint form or as dynamically instantiated object code at runtime. Graphs may be viewed as having two lives as a running live instance and as a description of how that instance is saved for communication transportation distribution or storage needs. In the live context it will be referred to herein as a graph . In the description context for reference in communication transportation distribution or storage needs it may be referred to herein as a blueprint

A graph and blueprint may contain components compound components and may contain other graphs compound graphs . A compound graph can be exported and referenced as a single component . The system is operable to reference components compound components graphs blueprints and compound graphs in the same manner.

Referring now to there is shown a block diagram of an example graph surrounded by a blueprint e.g. final embodiment of the graph in accordance with an example embodiment. The graph is a compound graph and includes an outer graph and an inner sub graph both of which contain components file source interlace detector film removal deinterlacer noise reduction file sink . The components and graphs may be connected by pins.

A graph and blueprint may be used by system to develop and deploy a media application and may be loaded from the repository at application runtime. A graph and blueprint can simultaneously handle source data in one or more of its possible forms in a component .

As shown in components compound components graphs compound graphs and data containers are maintained in one or more linked repositories . A graph may implement a variety of processing roles such as an installer manager and executor.

A component s lifecycle is connected to that of its parent graph . Different component methods may be called during different graph lifecycle states. Before a graph starts its components may be instantiated and connections may be made between them. Components can complete their configuration after they have been instantiated and before the graph starts. When a graph is loaded from file its components are instantiated as soon as the graph is fully loaded. Additional graph and component configurations may take place after the graph is loaded but before it starts. Once a graph starts its lifecycle may go through a realize pre process pre process sources start and sources stop states for example.

When a component has completed its processing it may move from the active state to the inactive state. A graph s lifecycle is done when none of its components remain in the active state. The graph may be able to keep track of the state of its components unless these components start their own worker threads. If a component starts its own worker thread it is responsible for setting its own active flag. A set active method may be used for this purpose for example. Once all components have become inactive the graph may enter the Finish state.

Component lifecycle actions include for example realize components load native libraries and perform self setup such as allocating memory and reading properties pre process and pre process components send their output data type information through the graph and any components that need data type information block until they receive it sources start source components start transmitting data components process data coming through their input pins sources stop source components stop transmitting data and processing continues until all data has passed through the graph abort a signal is sent to all components to cease activity and pass the abort signal to their threads and threads may exit their run loop as soon as possible and finish all components are inactive and all data transmission and processing has stopped .

If a component needs to perform lifecycle related actions they may need to implement the appropriate lifecycle method or function. Example component life cycle methods include post initialize post load from document life cycle realize life cycle pre process life cycle pre process life cycle sources start life cycle sources stop process life cycle abort and life cycle finish.

Post initialize may be called after the component has been instantiated while the graph is still in the initial state. It may be called to complete the configuration of the component by adding elements that can only be added once the component is initialized. Post initialize may be implemented to create a complex data type restriction add a property change listener set the data type on an output pin dynamically add pins to the component or perform property validation for example.

Post load from document may be called after a saved graph has finished loading and while the graph is still in the initial state. Post load from document may be implemented to configure a component based on its connections to other components in the graph for example.

Life cycle realize may be the first method called when the graph is started. There may be no data passing through the graph when life cycle realize is called so the component may only have access to its own properties and to data types. Life cycle realize may be implemented to create a worker thread worker thread is started in sources start or get and or verify properties that are set when the graph starts for example. If a property is only read during the realize state any changes made to the property value while the graph is running may not be picked up or used by the component. The changes may be picked up and used in subsequent executions of the graph.

Life cycle pre process may be called once the graph is started and all components are instantiated and configured. Empty data containers consisting of only their data types may be sent through the graph to prime components with run time data type information such as image sizes and video frame rates. Source components implement life cycle pre process to send their empty data containers through the graph. Life cycle pre process may be implemented to provide run time data type information to other components. With regards to life cycle pre process as data type information is passed through the graph to prime components the components that use the data type information can block in life cycle pre process until they receive the information they need to perform their configurations. Life cycle pre process may be implemented to block until your component receives data type information needed to complete its configuration or perform its processing or block sending data through the graph until the graph is completely configured for example.

For life cycle sources start once the graph has been primed and all the components are configured data can begin flowing through the graph. Components can start pushing data through the graph in life cycle sources start. Life cycle sources start may be implemented to transmit data through the graph or start a worker thread for example.

If source data running through the graph is stopped through external methods timed broadcast user controlled streaming life cycle sources stops may be called when a signal to stop the source is detected. Any source clean up stopping threads closing files etc. should be implemented in this method. Life cycle sources stops may be implemented to stop the source stream based on an external event for example.

The process method may be called any time data arrives on a component s input pin. The process method is where all data processing occurs. The process method is where data is retrieved from input pins and placed onto output pins. The process method may be implemented to transform data retrieve data from input pins push data onto output pins change or set properties and so on.

If an error occurs in the graph life cycle abort may be called. Life cycle abort is used to stop threads and close files. Life cycle abort may be implemented to stop worker threads or close files for example.

Life cycle finish may be the final method called in the graph lifecycle. It may be called when no components remain in the active state. Any final clean up needed to be done should be implemented in this method. Life cycle finish may be implemented to close files release allocations close socket connections or wait for internal threads to finish for example.

The repository is operable to manage versioning of components graphs and blueprints in order to keep track of updates variations and modifications made to components graphs and blueprints . The repository is operable to handle runtime libraries and engines used by graphs blueprints and components such that the repository is self managed with respect to versioning. The repository is further operable to receive the development framework to manage versioning of and updates to the development framework . That is the repository can load up to date versions of the development framework including runtime libraries and engines. The development framework may be loaded upon request so that appropriate and updated versions of the development framework are used. The graphs and blueprints are loaded at run time so that the appropriate version of the graph and each component in the graph is used. A blueprint may reference a solution set of components. A solution set of components is a set of components and specific versions of each component in the set. The blueprint may reference a solution set of components using a label. A blueprint may reference a solution set using a label in order to dereference from the specific components and versions of the solution set. That way if the solution set changes such as if a component is added or removed from the solution set or a version of a component changes in the solution set then the same label will reference the updated solution set without requiring modification to the blueprint containing the label. This may result in more efficient processing as a reduced number of modifications and updates are required. Further components may be self contained and isolated from a dependency point of view. The entire dependency set of a component may be self contained being specified and packaged in the component distribution unit e.g. plugin . The component dependencies may also be isolated referring exclusively to the specific component and version s they depend on. This may enable the system to realize complex workflows while resolving components dependencies without user intervention. Further the dependency isolation may allow the system to provide distinct behavior while executing blueprints built with the same components by isolating the different versions of these components and their dependencies. Processing errors may also be reduced as the system and user may not have to manually track and manually update components defined by blueprints or graphs when a label is used.

Referring now to there is shown a block diagram of an example interface for defining a solution set of components in accordance with example embodiments. In this example the interface displays different types of components along one axis and different versions of each type of component along another axis. In this example there are 6 different types of components and each type may be associated with a component identifier such as for example c1 c2 c3 c4 c5 c6. System may use the component identifier to reference a particular type of component.

There may be multiple versions of each type of component or some types of components may only have one version. For example a type of component c1 may have 8 different versions. Each version may be associated with a version identifier such as for example c1v1 c1v2 c1v3 c1v4 c1v5 c1v6 c1v7 c1v8. System may use the version identifier to reference a particular version of a specific type of component.

A solution set references a set of components and more particularly may reference a specific version of each type of component for use by a computing application. In this example the solution set is the specific version of each type of component that is intersected by a line c1v4 c2v3 c3v4 c4v1 c5v2 c6v1 . The solution set may be modified by changing a version of a specific component by removing a particular type of component by adding a new type of component and so on. The interface may provide a mechanism for a user to efficiently modify test and deploy different versions of components by changing the solution set. For example the interface may change a solution set by sliding a new version of a component to intersect with the line sliding all versions of a type of component line so that no versions of a particular type of component intersect with the line i.e. which may indicate that a particular component is no longer part of the solution set and so on. System is operable to test and deploy a modified solution set for a particular computing application and can also test all updates made to a solution set .

A blueprint is operable to reference a particular solution set using a label to dereference from the specific components and versions of the solution set. If the contents of a solution set changes then the blueprint label will reference the changed solution set without requiring modification to the blueprint . Multiple blueprints may reference the same solution set . A blueprint may also reference multiple solution sets . If a change is made to the solution set and a label is not used to dereference from the specific components and versions of the solution set then multiple blueprints may require updating and tracking as referencing the solution set in order to ensure that the blueprints reference the appropriate components and versions thereof.

Also in accordance with some embodiments a solution set may itself have a version number. The version number can be referenced by the label of the blueprint to identify which version of the solution set the blueprint is working with. In other embodiments a blueprint may ignore the version number and automatically update to refer to the latest version of the solution set. The solution set version number may provide a mechanism to maintain and create a history of solution sets as changes are made thereto.

The development framework enables complexity abstraction by defining an entire graph or blueprints as a component . A component which defines an entire graph may in turn be used in another graph or blueprint such that a graph may be embedded within another graph or blueprint . The graph or blueprint may reference the component using a label to dereference from the specific instance of the component . That way if the component is modified then the label of the graph or blueprint will reference the modified component without requiring additional modification to the graph or blueprint . That is the graph or blueprint will automatically update to reference the modified component by virtue of the label reference. The development framework also provides properties redirection through the ability to expose a component property as a property of an enclosing graph . The development framework further enables modular and recursive construction of graphs through the use of pre packaged graphs and components .

Commands along with events provide a means for components graphs and calling applications to communicate outside of the regular data flow. Commands are functions that may be called on components. A command may be executed by passing the command name and an argument in the form of a data container to a process command method. A data container may be passed to process command method even if the command will not be using the data. If the command will not be using any data an empty data container may be passed to process command function.

Command pins may act as triggers to call commands on components. When a data container is placed on a command pin the process command function may be called with the command name the name of the pin and the data container as arguments. The data in the data container may be used by the command but it does not need to be. Commands may be defined within the component definition file such as a plugin.xml file for example. Commands may have attributes or properties such as a name which may be used to access the command and description which may include information such as what the command does and any data the command expects including data type. An example command may be read name which reads a certain number of bytes starting from a particular location and takes a data container with the number of bytes and a seek position description .

Events along with commands may provide a means for components graphs and their calling applications to communicate outside of the regular data flow. Events may follow an event listener pattern where components fire events to registered event listeners implementing a node event listener interface. A node event may include the event name String and raw data Object . The identity of the component that fired the event may also be contained within a node event.

Events may be exposed on pins. When an event occurs the data object generated by the event may be encapsulated in a data container that is pushed onto the event pin. If the event generates a null object an empty data container may be placed on the pin. The propagation of a data container on an event pin may signal that the event has occurred. Events may be defined within a component s definition file such as for example a plugin.xml file. Events may have attributes or properties such as a name which may be used to access the event and description which may include information such as under what circumstances the event is fired and whether the event contains any data

Capabilities may be externally defined contracts that define how a component with a particular capability should behave and appear. A capability definition may include information such as the properties and pins that are expected in a component with this capability. Capabilities are intended for components graphs and applications to request components dynamically based on their functionality. A component may declare that it implements more than one capability. Capabilities are declared in the component definition file such as for example in a plugin.xml file. Capability names may be unique.

Data processing in a component can follow either a push or pull paradigm. In the push paradigm data is pushed onto a component s input pin calling that component s process method. In the pull paradigm a component will request data from its input pin on a separate internal thread. The internal pulling thread will block until data is received.

When a graph is started source components may send a priming data container consisting only of data type information through their output pins. The data type information in these empty containers may be used by components downstream to complete their configuration. A source component will initially produce an empty data container. Once the empty data container has been sent through the graph real data will be output. All components should check for empty data containers arriving on their input pins. When an empty data container is received on an input pin the component should validate the data type information and send out an empty data container of its own consisting of its output data type. An application programming interface class may provide convenience methods for pushing containers including empty containers onto output pins.

Passing mutable data containers may allow components to perform data processing without making copies of the data. However in place modifications should only be done if the data is not being used elsewhere. If the data will be used in two locations threads components methods etc. at once it may be made immutable. If an output pin feeds into multiple input pins the same data container will be passed to each input pin the data container will automatically become immutable to prevent the receiving components from modifying the same object.

A component may call clone if immutable method on the input data container if it will be modifying the data container s data object as well as its data type. The method clone if immutable returns a clone of the data container if the data container is immutable otherwise it returns the data container itself. The method clone if immutable will make a full copy of the entire data object in the data container potentially using a substantial amount of memory. If the component only needs to modify the data type within the data container then clone if immutable should only be called on the data type before it is modified.

All stream data type definitions may inherit from a base stream data type definition data type stream . The stream data type definition includes an end of stream key that indicates whether or not this data container is the last. Marking end of stream is important to signal that no other data will be arriving for processing. All stream source components may set end of stream to true on the last data container they send. The end of stream data container can be empty no data object . Stream processing components may check for end of stream in the data Type of each data container they receive. When they receive the end of stream data container they must in turn send out an end of stream data container.

In the push data processing model data gets pushed onto the component s input pin calling that component s process method. The process method is effectively called by the component pushing the data onto the input pin. The push model is a passive model. Data containers are pushed onto the input pin by the previous component in the workflow. A process method may be called whenever a data container arrives on the input pin. The component may not be active unless it is processing data.

The push model may be used in cases where there is only one pin or in cases where the input of multiple pins do not need to be coordinated. If the data containers arriving on multiple input pins need to be coordinated then the pull model may be used.

In the pull model the component will block until either a data container arrives on the input pull pin or a timeout expires. A worker thread may be used to drive pulling data from the input pins processing the data and pushing output to the next component. Methods may be called on pull input pins to pull the data blocking until either a data container arrives on the pin or a timeout expires. If the timeout expires before a data container arrives on the pin a null data container may be returned.

To prevent a pull component from entering a busy loop it is preferable to block until data arrives rather than until a timeout expires. However there are cases where a timeout is necessary for example if one pin only receives sporadic input. If one pin will not always receive data the component can use a timeout on this pin to allow it to continue its processing without this pin s input. Unlike a push processing component a pull processing component needs to be aware of when to stop processing. An end of stream data container can be used for this purpose. If the parent graph is aborted a null data container will be returned by the pull method. Pull components may need to verify whether their parent graph has aborted whenever they receive a null data container.

The visual design subsystem is operable to output graphs and blueprints for developing media applications using components compound components blueprints and other graphs . The visual design subsystem defines relationships between components compound components and graphs using pins to define the connections.

In one example embodiment the visual design subsystem may be accessible via a cloud computing system. The visual design subsystem may allow a user to create components and graphs and define an order of operations or workflow for the graph . The visual design subsystem may allow the user to group components including compound components and graphs into functional blocks and arrange those functional blocks into specific orders of operation. The visual design subsystem further allows the construction of logic branches which allow for flexibility in execution of the components or functional blocks. The visual design subsystem may also allow for the construction of functional blocks which may operate linearly in time non linearly or as discrete operations with separate lifecycle management.

The visual design subsystem defines a graph by connecting components compound components and graphs using connection mechanisms such as pins.

The visual design subsystem allows parameters for the components to be set and monitored. The visual design subsystem may also allow graphs to be instantly reviewed to test functionality and performance. The visual design subsystem may simplify component and graph testing development and deployment.

The visual design subsystem may provide an interface such as interface of in order to define solution sets of components and versions thereof for use in graphs blueprints and other components . The visual design subsystem is operable to test and deploy a solution set for use in graphs and blueprints . The visual design subsystem is operable to test and deploy a version of a component for use in a solution set for graphs and blueprints

Referring now to there is shown a block diagram of an example interface for a visual design subsystem in accordance with an example embodiment. The example interface for a visual design subsystem includes a graph and components file input color space converter logic branch with routing based on image width and height scaler and AVC encoder . Other example components include YUV to RGB Java image controller scripted component flow control component and so on. The example interface for a visual design subsystem illustrates an interface for setting the properties and values for components .

The visual design subsystem outputs a graph or blueprint which may be stored in the repository for subsequent use and reference. For example the visual design subsystem may output a file e.g. XML file which describes a graph components compound components blueprints and compound graphs . The file describes the components that are used the parameter values and the connections between the pins of the components . A graph may be used as part of media applications and may be loaded by the system at run time to ensure the appropriate components of the graph are used. For example a graph may reference a solution set of components and versions thereof. The solution set may change or update and because the graph references the solution set by label the appropriate solution will be loaded by the system at run time. The repository maintains a collection of graphs blueprints and components . The repository manages versioning of components and graphs to keep track of updates made to components and graphs and new versions thereof. The graphs are loaded at run time so that the appropriate version of the graph and each component in the graph as defined by a solution set for example is used. Further the graphs may reference the solution set by label so that if the solution set is changed the graph will automatically reference the changed solution set without requiring a manual update to the graph . That is the blueprint with the label may automatically reference the changed solution set without requiring a manual update. A solution set may be referenced by different blueprints using the same or different labels. For example a user may configure a blueprint with a label for a solution set such as ready for testing or passed testing and another user may configure the same or different blueprint with a different label for the same solution set such as MY SET for example. The label provides a descriptive mechanism for a user and also provides efficient processing and propagation of updates. The label may continue to reference a solution set even if a modification is made thereto. Labels may also be used to reference components blueprints graphs and so on. Different labels may be used to reference the same components blueprints graphs and so on.

The visual design subsystem may export a blueprint or a graph . For example the blueprint may be instantiated on a desktop platform as a local engine or subset of an application or in the cloud by a cloud engine . A blueprint may be considered to be a final embodiment of a graph . A blueprint and a graph reference a solution set of components and versions thereof using a label.

The visual design subsystem may be an engine or object code that can be run through an application interface or through the set of SDKs. The visual design subsystem is operable to construct graphs test graphs perform run time validation and simulate graphs .

The visual design subsystem may perform design time media inspection and propagate media type data container information and component configuration changes across graphs and blueprints thus validating proper realization of the graph and blueprint into a media application that can process the desired type of media. For example labels may be used to reference solution sets so that if the solution set changes then label used in the blueprints will also reference the updated solution set without requiring the blueprint to be updated. The visual design subsystem enables complexity abstraction by defining an entire graph or blueprint as a component . Accordingly data containers components compound components graphs and blueprints may be generally referred to herein as components and may be used like components as building blocks for computing applications.

The visual design subsystem may provide properties redirection through the ability to expose a component property as a property of an enclosing graph . The visual design subsystem enables modular and recursive construction of graphs through the use of pre packaged or pre constructed graphs and components . The visual design subsystem uses the repository to provide graph and blueprint persistence storage and versioning strategy enabling backward compatible changes. The visual design subsystem provides dynamic override able and decoupled user interface support.

Referring now to there is shown a block diagram of the data flow of a system for dynamic development and deployment of computing applications in accordance with an example embodiment.

The system may include a user system delivering a plug in package that may contain one or more components graphs and blueprints . The system is also shown to include a repository agent engine and an application system .

Components may be stored in a repository server . The repository server manages the components availability versioning and OS platform capability. When a new job is running the agent will contact the repository server to acquire the components required by the engine which will be running the graph blueprint

Components may be delivered to the repository server as Plugin Packages. The Plugin Packages contain one or more components of related functionality. The Plugin Packages may also include graphs or blueprints for example. Note that each Plugin Package may also be signed and have a manufacturer s digital certificate. Third party Plugin Packages may require a certificate with their company s identifier before the package may be recognized by the repository . This certificate may be provided by a certification agent as will be described in relation to .

The visual designer may provide a graphical interface that can be used to create new graphs or to create new compound components based on existing components . Compound components include components embedded within other components and may be referred to herein simply as components . Components are the basic data processing elements. Components may have input pins which allow data to enter the component output pins which allow data to leave the component and settings which allow the user to set some of the parameters properties which define what happens to the data when it is processed by the component . Compound components can be created using existing components and these compound components can be saved as new components .

A graph is a set of connected components . Components are connected via their pins. Data is encapsulated and passed between components in data containers . A data container may be comprised of a data object the raw data that is being processed and a data type meta information about the raw data .

A graph can be a specific workflow solution or a graph can be embedded within another graph as part of a more complex workflow. Complete workflow solutions can be saved to the repository as blueprints

The deployment subsystem may include one or more linked repositories a license server cloud agents on user computing systems cloud engines run by the cloud agents a job manager and a security module . The deployment subsystem provides external interfaces to repositories to manage components blueprints and graphs to the job manager to manage application jobs and to cloud engines to manage the execution of graphs and blueprints

The deployment subsystem may include a computing application used to manage the workflow and to define the graphs . This application may optionally provide access to a graph creation tool such as the visual designer . The deployment subsystem may include an agent which may exchange commands and status between the application and engines . One agent can communicate with more than one engine . The deployment subsystem may include an engine which is operable for running components in a graph .

The deployment subsystem may include a license server used by engines to check in and out licenses for the purchased components . The license server may also be used to enable the application. The deployment subsystem may include a repository server used to store the components that are to be deployed on engines .

Referring now to there is shown a block diagram of stand alone deployment. In this type of deployment the application accesses the development framework API directly. All of the components of the deployment can be installed on a single host system . That is the local disk is used to store components graphs and blueprints . Alternatively the repository may be used instead of the local disk to provide a database of plugin packages. The repository can be used by more than one host system . The license server can be installed on the host system for a true stand alone deployment or it can be installed on the network so that it can be accessed by more than one host system to allow for network licensing.

Referring now to there is shown a block diagram of network deployment. In this type of deployment an agent is required to communicate with the higher level management application and to communicate with the engines . The agent may reside on one to n different host systems . Access to a repository may be required for network deployment.

An agent may be the dispatch coordinating service installed on all host systems which will run engines . An agent may coordinate management and monitoring of systems on the network and dispatches and monitors jobs running on engines . An agent communicates with higher level applications for example job manager through a web services interface for example. Agents may include a communication service and a server service. Agents can coordinate management and monitoring of more than one engine or a mix of engines on the same system the only restriction may be the practical limits of the host system s resources cpu memory bandwidth etc .

An engine is a running version of a graph or blueprint . An engine may access source files write output files and return status to the agent or Kayak based application. An engine communicates with the agent to acquire the required components and with the license server to authorize the components required to run the graph .

The repository stores components compound components blueprints and graphs . As one example the repository may be a web services based repository accessible through a cloud computing system via external interfaces . As another example the repository may be stored on a local system. The deployment subsystem may use one or more linked repositories for version management maintenance and deployment. The repository is a hosted collection of components and graphs which are accessed by a protocol identified as required and transferred to the target host environment. As an illustrative analogy a graph may be viewed as a recipe i.e. template listing different ingredients i.e. components and the repository contains the blueprint for the graph and components thereof to provide the user with both the recipe and the ingredients listed in the recipe .

The repository organizes each component regardless of whether it is a standalone component or is a compound component graph blueprint or solution set with reference to other components with respect to revision i.e. versions of the component ownership structure licensing requirements and dependencies on other components or technologies. These dependencies or requirements may further require specific revisions of technologies or components for proper function.

The repository manages versioning such that it can determine the most appropriate version of a component graph and blueprint . The appropriate version of a component may be defined by a solution set. The repository allows access to any of the available versions of components and graphs which may include the most recent version but necessarily. The repository may interact with interface in order to provide available versions for each component and define solution sets. For example a customer may want a version of a component that they have tested instead of the latest version and may include the tested version in the solution set. This is may be important for downstream management. When a graph and blueprint thereof is used by an application the components defined by the solution set referenced by the label in the blueprint or graph are loaded from the repository at media application runtime so that the proper version of the components and graphs are used. The repository is configured to provide versioned components with multi stage capability automatic component update propagation and gated component update release.

Referring now to there is shown a block diagram of an example user interface for a repository in accordance with an example embodiment. The example interface for the repository displays an address for the repository such as a uniform resource locator. The example interface for the repository displays a listing of names of components compound components and graphs along with an associated description provider and version . The listing may also include an associated status such as complete tested and so on. The interface may also include the interface of .

There may be multiple linked repositories and a media application can access the multiple repositories when a graph or blueprint is used by the media application at runtime. Examples of repositories include staging preproduction and production.

A cloud agent may be provided to a user computing system to manage the local resources of the host computing system. The term cloud as used herein may describe a heterogenous environment where agents can live in the cloud or on desktops laptops mobile devices and so on and is not limited to cloud computing systems accessible through the Internet. That is a cloud agent may also refer to a desktop agent local agent and so on. The cloud agents may interact with cloud engines to execute graphs and blueprints thereof in order to run media applications or other computing applications. At application runtime a pool of one or more cloud agents can access a shared repository of components and graphs to construct the application. A cloud agent is operable to instantiate blueprints of a graph and run them in a cloud engine .

A cloud engine provides a running environment for blueprints of graphs and creates media applications on the blueprints of the graph . The term cloud as used herein may describe a heterogenous environment where engines can live in the cloud or on desktops laptops mobile devices and so on and is not limited to cloud computing systems accessible through the Internet. That is a cloud engine may also refer to a desktop engine local engine and so on. The cloud engine is a runtime construct which receives blueprints of graphs analyzes and organizes component dependencies executes protocols for retrieval of the required components constructs those components into new run time executables and dispatches those executables against a dynamic job or process. The dispatch of new run time executables can be persistent or dynamic in nature. In persistent mode the cloud agent registers the availability of cloud engines with the calling server or application and no further deployment installation is required. In dynamic mode each executable can be renewed at each job instantiation creating a new product with each deployment.

The cloud agent can be implemented as a desktop application or a cloud based application using an external interface . For a cloud based application the cloud agent may be required to manage the cloud engine and provisioning for specific components graphs blueprints and other resources. For the desktop application a dynamic link library may be used and the system SDK may allow for dynamic updates of components and graphs .

The cloud engine is operable to coordinate the license server and the repository . The cloud agent is operable to dispatch manage and run independent unrelated functionality on a single host system.

The cloud agent is operable to provide interfaces and control over lifecycle of functional blocks of components.

The cloud agent is operable to monitor aggregate and report information about the environment in which it is running to allow for maximum optimization and balance of work.

A cloud engine is operable to execute a graph or blueprint thereof at application runtime in order to construct and deploy a media application or other computing application. At application runtime a cloud engine is operable to use a blueprint of a graph and the solution set referenced in the blueprint in order to identify components and other graphs . Further as a facilitator for version resolution components may be self contained and isolated from a dependency point of view. The entire dependency set of a component may be self contained being specified and packaged in the component distribution unit e.g. plugin . The component dependencies may also be isolated referring exclusively to the specific component and version s they depend on. This may enable the system to realize complex workflows while resolving components dependencies without user intervention. Further the dependency isolation may allow the system to provide distinct behavior while executing blueprints built with the same components by isolating the different versions of these components and their dependencies.

The cloud engine is operable to send a request to the repository for the identified components and graphs receive a copy of the components and graphs from the repository and dynamically build a media application using the components and graphs . Cloud agents run the cloud engines . A cloud agent is operable to instantiate blueprints of graphs and run them in a cloud engine .

A cloud engine is registered with a shared repository and dispatched by job manager . The shared repository works similar to a local repository but its contents are shared by a pool of cloud agents . The job manager dispatches blueprints of graphs cloud agents referencing available licenses in the license pool as maintained by the license server .

The cloud agent may provide life cycle management services for the cloud engine which in turn manages the components blueprints and graphs . The cloud engine is operable to control all components in a multi threaded and multi process execution environment and to manage initialization. The cloud engine may enable early propagation of data type information. The cloud engine may provide graceful and non graceful termination.

The cloud engine is operable to provide component configuration services for graph execution. The cloud engine is operable to provide the ability to auto configure component settings based on the input data type avoiding unnecessary user input.

The cloud engine is operable to provide the ability to configure individually each input pin to function according to a push or pull model allowing heterogeneous components to connect to realize the graphs blueprints .

The cloud engine is operable to provide memory management services through memory pools garbage collection and lifecycle management for large data objects.

The cloud engine is operable to manage data communication pathways in between components allowing them to connect and pass data to realize the blueprints

The cloud engine is operable to define generic media data type and metadata model video audio time code subtitles closed captions a specific application domain data dictionary a mechanism to encapsulate data and data type information with data packets for richer information and optimizes data container management The cloud engine is operable to provide hierarchical data type representation of the information occurring in the graph. The cloud engine is operable to provide data type transformation strategies to ease component manipulation of data types.

The cloud engine is operable to provide multithreaded data integrity through immutable read only packets and data access performance optimization components altering writable packets in place copying only read only data.

The cloud engine is operable to provide out of process execution support thus enabling blueprints execution in separate processes while managing large data structures transfer inter process communication and transparent shared memory when possible.

The cloud engine is operable to provide support for multi language component development with communication and interoperability between them.

The cloud engine is operable to provide cross platform application execution support allowing graphs to be executed on multiple types of platforms including Windows Mac Linux platforms for example.

The license server is operable to dynamically manage a license pool of licenses and associate licenses with components and graphs . The license server is operable to determine whether a requesting user has the appropriate license for the components identified in a graph that forms part of the media application. A user may only be permitted to use components and graphs if they have the required and appropriate license. This allows a user to use the technology across departments groups and companies depending on the conditions of the license associated with the various components of the graphs . Further this enables a provider to control and track use of its components and graphs . The license server provides tracking of all in use technology and provides for a central accounting mechanism. The licenses can be controlled by concurrency physical system floating and leased.

That is the license server provides runtime authorization to components through a pool of available licenses. Referring now to there is shown an example browser based console which can be used to access the license server to show which features are available how many are currently in use and which systems are using the features. The license server can access and or import plug in package of licenses. Engines can access the license server to check out licenses for the components required to run a graph and to check in those licenses once the graph has finished running. An application system can access the license server to check out licenses for the components required to run an application and to check in those licenses once the application has finished running.

The job manager is configured to provide job engine dispatch failover tracking and reporting. The job manager dispatches cloud engines based on available resources system availability processing capability available licenses in the license pool maintained by the license server . In particular the job manager dispatches cloud engines based on the latest or appropriate graph blueprints registered with production repository and available licenses in the license pool . The job manager may also be configured for mapping graphs to cloud engines . The job manager may also be configured to provide the highest level of access to the running cloud engines and provide centralized access to the cloud engines regardless of state running or not . The job manager may further self extend interfaces e.g. web services based on the graph blueprint that is loaded on the cloud engine to provide a namespace for example similar to the web which may allow the developer to discover which graphs and components are used in that particular computing application query parameters set parameters and so on.

Referring now to there is shown a block diagram of an example interface for a job manager in accordance with an example embodiment. The interface provides a listing of resources managed by the job manager including a start time end time resource name status e.g. running completed failed cancelled progress average encoding rate estimated time remaining failures source file project and notes. The interface may also include a search box for searching for jobs managed by job manager . The search box may provide a variety of search parameters such as date range project name resource group current state and events e.g. dropped failover for example. The interface is operable to provide a variety of pages or windows such as a summary network monitor groups resources schedule jobs and alerts for example.

A code signing module is operable to digitally sign each component to associate a developer license or both with each component .

The translation module is operable to translate multiple languages into a common language for system .

An interface application may provide users with a way to create graphs and to run those graphs . The graph creation may be programmatic where a graph is generated based on a few user selected parameters and the actual graph itself is hidden from the user. At the other end of the spectrum the interface application may provide full access to the visual designer with the user choosing and connecting the components in the graph manually. The interface application may also provide a way to select the data inputs for the graph e.g. source files to set the outputs for the graph e.g. archive files and to monitor and control the execution of the graph .

An example of an interface application is job manager with job engines . The job manager may be a media manager server which manages file transcode jobs. User access to the Media Manager Server may be via an interface application. Jobs are submitted to the server by adding source files to watch folders. Watch folders are associated with job projects graphs for transcoding jobs . Graphs may be created using a customized version of the visual designer . The Media Manager Server may have access to a pool of transcode host systems and each transcode host system may communicate with the Media Manager Server using an agent installed on the host. When a job is submitted the source file and project graph are sent to a host system with an agent which will then manage the engine which processes the job. Status is returned to the Manager Sever while the job is being processed and when the job completes.

Referring now to there is shown a block diagram of the data flow of a system for dynamic development and deployment of media applications in accordance with an example embodiment. A blueprint is a container of one or more graphs . A graph can contain other graphs but all run in one lifecycle whereas the graphs contained at the blueprint level may run simultaneously or sequentially. Cloud agents and cloud engines may be operable to receive a blueprint and use it to instantiate a graph of components compound components and data containers .

The normalization module is operable to receive input media files which may be files as in the original document live media and so on and convert and parse the input media files into data containers to be processed by the graph blueprint . The normalization module extracts as much data as possible from the input media file to populate the data containers and the data type and data objects of the data containers . The normalization module can match the input data to a dictionary of languages linked to data types in order to populate the data type component of the data containers . Normalization module capability may be distributed across various components being actually provided by specific components or for example a media file input component .

System may be implemented as a cloud computing system and the user may access system through external interfaces such as web services for example .

Referring now to there is shown block diagrams of example web services implementations in accordance with example embodiments.

As shown in web services may connect and interact with a broadcast system post broadcast system and cable IPTV system . Web services may provide a virtual layer between external systems e.g. service system post processing system cable IPTV system and the components of system . The web services interact with job manager which in turn dispatches and manages one or more cloud engines . The job manager may also interact with license server and license pool to comply with license restrictions. The web services may be provided as a cloud computing system. One feature of embodiments described herein is automatic generation web services based on the components that exist in a running engine. The web services can be further filtered through access control by the author designer of the application.

As shown in web user interfaces may connect and interact with one or more service system s post processing system s and other external systems e.g. cable IPTV system . Web user interfaces may provide a virtual layer between external systems e.g. service system s post processing system s other system s and the components of system referred to as virtual appliances . In some embodiments some web user interfaces may interact with an application to access the components of system . In some embodiments business logic residing on web servers is operable to control interactions between web user interfaces and the components of system .

An example embodiment may implement an asset management and publishing system that is responsible for implementing actions including storing conforming searching and publishing large amounts of media data to individual publishing profiles. A publishing profile can be a VOD target a device a service and a network for example. The asset management and publishing may be implemented as a web application.

Referring now to there is shown diagrams of example data flows for implementing an asset management and publishing system in accordance with example embodiments. At system is operable to ingest digital media assets such as input media files . At system is operable to determine whether the digital media assets meet codified requirements and use job manager to dispatch cloud engines for processing and modifying the digital media assets to meet such codified requirements. At system is operable to store digital media assets. In some embodiments the job manager may be used to manage the storing of the digital media assets. At system is operable to search through the digital media assets for refinement based on search parameters. At system is operable to publish the processed and refined digital media assets to a customer by using the job manager to dispatch corresponding cloud engines for preparing e.g. advanced video coding and publishing the digital media assets to specific customers at .

Referring now to there is shown a block diagram of an example certification system in accordance with example embodiments. The certification system may certify or sign a solution set graph component blueprint and so on referred to generally herein as components with digital certificates to indicate acceptance that the particular component will perform or carry out a function as expected by one or more user computing systems associated with the particular component and one or more component provider systems . illustrates multiple user computing system each associated with different media applications developed and deployed using system . further illustrates multiple component provider systems each having provided resources such as one or more components for use by system or one or more hardware resource used to execute computing applications for example.

A user computing system may be any networked computing device operated by a user of system including a processor and memory such as an electronic tablet device a personal computer workstation server portable computer mobile device personal digital assistant laptop smart phone WAP phone an interactive television video display terminals gaming consoles and portable electronic devices or a combination of these. A networked device is a device capable of communicating with other devices and components of system and certification system through a communication network such as network . A network device may couple to the communication network through a wired or wireless connection. Similarly component provider system maybe any networked computing device operated by a resource provider including a processor and memory

Network may be any network s capable of carrying data including the Internet Ethernet plain old telephone service POTS line public switch telephone network PSTN integrated services digital network ISDN digital subscriber line DSL coaxial cable fiber optics satellite mobile wireless e.g. Wi Fi WiMAX SS7 signaling network fixed line local area network wide area network and others including any combination of these.

The user computing systems and the component provider systems use digital certificates to indicate that they agree that a particular component operates properly. That is the digital certificates signify acceptance by both the user computing system and the component provider that a particular component satisfies a performance standard. For example the digital certificate may sign a particular component when a user computing system activates a digital button I agree linked to a digital representation of a license agreement. It may be important to track and record acceptance by users and providers to efficiently resolve disputes and to ensure only accepted components are used in the computing applications so that the computing application functions as agreed. It may be important that the functionality performed by the application or the deliverable what the application creates or transforms can be tracked agreed upon etc. A digital certificate may be an electronic file that identifies an individual or organization and electronically indicates to system that the individual or organization accepts a component. A digital certificate may be issued by system or by a third party certificate issuer. A digital certificate may have security measures to authenticate the individual or organization associated therewith so that the digital certificate is not used fraudulently.

The certification system may extend to multiple user computing systems each with a digital certificate for signing components blueprints and so on. The certification system uses digital certificates to create a chain of trust between all aspects of the system . Trusted components may create trusted graphs which may include trusted or untrusted components . A graph may become a trusted graph when signed by multiple user computing systems and provider systems to create trusted exchange of trusted graphs blueprints for use within a media application. That is components may be signed using digital certificates and the signed components may be used to create graphs and blueprints. The graphs and blueprints may also be signed using digital certificates . Those signed graphs and blueprints may form part of a computing application and system may check to ensure all of the computing application components are signed i.e. accepted by a user and provider prior to executing the computing application.

As an example a user computing system may use system to develop a media application involving a particular component and may test and deploy the particular component to ensure it functions properly. Once the user computing system agrees that the particular component satisfies a performance standard i.e. functions properly then the user computing system can indicate acceptance using a digital certificate associated with the user computing system . The use of a digital certificate to indicate acceptance enables the system to automatically and efficiently track and check the acceptability of media applications and components thereof. The user computing system signifies acceptance by signing the component with the digital certificate associated with the user computing system . Similarly the component provider signifies acceptance by signing the component with a digital certificate associated with the component provider .

The license server includes a certificate component matrix which manages records relating to digital certificates . In particular a record links the digital certificates and the accepted resources such as components graphs computing applications hardware resources used to execute computing applications and so on. A component may be used in multiple computing applications associated with different user computer systems where each user computer system is associated with a different digital certificate . Accordingly the certificate component matrix may include multiple records associated with the same component where each record links the component to a different digital certificate associated with a different user computer system .

In accordance with some embodiments the computing application is deployed internally by system or externally by a remote computing system. For example the remote computing system may be cloud based infrastructure. The remote computing system may be operated by system or may be operated by a third party for example. A cloud engine or a cloud agent may query the license server to ensure that a component has been signed by both digital certificates before executing a component at runtime as part of a media application associated with the user computing system . If the component has not been signed by both digital certificates then the cloud engine or the cloud agent may not execute the component and may provide an error message requesting that the component be signed by the digital certificates . The cloud engine or the cloud agent may submit a query that includes both the user computer system associated with the media application and the component. The cloud engine or the cloud agent is operable to verify that the relevant user computing system has accepted the component as a component may be associated with a different user computing system . Further the cloud engine or the cloud agent is operable to verify that the component provider has accepted the component before deployment.

Further the license server may include a record database which stores a record or report each time the resource operates successfully such as when a component successfully executes within the computing application when a signed hardware resource successfully executes the computing application and so on. The record establishes that the resource operated successfully e.g. a component or blueprint executed successfully in the event of a dispute between the user computing system and the component provider . The license server may generate summary of all records associated with a resource for provision to the component provider system or user computing system . The summary provides a mechanism to notify the component provider or user computing system that the resource is or is not successfully operating.

Using certification system system is operable to supply some signed components signed with digital certificates to guarantee a certain level of functionality. A signed component may establish trust regarding performance and functionality.

For example a gas company may operate user computing system and may create a computing application including a blueprint graph components and so on which contains some signed components required to perform a particular job such as a component configured to perform job data mining on a large database of information about potential drill sites geophysical information for each of these sites potential risks associated with each site costs government limitations environmental liabilities and so on. The company may not have the processing resources to perform the computations of the computing application in a required timeframe and may use a remote computing system such as a cloud based infrastructure for example to execute the computing application in order to perform the computations. The company may want a guarantee of a performance level in relation to the execution of the computing application by the remote computing system.

The system may engage third parties such as a component provider system e.g. vendor of components to provide the remote computing system such as the cloud based infrastructure. The system and component provider system may be associated with a service level agreement that guarantees performance of the remote computing system provided by the component provider system . In order for the gas company operating the user computing system to trust system to run their computing applications there may be a chain of trust established between the component provider system the system and the user computing system . Accordingly there may be more than two digital certificates signing the computing application or components blueprints graphs thereof . System may use its own digital certificate to sign to the computing application to guarantee that it functions exactly as the gas company associated with the user computing system requires. In addition the user computing system may use their digital certificate to sign the computing application and the component provider which may also be referred to as a service provider as it may provide the cloud computing resources in this example may use their digital certificate to sign the media application. In effect instead of offering remote computing system resources such as raw cloud resources for example the system may be viewed as offering a Workflow As A Service in some examples. The system may not know exactly what job the media application is performing only that it functions in the remote computing system infrastructure properly. The digital certificates provide a chain of trust and acceptance between the parties a security mechanism and a validating reference point that the parties can feel confident about. Accordingly in this example the gas company operating the user computing system signs the application or blueprint graph component thereof with their digital certificate the system countersigns the media application with their digital certificate and the component provider system signs the media application with their digital certificate. The system is operable to only execute the blueprint only if all digital signatures made by the digital certificates are valid. Security may be derived from the digital certificates and chain of trust established thereby as only signed components blueprints and graphs may be executed by system in some embodiments.

As system generates reports each time the computing application and blueprints graphs and components thereof successfully execute and those reports are stored by license server in the record database . A results summary may be generated and transmitted to the user computing system . The chain of trust is maintained so that the gas company operating the user computing system can trust the results of the media application third party service etc. and the fact that the data and blueprints have been protected throughout the entire process.

Other potential types of computing applications and contexts include voter registration integrity management and vote tally applications.

For example a computing application may include a blueprint defining a workflow at place at each voting station. The computing application may be a trusted application using trusted i.e. signed components running on a trusted system . The user voter registers their data and signs the data using their digital certificate and the system adds a user specific certificate to the data. At voting time the trusted user data is interjected into the trusted workflow and the vote is recorded by system . All of the voter stations involved send trusted data into the remote computing system hardware infrastructure executing the computing application where trusted processes are running inside of a trusted environment. The remote computing system solution provider e.g. component provider system countersigns the computing application implementing the workflow with their digital signature the data coming back is secure i.e. signed the public and government can trust the system because it is secure i.e. signed and the results are trusted because of the nature of the system . The signing of a component may involve encrypting the component to enhance security.

The use of digital certificates in the described example embodiments differs from a traditional https style of key exchange. For an https system when a user accesses a website say a bank the user can trust the bank because the certificate at the bank website is certified against that particular system. In a remote environment such as a cloud environment where the system providing the remote hardware infrastructure may be unknown and using the described embodiments the digital certificates may be used to secure the process implemented by the computing applications. The described embodiments may use digital certificates to sign the entire media application including the individual components and entire workflows implemented by blueprints and even multiple stages of workflow.

As another example a media company may sign a media application provided by system as a Workflow As A Service. The media company may operate the user computing system to access system and develop blueprints workflow for the media application. System or a third party such as a media company association may certify that the workflow blueprint or media application is secure when all involved companies sign the blueprint using their digital certificates. The signatures makes all parties feel protected and ensures with some level of credibility that the media will be secure the processes will be secure and operate as expected and the chain of trust is secure.

A process flow associated with the certification system may include the following steps in accordance with an example embodiment.

A user computing system may be provided via network with access to the system which includes a development framework with a software development kit components data containers pins graphs blue prints and so on in order to construct a computing application. The software development kit may be used to define the components data containers pins graphs blue prints and solution sets each generally referred to as components . Each component defines a computing processing mechanism for processing data containers of data at application runtime. Each graph or blueprint comprises a reference to a solution set of components where the solution set of components is a set of particular versions of components.

The user computing system may be provided via network with access to the visual design subsystem configured to define and output graphs and blueprints in order to develop computing applications. The visual design subsystem is operable to arrange components into functional blocks and define specific orders of operation for the functional blocks. The user computing system may use the visual design subsystem in order to define solution sets for blueprints and graphs using interface .

The user computing system may be provided with a digital certificate associated therewith. The certificate may be provided by system and in particular by license server . The certificate may also be provided by a third party certificate provider.

The component provider provides one or more resources such as components to system for use by the user computing system to develop components and computing applications. Other example resources include signed computing applications and hardware resources to execute computing applications. The component provider is provided with a certificate associated with the provided components. The certificate may be provided by system and in particular license server . The certificate may also be provided by a third party certificate provider.

The user computing system may use the component provided by the component provider for one or more of their media applications. As described herein the user computing system may require a license to use the component as managed by the license server and the license pool .

The user computing system may be provided via network with access to the deployment subsystem for deploying the computing applications including the component. As described herein the deployment subsystem includes a repository cloud agent cloud engine and other modules. The computing application may identify graphs blue prints compound components and components including the component provided by the component provider . The repository is configured to store graphs blueprints and components for loading at application runtime.

The user computing system may use the deployment subsystem to test and deploy the component provided by the component provider . If the user computing system is satisfied that the component provided by the component provider functions as expected then the user computing system may accept the performance by signing the component using the digital certificate associated therewith. The license server receives the digital certificate from the user computer system via network and creates a record in the certificate component matrix that links the signed component with the digital certificate . Similarly the component provider may accept the performance by signing the component using the digital certificate associated therewith. The license server receives the digital certificate from the component provider via network and updates the record in the certificate component matrix to also link the signed component with the digital certificate .

A cloud engine provides a running environment for the media applications and the graphs and blueprints thereof and executes the graphs and blueprints at runtime to instantiate the media application. The cloud agent controls the cloud engine s . At runtime the deployment subsystem dynamically constructs and deploys a computing application by sending a request at runtime to the repository for the graphs blueprints compound components and components identified in the media applications. The deployment subsystem and in particular the cloud engine or the cloud agent is operable to query the license server at runtime to ensure that the component of the computing application has been accepted by both the user computing system and the component provider prior to executing the component and running the computing application. The license server is operable to respond to the query by checking the certificate component matrix for a record that links the component to the user computing system and the component provider . If the component has not been accepted an error message may be provided requesting acceptance.

Each time the component of the computing application successfully executes the cloud agent or the cloud engine may provide a record or report of the successful execution to the license server .

The job manager is operable to store the record of successful execution in the record database in association with the component the user computing system or the component provider . That way if a dispute arises in relation to the operation of the component the job manager can provide a copy of the record to establish that the component did or did not execute successfully to resolve the dispute. The license server may know whether or not specific technology resources are in use may not know whether or how the technology resources used was actually successful.

In accordance with some embodiments system is operable to provide support for mixed architectures. This may provide increased flexibility as typically a process needs to be compiled for the same architecture binary. For example a 32 bit CODEC library would typically have to run on a 32 bit context and typically could not run in a 64 bit context or with a 64 bit library. In accordance with some embodiments system is operable to develop and deploy an application instance which combines components written for both 32 bit and 64 bit architectures. System and in particular cloud engine is operable to detect whether a particular media application has been developed using both components for different architectures such as components for 32 bit architectures and components for 64 bit architectures for example. If so system is operable to create a separate process space or instance for each context and handle inter process communications using mapping and a shared memory. For example the system is operable to create a 32 bit architecture process instance and a 64 bit architecture process instance and manage communications between the process instances.

Referring now to there is shown a block diagram of a mixed architecture in accordance with example embodiments. A graph may contain components developed for different architectures such as components for 32 bit architectures and components for 64 bit architectures for example. System and in particular cloud engine is operable to detect whether a particular graph includes components for different architectures. In this example graph contains components developed for 32 bit architectures and further contains a subgraph with components developed for 64 bit architectures. System is operable to create a separate process space or instance of graph for the 64 bit context and handle inter process communications using mapping and a shared memory to receive and provide input and output. The subgraph may run out of process for example.

In accordance with some embodiments system is operable to provide selective scalability through dynamic provisioning and deployment based on the individual workload of a component group of components or entire graph blueprint . System is operable to analyze the runtime processing of a blueprint and break down the blueprint into separate running graphs based on derived knowledge of the processing overhead e.g. bottlenecks of particular components which exist in a particular workflow. System is further operable to isolate those component s and partition the blueprint into multiple graphs e.g. create new graphs on the fly which can exist on a separate host system or the same host system while maintaining the communication and integrity of the original workflow blueprint . For example system is operable to use a separate host system with more resources to process to overhead bottlenecks and manage data flows between. The modular nature of components and graphs enable system to partition a graph into multiple graphs and run them separately on different computing resources.

Referring now to there is shown a block diagram of a graph partitioned into two graphs where each is run on a separate host system . System is operable to identify a processing bottleneck i.e. graph in a graph running on a host system isolate the components associated with the processing bottleneck and create a new graph on the fly which can exist on separate host system . The separate host system provides additional resources to process graph . System is operable to manage communications and data flow e.g. via a shared memory between the host systems and graphs .

In accordance with some embodiments system is operable to provide security through dynamic re location of graphs and components that make up a particular computing application. The process is similar to as described above in relation to selective scalability except that a graph is partitioned for the purpose of increased security as opposed to the purpose of isolating a processing bottleneck. For example security module may interact with license server to determine whether a particular graph for a media application refers to components or embedded graphs that are signed. If so system may partition the graph for the media application by isolating the signed components for increased security by obfuscating the original footprint of the media application. The partitioned components may then run on a separate host system similar to that shown and described in . System is operable to further limit access to the running footprint of a particular blueprint and relocate sections of the blueprint onto different hosts in a dynamic fashion. This may be viewed as scrambling the application footprint at the functional level making it harder to find and compromise. For example an attacker may focus on one host to monitor and listen so splitting a process onto multiple hosts may make it more difficult for an attacker to monitor and tamper with the program. The original functionality is maintained as system manages communications and data between the multiple host systems. Security is maintained as the process of creating the new sub graphs may involve automatic injection of secure messaging components e.g. encryption . As an extension of this system is further operable to create multiple instances of each new sub graph and to randomize the data paths through the running components of the sub graphs . Further system may be operable to maintain a set of potential host systems and randomize selection of a subset of those host systems on which to run the program so that the host systems are also randomly selected.

In accordance with some embodiments system is operable to control access to resources using virtual priority management. That is system is operable to tune a media application to control priority of processing parallelization and threading. At runtime system is operable to manage the execution of a component in such a way as to make it process faster or slower than normal. There may be an imbalance of resource utilization between components in a media application and system is operable to manage the processing prioritization of a particular component while other components are prioritized independently. For example if a more important component is running then system is operable to manage control manipulate or throttle i.e. slow down another component that may be consuming a larger amount of resource until the more important component has completed its processing.

As an illustrative example the virtual priority management may be implemented using a virtual clock as a mechanism to control priority. A virtual clock is one example and the implementation could be done a number of different ways.

As noted above system is operable to limit resources allocated to a particular component . For example this may be limiting component access to a thread pool memory or other mechanism. System may throttle the data while not touching anything. An example may be a source component such as a complex signal generator. The signal generator may be the first component in the pipeline and may generate frames faster than they can be consumed but while doing so can also use some amount of CPU. If system decides at runtime to limit the CPU activity the system may simply trigger the signal generator less often. This may not require any manipulation of threads memory or source data packets. Another example may be something at the end of the pipeline that is designed to send out notifications or updates but is also blocking while doing so. The component may send email notifications and the act of sending those notifications takes longer than the rest of the pipeline does in actual processing. System may limit the number of notifications by throttling the packets that normally trigger the component to start execution.

In accordance with some embodiment components may be self contained and isolated from a dependency point of view. The entire dependency set of a component may be self contained being specified and packaged in the component distribution unit plugin . The component dependencies may also be isolated referring exclusively to the specific component and version s thereof they depend on. Thus the system may be able to realize complex workflows while resolving components dependencies without user intervention. Further the dependency isolation may allow the system to provide distinct behavior while executing different solution sets blueprints built with the same components by isolating the different versions of these components and their dependencies.

As described herein graphs and blueprints are portable and may be packaged to run anywhere there is a cloud agent .

In accordance with some embodiments components and graphs may support promotion of properties and values. For example if one component is embedded within another component the inner component may promote one or more of its properties to the outer component . A user may pass expressions to components to change promote properties. That is properties may be reauthored as they are promoted. Properties may be selectively promoted in that not all properties need to be promoted together. Properties may be promoted without exposing the values and without exposing the values of the properties that are not promoted.

Embodiments have been described herein in relation to media applications as an illustrative example. The system and methods described herein may be used to develop and deploy other type of software applications and are not limited to media applications such as natural resource applications voting applications and so on.

Embodiments have been described here by way of example only. Various modification and variations may be made to these exemplary embodiments.

