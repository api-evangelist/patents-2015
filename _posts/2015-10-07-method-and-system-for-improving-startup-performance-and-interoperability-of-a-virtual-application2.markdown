---

title: Method and system for improving startup performance and interoperability of a virtual application
abstract: A data structure including simple and complex objects. Each simple object includes a content type indicator, a size indicator, and one or more simple data types. Each complex object includes a content type indicator, a size indicator, and one or more child objects. The complex objects include a layer object having first and second child objects. The first child object is a collection of complex objects storing information for configuring a virtual filesystem of a virtual application at application startup. The second child object is a collection of complex objects storing information for configuring a virtual registry of the virtual application at application startup. Reading of selected simple and complex objects may be deferred at startup based on the content type indicator. Deferred objects may be read after startup when access to information stored by the deferred object is request by the virtual application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569286&OS=09569286&RS=09569286
owner: CODE SYSTEMS CORPORATION
number: 09569286
owner_city: Seattle
owner_country: US
publication_date: 20151007
---
The present invention is directed generally to file formats and data structures used to implement application virtualization.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information.

The data files and or executable files are configured to execute within a virtual runtime environment that is provided at least in part by the virtual operating system. When the virtual application is executed within the virtual runtime engine the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

As is apparent to those of ordinary skill in the art to execute the virtual application the virtual runtime engine reads the configuration information and the virtual application files stored in the data file s and or executable file s . Thus an amount of time required to execute the virtual application is determined at least in part by how efficiently the reader can access data stored in the data file s and or executable file s . File formats that enable efficient data access by the reader of the virtual runtime engine are desirable. To reduce an amount of time required to startup a virtual application a need exists for a file format configured to identify portions that may be skipped initially and read at a later time. Further compatibility of a particular virtual application with a particular version of the virtual runtime engine is determined at least in part by the format of the data file s and or executable file s . Therefore a need exists for file formats configured to provide forward and or backward compatibility. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

In the virtualized application file includes components necessary to implement a virtual operating system configured to execute in the host operating system and a virtual application configured to execute in the virtual operating system . In the embodiment illustrated a single virtual application file is used to implement both the virtual operating system and the virtual application . However those of ordinary skill in the art appreciate that more than one virtual application file may be used to implement the virtual operating system and the virtual application .

The virtual operating system includes a virtual filesystem virtual registry and a virtual process environment and threading subsystems component . The virtual application interacts with the virtual filesystem virtual registry and virtual process environment and threading subsystems component instead of interacting directly with the host filesystem the host registry and the process environment and threading subsystems component of the host operating system . The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application .

The virtual application executes inside a virtual runtime environment provided at least in part by the virtual operating system . Some virtual applications require one or more additional runtime environments to execute. For example to execute a Flash application the Flash runtime engine must also be installed. Therefore to virtualize a Flash application both the Flash application and Flash runtime engine must be included in the virtualized application file and configured to execute in the portions of the virtual runtime environment provided by the virtual operating system . Collectively all runtime components necessary to execute the virtual application will be referred to as a virtual runtime engine. However those of ordinary skill in the art appreciate that the virtual runtime engine may include only the virtual operating system and components of other additional runtime engines e.g. the Flash runtime engine required to execute the virtual application may be loaded separately by the virtual operating system . When executed the virtual runtime engine generates at least in part the virtual runtime environment in which the virtual application executes.

A natively installed version of an application is configured to execute within a runtime environment provided at least in part by the host operating system . Typically to execute within the runtime environment provided at least in part by the host operating system a natively installed version of an application modifies the configuration and settings of the host operating system . For example the natively installed version may install dynamic link libraries or change registry settings of the host operating system . In contrast a virtual version of the same application may be executed on the host operating system without installation on the host operating system . Thus the virtual application does not modify the configuration or settings of the host operating system . For example to execute the virtual application dynamic link libraries dlls data files registry settings environment variables and the like need not be modified on to the host operating system .

The virtualized application file includes virtualized application files A C corresponding to application files A C of a natively installed version of the same application. The virtualized application files A C are stored as blocks of data inside a configuration data block . During execution the virtualized application files A C are accessed via the virtual filesystem . The virtualized application files A C include one or more startup executables. The virtualized application file identifies one or more startup executables that are executed when the virtual application is first executed. The startup executables may be identified in the configuration data block .

When the virtualized application file is executed the configuration data block is used to configure the virtual operating system to execute the virtual application. For example the configuration data block may contain configuration information related to the files in the virtual filesystem e.g. the virtualized application files A C entries in the virtual registry environment variables services and the like. The configuration data block may also include basic application metadata and settings such as the application name application version and sandbox location. Further the configuration data block may provide isolation information to the virtual operating system . This information indicates which virtualized application files A C virtual registry keys virtual registry values environment variables and services are to be isolated from the host operating system .

The configuration data block may also include one or more virtual layers. Each virtual layer may identify files registry entries environment variables and services. As the virtual layers are read the corresponding files registry entries environment variables and services are added to appropriate runtime data structures. If the virtualized application file is configured to execute on more than one host operating system the configuration data block may include a virtual layer for each operating system. In such an embodiment each virtual layer includes information necessary to configure the virtual runtime environment to execute on a particular operating system. Further the configuration data block may include a virtual layer that includes configuration information common to the other virtual layers e.g. a default virtual layer .

To execute the virtual application an initialization process is first performed. During this process the virtual operation system is launched and configured by the configuration data block . A component of the virtual runtime engine referred to as a reader reads data stored in the configuration data block and uses that data to configure the virtual runtime environment. For example the reader reads the virtual layer for the host operating system and any other applicable virtual layers and uses the information read to configure the virtual operation system and in some implementations other components of the virtual runtime environment to execute the virtual application on the host operating system . The virtual filesystem may be configured to mirror a host filesystem configured to execute a natively installed version of the application. Similarly the virtual registry may be configured to mirror a host registry configured to execute a natively installed version of the application.

After the initialization process has completed the appropriate startup executable s is are launched inside the virtual operating system . The virtual operating system intercepts calls to the host operating system and routes them to corresponding components of the virtual operating system . For example when the virtual application requests to access an application file using a path of a natively installed version of the application the virtual operating system intercepts the request and routes the request to one of the virtualized application files A C corresponding to the application file requested. The virtual operating system may also route some requests and actions to the host operating system for processing.

The virtualized application file is read only and when executed cannot be modified by the virtual application or components of the virtual runtime engine. Therefore modifications to the data stored in the configuration data block e.g. modifications to the virtualized application files A C modifications to the registry keys of the virtual registry and the like are written to a readable and writable memory location referred to herein as a sandbox . The sandbox is a location on the host filesystem a network share a removable storage device and the like whereat files may be created modified and deleted by the virtual application at runtime. For example when the virtual operating system needs to create modify or delete a virtualized application file the virtual operating system does so in the sandbox . Similarly if the virtual application modifies a virtual registry value the virtual registry value is changed in the sandbox . The virtual operating system may also route some requests and actions to the host operating system for processing.

U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 the virtualized application file may be created by a virtual application executable constructor or authoring tool using an application template that includes copies of files such as a configuration file application files A C and the like used to configure the virtualized application file . However the template is not a requirement. Instead to build the virtualized application file the authoring tool needs only the configuration file and copies of any applications files A C necessary for a natively installed version of the application to execute. The applications files A C and the configuration file are referred to collectively as an application configuration .

The authoring tool combines the application configuration and the components of the virtual runtime engine e.g. the virtual operating system into the executable virtualized application file . Sometimes multiple virtual applications share a common set of virtual machine configuration settings or virtual runtime engine components. By way of a non limiting example multiple Flash applications may be configured to be executed by the same Flash runtime engine. Further system administrators may want to share a common set of configuration options e.g. browser bookmarks application settings etc. across a department or enterprise. These settings may be stored in a file referred to as an xlayer file and incorporated into one or more virtual application files at runtime by the virtual runtime engine. Depending upon the implementation details the authoring tool may be used to create the xlayer file .

The xlayer file cannot be executed directly from the host operating system and instead requires the virtual runtime environment supplied at least in part by the virtual operating system . Like the configuration data block the xlayer file may be read by the reader of the virtual runtime engine at runtime. The information stored within the xlayer file may be made available to a virtual application e.g. the virtual application via the virtual filesystem and virtual registry of the virtual operating system at runtime. By way of a non limiting example the configuration data block may specify a location on the host filesystem whereat the virtual runtime engine e.g. the virtual operating system is configured to look for xlayer files. If an xlayer file is located in the specified location the xlayer file may be read automatically by the reader of the virtual runtime environment. Alternatively the virtual runtime engine may be configured to look for xlayer files in a particular location each time the virtual application is executed.

The xlayer file may be shared between users and used to supply virtual machine settings to multiple virtual applications. The xlayer file may include all virtual registry and virtual filesystem information associated with a particular software component e.g. a virtual runtime engine component allowing the component to be fully installed in the virtual runtime environment. The xlayer file may be implemented as a binary file. The data in the xlayer file may be organized in one or more virtual layers substantially similar to the virtual layers of the configuration data block described above.

As is apparent to those of ordinary skill in the art the number of files and registry keys needed to implement a virtual application such as the virtual application and or a component encoded in the xlayer file can be very large. For example it is not uncommon for the number of files and registry keys needed to implement a virtual application to total in the tens of thousands. Therefore the performance characteristics of the configuration data block and the xlayer file can affect the performance of the virtual application significantly. In other words the performance characteristics of the configuration data block and or the xlayer file can increase or decrease the startup time for the virtual application .

As is apparent to those of ordinary skill in the art the configuration data block and the xlayer file store similar data and therefore can be formatted in accordance with a common format. illustrates a file format that may be used to configure the configuration data block portion of the executable virtualized application file and or the xlayer file .

Typically as operating systems are updated new operating system features need to be virtualized to support new classes of applications. In other words the virtual operating system may be updated to support new applications. When this occurs the file format may need to be reconfigured to execute within the updated virtual operating system. Therefore the file format illustrated in is configured to be readily reconfigurable.

It may be desirable to avoid modifying the file format after it has been created to avoid forward and backward incompatibility issues with newer and older versions of the virtual runtime engine. In other words the file format should be compatible with the virtual operating system despite modifications made to the file format . Additionally it may be advantageous to separate the components implementing the virtualization runtime environment e.g. the components of the virtual operating system from the data stored in the file format . This separation allows updates to be made to the virtualization runtime environment without also requiring a re build of the virtualized application file and or the xlayer file .

Sometimes a user may wish to execute or load multiple virtualized application files and or xlayer files in one virtualization runtime environment to allow multiple virtual applications to interact or interoperate with one another. Therefore the file format may be configured to be parsed quickly and to be forward and backward compatible with different versions of the virtualization runtime environment. For example the file format may include strongly typed data and size encoding to improve performance and interoperability between virtual applications.

The file format includes a signature value a version stamp a size indicator an error checking section and a body section . The data in file format is ordered with the signature value being first followed by the version stamp which is followed by the size indicator which is followed by the error checking section which is followed by the body section . The body section may include any number of child objects .

The signature value is a value used to authenticate the information stored in a file. The signature value may be implemented as a block of six bytes of data. The value stored in the signature value may be generated using any method and the present teachings are not limited to use with a signature value generated by any particular method.

The version stamp may include a major version identifier and a minor version identifier . The major version identifier should be modified if a change is made to the file format that would make the file incompatible with a previous version of the virtual runtime engine. The minor version identifier may be incremented for informational purposes when a new content type is added to the file format or for other minor modifications to the file format . Each of the major and minor version identifiers and may be implemented as 32 bit integers.

The size indicator identifies a location in memory that corresponds to the end of a file having the file format . The location in memory to which the size indicator refers is identified in by a curved arrow A. By way of a non limiting example the size indicator may be implemented as a 32 bit integer.

By way of a non limiting example the error checking section may be implemented using a cyclic redundancy check CRC method. In such an embodiment the error checking section may include a CRC code and a CRC size indicator . Each of the CRC code and the CRC size indicator may be implemented as 32 bit integers.

The CRC code may be created using a simple XOR based CRC function. The CRC size indicator may indicate on how many bytes the CRC function is performed. By way of a non limiting example the CRC function may be performed on a number of bytes specified by the CRC size indicator starting with the bytes of the CRC size indicator . By performing the CRC function on fewer than all of the bytes following the CRC size indicator error checking may be performed on more sensitive data stored nearer the beginning of the virtualized application file or the xlayer file . For example if a child object named Object stores licensing data it may be desirable for that data to be tamper resistant. However subsequent data e.g. the data stored in a child object named Object N may be less sensitive to tampering. Therefore performance may be improved by limiting error checking to only data sensitive to errors. In other words this technique may be used to reduce initial costs e.g. processor time associated with validating the data stored in the virtualized application file and or the xlayer file .

The body section includes a number of child objects . Each of the child objects has a simple format illustrated in a complex format illustrated in or a collection format illustrated in . Referring to an object having the simple format is referred to as a simple object and an object having the complex format is referred to as a complex object. The collection format is configured to store a collection of simple or complex objects.

Each of the simple complex and collection formats and includes a content type indicator and the size indicator . The content type indicator is positioned first in each of the simple complex and collection formats and and indicates whether an object has the simple format the complex format or the collection format . By way of a non limiting example an object may be identified as having the collection format when a highest order bit in the content type indicator is set. In such an embodiment if the highest order bit is not set the object has the simple format or the complex format .

The content type indicator identifies the type of data stored in the object. Further the content type indicator indicates which data items other than the content type indicator and the size indicator are included in the object. For example as shown in when the content type indicator indicates the content type of an object is File see Table A below the object has the simple format configured to store seven data items other than the content type indicator and the size indicator . This format is referred to as a File simple format and has been identified in by reference numeral A. On the other hand as shown in when the content type indicator indicates the content type of an object is RegValue see Table A below the object has the simple format configured to store four data items other than the content type indicator and the size indicator . This format is referred to as a RegValue simple format and has been identified in by reference numeral B.

Non limiting examples of other types of content are provided in a leftmost column of Table A below. The rightmost column of Table A indicates in which format the simple format or the complex format the content may be stored. By way of a non limiting example the content type indicator may be implemented as a 32 bit integer.

Each of the simple and complex formats and also includes the size indicator . The size indicator identifies a location in memory that corresponds to the end of the object. By way of a non limiting example the size indicator may be implemented as a 32 bit integer.

Turning to the simple format includes the content type indicator the size indicator and a predetermined sequence of data items each having a simple data type. The term simple data type refers to basic data types such as integers strings flags Booleans byte arrays and the like. In the embodiment illustrated the data in a simple format is ordered with the content type indicator being first followed by the size indicator which is followed by the predetermined sequence of data items. The sequence illustrated includes simple data types named DATA DATA . . . DATA N. The location in memory to which the size indicator refers is identified in by a curved arrow A. 

Referring to the complex format includes the content type indicator the size indicator a header section and a body section . In the embodiment illustrated the data in the complex format is ordered with the content type indicator being first followed by the size indicator which is followed by the header section which in turn is followed by the body section . The location in memory to which the size indicator refers is identified in by a curved arrow A. 

The format of the header section is similar to the simple format but omits the content type indicator . Specifically the header section includes the size indicator followed by a predetermined sequence of data items each having a simple data type. The sequence illustrated includes simple data types named DATA DATA . . . DATA N. The location in memory to which the size indicator in the header section refers is identified in by a curved arrow A. The header section stores information related to the complex object itself.

The body section includes any number of child objects . The child objects illustrated include objects named CHILD OBJECT CHILD OBJECT . . . CHILD OBJECT N. Each of the child objects may have the simple format the complex format or the collection format . Therefore each of the child objects includes the content type indicator and the size indicator .

Referring to the collection format includes the content type indicator the size indicator a count indicator and a number of collection objects . In the embodiment illustrated the data in the collection format is ordered with the content type indicator being first followed by the size indicator which is followed by the count indicator which is followed by the collection objects . The collection objects illustrated include objects named OBJECT OBJECT . . . OBJECT N. 

As mentioned above an object has the collection format when the highest order bit of the content type indicator is set. When the highest order bit of the content type indicator is set the lower order bits of the content type indicator indicate the format of the data stored in the collection objects . For example when the highest order bit is set and the lower order bits indicate the content type of the collection object is File see Table A above each of the objects in the collection objects has the File simple format A illustrated in . Thus each of the collection objects has the content type identified by the content type indicator of the collection.

The size indicator refers to an address of the last object in the collection objects . The location in memory to which the size indicator refers is identified in by a curved arrow A. 

The count indicator indicates how many collection objects are in a collection. By way of a non limiting example the count indicator may be implemented as a 32 bit integer.

Each of the collection objects has the simple format the complex format or the collection format . Therefore each of the collection objects includes the content type indicator and the size indicator .

Referring to the body section of the file format resembles the body section see of a complex format and may include any number of child objects . Referring to the child objects of the file format may have the simple format the complex format or the collection format . The minor version identifier of the file format may be incremented for informational purposes when a new simple element is added to the simple format of a preexisting content type a simple element is added to the header section of the complex format for a particular content type or a new child object is added to the body section of the complex format for a particular content type.

As explained above referring to the data in the virtualized application file and or the xlayer file may include one or more virtual layers. As shown in Table A when the content type indicator indicates the content type is Layer the object has the complex format configured to store virtual layer data. This format is referred to as a Layer complex format and has been identified in by reference numeral A.

By way of a non limiting example the virtualized application file and or the xlayer file may include a virtual layer for each different host operating system or host runtime environment on which the virtual application is configured to be executed. Further as explained above the virtual application may be implemented using one or more executable files and or xlayer files. Therefore to execute a single virtual application the reader of the virtual runtime engine may need to parse more than one complex object having the Layer complex format A.

The Layer complex format A stores information used to configure the virtual filesystem and the virtual registry . In the header section the layer format A has a name indicator for storing the name of the virtual layer and a flags indicator . The flags indicator indicates whether an object having the Layer complex format A is a System layer. A System layer includes items such as a licensing module used by the virtual runtime engine. These items may be created by the authoring tool . In particular implementations the items are not authored by the authoring tool and not by a user. In the body section the Layer complex format A includes nine child objects .

A first child object named Condition is a simple object of type LayerCondition see Table A above . This object specifies a condition for including or excluding the content of the parent Layer complex object. For example the condition may identify a particular operating system and whether to include or exclude the parent Layer complex object depending upon whether the host operating system is the particular operating system specified.

A second child object named FileSystem is a collection of objects having the content type Directory see Table A above . Objects having the content type Directory are referred to herein as Directory complex objects. As indicated in Table A above an object having the content type Directory has the complex format see configured to store directory information. This format is referred to as a Directory complex format and has been identified in by reference numeral B. Therefore in the second child object each of the child objects has the Directory complex format B.

As is apparent to those of ordinary skill in the art files and directories are organized in the virtual filesystem in a hierarchical structure with a root directory storing files and subdirectories located at the base of the hierarchy and nodes subdirectories linked to the root directory. The collection of Directory complex objects of the second child object stores subdirectories used to configure a root directory of the virtual filesystem . The collection of Directory complex objects may be configured to mirror the subdirectories stored in a root directory by a natively installed version of the application. If the virtual application is executed using more than one virtual layer each virtual layer may configure a portion of the same root directory. Alternatively two or more of the virtual layers may configure subdirectories within the virtual filesystem . Referring to each of the Directory complex objects of the second child object see corresponds to a subdirectory and has the Directory complex format B.

The Directory complex format B includes a flags indicator and a name indicator in the header section . The flags indicator indicates one or more values assigned to properties of the subdirectory in the virtual filesystem . By way of non limiting examples the flags indicator may include bits indicating which of the following flags have been set to TRUE isolated merged empty read only and hidden. When the flag isolated is set to TRUE the directory is isolated from the host operating system . When the flag merged is set to TRUE the directory is merged with a corresponding directory on the host filesystem . When the flag empty is set to TRUE the directory is empty i.e. the directory does not include any files or subdirectories . When the flag read only is set to TRUE the contents of the directory are read only. When the flag hidden is set to TRUE the directory is hidden. The flags indicator may be implemented as a 32 bit integer.

The name indicator indicates the name of the subdirectory to which the Directory complex object corresponds. The name indicator may be implemented as a string.

In the body section each of the Directory complex objects of the second child object includes a collection of simple objects of the type File File simple objects and a collection of Directory complex objects.

Each of the File simple objects of the collection corresponds to a file stored in the subdirectory to which its parent Directory complex object corresponds. Referring to each of the File simple objects has a File simple format A that includes a flags indicator a PayloadOffset indicator a PayloadSize indicator a FullSize indicator a RandomSeed indicator a name indicator and a MD5 field .

The flags PayloadOffset PayloadSize FullSize and RandomSeed indicators and may be implemented as 32 bit integers. The PayloadOffset indicator indicates a location of the start of the block of data or payload corresponding to a location in memory whereat the data stored in the File simple object begins. Thus the PayloadOffset indicator refers to an offset whereat bytes of file data begin. These bytes may be raw or compressed. The PayloadSize indicator indicates the size of the payload starting at the location stored in the PayloadOffset indicator . The FullSize indicator indicates an uncompressed size of the data stored in the File simple object. The value of the FullSize indicator will be the same as value of the PayloadSize indicator when the bytes of file data are not compressed.

The RandomSeed indicator may be used to obfuscate the contents of the data stored in the File simple object. In this manner files may be less recognizable within the virtualized application file and or the xlayer file . The RandomSeed indicator may be used to perform a function or transform e.g. XOR on the bytes of file data. For example an XOR function may be used on the RandomSeed indicator and the first byte of the file data. After each XOR operation a result of the operation may be used to compute a new seed value e.g. using a simple pseudo random sequence generating function that may be used on the next byte of file data.

The MD5 field stores a hash value that may be used as a unique identifier for the data stored in the File simple object. By way of another non limiting example the MD5 field may be used determine whether the data stored in the File simple object includes an error. The MD5 field may be implemented as a blob e.g. a blob of 16 bytes .

Returning to subdirectories within the subdirectories of the root directory may be stored within one or more of the Directory complex objects stored within the collection of Directory complex objects. In other words the Directory complex objects used to configure the virtual filesystem may be nested and used to configure a hierarchical directory structure.

Returning to a third child object is a collection of complex objects of type RegKey RegKey complex objects . In the third child object each of the child objects is a RegKey complex object and has the RegKey complex format C illustrated in . As is apparent to those of ordinary skill in the art key and key values are organized in the virtual registry in a hierarchical structure have a root node storing keys at the base of the hierarchy. Sub keys or sub nodes are linked to the root node. The third child object stores the keys used to configure the root node of the virtual registry . Each of the RegKey complex objects of the third child object corresponds to a key. If the virtual application is executed using more than one virtual layer each virtual layer may configure a portion of the same root node of the virtual registry . Alternatively two or more of the layers may configure different sub nodes or sub keys of the virtual registry .

Referring to the RegKey complex format C includes a flags indicator and a name indicator in the header section . The flags indicator may be substantially similar to the flags indicator see . The flags indicator indicates one or more values assigned to properties of the registry key in the virtual registry . By way of non limiting examples the flags indicator may include bits indicating which of the following flags have been set to TRUE isolated merged empty read only and hidden. However depending upon the implementation details the flags indicator may exclude the hidden flag. The flags indicator may be implemented as a 32 bit integer.

The name indicator indicates the name of the key to which the RegKey complex object corresponds. The name indicator may be implemented as a string.

In the body section each of the RegKey complex objects includes a collection of simple objects of the type RegValue see Table A above and a collection of RegKey complex objects.

Each of the RegValue simple objects of the collection corresponds to a registry value stored in the sub key to which its parent RegKey complex object corresponds. Each of the RegValue simple objects of the collection corresponds to a key value.

Referring to a RegValue simple object has a RegValue simple format B that includes a Name indicator a NameTupleInfo indicator a ValueType indicator and a ValueData field . The Name indicator may be implemented as a string. The NameTupleInfo indicator may be implemented as an array of 16 bit integers. The ValueData field may be implemented as a string a 32 bit integer a 64 bit integer or a blob e.g. a blob of 16 bytes . The ValueType indicator indicates the type of the ValueData field and may be implemented as a 16 bit integer.

Additional sub keys within the sub keys of the root node may be stored within one or more of the RegKey complex objects stored within the collection of RegKey complex objects of . In other words the RegKey complex objects used to configure the virtual registry may be nested and used to configure a hierarchical registry key structure.

Returning to a fourth child object is a collection of simple objects of type Service Service simple objects . Each of the Service simple objects stores configuration information for a virtual service e.g. a virtual Windows service . For example SQL Server is a Windows service. Thus the Layer complex object may include a Service simple object for SQL Server.

A fifth child object is a collection of simple objects of type EnvironmentVariable EnvironmentVariable simple objects . Each of the EnvironmentVariable simple objects stores configuration information for a virtual environment variable e.g. a virtual Windows environment variable . For example PATH is an environment variable typically used by a Windows operating system. Thus the Layer complex object may include an EnvironmentVariable simple objects for the PATH environment variable.

A sixth child object is a collection of simple objects of type ShortcutDir ShortcutDir complex objects . Each of the ShortcutDir complex objects stores configuration information for a virtual shortcut folder e.g. a virtual Windows shortcut folder typically located in a start menu . Shortcut simple objects may be included as child objects see in a ShortcutDir complex object.

A seventh child object is a collection of complex objects of type ProgId ProgId complex objects . Each of the ProgId complex objects stores a virtual program identifier ProgId such as a virtual Windows ProgId. An example of a virtual Windows ProgId is Microsoft.Word.12. A ProgId uniquely identifies an application and is often used to associate an application with one or more file types and or actions provided by the application.

A eighth child object is a collection of simple objects of type Font Font simple objects . A font file is a special file that provides all information needed to render a particular font or style of print such as Times New Roman. Each of the Font simple objects stores a font file. The Font simple object is substantially similar to the File simple object but includes an additional property needed to initialize the font file at the startup of the virtual application.

A ninth child object is a collection of simple objects of type SnapshotDirectory SnapshotDirectory simple objects . Each of the SnapshotDirectory simple objects stores a path identifier and a folder identifier such as an IdProgramFiles indicator . As is apparent to those of ordinary skill in the art the authoring tool see may be used to create the virtualized application file and or the xlayer file on a first computing device. Then these files may be executed a second different computing device. The path and folder identifiers are used to normalize any file path encountered at runtime that refers to a location on a computing device on which the virtual application was configured instead of a location on the second computing device . When such a path is encountered it is replaced with a path on the second computing device using the path and folder identifiers of the SnapshotDirectory simple object.

Referring to as explained above each of the simple complex and collection formats and includes the content type indicator and the size indicator . The content type indicator is used to identify which type of data is stored in the object. Using the content type indicator the virtual runtime engine identifies which portions of the virtualized application file and or the xlayer file to expand and which portions to skip or defer for later expansion. In particular implementations it may be beneficial to skip expansion of Directory complex objects and or RegKey complex objects.

The reader of the virtual runtime engine uses the size indicators to skip one or more portions of data stored in the virtualized application file and or the xlayer file . For example some files stored in File simple objects and subdirectories stored in Directory complex objects of a Layer complex object may be useful for desktop integration but are not needed to execute the virtual application . During the virtual application startup routine the reader may use the various size indicators included in the simple complex and collection formats and to skip over portions of the data useful for desktop integration.

Further the size indicators may be used to parse the portions of the virtualized application file and or the xlayer file used to configure the virtual filesystem and or the virtual registry . For example at initial startup the Directory complex objects in the second child object i.e. the subdirectories can be skipped and offset placeholders stored for each Directory complex object that may be used later to expand skipped directories on demand. Further the RegKey complex objects in the third child object illustrated in i.e. the sub keys can be skipped and offset placeholders stored for each RegKey complex object that may be used later to expand skipped sub keys on demand. Only when the virtual application actually needs to access the skipped subdirectories or sub keys are those portions of the Layer complex object parsed. In this manner expansion of nested subdirectories and sub keys may be deferred at each level until the nested information is needed. This process may be characterized as a type of deferred recursion.

In first block the reader identifies a Layer complex object to read. In next block the reader performs a method described below to read or parse the Layer complex object identified in block . In decision block the reader determines whether the Layer complex object identified in block is the last Layer complex object to be read. If the Layer complex object is the last Layer complex object to be read the decision in decision block is YES. If the Layer complex object is not the last Layer complex object to be read the decision in decision block is NO. If the decision in decision block is YES the method terminates. On the other hand if the decision in decision block is NO in block the reader identifies the next Layer complex object and returns to block .

In decision block the reader determines whether the first child object is a collection having the collection format . If the first child object is a collection the decision in decision block is YES. If the first child object is not a collection the decision in decision block is NO. 

If the decision in decision block is NO in decision block the reader determines whether to read the first child object or defer reading the first child object. A function named IsDeferredType may be used to determine whether the content type e.g. Directory is to be deferred. If the function determines content of this type is to be deferred the decision in decision block is YES. If the function determines content of this type is to be read the decision in decision block is NO. 

If the decision in decision block is YES in block the reader determines the offset value and stores the offset value in an appropriate data structure so that the deferred portion may be expanded at a later time when needed. For example if the deferred data is a Directory complex object i.e. the data for configuring a subdirectory in the virtual filesystem the offset value may be stored in a subdirectory used as a placeholder in the virtual filesystem . The placeholder subdirectory may be empty except for the offset value and have the name indicated by the Name indicator in the skipped Directory complex object. The offset value indicates where in the virtualized application file or the xlayer file the skipped data may be located when need. By way of another example if the deferred data is a RegKey complex object i.e. the data for configuring a sub key in the virtual registry the offset value may be stored in a sub key used as a placeholder in the virtual registry . The placeholder sub key may be empty except for the offset value and have the name indicated by the Name indicator in the skipped RegKey complex object. The offset value indicates where in the virtualized application file or the xlayer file the skipped data may be located when need.

In block after storing the offset value the reader advances in the data stream e.g. the virtualized application file or the xlayer file by the amount specified in the offset value.

When the virtual application needs to access the data stored in a skipped subdirectory or a skipped sub key a method described below and illustrated in may be used.

Then decision block of determines whether the current child object of the Layer complex object is the last child object. If the current child object is the last child object the decision in decision block is YES. If the current child object is not the last child object the decision in decision block is NO. 

If the decision in decision block is YES the method terminates. If the decision in decision block is NO in block the reader reads the content type indicator of the next child object of the Layer complex object and returns to decision block .

If the decision in decision block is NO in block the reader reads the data in the child object and stores it in the appropriate data structure in the virtual runtime environment. For example if the child object is a LayerCondition simple object e.g. the first child object the environmental variable values are read from the EnvironmentVariable simple object and used to set the values of corresponding environmental variables in the virtual runtime environment. Then the reader returns to decision block .

If the decision in decision block is YES in block the reader performs a method to read a collection of objects. Then the reader advances to decision block .

If the decision in decision block is YES in block the reader determines the offset value and stores the offset in an appropriate data structure so that the deferred portion may be expanded at a later time when needed. For example if the deferred data is a Directory complex object i.e. data for configuring a subdirectory in the virtual filesystem the offset value may be stored in a subdirectory used as a placeholder in the virtual filesystem . The placeholder subdirectory may be empty except for the offset value and have the name indicated by the Name indicator in the skipped Directory complex object. The offset value indicates where in the virtualized application file or the xlayer file the skipped data may be located when need. By way of another example if the deferred data is a RegKey complex object i.e. data for configuring a sub key in the virtual registry the offset value may be stored in a sub key used as a placeholder in the virtual registry . The placeholder sub key may be empty except for the offset value and have the name indicated by the Name indicator in the skipped RegKey complex object. The offset value indicates where in the virtualized application file or the xlayer file the skipped data may be located when need.

When the virtual application needs to access the data stored in a skipped subdirectory or a skipped sub key the method described below and illustrated in may be used.

Then decision block of determines whether the current collection object of the collection is the last object in the collection. If the current object is the last object in the collection the decision in decision block is YES. If the current object is not the last object in the collection the decision in decision block is NO. 

If the decision in decision block is YES the method terminates. If the decision in decision block is NO in block the reader reads the content type indicator of the next object of the collection and returns to decision block .

If the decision in decision block is NO in block the reader reads the data in the collection object and stores it in the appropriate data structure in the virtual runtime environment. For example if the collection object is an EnvironmentVariable simple object the environmental variable values are read from the EnvironmentVariable simple object and used to set the values of corresponding environmental variables in the virtual runtime environment. Then the reader advances to decision block .

An exemplary implementation of the method is provided in the following pseudocode. The pseudocode defines a function named ExpandDeferredRegion. The ExpandDeferredRegion function receives a single parameter a structure named SChildDataForLayer having two members an OwningLayer member and an Offset member may be used to store offset placeholders.

As explained above virtual applications can be implemented using more than one Layer complex object. The OwningLayer member identifies the particular Layer complex object being parsed. The Offset member identifies a start location of a collection of objects to be parsed. By way of a non limiting example the start location is the beginning of the size indicator of a collection of objects.

In this example the ExpandDeferredRegion function reads binary data from the collection of objects wherein the size indicator is followed by the count indicator . The collection of objects may be the second child object and or the third child object . Further the collection of objects may be a Directory complex object nested inside the second child object and or a RegKey complex object nested inside the third child object . In the pseudocode below a BinaryReader class provided by .NET is used. The BinaryReader class provides a plurality of predefined read operations such ReadInt ReadString etc. The ReadInt function reads a four byte signed integer from the current stream i.e. the size indicator and advances the current position of the stream by four bytes.

In the pseudocode above the reader reads the content type indicator of each object of the collection blocks and . The function named IsDeferredType determines whether data in a particular object in the collection is to be deferred based on the content type indicator of the object block . The IsDeferredType function returns TRUE when data stored in a object is to be skipped or deferred and FALSE otherwise. If subdirectories and sub keys are to be skipped the IsDeferredType function returns TRUE when the content type indicator of the object is Directory or RegKey. In such an implementation if the content type indicator of the object is other than Directory or RegKey the IsDeferredType function returns FALSE. 

When the IsDeferredType function returns TRUE the ExpandDeferredRegion function determines the current position of the reader in the object and stores the current position in a variable named currentPosition. Then the ExpandDeferredRegion function reads the size indicator of the child object and stores it in a variable named skipSize. The value stored in currentPosition is stored in the Offset member of an instance of the SChildDataForLayer struct named childData. A function named StoreChildDataForDeferredExpansion is called to store the value of the variable currentPosition i.e. the value stored in the Offset member of the structure named childData in the data structure being populated e.g. a virtual directory or virtual registry key node block . Then the ExpandDeferredRegion function sets the reader position to the end of the deferred child object i.e. the location at a sum of the value of the variable named currentPosition and the value of the variable named skipSize . Thus the data structure being populated has the starting position from which to start reading when the skipped portion needs to be expanded.

When the IsDeferredType function returns FALSE a function named ReadItemNormally reads or expands the child object block .

With this deferred expansion of the data used to configure and populate the virtual filesystem and the virtual registry only those portions of the virtual filesystem and virtual registry actually accessed by the virtual application need to be expanded which may save a significant amount of time spent parsing the Layer complex object.

In next block the skipped portion of the virtualized application file or the xlayer file is identified. The skipped portion is stored within an object having either the simple format see or the complex format see . Therefore in block the reader identifies a single object having either the simple format or the complex format stored inside a Layer complex object. However the particular data requested may be stored within one or more objects nested inside the object identified. Therefore to locate the requested data the reader may have to parse several layers of nested objects.

When the virtual runtime engine encounters a skipped directory e.g. the subdirectory named program in block the reader identifies the corresponding object by reading the information identifying the Layer complex object and the offset value stored in the skipped subdirectory in the virtual filesystem . The data structure named SChildDataForLayer may be used to store the start location of the skipped portion and to identify the Layer complex object in which the skipped portion resides.

Then in decision block the reader determines whether the skipped object is a complex object. The decision in decision block is YES when the skipped object is a complex object. The decision in decision block is No when the skipped object is a simple object.

If the decision in decision block is NO in block the reader reads the data in the simple object and then the method terminates. On the other hand if the decision in decision block is YES in block the reader performs the method of to expand the complex object.

In decision block the reader determines whether the requested data has been expanded. For example at this point the directory named program may have been expanded using the method . However the subdirectories stored in the collection of directories associated with the Directory complex object corresponding to the directory named program would have been skipped when the method of was performed to expand the collection of Directory complex objects. Therefore at this point the requested data has not yet been expanded.

The decision in the decision block is YES when the requested data has been expanded. On the other hand the decision block is NO when the requested data has not been expanded. If the decision in the decision block is YES the method terminates. If the decision in the decision block is NO in block the reader identifies a next object in a path to the requested data e.g. the Directory complex object corresponding to the directory named first and returns to the decision block .

Because each object incorporated in the file format see indicates its own size via the size indicators and child objects are self describing via the content type indicator the code that implements the reader of the virtual runtime engine can be made tolerant of unfamiliar simple and complex object types. This allows older virtual machine runtimes to be made compatible with newer virtualized application files and or xlayer files provided their major version identifiers are the same. Likewise the code implementing the virtual runtime reader can be made tolerant of reading older virtualized application files and or xlayer files in which certain simple and complex object types may not be found or in which the format of one or more the simple and or complex object types has changed.

Forward and backward compatibility may be provided at least in part by a SizeReader class that may used to read data from the Layer complex object. The SizeReader class may be derived from the BinaryReader class provided by the .NET framework offered by Microsoft Corporation. However the SizeReader class differs from the BinaryReader class in that the SizeReader class knows how much data is stored in the object. If the reader tries to read past the end of the object a default value is returned. Furthermore when reading is finished the underlying stream is taken to the end of the current object even if all of the data has not yet been read. In other words the reader jumps to the end of the object being read. If new data items are added after those of previously included in the format when the reader jumps to the end of the object being read the reader ignores the new data items with which the reader is unfamiliar.

As a derived class the SizeReader class supports operations provided by the BinaryReader class such as ReadInt ReadString etc. However several functions may be modified or overridden. A portion of a basic class specification for the SizeReader class is provided below 

For the sake of brevity most of the BinaryReader methods have been omitted from the basic class specification provided above. However three of the overridden functions ReadBytes ReadInt and ReadString have been provided as examples. As mentioned above each of these functions has been modified to return a default value. The constructor to this class uses a function named OnSizeValue to determine an amount of data stored in an object. The amount of data stored in an object informs the reader as to how much data there is to be read in the child objects. A function named Dispose is called when reading with respect to a particular object is finished. If the Boolean type variable named disposing is TRUE the Dispose function calls a function named DoneReading which sets the underlying stream to the end of the object.

An example of how the simple and complex formats and provide forward and backward compatibility will now be described. illustrates a simple object configured for a version 1.0 of the virtual runtime engine. Thus the xlayer file or the virtualized application file in which the simple object is stored has a format version 1.0 i.e. the major version identifier has a value of 1 and the minor version identifier has a value of 0 . The content type indicator identifies the simple object as having type RegValue. As explained above a RegValue simple object may be used to store a register key value. The simple object has a format B V1.0 which is identical to format B illustrated in . Thus the simple object includes the content type indicator the size indicator and four simple data items the Name indicator e.g. a string the NameTupleInfo indicator e.g. a 32 bit integer the ValueType indicator e.g. a number of bytes or block of binary data and the ValueData field .

The dashed lines L and L above and below the RegValue simple objects and depicted in respectively indicate that the simple objects and may be located within the binary data of the Layer complex object i.e. within the data stream read from the Layer complex object .

The following pseudocode demonstrates how the reader of the virtual runtime engine version 1.0 might read the simple object illustrated in configured for a version 1.1 of the virtual runtime engine.

The last line in the pseudocode above jumps to the end of simple object without having had read all of the simple data items. In other words the Dispose function skips the isolation indicator with which the reader of the virtual runtime engine version 1.0 is unfamiliar.

The following pseudocode demonstrates how the virtual runtime engine version 1.1 might read the simple object illustrated in configured for a version 1.0 of the virtual runtime engine.

In the pseudocode above the reader attempts to read the isolation indicator that is not in 1.0 version of the RegValue simple object i.e. simple object . Thus the reader may be described as having read past the end of the simple object . As discussed above the reader knows the size of the simple object and can determine the reader has read past the end of the simple object . When this occurs a default value e.g. a 32 bit integer value of zero may be returned. Again in the last line of the pseudocode above the Dispose function is called after all known data items have been read.

In both cases the reading of the RegValue simple objects and proceeds without a problem. When a new data member is added to the simple or complex format for a particular content type it is desirable to ensure that the SizeReader class is configured to provide a default value for the new data member that has the correct semantics for older versions of the object format. For example when the reader for the virtual runtime engine version 1.1 reads the simple object and obtains the default value e.g. 32 bit integer value of zero provided for the isolation indicator the virtual runtime engine version 1.1 should respond in a manner substantially similar to the manner in which the reader for the virtual runtime engine version 1.0 reads would respond when reading the simple object .

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the virtual application file the xlayer file the authoring tool and or virtual runtime engine may be implemented using one or more computing devices like the computing device . By way of non limiting example the virtual application file the xlayer file the authoring tool and or virtual runtime engine may be implemented on the computing device .

The computing device includes the system memory a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the host operating system the virtual application file the xlayer file the authoring tool and or virtual runtime engine may be stored as computer executable components on the system memory . Each of the host operating system the virtual application file the xlayer file the authoring tool and or virtual runtime engine may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

