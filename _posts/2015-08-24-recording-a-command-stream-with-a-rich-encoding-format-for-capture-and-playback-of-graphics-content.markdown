---

title: Recording a command stream with a rich encoding format for capture and playback of graphics content
abstract: Analyzing an application executing on a target device. An application may be executed on a target device. Low cost measurement may be gathered regarding the application executing on the target device. In response to a trigger, high cost measurement data may be gathered regarding the application executing on the target device. The high cost measurement data may include graphics commands provided by the application. The graphics commands and related information may be stored and provided to a host. The host may modify the graphics commands to perform experiments to determine performance issues of the application executing on the target device. The host may determine whether the performance is limited by the CPU or the GPU and may determine specific operations that are causing performance issues. The host may provide suggestions for overcoming the performance issues.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09417767&OS=09417767&RS=09417767
owner: Apple Inc.
number: 09417767
owner_city: Cupertino
owner_country: US
publication_date: 20150824
---
This application is a continuation of U.S. patent application Ser. No. 14 139 467 filed on Dec. 23 2013 which is a continuation of U.S. patent application Ser. No. 12 896 097 filed on Oct. 1 2010 the entire contents of each of which are incorporated herein by reference.

The present invention relates to the field of computer graphics and more particularly to performance analysis of graphics applications.

Many modern devices include high end graphical processing systems for presenting graphics on a display. Due to their complexity development of graphical software applications for such devices is often difficult. For example development of software which interacts with the graphical processing system often results in sub optimal graphical system performance and resource utilization. In order to assist developers in creating graphical software applications improved tools are desired for detection of performance bottlenecks and opportunities for performance optimization in graphical application development.

Various embodiments are presented of a system and method for analyzing applications executing on a target device. In particular embodiments are presented for analyzing the performance of graphics applications applications which generate graphics for display .

The target device and a host device may be paired together. The host device may execute a development application to perform testing of an application on the target device. The host device may deploy the application to the target device and begin execution of the application on the target device. The host device may also deploy other programs on the target device in order to analyze the execution of the application on the target device. For example the host device may deploy one or more measurement or monitoring applications which may perform monitoring of the execution of the application while it executes on the target device.

For example the measurement programs may initially perform low cost measurement of the application while it executes on the target device. The low cost measurement of the application may not substantially impact performance of the application execution. The low cost measurement may provide execution information such as CPU load e.g. related to graphics processing or not GPU load frame rate etc.

The target device may include a graphics system which includes both a central processing unit CPU and a graphics processing unit GPU . During execution of the graphics application on the CPU of the target device the measurement software may measure execution load of the CPU and the GPU of the device and determine whether the CPU is limiting graphics performance of the graphics application. If the CPU is limiting graphics performance of the graphics application the measurement software may provide an indication to the host computer. The application developer can then use this information to modify the application.

During operation of the low cost measurement the measurement program may monitor for various conditions or triggers which indicate a performance issue that merits more detailed monitoring. In response to a trigger high cost measurement may be initiated e.g. by the measurement application . The high cost measurement involves a more detailed analysis of system performance which is hence more costly or more intrusive . The high cost measurement may be provided via automatic processes e.g. a detected drop in frame rate above a threshold amount increase in GPU load a threshold amount etc. or manually e.g. a user providing input to invoke the trigger .

During high cost measurement graphics commands provided by the application may be captured and recorded. For example graphics commands provided from the application to a graphics framework also executing on the target device may be intercepted by the measurement application. The measurement application may then store these commands and may also derive additional information regarding the commands or the state of the graphics system of the target device. The additional information may comprise data such as a timestamp indicating a time when the first graphics command was received or executed a duration of time for execution of a first graphics command state information indicating an execution state of the application a current graphics framework error at the time of receiving a respective graphics command a flag indicating that the first graphics command should not be executed on later playback of the plurality of graphics commands and or a graphics command that is not provided by the graphics application among numerous others. The additional information may be used in conjunction with the recorded command stream for later playback of the commands or for analysis as desired. The measurement application may also store related graphics information e.g. textures referenced by the graphics commands .

After completion of the high cost measurement a command stream as well as additional information may be stored by the host device. In one embodiment the command stream may be aggregated by the host device in response to provision of the commands additional data and associated graphics data by the target device.

The host device may generate one or more modifications to the command stream in order to determine performance issues or bottlenecks of the application that were present during the high cost measurement. For example the modifications may disable or simplify various portions of the graphics pipeline or individual operations in order to determine a cause of a performance issue. In some embodiments the modifications may comprise a modification to one or more of a shader resource or graphics state during execution of the modified command stream.

The modifications may be used to generate one or more modified command streams e.g. by the host or the target device which may then be executed by the target device. The modified command stream s may be executed by a player application that may be deployed on the target device. The player application may be configured to execute the various modified command streams. The target device may monitor execution of the various modified command streams in order to gather performance information of that respective modified command stream.

Accordingly the various modifications to the command stream may be executed and performance data may be gathered for each execution of the modified command stream. The performance data may be analyzed to identify performance issues of the application executing on the target device. Stated another way the host may try out different modifications to the recorded command stream to attempt to isolate respective portions of the application software that are causing bottlenecks or performance issues when run on the target device. Once the performance issues are identified one or more suggestions may be provided e.g. to the developer using the development program to overcome or address these performance issues.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

Memory Medium Any of various types of memory devices or storage devices. The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM DDR RAM SRAM EDO RAM Rambus RAM etc. a non volatile memory such as a Flash magnetic media e.g. a hard drive or optical storage registers or other similar types of memory elements etc. The memory medium may include other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide program instructions to the first computer for execution. The term memory medium may include two or more memory mediums which may reside in different locations e.g. in different computers that are connected over a network. The memory medium may store program instructions e.g. embodied as computer programs that may be executed by one or more processors.

Carrier Medium a memory medium as described above as well as a physical transmission medium such as a bus network and or other physical transmission medium that conveys signals such as electrical electromagnetic or digital signals.

Computer System any of various types of computing or processing systems including a personal computer system PC mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA personal communication device smart phone television system grid computing system or other device or combinations of devices. In general the term computer system can be broadly defined to encompass any device or combination of devices having at least one processor that executes instructions from a memory medium.

Automatically refers to an action or operation performed by a computer system e.g. software executed by the computer system or device e.g. circuitry programmable hardware elements ASICs etc. without user input directly specifying or performing the action or operation. Thus the term automatically is in contrast to an operation being manually performed or specified by the user where the user provides input to directly perform the operation. An automatic procedure may be initiated by input provided by the user but the subsequent actions that are performed automatically are not specified by the user i.e. are not performed manually where the user specifies each action to perform. For example a user filling out an electronic form by selecting each field and providing input specifying information e.g. by typing information selecting check boxes radio selections etc. is filling out the form manually even though the computer system must update the form in response to the user actions. The form may be automatically filled out by the computer system where the computer system e.g. software executing on the computer system analyzes the fields of the form and fills in the form without any user input specifying the answers to the fields. As indicated above the user may invoke the automatic filling of the form but is not involved in the actual filling of the form e.g. the user is not manually specifying answers to fields but rather they are being automatically completed . The present specification provides various examples of operations being automatically performed in response to actions the user has taken.

As shown in the computer system may include a display device configured to display a graphical user interface GUI e.g. of a control or development application executing on the computer system . The graphical user interface may include any type of graphical user interface e.g. depending on the computing platform. The computer system may include at least one memory medium on which one or more computer programs or software components according to one embodiment of the present invention may be stored. For example the memory medium may store the control application e.g. which may be executable to perform at least a portion of the methods described herein. Additionally the memory medium may store a programming development environment application or developer s tools application used to create applications e.g. for execution by the target device . The memory medium may also store operating system software as well as other software for operation of the computer system. Various embodiments further include receiving or storing instructions and or data implemented in accordance with the foregoing description upon a carrier medium.

As also shown in the target device may include a display which may be operable to display graphics provided by an application executing on the target device . The application may be any of various applications such as for example games internet browsing applications email applications phone applications productivity applications etc. The application may be stored in a memory medium of the target device . The target device may include a central processing unit CPU and a graphics processing unit GPU which may collectively execute the application. For example the CPU may generally execute the application as well as a graphics framework e.g. OpenGL DirectX etc. and graphics driver which may handle any graphics calls or commands that are provided by the application during execution. The graphics driver may in turn provide GPU commands to the GPU which may execute these commands to provide display capabilities for the application. As used herein a graphics application refers to an application which provides graphics commands for displaying graphics of the application on a display. In other words the term graphics application refers to a software application that when executed causes the display of various graphics on a display.

The memory medium of the target device may also store one or more programs for implementing embodiments described herein. For example the memory medium of the target device may store a program for capturing and encoding graphics commands received from the application. The memory medium of the target device may also store a program for playing back a stream of graphics commands e.g. which may be provided from the computer system . Further the memory medium of the target device may store a program for performing measuring or monitoring e.g. at different levels of detail of the application when it is executing on the target device . In further embodiments the programs may be stored on the computer system and may be read onto the target device for execution.

More specifically illustrates one embodiment of a hardware architecture of a target device computer system such as or . As shown the CPU and CPU memory may be coupled together e.g. over a system bus and GPU and GPU memory may also be coupled together. The CPU and GPU and their corresponding memories may be coupled via bus interface . For example in one embodiment the GPU and GPU memory may be implemented as a video system having a different system interface than the CPU and CPU memory . For example the GPU and GPU memory may be implemented as a video card that is plugged in to a slot of the computer system or . The video card may be implemented as a PCI PCIe AGP etc. card. Accordingly bus interface may interface with the system bus of the CPU and the bus of the video card. The target device or would also include display logic not shown as well as various other logic.

It should be noted that the above hardware architectures of the graphics system are exemplary and are provided for illustration purposes only. Thus various modifications e.g. of blocks or connectivity resulting in different hardware architectures are envisioned.

As shown in the host may execute a development environment or control application . The development environment may be used to develop applications for execution on the target device . The development environment may also control execution of a developed application a playback application a measurement application etc. that may be executing on the target device .

As also shown in the target device may execute a variety of programs including application measurement application playback application graphics framework and graphics driver . While this diagram largely shows programs that are executed by the CPU of the target device note that the GPU of the target device may also execute programs e.g. shaders that may be provided by the application .

In more detail the application or graphics application may be an application that is under development or testing e.g. within the development environment . For example a developer may be developing the application on the host for ultimate deployment and execution on the target device and may periodically need to test or debug the application while it is executing on the target device . Correspondingly the development environment may be used to deploy the application to the target device for execution and testing.

The development environment may also deploy other software to the target device to assist in developing the application e.g. once the developer has designated that the target device is used for development of the application . For example the development environment may deploy the measurement application which may measure or monitor the execution of the application on the target device . In some embodiments as described below the measurement application may be operable to measure or monitor at a first level of detail e.g. a first level of intrusion or cost and at a second higher level of detail e.g. at a second higher level of intrusion or cost . For example measuring at the first level of cost may provide fewer details than the second level of cost but may not impact performance of the execution of the application . On the other hand measuring at the second level of cost may garner more detailed information regarding the execution of the application e.g. the graphics performance of the application but may impact the performance of the execution of the application .

As described below when the measurement application operates in the second level of cost it may intercept and record graphics commands provided by the application to the graphics framework as shown referred to as graphics framework commands . However in alternate embodiments the measurement application may be configured to intercept and record commands at other times e.g. between the graphics framework and the graphics driver referred to as graphics driver commands or even commands from the graphics driver to the GPU referred to as GPU commands as desired. Further in one embodiment rather than being coupled to both origin and destination programs in the manner shown the measurement application may be interposed between the origin and destination programs or blocks .

These intercepted commands may be encoded as a command stream which may be used for further testing and analysis as described below. For example the development environment may deploy the playback application to the target device which may be configured to play back the intercepted recorded graphics commands e.g. to the graphics framework as shown or to other blocks depending on where the commands were originally intercepted. As discussed further below the playback application may be configured to play back various modified versions of the recorded graphics commands to try out various possibilities for improving application execution performance. Note that the playback application and the measurement application may be the same application.

The graphics framework may be any of various types of graphics frameworks e.g. various versions of openGL including openGL for embedded systems ES DirectX etc. The graphics framework may receive API calls from the application for performing graphics framework functions. In turn the graphics framework may provide commands to the graphics driver which may also be executing on the target device . Finally the graphics driver may provide GPU commands to the GPU. The CPU executing the graphics framework and the graphics driver along with the GPU may form a graphics pipeline such as those embodiments described in below.

Note that the above software architecture is exemplary only and other variations and modifications are envisioned. For example in some embodiments the graphics framework may not be necessary and or may be implemented as part of the application rather than being a separate executable.

In the graphics pipeline of the pipeline may begin with vertex data in . The vertex data may specify the vertices of the graphics data to be rendered. In one embodiment the vertex data may include data about polygons with vertices edges and faces that constitute an entire scene.

In the vertex data of may be processed by a vertex shader. More particularly the vertex shader may be run for each vertex e.g. by the GPU. This process may transform each vertex s 3D position in virtual space to the 2D coordinate at which it will appear on the display. The vertex shader may manipulate various properties including position color texture coordinate etc. As shown the vertex shader may be informed by texture data and or shader uniform data .

In primitives may be assembled from the vertices output from . For example in this stage vertices may be collected and converted into geometric shapes e.g. triangles.

In the primitives may be used in rasterization. More particularly the primitives from may be filled with pixels or fragments.

In the fragment shader e.g. executed by the GPU may add textures and final colors to the fragments. Fragment shaders may typically take into account scene lighting and related effects such as bump mapping and color toning. As shown the fragment shader may be informed by texture data and shader uniform data .

In various per fragment operations may be performed. For example the operations may combine the final fragment color its coverage and or degree of transparency with the existing data stored at the associated 2D location in the frame buffer to produce the final color for the pixel to be stored at that location.

In the data may be stored in physical memory which holds the actual pixel values displayed on the screen. The frame buffer memory may also store graphics commands textures and or other attributes associated with each pixel. This data may be used to output the final image to the display.

Thus illustrate exemplary graphics pipelines that may be utilized in embodiments described herein. However other different graphics pipelines are envisioned.

In a target device may be coupled or paired to a host device. As indicated above the target device and host device may be coupled together in a variety of ways e.g. directly via a wired or wireless connection or indirectly over a network e.g. an Intranet or the Internet .

In an application may be executed on the target device. For example the application may be developed using a development environment program executed by the host device. The user e.g. the developer may compile the application for execution and or deploy the application to the target device. As indicated above the development environment program may also deploy other programs to the target device e.g. measurement programs playback programs etc.

Once deployed on the target device the development environment program may initiate execution of the application and or any other programs such as those described above on the target device e.g. by sending an execution command to the target device. Thus in the application may be executed by the target device.

In during or after the execution of the application the target device may provide application execution information to the host device. The application execution information may be any of a variety of information. For example the application execution information may include information gathered by a measurement application executing on the target device while the application is executing. For example the measurement application may gather CPU load information GPU load information and or other information. In further embodiments the measurement application may intercept and record graphics commands provided by the application. The application execution information may include those graphics commands e.g. encoded in a bitstream . As described in below the application execution information may be gathered in response to input from the host device e.g. in response to explicit user input or may be gathered automatically based on various detected conditions or triggers .

In the execution information may be analyzed. For example the execution information may be analyzed to determine any execution issues or performance bottlenecks of the application. In some embodiments these issues may be particularly identified in relation to graphics performance. For example the execution information may be analyzed to determine which portion of the graphics pipeline is causing a performance bottleneck during execution of the application. The execution information may also be analyzed to determine if the CPU or GPU is limiting the graphics performance of the application. More details on this particular CPU GPU analysis is provided in below.

In some embodiments further analysis e.g. similar to and may be performed repeatedly as described in below in order to identify or determine various performance issues e.g. graphics bottlenecks of the application.

Finally in based on the analysis suggestions may be provided to increase performance or remove bottlenecks of the application. For example where a particular texture is determined to cause a performance bottleneck in the graphics pipeline the method may provide a suggestion to use a more compact or compressed version of the texture or even a different texture e.g. a less complex e.g. lower resolution texture. Thus the suggestions may help a developer create a more streamlined application particularly with respect to graphics of the application. Note that the suggestions may be specific to increasing performance of the application itself or may be specific to increasing performance of the application when specifically executing on a particular target device. For example improvements may not necessarily be required on a high performance system but may be required when the application is executing on a lower performance system. Additionally if a particular target device has a lower texture buffer the suggestions may be specific to improving performance because of that particular texture buffer on the particular target device. Thus the suggestions may be generic with respect to target devices but still specific to the application or target device specific as desired.

The analysis and provision of suggestions may be performed by the development environment program executing on the host device or by another application as desired. More specific methods and examples are provided below.

In low cost e.g. non intrusive or less intrusive measurement of execution of the application may be performed. More particularly the low cost measurement may measure graphics performance of the application. As indicated above the low cost measurement may be performed by a measurement application that is deployed e.g. stored in memory on the target device. Thus the measurement program may execute along with the application on the target device and may perform low cost measurement of the application executing on the target device. The low cost measurement may be performed at a level that does not substantially interfere with the execution of the application. For example in some embodiments the low cost measurement may not cause a perceptible by a user change in graphics performance of the application. In one embodiment during low cost measurement the application may execute with at least 90 95 98 99 etc. of the resources or processing time than it would have had if the low cost measurement were not being performed. In other embodiments the low cost measurement may cause a perceptible change in graphics performance of the application but this amount of perceptible change is quite a bit less than the amount of perceptible change caused by the high cost measurement.

In one embodiment low cost measurement may measure the following parameters frame rate of the graphics application executing on the target device percentage CPU utilization or CPU load percent of CPU time in graphics framework versus not percent of CPU time spent waiting for the GPU percentage of GPU utilization e.g. average tiler utilization percent and average render utilization percent GPU power consumption etc. The low cost measurement may also measure data specifically from the driver. For example the driver may be configured to record how long it spends in specific sections of the graphics pipeline e.g. including frame presentation wait time time spent waiting for the system to present the frame buffer and provide another render buffer texture upload time time spent uploading texture data to the GPU state validation time time spent validating that the graphics framework state is valid vertex copy time time spent converting and copying vertex data to the GPU etc. These times may be recorded using counters and may be used to determine relative percentages of time spent on these sections of the driver.

In some embodiments during the low cost measurement low cost measurement data may be provided from the target device to the host device. The provided low cost measurement data may include all or a portion of the parameters being measured during low cost measurement. Additionally the low cost measurement data may be provided for display by the host device e.g. for presentation to a user or developer using the host device.

In a trigger may be received to perform high cost measurement of the application. The trigger may be provided via a variety of mechanisms. For example in one embodiment the target device may be coupled to a host device during execution. During execution the host device may receive input from a user e.g. the developer to begin high cost measurement. For example the user may be monitoring graphics performance of the application on the target device or monitoring provided low cost measurement data. The user may then decide to manually invoke the high cost measurement of the application e.g. after perceiving a performance issue in graphics performance of the application. Accordingly the host device may provide a signal to the target device to begin the high cost measurement of the application thereby triggering the high cost measurement of the execution of the application. In alternate embodiments the user input may be provided directly to the target device instead of via the host device.

Alternatively or additionally the trigger may be detected provided in an automatic fashion. For example the device and or the host may have certain conditions that when detected during application execution will initiate the high cost measurement of the application. These conditions may be related to detected performance issues. For example the conditions may correspond to a graphics performance issue during execution of the application. In one embodiment the conditions may be based on the parameters being measured by the low cost measurement. For example the trigger may be a threshold frame rate or a threshold change in frame rate of the graphics of the application on the target device. The trigger may also be based on GPU load CPU load CPU graphics load e.g. CPU load devoted to the graphics driver framework or pipeline in general etc. For example the trigger may be based on a threshold change e.g. increase in one or more of GPU utilization GPU block utilization e.g. tiler rasterizer etc. graphics framework CPU utilization e.g. in general or specific to a particular task such as vertex copy state validation texture upload etc. GPU power usage etc.

The condition may be automatically determined by the host and or the target device. When determined by the target device the target device may simply utilize a condition detected by the low cost measurement information to automatically trigger the high cost measurement. When determined by the host device the target device may continually or periodically provide the low cost measurement information to the host device which may then analyze that information e.g. compared to previous measurement information to detect the condition. Accordingly upon detection of the triggering condition the host device may provide an interrupt or other signal to the target device to initiate and perform the high cost measurement of the application.

In one embodiment rather than capturing all of the low cost measurement data described above throughout execution of the application only the conditions for triggering may be monitored. Upon reaching a triggering condition the trigger a snapshot of the performance of the application may be gathered including all or a portion of the parameters described above in the low cost measurement portion e.g. CPU load GPU load GPU power etc. . Once this snapshot has been recorded the high cost measurement may be triggered as described. By capturing this snapshot this information may provide a baseline performance of the graphics application for the period of time when the high cost measurement is being performed since the high cost measurement impacts performance of the execution of the application. In other words the snapshot may provide the most accurate execution conditions for the period of time that high cost measurement is performed since it is directly preceding that time and the low cost measurement does not significantly impede application execution. Note that this snapshot may also be recorded after completion of the high cost measurement.

In in response to the trigger to begin high cost measurement high cost measurement e.g. intrusive measurement of the application may be performed. Unlike some embodiments of low cost measurement as indicated above high cost measurement may typically impact performance of the execution of the application. For example the high cost measurement may cause a noticeable by a user impact to performance of the application. The high cost measurement may be used to allow for more extensive testing of the application. For example the high cost measurement may continually measure more detailed information of execution of the application e.g. in a full profile mode . The high cost measurement may also record all graphics commands e.g. and associated graphics data for later analysis and playback e.g. in a record mode . describes one embodiment of a method for performing high cost measurement of an application executing on a target device. The low cost measurement and high cost measurement may be performed by the same measurement program or different measurement programs as desired.

In before during and or upon completion of the high cost measurement measurement information of execution of the application may be provided to the host device e.g. for further analysis as in above. The measurement information may include the high cost measurement information and or the low cost measurement information as desired. For example the low cost measurement information may be provided periodically during low cost measurement and the high cost measurement information may be provided periodically during the high cost measurement. Alternatively the measurement information may be provided after completion of each stage or after completion of all measurement.

By generally performing low cost measurement and only performing high cost measurement when certain undesirable conditions are detected a more accurate performance of the application executing on the target device is measured. Were an intrusive measurement always performed various problems might arise that are avoided using the method described above. For example intrusive measurement may not perturb the application evenly across different units or stages of the graphics pipeline which can disguise a performance bottleneck in one area e.g. by creating another in a different area. Additionally since the graphics of an application can achieve a maximum frame rate where graphics improvements become moot the graphics rate can be quantized by the refresh rate interval. Accordingly when such perturbation occurs it may be magnified due to the quantization caused by the refresh rate interval. Thus by performing low cost measurement to trigger high cost measurement these potential problems may be avoided.

Note that the method of may be performed repeatedly throughout execution of the application. For example low cost monitoring may be reinitiated after the high cost monitoring is terminated and the high cost monitoring may be retriggered at a later point in execution of the application. This process may continue until the application is terminated. Alternatively upon completion of the high cost monitoring the application may be automatically terminated.

In an indication to perform high cost measurement of an application executing on a target device may be received. For example the indication may be received as a trigger as described in above.

In a graphics command may be intercepted. For example the graphics command may be intercepted by a measurement application or graphics command capture application executing on the target device. In one embodiment the graphics command may be provided from the application and may be intended for reception by a graphics framework. In this embodiment the graphics command may be an API call from the application to the graphics framework. Accordingly the measurement application may intercept the command before it is provided to the graphics framework. In one embodiment the graphics command may be particularly intercepted by an interpose library e.g. the measurement application or a portion of the measurement application that may be injected into the application executing on the target device. Accordingly this library may intercept all graphics framework functions and other platform APIs and gather execution state information of the application and or target device when graphics commands are issued.

Alternatively the graphics command may be intercepted between the graphics framework and a graphics driver executing on the target device. In further embodiments the graphics command may be intercepted between the graphics driver and the GPU although those commands may be generally referred to as GPU commands rather than graphics commands.

In the graphics command may be stored in a first buffer. The graphics command may be stored in the buffer as originally received or may be modified. For example where the graphics command references additional graphics data e.g. texture data which is usually done via a pointer to a memory address the pointer may be modified to reference a file name or different storage path e.g. via a URI or URL . Further details regarding storage of the graphics data is provided in below. Additionally the graphics command may be encoded in a different format e.g. a bitstream than the original format.

Further additional data or additional information regarding the graphics command or associated with it may also be determined and stored in the first buffer. For example the additional data may be derived from the graphics command and or from the graphics system e.g. the state of the graphics system the GPU load the CPU load or any other information . Thus the additional data may be determined after the graphics command is intercepted and includes new data that was not included in the graphics command originally.

The additional data may be any of a variety of flags or commands. For example the additional data may include a no execute flag which may indicate that the graphics command should not be executed or should be ignored by any future playback applications but possibly not for analysis. The additional data may include an inserted command and associated flag which may indicate that the inserted command was generated by the measurement application and should be executed by playback applications but possibly not processed by other systems e.g. during analysis . For example the inserted command may add functionality such as creating a new surface or other graphics function.

The additional data may include a no trace flag which may indicate that the command should not be traced printed or displayed to the user by any system but should otherwise be considered for analysis. The additional data may include a backtrace e.g. a set of bytes representing the execution state of the application e.g. of a user space thread of the target device at the time the command was being executed. The backtrace may be encoded in a platform independent manner. The additional data may include trace events e.g. a set of bytes including a platform independent header followed by a platform dependent structure e.g. bitstream encoding various events state performance counters or data current at the time the command was being executed. In one embodiment this could be a bitfield indicating that certain events have occurred in the graphics framework or driver between the time of the previously intercepted command and the current command. Further the additional data may specify performance data e.g. graphics performance data of the application e.g. framerate CPU load GPU load etc. .

The additional data may include metadata for the command e.g. a set of bits indicating the nature of the command. In one embodiment this could be a set of bits indicating if the command is a C function or an Objective C method. This metadata may also specify an indicator for whether the format is big endian or little endian bit width or other bit formats etc. This additional data may be useful in ensuring that the graphics commands are later executable by target devices other than the one from which the commands are being captured e.g. which may have different bit formats or lengths .

The additional data may also indicate type information including for example core type e.g. storage characteristics of the data char float double etc. and semantic type e.g. number constant symbols etc. . By storing this typing information rich tracing may be more easily performed. For example a value can be converted to a string e.g. where the value is a constant which may allow the value to be later printed.

The additional data may also indicate that a particular value e.g. associated with the graphics command is a variable. In this embodiment rather than storing the value a new variable may be created. Accordingly when the graphics command is re executed e.g. in playback during analysis the returned value may be different but may be recognized as a variable thereby ensuring that the value of that variable is repeatable in later uses e.g. by later graphics commands during playback.

The additional data may include a thread ID e.g. a numerical identifier for the system thread in which the command was executing. The additional data may include a timestamp e.g. a timestamp relative to a capture clock or timer e.g. of the measuring application indicating the time at which the command was executed or captured e.g. encoded . The additional data may include the amount of time e.g. in nanoseconds that the command took to execute. The additional data may include a graphics framework error e.g. an OpenGL error which may indicate the current frameworks error e.g. part of the graphics framework state machine at the time the command was being executed.

In if the graphics command referenced any graphics data that graphics data may be stored in a second buffer although in other embodiments the data may be stored in the first buffer with the graphics command and additional data . The graphics data may include textures referenced by the graphics command. For example the graphics command may reference a texture stored in memory e.g. via pointers pointing to specific memory address es . Accordingly the graphics data may be retrieved from the memory and stored in the second buffer. In some embodiments any graphics data may be stored as individual files in the second buffer with corresponding names. For example a referenced texture may be stored as a single file per texture. Alternatively all of the graphics data may be stored in a graphics data file as desired. As indicated above the graphics command may be modified when stored in the first buffer to reference the new location or file name of the graphics data rather than the original pointer to the memory address es .

In some embodiments if the graphics data has been previously copied to the second buffer or previously copied in general a reference to the graphics data may be stored rather than re storing the graphics data itself thereby saving memory space and transfer time. Thus redundant graphics data may not be duplicated in the second buffer or for the graphics commands in general .

In the original graphics command may be provided to its destination. In some embodiments the graphics command may be provided from the measuring application to the destination e.g. the graphics framework e.g. in embodiments where the measuring application captured the graphics command and prevented it from being provided to the destination. Where the graphics command was captured between other entities e.g. between the framework and the driver it may be provided to the driver. Alternatively the graphics command may have been originally delivered to the destination but the measuring application may have copied the command prior to delivery. In this embodiment and may operate on the copy of the graphics command.

In the multiple stored graphics commands and associated additional data from the first buffer and the accumulated graphics data from the second buffer may be provided to the host device e.g. once the buffers are full. In some embodiments the graphics commands and additional data may be encoded e.g. as a bit stream. The graphics commands may have been encoded in or may be encoded at the time of transfer to the host device.

The process of may be performed multiple times within the high cost measurement. The commands additional data and graphics data may be aggregated as a file or directory which may be used for later testing and analysis as described in below. The commands and additional data and possibly the graphics data may be aggregated as a command stream. In embodiments where the command stream is encoded the encoded data may be a bit stream that includes a function identifier and descriptions of the arguments and values. For example for values that are sensitive to the platform e.g. pointer size endian character etc. the entire command stream may be marked such that it can be converted to the appropriate platform for later execution depending on the target device. Thus the command stream may be executable for playback on any of various different platforms regardless of the original platform on which it was recorded.

Finally in an indication to terminate the high cost measurement may be received e.g. from the host device.

As indicated in the descriptions of the method of may be performed a once or multiple times during the execution of the application as desired.

In a command stream and performance data may be received based on an application executing on a recording target device e.g. as described in above.

In the command stream may be provided to a target device for replay. The target device may be the same target device that the command stream was originally recorded by or another target device as desired. In some embodiments where the target device is the same as the device which recorded the commands of the command stream the target device may already have the command stream and may not need to be transferred to the target device for replay.

In one embodiment rather than using the performance data received from the recording target device executing the application the command stream may be replayed on the target device to determine a baseline performance of the command stream. Since the command stream may not constitute the whole of the application executing on the target device because other processes are executed during the application s execution this baseline performance may be more useful for comparison with executions of modifications to the command stream. Thus in one embodiment the command stream may be first executed on the target device and performance may be gathered on that execution of the command stream for comparison to later performance data.

The command stream may be executed in a variety of manners. For example the command stream may include initial state data that may be used to recreate the initial graphics state of the application when the command stream was initially recorded. Accordingly the target device may initiate the graphics framework graphics driver graphics pipeline memory mediums etc. to replicate the initial state when the command stream was recorded. The commands of the command stream may then be executed to generate the performance data. In some embodiments the commands may simply be executed a single time to generate the performance data.

However it may be desirable to execute the command stream multiple times to reach a steady state in execution and then generate performance data of execution of the command stream once that steady state has been reached. In order to execute the command stream multiple times the command stream may also store final state data that indicates the final graphics state of the application when the command stream was finished recording. This final state information may be used to generate a set of commands to revert the final state to the initial state. Accordingly the graphics system may be initiated at the initial state the command stream may be executed the set of commands to revert the final state to the initial state may be executed and the process may be repeated until a steady state is reached. As indicated above once this steady state is reached the performance data of the command stream may be recorded. This performance data may be based on a single execution of the command stream or may be based on multiple executions of the command stream e.g. an average or median execution of the command stream . By gathering performance data over multiple executions of the command stream more accurate performance data may be gathered.

In a modification to the command stream may be generated and provided to the target device. The modification to the command stream may be used to test a particular operation or portion of the graphics pipeline to determine if that operation is causing a performance issue or bottleneck for the application. Stated another way modifications to the command stream may be made to try out different execution scenarios or experiments in order to attempt to isolate various causes of performance issues. More detailed descriptions regarding the modifications to the command stream to perform testing are provided immediately after descriptions of .

In further embodiments in order to test a portion of the graphics pipeline various switches may be modified in the graphics driver to disable parts of the graphics pipeline. For example color writes may be disabled for the entirety of the command stream or within a portion of the command stream e.g. within a frame using graphics driver switches. These switches may be modified in addition to or potentially instead of the modification to the command stream. For example the graphics driver switches may be used to disable one or more portions of the graphics pipeline via initial state data thereby disabling the portion of the graphics driver for at least the beginning and potentially throughout the entirety of the execution of the command stream or may be set during playback of the modified command stream. In some embodiments the switches may be set as playback commands within the command stream. Alternatively or additionally the switches may be set externally e.g. as specified within a current test or experiment definition. When set externally the switches may be enabled or disabled on the fly during execution of the modified command stream in . In some embodiments the host may provide instructions to the target device for setting these switches during execution of the modified command stream e.g. as initial state data as part of an experiment definition and or as part of the modification to the command stream among other possibilities.

In the target device may modify the command stream e.g. using the command stream player application according to the modification to the command stream to generate a modified command stream.

In some embodiments rather than providing the command stream and then providing a modification to the command stream a modified command stream may be generated and provided to the target device. However modifications to the command stream are generally much smaller than the entirety of the command stream itself so when there are multiple tests or modifications to the command stream to perform it may generally be more efficient to provide the original command stream and subsequent modifications to the command stream. As used herein provision of one or more modified versions of the command stream may refer to provision of the modified command stream or simply provision of modifications to the command stream that may be used to generate modified command streams.

In the target device may execute the modified command stream and measure the performance of execution of the modified command stream e.g. using the low cost measurement of the measurement application. The execution of the modified command stream may be performed in a variety of ways as described above regarding the execution of the original command stream in .

In further embodiments rather than modifying the command stream and separately executing the modified command stream as in and above the original command stream may be modified dynamically or on the fly using the modification to the command stream. However even in this embodiment the target device is still executing the modified command stream but simply has not created an entire new modified command stream from the original command stream. Thus rather than creating a modified command stream the original command stream may be dynamically modified during execution using the modification received in .

In the performance data may be analyzed. More particularly the performance data between the different modifications may be compared to determine where there are performance issues or bottlenecks. For example in one embodiment the frame rates of each modified command stream may be compared to determine relative increases or decreases between each different modification. From this information relative information can be identified among the different modifications to determine where the performance issues are located e.g. in the graphics pipeline or at lower levels as desired . In one embodiment the analysis may yield a cost per command or statement in the command stream or even within a shader which may be utilized to determine the bottleneck s of the application executing on the target application via the modifications to the command stream.

In some embodiments the results of the analysis may be provided for display to the user e.g. the developer on the host device. For example where a particular stage of the graphics pipeline has been identified as causing a performance bottleneck for the application this information may be provided to the user. In one embodiment a graphics pipeline image may be displayed which highlights the portions of the pipeline that are causing a performance issue e.g. as a heat map . Where particular operations or shaders are causing performance issues these may be identified to the user as well.

In based on the analysis one or more suggestions may be provided. For example the suggestions may be provided to the user on the host device e.g. in the development application executing on the host device. The suggestions may be provided to the user in graphical or textual manners as desired. Exemplary suggestions and methods for providing that information are provided in the section below as well as in the descriptions of .

The modifications to the command stream may be performed to create tests used to isolate any performance issues or bottlenecks in the application. In general the tests may be initially used to isolate the problem at higher levels all the way down to per operation per command or per texture issues. Correspondingly the initial tests may identify a particular stage in the graphics pipeline that is causing the performance issue. From there that stage may be further analyzed e.g. through analysis of more particular modifications to the command stream to determine which specific operation command or texture within that stage is causing the performance issue. Once the issue s are particularly identified one or more suggestions may be provided to the user in order to overcome the identified issue s .

In one embodiment these modifications may be performed on a per operation basis and may disable various fragment processing disable complex texture filtering e.g. by using a less costly filtering mode when sampling from a texture such as blinear filtering instead of anisotropic filtering disable texture compression use a smaller mipmap reduce vertex information complexity etc. In general the experiments may modify one or more of the following to determine a graphics bottleneck e.g. after a stage has been identified as being problematic a shader a resource e.g. textures buffers vertex data index data etc. or a graphics e.g. framework state e.g. texture filtering alpha test state depth test state . Thus a shader e.g. a vertex shader or fragment shader may be replaced with a simpler shader or nonexistent shader identity version to remove the shader s effect a resource may be replaced with a simpler resource or removed and the state may be changed to a less intensive state as some examples. Additionally the modifications may add or remove different commands from the command stream as desired.

Based on these experiments specific and tangible optimization or improvement advice may be provided. For example if the bottleneck is determined to be bound by the GPU performing texture lookup the suggestions may include 

If the analysis determines that particular textures are responsible for this then the suggestions may specifically advise these optimizations for the identified textures.

The present render buffer may be disabled which may be performed on a per frame basis. Rendering in general may be disabled which may be performed on a per frame or per draw basis. Color writes may be disabled on a per frame or per draw basis. Depth writes may be disabled on a per frame or per draw basis. Stencil writes may be disabled on a per frame or per draw basis. Color masks may be overridden on a per frame or per draw basis. Rasterization may be disabled on a per frame or per draw basis. A minimal viewpoint may be used on a per frame or per draw basis. Cheap or cheapest texture filtering may be used on a per frame per draw or per texture basis. Small textures may be used on a per frame per draw or per texture basis. Compressed textures may be used on a per frame per draw or per texture basis. Texture uploads may be disabled on a per frame per draw or per texture basis. Minimal vertex shaders e.g. for OpenGL ES 2.0 may be used on a per frame per draw or per shader basis. Minimal fragment shaders e.g. for OpenGL ES 2.0 may be used on a per frame per draw or per shader basis. Alpha testings e.g. for OpenGL ES 1.1 may be disabled on a per frame or per draw basis. Fragment discards e.g. for OpenGL ES 2.0 may be disabled on a per frame per draw or per shader basis. Lighting e.g. for OpenGL ES 1.1 may be disabled on a per frame or per draw basis. Matrix palette e.g. for OpenGL ES 1.1 may be disabled on a per frame or per draw basis. Vertex fetching may be disabled on a per frame or per draw basis. Tiling may be disabled on a per frame or per draw basis. Interleaved vertex data may be forced on a per frame per draw or per vertex buffer basis. Optimal vertex format may be forced on a per frame per draw or per vertex buffer basis. Indexed drawing may be forced on a per frame per draw or per vertex buffer basis. Vertex buffer usage may be forced on a per frame or per draw basis. Index buffer usage may be forced on a per frame or per draw basis. Redundant calls may be removed on a per frame basis.

The following provides one embodiment a more detailed account of different experiments that may be performed to isolate performance issues of an application executing on a target device.

The following provides exemplary experiments for the pipeline of GPUs with fragment shader capabilities that may apply to both OpenGL ES1 and OpenGL ES2 applications 

The following provides exemplary experiments for the pipeline of GPUs without fragment shader capabilities 

By performing the various experiments above more detailed information regarding the specific resources shaders or states that are causing the performance issues may be gathered. Additionally specific suggestions for overcoming these issues may be presented to the developer. This provides a much more efficient and helpful system in assisting a developer create an application that makes efficient use of the graphics system and goes into a level of detail much greater than for example simply identifying that the GPU is limiting graphics performance. Thus the experiments described above may allow a developer to more easily to determine per operation bottlenecks and solutions.

In during execution of the graphics application performance information of the CPU and GPU may be measured e.g. by a measurement application executing on the target device. The measurement application may be performing low cost measurement of the application as described in above. However in further embodiments this information may be gathered while performing high cost measurement of the application or analysis of the high cost measurement as described in above.

In some embodiments the performance information may include CPU load and GPU load among other information. The CPU load may be measured in terms of overall CPU load CPU load while performing graphics operations e.g. CPU load of the graphics framework and or graphics driver and or CPU load while performing non graphics operations e.g. overall CPU load minus the graphics CPU load . The amount of CPU time spent waiting for the GPU or performing graphics related processing may be also measured. Further the load of the GPU may be measured.

By performing these measurements the performance cost of an application may be gauged with respect to CPU and GPU. This may also be extended to measure the CPU and GPU cost of specific graphics commands e.g. using the method of . For example a particular graphics command may provide a vertex array in a format that is not accepted by the GPU. The CPU may accordingly have to convert the vertex array from the original format to the GPU accepted format a graphics related process and provide that converted vertex array to the GPU to perform a draw operation. The performance information may include for example the duration start time and end time of that graphics related operation and or a sum of those durations for all graphics related operations e.g. by the CPU . Thus the original graphics command will have a performance cost in terms of both CPU and GPU and the overall application performance may be bound by the CPU s conversion the GPU s draw operation or neither depending on the application. Other CPU graphics related processing may include texture upload state validation etc. and similar data may be gathered for that processing.

However the CPU is generally also performing non graphics related processing e.g. for the application executing on the target application. Where this processing is particularly intensive it may be limiting the graphics performance of the application.

Thus the performance data in may be gathered to determine CPU and GPU costs during execution of an application on a target device.

Accordingly in based on the performance information it may be determined whether the CPU is limiting graphics performance of the application. More specifically it may be determined whether the CPU is limiting graphics performance due to graphics related processing or non graphics related processing. Where the CPU is limiting graphics performance due to non graphics related processing further graphics analysis may no longer be required. In some embodiments if possible the method may determine which non graphics related process is limiting graphics performance e.g. whether it is execution of the application a service executed by the target device another application etc. .

However if it is not based on non graphics related processing i.e. it is related to graphics processing it may be determined if the CPU s graphics related processing e.g. associated with the application is limiting graphics performance or if it is the GPU that is limiting graphics performance. This may be determined using for example the method of .

In an indication may be provided if the CPU is limiting graphics performance of the application. More particularly the indication may indicate a if the CPU is limiting graphics performance due to non graphics related processing b if the CPU is limiting graphics performance due to graphics related processing or c if the CPU is not limiting graphics performance in which case it is most likely that the GPU is limiting graphics performance . The indication may further include an identification of the performance bottleneck that is limiting graphics performance whether it is CPU or GPU related etc.

The method of may be incorporated with the method of . More particularly this analysis and indication may be performed along as a part of the analysis performed in . For example where the CPU is limiting graphics performance due to non graphics processing the method may stop and the analysis of may not be performed. However where the CPU is not limiting graphics performance due to non graphics processing the method of may be performed including determining whether CPU graphics related processing is causing performance issues for the application executing on the target device.

As shown in the user may select an application to be investigated. In this particular example the user e.g. the application developer may select iOS device and application . The user may then launch the performance analysis program using the launch button.

In the program may begin collecting evidence. More particularly at this stage the application may be executed on the target device and the user may provide input to initiate high cost measurement. Thus this Figure illustrates an exemplary GUI for initiating high cost measurement e.g. according to the method of .

In the program may perform high cost measurement e.g. in response to user input in although automatic triggering is also envisioned as discussed above .

In the program may begin analysis and replay using the high cost measurement data e.g. as described in . As shown in this particular screen shot the fragment shaders are currently being investigated.

Finally in after analysis the program may provide suggestions for improving graphics performance of the application executing on the target device. In this particular example the program suggests compressing textures to consume less texture memory and bandwidth. The program also suggests simplifying complex vertex shaders to consume fewer execution cycles. Further the program suggests culling out vertices that are outside the field of view to avoid wasted GPU effort. The program also provides a graph of potential increased performance after addressing these issues estimating an increase of 16 frames per second FPS for uncompressed textures 12.5 FPS for simplifying the vertex shader and 11.5 FPS for culling out of view verticies. The user may then select the report button to export a version of this data which may include further suggestions performance data more details etc.

Thus illustrate exemplary screen shots of a program that analyzes graphics performance of an application executing on a target device.

In further embodiments instead of testing for performance issues or bottlenecks for an application the command stream and playback may be used to test graphics frameworks or graphics drivers. More particularly they may be used to compare performance of a new version of the graphics framework or driver against an older version of the graphics framework or driver. For example a same command stream may be executed according to a first version of the graphics framework and or driver and then compared to execution according to a second version of the graphics framework and or driver. Modifications to the command stream may also be used to identify particular differences in performance of the graphics framework and or driver. Thus the both general pipeline or per operation performance differences in new versions or modified versions of the graphics framework and or driver may be identified using the methods described above.

Additionally while the above is discussed with respect to graphics pipelines or graphics operations it may be modified to apply to any type of pipeline or application execution. For example similar methods may be applied to any computation API or command based applications such as OpenCL or others.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

