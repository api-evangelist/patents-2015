---

title: Computer-implemented methods and systems for determining application matching status
abstract: Computer-implemented systems and methods are provided for determining application matching status. In one implementation, a method is implemented with one or more processors and includes accessing, at a server, a first dependency tree representing a first application and a second dependency tree, and acquiring one or more values for the first dependency tree and one or more values for the second dependency tree. The method also includes comparing the one or more values of the first dependency tree with the one or more values of the second dependency tree. The method further includes determining a matching status between the first application and an application represented by the second dependency tree based on the comparison, and providing, for display, an indication of the matching status.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600396&OS=09600396&RS=09600396
owner: Citrix Systems, Inc.
number: 09600396
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20150310
---
This application claims the benefit of U.S. Provisional Application No. 61 951 403 filed Mar. 11 2014 which is herein incorporated by reference in its entirety.

Today s rapidly changing technology requires application users to periodically migrate from one system to another such from as a system implemented using Windows 7 platform to a system implemented using Windows 8 platform or changes to runtime environment such as App V . For every migration users have to validate each application to ensure compatibility with the new system. This process might need to be repeated for every major and or minor new release of a given system. As users demand new and improved features the frequency of updating systems increases thereby also increasing the importance of the migration from one system or version to another.

Such migration is critical for enterprise users running thousands of applications for any given project on any given system. And each such application can be associated with many different algorithms. That is verification of applications and their associated algorithms for any given system can be very complex and time consuming. Traditionally such migration and verification is implemented manually costing the organization a significant number of man hours or months or years and cost.

While a number of current techniques can be used to perform an accurate analysis to detect compatibility and matching of an application across different systems the current techniques often involve manual testing of hundreds of applications using diagnostic tools such as process monitoring and debuggers to discover any defects. A disadvantage for such a process is the specialized knowledge required by a person in charge of the testing.

Another drawback with the current techniques is an inefficiency associated with application testing where each application of a set of identical applications that are residing across different systems is verified for compatibility for the new platform. A reduction in the amount of time it takes to verify compatibility of applications between platforms is useful for applications users especially when migrating between systems.

Yet another drawback with the current techniques is an inefficiency associated with verifying that each application of a set of identical applications that are residing across different systems is installed correctly. A reduction in the amount of time it takes to verify installation of applications between platforms is useful for applications users especially when migrating between systems.

Reference will now be made in detail to the exemplary embodiments consistent with the embodiments disclosed herein the examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

The present disclosure generally relates to application matching between applications residing in different systems. Exemplary embodiments relate to computer implemented methods and systems for machine learning to determine a matching status for applications residing in different systems. Disclosed embodiments provide multiple technological advantages including computerized application analyses to identify applications compatible with a new or updated platform. Moreover the disclosed embodiments significantly reduce bandwidth requirements for application testing by transmitting hashes of an application s dependency tree rather than a fuller description of the application binary and meta data. Thus the disclosed embodiments enhance the functionality of computer hardware and software by ensuring compatibility while identifying any incompatibilities without the need for extensive manual testing and intervention.

One or more client devices A F are devices that can acquire remote services from data center through various means. Client devices A F can communicate with data center either directly e.g. client device E or indirectly through a public network e.g. client devices A D or a private network e.g. client device F . When client device communicates through public network or private network a communication link can be established. For example a communication link can be established by public network thereby providing a client device e.g. client devices A D access to data center . A communication link can also be established by private network thereby providing a client device e.g. client device F access to data center . While client devices A F are portrayed as a computer e.g. client devices A E and F a laptop e.g. client device B a tablet e.g. client device C and a mobile smart phone e.g. client device D it is appreciated that client device could be any type of device e.g. wearable device that communicates packets to and from data center . For example client devices A F can be referred to as a computing device an electronic device a mobile device a communications device and the like.

Public network and private network can be any type of network such as a wide area network WAN a local area network LAN or a metropolitan area network MAN . As an example a WAN can be the Internet or the World Wide Web and a LAN can be a corporate Intranet. Public network and private network can be a wired network a wireless network or a combination of both.

Data center can be a central repository either physical or virtual for the storage management and dissemination of data and information pertaining to a particular public or private entity. Data center can be used to house computer systems and associated components such as one or physical servers virtual servers and storage systems. Data center can include among other things one or more servers e.g. server a desktop delivery controller a virtual desktop applications and a backend system . In this disclosure the term system refers to any system capable of hosting software applications. For example a data center can be a system that is hosting software applications e.g. applications . In some embodiments data center can include more than one system such that each of those systems can be different from one another. For example when company A merges or acquires company B each company having their own system that can be different from the other the combined company including company A and company B can have a single system or two different systems hosting software applications. A system hosting software applications can be referred to as a hosting system.

Server can be an entity represented by an IP address and can exist as a single entity or a member of a server farm. Server can be a physical server or a virtual server. In some embodiments server can include a hardware layer an operating system and a hypervisor creating or managing one or more virtual machines. Server can provide one or more services to an endpoint. These services can include providing one or more desktops operating on one or more systems and one or more applications to one or more endpoints e.g. client devices A F . For example the one or more applications can include Windows or SAP based applications and computing resources. In some embodiments server can provide application matching services. For example application matching between applications residing on one platform and applications residing on another e.g. Window 7 and Windows 8 can be performed at server . Moreover the matching services can include applications compatibility services and application migration services.

In some embodiments server can provide application matching services. For example application matching between applications residing in different systems e.g. system A of organization A and system B of organization B and or different software platforms or platforms e.g. Window 7 Windows 8 can be performed at server . Alternatively application matching can be performed so as to identify any application on disparate systems that matches with a golden reference an exemplar application . A platform can include for example a Windows based platform e.g. Windows 8 an Apple based platform Mac OS X or a mobile based platform such as Apple iOS . It will be understood in some embodiments that the term platform as used herein can also refer to a hardware platform. It will also be understood in some embodiments that a system can include one or more platforms. For example system A of organization A can include a plurality of platforms Window 7 Windows 8 .

Desktop delivery controller can be a device that enables delivery of services such as virtual desktops to client devices e.g. client devices A F . Desktop delivery controller can provide functionality required to manage maintain and optimize all virtual desktop communications. In some embodiments desktop delivery controller can control manage maintain or optimize the provisioning of applications . In some embodiments controlling managing maintaining or optimizing the provisioning of applications can be implemented for one or more systems. That is desktop delivery controller can enable delivery of application migration and matching services for one or more systems.

In some embodiments one or more virtual desktops can provide one or more applications . Virtual desktops can include hosted shared desktops allowing multiple users to access a single shared remote desktop services desktop virtual desktop infrastructure desktops allowing each user to have their own virtual machine streaming disk images a local virtual machine individual applications e.g. one or more applications or a combination thereof. In some embodiments applications can be associated with one or more systems. That is one or more virtual desktops can provide one or more applications that can be used to verify application matching and application migration corresponding to a system.

Backend system can be a single or multiple instances of computer networking hardware appliances or servers in a server farm or a bank of servers. Backend system can interface directly or indirectly with server . For example backend system can include Microsoft Active Directory which can provide a number of network services including lightweight directory access protocol LDAP directory services Kerberos based authentication domain name system DNS based naming and other network information and synchronization of directory updates amongst several servers. Backend system can also include among other things an Oracle backend server a SQL Server backend and or a dynamic host configuration protocol DHCP . Backend system can provide data services or a combination of both to data center which can then provide that information via varying forms to client devices or branch office not shown .

As shown in each computing device such as server or a client device interfacing with server includes a central processing unit CPU and a main memory . CPU can be any logic circuitry that responds to and processes instructions fetched from the main memory . CPU can be a single or multiple microprocessors field programmable gate arrays FPGAs or digital signal processors DSPs capable of executing particular sets of instructions stored in a memory e.g. main memory or cache e.g. cache . CPU can be for example one or more general purpose microprocessors becoming one or more special purpose microprocessors during the importing analyzing reporting and or displaying steps of application matching process as described herein or can be a reduced instruction set of one or more microprocessors.

The memory includes a tangible and or non transitory computer readable medium such as a flexible disk a hard disk a CD ROM compact disk read only memory MO magneto optical drive a DVD ROM digital versatile disk read only memory a DVD RAM digital versatile disk random access memory flash drive flash memory RAM one or more caches one or more registers or a semiconductor memory. Main memory can be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by CPU . Main memory can be any type of random access memory RAM or any other available memory chip capable of operating as described herein. In the exemplary embodiment shown in CPU communicates with main memory via a system bus . Computing device can also include a visual display device and an input output I O device e.g. a keyboard mouse or pointing device connected through I O controller both of which communicate via system bus . One of ordinary skill in the art would appreciate that CPU can also communicate with memory and other devices in manners other than through system bus such as through serial communication manners or point to point communication manners. Furthermore I O device can also provide storage and or an installation medium for the computing device .

As shown in computing device can support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats a USB device a hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. Computing device can further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to client agent . Optionally any of the installation devices could also be used as storage device .

Furthermore computing device can include a network interface to interface to a LAN WAN MAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. Network interface can comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing computing device to any type of network capable of communication and performing the operations described herein.

Each application can include a plurality of data points which can be referred to as the application s intrinsic data. In some embodiments the data points of the application s intrinsic data can be based on heuristics. For example each application can include over 68 000 data points. An example of these data points is illustrated in . As shown in these data points can include information associated with an application s static data and also runtime data . Application s static data can include information associated with install logic install conditions and or install actions. Such data can also include information associated with application s files registry settings and or configuration settings. It can further include information associated with API calls API imports and or API exports. Additionally static data can include information associated with relationships and or dependencies within an application e.g. dependency tree of . Runtime data of application s intrinsic data can include either runtime internal data regarding performance and resources or runtime external data regarding dependencies between network database etc. These data points can also include an operating system s static data . For example operating system s static data can include information associated with operating system s files registry settings and or configuration settings. It can also include information associated operating system s API calls API imports and or API exports. Additionally operating system s static data can also include information associated with relationships and or dependencies of an operating system. These data points can also include information associated with external context . For example external context can include information associated with users and or machines used by the users. External context can also include information associated with usage and or utilization of application matching system resources.

In some exemplary embodiments an application s intrinsic data can be organized as a dependency tree that represents a relationship between various executable files and API calls. An exemplary dependency tree e.g. dependency tree is shown in . Dependency tree can be created for any application that uses accessible linkage such as for example API imports and API exports that can be queried. For example accessible linkage can include import address table IAT and export address table EAT in a portable execution or any other executable file. A dependency tree can be created by traversing through files e.g. executable files like .exe files and or .dll files and or API calls e.g. calls associated with IAT and EAT included in the application. As shown in dependency tree can include an executable file e.g. File 1.exe at the top level hierarchy this could also be a library file like a DLL at the top level hierarchy. File 1.exe can include import functions e.g. Imports . Imports can include functions AFunc BFunc and GetDate . Functions AFunc and BFunc can depend on executable file File 2.dll . That is File 1.exe can directly depend on a second file File 2.dll . Similarly File 1.exe can also directly depend on another file Kernel32.dll through function GetDate . As shown in Kernel32.dll can include an export function e.g. Exports that comprises the function GetDate .

File 2.dll can include export functions e.g. Exports and import functions e.g. Imports . As shown in Exports can include functions AFunc BFunc and CFunc . Imports can include functions FEFunc and FFunc which can depend on another file File 3.dll . That is File 2.dll can directly depend on a third file File 3.dll and File 1.dll can indirectly through second file File 2.dll depend on the third file File 3.dll . also shows that File 3.dll can include export functions e.g. Exports that comprise functions FEFunc and FFunc . As shown in dependency tree can depict relationships and or linkages between various files and API calls included in an application. While dependency tree shows a dependency tree that includes only three levels of hierarchy e.g. File 1.exe depending on File 2.dll and further on File 3.dll it is understood that an application can include dependencies between files e.g. executables files and or API calls e.g. calls associated with import address table and export address table that can include any number of hierarchies.

Referring back to applications imported in importing step can comprise any kind of application including but not limited to desktop applications e.g. MSI applications non MSI applications or web based applications for example web applications . MSI applications can include for example Microsoft Installer or Windows Installer based applications. That is MSI applications can be applications that use a .msi file Microsoft Installer or Windows Installer in the process of installation. Non MSI applications can be applications that use an interface other than Microsoft Installer or Windows Installer interface for installation such as Microsoft App V or a custom developed setup.exe file. In some embodiments the imported applications can include any application or process that includes dependent linkages that for example depict relationships and or linkages between various files and API calls.

Importing step can be implemented differently between importing desktop applications and web applications. For example Windows desktop applications can be imported using the applications installation packages. These installation packages can include an .msi file or any other type of installation package used in the industry. In some embodiments such installation packages can be App V e.g. .sft or .appv packages. Web applications can be imported into the application matching system by using one of the two different exemplary approaches described below or a combination of those approaches. In some embodiments web applications can be imported by a directed web spider or web crawler to crawl over the run time HTML pages and capture them for import into the application matching system. In some embodiments importing can be accomplished by importing the web applications source files into a database of application matching system.

In some embodiments database can reside within a server e.g. server hosting the application matching system. In some embodiments database can reside on a server or on a distributed network of servers remote from a server hosting the application matching system. Applications imported in importing step of the application matching system can reside in database . Each such application can be associated with one or more matching algorithms not shown which can also reside in database . In some embodiments matching algorithms are created by a user of the application matching system whereas in other embodiments such algorithms can already be created and saved in a universal algorithm library residing in database .

Database can also include information associated with operating systems e.g. operating system intrinsic data running on computing device . For example operating systems running on computing device can include Windows 7 Windows Server 2003 Windows XP and Windows Server 2008 R2 . In some embodiments information associated with operating system e.g. operating system image or snapshot can be uploaded by a user of the application matching system whereas in other embodiments such information can be extracted by an application matching system itself. For example operating system intrinsic data can include information describing a certificate chain on an operating system image. Using the signing certificate authority on the certificate chain an algorithm can simply process the certificate chain until it identifies the certificate as either trusted or untrusted. It will be understood that the application matching system can also allow users to load multiple operating system images concurrently to enable the user to execute algorithms for matching with all such platforms in a single pass. Database can further include information associated with usage and or runtime data . Database can further include information associated with auditing performance users groups and or devices as depicted in .

In some embodiments a matching status of an application can be determined by computing and comparing a digital signature associated with the application that uniquely identifies the application. A digital signature associated with an application can be a specific pattern. For example an application s digital signature can be a hash value returned by a hash function. It is well understood that a hash function can be any algorithm that maps data of variable length to data of a fixed length e.g. MD5 and SHA 2 . It is well understood that even a one bit change in the input data can result in a significant change in the hash value of the input data. Said differently hash functions resulting in hash values are a good exemplary function that can uniquely identify a variable length of data including binary files. The values returned by a hash function can be called hash values hash codes hash sums checksums or simply hashes. In some embodiments where an application s digital signature is defined as a hash value returned by a hash function operated on an entire dependency tree of the application an application matching system can determine a matching status between two applications by comparing each application s hash value. If the comparison results in a match between the hash values of the two applications the application matching system can identify that the two applications are the same applications that may be residing on two different platforms or systems.

If on the other hand the comparison does not result in a match between the hash values of the two applications the application matching system can identify that the two applications do not match. In some embodiments when the comparison does not result in a match between a top level hash values of the dependency trees of the two applications e.g. File 1.exe a hash value can be computed on a second level hierarchy of the dependency tree e.g. File 2.dll for further comparison. If the comparison of hash values at the second level hierarchy of the dependency trees results in a match between the two applications the application matching system can identify that the two applications include the same files at the second level hierarchy e.g. File 2.dll that were used for computing the hash value. If however the comparison of the hash values at the second level hierarchy of the dependency tree does not match then the process can be repeated to the third level hierarchy of the dependency tree e.g. File 3.dll and so on. It will be understood that the hash values can be computed and later compared for any number of hierarchies of an application s dependency tree. It will be understood that an application s digital signature value can be defined in many ways other than and different from the exemplary hash function described above.

Imported applications can be associated with matching algorithms that can be used in the analysis process. In some embodiments each imported application can be associated with one or more matching algorithms. Matching algorithms can be implemented as heuristic algorithms . In some embodiments matching algorithms can relate to information associated with the one or more systems and or platforms including internal states dependencies relationship between one application to another relationship between an application and an operating system or external data. Matching algorithms can also relate to operating system image dependent algorithms including dependencies on features that are provided by an operating system. When relevant these algorithms can interrogate the operating system image data that has been loaded into the database e.g. database of the application matching system. These algorithms can check a variety of operating system image information including APIs registry information file management system for each fixed drive partition the certificate store or some matching settings.

The application matching system can generate reports e.g. report step as an output of analysis step . For example such reports can contain information about a matching status for two or more applications that have been analyzed by the application matching system to determine whether the two or more applications match. In some embodiments reports can include a plurality of icons to indicate a matching status for two or more applications. For example icons represented by red R amber A and green G colors or indications can signify different matching statuses for applications illustrated in . An icon G can indicate that a matching status between two or more applications is at least above a predetermined percentage. An icon R can indicate that a matching status between two or more applications is below a predetermined percentage. An icon A can indicate either that a matching status between two or more applications is unknown or that a matching determination is unsuccessful. It will be understood the above listed definitions of icons are merely exemplary and other definitions are possible. An exemplary method describing a process of determining a matching status between two or more applications is described in below.

Server can host a database e.g. database where a plurality of applications can reside. In some embodiments each of the plurality of applications residing at server can be organized into a dependency tree e.g. dependency tree associated with each of the plurality of the applications. Dependency tree can be created for any application that uses accessible linkage that can be queried such as for example API imports and API exports . For example accessible linkage can include IAT and EAT in a portable execution or a new executable file. It is understood that an application can include dependencies between files e.g. executables files and or API calls e.g. import address table and export address table that can include any number of hierarchies e.g. three levels of hierarchy shown in dependency tree .

It will be understood that a number of hash values that can be computed for each dependency tree can be based on a total number of files e.g. executable files included in the dependency tree. For example if a dependency tree includes 4 files as in dependency tree File 1.exe File 2.dll File 3.dll and Kernel32.dll 4 different hash values can be computed for dependency tree . That is a hash value can be computed for each of the files that are included in the dependency tree. Accordingly in some embodiments a plurality of hash values can be computed for each dependency tree and therefore for each application. In some embodiments a hash value for a particular file can include all files that it may further depend on. For example a hash value for File 2.dll can also include File 3.dll . Alternatively a hash value for a particular file can only include the particular file and might not include any file that it may further depend on. For example a hash value for File 2.dll need not include File 3.dll .

In some embodiments a hash value can be computed for all hash values that have been computed for all files included in dependency tree e.g. 4 files listed above . In some embodiments this hash value can be the application s fingerprint that uniquely identifies the application. An advantage of using a fingerprint hash value can be that when a fingerprint hash value of two applications match there is no need to compare hash values for each file at a lower level of hierarchy of an application.

Application matching system can perform a comparison between the one or more values of the first dependency tree and the one or more values of the second dependency tree. In some embodiments the comparison can include bit by bit comparison of the values. For example an MD5 hash function results in a 128 bit hash value whereas an SHA 2 hash function can result in a hash value ranging from 224 bits to 512 bits. In embodiments using MD5 hash function the comparison step can include comparing each bit of the 128 bit hash value between the one or more hash values of the first dependency tree and the one or more hash values of the second dependency tree. The bit by bit comparison can result in either a match or no match between any pair of hash values. Application matching system can perform a determination of a matching status between the first application and the second application based on the comparison of the hash values. If the bit by bit comparison for example results in a match between the one or more hash values of the first dependency tree and the one or more hash values of the second dependency tree a matching status signifying a perfect match the hash values are identical between the first dependency tree and the second dependency tree between the first application and the second application can be reported. If on the other hand the bit by bit comparison results in a no match e.g. difference of at least one bit between the first hash value and the second hash value a matching status signifying no match between the first application and the second application can be reported. Application matching system can report a matching status in a report e.g. Report depicted at of .

In step an application matching system e.g. application matching system can access a first dependency tree representing a first application e.g. first application and a second dependency tree representing a second application e.g. second application . In step the application matching system can acquire one or more values for the first dependency tree and one or more values for the second dependency tree wherein the acquired values have been previously computed and stored in a database e.g. database . That is the one or more values can either be computed within the application matching system or external to the application matching system. In some embodiments the application matching system can perform a computation of one or more hash values for the first dependency tree and one or more hash values for the second dependency tree. In some embodiments as described in one or more hash values for a particular dependency tree can represent the entire dependency tree of the particular dependency tree or one or more portions of the particular dependency tree i.e. each portion can be associated with each file and or API call of the particular dependency tree .

In step the application matching system can perform a comparison of the computed first hash value or a first set of hash values and the computed second hash value or a second set of hash values . In some embodiments the comparison can include bit by bit comparison of the values. The bit by bit comparison can result in either a match or no match between any pair of hash values.

In step the application matching system can determine a matching status between the first application and the second application based on the comparison of the hash values. If the bit by bit comparison for example results in a match between the one or more hash values of the first dependency tree and the one or more hash values of the second dependency tree a matching status signifying a perfect match the hash values are identical between the first dependency tree and the second dependency tree between the first application and the second application can be reported. If on the other hand the bit by bit comparison results in a no match e.g. difference of at least one bit between the first hash value and the second hash value a matching status signifying no match between the first application and the second application can be reported.

In step the application matching system can provide for display a report e.g. report as depicted in indicating the matching status between the first application and the second application.

The flowchart of can further be described with an exemplary scenario where a matching status between two applications needs to be determined. In this exemplary scenario the application matching system determines a matching status between a first application Microsoft Word 2007 and a second application unknown application. A dependency tree exists for each of the first and second applications. In this example the first dependency tree representing Microsoft Word 2007 application includes a top level file name File 1.exe whereas the second dependency tree representing an unknown application includes a top level file name SomeOtherName.exe. After the application matching system accesses the first and second applications step in step the application matching system can compute a first hash value for File 1.exe and a second hash value for SomeOtherName.exe. In step the application matching system can compare the first hash value with the second hash value bit by bit. If the application matching system determines that the first hash value matches with the second hash value the application matching system can generate a report showing that there is a perfect match between Microsoft Word 2007 and the unknown application. Given the perfect match of hash values even though the second application is unknown it may be safe to identify the unknown application is also a Microsoft Word 2007 application. In some embodiments the second application can reside in a system that is different from a system where the first application resides.

Continuing with the above exemplary scenario if the application matching system determines that there is no match between the first hash value and the second hash value where the hash values are computed for the top level files of the respective applications File 1.exe and SomeOtherName.exe steps through can be repeated by traversing down the hierarchy level of dependency trees of the applications. For example a hash value can be computed for files at a second level hierarchy of the dependency tree e.g. File 2.dll of dependency tree for further comparison. If the comparison of hash values at the second level hierarchy of the dependency trees results in a match between the two applications the application matching system can identify that the two applications include the same files at the second level hierarchy e.g. File 2.dll of dependency tree and below that were used for computing the hash value. That is while the second application might not be identical to Microsoft Word 2007 a second level hierarchy match of hash values indicates that the second application shares some common files as that of Microsoft Word 2007 application. If however the comparison of the hash values at the second level hierarchy of the dependency tree does not match then the process can be repeated to the third level hierarchy of the dependency tree e.g. File 3.dll of dependency tree . It will be understood that the hash values can be computed step and later compared step for any number of hierarchies of an application s dependency tree.

In some embodiments a match between two applications can be defined when a comparison between the hash values is above a predetermined threshold. For example the predetermined threshold can be any number equal to or less than one hundred percent. If the predetermined threshold is equal to one hundred percent such a match can be referred to as a perfect match. Alternatively if the predetermined threshold is less than one hundred percent such a match can be referred to as a partial match. A partial match scenario can be applicable in cases where a hash value is computed for each file of the dependency tree and matching between two applications is determined based on whether a percentage of the number of hash values that are same between the two applications is at least equal to the predetermined threshold. For example if each of Microsoft Word 2007 and the unknown application have 4 files similar to dependency tree included in their respective dependency trees and let us also assume that a predetermined threshold is set as seventy percent. If a comparison of hash values for each of the four files of the two applications results in a match of three of the four files i.e. seventy five percent the application matching system will determine that portions of the unknown application matches portions of the Microsoft Word 2007 application.

In practice while a predetermined threshold of less than one hundred percent signifies that the two applications are not identical a predetermined threshold of seventy five percent for example signifies that the two applications share many of the common files and can be closely related. For example if three of the four files match between Microsoft Word 2007 and the unknown application it can signify that the unknown application can be a Microsoft Word application that is different from 2007 version of the application e.g. Microsoft Word 2010 . Another example can signify a situation where the unknown application can still be a Microsoft Word 2007 but one of the files was not properly installed. Accordingly a predetermined threshold of less than one hundred percent can result in useful insights in identifying closely related applications which can help in making application migration from one system to another more efficient. In some embodiments a match between applications can be based on hash values of both files as well as API calls. Alternatively a match between applications can be defined such that it is based on hash values of either files or API calls but not both.

In some embodiments the application matching system can determine a matching status between two or more applications based on an exemplar application as a reference. For example when an organization is migrating its applications from one platform to another applications residing in different systems of the organization need to be verified for compatibility with the new to be migrated platform as described in U.S. patent application Ser. No. 14 094 697 titled Methods and Systems for machine learning to discover application compatibility filed on Dec. 2 2013 the entirety of which is incorporated herein expressly. The application matching process described in and depicted in can be utilized to make the application migration process more efficient. In some embodiments the application matching system can receive an exemplar application e.g. Microsoft Word 2007 whose dependency tree and associated hash value or a set of hash values can be first computed. The application matching system can operate on applications involved in the migration process such that the application matching system can identify all applications that match the exemplar application by computing step and comparing step hash values associated with each of the applications involved in the migration process.

After the application matching system determines step a matching status for each application as compared with the exemplar application such that it identifies all applications that match the exemplar application. In such a scenario an application compatibility system checking for compatibility of applications with a particular platform could only check the exemplar application for compatibility with the new platform. That is after the application compatibility system verifies that the exemplar application is compatible with the new platform the application compatibility system can automatically mark that all applications matching the exemplar application are also compatible with the new platform without having to check a compatibility status for any of those applications that match the exemplar application. As will be appreciated the above described scenario improves an efficiency of application compatibility with platform by reducing a processing iterations and time by utilizing the application matching process of .

In some embodiments the above described process of improving efficiency of an application compatibility system can also be extended to verify whether applications are correctly installed on various platforms. In some embodiments determining a matching status between applications can be performed over a low bandwidth network connection. In such embodiments the hash value can be a small string of data e.g. 32 bit hash value that can uniquely represent an application and by transmitting only hash values that are relatively short in size a matching determination can be performed over a low bandwidth network connection. That is application matching system can perform application matching either on one electronic device e.g. server or distributed over a network either a high bandwidth network or a low bandwidth network.

The methods disclosed herein may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a standalone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

A portion or all of the methods disclosed herein may also be implemented by an application specific integrated circuit ASIC a field programmable gate array FPGA a complex programmable logic device CPLD a printed circuit board PCB a digital signal processor DSP a combination of programmable logic components and programmable interconnects a single central processing unit CPU chip a CPU chip combined on a motherboard a general purpose computer or any other combination of devices or modules capable of performing media format substitution disclosed herein.

In the preceding specification the systems and methods have been described with reference to specific exemplary embodiments. It will however be evident that various modifications and changes may be made without departing from the broader spirit and scope of the disclosed embodiments as set forth in the claims that follow. The specification and drawings are accordingly to be regarded as illustrative rather than restrictive. Other embodiments may be apparent to those skilled in the art from consideration of the specification and practice of the embodiments disclosed herein.

