---

title: Buffer display techniques
abstract: Buffer display techniques are described. In one or more implementations, at least part of an off-screen buffer is rasterized by an application to generate an item for display by the computing device. One or more communications are formed that describe the part of the off-screen buffer which contains the item that is to be copied to update an onscreen buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424814&OS=09424814&RS=09424814
owner: Microsoft Technology Licensing, LLC
number: 09424814
owner_city: Redmond
owner_country: US
publication_date: 20150721
---
This application claims benefit of priority of U.S. patent application Ser. No. 14 515 444 entitled Buffer Display Techniques filed Oct. 15 2014 that claims priority of U.S. patent application Ser. No. 13 229 474 entitled Buffer Display Techniques filed Sep. 9 2011 the content of both of which is incorporated by reference herein in its entirety.

The variety of computing device configurations continues to increase. From traditional desktop personal computers to mobile phones game consoles set top boxes tablet computers and so on the functionality available from each of these configurations may vary greatly. Consequently traditional display techniques that were developed for one configuration may not be as well suited for another configuration. For example display techniques that were previously utilized for devices having significant memory resources may be ill suited for devices having fewer resources.

Buffer display techniques are described. In one or more implementations at least part of an off screen buffer is rasterized by an application to generate an item for display by the computing device. One or more communications are formed that describe the part of the off screen buffer which contains the item that is to be copied to update an onscreen buffer.

In one or more implementations one or more communications are received that describe a part of an off screen buffer maintained in memory of a computing device which contains an item rasterized in the off screen buffer by an application that is executed by the computing device. The part of the off screen buffer described in the one or more communications is copied to an onscreen buffer. The onscreen buffer is caused to be used to display data contained therein on a display device of the computing device.

In one or more implementations a computing device includes a display device memory configured to maintain off screen and onscreen buffers containing bitmaps for display by the display device the off screen buffer having a size that is less than a size of the onscreen buffer and one or more modules implemented at least partially in hardware. The one or more modules are configured to update the onscreen buffer using at least a portion of the off screen buffer to cause display of the portion of the off screen buffer with at least a portion of the onscreen buffer simultaneously on the display device.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Display techniques are described herein which leverage buffers. In one or more implementations a buffer display technique is utilized that is based on an object called a swap chain which is an array of buffers representing a bitmap generally having a matching size. One of the buffers is used to present data on a display device at any one time and therefore may be called the onscreen buffer or front buffer. The other buffers are made available to an application for rasterization off screen and therefore are referred to as an off screen buffer or back buffer. 

An application may make a change to what is displayed on the screen in a variety of ways. In a first such technique the application can redraw one of the back buffers and flip the contents such as by making one of the off screen buffers the onscreen buffer using a pointer and vice versa. The additional buffers however cost additional video memory. In the case where the contents on screen change infrequently that extra memory may be wasted.

Accordingly in a second such technique buffers of different sizes may also be leveraged. For example the buffer display techniques may leverage a first buffer as an onscreen buffer. The buffer display techniques may also leverage a second buffer that is smaller than the first buffer as an off screen buffer. Therefore when an update is to be made to the content the update may be rasterized to the second buffer. The update may then be copied to the onscreen buffer. In this way resources of a computing device may be conserved.

In the following discussion an example environment is first described that is operable to perform the buffer display techniques described herein. Examples procedures are then described which are operable in the example environment as well as in other environments. Likewise the example environment is not limited to performance of the example procedures.

The computing device also includes an operating system that is illustrated as being executed on the processing system and is storable in memory . The computing device further includes applications that are illustrated as being stored in the memory and are also executable on the processing system . The operating system is representative of functionality of the computing device that may abstract underlying hardware and software resources for use by the applications . For example the operating system may abstract functionality of how data is displayed on the display device without the applications having to know how this display is achieved. A variety of other examples are also contemplated such as to abstract the processing system and memory resources of the computing device network resources and so on.

The computing device is also illustrated as including a display manager module . Although illustrated as part of the operating system the display manager module may be implemented in a variety of ways such as a stand alone module as a separate application as part of hardware of the computing device and so on.

The display manager module is representative of techniques that may be used to display data from applications on the display device . For example the display manager module may leverage a pool of buffers two examples of which are illustrated as buffer and buffer but it should be readily apparent that a larger number of buffers are also contemplated.

The display manager module may support a variety of different techniques that leverage the buffers for use in display of data on the display device . On such technique may expose the buffer for rasterization by the applications to generate an initial view of the display device e.g. via one or more application programming interfaces APIs . For example the application may specify a desired size of the buffer and generate a bitmap for display. A pointer may then be provided by the application to the display manager module to indicate that the bitmap in the buffer is ready for display. Thus this buffer may be set for use by the display manager module as the onscreen buffer.

Another such technique may be supported to allow the application to provide updates to what is being displayed from the onscreen buffer. For example the application may also specify another buffer as an off screen buffer. The application may then write updates to this buffer e.g. rasterize data at a bitmap for display.

When ready the application may then communicate with the display manager module to provide a location where the update is available a size of the update a source that is to receive the update and a location in the source at which the update is to be copied. The update may then be copied from buffer i.e. the off screen buffer to the buffer i.e. the onscreen buffer to cause display of the update. Thus the buffer configured as the off screen buffer may be made smaller e.g. consume less memory resources than the buffer configured as the onscreen buffer provide increased update efficiency by decreasing an amount of data that is drawn to the buffer and so on further discussion of which may be found in relation to the following figures.

Generally any of the functions described herein can be implemented using software firmware hardware e.g. fixed logic circuitry or a combination of these implementations. The terms module functionality and logic as used herein generally represent software firmware hardware or a combination thereof. In the case of a software implementation the module functionality or logic represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices. The features of the buffer display techniques described below are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

For example the computing device may also include an entity e.g. software that causes hardware of the computing device to perform operations e.g. processors functional blocks and so on. For example the computing device may include a computer readable medium that may be configured to maintain instructions that cause the computing device and more particularly hardware of the computing device to perform operations. Thus the instructions function to configure the hardware to perform the operations and in this way result in transformation of the hardware to perform functions. The instructions may be provided by the computer readable medium to the computing device through a variety of different configurations.

One such configuration of a computer readable medium is signal bearing medium and thus is configured to transmit the instructions e.g. as a carrier wave to the hardware of the computing device such as via a network. The computer readable medium may also be configured as a computer readable storage medium and thus is not a signal bearing medium. Examples of a computer readable storage medium include a random access memory RAM read only memory ROM an optical disc flash memory hard disk memory and other memory devices that may use magnetic optical and other techniques to store instructions and other data.

In the following discussion a visual may refer to a basic composition element. For example a visual may contain a bitmap and associated compositional metadata for processing by the display manager module . An atlas may refer to an aggregate layer which may include a plurality of layers to be rendered although a single layer is also contemplated.

A swap chain refers to a series of buffers that may flip to the screen on after another such as by changing pointers. Accordingly a flip mode is a mode by which a swap chain technique is used to make an off screen buffer an onscreen buffer e.g. through the use of swapping points between the off screen and onscreen buffers. However a blit mode refers to a technique in which a runtime of the display manager module issues a blit e.g. bit block image transfer from an off screen buffer to an onscreen buffer . An example implementation using these terms is now discussed.

An example of use of a flip chain technique may be found in relation to the example system of . The system includes logical off screen and onscreen buffers . Use of the off screen buffer and onscreen buffer is further illustrated through use of first and second stages which may refer to different points in time.

At the first stage an application has rasterized a bitmap to an off screen buffer . The off screen buffer may thus function as a generic surface for which content can be drawn and read from. The definition of whether a buffer is an off screen or onscreen buffer may be based on ownership of the buffer e.g. which entity has access to the buffer. When the application has write access to a buffer the buffer is defined as an off screen buffer. When the display manager module has access the module owns the buffer for display of the bitmap from the buffer and thus may be referred to as the onscreen buffer . The display manager module for instance may expose an API that allows the application to hand an off screen buffer to the display manager module to use as an onscreen buffer as shown in the second stage .

Thus upon initialization an application may render directly to the onscreen buffer without rendering to the off screen buffer first to reduce the initial first frame cost. This may be done by rendering to the off screen buffer and then passing control of the buffer to the display manager module thereby making this buffer the onscreen buffer. Subsequent updates may then be made through the off screen buffer as further described in relation to the following figure.

At the first stage of an application creates a visual e.g. a visual tree in the off screen buffer . The application also associates the visual with a bitmap in the onscreen buffer e.g. a location at which the visual is to be rendered.

At the second stage the application may then hand the update to the display manager module for rendering. For example the application may communicate an identification of the off screen buffer a size and or location of the update in the off screen buffer an identification of the onscreen buffer and a location in the onscreen buffer at which the update is to be rendered. The display manager module may then update the onscreen buffer by copying the update to the onscreen buffer e.g. using a blit operation.

Thus the techniques described herein may reduce surface creation time and video memory cost associated with creating a swap chain for each visual. As described above the display manager module may enable the application to create an off screen buffer e.g. a back atlas which may refer to an off screen buffer that is an atlas which may be used to contain multiple visuals into one surface. The application may then leverage this off screen buffer to create updates formed as bitmaps without creating a swap chain for each new visual. When the content is ready to be composed the content of the off screen buffer may be copied to the onscreen buffer for consumption by the display manager module using a blit operation. After the copying is complete e.g. the blit operation is finished the application may continue to use the off screen buffer for further updates.

An example of this is illustrated in the example system of that includes a plurality of off screen buffers and a plurality of onscreen buffers . In this example a visual of a tree in the off screen buffer is leverage for both onscreen buffers . A visual of a car in the off screen buffer is utilized for onscreen buffer and a visual of a dog in the off screen buffer is utilized to update the onscreen buffer . In the way an application may cause a visual to be copied by the digital display module to whichever destination it chooses.

The application also has the freedom to decide how large of a surface area is to be allocated for each of the buffers. This technique affords the applications the agility to design a configuration that optimizes a scenario s performance characteristics.

In terms of video memory consumption depending on the efficiency of the packing algorithm and how the off screen and onscreen buffers are set up an application can consume less than 2 the area of the visuals as was previously involved using a swap chain alone. Moreover an application can avoid the padding cost some drivers apply when dealing with small textures to reach the minimum supported size.

In one or more implementations the display manager module owns execution of the blit operation. Further the application may be blocked from access to the off screen buffer during performance of the operation. This way the display manager module may synchronize updates to the onscreen buffer e.g. with when it wakes up on video blanking intervals. This may be utilized to avoid tearing that may take place due to an application updating the content of the off screen buffer before the display manager module has had the chance to draw the previously committed changes. It should be readily apparent though that other implementations are also contemplated in which ownership of the operation is given to another entity of the computing device .

As described above the display manager module may expose functionality to allow an application to create a pool of buffers e.g. texture buffers of different sizes. Further the display manager module may permit the application to associate one or more buffers with one or more visual to be rendered thereby allowing the display manager module to determine where and how to present data from the buffers on the display device .

The application may also associate portions e.g. sub rectangles of a buffer with one or more visuals. This allows the application to use a single buffer to logically contain several images. This kind of image organization may be referred to as an atlas. In one or more implementations the buffers in the pool which are associated with visuals are not directly accessible by the application but rather indirectly via a method of the display manager module that instructs the module to copy a set of rectangles from a set of off screen buffers to a set of on screen buffers. The buffers which are not associated with visuals are accessible to the application for rasterization.

Therefore when the application wants to update one or more on screen buffers the application produces a rasterization for each of the regions to be updated. The application may then build a mapping of updated regions to updated sections of the onscreen buffers.

The following is a sample usage pattern of a call by an application to one or more APIs of the display manager module . First the application may render one or more visuals to an off screen buffer e.g. a back atlas. Once the drawing is completed the application may call one or more APIs of the display manager module . The display manager module may wake up e.g. at a video blanking interval and assume temporary ownership of the off screen buffer thereby preventing the application from making further updates to the buffer.

The display manager module may then use pixel data from the API call i.e. description of a source and a location of a destination in the onscreen buffer to blit one or more visuals to the onscreen buffer e.g. a front atlas buffer. Once the blit operation completes the application regains write access to the off screen buffer at which point further updates can begin. Thus the swap chain techniques may be utilized in a variety of ways such as for video a progress seek bar and so on. The blit mode techniques may be used for video titles controls and so on. Thus the application may choose which of these techniques to use thereby promoting efficient use of the computing device .

The following discussion describes buffer display techniques that may be implemented utilizing the previously described systems and devices. Aspects of each of the procedures may be implemented in hardware firmware or software or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion reference will be made to the environment of and the systems of .

One or more communications are formed that describe the part of the off screen buffer which contains the item that is to be copied to update an onscreen buffer block . The communications for example may be configured as one or more API calls to the display manager module . The communications may identify the off screen buffer describe a size of the item a location of the item in the off screen buffer a destination buffer that is to receive the item and an offset at which the item is to be copied to the buffer.

The one or more communications are received by the display manager module of the computing device block . Ownership of the off screen buffer is assumed by the display manager module block such as to block access by the application to the buffer. The item is copied to an onscreen buffer by the display manager module block such as by using a blit operation. Upon completion the ownership of the off screen buffer is passed back to the application block .

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link. In one embodiment this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on.

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on. The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples the techniques described herein which is illustrated through inclusion of the display management module .

The cloud includes and or is representative of a platform for content services . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The content services may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Content services can be provided as a service over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the content services that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality of the functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

Device also includes communication interfaces that can be implemented as any one or more of a serial and or parallel interface a wireless interface any type of network interface a modem and as any other type of communication interface. The communication interfaces provide a connection and or communication links between device and a communication network by which other electronic computing and communication devices communicate data with device .

Device includes one or more processors e.g. any of microprocessors controllers and the like which process various computer executable instructions to control the operation of device and to implement embodiments of the techniques described herein. Alternatively or in addition device can be implemented with any one or combination of hardware firmware or fixed logic circuitry that is implemented in connection with processing and control circuits which are generally identified at . Although not shown device can include a system bus or data transfer system that couples the various components within the device. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures.

Device also includes computer readable media such as one or more memory components examples of which include random access memory RAM non volatile memory e.g. any one or more of a read only memory ROM flash memory EPROM EEPROM etc. and a disk storage device. A disk storage device may be implemented as any type of magnetic or optical storage device such as a hard disk drive a recordable and or rewriteable compact disc CD any type of a digital versatile disc DVD and the like. Device can also include a mass storage media device .

Computer readable media provides data storage mechanisms to store the device data as well as various device applications and any other types of information and or data related to operational aspects of device . For example an operating system can be maintained as a computer application with the computer readable media and executed on processors . The device applications can include a device manager e.g. a control application software application signal processing and control module code that is native to a particular device a hardware abstraction layer for a particular device etc. . The device applications also include any system components or modules to implement embodiments of the techniques described herein. In this example the device applications include an interface application and an input output module that are shown as software modules and or computer applications. The input output module is representative of software that is used to provide an interface with a device configured to capture inputs such as a touchscreen track pad camera microphone and so on. Alternatively or in addition the interface application and the input output module can be implemented as hardware software firmware or any combination thereof. Additionally the input output module may be configured to support multiple input devices such as separate devices to capture visual and audio inputs respectively.

Device also includes an audio and or video input output system that provides audio data to an audio system and or provides video data to a display system . The audio system and or the display system can include any devices that process display and or otherwise render audio video and image data. Video signals and audio signals can be communicated from device to an audio device and or to a display device via an RF radio frequency link S video link composite video link component video link DVI digital video interface analog audio connection or other similar communication link. In an embodiment the audio system and or the display system are implemented as external components to device . Alternatively the audio system and or the display system are implemented as integrated components of example device .

Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as example forms of implementing the claimed invention.

