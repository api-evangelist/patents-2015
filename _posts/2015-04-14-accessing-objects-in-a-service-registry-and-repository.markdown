---

title: Accessing objects in a service registry and repository
abstract: This invention relates to query management. A query management method includes receiving a database query, generating an abstract syntax tree representation of the database path query into a set of java objects, and processing the abstract syntax tree representation of the database path query. The method further includes determining a selector upon processing the abstract syntax tree representation of the database path query and deriving a SELECT clause from the selector clause, where the SELECT clause indicates a portion of an expression from an XMeta Query Language (XMQL) query. The method yet further includes appending a FROM clause to the expression for the XMQL query, appending a WHERE clause to the expression for the XMQL query, and executing the expression for the XMQL query including the appended FROM clause and also the appended WHERE clause to access objects in an object repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09384301&OS=09384301&RS=09384301
owner: International Business Machines Corporation
number: 09384301
owner_city: Armonk
owner_country: US
publication_date: 20150414
---
This application is a Continuation of U.S. application Ser. No. 11 843 713 filed Aug. 23 2007 now allowed which is incorporated herein by reference in its entirety. This application further contains subject matter related to the subject matter disclosed in U.S. application Ser. No. 11 843 968 filed on Aug. 23 2007 now U.S. Pat. No. 7 725 482 and U.S. application Ser. No. 11 859 938 filed on Sep. 24 2007 now U.S. Pat. No. 7 783 656.

This invention relates to a service registry and repository system and method. In particular this invention relates to a service registry and repository system and method for accessing objects in an object repository.

A service registry and repository registers and stores service descriptions as part of a service oriented architecture SOA promising business agility and resilience through reuse loose coupling flexibility interoperability integration and governance. These promises are addressed by separating service descriptions from their implementations and using the service descriptions across the life cycle of the service. Standards based service metadata artefacts such as Web Service Definition Language WSDL XML schema policy or Service Component Architecture SCA documents capture the technical details of what a service can do how it can be invoked or what it expects other services to do. Semantic annotations and other metadata can be associated with these artefacts to offer insight to potential users of the service on how and when it can be used and what purposes it serves.

Service descriptions are used by analysts architects and developers during a Development Phase of the SOA life cycle to locate services to reuse and to evaluate the impact of changes to service configurations. Service descriptions are used by deployers in a Change and Release Phase and by administrators in a Runtime Integration Phase. It is used in the Operation Phase of the life cycle to support policy enforcement required by Service Level Agreements SLAs and to present a more comprehensive view of the managed service environment. Service descriptions are used by various technologies for different purposes and needs to be persisted in a reliable and accessible format. Service descriptions are variously described as metadata objects documents entities and artefacts.

A service registry and repository is an application that persists service descriptions as a data objects in a relational database system. Typically a user uses a graphical tool to design classes that represent the service descriptions that need to be persisted. Java objects that represent the classes are compiled into binary files. Database schema are generated that can represent the objects and are installed into a relational database IBM DB2 Oracle etc . The objects are registered with service register and stored within the repository. The objects are persisted and retrieved directly from the object database. IBM and DB2 are registered trademarks or trademarks of International Business Machines Corporation in the United States and or other countries. Oracle is a registered trademark of Oracle Corporation.

One type of service registry and repository stores the descriptions as objects within the repository and queries the repository using an object query language. An example of this type of service registry is IBM WebSphere Registry and Repository WSRR uses an IBM object query language called XMeta Query Language XMQL for internal communication with the repository. WebSphere is a registered trademark or trademark of International Business Machines Corporation in the United States and or other countries.

XMeta Query Language XMQL is a declarative object query language designed for the efficient retrieval of objects stored in a repository such as WSRR. XMQL allows the use of the dot operator for accessing predefined properties on a given modelled object type. XMQL also allows a dereferencing operator for traversing relationships between any two given object types. The XMQL query expression is defined in the context of a given package registered with WSRR. XMQL has a SELECT FROM WHERE type of structure and returns a set of objects.

The SELECT FROM WHERE clause is the basic structure of an XMQL query. It allows the user to specify which class es should be searched to retrieve information and which parts of the information to be included in the results set. It also allows the user to specify conditions to filter out of the results set the instances that do not meet the conditions.

The SELECT clause defines the structure of the query result which can be either a collection of objects or a collection of rows with the selected attribute values. The entries in the select part of a query constitute the so called projection list of the query in that they define what is projected out of the repository and into the result set entries result objects or result rows of atomic values depending on the number and type of the entries in the projection list . When retrieved the type of the query result is a List of instances of objects or a List of arrays result rows of instances of objects result row columns .

The FROM clause introduces the primary class extent against which the query runs. A class extent is the set of all instances of a given class including instances of its sub classes . A variable needs to be declared to iterate over the instances of the class being queried the so called primary iteration variable. That variable can be used in the other parts of the query and denotes an instance of the class extent being iterated upon. The FROM clause also allows the introduction of other variables to iterate over instances that can be reached through navigation via multiplicity many references from previously introduced iteration variables. These extra variables are called secondary iteration variables. As explained above unqualified class names in a query expression are resolved relative to that package the so called query context package.

The WHERE clause introduces a predicate that filters the instances of the class being queried. This is an optional sub clause.

SELECT e FROM e in Employee WHERE e.salary 200000. This query returns the instance s of class Employee including any of its sub classes whose salary attribute value is greater than 200000. The FROM clause gives the class whose extent the query will filter class Employee and introduces the variable e to be used to iterate over that class extent. The extent of class Employee includes all instances of all of its direct and indirect sub classes. The SELECT clause defines the type of the entities returned in the result collection to be instances of class Employee or any of its sub classes. In this example the class being queried is an abstract class and the result collection will contain instances of sub classes FullTimeEmployee and PartTimeEmployee. The WHERE clause filters the instances being iterated upon so that only those for which the value of attribute salary is greater than 200000 are returned in the result.

SELECT e FROM e in Employee. This example retrieves all the instances of class Employee. It also illustrates the fact that the WHERE clause is optional.

SELECT e FROM e in AnotherPackage Employee. In this example the package in the query expression takes precedence over the context package in case a class with the same name is defined in both. If the class defined in the query context package or if it is defined in a package it depends on and there is no name conflict i.e. different classes with the same name defined in different packages depended upon then there is no need to qualify the class name in the query expression.

Patent publication U.S. Pat. No. 7 028 028 Enosys Markets Inc. discloses a system for querying markup language data stored in a relational database according to markup language schema. The system translates from the input XML query language to apply corresponding query instructions to the underlying relational database using a relational database query language such as SQL.

Although a relational database query language is a useful way to access objects in a repository it does not return complex collection of objects as an object query language can. As such an object query language is a powerful way to access objects in a repository. Furthermore object query languages provide additional features such as object references and dot notation where SQL does not. However one problem for users accessing objects in the repository is that a specialized object query language can be counter intuitive if one is used to a different query language such as a path expression query language. For instance XPath is a path expression language that is more suitable for accessing content within an XML instance document than for accessing objects in an object database but many users are familiar with it and prefer to use it to locate objects.

Users will issue queries against WSRR that are expressed using XPath notation such as WSRR WSDLDocument . WSRR must translate this into an appropriate XMQL query in order that the user s query can be executed so that XPath WSRR WSDLDocument becomes XMQL SELECT a FROM a in Physical WSDLMetadataltem .

An XPath query is a statement such as WSRR WSDLDocument WSRR WSDLService name stockQuote or WSRR WSDLService ports name aPort . A step is an an expression between two forward slash delimiters WSDLDocument is step 2 in the first example above. A Predicate is a filter within square brackets in a step so the in WSRR WSDLDocument name myDoc the expression name myDoc is the predicate.

The following examples show equivalent XPath and XMQL query statements after conversion using the method and system of the invention.

Return all WSDLDocument objects XPath WSRR WSDLDocument XMQL SELECT a FROM a in Physical WSDLMetadataItem .

Return all WSDLService objects called myService XPath WSRR WSDLService name myService XMQL SELECT a FROM a in Logical WSDLService WHERE a.name myService .

return all WSDLPort objects contained inside WSDLService objects that are called myService XPath WSRR WSDLService name myService ports XMQL SELECT a FROM a in Physical WSDLMetadataltem a in a port WHERE a.name myService 

A common approach is to define an adapter framework that allows one to virtualise the backend and represent it through some kind of adapter which is used by the framework to evaluate the query against the backend. An example of such a framework is the Virtual XML Framework from IBM Research. This approach uses a stepwise evaluation of the XPATH query in the framework since each step is evaluated separately and run as an independent query it leads to a large amount of queries being issued and unnecessary data being pulled back from the backend.

The solution therefore translates the XPath query into XMQL directly and then executes the resulting XMQL as a single query. The objects returned are of an XMeta Type and then gets transformed into an WSRR Type .

IBM WebSphere Service Registry and Repository is a master metadata repository for service definitions. Such service definitions include traditional internet services that implement WSDL and XSD interfaces with SOAP HTTP simple object access protocol and hypertext transfer protocol as well as a broad range of SOA services that can be described using WSDL XSD and policy decorations. The service definitions might use a range of protocols and be implemented according to a variety of programming models. WSDL stands for web service definition language. XSD stands for XML schema definition language where XML is extensible mark up language. SOAP and HTTP stand for simple object access protocol and hypertext transfer protocol respectively. SOA stands for Service Oriented Architecture.

WebSphere Service Registry and Repository 10 WSRR is a Java 2 Platform Enterprise Edition J2EE application that runs on a WebSphere Application Server 8 and uses a relational database as a backing store for service metadata persistence. As such it takes advantage of the role based access control provided by WebSphere Application Server so that role based views and access control can be turned on when WSRR is deployed as an enterprise wide application. Referring to the top level components of WSRR comprise a registry and repository core a governance component an administration interface a user interface a programming interface . Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both.

The registry and repository core offers both registry function and repository function for service metadata. The repository function allows users to store manage and query service metadata artifacts holding service descriptions WSDL XSD WS Policy SCDL or XML documents . It not only takes good care of the documents containing service metadata but it also provides a fine grained representation of the content of those documents for example ports and portTypes in WSDL documents . The registry function makes provision for decorating registered service declarations and elements of the derived content models with user defined properties relationships and classifiers. The registry and repository core provides a rich query interface that makes use of those decorations when a search is performed to find entities such as a service endpoint or service interface.

Whenever a change to registry or repository content is detected by registry and repository core it invokes all validation and notification function that are registered in the validation register and the notification register . Both kinds of function are considered extension mechanisms that can be used to customize how WSRR reacts to changes. Validation function can be written and registered that the registry and repository core will execute when changes are made to the content. For example a validation function that checks for completeness of a service definition. Notification functions can be written and registered to communicate changes to the content of the repository. The registry and repository core comes with an out of the box JMS notification plug in. The registry and repository core has a subscription capability that allows your users to register their interest in consuming notifications.

Through the governance component WSRR supports a rich set of extensible governance functions including the ability to model service life cycle model for governed entities define valid transitions between service states write and plug in validators to guard the transitions between states and designate notification actions to be taken as result of the transition. It also provides interfaces to analyze the impact of changes to WSRR content and provides auditing of such changes.

The classification component allows service descriptions and parts of service definitions to be annotated with corporate vocabulary and to capture the governance state. WSRR classification systems are captured in web ontology language OWL documents that are loaded into Registry and Repository using the administrative interface. WSRR entities can be classified with values from these classification systems which allows classification based queries to be performed and access restricted based on classification.

The access controller supports a fine grained access control model that allows for the definition of which user roles can perform specific types of actions on corresponding artifacts. Visibility of services can be restricted by business area and user roles can be restricted from transitioning services to certain life cycle states. This is in addition to the role based access control provided by the WebSphere Application Server.

The administration interface support the import and export of WSRR content for exchange with other WSRR repositories and provide a JMX based API for Registry and Repository configuration and basic administration. These support interactions with the Access Controller and with the Classifier

User interface comprises a web interface and an eclipse plugin interface to enable interaction with WSRR. A servlet based web user interface UI supports is the main way for users representing different roles to interact with WSRR. The Web interface supports all user roles offering lookup browse retrieve publish and annotate capabilities as well as governance activities such as import export and impact analysis. A subset of this user interface is offered as an Eclipse plug in to meet developer needs and analyst users needs that use Eclipse based tooling. The Eclipse plug in is used primarily for lookup browse retrieve and publish capabilities. The Web based user interface can also be used for performing service metadata management and governance.

Programming interface uses Java and SOAP APIs to interact programmatically with registry and repository core . These APIs provide basic CRUD operations governance operations and a flexible query capability based on XPath. The SOAP API is used to communicate content using XML data structures. The Java API is used to communicate content using service data object SDO graphs. Using either the user interface or the programming interface documents and concepts managed by WSRR can be created retrieved updated and deleted. However logical entities in the logical model cannot be modified and these can only be changed by updating a document that contains the logical entity. Concepts can be created retrieved and deleted.

WSRR supports two application programming interfaces APIs that can be used to interact with the registry and repository core the governance component and the administration interface a Java based API and a SOAP based API. Both APIs support publishing creating and updating service metadata artifacts and metadata associated with those artifacts retrieving service metadata artifacts deleting the artifacts and their metadata and querying the content of the Registry and Repository. The programming APIs use Service Data Objects SDO to capture the data graphs inherent in the content model allowing access to physical documents logical parts of the physical documents and concepts. The SOAP API uses XML documents to similarly represent Service Data Objects to communicate content structures in both the physical and logical model.

XPath expressions are used to perform searches with the query interface for coarse and fine grained queries. Queries can be performed using semantic annotations properties and all or parts of physical service metadata artifacts. Fragments of metadata be returned such as endpoints all metadata be returned and both metadata and documents be returned. In addition to free form XPath based queries a set of pre canned queries are available to use to address common paths through the WSRR content model. An XPath expression identifies the type of managed entity to be returned and filters that capture the managed elements related to the desired object. Extensions are provided to include classification annotations in a query. For example if the search is for all WSDLServices that have a port that refers to a binding that refers to a portType named StockQuotePortType the following query expression would be used WSRR WSDLService port binding portType name StockQuotePortType 

The governance component allows analysis of the impact of changes to specific artefacts through an API. A set of predefined impact queries is available to help you navigate through the registry and repository content according to popular patterns such as which WSDL files import or use this XSD. In addition one can use Governance operations to request life cycle transitions for a governed entity as well as the configuration of e mail notifications for users interested in specific content changes.

The administration interface provides a JMX based administration API that supports basic configuration and loading and managing of metadata in support of repository content such as classification and life cycle management. The administration API allows you to load definitions of state machines to be used to model the life cycle of governed entities and to load classification systems described in OWL. In addition the administration API supports registration of plug ins for validation functions or additional notification functions.

Referring to an informal description of the WSRR content model is provided. Broadly the content model has entities representing service description entities and service description metadata . All artifacts have a WSRR assigned URI a name and a description. Examples of each type of artefact are shown within the boxes in but are not necessarily referred to in the description.

Service Description Entities stored and managed in Registry and Repository comprise physical documents logical derivations and concepts . Physical Documents are XML documents that are known as service metadata artefacts. Logical derivations are the finer grained pieces of content that result when some types of physical document are shredded as they are loaded into Registry and Repository. Concepts are generic entities that are usually typed and represent anything that is not represented by a document in Registry and Repository. All three types of service description entities can be use in queries have service annotations applied and have relationships established from and to them.

The most elemental building blocks for the WSRR are the physical documents such as XSD WSDL SCDL or WS Policy documents. In addition any XML service metadata artifact type or binary document can be stored in WSRR and receive the benefits of broader visibility reuse management and governance. The coarse grained model made up from registry objects that represents those documents is referred to as the physical model. Documents are versionable objects in the WSRR content model which means that in addition to a URI name and description they also have a version property.

For some of the physical document types WSRR derives logical objects and stores them in logical derivations . For instance WSRR can shred a document upon receipt into a set of logical objects to enable users to explore WSRR content beyond the boundaries of the files stored. Logical objects are not versionable. For some physical document types WSRR defines a predefined properties and detects relationships to other physical documents. An XSD document for example has a target Namespace property and the relationships with other imported XSD documents other redefined XSD documents and other included XSD documents. When an entry for a certain physical document is created in WSRR it is introspected for relationships to other artifacts. If not already represented in WSRR a related artefact is also added and in either case the relationship between the artifacts is recorded.

The set of logical derivations comprises the logical model of WSRR. The logical model has entities such as portType port and message related to WSDL files and complexType or simpleType related to XSD documents. Elements of the logical model have properties and relationships reflecting a subset of their characteristics as defined in the underlying document. For example a WSDLService element has a namespace property and a relationship to the ports it contains. It is important to note that all individual results of document shredding are aggregated into one logical model that represents not only the content of individual documents but also relationships between content in different documents.

WSRR stores other types of service metadata using the XML Document a generic document type. Documents of type XMLDocument are not decomposed into the logical model.

WSRR uses a concept to represent anything that does not have a physical document. Concepts are used to represent a reference to content in some other metadata repository such as a portlet in a portlet catalogue or an asset in an asset repository. It can also be used to group physical artifacts together to govern them as a unit for example concepts can be versioned.

In addition to content directly related to entities WSRR supports a number of metadata types that are used to describe entities . These metadata types are referred to as service description metadata . WSRR supports three types of service semantic metadata types properties relationships and classifications . All three types describe physical model entities logical model entities and or concepts. For example service description metadata can be used to associate a property businessValue with a physical model entity representing a WSDL file. It might also be used to define a new relationship makesUseOf between an entity in the logical model representing a portType and an entity in the physical model representing an XML document. Furthermore one could create a classification of importantThings and associate it with a port entity in the logical model and with an entity in the physical model representing a Policy document. This enables semantic queries to target individual elements of the service metadata and meaningful dependency analyses to take place prior to making changes.

Properties are simple name value pairs that are associated with any of the Service Description Entities . Some properties are assigned by the system such as the unique id the owner and the last time the service entity was changed. These system assigned properties cannot be changed. Others are derived through the shredding of a key type service description document into its logical model. Properties of this type include name and namespace. Sometimes these system assigned values are allowed to be changed and properties can be created. Such a user defined property can be used as a simple unstructured and untyped extension mechanism. Properties can be used in queries and can be used to establish fine grained access control.

Relationships tie together one source service description entity to one or more target service description entities. Every relationship is given a name and a source is only allowed to have a single relationship with a given name. Some relationships are assigned by WSRR during the shredding of key types of documents. The relationship established between XSD documents based on the importing of one into the other is one such system assigned relationship. Relationships can also be user defined. For example a user can relate a concept that represents an external object to a service using a user defined relationship relate all of the service description documents that will be governed as a unit to a governable entity and or relate a monitoring policy to a service endpoint.

A user can load classification into WSRR where they can then be used to apply semantic meaning to service description entities . Classification systems are documents encoded using the Web Ontology Language OWL . WSRR represents OWL Classes as classifiers and interprets the subTypeOf relationship between those Classes as establishing a classifier hierarchy. Other OWL concepts such as data or relationship representing properties or other built in OWL relationships are ignored. A classification system is imported into Registry and Repository as a whole and can not be modified via WSRR. Updates are done by importing a modified version of the ontology. Any Class in the underlying ontology can be used as a classification the same classification can be used to classify multiple entities and an entity can be associated with multiple classifications.

In one embodiment the invention is provided as discrete nested logical entities within the Query manager as shown in . Referring to the Query manager comprises XMQL query engine and XPath query translator . XPath Query translator comprises XPath register node generator register and validator XPath tree node processor tracker SELECT clause generator and XMQL register and generator . The XPath tree node processor comprises node counter A node search type locator A search type register A selector register A from clause generator A and where clause generator A. The XMQL query engine is a standard XMQL query engine using an XMQL query expression to access objects in WSRR.

The XPath query translator performs the translation between an input XPath expression and returns as output a XMQL expression.

The XPath register stores the XPath query expression so that it may be operated on by the node generator register and validator . The example A in shows the complete XPath expression WSRR WSDLService name GetQuote ports version 1.0 stored in the register. The example B in shows the XPath separated into the sequence nodes.

The hierarchical node generator register and validator operates on the stored XPath query expression by building the node hierarchy registering the hierarchy and validating that the hierarchy and the nodes conform to what is expected by the service registry and repository. The reference in shows a simple hierarchy with two parents each with a respective child. In a more complicated hierarchy a parent node would have more than one child node.

The tracker comprises register for each of FROM clause WHERE clause and selector. The FROM clause and WHERE clause registers are appended after processing each node in the hierarchical node register. The selector may depend on the class of the node that is being processed.

The SELECT clause generator derives the SELECT clause from the last known selector if it is valid this derivation gives a reasonable approximation and is correct much of the time. However other factors may be taken into account for more complex XPath expressions where a simple approximation is not correct.

The XMQL register and generator bring the SELECT clause the FROM clause and the WHERE clause together as a complete XMQL expression. See in WHERE Selector a FROM register a in logical WSDLService a in a ports and Where register a.name GetQuote and a.version 1.0 in tracker C are appended to produced the complete translated query in Register SELECT a FROM a in logical WSDLService a in a ports WHERE a.name GetQuote and a.version 1.0 .

The XPath tree node processor controls the individual processing of the node in the hierarchical node tree and loops back to process each node of the tree. When all the nodes are processed then the XPath tree node processor hands control back to the XPath query translator .

The node search type locator A acquires the XPath expression for the current node and finds the class of node and the properties associated with it. If the located search type is not the same as in the search type register then tracker selector register is incremented and the search type register A is updated with the located search type.

The FROM clause generator A combines the current node and the current selector into a FROM clause portion if the search type is of the FROM class. The FROM clause portion is added to the tracker .

The WHERE clause generator A translates a predicate using properties associated with the particular search type into a WHERE clause portion if the search type is of the WHERE class. The WHERE clause portion is added to the tracker .

The query management system is one embodiment of the invention. In a preferred embodiment the invention is provided as a process as shown in .

In step an abstract syntax tree representation of the XPath query is generated as a set of Java objects.

In step the highest node in the syntax tree is located. This node represents a top level type in the WSRR SDO hierarchy. The node is saved as Current Search .

In step the Selector Clause is derived from the selector saved in the XMQL register as a starting expression for the XMQL query. A simple derivation for simple XPath expressions is to use the last selector value after the node processing. However for more complex XPath a more complex algorithm involving the use of the current selector the current search class and the sequence of steps from the last predicated step in the original expression is used.

In step the expression in the XMQL register corresponds to a translated XMQL expression of the XPath query. The XMQL expression is provided as input to the XMQL engine to access objects in the object repository.

The process starts step at the root of the abstract syntax tree. In this embodiment the root node is verified as WSRR this identifies the query as being targeted towards a service registry system. In the tracker the FROM register and Where register are nulled and the selector is set to the first node of the abstract syntax tree.

In step the tree is examined for a node to process and exits if all the nodes have already been processed.

In step the search type is located by lookup. Properties associated with the located search type are similarly acquired.

In step if the new search type is the same as a current search type then the process misses step and starts again at using the current search type found in the search type register.

In step the selector is incremented and the newly found search type is saved in readiness for updating of the FROM and Where clauses in step and .

In step the current node search type and the current selector are combined into a FROM clause and added to the tracker.

In step if the current node has a predicate then it is translated using properties associated with the search type into a WHERE clause and added to the tracker.

It will be clear to one of ordinary skill in the art that all or part of the method of the preferred embodiments of the present invention may suitably and usefully be embodied in a logic apparatus or a plurality of logic apparatus comprising logic elements arranged to perform the steps of the method and that such logic elements may comprise hardware components firmware components or a combination thereof.

It will be equally clear to one of skill in the art that all or part of a logic arrangement according to the preferred embodiments of the present invention may suitably be embodied in a logic apparatus comprising logic elements to perform the steps of the method and that such logic elements may comprise components such as logic gates in for example a programmable logic array or application specific integrated circuit. Such a logic arrangement may further be embodied in enabling elements for temporarily or permanently establishing logic structures in such an array or circuit using for example a virtual hardware descriptor language which may be stored and transmitted using fixed or transmittable carrier media.

It will be appreciated that the method and arrangement described above may also suitably be carried out fully or partially in software running on one or more processors not shown in the figures and that the software may be provided in the form of one or more computer program elements carried on any suitable data carrier also not shown in the figures such as a magnetic or optical disk or the like. Channels for the transmission of data may likewise comprise storage media of all descriptions as well as signal carrying media such as wired or wireless signal carrying media.

The present invention may further suitably be embodied as a computer program product for use with a computer system. Such an implementation may comprise a series of computer readable instructions either fixed on a tangible medium such as a computer readable medium for example diskette CD ROM ROM or hard disk or transmittable to a computer system using a modem or other interface device over either a tangible medium including but not limited to optical or analogue communications lines or intangibly using wireless techniques including but not limited to microwave infrared or other transmission techniques. The series of computer readable instructions embodies all or part of the functionality previously described herein.

Those skilled in the art will appreciate that such computer readable instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic or optical or transmitted using any communications technology present or future including but not limited to optical infrared or microwave. It is contemplated that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation for example shrink wrapped software pre loaded with a computer system for example on a system ROM or fixed disk or distributed from a server or electronic bulletin board over a network for example the Internet or World Wide Web.

In an alternative the preferred embodiment of the present invention may be realized in the form of a computer implemented method of deploying a service comprising steps of deploying computer program code operable to when deployed into a computer infrastructure and executed thereon cause the computer system to perform all the steps of the method.

In a further alternative the preferred embodiment of the present invention may be realized in the form of a data carrier having functional data thereon said functional data comprising functional computer data structures to when loaded into a computer system and operated upon thereby enable said computer system to perform all the steps of the method.

It will be clear to one skilled in the art that many improvements and modifications can be made to the foregoing exemplary embodiment without departing from the scope of the present invention.

