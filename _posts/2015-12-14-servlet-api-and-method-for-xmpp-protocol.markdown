---

title: Servlet API and method for XMPP protocol
abstract: A communication system and method include a server hosting an interactive voice response or self-help application in a virtual machine. In order to leverage the advantages and facilities of the servlet model, a XMPP (Extensible Messaging and Presence Protocol) servlet container is provided for the server so that the communication application can be programmed with objects defined by an XMPP servlet API, as well as such as HTTP and SIP servlets, in order to service an XMPP client. In addition to the generic class objects of the Java servlet model, the API also provides a set of XMPP-specific class objects. The XMPP servlet container includes a network point at a transport level for handling network connections, an XMPP service layer for managing XMPP sessions and streams, and an application layer for managing XMPP stanzas.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09479400&OS=09479400&RS=09479400
owner: Cisco Technology, Inc.
number: 09479400
owner_city: San Jose
owner_country: US
publication_date: 20151214
---
This application is a continuation of U.S. patent application Ser. No. 13 088 394 titled SERVLET API AND METHOD FOR XMPP PROTOCOL filed on Apr. 17 2011 which claims the benefit of U.S. provisional patent application No. 61 325 348 titled SERVLET API AND METHOD FOR XMPP PROTOCOL and filed on Apr. 18 2010 the specifications of each of which are incorporated herein in their entirety by reference.

The present invention relates to telecommunication and a networked computer telephony system including the Internet and the Public Switched Telephone System and more particularly to a system and method for deploying XMPP compliant applications built on an XMPP API according to the Java servlet model.

Two major telecommunication networks have evolved worldwide. The first is a network of telephone systems in the form of the Public Switched Telephone System PSTN . This network was initially designed to carry voice communication but later also adapted to transport data. The second is a network of computer systems in the form of the Internet. The Internet has been designed to carry data but also increasingly being used to transport voice and multimedia information. Computers implementing telephony applications have been integrated into both of these telecommunication networks to provide enhanced communication services. For example on the PSTN computer telephony integration has provided more functions and control to the POTS Plain Old Telephone Services . On the Internet computers are themselves terminal equipment for voice communication as well as serving as intelligent routers and controllers for a host of terminal equipment.

The Internet is a worldwide network of IP networks communicating under TCP IP Transmission Control Protocol Internet Protocol suite. Specifically voice and other multimedia information are transported on the Internet under the VoIP Voice over IP protocol.

The integration of the PSTN and the IP networks allows for greater facility in automation of voice applications by leveraging the inherent routing flexibility and computing accessibility in the IP networks.

An example platform for easy deployment of telephony applications is described in U.S. Pat. No. 6 922 411 which entire disclosure is incorporated herein by reference. Essentially a networked telephony system allows users to deploy on the Internet computer telephony applications associated with designated telephone numbers. The telephony application is easily created by a user in XML Extended Markup Language with predefined telephony XML tags e.g. VoiceXML and easily deployed on a website. The telephony XML tags include those for call control and media manipulation. A call to anyone of these designated telephone numbers may originate from anyone of the networked telephone system such as the PSTN Public Switched Telephone System a wireless network or the Internet. The call is received by an application gateway center AGC installed on the Internet. Analogous to a web browser the AGC provides facility for retrieving the associated XML application from its website and processing the call accordingly.

This type of telephony platform allows very powerful yet simple telephony applications to be built and deployed on the Internet. The following are some examples of the telephony applications deployed on this platform. A find me follow me application sequentially calls a series of telephone numbers as specified by a user until one of the numbers answers and then connects the call. Otherwise it does something else such as takes a message or sends e mail or sends the call to a call center etc. In another example a telephonic polling application looks up from a database the telephone numbers of a population to be polled. It then calls the numbers in parallel limited only by the maximum number of concurrent sessions supported and plays a series of interactive voice prompts messages in response to the called party s responses and records the result in a database and so forth. In another example a help desk application plays a series of interactive voice prompts messages in response to the called party s responses and possibly connects the call to a live agent as one option etc. In yet another example a stock or bank Transactions application plays a series of interactive voice prompts messages in response to the called party s responses and conducts appropriate transactions with a backend database or web application etc.

The latter examples are generally referred to as self help applications. In the voice context a self help application is referred to as IVR. IVR refers to Interactive Voice Response and is a technology that automates interaction with telephone callers. Enterprises are increasingly turning to IVR to reduce the cost of common sales service collections inquiry and support calls to and from their company.

As described earlier an IVR is a specific example of a self help application in which users can help themselves by interacting with the application to perform some tasks. A traditional IVR only allows users to interact with it through a voice channel. Similarly a web bot is a specific example of a self help application that allows users to perform tasks using a text channel.

One example of the platform is to host an IVR application that interacts with voice text messaging and other clients in a multi channel environment.

Text messaging has become very popular with the proliferation of portable phones and computing devices. Text messaging is a form of communication by exchange of text messages from point to point or point to multiple points. Most common forms of text messaging are email web blog and instant messaging. Instant messaging IM exchanges messages almost in real time. There are a number of proprietary instant messaging networks each providing IM service to each own clients using a native protocol. An open source IM Network also exists and uses the XMPP protocol.

XMPP refers to Extensible Messaging and Presence Protocol and it is a set of open XML technologies for presence and real time communication developed by the Jabber open source community in 1999.

An XMPP service for a Java application has been implemented in Google Talk as an XMPP extensions a chat application from Google Inc. California USA to make it XMPP compatible. This is accomplished by wrapping XMPP messages as MIME Multipurpose Internet Mail Extensions messages and putting the MIME messages inside a HTTP messages. So from an application point of view it actually receives a HTTP message and has to use a Google specific API to extract the XMPP messages out of the MIME messages inside the HTTP message. This approach is not fully compliant with the standards based Java servlet model.

It is desirable to have a self help application that allows interaction with text messaging clients. It is therefore desirable to have a converged communication application platform which allows applications to be easily developed and executed on the application server side similar to HTTP servlets for web clients or Session Initiation Protocol SIP servlets for voice clients.

A communication system and method include a server hosting an interactive v01ce response or self help application in a Java virtual machine. In order to leverage the advantages and facilities of the Java servlet model a Java XMPP Extensible Messaging and Presence Protocol servlet container is provided for the server so that the communication application can be programmed with objects defined by an XMPP servlet API as well as objects defined by the standards based Java EE platform such as HTTP and SIP servlets in order to service an XMPP client.

In addition to the generic class objects of the Java servlet model the API also provides a set of XMPP specific class objects.

The Java XMPP servlet container includes a network point at a transport level for handling network connections an XMPP service layer for managing XMPP sessions and streams and an application layer for managing XMPP stanzas.

The application is allowed to be programmed with the Java XMPP servlet API in order to leverage the advantages and facilities of the Java servlet model so that programming need not be concerned with low level transport and connection functions and instead focus on business logic.

The architecture of the Java XMPP servlet container is such that the negotiation of streams terminates at the XMPP service layer and not at the application layer. This allows portability of the applications from one server to another server within a cloud of computing resources.

Additional objects features and advantages of the present invention will be understood from the following description of its preferred embodiments which description should be taken in conjunction with the accompanying drawings.

Text messaging has become very popular with the proliferation of portable phones and computing devices. Text messaging is a form of communication by exchange of text messages from point to point or point to multiple points. Most common forms of text messaging are email web blog and instant messaging. Instant messaging IM exchanges messages almost in real time. There are a number of proprietary instant messaging networks each providing IM service to each own clients using a native protocol. An open source IM Network also exists and uses the XMPP protocol.

XMPP refers to Extensible Messaging and Presence Protocol and it is a set of open XML technologies for presence and real time communication developed by the Jabber open source community in 1999.

Some actions in speech applications may find correspondence to text messaging applications. For example playing an audio file is similar to sending a file over IM recording a call is similar to recording a text messaging conversation transferring a call is similar to setting up a chat involving multiple IM users .

The text messaging clients will interact with the self help application hosted in the application platform as if the self help application is a web bot. A popular class of text messaging is Instant Messaging IM where exchange of text messages between parties is almost in real time. An open source IM client OS or XMPP client communicates with an open source network having an XMPP server. Examples of the various native IM networks are AOL Instant Messenger MSN Messenger Yahoo Messenger Lotus Sametime Google Talk and so forth.

Generally each IM network operates under its own native protocol and they are not interoperable. Another class of IM networks is based on the open standard of XMPP as described earlier. A Jabber server provides IM service to its clients. Google Talk is another one that is based on the XMPP standard.

Preferably XMPP server is used as a bridge for the multi channel self help application platform to interoperate with the various different IM networks. A transport module not shown is employed with XMPP server which acts as a XMPP gateway to the various IM networks. To XMPP server the multi channel self help application platform would just be another XMPP client . In this way the various IM clients are able to communicate with the multi channel self help application platform via the transports module and the XMPP server . When the IM client is already part of the XMPP network it will not need to be transported by the transports module but simply talk directly with the XMPP server.

In the traditional web paradigm a user agent in the form of a client machine running a web browser makes a request to a web server. The web server returns a response to the request. The communication is taking place under the HTTP Hypertext Transfer Protocol . Specifically the web browser requests a web resource such as a web page as specified by an URL from a web server. Typically the web server responds by returning the requested web page. The web page may contain text content with embedded instructions for the browser to render the text in the web page. In more sophisticated applications a web page is often generated dynamically by employing server side programs and may incorporate content as queried results from backend databases. Thus some of the content are not hard coded on the web page but are generated and rendered dynamically by the web server. The server side programs may also serve to post data from the client to the backend databases.

Traditionally these server side programs are implemented as scripts conforming to the CGI protocol Common Gateway Interface . The CGI scripts are code modules that perform the task on the web server to generate and render dynamic content or perform other backend functions.

However CGI has several disadvantages. First it is not very portable as different web serving machines with different processors and operating systems may require their own versions of scripts. Secondly it does not use the server resource efficiently. The different CGI scripts is are run in a different process context than the server which starts them. There is the overhead of creating a new process for each request and the different processes do not have access to a common set of server resources.

The Java Servlet model addresses the disadvantages of the CGI. Servlets are modules written in the highly portable Java programming language as they run in the same virtual JAVA machine which is independent of the processor hardware or the operating system. In the objected oriented Java programming language the HTTP requests are parsed and made to interact with software objects modeled on the real objects that operate with the application. Similarly the responses are made to conform with the HTTP protocol before being sent to the requester. Servlets run in a multi threaded environment in the Java server and allow each request to be handled by a separate thread. Also one instance of the Java scripts needs be loaded into the processor memory as compared to CGI where contemporaneous requests require multiple copies of the CGI scripts to be loaded. The original Servlets conform to the HTTP protocol and may be regarded as HTTP Servlets . The Servlet model provides a set of APIs Application Programming Interfaces that is implemented by loading a corresponding Servlet container in the application server. The Servlet model enables developers to rapidly develop applications to port them to different servers and to be able to run them efficiently. It is widely used in web applications and is based on open standards.

The API is an abstraction that describes an interface for the interaction with a set of functions used by the components . It is a list containing the description of a set of functions that is included in a library and that addresses a specific problem. In the current context of Java object oriented languages it comprises a description of a set of Java class definitions and extension class definitions with a set of behaviors associated with the classes. The API can be conceived as the totality of all the methods publicly exposed by the classes the class interface . This means that the API prescribes the methods by which one handles the objects derived from the class definitions.

For call control a number of protocol standards have been put forward for interoperability. For example the H.323 standard is a protocol standard recommended by the ITU International Telecommunication Union for signaling and call control of IP telephony.

An increasingly popular alternative to the H.323 standard for call control is SIP Session Initiation Protocol . SIP is an IETF Internet Engineering Task Force protocol for signaling and call control of IP telephony and multimedia communication between two or more endpoints. It is text based and more web centric and is a comparatively simpler and more lightweight alternative to H.323.

For call control a SIP Servlet has been developed and established as a standard to handle requests under the SIP protocol just as the HTTP Servlet handles requests under the HTTP protocol.

The SIP Servlet Specification JSR 289 is a container based approach modeled on the HTTP Servlet paradigm to developing communication applications utilizing the Session Initiation Protocol SIP protocol. A SIP Servlet is a Java programming language server side component that performs SIP signaling. SIP Servlets are managed by a SIP Servlet container which typically is part of a SIP enabled application server. SIP Servlets interact with clients by responding to incoming SIP requests and returning corresponding SIP responses. SIP Servlets are built of the generic Servlet API provided by the Java Servlet Specification which is established as an open standard by the Java Community Process SM Program through the Java Specification Request JSR process.

Using a SIP Servlet JSR 289 for call control leverages the benefits of the Servlet model. Thus an application developer can develop components of a communication application in terms of low level call control objects and API in the form of HTTP Servlets and SIP Servlet based on the open standards JSR 289.

It is therefore desirable to be able to provide a set of API based on the Servlet model that operates with the XMPP protocol.

The existing Java Servlet model such as HTTP Servlet and SIP Servlet are predicated on the request response model. In the HTTP case the interactions are synchronous. In the SIP case the interactions are asynchronous. While the HTTP Servlet is basically stateless the SIP Servlet has to maintain state in a session.

In XMPP case IM messages are exchanged and there is no inherent concept of request response. The interactions are essentially asynchronous although the handshaking interactions may be synchronous. Similarly IM is basically stateless. However when employing an IM client to interact with a self help application state needs be maintained. Thus a XMPP servlet specification has to overcome these differences.

The Extensible Messaging and Presence Protocol XMPP is an open Extensible Markup Language XML protocol for near real time messaging presence and request response services. The core features of XMPP are defined in Extensible Messaging and Presence Protocol Core RFC3920 which is maintained by the XMPP Standards Foundation formerly the Jabber Software Foundation . The core features include XMPP specific features such as XML streams use of TLS and SASL and the and children of the stream root. These features provide the building blocks for many types of near real time applications e.g. an instant messaging IM and presence application defined in Core RFC3921 .

An important aspect of any communication infrastructure is programmability and the purpose of the XMPP servlet API is to standardize the platform for delivering XMPP based services. The term platform is used here to include the Java API itself as well as standards covering the packaging and deployment of applications. The platform mainly provides the core XMPP features defined in RFC3920 and infrastructure functions so XMPP applications e.g. XMPP IM applications can be built on the platform easily.

A XMPP Servlet is a Java based application component that is managed by a XMPP Servlet container just as a HTTP Servlet is managed by a HTTP container. A XMPP Servlet performs XMPP application functions for example a XMPP Servlet behaves as a XMPP IM application. A XMPP Servlet is responsible for XMPP stanza processing according to application rules for example processing the initial presence stanza by sending probe presence stanza and broadcasting presence stanza . A XMPP Servlet can also control the stream negotiation process by interacting with the container through the XMPP Servlet APL. Like other Java based components Servlets are platform independent Java classes that are compiled to platform neutral bytecode that can be loaded dynamically into and run by a Java enabled XMPP application server. Containers sometimes called Servlet engines are server extensions that provide Servlet functionality. XMPP Servlets interact with XMPP clients or other XMPP servers by exchanging stanzas through the Servlet container.

The Servlet container is a part of an application server that provides the network services over which requests and responses are received and sent. It decides which applications to invoke. A Servlet container also contains and manages Servlets through their lifecycle. A XMPP Servlet container is responsible for managing the connection and the XMPP stream upon the connection with other XMPP entities and the container receives the incoming stanza dispatch the stanza to the appropriate Servlet and accepts the outgoing stanza from the application and routes them it to the appropriate XMPP entity. Servlet containers can be built into or possibly installed into Servlet enabled application servers. A XMPP Servlet container manages the network listen points on which it listens for incoming XMPP traffic a listen point being a combination of transport protocol IP address and port number . A Servlet container may place security restrictions on the environment in which a Servlet executes. In a Java 5 Platform Standard Edition J2SE 5.0 or Java Platform Enterprise Edition 5 Java EE 5 environment these restrictions should be placed using the permission architecture defined by the Java platform. For example high end application servers may limit the creation of a Thread object to ensure that other components of the container are not negatively impacted.

There are three levels of communication from the XMPP Servlet container point of view. The first level is transport layer . In the preferred embodiment TCP is employed as the transport protocol. The network point component in transport layer accepts incoming TCP connection from XMPP client or other XMPP servers and creates outgoing TCP connection to XMPP client or other XMPP servers . The network point component maintains these connections and transfers the incoming data and necessary information to the higher level and also receives outgoing data from the higher level and sends it out.

The second level is the stream level where XMPP streams are handled in an XMPP Service Layer . The stream concept in RFC3920 is mapped to XmppSession interface in the XMPP Servlet API so this level is really responsible for maintaining XmppSession information and providing the session information to higher level.

As shown in application router is a plug in for XMPP Servlet container . During initial connection negotiation container receives open tag requests from a client or other entities and processes it at XMPP Service Layer which then sends a query to the application router as to which application to select. The application router returns a reply with an application selection based on a routing table or predefined rules. The XMPP Service Layer then invokes the selected application and establishes the connection.

The third level is the stanza level where XMPP stanzas are handled. At the stanza level stanzas come into and go out from applications . Stanzas are actually wrapped in Servlet request and response pairs so applications can also get the XMPP Session or connection information from the request or response in addition to the stanza information.

The architecture of the Java XMPP servlet container is such that the negotiation of streams terminates at the XMPP service layer and not at the application layer. This allows portability of the applications from one server to another server within a cloud of computing resources.

As also described in connection with the XMPP Servlet container maintains all network connections at the network point and maintains the XMPP stream information at XMPP service layer .

An example of IM presence is given below. In a XMPP IM application defined in RFC3921 after establishing a session a client sends initial presence to the server in order to signal its availability for communications. The steps performed by the application and container are as follows 

XMPP Messages are handled by the Servlet container. The basic Servlet interface defines a service method for handling client requests. This method is called for each message that the Servlet container routes to an instance of a Servlet. The handling of concurrent messages in a Servlet application generally requires the developer to design Servlets that can deal with multiple threads executing within the service method at a particular time. Generally the Servlet container handles concurrent requests to the same Servlet by concurrent execution of the service method on different threads. XMPP Servlets are invoked to handle all incoming stanzas. In either case the stanza is wrapped in a ServletRequest message or a ServletResponse message and delivered through the service method of the Servlet interface 

If the message is a request the response argument MUST be null and if the message is a response the request argument MUST be null. When invoked to process a XMPP event the arguments must implement the corresponding interfaces as the case may be. For example if it is an IQ set stanza it must implement the IQRequest interface and if it is a IQ result stanza it must implement the IQResponse interface. The XmppServlet implementation of the service method dispatches incoming messages to a method doRequest for requests and a method doResponse for responses respectively 

The XMPP Servlet abstract subclass defines a number of methods beyond what is available in the basic Servlet interface. These methods are automatically called by the doRequest method and indirectly from service in the class to aid in processing XMPP based requests.

The three methods are for stanza processing. Applications usually implement these three methods to process the corresponding stanza for example an IM application may implement the doMessage method for message exchanging.

The doResponse method dispatches the received response to the following method. There is only one method for IQ result or error stanza. Applications need to implement this method when they want to process IQ result or error stanza.

The JID interface represents the JID of any entity corresponding to the JID conception in XMPP core. JID is a class and is an XMPP address.

Requests and responses are objects exchanged between the container and Servlets. When the container received an incoming XML element it encapsulates it in a request or response with other necessary information e.g. the XmppSession object the stanza belongs to and then transfers the request or response to the appropriate Servlet by the Servlet interface. Requests and responses are really wrapped stanza or XML element transferring over a stream.

In order to fit in the Servlet model all request interfaces extend the ServletRequest interface and all response interfaces extend the ServetResponse interface. Apart from the inherited methods these request and response interfaces have only a few their own methods these methods are 

XmppSession getSession for getting the XmppSession this XmppServletResponse belong to void send for sending out this request or response as XML element.

XMPP applications typically must process multiple messages in order to provide the intended service. As Servlets themselves are stateless the API provides a mechanism that allows messages to be correlated and specify how containers associate application data with subsequent messages processed in an application instance . The HTTP Servlet API provides such a mechanism in the form of HTTP sessions. The HttpSession interface allows Servlets to correlate a series of HTTP requests from a particular client and also acts as a store for application data.

The XmppSession interface is the XMPP Servlet API equivalent of HttpSession. It represents a point to point relationship between two entities. However we need converged applications to communicate with other network elements using multiple protocols for example SIP HTTP email etc. Application composition allows for many applications to be active together. This implies that there may be more than one application invoked on a single call that any one application instance may consist of multiple point to point relationships and that these relationships may employ different protocols. This is reflected in the XMPP Servlet API through the notions of protocol sessions and application sessions. A protocol session is a protocol specific session object typically representing a point to point relationship. The XmppSession HttpSession and SipSession interfaces are examples of protocol sessions. An application session in a sense represents an application instance. It contains a number of protocol sessions and is also used as a container for application data. All protocol sessions belonging to the same application instance belong to the same SipApplicationSession this name is inherited from the SIP specification JSR289 . Containers may as an optimization create application session and XMPP session objects lazily for example by postponing creation until requested by the application. The result should be indistinguishable from an implementation that always creates the session objects.

The underlying TCP connection and XMPP stream RFC 3920 are modeled as XmppConnection instances. XmppSession is only loosely coupled with XmppConnection. This allows XmppSession to be replicated among different nodes within a cluster of servers with the knowledge of the underlying network connection and stream negotiation. Such replication provides load balance and fail over capability for a set of clustered Xmpp Servlet Containers.

One of the goals of the XMPP Servlet API is to keep the application programming model simple. This is accomplished by delegating a number of tasks to the container and freeing up the applications to focus on their business logic. Tasks such as management of network listen points TLS negotiation and XMPP XML element parsing are handled by the containers. Speaking overall containers accomplish the following tasks 

An important function of XMPP Servlet application servers is to select applications for invocation and route XMPP messages to them. The application selection and Servlet selection policy in XMPP Servlet container is similar with the SIP Servlet API JSR289 . A key component of the XMPP application selection procedure is the application router which is a logical entity shown in and . Application router is called by the container to select a XMPP Servlet application to service an initial request. It embodies the logic used to choose which applications to invoke. An application router is required for a container to function but it is a separate logical entity from the container. Application router is solely responsible for application selection and must not implement application logic.

The container receives open tag requests from other entities calls application router to obtain the application to invoke and then invokes the selected application. A common application router will check the to attribute in the open tag and select the appropriate application based on the value of the to attribute. Initial requests are routed based on an application selection process. The routing of an open tag request establishes a path of applications. Subsequent requests and responses are then routed along the path taken by the initial request.

Each application is responsible for Servlet selection. As mentioned in application architecture every application has a MAIN Servlet. The container dispatches all the incoming request only to the MAIN Servlet and then the MAIN Servlet dispatches the request to other Servlets in the application by the application s own business rules.

In the XMPP protocol when a server accepts a TCP connection and receives a open tag for initiating a XMPP stream the server responds by opening a TCP connection and sending an XML stream header to the initiating entity and then advertises supported features by sending the XML element. In the XMPP Servlet API the three features TLS SASL and resource binding that are described in XMPP core RFC3920 must be configured in the deployment descriptor. If the application needs any of the three features it can configure it in the deployment descriptor then the container will advertise these features to the initiating entity when received a stream request. If the application needs other application specific features it must do the following things 1 configure a XmppConnectionListener in the deployment descriptor to receive XmppConnectionEvent which is triggered by the stream open request of the initiating entity 2 implement the onStream XmppConnectionEvent event in the XmppConnectionListener and 3 return the application specific feature in this method.

The TLS negotiation is accomplished by container the only thing that needs applications do is to configure it in the deployment descriptor.

Applications can configure to use container managed security in the deployment descriptor so the container can accomplish all the SASL negotiation by using the configured information. Applications can also process the SASL negotiation by registering their own SASL mechanism provider and selecting another mechanism during SASL negotiation.

Once the XmppConnectionListener selects the mechanism the container will complete the authentication based on the mechanism selected by the XmppConnectionListener.

The resource identifier of JID is used to identify a specific session with a client and the container is responsible for maintaining session information so the container itself must accomplish the resource binding process. When an application needs resource binding functionality it only needs to configure the requirement in the deployment descriptor. When the container finds the resource binding configuration it will accomplish the resource binding process by itself and set the negotiated resource identifier in the XmppSession object.

The following is a snippet of a deployment descriptor instance. This snippet illustrates the main different part of XMPP deployment descriptor with SIP and HTTP deployment descriptor. There are three parts in the snippet. The client login config part configures the policy when the container accepts connections from a client. The server login config element configures the policy when the container accepts connections from other XMPP server. The login to other server config element configures the policy when the container initiates connections to other XMPP server. In every part there are four elements. The appProcessStream element is used to configure whether the application wants to receive the open tag request and which request to receive any of the three types the RAW request the request received after TLS negotiation the request received after SASL negotiation. The TLS configure element is used to configure the TLS requirement level. The SASL mechanism is used to configure the SASL mechanism. The resource binding element is used to configure if resource binding is required.

While the embodiments of this invention that have been described are the preferred implementations those skilled in the art will understand that variations thereof may also be possible. Therefore the invention is entitled to protection within the full scope of the appended claims.

