---

title: Application management
abstract: The subject matter of this specification can be embodied in, among other things, a method that includes executing one or more computer applications and ranking the applications according to one or more criteria that change in response to a user's interaction with the applications. State information for certain of the one or more applications is saved and one or more applications are terminated in response to a memory condition. Subsequently, one of the terminated applications is revived using the saved state information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09384096&OS=09384096&RS=09384096
owner: Google Inc.
number: 09384096
owner_city: Mountain View
owner_country: US
publication_date: 20150610
---
This application is a continuation application of and claims priority to U.S. application Ser. No. 13 964 559 filed on Aug. 12 2013 now U.S. Pat. No. 9 069 615 which is a continuation of and claims priority to U.S. application Ser. No. 11 932 613 filed on Oct. 31 2007 now U.S. Pat. No. 8 510 743 the entire contents of each are hereby incorporated by reference.

This document refers to management of applications running on a computing device when memory is limited.

Computers continue to expand outward from their origins in temperature controlled data centers to room size mainframes to desktop personal computers to laptops and on to portable devices such as personal digital assistants PDAs and smartphones. The ever decreasing size of computers creates a challenge for computer designers and for software developers seeking to develop operating systems for the computers and programs to run on the computers. Even as the size of the devices shrink the demands of computer users have increased so that people expect their cellular telephones to play audio and video and to carry out all sorts of additional functions often at the same time.

Each such application requires computer memory to run however the smaller a device is the less memory it typically can have. Thus a computer may run out of memory when it is executing multiple applications simultaneously. Such a memory overflow condition can sometimes cause the computer to crash. Memory management techniques commonly employed by desktop computers laptops and the like are generally unsuitable for their less powerful portable counterparts. For example the virtual memory management systems commonly used in a desktop computing system require numerous read and write operations from and to the system s hard drive. Portable devices often rely on flash memory that is ill suited for frequent write operations and is often too small for use in a virtual memory management system. Desktop computing systems may also rely on the user to manage applications running the system e.g. the user often closes unnecessary applications or applications that consume too much memory. However user memory management is often undesirable for portable computing devices. The exemplary systems and methods manage memory on portable computing devices without using virtual memory or requiring the user to participate in memory management. Memory management in the exemplary systems is often transparent to the user because in some implementations every application may appear to be running when in fact one or more of the applications may have been terminated. In an illustrative example the operating system may close one or more applications when memory is needed. If a user wants to interact with a terminated application the operating system may revive the application using saved state information.

In general this document describes systems and techniques for managing applications on a computing device such as a mobile telephone when memory runs out. The systems and techniques may monitor memory usage on a device and when memory runs out or in some implementations begins to run low the system kernel may identify applications that are of lesser importance to the user. Various state parameters for such applications may be saved where the state parameters are selected to be sufficient to recreate the current state of the application. The system kernel may then shut down the selected application or applications to free up memory. Later applications that were shut down may be re launched often in a manner that is transparent to the user.

In certain implementations the applications to be shut down may be selected as applications that closely match the memory that is required or expected to be required by a dominating application. In addition the applications to be shut down may be based on the application type e.g. applications that do not respond to periodic outside communications can be shut down before applications that do application visibility or based on frequency of use by the user e.g. as determined by the elapsed time since the user last focused on the application or on the number of times or the amount of time the user has focused on the application over a prior time period .

One implementation provides a computer implemented method for managing computer applications. The computer implemented method includes steps that when performed execute one or more computer applications. The method may also include steps that rank the applications according to one or more criteria that change in response to a user s interaction with the applications and save state information for certain of the one or more applications. The computer implemented method may also include steps to terminate one or more applications in response to a memory condition and subsequently revive one of the terminated applications using the saved state information.

In a second general aspect a computer implemented system for managing computer applications includes an application manager to classify applications according to one or more criteria that change in response to a user s interaction with the applications and to save state information for certain of one or more applications. The system may also include an application terminator to terminate one or more applications upon the occurrence of a memory shortage and a kernel to in response to user interaction with the one or more applications revive a terminated application using the saved state information when the terminated application has the highest application ranking.

In a third general aspect the computer implemented system includes computer memory to store a plurality of simultaneously operating computer applications. The system may also include an application manager and means for temporarily terminating and re launching applications in response to a computer memory condition

The systems and techniques described here may provide one or more of the following advantages. First a system can run multiple applications on a computing device with limited memory without requiring fixed constraints on memory usage or using virtual memory. Additionally the system may provide the user with a substantially uninterrupted computing experience while providing transparent memory management.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages of those features will be apparent from the description drawings and the claims. The details of one or more embodiments of the features are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

This document describes systems and techniques for managing memory on a computing device with limited memory. In an exemplary implementation applications running on the system are ranked and low ranking applications are killed if the device s memory is unable to accommodate current memory demands. A killed application may be subsequently revived by the system if a user attempts to interact with the killed application. For example it is increasingly common today for cellular telephone users to run multiple programs at the same time on their telephone. One or more applications may lie dormant in the background of the telephone s display as the user interacts with another application in the telephone s foreground. If the telephone runs out of memory the telephone s operating system may kill one or more background applications to ensure that enough memory is available for use by the foreground application. When the user attempts to return to the terminated background application the system may recreate the application as it existed before it was killed using information saved by the application. In an alternative implementation the telephone s operating system may detect a pending memory shortage and in response terminate one or more applications to provide sufficient memory for important applications. If the user tries to use a terminated application the application is recreated using data saved by the application before it was killed.

In one implementation where the device is a telephone after turning on the telephone the telephone s operating system may be loaded from persistent memory and may present a graphical user interface containing a predetermined display of icons to the user. Each icon can be either an application or a proxy for an application available to the user when selected a chosen icon may if necessary pass the associated application s parameters and file location in memory to the operating system which in turn can execute the application . Each executed application uses a segment of the telephone s persistent memory as an application continues to run its memory requirements may increase. As the user executes more applications or the running applications consume additional memory the telephone s memory may eventually become inadequate to accommodate the memory demands of the applications .

In an exemplary implementation the memory management system may respond to memory shortages by terminating one or more applications when persistent memory has been exhausted and reviving the terminated application when the user returns to the application. In certain implementations because the terminated application window may be either fully or partially obscured by another application window the user may not be aware that the application has been terminated. When a user chooses to switch back to the application the application may be re launched and the user may not know that the application was temporarily terminated aside from perhaps a sluggish response in displaying the application.

In an illustrative implementation the operating system can rank the applications according to a user s interactions with the graphical user interface and each application may generate and save information regarding its current state in response to a signal from the operating system. The applications may save such state information themselves or may provide the information to the operating system which may in turn save the information to persistent storage e.g. flash memory .

If memory is exhausted the operating system may terminate one or more ranked applications and later recreate the terminated applications in response to a user request. For example once the operating system has loaded the user may select a document viewing application to read a stored document. Subsequently while the document viewer is still running the user may open a web browser and begin surfing the Internet. In the midst of the web browsing session the user in response to a notification that an email has arrived may select the telephone s email application to review the new email. As the user is reading the email the user may attempt to run a calendar application to create a reminder for an event mentioned in the email.

In an exemplary implementation as the user opens new applications the operating system may rank the applications according to one or more dynamic criteria. Here the operating system might rank the running applications in descending order of importance in the following manner email application web browser and document viewer. Such ordering may occur in various ways. For example the applications may be separated into various categories such as necessary business applications entertainment applications etc. In some implementations the operating system may recognize that a particular application lays dormant when it is in the background so it may classify that application as low priority. But another application may be constantly accessing information over a network e.g. a messaging program and may thus be ranked as a higher priority application. In some implementations applications are divided into two categories visible and invisible applications. Invisible applications i.e. those applications whose windows are not visible to the user are ranked lower than visible applications. In an alternative implementation the developers of the applications may self classify the applications or the user may classify or otherwise rank the applications and such classifications or rankings may be provided to the operating system .

As the user interacts with the applications each application may generate and save information regarding the current state of the application. For example when an application enters a state where it could be killed by the operating system at any time e.g. the application is no longer visible to the user the operating system may instruct the application to save its current state.

Returning to the illustrative example because the telephone s memory might be insufficient to run all four applications at once the operating system may choose to terminate the lowest ranked application in this example the document viewer as it opens the calendar application because it has run out of memory. In an alternative implementation the operating system may predict a pending memory shortage and terminate one or more applications to prevent memory from running out. For example if the amount of memory currently available drops below a predetermined threshold the operating system may kill low ranking applications to bring the amount of currently available memory above the threshold. In an alternative implementation the operating system may compare upcoming memory requests by applications with the amount of memory currently available if the amount requested exceeds the amount currently available the operating system may kill one or more applications.

In such a situation the operating system may identify the lowest ranked application or applications and terminate them temporarily. The operating system may also set a flag as an indication of applications that may need to be re launched automatically at a later time e.g. when memory frees up 

Selection of an application to kill may occur by other techniques. For instance the operating system may determine the amount of memory that is needed by a particular application and then identify other operating applications that can free up that amount of memory plus a certain safety zone of overhead memory. As one example an application might require 3000K of extra memory and three other applications might each be capable of freeing up 2000K 3000K and 15000K of memory respectively. The operating system may determine that the least damage to memory or the best use of available memory may be accomplished by killing the first two programs because they most closely approximate the amount of memory that is needed. Alternatively the operating system may be programmed to prefer killing as few applications as possible. In such a situation the third application in the example would be killed.

Once the user has finished using the calendar application the user may choose to return to the document viewing application. When the operating system detects an attempt by the user to return to the document viewing application which has been killed temporarily the operating system may recreate the application using the saved state information.

To do so the operating system may first sense a command to access the document viewing application and may note from the stored flag that such application was active but has been killed temporarily. The operating system may then launch the application and pass the saved state information to the application so that the application may be recreated in the form it was in or substantially the form it was in when it was temporarily killed. Alternatively the application may have stored its own state information in cooperation with the operating system and may itself access and implement such information.

As described in greater detail below the operating system can control the execution of various applications running on the system . By among other things scheduling when applications may execute instructions on the computing device s processor not shown the operating system may prevent the applications from causing critical system errors such as memory overflow errors.

In an illustrative implementation a kernel can be included in the operating system . The kernel may be responsible for directing core operating system applications such as controlling process execution managing memory and handling device drivers among many others. In certain implementations the kernel may rank applications in an application hierarchy according to when an application s associated window was in the foreground of the display and able to receive user input i.e. when the window was in focus. In an alternative implementation the kernel may rank applications according to other criteria. For example applications may be ranked according to memory or processor usage the amount of time the application has been running or the visibility of the application window and other factors discussed herein.

The application hierarchy may be implemented for example as a program stack. In certain implementations applications are ranked in descending order beginning at the top of the stack. Because in some implementations the application that is currently in focus is placed on the top of the stack the stack can represent a ranking of active applications by when they were in focus or by another parameter.

Application manager may in certain implementations monitor applications running on the system. In some implementations when an application s state changes application manager may instruct the kernel to update the application hierarchy . As the state of the applications change the application manager may also direct each application to save the application s current state to persistent memory .

In an alternative implementation the saved state information may include dependencies between applications. For example at times a user may execute an application that relies on information produced by other applications. In an illustrative example a user may execute both a media player and a web browser. As the media player is playing music stored on the computing device the name of the artist song and other information related to the currently playing track may be displayed in the status bar of the web browser. When the web browser is instructed to save state information it may include information relating to the media player that would allow the browser to continue displaying song information when the browser is revived. For instance the state information may include the media player s program identifier and operating parameters.

The kernel may include an application terminator . The application terminator may in response to receiving an appropriate command from the kernel erase one or more applications from memory . The application terminator in an alternative implementation may be part of a unified system cache not shown . In some implementations the application terminator may kill an application while leaving a snapshot of the application window visible in the graphical user interface. For example if the application window of the application to be terminated is partially visible in the background of the graphical user interface before the application is killed by the application terminator the terminator may copy the application window. After killing the application the operating system may display the copy of the application window in the graphical user interface. By displaying the copy of terminated application window the operating system may prevent the user from realizing that a background application has been killed.

In an alternative implementation either the application manager or the application terminator may generate and update the application hierarchy . For example as applications change state the appropriate entity may update the application hierarchy . When the system runs out of memory or in an alternative implementation detects an impending memory shortage information identifying applications at the bottom of the hierarchy can be passed from the proper entity to the kernel if necessary.

Referring to in certain implementations as one or more applications are executed on a graphical user interface the application manager may observe the running applications and as a user interacts with the applications may inform the kernel when an application changes state. For example when the operating system is loaded from memory the operating system may run the application manager during the operating system s start up routine. In an illustrative example as a user interacts with the graphical user interface the application manager may instruct the kernel to update the application hierarchy as applications gain and lose focus. For example when the application manager reports that an application s window is no longer in the foreground of the display the application terminator can downgrade that application in the hierarchy .

In an illustrative implementation when an application s state changes the application manager may order the application to save the application s current state to memory . In some implementations before an application saves state information to persistent memory the application may save state information to the application s memory . For example when an application s window moves to the background of the telephone s display or is no longer visible the application manager may instruct the application to save any information necessary to later recreate the application. In response the application may first temporarily save the state information to application memory when the appropriate function is called the application may then save the recorded state information to persistent memory .

As an increasing number of applications are executed or the existing applications use more memory the operating system may terminate one or more applications . For example when the system has run out of memory the kernel may kill one or more applications so that there is sufficient memory to execute important i.e. highly ranked applications. In some implementations the kernel may detect that no memory is available and in response notify the application terminator to kill one or more low ranked applications. In an alternative implementation the kernel may detect an imminent memory shortage. When an impending memory shortage is detected the kernel may notify the application terminator to make more memory available by stopping one or more applications. In some circumstances when the kernel detects that memory is becoming scarce the kernel may notify the application terminator to terminate one or more applications near the bottom of the application hierarchy to free enough memory to run other applications .

In some implementations the operating system may after receiving a request from the user restore a terminated application. For example by minimizing or closing other application windows or by selecting an icon that represents the dead application the user may return to the application that was stopped by the application terminator . When the operating system receives an indication that the user has returned to the terminated application the operating system may recreate the application using the saved state information.

Referring to a process illustrates the lifecycle of an application in the exemplary method for managing potential memory shortages on a computing device. The method begins at step where an application is executed. For example the operating system may load an application from persistent memory in response to a user request or at the behest of another application. Next at step the system determines whether the state of the application has changed. In some implementations the application monitor can note when an application takes focus when a new application has been created or when application has been terminated. In an alternative embodiment in addition to or in lieu of the changes mentioned above the application manager may monitor user inputs to the system e.g. key presses mouse clicks stylus or finger taps etc. to determine when an application may have changed state.

If a change of state is not detected the method proceeds to step where the system determines whether a memory shortage exists. If the system determines that a memory shortage does exist the method proceeds to step discussed below. If however a memory shortage does not exist step is repeated.

Once a state change is detected the method proceeds to step . At step state information is generated and stored. Because applications in certain states may be killed at any time after the application monitor detects a state change the application monitor may instruct the application to generate and store state information in persistent memory . In an illustrative implementation the state information may include information used to recreate the application as the application existed before it was terminated. For example the state information may include but is not limited to the location of the application s window on the display any changes to an application file made by the user and the user s preferred view mode. Once the state information is generated the application may store the state information to persistent memory .

After state information is generated and saved the method proceeds to step where the system determines whether a memory shortage exists. If the system determines that memory has run out the kernel may instruct the application terminator to make memory available by killing one or more applications. In an alternative implementation the kernel may determine whether memory is becoming scarce. The kernel may detect an imminent memory shortage by comparing memory requests from the applications with the memory currently available. The kernel may also determine whether the amount of memory available is lower than a predetermined threshold value. When a shortage is detected the kernel may take steps to free enough memory to ensure that selected applications will have sufficient memory to continue normal operation.

If the system has determined that memory is needed the method advances to step where the application terminator determines if the application is the lowest ranked application i.e. whether the application is at the bottom of the application hierarchy . If the application is not at the bottom of hierarchy the method returns to step where the system monitors the application for a change of state. If the application is at the bottom of the hierarchy the method proceeds to step where the application is killed. In some implementations the application terminator determines whether the application is the last application in a program stack. If so the application and any associated threads are killed.

At step they system determines if the application should be revived. In an illustrative implementation if the system detects a user attempt to return to an application that was killed the method returns to step where the application is revived using stored state information. For example the system may detect attempts by the user to close or minimize windows overlaying the killed application. In response the system loads state information for the application from persistent memory and uses the stored information to revive the application.

If the system does not detect an attempt to interact with the killed application the method returns to step where the system again determines whether to revive the application.

Referring to an application s lifecycle begins with its creation. As discussed in reference to above in certain implementations applications may be created in response to either a user request or a command from another application. In an exemplary implementation when an application is created the system may call the onCreate function. In some implementations onCreate handles static setup operations such as binding data to lists and creating views. Some applications may not require or permit any interaction with the user during its execution when these applications finish running they are subsequently destroyed by the onDestroy function.

If an application does require user interaction in some implementations the system may call the onResume function. In an illustrative example onResume is called before the application gains focus and prepares the application to interact with the user. For example onResume may start window animations or take control of devices e.g. a camera or a microphone for exclusive use by the application. Again if the application finishes executing before another program takes focus away from the application the application may be terminated by the onDestroy function.

After the system calls onResume the application switches to the active state and continues executing until the application finishes or the application window loses focus. An application window may lose focus if for example a user navigates away from the application window or a new application window is opened. In some implementations if the application loses focus the operating system may subsequently call the onFreeze and onPause functions. onFreeze in some circumstances may generate and save state information for the application to application memory . The system may call onPause immediately after onFreeze to save the state information generated by onFreeze to persistent memory .

In an illustrative example after saving its state information to persistent memory the state of the application may change depending on the visibility of the application s window. In some implementations if the application window is still visible after losing focus e.g. the new window is transparent or a floating window the active application may change to a paused application. In some circumstances the paused application may be erased by the operating system this procedure is discussed further in the description of the stopped state. If the paused application regains focus by for example the new screen being closed the paused application changes state back to an active application. If however a new full screen application window opens the paused application shifts to the stopped state which is discussed in further detail below.

In some implementations if the new application s window occupies the entire screen the operating system calls the onStop function. In an illustrative implementation onStop saves the application s state information to persistent memory and the paused application changes state to a stopped application. In the illustrative implementation when an application in the stopped state regains focus the system may call the onRestart function. onRestart may requery a cursor before the application changes back to the active state.

As noted above applications in the stopped or paused state may be terminated by the operating system at any time. When an application is killed the application becomes a dropped application and any associated application memory is erased and made available to other applications.

Since dropped applications have no state information in application memory they must be recreated from state information saved in persistent memory . In the exemplary implementation when user returns to a dropped application the system calls onCreate to recreate the dropped application. Using the state information saved to persistent memory onCreate revives the application and the state transition process described above is repeated.

At step an operating system detects a state change in a graphical user interface. In some circumstances an application monitor may monitor the graphical user interface and note when a new application comes into the foreground of the user interface. In response to the state change at step the operating system instructs the applications to generate and save state information. Instead of saving the state information to memory on the device applications may transmit the state information to a remote computing device . In an illustrative example the remote computing device can be a web server . In alternative implementations the remote computing device may a mobile device e.g. cellular telephone PDA or laptop or a personal computer.

After detecting a state change and saving state information the system updates an application hierarchy at step . In some circumstances the applications can be ranked in the hierarchy according to when each application was in focus. In alternative implementations applications may be ranked according to other criteria such as memory or processor usage. This process detecting a state change saving state information to a remote device and updating an application hierarchy is repeated until memory on the computing device is exhausted. If at step the operating system detects a memory shortage the operating system may kill one or more applications at step .

In some situations the operating system may kill applications at the bottom of the application hierarchy . In an alternative implementation the system may notify the user of the memory shortage and allow the user to select an application to terminate. Subsequently at step when the system detects an attempt by the user to return to the killed application at step the application may request state information from the computing device at step . At step the remote computing device may transmit state information to the computing device . After receiving the state information transmitted at step the computing device may revive the suspended application at step .

Referring now to the exterior appearance of an exemplary device that implements various aspects of an application manager is illustrated. Briefly and among other things the device includes a processor configured to connect to an application management system and perform various functions some of which have been described above in relation to managing applications running on the device upon request of a user of the mobile device.

In more detail the hardware environment of the device includes a display for displaying text images and video to a user a keyboard for entering text data and user commands into the device a pointing device for pointing selecting and adjusting objects displayed on the display an antenna a network connection a camera a microphone and a speaker . Although the device shows an external antenna the device can include an internal antenna which is not visible to the user.

The display can display video graphics images and text that make up the user interface for the software applications used by the device and the operating system programs used to operate the device . Among the possible elements that may be displayed on the display are a new mail indicator that alerts a user to the presence of a new message an active call indicator that indicates that a telephone call is being received placed or is occurring a data standard indicator that indicates the data standard currently being used by the device to transmit and receive data a signal strength indicator that indicates a measurement of the strength of a signal received by via the antenna such as by using signal strength bars a battery life indicator that indicates a measurement of the remaining battery life or a clock that outputs the current time.

The display may also show application icons representing various applications available to the user such as a web browser application icon a phone application icon a search application icon a contacts application icon a mapping application icon an email application icon or other application icons. In one example implementation the display is a quarter video graphics array QVGA thin film transistor TFT liquid crystal display LCD capable of 16 bit or better color.

A user uses the keyboard or keypad to enter commands and data to operate and control the operating system and applications that provide for displaying configuring and viewing various applications. The keyboard includes standard keyboard buttons or keys associated with alphanumeric characters such as keys and that are associated with the alphanumeric characters Q and W when selected alone or are associated with the characters and 1 when pressed in combination with key . A single key may also be associated with special characters or functions including unlabeled functions based upon the state of the operating system or applications invoked by the operating system. For example when an application calls for the input of a numeric character a selection of the key alone may cause a 1 to be input.

In addition to keys traditionally associated with an alphanumeric keypad the keyboard also includes other special function keys such as an establish call key that causes a received call to be answered or a new call to be originated a terminate call key that causes the termination of an active call a drop down menu key that causes a menu to appear within the display a backward navigation key that causes a previously accessed network address to be accessed again a favorites key that causes an active web page to be placed in a bookmarks folder of favorite sites or causes a bookmarks folder to appear a home page key that causes an application invoked on the device to navigate to a predetermined network address or other keys that provide for multiple way navigation application selection and power and volume control.

The user uses the pointing device to select and adjust graphics and text objects displayed on the display as part of the interaction with and control of the device and the applications invoked on the device . The pointing device is any appropriate type of pointing device and may be a joystick a trackball a touch pad a camera a voice input device a touch screen device implemented in combination with the display or any other input device.

The antenna which can be an external antenna or an internal antenna is a directional or omni directional antenna used for the transmission and reception of radiofrequency RF signals that implement point to point radio communication wireless local area network LAN communication or location determination. The antenna may facilitate point to point radio communication using the Specialized Mobile Radio SMR cellular or Personal Communication Service PCS frequency bands and may implement the transmission of data using any number or data standards. For example the antenna may allow data to be transmitted between the device and a base station using technologies such as Wireless Broadband WiBro Worldwide Interoperability for Microwave ACCess WiMAX 6GPP Long Term Evolution LTE Ultra Mobile Broadband UMB High Performance Radio Metropolitan Network HIPERMAN iBurst or High Capacity Spatial Division Multiple Access HC SDMA High Speed OFDM Packet Access HSOPA High Speed Packet Access HSPA HSPA Evolution HSPA High Speed Upload Packet Access HSUPA High Speed Downlink Packet Access HSDPA Generic Access Network GAN Time Division Synchronous Code Division Multiple Access TD SCDMA Evolution Data Optimized or Evolution Data Only EVDO Time Division Code Division Multiple Access TD CDMA Freedom Of Mobile Multimedia Access FOMA Universal Mobile Telecommunications System UMTS Wideband Code Division Multiple Access W CDMA Enhanced Data rates for GSM Evolution EDGE Enhanced GPRS EGPRS Code Division Multiple Access 2000 CDMA2000 Wideband Integrated Dispatch Enhanced Network WiDEN High Speed Circuit Switched Data HSCSD General Packet Radio Service GPRS Personal Handy Phone System PHS Circuit Switched Data CSD Personal Digital Cellular PDC CDMAone Digital Advanced Mobile Phone System D AMPS Integrated Digital Enhanced Network IDEN Global System for Mobile communications GSM DataTAC Mobitex Cellular Digital Packet Data CDPD Hicap Advanced Mobile Phone System AMPS Nordic Mobile Phone NMP Autoradiopuhelin ARP Autotel or Public Automated Land Mobile PALM Mobiltelefonisystem D MTD Offentlig Landmobil Telefoni OLT Advanced Mobile Telephone System AMTS Improved Mobile Telephone Service IMTS Mobile Telephone System MTS Push To Talk PTT or other technologies. Communication via W CDMA HSUPA GSM GPRS and EDGE networks may occur for example using a QUALCOMM MSM7200A chipset with an QUALCOMM RTR6285 transceiver and PM7540 power management circuit.

The wireless or wired computer network connection may be a modem connection a local area network LAN connection including the Ethernet or a broadband wide area network WAN connection such as a digital subscriber line DSL cable high speed internet connection dial up connection T 1 line T 3 line fiber optic connection or satellite connection. The network connection may connect to a LAN network a corporate or government WAN network the Internet a telephone network or other network. The network connection uses a wired or wireless connector. Example wireless connectors include for example an INFRARED DATA ASSOCIATION IrDA wireless connector a Wi Fi wireless connector an optical wireless connector an INSTITUTE OF ELECTRICAL AND ELECTRONICS ENGINEERS IEEE Standard 802.11 wireless connector a BLUETOOTH wireless connector such as a BLUETOOTH version 1.2 or 3.0 connector a near field communications NFC connector an orthogonal frequency division multiplexing OFDM ultra wide band UWB wireless connector a time modulated ultra wide band TM UWB wireless connector or other wireless connector. Example wired connectors include for example a IEEE 1394 FIREWIRE connector a Universal Serial Bus USB connector including a mini B USB interface connector a serial port connector a parallel port connector or other wired connector. In another implementation the functions of the network connection and the antenna are integrated into a single component.

The camera allows the device to capture digital images and may be a scanner a digital still camera a digital video camera other digital input device. In one example implementation the camera is a 6 mega pixel MP camera that utilizes a complementary metal oxide semiconductor CMOS .

The microphone allows the device to capture sound and may be an omni directional microphone a unidirectional microphone a bi directional microphone a shotgun microphone or other type of apparatus that converts sound to an electrical signal. The microphone may be used to capture sound generated by a user for example when the user is speaking to another user during a telephone call via the device . Conversely the speaker allows the device to convert an electrical signal into sound such as a voice from another user generated by a telephone application program or a ring tone generated from a ring tone application program. Furthermore although the device is illustrated in as a handheld device in further implementations the device may be a laptop a workstation a midrange computer a mainframe an embedded system telephone desktop PC a tablet computer a PDA or other type of computing device.

The CPU can be one of a number of computer processors. In one arrangement the computer CPU is more than one processing unit. The RAM interfaces with the computer bus so as to provide quick RAM storage to the CPU during the execution of software programs such as the operating system application programs and device drivers. More specifically the CPU loads computer executable process steps from the storage medium or other media into a field of the RAM in order to execute software programs. Data is stored in the RAM where the data is accessed by the computer CPU during execution. In one example configuration the device includes at least 128 MB of RAM and 256 MB of flash memory.

The storage medium itself may include a number of physical drive units such as a redundant array of independent disks RAID a floppy disk drive a flash memory a USB flash drive an external hard disk drive thumb drive pen drive key drive a High Density Digital Versatile Disc HD DVD optical disc drive an internal hard disk drive a Blu Ray optical disc drive or a Holographic Digital Data Storage HDDS optical disc drive an external mini dual in line memory module DIMM synchronous dynamic random access memory SDRAM or an external micro DIMM SDRAM. Such computer readable storage media allow the device to access computer executable process steps application programs and the like stored on removable and non removable memory media to off load data from the device or to upload data onto the device .

A computer program product is tangibly embodied in storage medium a machine readable storage medium. The computer program product includes instructions that when read by a machine operate to cause a data processing apparatus to store image data in the mobile device. In some embodiments the computer program product includes instructions that allow a user to fully implement and use various applications simultaneously. In some embodiments the computer program product includes functionality for accepting amendments to the software for example updating the computer program product to correct bugs or glitches in the software or hardware operations. In some embodiments the updating can include adding additional elements and features to the computer program product that improve its utility.

The operating system may be a LINUX based operating system such as the GOOGLE mobile device platform APPLE MAC OS X MICROSOFT WINDOWS NT WINDOWS 2000 WINDOWS XP WINDOWS MOBILE a variety of UNIX flavored operating systems or a proprietary operating system for computers or embedded systems. The application development platform or framework for the operating system may be BINARY RUNTIME ENVIRONMENT FOR WIRELESS BREW JAVA Platform Micro Edition JAVA ME or JAVA 2 Platform Micro Edition J2ME using the SUN MICROSYSTEMS JAVASCRIPT programming language PYTHON FLASH LITE or MICROSOFT .NET Compact or another appropriate environment.

The device stores computer executable code for the operating system and the application programs such as an email instant messaging a video service application a mapping application word processing spreadsheet presentation gaming mapping web browsing JAVASCRIPT engine or other applications. For example one implementation may allow a user to access the GOOGLE GMAIL email application the GOOGLE TALK instant messaging application a YOUTUBE video service application a GOOGLE MAPS or GOOGLE EARTH mapping application or a GOOGLE PICASA imaging editing and presentation application. The application programs may also include a widget or gadget engine such as a TAFRI widget engine a MICROSOFT gadget engine such as the WINDOWS SIDEBAR gadget engine or the KAPSULES gadget engine a YAHOO widget engine such as the KONFABULTOR widget engine the APPLE DASHBOARD widget engine the GOOGLE gadget engine the KLIPFOLIO widget engine an OPERA widget engine the WIDGETS widget engine a proprietary widget or gadget engine or other widget or gadget engine the provides host system software for a physically inspired applet on a desktop.

Although it is possible to provide for implementing a application manager using the above described implementation it is also possible to implement the functions according to the present disclosure as a dynamic link library DLL or as a plug in to other application programs such as an Internet web browser such as the FOXFIRE web browser the APPLE SAFARI web browser or the MICROSOFT INTERNET EXPLORER web browser.

The navigation module may determine an absolute or relative position of the device such as by using the Global Positioning System GPS signals the GLObal NAvigation Satellite System GLONASS the Galileo positioning system the Beidou Satellite Navigation and Positioning System an inertial navigation system a dead reckoning system or by accessing address internet protocol IP address or location information in a database. The navigation module may also be used to measure angular displacement orientation or velocity of the device such as by using one or more accelerometers.

The operating system can generally be organized into six components a kernel libraries an operating system runtime application libraries system services and applications . The kernel includes a display driver that allows software such as the operating system and the application programs to interact with the display via the display interface a camera driver that allows the software to interact with the camera a BLUETOOTH driver a M Systems driver a binder IPC driver a USB driver a keypad driver that allows the software to interact with the keyboard via the keyboard interface a WiFi driver audio drivers that allow the software to interact with the microphone and the speaker via the sound interface and a power management component that allows the software to interact with and manage the power source .

The BLUETOOTH driver which in one implementation is based on the BlueZ BLUETOOTH stack for LINUX based operating systems provides profile support for headsets and hands free devices dial up networking personal area networking PAN or audio streaming such as by Advance Audio Distribution Profile A2DP or Audio Video Remote Control Profile AVRCP . The BLUETOOTH driver provides JAVA bindings for scanning pairing and unpairing and service queries.

The libraries include a media framework that supports standard video audio and still frame formats such as Moving Picture Experts Group MPEG 4 H.264 MPEG 1 Audio Layer 3 MP3 Advanced Audio Coding AAC Adaptive Multi Rate AMR Joing Photographic Experts Group JPEG and others using an efficient JAVA Application Programming Interface API layer a surface manager a simple graphics library SGL for two dimensional application drawing an Open Graphics Library for Embedded Systems OpenGL ES for gaming and three dimensional rendering a C standard library LIBC a LIBWEBCORE library a FreeType library an SSL and an SQLite library .

The operating system runtime which generally makes up a Mobile Information Device Profile MIDP runtime includes core JAVA libraries and a Dalvik virtual machine . The Dalvik virtual machine is a custom JAVA compatible virtual machine that runs a customized file format .DEX as well as unmodified JAVA files .CLASS .JAR . With regard to graphics rendering a system wide composer manages surfaces and a frame buffer and handles window transitions using the OpenGL ES and two dimensional hardware accelerators for its compositions.

The Dalvik virtual machine may be used with an embedded environment since it uses runtime memory very efficiently implements a CPU optimized bytecode interpreter and supports multiple virtual machine processes per device. The custom file format .DEX is designed for runtime efficiency using a shared constant pool to reduce memory read only structures to improve cross process sharing concise and fixed width instructions to reduce parse time thereby allowing installed applications to be translated into the custom file formal at build time. The associated bytecodes are designed for quick interpretation since register based instead of stack based instructions reduce memory and dispatch overhead since using fixed width instructions simplifies parsing and since the 16 bit code units minimize reads.

The application libraries which generally make up the MIDP JAVA Specification Requests JSRs includes a view system a resource manager and content providers . The system services includes a status bar an application launcher a package manager that maintains information for all installed applications a telephony manager that provides an application level JAVA interface to the telephony subsystem a notification manager that allows all applications access to the status bar and on screen notifications a window manager that allows multiple applications with multiple windows to share the display an activity manager that runs each application in a separate process manages an application life cycle and maintains a cross application history an application monitor to monitor state changes in the applications and an application terminator to terminate one or more applications.

The applications which generally make up the MIDP applications include a home application a dialer application a contacts application a browser application and a dictionary application .

The telephony manager provides event notifications such as phone state network state Subscriber Identity Module SIM status or voicemail status allows access to state information such as network information SIM information or voicemail presence initiates calls and queries and controls the call state. The browser application renders web pages in a full desktop like manager including navigation functions. Furthermore the browser application allows single column small screen rendering and provides for the embedding of HTML views into other applications.

The persistent core system services such as the surface manager the window manager or the activity manager are hosted by system processes although application processes such processes associated with the dialer application may also be persistent. The processes implemented by the operating system kernel may generally be categorized as system services processes dialer processes browser processes and maps processes . The system services processes include status bar processes associated with the status bar application launcher processes associated with the application launcher package manager processes associated with the package manager activity manager processes associated with the activity manager resource manager processes associated with a resource manager not shown that provides access to graphics localized strings and XML layout descriptions notification manager processes associated with the notification manager window manager processes associated with the window manager core JAVA libraries processes associated with the core JAVA libraries surface manager processes associated with the surface manager Dalvik JAVA virtual machine processes associated with the Dalvik virtual machine LIBC processes associated with the LIBC library application terminator processes associated with the application terminator and application monitor processes associated with the application monitor .

The dialer processes include dialer application processes associated with the dialer application telephony manager processes associated with the telephony manager core JAVA libraries processes associated with the core JAVA libraries Dalvik JAVA virtual machine processes associated with the Dalvik Virtual machine and LIBC processes associated with the LIBC library . The browser processes include browser application processes associated with the browser application core JAVA libraries processes associated with the core JAVA libraries Dalvik JAVA virtual machine processes associated with the Dalvik virtual machine LIBWEBCORE processes associated with the LIBWEBCORE library and LIBC processes associated with the LIBC library .

The maps processes include maps application processes core JAVA libraries processes Dalvik JAVA virtual machine processes and LIBC processes . Notably some processes such as the Dalvik JAVA virtual machine processes may exist within one or more of the systems services processes the dialer processes the browser processes and the maps processes .

Computing device includes a processor memory a storage device a high speed interface connecting to memory and high speed expansion ports and a low speed interface connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as display coupled to high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In one implementation the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device memory on processor or a propagated signal.

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of functions is exemplary only. In one implementation the high speed controller is coupled to memory display e.g. through a graphics processor or accelerator and to high speed expansion ports which may accept various expansion cards not shown . In the implementation low speed controller is coupled to storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In addition it may be implemented in a personal computer such as a laptop computer . Alternatively components from computing device may be combined with other components in a mobile device not shown such as device . Each of such devices may contain one or more of computing device and an entire system may be made up of multiple computing devices communicating with each other.

Computing device includes a processor memory an input output device such as a display a communication interface and a transceiver among other components. The device may also be provided with a storage device such as a microdrive or other device to provide additional storage. Each of the components and are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the device such as control of user interfaces applications run by device and wireless communication by device .

Processor may communicate with a user through control interface and display interface coupled to a display . The display may be for example a TFT LCD Thin Film Transistor Liquid Crystal Display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may be provide in communication with processor so as to enable near area communication of device with other devices. External interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. Expansion memory may also be provided and connected to device through expansion interface which may include for example a SIMM Single In Line Memory Module card interface. Such expansion memory may provide extra storage space for device or may also store applications or other information for device . Specifically expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example expansion memory may be provide as a security module for device and may be programmed with instructions that permit secure use of device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory as discussed below. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory expansion memory memory on processor or a propagated signal that may be received for example over transceiver or external interface .

Device may communicate wirelessly through communication interface which may include digital signal processing circuitry where necessary. Communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. Such communication may occur for example through radio frequency transceiver . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to device which may be used as appropriate by applications running on device .

Device may also communicate audibly using audio codec which may receive spoken information from a user and convert it to usable digital information. Audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on device .

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium computer readable medium refers to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

A number of embodiments have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of this disclosure. For example while the above disclosure uses the term telephony it is implied that other forms of communication that don t necessarily use telephones such as voice over IP systems are considered equivalent with regard to the ability to connect one person to another over transmission lines or wirelessly. Accordingly other embodiments are within the scope of the following claims.

In addition the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other implementations are within the scope of the following claims.

