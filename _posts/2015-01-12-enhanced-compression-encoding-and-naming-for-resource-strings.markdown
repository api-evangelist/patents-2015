---

title: Enhanced compression, encoding, and naming for resource strings
abstract: Technology is disclosed herein for compressing, encoding, and otherwise reducing the size of resource files. In at least one implementation, similarity compression is employed to reduce the size of a resource file. In another implementation, map-less encoding is employed to reduce the number of bytes used to represent a resource string. Bit-level compression is employed in another implementation to reduce the quantity of bits used to encode each character in a string. In addition, implementations are disclosed related to technology for naming strings and accelerated string location and retrieval.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09467166&OS=09467166&RS=09467166
owner: Microsoft Technology Licensing, LLC
number: 09467166
owner_city: Redmond
owner_country: US
publication_date: 20150112
---
Many software applications include large quantities of resource strings such as menu labels feature descriptions and other character strings that may be displayed in a user interface to an application. A resource file or files is typically used to store the resource strings for an application or suite of applications. The resource file may be accessed at runtime by other components of the application when a particular string or set of strings is needed for display in a user interface to the application.

Compression and encoding technology may be employed during the build process to reduce the size of a resource file. A reduced file size is advantageous in view of bandwidth and storage constraints that may be encountered when provisioning and delivering an application. For example a reduced file size may make downloading an application package faster than it otherwise would be. In addition the reduced file size may require less local storage space once it has been downloaded to a local environment. Compression may be especially beneficial with respect to applications that provide support for language localization as a given menu label or other such user interface item may be described by multiple character strings each in a different language.

While a variety of compression technologies exist for compressing text files many are not well suited to compressing relatively short text strings such as a resource string because they usually do not exhibit a repetitive pattern. In addition most compression technologies compress an entire file and then during decompression decompress the entire file at once. In contrast resource strings are decompressed on a per string basis when a string is needed as opposed to decompressing an entire source file at that time.

Decompressing resource strings on a per string basis mandates that a particular resource string be located quickly in a resource file. How strings are named can impact the speed with which they are found. Giving resource strings numerical identifiers in an index allows for fast look up at runtime but such identifiers are difficult to maintain over time especially across multiple development and build platforms. Utilizing resource names may increase ease of use and maintainability but results in slow look up times at runtime.

A balance is therefore continuously sought between the storage gains achieved by resource string compression and encoding and the performance load presented by decompression decoding and various naming constructs at runtime.

Provided herein are various implementations describing enhanced technology for compressing encoding and otherwise reducing the size of resource files. In addition implementations are disclosed related to technology for naming strings and accelerated string location and retrieval. Any particular implementation disclosed below may be considered independently or in combination with any one or more of the other implementations.

In at least one implementation similarity compression is employed to reduce the size of a resource file. Resource strings in the file are compressed based on their similarity to one or more other strings in the file. The compressed strings are comprised of a similarity value representative of the extent to which a string is similar to another as well as a remaining portion of the string not represented in the value.

In another implementation map less encoding is employed to reduce the number of bytes used to represent a resource string. The high byte of each character in a string is eliminated while the lower byte is preserved. In some cases the lower byte may be shifted to avoid overlap with the byte value of another character or characters.

Bit level compression is employed in another implementation to reduce the quantity of bits used to encode each character in a string. In bit level encoding a string specific dictionary is created. Each character in the string is then encoded based on either its position in the dictionary or its relative position in a range that covers the other characters.

Lastly resource strings are stored in association with hash values that are generated from the resource names for the strings. A resource strings is retrieved at runtime based on a proportionality relationship between the hash value for the resource string the total number of possible hash values and the quantity of strings in a resource file.

This Overview is provided to introduce a selection of concepts in a simplified form that are further described below in the Technical Disclosure. It may be understood that this Overview is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Implementations of enhanced resource string compression and encoding technology are disclosed herein including similarity compression map less encoding and bit level compression. In addition an enhanced naming process may be utilized at build time when naming resource strings. A corresponding process is thus disclosed for locating resource strings in a resource file that are named in accordance with the convention.

With respect to similarity compression resource strings in a resource file are compressed based on their similarity to one or more other resource strings. Map less encoding allows each character in a resource string to be encoded with fewer bytes than otherwise even when multiple languages occur in a string. Bit level compression reduces the number of bits in each character byte in a resource string.

The enhanced naming process disclosed herein generates a hash value from the name given to a resource string. The hash value is then used for identifying the resource string in resource file. An enhanced location process is followed locally during runtime to locate a given resource string in a resource file that is named per its hash value.

Referring to operational architecture includes a build platform on which build environment is hosted. Application is developed in the context of build environment and readied for distribution. As a part of building application build environment includes compression and encoding processes which may be applied to elements of application .

Application may include a variety of elements that together form a program or suite of programs non limiting examples of which are represented by one or more resource files and code . Various processes may be carried out in build environment with respect to application in order to produce an application package such as compiling code packaging binary code running automated tests.

In addition several compression and encoding processes may be applied to one or more of resource files which are represented by similarity compression process map less encoding process bit level compression process and name encoding process . The compression and encoding processes serve to reduce the size of at least one of resource files as is discussed in more detail below with respect to .

Application package which includes resource files and code is representative of what may be produced by build environment and uploaded or otherwise provided to service platform . While shown separately build environment may be integrated with service platform and or application provisioning service in some implementations.

From there application provisioning service may distribute application package in any of a variety of ways to runtime platforms for local execution. Runtime platform is representative of one such local execution platform. For example application package may be downloaded to runtime platform and installed as a local application in runtime environment . In another example application package may be streamed into runtime environment or provisioned as a web application that executes in the context of a browser application s runtime environment.

The contents of resource files are decompressed and or decoded at runtime as resources stored therein are accessed by executing components of code . In particular resource files includes at least one resource file in which resource strings are stored. When needed relevant strings are retrieved from the resource file decompressed and decoded and surfaced in a user interface to local application .

Referring now to operational scenario illustrates various aspects of enhanced compression and encoding technology for resource strings as contemplated herein. Operational scenario includes examples of similarity compression map less encoding and bit level compression as applied to a resource string although it may be appreciated that one or more techniques may be skipped or modified.

Operational scenario begins with respect to a resource file that is part of an application build. Resource file includes resource string and resource string for surfacing as text in a user interface to an application. Resource string is text that reads Change Shape to Rounded Rectangle and may be for example a description for a shape formatting feature in a format menu. Resource string is text that reads Change Shape to Right Triangle which includes both Latin text and non Latin text.

In a first stage of operational scenario similarity compression is applied to resource string . This involves a comparison of the similarity between resource string and resource string . A resulting similarity value 17 is generated that represents the extent to which resource string and resource string are similar. Resource string is compressed by substituting the value 17 for the first portion of resource string that overlaps with resource string . Accordingly resource string after undergoing similarity compression includes a similarity value and a remaining portion .

Next a double byte Unicode representation of resource string is analyzed. The double byte Unicode representation includes a Unicode value for each character in the remaining portion of resource string after having been compressed via similarity compression. Thus the double byte Unicode representation begins with U 0069 for the Latin character i and U 0067 for the Latin character g and so on for the other characters. The last few characters of the remaining portion of resource string are non Latin characters Cyrillic in this example . U 03B2 is the Unicode value for and U 03B3 is the Unicode value for . 

Each Unicode value may be understood to have two bytes a high byte and a lower byte. The high byte of a Unicode value generally identifies a range of values in the Unicode map where a given character may reside and can correspond to certain languages. Thus when the high byte of a character is 00 it may be understood that the character is a Latin character. But when the high byte of a character is 03 it may be understood that the character is a non Latin character such as a Cyrillic character.

When subjected to map less encoding each character in a resource string or at least each character in the remaining portion of a resource string is encoded using the lower byte of the Unicode representation of the character. Accordingly the character i is encoded as 69 and the character g is encoded as 67 leaving off the high byte for each character. An encoding byte is identified as the value of the high byte for any non Latin characters which in this example is 03. The non Latin characters using their lower byte only. After map less encoding resource string therefor includes an encoding byte and a set of values that correspond to the lower byte of each character remaining in resource string .

Bit level compression may then be applied to resource string to further compress the string. With bit level compression the quantity of binary bits needed to represent the lower byte of each character remaining in resource string is reduced from eight bits to five bits or from some other quantity to a smaller quantity . In the map less encoding stage each character was reduced to one byte from two. In this next stage the eight bit lower byte for each character can be reduced to five bits.

To accomplish bit level compression a dictionary is identified for resource string that includes the characters T and . The character T is drawn from the word Triangle while the characters and are the last three characters in resource string as originally presented. The character a is identified a range character in the string suitable for anchoring a range of characters that are not included in the dictionary. Then each character is compressed by encoding it with respect to either its location in the dictionary or its location relative to the range character.

For example the hexadecimal Unicode value for the character a is U 0061 while the hexadecimal Unicode value for character g is U 0067. However the hexadecimal value 67 in binary is 01100111 which is seven bits in length. To save bits a difference between a subject character and the range character is calculated. The number of characters in the dictionary is then added to the difference to arrive at an offset value. The subject character is encoded in the binary representation of the offset value. Thus in the preceding example the character g is encoded as the hexadecimal value A 10 in decimal which is the equivalent of the difference 6 plus the number of characters in the dictionary 4 . Thus A hexadecimal can be represented in just four binary bits 1010. 

The same routine can be applied to each character in resource string resulting in the bit level representation of resource string C A . . . 2 3. In other words i is encoded as the hexadecimal value C binary 1100 and g is encoded as the hexadecimal value A binary 1010 . The character is encoded as 2 or 0010 in binary and is encoded as 3 or 0011 in binary to represent their respective locations in the dictionary.

In operation the resource strings in a resource file are ordered alphabetically step . Each string in the resource file that qualifies for similarity compression is then analyzed to identify a similarity value for the string step . The similarity value represents an extent to which a subject string is similar to a string occurring next alphabetically in the file.

Whether or not a string qualifies for similarity compression depends on its place in the alphabetically ordered file. For instance the last string in the file would not qualify for similarity compression as no other string would follow it. In another example while a given string may be followed by other strings a recursion depth may be too great to subject the string to similarity compression.

Upon identifying a similarity value for a qualifying resource string an initial portion of the string is replaced with the similarity value step . A remaining portion of the string is retained. The resource string moving forward would therefore be comprised of the similarity value and the remaining portion of the string.

In operation a given string that is requested by a local application component is located in a resource file step . Assuming the resource string is encoded in the manner discussed above with respect to it will include two parts a similarity value and a remaining portion.

A next string in the resource file relative to the subject string is identified and analyzed to determine whether or not any un encoded characters in the next string can be used to decode the subject string step . That is the remaining portion of the next string as opposed to its similarity value is analyzed to determine if any of those characters are relevant to the subject string.

If none of the next string s un encoded characters can be utilized then the process moves to the next string in the resource file step and the process continues until the subject string is decoded in its entirety. However if any of the next string s un encoded characters are relevant they can be used to decode the compressed portion of the subject string step .

If all of the subject string s encoded characters have been decoded step the subject string in its decoded form can be returned to the requesting application component step . If some characters remain to be decoded then the process moves to the next encoded string in the resource file step .

In the preceding example the savings is roughly equivalent to the number of cut characters less a similarity number byte times one less than the number of strings in a resource file. In other words 61 out of 152 characters were saved.

To decompress the first string in resource file the decompression stages for the first string of the sample are as follows. For the first 16 characters recursively dive to the last string and obtain Change Shape to. Collect the 17th character R from the third string to produce Change Shape to plus R. Add remaining characters from the first string to obtain Change Shape to plus R plus ight Triangle. 

An appreciation of the Unicode encoding model may assist with an understanding of map less encoding. The Unicode encoding model keeps code points of the same script in a consecutive range. Alphabet and alpha syllabary script ranges are generally short. Usually an alphabet is within 128 code points. A basic alphabet is either in the first or last 128 characters of a 256 characters range.

A double byte Unicode code point could be divided as a byte of a range and a significant byte of a character. The range byte is the same for a language. Alphabet languages are all below 0x8000. It is an optional assumption that allows using one highest bit of an encoding byte as a flag.

In map less encoding as contemplated herein one byte has enough bits to encode 256 characters or according to the above calculation two languages. The first language could always be the basic Latin range with numbers and punctuation. The second language could be the language of a particular string. The language or Latin ranges could be shifted to either the upper or lower half of 256 characters. The language range byte could be extracted and stored separately.

Referring to a double byte representation for each character in a resource string is identified step . In a Unicode example a character may be represented by two bytes a high byte and a lower byte. Next the characters in a resource string are analyzed for the occurrence of any non Latin characters step . This is accomplished by examining the high byte of each character for the occurrence of non zero values. As the high byte of Latin characters in Unicode is represented by 00 the presence of non zero values indicates that a character is a non Latin character such as a Cyrillic character.

When a non zero value is encountered the value of an encoding byte is set to equal the non zero value step . The encoding byte serves to identify which other language in addition to Latin is reflected in a resource string.

Upon identifying an encoding byte the high byte of each character in a resource string is discarded step . In the aggregate discarding the high byte of each character in a string reduces the size of the string. Doing so for each resource string in a resource file reduces the size of the file.

Under some conditions the value of the low byte of any Latin characters is shifted so as not to collide with the value of the low byte of any non Latin characters step . The non Latin characters are either in lower or upper half of 256. If it is the low part then the non Latin and Latin will conflict after removing high bytes. Thus shifting is necessary to distinguish Latin and non Latin in this case. If shifting is necessary and the character is a Latin one then add a mask 0x80 to the low byte. In addition and if shifting is necessary then apply the mask to the encoding byte. The mask bit is an indicator of shifting for decompression code.

In operation a given string that is requested by a local application component is located in a resource file step . Assuming the resource string is encoded in the manner discussed above a Unicode double byte character high and low byte is created for each byte of content in the encoded resource string. The first step for each character is to determine whether or not shifting is necessary step . If shifting occurred during the encoding process then shifting is necessary when decoding.

If shifting is unnecessary and if the value of the current byte is less than or equal to 127 step then the value of the high byte is set to 0 and the value of the low byte is set to equal the value of the current byte step . Otherwise the high byte is set to the value of the encoding byte and the low byte is set to equal the value of the current byte step .

If shifting is necessary and if the current byte is less than or equal to 127 step then the high byte is set to equal the value of the encoding byte and the low byte is set to equal the value of the current byte under consideration step . Otherwise the value of the high byte is set to 0 and the low byte is set to equal the unmasked shifted value of the current byte step .

The first text character in the string is the letter which corresponds to the Unicode value 0411. The high byte in the Unicode value is 04 whereas the lower byte is 11. The second text character is the letter which corresponds to the Unicode value 0413. The third text character is the common symbol which corresponds to the Unicode value 002C. The fourth text character is the space symbol which corresponds to the Unicode value 0020. The fifth text character is the letter a which corresponds to the Unicode value 0061. The sixth and last text character in the string is the letter b which corresponds to the Unicode value 0062. 

In the Unicode representation of the resource string is given with the high bytes discarded and the lower bytes retained. Thus U 0411 has been reduced to 11 U 0413 has been reduced to 13 U 002C has been reduced to 2C U 0020 has been reduced to 20 U 0061 has been reduced to 61 and U 0062 has been reduced to 62.

In the Unicode representation of the resource is given with the high bytes discarded the lower bytes retained and the value of Latin characters shifted to avoid potential overlap with the lower byte of any non Latin characters. The Unicode representation thus becomes 0x11 0x13 0xAC 0xA0 0xE1 0xE2. 

In operation a string specific dictionary is defined for each resource string in resource file step . In other words a different dictionary is defined for each resource string in a file. To compress a given resource string each character in the string is analyzed to determine whether or not the character is present in the dictionary for that string step .

For any of those characters found in the dictionary the character is encoded to represents its relative position in the dictionary step . For any of those characters not found in the dictionary the character is encoded to represents its position in a range of characters that are excluded from the range step .

In operation the bit value of an encoded character is identified step . This occurs when a given string that is requested by a local application component is located in a resource file and the individual characters in the string are parsed on a per five bit basis.

Then for each character in the resource string the five bit value of the character is analyzed to determine whether or not its value is less than the size of the dictionary for the string to which it belongs step . If so then the value of the character is converted to the value of the character in the position in the dictionary that corresponds to the five bit value of the character step . In other words the five bit value of the character represents an index to the dictionary and the actual value of the character is the value represented by the indexed position in the dictionary.

If the five bit value of the character is not less than the size of the dictionary then the value of the character is set to equal its index size five bit value less the dictionary size plus the value of the range character with which the resource string was encoded step . In this manner the five bit representation of the character in its bit level encoded state is decoded and equals either a character represented in the dictionary or a character defined by an offset relative to the range character.

In resource file includes a resource string that reads Highlighter. A corresponding single byte Unicode representation of the resource string in hexadecimal is also illustrated in and reads 48 69 67 68 6C 69 67 68 74 65 72. 

When subjected to bit level compression a dictionary specific to resource string is generated that includes the letter H. In addition a range character e is identified. The dictionary and the range character are included in parameters that are used to encode the characters of the resource string. Accordingly the letters of resource string are encoded as follows the values of which are given in hexadecimal.

The letter H is encoded as 0 to denote its place as the first character in the dictionary. The other letters of the resource string that are not included in the dictionary are instead encoded with a value that represents a relative distance from the range character e plus a size of the dictionary. Thus i is encoded as 6 4 1 g is encoded as 3 h is encoded as 4 l is encoded as 8 i is again encoded as 5 g is again encoded as 3 h is again encoded as 4 t is encoded as 10 e is encoded as 1 and r is encoded as E. Note that when converted to binary none of the encoded values exceeds five bits.

To begin a hash value has been produced to identify each resource string in a resource file step . This step is carried out during the build process and occurs in the context of a build environment. The hash value is produced by inputting the name of a resource string into a hash function that generates a distribution of hash values.

The lookup goal is to find the resource ID in ID Content array with minimum iterations. The distribution of probe indexes should be as close as possible to the targeted index. The narrow distribution is necessary to reduce hardware access as an operating system reads data from a hard drive by large chunks pages . If all probe indexes are within the same page then the operating system reads the hard drive only once. The following is a sample function that converts an input resource name to a hash number and after that randomizes bits.

At runtime when a resource string is needed by an application the resource string is invoked using the hash value assigned to it during the build process. However the actually resource string or a pointer to it must be found in the resource file before it can be read and provided to the calling application or component. The location of the resource string in the file is identified based on a proportional relationship between the hash value and the total number of possible hash values step . This proportion or ratio is then applied to the resource file and the total number of resource strings in the file to find an approximate location of the resource string. The lookup is based on this proportion 

If the resource string is found step then decompression and or decoding processes are applied to the string that correspond to the similarity compression map less encoding and bit level compression discussed above step . However if the resource string is not found then search parameters are adjusted that redirect or narrow the search of the resource file for the string. The process continues with additional parameters adjustments as necessary or until the string is found.

In some implementations there may be grouped resources. The groups string tables band several resource into a functional unit. The group could be considered as a list or an array of resources.

When this occurs a compound value may be utilized to identify a resource and may be represented by two 16 bit integers. The high 16 bit WORD is a table ID. The low WORD is a resource identifier within the table usually a zero based index in the table lookup array .

The compound ID structure can be a part of a resource API. For example enumerating resources in a table could be implemented as increasing ID by 1 in a loop. As compound IDs are widely used in some code for application suites the ID notation contemplated herein may keep this structure for grouped resources.

The low WORD of such an ID cannot be a hash value because it is an index. But the high WORD can be a hash of a table name. Collision probabilities for 16 bit hashes are much worse than for 32 bit values. For instance there is 7 probability of a collision for 100 table names. A new table name could cause a collision with 0.4 probability for 300 tables. These numbers are acceptable because new tables are much less frequent than new resources. A grouped resource ID could thus be a hash value of a table name high WORD and a resource index within the table low WORD .

At step A set boundary values Index min 0 Index max Number of Ungrouped Resources 1 ID min 0 ID max 0xffffffff. If the binary does not contain resource tables then continue to step B. Otherwise try to find the resource in tables. Even if the resource is not in tables the table array contain information that helps to narrow table less lookup.

At step A find the table that could contain the resource with the requested ID. The table lookup occurs in the string table blob. It is an array of structures with table ID and other table information.

At step A the table ID is the high WORD of resource ID. Even if the resource is a table less one calculate a fake table ID. Table ID Resource ID 0xffff0000 16.

Otherwise at step A continuously check table IDs of neighbor array elements going up if targeted ID is smaller or down if bigger.

At step A stop when the current table ID matches the targeted one or when ID Target ID current changes sign or when the index hits top or bottom of the array.

At step A if the following condition is true then the resource is a grouped resource HIWORD Resource ID Current Table ID LOWORD Resource ID 

At step A if true the LOWORD Resource ID is an index in the table ID Content array. Stop the lookup the resource is found.

Otherwise at step A the table structure contains the first index of an ungrouped resource with ID greater than the current table ID. It has nothing to do with the table itself but helps to narrow the lookup with respect to step B. Therefore assign Index min Ungrouped Index of Current Table Index max Ungrouped Index of Next Table ID min Current Table ID

At step B if the resource ID at the current index matches the targeted ID then stop the resource is found.

At step B adjust the index knowing the deviation of the previous ID from the requested ID and continue from step B.

Various technical effects may be appreciated from the foregoing implementations. Employing any one or more of compression and encoding processes reduces the size of any one or more of resource files . In turn the size of application package is reduced. This improves the speed with which application package is downloaded from application provisioning service to runtime platform . In addition to improving provisioning times a reduced file size also saves bandwidth on the links or channels between application provisioning service and runtime platform . Such technical effects are applicable to any provisioning scenario but are especially beneficial in the context of mobile provisioning scenarios where bandwidth is at a premium.

Referring back to build platform is representative of any physical or virtual computing system device or collection thereof capable of hosting build environment and implementing one or more compression and encoding processes including similarity compression process map less encoding process and bit level compression process . Examples of build platform include but are not limited to server computers web servers application servers rack servers blade servers virtual machine servers or tower servers as well as any other type of computing system of which computing system illustrated in is representative.

Service platform is representative of any physical or virtual computing system device or collection thereof capable of hosting application provisioning service . Examples of service platform include but are not limited to server computers web servers application servers rack servers blade servers virtual machine servers or tower servers as well as any other type of computing system of which computing system illustrated in is representative.

Runtime platform is representative of any physical or virtual computing system device or collection thereof capable of executing local application in the context of runtime environment . Examples of runtime platform include but are not limited to smart phones laptop computers tablet computers desktop computers hybrid computers gaming machines smart televisions virtual machines and wearable devices as well as any variation or combination thereof of which computing system illustrated in is representative.

Application is representative of the build stage of any software application module component or collection thereof. Application package is representative of the provisioning stage of any application module component or collection thereof. Local application is representative of the runtime stage of any application module component or collection thereof. Examples of local application include but are not limited to email applications cloud storage applications productivity applications calendar applications real time communication applications blogging and micro blogging applications social networking applications e commerce applications and gaming applications as well as any other type of application.

Local application may a locally installed and executed application a streamed application a mobile application or any combination or variation thereof. In some implementations local application may be a browser based application that executes in the context of a browser application. Local application may be implemented as a stand alone application or may be distributed across multiple applications.

Local application may be one of a suite of applications in some implementations. In such scenarios resource files may be shared entirely or in part between the individual ones of the suite of application. Code may also be shared in its entirety or in part.

Computing system may be implemented as a single apparatus system or device or may be implemented in a distributed manner as multiple apparatuses systems or devices. Computing system includes but is not limited to processing system storage system software communication interface system and user interface system . Processing system is operatively coupled with storage system communication interface system and user interface system .

Processing system loads and executes software from storage system . Software includes compression and encoding processes which are representative of the compression and encoding processes discussed with respect to the preceding including compression and encoding processes similarity compression process map less encoding process and bit level compression process as well as the aspects embodied in operational scenarios and .

Software may optionally include decompression and decoding processes capable of decompression and or decoding resource strings when computing system is representative of a runtime platform. Software may also include a process or processes for implementing an enhanced naming convention as discussed herein with respect to .

When executed by processing system to enhance compression and encoding capabilities software directs processing system to operate as described herein for at least the various processes operational scenarios and sequences discussed in the foregoing implementations. Computing system may optionally include additional devices features or functionality not discussed for purposes of brevity.

Referring still to processing system may comprise a micro processor and other circuitry that retrieves and executes software from storage system . Processing system may be implemented within a single processing device but may also be distributed across multiple processing devices or sub systems that cooperate in executing program instructions. Examples of processing system include general purpose central processing units application specific processors and logic devices as well as any other type of processing device combinations or variations thereof.

Storage system may comprise any computer readable storage media readable by processing system and capable of storing software . Storage system may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Examples of storage media include random access memory read only memory magnetic disks optical disks flash memory virtual memory and non virtual memory magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other suitable storage media. In no case is the computer readable storage media a propagated signal.

In addition to computer readable storage media in some implementations storage system may also include computer readable communication media over which at least some of software may be communicated internally or externally. Storage system may be implemented as a single storage device but may also be implemented across multiple storage devices or sub systems co located or distributed relative to each other. Storage system may comprise additional elements such as a controller capable of communicating with processing system or possibly other systems.

Software may be implemented in program instructions and among other functions may when executed by processing system direct processing system to operate as described with respect to the various operational scenarios sequences and processes illustrated herein. For example software may include program instructions for implementing enhanced resource string compression and encoding as well as an enhanced naming convention for resource strings.

In particular the program instructions may include various components or modules that cooperate or otherwise interact to carry out the various processes and operational scenarios described herein. The various components or modules may be embodied in compiled or interpreted instructions or in some other variation or combination of instructions. The various components or modules may be executed in a synchronous or asynchronous manner serially or in parallel in a single threaded environment or multi threaded or in accordance with any other suitable execution paradigm variation or combination thereof. Software may include additional processes programs or components such as operating system software or other application software in addition to or that include compression and encoding processes . Software may also comprise firmware or some other form of machine readable processing instructions executable by processing system .

In general software may when loaded into processing system and executed transform a suitable apparatus system or device of which computing system is representative overall from a general purpose computing system into a special purpose computing system customized to facilitate enhanced resource string handling. Indeed encoding software on storage system may transform the physical structure of storage system . The specific transformation of the physical structure may depend on various factors in different implementations of this description. Examples of such factors may include but are not limited to the technology used to implement the storage media of storage system and whether the computer storage media are characterized as primary or secondary storage as well as other factors.

For example if the computer readable storage media are implemented as semiconductor based memory software may transform the physical state of the semiconductor memory when the program instructions are encoded therein such as by transforming the state of transistors capacitors or other discrete circuit elements constituting the semiconductor memory. A similar transformation may occur with respect to magnetic or optical media. Other transformations of physical media are possible without departing from the scope of the present description with the foregoing examples provided only to facilitate the present discussion.

Referring again to as an example through the operation of a computing system or systems of which computing system is representative transformations may be performed with respect to the various scenarios described therein. As an example resource string compressed and encoded thereby changing its state and the state of resource file .

Communication interface system may include communication connections and devices that allow for communication with other computing systems not shown over communication networks not shown . Examples of connections and devices that together allow for inter system communication may include network interface cards antennas power amplifiers RF circuitry transceivers and other communication circuitry. The connections and devices may communicate over communication media to exchange communications with other computing systems or networks of systems such as metal glass air or any other suitable communication media. The aforementioned media connections and devices are well known and need not be discussed at length here.

User interface system is optional and may include a keyboard a mouse a voice input device a touch input device for receiving a touch gesture from a user a motion input device for detecting non touch gestures and other motions by a user and other comparable input devices and associated processing elements capable of receiving user input from a user. Output devices such as a display speakers haptic devices and other types of output devices may also be included in user interface system . In some cases the input and output devices may be combined in a single device such as a display capable of displaying images and receiving touch gestures. The aforementioned user input and output devices are well known in the art and need not be discussed at length here.

User interface system may also include associated user interface software executable by processing system in support of the various user input and output devices discussed above. Separately or in conjunction with each other and other hardware and software elements the user interface software and user interface devices may support a graphical user interface a natural user interface or any other type of user interface.

Communication between computing system and other computing systems not shown may occur over a communication network or networks and in accordance with various communication protocols combinations of protocols or variations thereof. Examples include intranets internets the Internet local area networks wide area networks wireless networks wired networks virtual networks software defined networks data center buses computing backplanes or any other type of network combination of network or variation thereof. The aforementioned communication networks and protocols are well known and need not be discussed at length here. However some communication protocols that may be used include but are not limited to the Internet protocol IP IPv4 IPv6 etc. the transfer control protocol TCP and the user datagram protocol UDP as well as any other suitable communication protocol variation or combination thereof.

In any of the aforementioned examples in which data content or any other type of information is exchanged the exchange of information may occur in accordance with any of a variety of protocols including FTP file transfer protocol HTTP hypertext transfer protocol REST representational state transfer WebSocket DOM Document Object Model HTML hypertext markup language CSS cascading style sheets HTML5 XML extensible markup language JavaScript JSON JavaScript Object Notation and AJAX Asynchronous JavaScript and XML as well as any other suitable protocol variation or combination thereof.

Certain inventive aspects may be appreciated from the foregoing disclosure of which the following are various examples.

A method to facilitate enhanced resource file compression comprising ordering a set of resource strings in a resource file to produce an ordered set of resource strings in the resource file and reducing a size of the resource file by for any of the ordered set of resource strings that qualify for similarity compression at least identifying a similarity value representative of an extent to which an initial portion of a resource string is similar to a next resource string in the ordered set of resource strings and replacing the initial portion of the resource string in the resource file with the similarity value while retaining in the file a remaining portion of the resource string that was not replaced by the similarity value.

The method of Example 1 wherein ordering the set of resource strings in the resource file comprises alphabetizing the set of resource strings and wherein the method further comprises determining whether or not any given resource string of the ordered set of resource strings qualifies for the similarity compression based at least in part on whether or not the given resource string is followed by any other resource string in the ordered set of resource strings.

The method of Examples 1 2 wherein each of the ordered set of resource strings comprises a set of characters and wherein the method further comprises further reducing the size of the resource file by for any of the ordered set of resource strings that qualify for map less encoding at least identifying a double byte Unicode representation of each character in the set of characters in the resource string wherein the double byte Unicode representation comprises a lower byte and an upper byte identifying at least one character in the set of characters for which the upper byte of the one character comprises a non zero value wherein the non zero value indicates an occurrence of non Latin characters setting a value of an encoding byte to the non zero value and retaining the encoding byte in the resource file to reflect the occurrence of the non Latin characters discarding the upper byte from the resource file for each of the set of characters and retaining the lower byte in the resource file for each of the set of characters.

The method of Examples 1 3 further comprising determining whether or not any of the ordered set of resource strings qualifies for the map less encoding based at least in part on whether or not the set of characters for any given resource string of the ordered set of resource strings includes characters from more than two character ranges corresponding to more than two different languages.

The method of Examples 1 4 further comprising when a value of the lower byte of any of the non Latin characters falls within a lower half of a range of possible values for the lower byte shifting a value of the lower byte of any Latin characters into an upper half of the range of possible values for the lower byte.

The method of Examples 1 5 further comprising shifting the encoding byte to reflect the shifting of the value of the lower byte of the Latin characters into the upper half of the range of the possible values for the lower byte.

The method of Examples 1 6 wherein the lower byte retained in the resource file for each of the set of characters comprises an initial quantity of bits and wherein the method further comprises further reducing the size of the resource file by for any of the ordered set of resource strings that qualify for bit level compression at least defining a dictionary specific to the resource string to include one or more characters of the set of characters in the resource string and for each of the set of characters in the resource string encoding the character in the resource file in a subsequent quantity of bits that is less than the initial quantity of bits and that represents a position of the character in either the dictionary or in a range of characters not included in the dictionary.

The method of Examples 1 7 wherein the lower byte comprises eight bits initially and five bits subsequent to the encoding.

The method of Examples 1 8 further comprising determining whether or not any of the ordered set of resource strings qualify for bit level compression based at least in part on a length of a given string of the ordered set of resource strings.

The method of Examples 1 9 wherein the resource file comprises a one of a plurality of files associated with a productivity application and wherein the ordered set of resource strings describe features in the productivity application.

The method of Examples 1 10 wherein the method further comprises further reducing the size of the resource file by for any of the ordered set of resource strings that qualify for bit level compression at least identifying a double byte Unicode representation of each character in the set of characters in the resource string wherein the double byte Unicode representation comprises a lower byte and an upper byte wherein the lower byte comprises an initial quantity of bits defining a dictionary specific to the resource string to include one or more characters of the set of characters in the resource string and for each of the set of characters in the resource string encoding the character in the resource file in a subsequent quantity of bits that is less than the initial quantity of bits and that represents a position of the character in either the dictionary or in a range of characters not included in the dictionary.

The method of Examples 1 11 wherein the resource file comprises the ordered set of resource strings and a resource name corresponding to each of the ordered set of resource strings.

The method of Examples 1 12 wherein the method further comprises for each of the ordered set of resources strings hashing the resource name generate a hash value and replacing the resource name with a resource identifier that comprises the hash value.

A method to facilitate enhanced resource file compression comprising compressing at least a resource string of a plurality of resource strings in a resource file based at least in part on a similarity of the resource string to at least one other of the plurality of resource strings in the resource file further compressing the resource string by encoding a double byte representation of each character in the resource string in a single byte representation of the character and further compressing the resource string by compressing the single byte representation of the character from eight bits to five bits.

An apparatus comprising one or more computer readable storage media and program instructions stored on the one or more computer readable storage media for reducing a size of a resource file that when executed by a processing system direct the processing system to at least for any of an ordered set of resource strings in the resource file that qualify for similarity compression identify a similarity value representative of an extent to which an initial portion of a resource string is similar to a next resource string in the ordered set of resource strings and replace the initial portion of the resource string in the resource file with the similarity value while retaining in the file a remaining portion of the resource string that was not replaced by the similarity value.

The apparatus of Example 15 wherein each of the ordered set of resource strings comprises a set of characters and wherein the program instructions further direct the processing system to reduce the size of the resource file by for any of the ordered set of resource strings that qualify for map less encoding at least identify a double byte Unicode representation of each character in the set of characters in the resource string wherein the double byte Unicode representation comprises a lower byte and an upper byte identify at least one character in the set of characters for which the upper byte of the one character comprises a non zero value wherein the non zero value indicates an occurrence of non Latin characters set a value of an encoding byte to the non zero value and retaining the encoding byte in the resource file to reflect the occurrence of the non Latin characters discard the upper byte from the resource file for each of the set of characters and retain the lower byte in the resource file for each of the set of characters.

The apparatus of Examples 15 16 wherein the program instructions further direct the processing system to determine whether or not any of the ordered set of resource strings qualifies for the map less encoding based at least in part on whether or not the set of characters for any given resource string of the ordered set of resource strings includes characters from more than two character ranges corresponding to more than two different languages.

The apparatus of Examples 15 17 wherein the program instructions further direct the processing system to when a value of the lower byte of any of the non Latin characters falls within a lower half of a range of possible values for the lower byte shift a value of the lower byte of any Latin characters into an upper half of the range of possible values for the lower byte.

The apparatus of Examples 15 18 wherein the program instructions further direct the processing system to shift the encoding byte to reflect the shift of the value of the lower byte of the Latin characters into the upper half of the range of the possible values for the lower byte.

The apparatus of Examples 15 19 further comprising the processing system configured to execute the program instructions wherein the lower byte retained in the resource file for each of the set of characters comprises an initial quantity of bits and wherein the program instructions further direct the processing system to further reduce the size of the resource file by for any of the ordered set of resource strings that qualify for bit level compression at least define a dictionary specific to the resource string to include one or more characters of the set of characters in the resource string and for each of the set of characters in the resource string encode the character in the resource file in a subsequent quantity of bits that is less than the initial quantity of bits and that represents a position of the character in either the dictionary or in a range of characters not included in the dictionary.

The functional block diagrams operational scenarios and sequences and flow diagrams provided in the Figures are representative of exemplary systems environments and methodologies for performing novel aspects of the disclosure. While for purposes of simplicity of explanation methods included herein may be in the form of a functional diagram operational scenario or sequence or flow diagram and may be described as a series of acts it is to be understood and appreciated that the methods are not limited by the order of acts as some acts may in accordance therewith occur in a different order and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a method could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all acts illustrated in a methodology may be required for a novel implementation.

The descriptions and figures included herein depict specific implementations to teach those skilled in the art how to make and use the best option. For the purpose of teaching inventive principles some conventional aspects have been simplified or omitted. Those skilled in the art will appreciate variations from these implementations that fall within the scope of the invention. Those skilled in the art will also appreciate that the features described above can be combined in various ways to form multiple implementations. As a result the invention is not limited to the specific implementations described above but only by the claims and their equivalents.

