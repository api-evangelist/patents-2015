---

title: Media compression for tunneled real-time communications
abstract: A system performs compression of real-time communications (“RTC”). The system establishes a tunnel with a user equipment (“UE”) by a tunneling server, and communicates encapsulated media with the UE over the tunnel. Subsequently, the system receives a request from a tunneling client at the UE to enable compression for the encapsulated media, determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server, and sends a response back to the UE to indicate that compression is enabled for the encapsulated media. The system then communicates compressed encapsulated media with the UE over the tunnel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09332049&OS=09332049&RS=09332049
owner: Oracle International Corporation
number: 09332049
owner_city: Redwood Shores
owner_country: US
publication_date: 20150428
---
One embodiment is directed generally to a communications network and in particular to delivering real time traffic over a communications network.

Many enterprise environments have replaced their Public Switched Telephone Network PSTN telephony services with telephony services that use the Internet Protocol IP commonly known as Voice over IP VoIP or IP Telephony. Since IP Telephony uses an IP network as its backbone it can provide advanced features such as video conferencing call recording and call forwarding.

Recently the growing base of mobile data subscribers the wide availability of Internet access and the high availability of bandwidth in both fixed and mobile networks has resulted in the popularity of advanced services accessed via the Internet known as Over the Top OTT services . This has caused competitive service providers to offer OTT services and hence face corresponding challenges as they implement these new services.

Embodiments provide a system for performing compression of real time communications RTC . The system establishes a tunnel with a user equipment UE by a tunneling server and communicates encapsulated media with the UE over the tunnel. Subsequently the system receives a request from a tunneling client at the UE to enable compression for the encapsulated media determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server and sends a response back to the UE to indicate that compression is enabled for the encapsulated media. The system then communicates compressed encapsulated media with the UE over the tunnel.

One embodiment provides media compression services for real time communications RTC in a network environment. In one embodiment a tunneling client inspects packet formats of encapsulated traffic within a tunnel to determine whether the encapsulated traffic includes data or real time media. If real time media traffic is detected in the encapsulated traffic the tunneling client transcodes the packets such that the encapsulated media traffic occupies a smaller bandwidth. Accordingly embodiments use the tunnel bandwidth more efficiently and thereby improve the tunnel throughput.

In performing RTC UE communicates signaling and media traffic with respective servers in service provider network . Signaling traffic may be communicated according to an application layer protocol such as the Session Initiation Protocol SIP . SIP is configured to be independent of the underlying transport layer. Accordingly SIP can run on different transport protocols such as the Transmission Control Protocol TCP as described in for example Internet Engineering Task Force IETF request for comments RFC 793 and RFC 675 the User Datagram Protocol UDP as described in for example IETF RFC 768 etc.

Network further includes a tunneling server that together with a tunneling client within UE provides functionality for establishing and managing tunnels for performing RTC according to the Tunneled Services Control Function TSCF standard as described in for example 3rd generation partnership program 3GPP technical report TR 33.830 V0.5.0 the disclosure of which is hereby incorporated by reference in its entirety. In general using a tunnel for communications refers to using a delivery protocol to encapsulate a different payload protocol.

The TSCF standard provides client side and server side network elements for establishing managed tunnels for performing RTC e.g. tunneling client and tunneling server in . It also provides two types of outer layer tunneling transports a stream based outer layer tunneling transport via TCP or Transport Layer Security TLS and a datagram based outer layer tunneling transport via UDP or Datagram Transport Layer Security DTLS .

TLS is a cryptographic protocol as provided in for example IETF RFC 2246 RFC 4346 RFC 5246 and or RFC 6176. DTLS is a protocol that provides communications privacy for datagram protocols. TCP and TLS provide reliable ordered and error checked delivery of the inner layer traffic but introduce undesirable latency that is detrimental to RTC applications over a communications network that experiences impairments. On the other hand UDP and DTLS do not guarantee reliable delivery thus minimizing latency and being desirable for RTC.

In some embodiments IP network may include security devices e.g. firewalls proxies etc. that allow traffic of only a certain transport protocol e.g. only TCP only UDP etc. . Accordingly tunneling client and tunneling server may establish and manage a corresponding TSCF tunnel so that UE may use the TSCF tunnel to traverse such security devices and connect to tunneling server to reach servers in service provider network .

The TSCF standard further provides control messages for exchanging configuration information between tunneling client and tunneling server . According to the TSCF standard control messages are of a request response type and a control message response for a request includes either a corresponding reply or an error code indicating why the request cannot be honored by the receiving end. TSCF control messages use a Type Length Value TLV encoding. TLV is a variable length concatenation of a unique type and a corresponding value. The unique type is represented by an integer while the value is the actual value identified by the type.

Each TSCF control message includes a control message header at the beginning including a CM Version field identifying the version of the header and indicating the outer transport protocol of a TSCF tunnel a CM Indication field identifying whether the message is a control message or not a Reserved field reserved for future use a CM Type field identifying the type of the control message e.g. whether it is a request or a response the corresponding functionality etc. a TLV Count field indicating the number of TLVs that follow or are appended to the header in the corresponding control message a Tunnel Session ID TSID field including a tunnel session identifier ID assigned by tunneling server to uniquely identify TSCF tunnel and a Sequence field that is incremented per message as described in for example 3GPP TR 33.830 V0.5.0.

In one embodiment in order to establish TSCF tunnel tunneling client sends a configuration request message to tunneling server to obtain configuration information for TSCF tunnel . In a configuration request message TSID header field bits are set to 1 i.e. FFFF . . . . In response tunneling server assigns a TSID to a TSCF tunnel and sends a configuration response message back to tunneling client . The configuration response message includes the TSID assigned by tunneling server to TSCF tunnel . The subsequent messages between tunneling client and tunneling server include this assigned TSID in their headers.

In one embodiment if a control message is communicated between tunneling client and tunneling server and does not include the expected TSID the control message is dropped and the corresponding TSCF tunnel is terminated. Alternatively in one embodiment tunneling client may send a configuration release request message to tunneling server to terminate a TSCF tunnel. In response to such a configuration release request message tunneling server sends a configuration release response message to tunneling client . At this time the TSCF tunnel is terminated.

In one embodiment UE executes an application that may be a SIP based RTC application relying on a library such as the software development kit SDK provided by the tunneled session management solution from Oracle Corp.

System includes a bus or other communication mechanism for communicating information and a processor coupled to bus for processing information. Processor may be any type of general or specific purpose processor. System further includes a memory for storing information and instructions to be executed by processor . Memory can be comprised of any combination of random access memory RAM read only memory ROM static storage such as a magnetic or optical disk or any other type of computer readable medium. System further includes a communication device such as a network interface card to provide access to a network. Therefore a user may interface with system directly or remotely through a network or any other method.

Computer readable medium may be any available media that can be accessed by processor and includes both volatile and nonvolatile media removable and non removable media and communication media. Communication media may include computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media.

Processor may further be coupled via bus to a display such as a Liquid Crystal Display LCD . A keyboard and a cursor control device such as a computer mouse may further be coupled to bus to enable a user to interface with system on an as needed basis.

In one embodiment memory stores software modules that provide functionality when executed by processor . The modules include an operating system that provides operating system functionality for system . The modules further include a tunneling module for providing tunneling and all other functionality disclosed herein. In one example embodiment tunneling module may implement tunneling server of in conjunction with one or more remaining elements of . System can be part of a larger system such as added functionality to the Acme Packet 4500 session border controller from Oracle Corp. Therefore system can include one or more additional functional modules to include the additional functionality. A database is coupled to bus to provide centralized storage for tunneling module and additional functional modules .

In one embodiment tunneling module and or additional functional modules may include an establishing module that establishes a tunnel with a UE by a tunneling server a communicating module that communicates encapsulated media with the UE over the tunnel a receiving module that receives a request from a tunneling client at the UE to enable compression for the encapsulated media a determining module that determines a codec for transcoding the encapsulated media at the tunneling client and at the tunneling server a sending module that sends a response back to the UE to indicate that compression is enabled for the encapsulated media and a communicating module that communicates compressed encapsulated media with the UE over the tunnel as will be described herein with reference to .

Referring again to with known systems tunneling client and tunneling server may establish a TSCF tunnel that encapsulates different types of traffic ranging from pure data to real time media. In general data is sensitive to integrity while real time media is sensitive to latency. In some known systems encapsulated media is typically communicated according to the real time transport protocol RTP as provided for example in IETF RFC 3550 .

In some known systems encapsulated media that is packetized according to RTP includes a compressed payload encoded by a codec within application . A codec performs compression and or decompression of a data stream or signal according to a bitrate the number of bits conveyed or processed per unit of time .

In some known systems the compressed payload of packetized encapsulated media may be encoded by a high bitrate codec such as G.711 as provided for example according to the International Telecommunication Union ITU Telecommunication Standardization Sector ITU T standard.

One disadvantage with these known systems is that media streams that are compressed with a high bitrate codec occupy excessive bandwidth. For example with the same bandwidth that is used to transmit a single media stream transcoded using a high bitrate codec such as G.711 it is possible to transmit between 8 and 12 streams of speech transcoded using a lower bitrate codec such as G.729 as provided for example according to the ITU T standard. Transcoding is the direct analog to analog or digital to digital conversion of one encoding to another.

One known solution for more efficient bandwidth consumption is that before compressing speech and media in general the endpoints may negotiate codecs at the application layer via a signaling protocol. However notwithstanding the aforementioned negotiation high bitrate codecs are typically selected and used due to client and or network limitations. Further the resulting high bitrate transcoded media is encapsulated within a tunnel such as TSCF tunnel the tunneling architecture does not affect the flow of traffic and transmits it transparently at the same high bitrate therefore resulting in an unnecessarily high bandwidth consumption.

In contrast to the known solutions embodiments of the present invention provide an encapsulation configuration that automatically detects media traffic and transcodes it using a lower bitrate codec as it traverses TSCF tunnel . In some embodiments the detection and compression transcoding of embedded media streams within TSCF tunnel is performed independently of the application layer i.e. independently of application .

One embodiment provides media compression functionality by implementing a first transcoding module at tunneling client and a second transcoding module at tunneling server . In one embodiment first transcoding module at tunneling client inspects encapsulated traffic in TSCF tunnel to differentiate between data and real time media based on their different traffic patterns and performs compression on demand to improve the throughput of TSCF tunnel . In one embodiment first transcoding module transparently initiates media compression whenever real time media is detected in encapsulated traffic in TSCF tunnel .

In one embodiment first transcoding module notifies application whenever real time media is detected in encapsulated traffic in TSCF tunnel . In one embodiment when first transcoding module detects a transition from real time media to data mode or vice versa it notifies application by indicating the inner socket affected by such transition. A network socket is an endpoint of an inter process communication flow across a computer network according to a communications protocol. A network socket may be a datagram socket a connectionless network socket or a stream socket a connection oriented and sequenced socket . In general for regular communications a user can create a datagram or stream socket that uses the network interface of the system in which the application runs. In a TSCF environment however sockets use a tunnel for transport instead of a network interface. To differentiate these sockets from regular sockets they are referred to as inner sockets since they only exist inside a tunnel. That is an inner socket only exists in association with a tunnel and socket traffic gets transported by the tunnel.

In one embodiment first transcoding module determine whether the traffic pattern in TSCF tunnel is indicative of real time media or not by performing inner datagram packet analysis. When first transcoding module detects a transition to real time media in TSCF tunnel it tries to negotiate media compression with second transcoding module at tunneling server . Upon a successful negotiation media compression is enabled at first transcoding module and second transcoding module . Thereafter if first transcoding module detects a transition to data mode in TSCF tunnel it tears down i.e. terminates the media compression functionality that was negotiated with second transcoding module .

In one embodiment when media compression is negotiated between first transcoding module and second transcoding module they both transcode high bitrate media into low bitrate media before encapsulation and transcode low bitrate media into high bitrate media after de encapsulation. In one embodiment based on load requirements of tunneling server compression functionality may be asymmetric for example affecting only the traffic from tunneling client to tunneling server and not the other way around.

For example since transcoding introduces computational complexities that require specific signal processing resources if those resources are limited at tunneling server tunneling server may be able to perform decoding but not encoding hence not allowing the implementation of transcoding functionality that is symmetric across tunneling client and tunneling server . The resources that are limited at tunneling server include for example a specific number of concurrent channels required for performing encoding and a specific number of concurrent channels required for performing decoding. In one embodiment performing decoding may require much lighter resources than performing encoding therefore the limitation of resources at tunneling server typically relates to performing encoding.

In one embodiment for example G.711 encoding and decoding to from raw speech is according to a non linear conversion formula between 16 bit samples and 8 bit samples. However G.729 encoding of raw speech is more complex and requires extensive signal processing resources while G.729 decoding of compressed speech is simpler than its encoding and does not require as much resources. Accordingly if tunneling client converts traffic from G.711 to raw speech and from raw speech to G.729 before transmitting to tunneling server tunneling server may be serving multiple e.g. thousands of simultaneous clients and thus may not have enough resources to convert raw speech to G.729 before transmitting to tunneling client in the opposite direction. Therefore the transmissions between tunneling client and tunneling server may not be symmetrical and the only conversion to low bitrate may be performed for traffic sent from tunneling client to tunneling server resulting in asymmetric transcoding.

One embodiment provides TSCF SDKs that support application programming interface API notification that provides functionality for first transcoding module to notify application of the detection of a transition from real time media to data mode or vice versa in TSCF tunnel .

In RTP header configuration fields V SSRC and PT are fixed for every media stream and field SN is a 32 bit number that increases with every packet being transmitted. Accordingly in one embodiment first transcoding module may detect a media stream in TSCF tunnel when a sequence of consecutive frames have headers with the same V SSRC and PT fields and each header in the sequence has an SN field that is larger than the SN field of the previous header by one. In one embodiment first transcoding module may examine a certain number of consecutive frames e.g. 5 frames before indicating a media stream or otherwise data in TSCF tunnel . Similarly when a sequence of consecutive frames have headers that do not match the format expected of consecutive RTP headers first transcoding module may detect pure data in TSCF tunnel .

In one embodiment first transcoding module detects a traffic pattern in TSCF tunnel e.g. a media stream or otherwise pure data according to the following example functionality 

In the above functionality COUNT THRESHOLD is a pre configured number typically 5 . Once first transcoding module detects media or data in TSCF tunnel it notifies both application and second transcoding module at tunneling server .

At tunneling client sends a configuration request message to tunneling server to establish TSCF tunnel and at tunneling server responds to the configuration request message of tunneling client with a configuration response message. Configuration request and response messages allow for tunneling client to obtain configuration information for TSCF tunnel from tunneling server as described in for example 3GPP TR 33.830 V0.5.0. Accordingly TSCF tunnel is compliant with TSCF tunnel management e.g. tunnel initialization maintenance termination etc. as defined by e.g. 3GPP TR 33.830 V0.5.0 and TSCF tunnel transport protocols are supported for the negotiation of TSCF tunnel between tunneling client and tunneling server . In one embodiment from the RTC application perspective application at UE creates TSCF tunnel by executing a tsc ctrl new tunnel API and the configuration request message is sent to tunneling server in response to the execution of this API.

Upon completing the exchange of configuration request response messages tunneling client and tunneling server may use TSCF tunnel for performing RTC and communicating signaling traffic and media traffic. For example tunneling client and tunneling server may use TSCF tunnel to perform signaling negotiation at and to communicate high bitrate media at . In one embodiment when inner signaling and media sockets are needed to place a call e.g. for communicating SIP call control traffic or RTP media traffic application creates these sockets on TSCF tunnel by executing a tsc socket API. A socket is created by determining a socket type e.g. datagram vs. stream and a tunnel on which the socket should be created. In one embodiment when a socket is created application binds the socket by executing a tsc bind API. The bind function assigns a specific transport port e.g. TCP or UDP to the socket. This port is later used as a source port of all traffic generated by the socket. In one embodiment if an inner socket is created in TSCF tunnel there is a binding at tunneling server that links the internal IP address of TSCF tunnel to that socket.

At first transcoding module at tunneling client detects that high bitrate RTP media is flowing through TSCF tunnel and subsequently at first transcoding module sends a TSCF service request message to tunneling server to enable compression functionality.

At second transcoding module at tunneling server receives this service request message and if tunneling server can comply with the compression request answers back to first transcoding module with a TSCF service response message to confirm that compression functionality is enabled. In one embodiment tunneling server may not be able to comply with the compression request if for example it does not have transcoding resources or if the requested codec is not supported implemented at tunneling server .

Upon enabling compression functionality at tunneling client and tunneling server start communicating low bitrate compressed media over RTP through TSCF tunnel . In one embodiment since the input to a codec is raw speech e.g. with 16 bits per sample at an 8 KHz sampling rate when first transcoding module receives high bitrate payload from application it first converts it to raw speech and then compresses it into low bitrate payload to be transmitted as encapsulated media to second transcoding module . When second transcoding module receives such low bitrate payload it again converts it to raw speech and then compresses it into high bitrate payload to be transmitted to the untunneled side of the communication e.g. servers in service provider network . Similarly when second transcoding module receives high bitrate payload from the untunneled side of the communication it first converts it to raw speech and then compresses it into low bitrate payload to be transmitted as encapsulated media to first transcoding module . When first transcoding module receives such low bitrate payload it again converts it to raw speech and then compresses it into high bitrate payload to be provided to application .

At first transcoding module at tunneling client detects either an end of stream indicating media transmission has ended or detects data in TSCF tunnel and subsequently at first transcoding module issues a TSCF service request message to tunneling server to disable compression functionality.

At second transcoding module at tunneling server responds back to first transcoding module with a corresponding TSCF service response message indicating that compression functionality has been disabled.

One embodiment provides compression functionality by implementing a TSCF client service request message of type Service Type with two TLV values indicating compression enablement and disablement respectively. Further a Payload Type TLV is provided to indicate high bitrate and low bitrate codecs corresponding to the compression functionality and a Connection Info TLV is provided to indicate source and destination transport and network endpoints. Table 1 below provides example TSCF TLVs for providing compression services according to some embodiments.

In Table 1 the Payload Type TLV may indicate a high bitrate codec such as G.711 pulse code modulation PCM law PCMU and G.711 PCM A law PCMA or a low bitrate codec such as G.723 G.729 and adaptive multi rate AMR narrow band AMR NB . Typically compression functionality involves transcoding a high bitrate codec e.g. PCMU PCMA etc. into a low bitrate codec e.g. G.723 G.729 AMR NB etc. . However in some embodiments compression functionality may be provided to transcode between any two codecs that have the same or different bitrates.

In one embodiment once compression functionality has been enabled for a given stream of media in TSCF tunnel in order for tunneling client or tunneling server to process a given media packet a respective one of first transcoding module and second transcoding module transcodes the frame from a high bitrate payload into a low bitrate payload and changes the PT field in the RTP header of the frame to reflect the new codec corresponding to the low bitrate payload. In one embodiment in order to provide compression functionality first transcoding module and second transcoding module select a low bitrate codec based on codec availability at both tunneling client and tunneling server .

One embodiment provides a configuration object tscf interface that includes a parameter assigned services with keywords media detection and media compression that enable detection and compression of media respectively. Table 2 below provides an example TSCF configuration object for providing compression services according to one embodiment.

The following functionality provides an example address pool configuration for providing compression services according to one embodiment 

The following is an example XML functionality for providing compression services according to one embodiment 

Some embodiments do not require SDK API changes at application since compression functionality is triggered dynamically by tunneling client based on TSCF configuration parameters. Accordingly compression functionality may be provided transparently to application . However some embodiments support application notification whenever first transcoding module detects a transition from real time media to data mode or vice versa in TSCF tunnel .

The following is an example functionality for enabling notification and for providing a corresponding callback 

In the above functionality the fourth NULL parameter in tsc notification enable is an opaque private data pointer that can be recovered in the tsc notification data structure upon callback.

At first transcoding module at tunneling client inspects the traffic pattern in TSCF tunnel and determines that encapsulated media is being communicated over TSCF tunnel and sends a TSCF service request to tunneling server to enable compression for the encapsulated media in TSCF tunnel . In one embodiment first transcoding module determines that the traffic pattern of TSCF tunnel corresponds to the encapsulated media by identifying a sequence of consecutive headers conforming to RTP. In one embodiment upon determining that the traffic pattern of TSCF tunnel corresponds to the encapsulated media first transcoding module provides a corresponding notification to application at UE indicating an inner socket of the encapsulated media.

At first transcoding module and second transcoding module determine a codec for transcoding the encapsulated media into compressed encapsulated media at tunneling client and at tunneling server . In one embodiment first transcoding module and second transcoding module determine the codec based on available codecs at tunneling client and at tunneling server .

At second transcoding module at tunneling server sends a TSCF service response back to first transcoding module to indicate that compression is enabled for the encapsulated media in TSCF tunnel.

At first transcoding module and second transcoding module communicate compressed encapsulated media over TSCF tunnel . In one embodiment the encapsulated media includes high bitrate media and upon enabling compression first transcoding module and second transcoding module transcode the high bitrate media into low bitrate media and communicate the low bitrate media through TSCF tunnel . In one embodiment if first transcoding module subsequently determines that the traffic pattern of TSCF tunnel has changed to encapsulated data it sends a TSCF service request message to second transcoding module to disable compression and second transcoding module responds back by sending a TSCF service response message indicating that compression is disabled.

As disclosed embodiments allow for a TSCF tunneling configuration that provides media detection and compression functionality. Embodiments allow a tunneling client to detect media in a TSCF tunnel and initiate compression of encapsulated traffic. In one embodiment upon automatically detecting encapsulated media the high bitrate media payload is transcoded into a more efficient low bitrate payload. Accordingly embodiments give the end user the possibility of improving tunnel throughput via a more efficient use of bandwidth.

Several embodiments are specifically illustrated and or described herein. However it will be appreciated that modifications and variations of the disclosed embodiments are covered by the above teachings and within the purview of the appended claims without departing from the spirit and intended scope of the invention.

