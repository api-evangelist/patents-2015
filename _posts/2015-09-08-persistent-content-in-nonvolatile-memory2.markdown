---

title: Persistent content in nonvolatile memory
abstract: Applications may request persistent storage in nonvolatile memory. The persistent storage is maintained across power events and application instantiations. Persistent storage may be maintained by systems with or without memory management units.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563554&OS=09563554&RS=09563554
owner: Micron Technology, Inc.
number: 09563554
owner_city: Boise
owner_country: US
publication_date: 20150908
---
This application is a continuation application of U.S. application Ser. No. 12 638 950 filed Dec. 15 2015 issued as U.S. Pat. No. 9 128 762 on Sep. 8 2015 the application of which is hereby incorporated by reference in its entirety for any purpose.

The present invention relates generally to data storage in memory devices and more specifically to data storage in nonvolatile memory.

Many electronic devices store data in both volatile memory and nonvolatile memory. Volatile memory is memory that loses stored information when power is lost while nonvolatile memory is memory that retains information even when power is lost. Volatile memory such as random access memory RAM is generally faster than nonvolatile memory such as FLASH memory. As small inexpensive electronic devices e.g. cell phones smartphones media players become more feature packed the desire for increased memory resources has also grown.

Embodiments of the invention provide a method and system for utilizing nonvolatile memory for persistent data storage. Application programs can request that data objects be made persistent by storing them in nonvolatile memory. Some embodiments include virtual memory and other embodiments do not include virtual memory.

In some embodiments system has a wireless interface . Wireless interface is coupled to antenna to allow system to communicate with other over the air communication devices. As such system may operate as a cellular device or a device that operates in wireless networks such as for example Wireless Local Area Networks WLANs WiMax and Mobile WiMax based systems Wideband Code Division Multiple Access WCDMA and Global System for Mobile Communications GSM networks any of which may or may not operate in accordance with one or more standards. The various embodiments of the invention are not limited to operate in the above network types this is simply a list of examples. It should be understood that the scope of the present invention is not limited by the types of the number of or the frequency of the communication protocols that may be used by system . Embodiments are not however limited to wireless communication embodiments. Other non wireless applications can use the various embodiments of the invention.

System includes processor coupled to interface . Interface provides communication between processor and the various other devices coupled to interface . For example processor may communicate with memory devices in system memory as well as disk . Interface can include serial and or parallel buses to share information along with control signal lines to be used to provide handshaking between processor and the various other devices coupled to interface .

System memory may include one or more different types of memory and may include both volatile e.g. random access memory RAM and nonvolatile memory e.g. read only memory ROM phase change memory PCM NOR FLASH memory NAND single level cell SLC memory and NAND multi level cell MLC memory . These memory types are listed as examples and this list is not meant to be exclusive. For example some embodiments may include Ovonic Unified Memory OUM Chalcogenide Random Access Memory C RAM Magnetic Random Access Memory MRAM Ferroelectric Random Access Memory FRAM Static Random Access Memory SRAM Dynamic Random Access Memory DRAM or any other type of storage device.

Processor includes at least one core and each core may include memory. For example first core may include volatile or nonvolatile memory such as PCM FLASH or RAM. Each core may include any combination of different types of memory without departing from the scope of the present invention. Processor may execute instructions from any suitable memory within system . For example any of the memory devices within system memory may be considered a computer readable medium that has instructions stored that when accessed cause processor to perform embodiments of the invention.

In some embodiments processor also includes an integral memory management unit MMU . In some embodiments MMU is a separate device. Memory management unit is a hardware device or circuit that is responsible for handling accesses to memory requested by processor . When present memory management unit supports virtual memory and paging by translating virtual addresses into physical addresses.

Nonvolatile memory present in system may provide persistent storage for applications. For example NOR FLASH memory or PCM memory may be used to store data that remains persistent between instantiations of a software application. In various embodiments of the present invention an application can request persistent storage for data that it wishes to remain persistent. For example a web browser application may request persistent storage for state data such as viewing history. Once an application requests persistent storage any data may be stored in the persistent storage.

In some embodiments persistent storage in nonvolatile memory is available to applications each time they start up. For example persistent storage may be available to an application across instantiations of the applications as well as across power events.

Nonvolatile memory includes persistent data storage for any number of applications shown as n in . A first application Application has persistent data stored at a second application Application has persistent data stored at and a third application Application has persistent data storage at . The n.sup.th application has persistent data storage at . Nonvolatile memory also includes a data structure describing the persistent memory state . For each application with persistent data storage persistent memory state includes a record that includes at least three fields a key a size and a pointer. For example the persistent memory state record for application includes App key App size and App ptr. App key is a unique identifier that allows Application to be associated with the persistent storage at . App size is the size of the persistent storage at . App ptr is a pointer that points to the persistent storage at .

In operation an application can request persistent storage. When persistent storage is first requested a persistent storage block e.g. is allocated and a record is added to persistent memory state to associate the persistent memory block with the requesting application. If the application already has persistent storage then the appropriate record in persistent memory state is found and the application can access the persistent storage through the pointer.

In some embodiments an application programming interface API is provided to allow applications to request persistent data storage. For example a nonvolatile memory allocation routine may be provided that accepts a key and a size and returns a pointer. This nonvolatile memory allocation routine may take the following form ptr nvmalloc size key 

where the calling application provides the key and the size and the API returns the pointer. Each application has a unique key that it uses when requesting persistent storage. The application passes the unique key and the desired size of the persistent storage to the nvmalloc routine and the nvmalloc routine returns a pointer to the persistent storage. If the calling application does not yet have a persistent storage area then one is allocated and a pointer to the newly allocated persistent storage area is returned. If the calling application does have a persistent storage area e.g. when an application is being run subsequent to a previous call to nvmalloc then the existence of the persistent storage is verified and the pointer is returned.

In various embodiments of the invention an application can choose to store some data in persistent storage and some data elsewhere. In some embodiments a call to nvmalloc forces the system to use nonvolatile memory whereas a call to a different memory allocation routine e.g. malloc allows the system to determine where to provide storage. Providing this level of control to applications allows the applications to store and access data with the knowledge that this data will be accessible from one instantiation to another and also across power events.

Although the return value ptr is described above as a pointer this is not a limitation of the present invention. Any type of reference may be returned or updated to provide access to allocated persistent storage. For example an object of a different type may be returned. Also for example in some embodiments an application may pass a local global or static variable along with the size request and the variable may be updated with a reference to the allocated persistent storage.

Method is shown being invoked at as ptr nvmalloc size key . It should be understood that the term nvmalloc is provided as a convenient label for the purpose of explanation and that embodiments of method may be referred to using any suitable label or name. Likewise it should be understood that the passed parameters are not necessarily limited to a size and a key. Any number or type of parameters may be passed by an application requesting persistent memory. Further method is shown returning a pointer to the persistent memory although this is not a limitation of the present invention. Any suitable mechanism for referencing the persistent memory may be utilized. For example the calling application may receive a persistent object from method to point to the persistent memory.

At method examines the key provided by the calling application to determine if the key is present. This corresponds to determining if one of the key entries in persistent memory state includes the key. If the key is not present then the calling application does not currently have persistent memory allocated. In this case method continues at to determine if enough nonvolatile memory is available to satisfy the size request. If not then method ends at and the persistent memory request fails. In some embodiments this may result in the nvmalloc routine returning a null pointer or otherwise informing the calling application of the failure.

If method determines that memory is available at then a persistent memory block is reserved and a key entry is added at . This corresponds to a nonvolatile block of memory e.g. being reserved and a key entry being added to persistent memory state . The key entry includes the unique key the size of the memory block and a pointer to the memory block. At the pointer to the memory block is returned to the calling application.

If at method determines that the key is already present in a key entry in persistent memory state then the sizes are compared at . The size parameter passed from the calling routine is compared to the size stored in the key entry. If they are different then there is a mismatch in size between the currently allocated persistent memory and the size expected by the calling application. The response is to clear the existing key entry and release the corresponding persistent memory block at . The method then continues at to allocate a new persistent memory block as described in the previous paragraphs.

The persistent memory allocation described above with reference to may exist in systems with or without virtual memory. For example in some embodiments a system that includes a memory management unit may implement persistent memory in accordance with . Further in other embodiments a system that does not include a memory management unit may implement persistent memory in accordance with .

In contrast the persistent memory allocation described below with reference to exists in systems that are able to manage memory in the background. For example a system that includes a memory management unit may implement persistent memory in accordance with .

Persistent memory state is a data structure that includes a record for each allocated persistent memory block. Persistent memory state may maintain records for any number of applications shown as n in . For each application with persistent data storage persistent memory state includes a record that includes at least four fields a key a size a persistence qualifier and a pointer. For example the persistent memory state record for application includes App key App size App pqual and App ptr. App key is a unique identifier that allows Application to be associated with its allocated persistent storage. App size is the size of the persistent storage. App pqual is a persistence qualifier that provides guidance to the system on how to manage the persistent storage. And App ptr is a pointer that points to the persistent storage.

In operation an application can request persistent storage with a particular persistence qualifier. When persistent storage is first requested a persistent storage block is allocated and a record is added to persistent memory state to associate the persistent memory block with the requesting application. If the application already has persistent storage then the appropriate record in persistent memory state is found and the application can access the persistent storage through the pointer.

In some embodiments an application programming interface API is provided to allow applications to request persistent data storage with a persistence qualifier. For example a nonvolatile memory allocation routine may be provided that accepts a key a size and a persistence qualifier and returns a pointer. This nonvolatile memory allocation routine may take the following form ptr nvmalloc size key persistence qualifier 

where the calling application provides the key the size and the persistence qualifier and the API returns the pointer. Each application has a unique key that it uses when requesting persistent storage. The application passes the unique key and the desired size of the persistent storage along with the persistence qualifier to the nvmalloc routine and the nvmalloc routine returns a pointer to the persistent storage. If the calling application does not yet have a persistent storage area then one is allocated and a pointer to the newly allocated persistent storage area is returned. If the calling application does have a persistent storage area e.g. when an application is being run subsequent to a previous call to nvmalloc then the existence of the persistent storage is verified and the pointer is returned.

The persistence qualifier is used to specify the type or degree of persistence that is desired by the calling application. These persistence qualifiers are interpreted by systems with memory management units when determining how to manage persistent memory. For example and not by way of limitation valid persistence qualifiers may include DIRECTIO WRITEBACK WRITETHROUGH and ATOMIC.

The DIRECTIO persistence qualifier directs the system to read and write directly to the persistent storage in nonvolatile memory. Neither read nor write caches are maintained in volatile memory.

The WRITEBACK persistence qualifier directs the system to write to volatile memory and then migrate the data to nonvolatile memory as time permits. Both read and write caches may be maintained in volatile memory.

The WRITETHROUGH persistence qualifier directs the system to write to both volatile and nonvolatile memory. Read caches may be maintained but write caches are not because writes are always made to the nonvolatile memory. Examples of persistent memory blocks with different persistence qualifiers are described with reference to later figures.

The ATOMIC persistence qualifier directs the system to write to volatile memory until a command is given to flush it down such as from a special API such as sync key . When the system receives such a command it updates the nonvolatile memory object referenced by key as an atomic unit. If the data fails to write to the nonvolatile memory in its entirety the system will revert the object to its state before the write started.

Method is shown beginning at with a call to an nvmalloc routine. This nvmalloc routine is similar to the nvmalloc routine described above with reference to with the exception that a persistence qualifier is passed from the calling program.

At method examines the key provided by the calling application to determine if the key is present. This corresponds to determining if one of the key entries in persistent memory state includes the key. If the key is not present then the calling application does not currently have persistent memory allocated. In this case method continues at to determine if enough nonvolatile memory is available to satisfy the size request. If not then method ends at and the persistent memory request fails. In some embodiments this may result in the nvmalloc routine returning a null pointer or otherwise informing the calling application of the failure.

If method determines that memory is available at then a persistent memory block is reserved and a key entry is added at . This corresponds to a nonvolatile block of memory being reserved and a key entry being added to persistent memory state . The key entry includes the unique key the size of the memory block the persistence qualifier and a pointer to the memory block. At the pointer to the memory block is returned to the calling application.

If at method determines that the key is already present in a key entry in persistent memory state then the sizes are compared at . The size parameter passed from the calling routine is compared to the size stored in the key entry. If they are different then there is a mismatch in size between the currently allocated persistent memory and the size expected by the calling application. The response is to clear the existing key entry and release the corresponding persistent memory block at . The method then continues at to allocate a new persistent memory block as described in the previous paragraphs.

Application APP has persistent storage allocated as WRITEBACK WB application APP has persistent storage allocated as DIRECTIO DIO and application APP has persistent storage allocated as WRITETHROUGH WT . This corresponds to a system with a persistent memory state in which the persistence qualifiers for the first three applications are set to WRITEBACK DIRECTIO and WRITETHROUGH respectively.

The right side of shows how the various items are stored in physical memory. Kernel is typically in volatile memory e.g. RAM as shown although this is not a limitation of the present invention. Persistent memory state is stored in nonvolatile memory . Because the persistent memory state is stored in nonvolatile memory the state is persistent across power events and application instantiations.

The persistent storage blocks requested by and allocated to the applications are stored in one or both of the volatile and or nonvolatile memory as follows. Application requested persistent storage with a persistence qualifier of WRITEBACK. As a result writes are performed to volatile memory and the memory manager copies it from volatile memory to nonvolatile memory as time permits. Accordingly persistent storage is shown in both volatile memory and nonvolatile memory . Application requested persistent storage with a persistence qualifier of DIRECTIO. As a result writes are performed directly to nonvolatile memory . Accordingly persistent storage is shown only in nonvolatile memory . Application requested persistent storage with a persistence qualifier of WRITETHROUGH. As a result writes are always performed to both volatile memory and nonvolatile memory . Accordingly persistent storage is shown in both volatile memory and nonvolatile memory .

Page tables and are shown in both volatile memory and nonvolatile memory although this is not a limitation of the present invention. For example page tables may be in only of volatile memory or nonvolatile memory .

In some embodiments page tables are maintained in volatile memory while applications are running and are migrated to nonvolatile memory when the application is frozen. For example an application on a mobile phone may go dormant through non use. The application can be shut down so that it requires a complete restart the next time it is used or the application can be frozen so that it can be quickly revived when next used.

Method shows that the same application can be revived or unfrozen. At the page tables are migrated back to volatile memory and at the application is run from volatile memory while the persistent storage is left in nonvolatile memory. This is possible because the page tables were updated to reference the persistent storage in nonvolatile memory before they were migrated to nonvolatile memory themselves.

In some embodiments page tables are not migrated back to volatile memory. For example at the application may be run in volatile memory while the both the page tables and the persistent storage is left in nonvolatile memory.

Unless specifically stated otherwise as apparent from the preceding discussions it is appreciated that throughout the specification discussions utilizing terms such as monitoring storing detecting using identifying marking receiving loading reconfiguring formatting determining or the like refer to the action and or processes of a computer or computing system or similar electronic computing device that manipulate and or transform data represented as physical such as electronic quantities within the computing system s registers and or memories into other data similarly represented as physical quantities within the computing system s memories registers or other such information storage transmission or display devices.

Embodiments of the invention may include apparatuses for performing the operations herein. An apparatus may be specially constructed for the desired purposes or it may comprise a general purpose computing device selectively activated or reconfigured by a program stored in the device. Such a program may be stored on a storage medium such as but not limited to any type of disk including floppy disks optical disks compact disc read only memories CD ROMs magnetic optical disks read only memories ROMs random access memories RAMs electrically programmable read only memories EPROMs electrically erasable and programmable read only memories EEPROMs magnetic or optical cards or any other type of media suitable for storing electronic instructions and capable of being coupled to a system bus for a computing device.

Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the desired method. The desired structure for a variety of these systems appears in the description above. In addition embodiments of the invention are not described with reference to any particular programming language. A variety of programming languages may be used to implement the teachings of the invention as described herein. In addition it should be understood that operations capabilities and features described herein may be implemented with any combination of hardware discrete or integrated circuits and software.

Although the present invention has been described in conjunction with certain embodiments it is to be understood that modifications and variations may be resorted to without departing from the scope of the invention as those skilled in the art readily understand. Such modifications and variations are considered to be within the scope of the invention and the appended claims.

