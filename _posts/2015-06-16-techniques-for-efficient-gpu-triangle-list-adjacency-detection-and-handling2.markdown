---

title: Techniques for efficient GPU triangle list adjacency detection and handling
abstract: An apparatus may include a memory to store a set of triangle vertices in a triangle, a processor circuit coupled to the memory and a cache to cache a set of triangle vertex indices corresponding to triangle vertices most recently transmitted through a graphics pipeline. The apparatus may also include an autostrip vertex processing component operative on the processor circuit to receive from the memory the set of triangle vertices, compare an index for each vertex of the set of triangle vertices to determine matches to the set of cached triangle vertex indices, and shift a single vertex index into the cache, the single vertex index corresponding to a vertex miss in which a given vertex of the set of triangle vertices does not match any vertex index of the set of cached triangle vertex indices when exactly two matches to the set of cached triangle vertex indices are found.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619859&OS=09619859&RS=09619859
owner: INTEL CORPORATION
number: 09619859
owner_city: Santa Clara
owner_country: US
publication_date: 20150616
---
This application is a continuation of claims the benefit of and priority to previously filed U.S. patent application Ser. No. 13 627 699 filed Sep. 26 2012 entitled TECHNIQUES FOR EFFICIENT GPU TRIANGLE LIST ADJACENCY DETECTION AND HANDLING the subject matter of which is incorporated herein by reference in its entirety.

In processing data to generate an image graphics processor GPU performance and power consumption is directly related to the choice of input topology used to model the objects presented in an image. In the present day graphics processors typically render images using triangles as primitives. A major factor that defines the efficiency of image generation is the number of vertices required to describe the scene e.g. the average number of vertices required to define a triangle. This is based on several factors but is primarily due to the fact that GPUs typically transmit one vertex along a fixed function geometry pipeline every clock. The practice of passing multiple vertices down the geometry pipeline in one clock is generally prohibitive with respect to semiconductor die area and power consumption. This is due to the amount of information associated with each vertex the considerable length of the fixed function geometry pipeline and the complexity of processing input topologies to packets of a fixed number of vertices. In addition the ability to process multiple vertices per clock is not always required and therefore such practice may unnecessarily consume power and processor real estate.

Because of these considerations the use of triangle strips to render images provides distinct advantages. A triangle strip is a series of connected triangles that share vertices where each new vertex implicitly defines a new triangle. Triangle strips are used to accelerate the rendering of objects represented as triangle meshes. If the triangle strip tristrip topology is used except for the first two vertices each subsequent vertex defines a complete triangle. This contrasts with the so called triangle list trilist topology which renders each triangle separately and thereby requires three vertices to define a single triangle. Thus in principle the number of vertices sent to the GPU to define n triangles in a mesh may be reduced from 3n to n 2 in the best case.

Nonetheless current graphics processing applications including 3D graphics almost exclusively use trilist input topologies even though there is generally a high level of connectivity between triangles in the trilists. There are several reasons for the persistence of trilist topology including but not limited to the following 1 tristrip topologies only allow subsequent triangles to connect to the strip at the last submitted edge and this restrictive adjacency limits their usefulness in modeling complex shapes 2 tristrip topologies tend to be rather short few vertices when used to directly model objects which may yield poor performance due to driver and GPU overhead Draw Call overhead and the limited opportunity to amortize this overhead over the few triangles typically generated within each object of the topology 3 Historically 3D application programming interfaces APIs did not directly support packing multiple variable length tristrips in a draw call.

On the other hand use of trilist topologies typically lead to performance and power consumption issues including but not limited to the following 1 Most GPUs incorporate VertexShader VS cache in order to limit redundant vertex shading. Although vertices in a trilist topology with significant spatial coherency benefit from this VS cache each triangle requires three VS cache lookups that consume power 2 vertices that hit in the VS cache still need to be buffered within the vertex shader stage until the shading of all preceding miss vertices has completed which buffering consumes die area and power 3 Vertices that hit in the VS cache also require updates to the corresponding vertex reference counts to account for the additional vertex references sent down the pipeline which further consumes power 4 Each vertex passed down the pipeline consumes some amount of dynamic power due to buffering within between stages etc and 5 Following the vertex shading stage of the pipeline complete triangles need to be assembled for per triangle operations such as clip testing cull testing and triangle setup stages 6 Finally as noted use of trilist topologies lead to maximum processing rate of one triangle per three clocks as vertices arrive at a rate of one triangle per clock.

Given the tradeoffs mentioned above there may be a need for improved techniques and apparatus to solve these and other problems.

The present embodiments are related to architecture and methods for improved processing in a graphics pipeline. In particular the present embodiments involve treatment of triangle primitives to improve absolute geometry fixed function performance in a GPU such as triangle cull and setup rates as well as to improve GPU performance power by processing triangle list topologies faster and more efficiently.

In the present embodiments an Auto Stripification also referred to herein as autostrip herein feature is provided which unlike tristrip topologies is operative in GPU hardware to automatically detect general triangle connectivity within a window of N most recently processed vertices. In particular as detailed below the present embodiments extend beyond the implicit triangle connectivity of a tristrip topology to comprehend more general triangle connectivity within trilists while avoiding the performance and power consumption impact associated with trilist topology.

In various embodiments an autostrip vertex cache is provided within a geometry pipeline of a processor such as a graphics processor. In particular embodiments the autostrip vertex cache is a fully associative vertex based cache that is operative to record pipeline information associated with vertices most recently processed by the geometry pipeline and in particular with the last N trilist vertices where N represents an integer larger than one.

As detailed below input vertex indices may be used as cache tags in the autostrip vertex cache which may be employed exclusively for trilist topology processing. Trilist triangle vertices that hit in the autostrip vertex cache can subsequently be referenced simply by the relative location index within the cache. Given the small cache size and correspondingly small index values in some embodiments the fixed function pipeline data can be extended to pass two of these autostrip vertex cache indices and some control information alongside the existing vertex information. The additional control information may indicate this pipeline data as an AutoStripTriangle primitive type. This allows a complete trilist triangle description to be passed down the pipeline within each clock as opposed to conventional processing in which 3 clocks are required to pass each trilist triangle. It is to be noted that the term clock as used herein may refer to any convenient period and may vary according to GPU design.

In particular in various embodiments the GPU may comprise various hardware elements software elements or a combination of both. Examples of hardware elements may include devices components processors microprocessors circuits circuit elements e.g. transistors resistors capacitors inductors and so forth integrated circuits application specific integrated circuits ASIC programmable logic devices PLD digital signal processors DSP field programmable gate array FPGA memory units logic gates registers semiconductor device chips microchips chip sets and so forth. Examples of software elements may include software components programs applications computer programs application programs system programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application program interfaces API instruction sets computing code computer code code segments computer code segments words values symbols or any combination thereof. Determining whether an embodiment is implemented using hardware elements and or software elements may vary in accordance with any number of factors such as desired computational rate power levels heat tolerances processing cycle budget input data rates output data rates memory resources data bus speeds and other design or performance constraints as desired for a given implementation.

Examples of a display device include a liquid crystal display LCD light emitting diode display LED touch sensitive display plasma display cathode ray tube and other display types.

As further illustrated in the GPU may include an autostrip processing component and an autostrip vertex cache . The autostrip processing component may be embodied in hardware software or a combination of hardware and software and may be operative on the GPU to perform various processing functions related to vertex processing as detailed below.

Consistent with the present embodiments the autostrip processing component may operate in conjunction with the autostrip vertex index cache to automatically adjust processing of triangle vertex indices based upon how many cache hits take place in the autostrip vertex index cache . As detailed below when fewer than two hits take place the triangle vertex indices may be processed as trilist triangle while when two or more hits take place a shift to autostrip processing of the triangle vertex indices is triggered. This facilitates the ability to harness the advantages of both trilist and tristrip processing while avoiding some of the pitfalls of each.

In particular during the vertex fetch stage illustrated in the autostrip vertex index cache may be arranged with a set of cache tags in which the index of a vertex as read from the index buffer in memory serves as tag data for a given cache entry. As vertices are processed the index values of the vertices are considered as tags and are looked up in cache tag storage of autostrip vertex index cache . Each vertex index thereby registers a hit or miss in the tag lookup of the autostrip vertex index cache . If a vertex index hits in this cache tag lookup the result returned represents the location of the matching vertex index in the tag storage. For example for an autostrip vertex index cache having a cache size of 4 the number returned may range from 0 to 3.

In the example of a scenario is shown in which either zero or one cache hit is returned. When the GPU determines that either one or zero cache hits has been returned for the trilist triangle vertex indices being processed the GPU auto strip processing component performs multiple actions as illustrated in . The three trilist triangle vertex indices are shifted for temporary storage into the autostrip vertex index cache . In various embodiments the size N of the autostrip vertex index cache is three or greater. Assuming that any valid cache entries were present in the autostrip vertex index cache when invalidation takes place the N 3 vertex indices for vertices that were most recently transmitted through and processed in the geometry pipeline remain in the autostrip vertex index cache . As used herein in conjunction with triangle vertices the terms most recently transmitted and most recently processed refer to a set of vertices that includes the last most recent processed vertex the next most recently processed vertex and so forth. Accordingly if N 5 the N most recent vertices includes the last processed vertex the next to last processed vertex the third to last processed vertex the fourth to last processed vertex and the fifth to last processed vertex.

Because fewer than two cache hits occur in the scenario of the input triangle vertex indices cannot be handled according to tristrip processing. Therefore the three triangle vertices may be further processed similarly to conventional trilist processing in which one vertex of the triangle is processed per clock.

However when two or more cache hits are returned from the autostrip vertex index cache the present embodiments provide triangle processing that harnesses the power of the tristrip approach. illustrate another scenario of processing triangle list indices consistent with the present embodiments. In the example shown in the input triangle is assumed to generate two cache hits in the autostrip vertex index cache . As a consequence as shown in the GPU is triggered to perform several actions. For one the input triangle is converted into an AutoStripTriangle primitive type for processing. The AutoStripTriangle primitive includes the vertex of the input triangle that did not hit in the autostrip vertex index cache which may be deemed the miss vertex as well as the indices in the autostrip vertex index cache of the two hit vertices for the input triangle. The GPU autostrip processing component then shifts the vertex index of the miss vertex into the autostrip vertex index cache . In so doing assuming the cache is full the GPU may also evict the oldest entry in autostrip vertex index cache .

Also depicted in is a table that illustrates the content that is transmitted along a fixed function geometry pipeline in order to process the four triangles and in the trilist primitive .

The table contains groups of signals to pass Primitive Type Control information and Vdata which represents a full set of information that the pipeline requires for a given vertex V of a triangle being processed. In the example of n may have a value zero or greater. The table also includes autostrip cache index data which contains indices Vand Vthat include only the autostrip cache indices for the other two vertices of the triangle.

Each row in the table represents a set of data submitted to a pipeline in a different clock. For example the top row may be the data submitted to the pipeline on the 1clock the 2row may be the data submitted on the 2clock etc. Accordingly to provide all the data for the four triangles that constitute the triangle primitive a duration of six clocks is required which provides in succession the data shown in the rows and .

In the table the full set of information provided for an entry Vconstitutes the information the pipeline requires to perform computations on the given vertex. Consistent with the present embodiments and discussed further below the results of these computations may be subsequently stored pushed in the Data Cache blocks in clipping setup stages.

As is evident from table processing of the triangle primitive involves generating an initial triangle in the first three clocks followed by the generation of a new autostrip triangle each subsequent clock. In particular the autostrip processing component may generate Primitive Type Control information that lists a type of primitive corresponding to the vertex data being processed in a given clock as well as other control information if any. In the initial three clocks corresponding to the rows the primitive is indicated as tristrip and no other control information is shown. In the fourth clock corresponding to row the control information indicates that the pipeline data corresponds to an AutoStripTriangle primitive type. In addition further control information includes the order of vertices being processed. The order of vertices shown in row is V V and V which indicates for example that the full vertex is the second vertex corresponding to Vin the triangle primitive . This order information is required when the triangle is subsequently assembled in preparation for triangle based processing.

As illustrated in particular by table in the first three clocks the full vertex information corresponding to Vincludes the vertices V V and V which are used to construct the first triangle A . No entries are yet populated for the Vand Vautostrip cache indices. Beginning with the fourth clock corresponding to row the autostrip cache indices Vand Vare populated with entries to construct a subsequent triangle. In row the first index V V the second index V Vand third index V Vfrom which the second triangle B may be constructed in row the first index V V the second index V Vand third index V Vfrom which the third triangle C may be constructed and so forth.

The triangle processing illustrated in presents multiple advantages afforded by the present embodiments over conventional triangle processing. As noted only six clocks are required to generate the triangle primitive in contrast to conventional trilist topology in which a total of twelve clocks are required to construct the triangle primitive at a processing rate of one vertex per clock.

In addition the embodiment shown in avoids problems associated with conventional tristrip topology for constructing many shapes. To highlight this point illustrates the processing of triangle primitive according to conventional tristrip topology. In it is shown that two separate triangle strips and must be generated to construct the triangle primitive using tristrip topology. As is known tristrip topologies only allow subsequent triangles to connect to the strip at the last submitted edge thereby limiting their usefulness in modeling complex shapes. In the example of after the triangle C is formed having the last edge defined by vertices Vand V the triangle D to be constructed involves a vertex Vthat is not connected to the last submitted edge. Therefore a new tristrip is required to be generated that defines separately all three vertices in the triangle D. Accordingly a total of 9 clocks are necessary to generate the triangle primitive in addition to processing overhead associated with generating two separate triangle strips. The present embodiments avoid this problem by providing the autostrip cache indices that allow a geometry pipeline to determine the location of previously computed and cached data. Thus in the clock corresponding to row of table the full vertex Vis processed together with the autostrip cache indices Vand Vto generate the triangle D. 

In various embodiments subsequent to the vertex fetch stage the geometry pipeline further processes the vertices by taking into account autostrip information. In particular as illustrated by the vertex shading stage a miss vertex of a triangle may be subject to Vertex Shader processing including performing a lookup in a vertex shader cache not shown . The AutoStrip related information may remain associated with the miss vertex until the miss vertex subsequently exits the vertex shading stage as an autostrip primitive type.

Notably as discussed above the AutoStrip primitive hit vertices are only specified via an autostrip vertex index cache as opposed to the additional information used to specify the miss vertex. Accordingly relevant downstream units for processing the hit vertices are likewise required to cache any necessary information resulting from the previous processing of these vertices when they were sent down the geometry pipeline.

In the example of in the Clipping stage of the geometry pipeline the computed vertex position s and results of vertex clip testing may be cached in an autostrip vertex data cache . Likewise information obtained and or generated for a vertex in the Setup stage may also be cached in the autostrip vertex data cache . This caching may be performed so that the caching parallels the behavior of the autostrip vertex index cache so that the indices provided in the autostrip primitive correspond to the appropriate cached vertex information. The caching of this information parallels the information retention of the two previous vertices required for tristrip triangle processing and in particular may be a simple extension of existing tristrip information caching

Although depicted as separate caches consistent with the present embodiments autostrip vertex index cache and autostrip vertex data cache may form part of the same cache such as an autostrip vertex cache. In particular the autostrip vertex index cache may represent a tag portion of the autostrip vertex cache not separately shown while the autostrip vertex data cache represents the data portion of the autostrip vertex cache.

In various embodiments the size of an autostrip vertex cache may be arranged to balance the need for a small cache size with the ability to model more complex shapes in a single autostrip sequence. Thus as the value of the cache size N increases more vertex indices may be stored in an autostrip vertex index cache which allows more complex shapes to be modeled. For example referring to once more it may be determined to add to the triangle primitive an additional triangle containing an additional vertex Vand adjacent vertices Vand V. depicts an example of processing a set of triangles consistent with the present embodiments. In this case the arrangement of builds on the triangle primitive by adding an additional triangle E. 

Because general triangle connectivity is determined based upon the N most recently processed vertices the new triangle based upon vertex Vmay be generated if both Vand Vare present in the entries Vor Vin the autostrip cache index data of the table . Accordingly in order that Vbe retained as an index in the autostrip cache index data during processing of the vertex V N must have a value greater than 5. As shown in the number of rows which is equivalent to the value of N is seven. Accordingly the vertex Vis retained so that the additional triangle E whose vertices are V Vand V can be processed as an autostrip triangle.

On the other hand the performance gained by increasing the value of N may be balanced by considerations of cache size. A study of graphics workloads has shown that 50 of triangles within trilist topologies share at least two vertices with the immediately preceding triangle. Therefore if the pipeline cached information is stored for the previous three trilist vertices in more than 50 of triangle processing cases it should be possible to handle a next triangle as an AutoStripTriangle that only requires one full vertex description. Based on the study the overall processing performance of the trilist topologies should approach surpass two 2X clocks triangle instead of three 2X clocks triangle afforded by conventional processing. The study has also shown that when the number of vertices cached N increases from 3 to 5 the percentage of trilist triangles that are amenable to autostrip processing as described herein generally increases only slightly. In the cases studied the typical fraction of trilist triangles amenable to autostrip processing is about 40 to 80 for N 3 and typically increases in the range of a few percent to about ten percent when N is increased to a value of 5. Accordingly in some embodiments a cache size of three to five may provide an effective performance enhancement without incurring an undue real estate penalty.

In a further study it was found that the number of vertex shader cache accesses was only about 56 when an autostrip processing of input triangles was performed as opposed to triangle process processing employing conventional trilist topology. Moreover the average number of cases in which a miss generates a reshading of a vertex increases only marginally using autostrip processing which increase is only due to the large decrease in total cache accesses.

Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While for purposes of simplicity of explanation the one or more methodologies shown herein for example in the form of a flow chart or flow diagram are shown and described as a series of acts it is to be understood and appreciated that the methodologies are not limited by the order of acts as some acts may in accordance therewith occur in a different order and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all acts illustrated in a methodology may be required for a novel implementation.

At block a new trilist triangle is fetched for processing in the geometry pipeline. At block each of three triangle vertex indices of the new trilist triangle is compared to cached triangle vertex indices in the autostrip vertex cache.

The flow then proceeds to the decision block where a determination is made as to how many cache hits matches are found in the autostrip vertex cache. If the number of hits is either zero or one the flow moves to block where the new trilist triangle is processed as a conventional trilist triangle in the geometry pipeline

If the number of hits is equal to two the flow moves to block . At block the new trilist triangle is converted to an autostrip triangle primitive type that contains the missed vertex of the three triangle vertices of the new trilist triangle as well as the two hit vertices in which a match was found in the autostrip vertex cache. The flow then proceeds to block . At block an index of the miss vertex of the new trilist triangle is stored in the autostrip vertex cache. In so doing if the autostrip vertex cache is full an oldest entry in the autostrip vertex cache is deleted.

If at block three hits are found the flow moves to block . At block the third triangle vertex index of the new trilist triangle is designated as a miss index. The flow then proceeds to block .

In one embodiment the computing architecture may comprise or be implemented as part of an electronic device. Examples of an electronic device may include without limitation a mobile device a personal digital assistant a mobile computing device a smart phone a cellular telephone a handset a one way pager a two way pager a messaging device a computer a personal computer PC a desktop computer a laptop computer a notebook computer a handheld computer a tablet computer a server a server array or server farm a web server a network server an Internet server a work station a mini computer a main frame computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems processor based systems consumer electronics programmable consumer electronics television digital television set top box wireless access point base station subscriber station mobile subscriber center radio network controller router hub gateway bridge switch machine or combination thereof. The embodiments are not limited in this context.

The computing architecture includes various common computing elements such as one or more processors co processors memory units chipsets controllers peripherals interfaces oscillators timing devices video cards audio cards multimedia input output I O components and so forth. The embodiments however are not limited to implementation by the computing architecture .

As shown in the computing architecture comprises a processing unit a system memory and a system bus . The processing unit can be any of various commercially available processors. Dual microprocessors and other multi processor architectures may also be employed as the processing unit . The system bus provides an interface for system components including but not limited to the system memory to the processing unit . The system bus can be any of several types of bus structure that may further interconnect to a memory bus with or without a memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures.

The computing architecture may comprise or implement various articles of manufacture. An article of manufacture may comprise a computer readable storage medium to store logic. Embodiments may also be at least partly implemented as instructions contained in or on a non transitory computer readable medium which may be read and executed by one or more processors to enable performance of the operations described herein. Examples of a computer readable storage medium may include any tangible media capable of storing electronic data including volatile memory or non volatile memory removable or non removable memory erasable or non erasable memory writeable or re writeable memory and so forth. Examples of logic may include executable computer program instructions implemented using any suitable type of code such as source code compiled code interpreted code executable code static code dynamic code object oriented code visual code and the like.

The system memory may include various types of computer readable storage media in the form of one or more higher speed memory units such as read only memory ROM random access memory RAM dynamic RAM DRAM Double Data Rate DRAM DDRAM synchronous DRAM SDRAM static RAM SRAM programmable ROM PROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM flash memory polymer memory such as ferroelectric polymer memory ovonic memory phase change or ferroelectric memory silicon oxide nitride oxide silicon SONOS memory magnetic or optical cards or any other type of media suitable for storing information. In the illustrated embodiment shown in the system memory can include non volatile memory and or volatile memory . A basic input output system BIOS can be stored in the non volatile memory .

The computer may include various types of computer readable storage media in the form of one or more lower speed memory units including an internal hard disk drive HDD a magnetic floppy disk drive FDD to read from or write to a removable magnetic disk and an optical disk drive to read from or write to a removable optical disk e.g. a CD ROM or DVD and a solid state drive SSD to read or write data to from a non volatile memory NVM including a NAND flash memory phase change memory PCM a spin memory phase change memory with switch PCMS magnetoresistive random access memory MRAM spin memory nanowire memory ferroelectric transistor random access memory FeTRAM . The HDD FDD optical disk drive and solid state drive can be connected to the system bus by a HDD interface an FDD interface an optical drive interface and a solid state drive interface respectively. The HDD interface for external drive implementations can include at least one or both of Universal Serial Bus USB and IEEE 1294 interface technologies. The solid state drive interface may comprise any suitable interface for coupling to the host device such as for example but not limited to a serial advanced technology attachment SATA interface a serial attached SCSI SAS interface a universal serial bus USB interface a peripheral control interface PCI or other suitable device interface.

The drives and associated computer readable media provide volatile and or nonvolatile storage of data data structures computer executable instructions and so forth. For example a number of program modules can be stored in the drives and memory units including an operating system one or more application programs other program modules and program data .

A user can enter commands and information into the computer through one or more wire wireless input devices for example a keyboard and a pointing device such as a mouse . Other input devices may include a microphone an infra red IR remote control a joystick a game pad a stylus pen touch screen or the like. These and other input devices are often connected to the processing unit through an input device interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port IEEE 1294 serial port a game port a USB port an IR interface and so forth.

A monitor or other type of display device is also connected to the system bus via an interface such as a video adaptor . In addition to the monitor a computer typically includes other peripheral output devices such as speakers printers and so forth.

The computer may operate in a networked environment using logical connections via wire and or wireless communications to one or more remote computers such as a remote computer . The remote computer can be a workstation a server computer a router a personal computer portable computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include wire wireless connectivity to a local area network LAN and or larger networks for example a wide area network WAN . Such LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network for example the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a wire and or wireless communication network interface or adaptor . The adaptor can facilitate wire and or wireless communications to the LAN which may also include a wireless access point disposed thereon for communicating with the wireless functionality of the adaptor .

When used in a WAN networking environment the computer can include a modem or is connected to a communications server on the WAN or has other means for establishing communications over the WAN such as by way of the Internet. The modem which can be internal or external and a wire and or wireless device connects to the system bus via the input device interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with wire and wireless devices or entities using the IEEE 802 family of standards such as wireless devices operatively disposed in wireless communication e.g. IEEE 802.11 over the air modulation techniques with for example a printer scanner desktop and or portable computer personal digital assistant PDA communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi or Wireless Fidelity WiMax and Bluetooth wireless technologies. Thus the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi Fi networks use radio technologies called IEEE 802.11x a b g n etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wire networks which use IEEE 802.3 related media and functions .

Some embodiments may be described using the expression one embodiment or an embodiment along with their derivatives. These terms mean that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment. Further some embodiments may be described using the expression coupled and connected along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example some embodiments may be described using the terms connected and or coupled to indicate that two or more elements are in direct physical or electrical contact with each other. The term coupled however may also mean that two or more elements are not in direct contact with each other but yet still co operate or interact with each other.

In one embodiment an apparatus may include a memory to store a set of triangle vertices of a triangle a processor circuit coupled to the memory and a cache to hold a set of triangle vertex indices corresponding to triangle vertices most recently transmitted through a graphics pipeline. The apparatus may also include an autostrip vertex processing component operative on the processor circuit to receive from the memory the set of triangle vertices compare an index for each vertex of the set of triangle vertices to determine matches to the set of cached triangle vertex indices and to shift a single vertex index into the autostrip vertex cache the single vertex index corresponding to a vertex miss in which a given vertex of the set of triangle vertices does not match any vertex index of the set of cached triangle vertex indices when exactly two matches to the set of cached triangle vertex indices are found.

In another embodiment the cache may comprise an autostrip vertex cache and the set of cached vertex indices may comprise N most recently transmitted vertex indices N being an integer greater than two.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to delete an oldest entry of the set of cached triangle vertex indices when two matches are found.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to shift a vertex index for each vertex of the set of triangle vertices into the cache when zero or one match to the set of cached triangle vertex indices is found.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to designate a vertex index for a single vertex of the set of triangle vertices for storage in the cache and shift the designated vertex index into the cache for storage when three matches to the set of cached triangle vertex indices are found.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to provide control information with the set of triangle vertex indices the control information including an order of the set of triangle vertices.

Alternatively or in addition in a further embodiment the control information may comprise an order of the single vertex index and first and second vertex indices corresponding to vertices providing the two matches to the set of stored vertex indices.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to cache results of vertex clip testing and computed vertex positions of the set of triangle vertices in a data portion of an autostrip vertex cache.

Alternatively or in addition in a further embodiment the autostrip vertex processing component may be operative on the processor circuit to cache in a data portion of an autostrip vertex cache information obtained and or generated for a vertex in a setup stage of the geometry pipeline.

Alternatively or in addition in a further embodiment the apparatus may include a digital display to present an image generated from the triangle vertex indices.

In a further embodiment a computer implemented method may include receiving from memory a set of triangle vertices in a triangle for processing in a graphics geometry pipeline comparing an index for each vertex of the set of triangle vertices to determine matches to a set of cached triangle vertex indices stored in a cache and corresponding to triangle vertices most recently transmitted through a graphics pipeline and when exactly two matches to the set of cached triangle vertex indices are found shifting a single vertex index into the cache the single vertex index corresponding to a vertex miss in which a given vertex of the set of triangle vertices does not match any vertex index of the set of cached triangle vertex indices.

In another embodiment of the computer implemented method the set of cached vertex indices comprising N most recently transmitted vertex indices N being a number greater than two.

Alternatively or in addition in a further embodiment the computer implemented method may comprise deleting an oldest entry of the set of cached triangle vertex indices when two matches are found.

Alternatively or in addition in a further embodiment the computer implemented method may comprise when zero or one match to the set of cached triangle vertex indices is found shifting a vertex index for each vertex of the set of triangle vertices into the cache.

Alternatively or in addition in a further embodiment the computer implemented method may comprise when three matches are found designating a vertex index for a single vertex of the set of triangle vertices for storage in the cache and shifting the designated vertex index into the cache for storage.

Alternatively or in addition in a further embodiment the computer implemented method may comprise providing control information with the set of triangle vertex indices the control information including an order of the set of triangle vertices the order including an order of the single vertex index and first and second vertex indices corresponding to vertices providing the two matches to the set of cached triangle vertex indices.

Alternatively or in addition in a further embodiment the computer implemented method may comprise caching in a data portion of the cache information obtained and or generated for a vertex in a setup stage of the geometry pipeline.

Alternatively or in addition in a further embodiment the computer implemented method may comprise caching results of vertex clip testing and computed vertex positions of the set of triangle vertices in a data portion of the cache.

In a further embodiment an apparatus may be configured to perform the method of any one of the preceding embodiments.

In another embodiment at least one machine readable medium may comprise a plurality of instructions that in response to being executed on a computing device cause the computing device to carry out a method according to any one of the preceding embodiments.

It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition in the foregoing Detailed Description it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separate embodiment. In the appended claims the terms including and in which are used as the plain English equivalents of the respective terms comprising and wherein respectively. Moreover the terms first second third and so forth are used merely as labels and are not intended to impose numerical requirements on their objects.

What has been described above includes examples of the disclosed architecture. It is of course not possible to describe every conceivable combination of components and or methodologies but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the novel architecture is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims.

Various embodiments may be implemented using hardware elements software elements or a combination of both. Examples of hardware elements may include processors microprocessors circuits circuit elements e.g. transistors resistors capacitors inductors and so forth integrated circuits application specific integrated circuits ASIC programmable logic devices PLD digital signal processors DSP field programmable gate array FPGA logic gates registers semiconductor device chips microchips chip sets and so forth. Examples of software may include software components programs applications computer programs application programs system programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application program interfaces API instruction sets computing code computer code code segments computer code segments words values symbols or any combination thereof. Determining whether an embodiment is implemented using hardware elements and or software elements may vary in accordance with any number of factors such as desired computational rate power levels heat tolerances processing cycle budget input data rates output data rates memory resources data bus speeds and other design or performance constraints.

Some embodiments may be described using the expression coupled and connected along with their derivatives. These terms are not intended as synonyms for each other. For example some embodiments may be described using the terms connected and or coupled to indicate that two or more elements are in direct physical or electrical contact with each other. The term coupled however may also mean that two or more elements are not in direct contact with each other but yet still co operate or interact with each other.

Some embodiments may be implemented for example using a computer readable medium or article which may store an instruction or a set of instructions that if executed by a computer may cause the computer to perform a method and or operations in accordance with the embodiments. Such a computer may include for example any suitable processing platform computing platform computing device processing device computing system processing system computer processor or the like and may be implemented using any suitable combination of hardware and or software. The computer readable medium or article may include for example any suitable type of memory unit memory device memory article memory medium storage device storage article storage medium and or storage unit for example memory removable or non removable media erasable or non erasable media writeable or re writeable media digital or analog media hard disk floppy disk Compact Disk Read Only Memory CD ROM Compact Disk Recordable CD R Compact Disk Rewriteable CD RW optical disk magnetic media magneto optical media removable memory cards or disks various types of Digital Versatile Disk DVD a tape a cassette or the like. The instructions may include any suitable type of code such as source code compiled code interpreted code executable code static code dynamic code encrypted code and the like implemented using any suitable high level low level object oriented visual compiled and or interpreted programming language.

Unless specifically stated otherwise it may be appreciated that terms such as processing computing calculating determining or the like refer to the action and or processes of a computer or computing system or similar electronic computing device that manipulates and or transforms data represented as physical quantities e.g. electronic within the computing system s registers and or memories into other data similarly represented as physical quantities within the computing system s memories registers or other such information storage transmission or display devices. The embodiments are not limited in this context.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

