---

title: Advanced interactive command-line front-end for graph analysis systems
abstract: Systems and methods for interactive front-end graph analysis are provided herein. According to one embodiment, a front-end application receives, from a compiler, first meta-information for a particular graph analysis procedure, where the first meta-information identifies a set of input parameters for passing graph information to the particular graph analysis procedure. The front-end application registers, using the first meta-information, the particular graph analysis procedure as an available command. The front-end application also receives second meta-information that identifies, for each respective graph object of a set of one or more graph objects, a respective set of graph characteristics. In response to receiving a request to apply the particular graph analysis procedure to the set of one or more graph objects, the front-end application enforces a set of one or more constraints based on the first meta-information and the second meta-information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09575736&OS=09575736&RS=09575736
owner: Oracle International Corporation
number: 09575736
owner_city: Redwood Shores
owner_country: US
publication_date: 20150722
---
This application is related to U.S. application Ser. No. 14 805 897 entitled OPTIMIZATION TECHNIQUES FOR HIGH LEVEL GRAPH LANGUAGE COMPILERS the entire contents of which is hereby incorporated by reference as if fully set forth herein.

The present disclosure relates generally to graph analysis and more specifically to front end applications for interacting with graph data objects.

Graph analysis is a subfield of data analysis that generally encompasses systems and methods for analyzing datasets modelled as graphs. The graphs that are analyzed typically organize the underlying dataset into a set of nodes or vertices connected by edges each of which may have a particular direction. A graph captures fined grained arbitrary relationships between different data entities within a dataset. Graphs can be used to model a wide variety of systems and relationships including without limitation communication networks linguistic structures social networks data hierarchies and other physical or virtual systems. By analyzing the relationships captured by a graph data scientists applications or other users can obtain valuable insights about the original dataset.

Graph analysis is often performed in an exploratory manner. For instance a data scientist may apply different analysis algorithms on the dataset or a subset of it in an ad hoc manner until some valuable insight about the dataset is digested. In order to support such exploratory use cases some traditional database management systems DBMS and specialized graph processing systems provide command line front ends through which users may submit database queries and procedures. According to one such approach a general shell application is used to submit standard query language SQL statements and Procedural Language Structured Query Language PL SQL blocks to a database server. Such generalized shell applications allow a user to query and perform standard database operations on graph objects but generally do not provide any specialized support for performing graph analysis operations. Therefore the interactivity and operability of such generalized shell applications are significantly limited.

According to another approach a specialized shell application may be configured to support domain specific graph languages such as Gremlin. These shells allow users to submit commands specifically tailored for graph analysis. For instance the graph language may support pre defined graph operations for manipulating graph objects via graph traversals. These shells are typically built upon general interpreter frameworks and rely on the type checking capability of the baseline systems. Generalized type checking does not capture the nuances of a graph analysis environment which may lead to unintentional and potentially costly errors on the part of the user. As an example the user may apply a particular algorithm intended for a bipartite graph to a non bipartite graph. If left unchecked data may become corrupted or otherwise unreliable during graph analysis. Consequently the user may incorrectly interpret the data and or overlook potentially useful insights.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Systems and methods for interactive front end graph analysis are provided herein. In some embodiments a front end application receives from a compiler first meta information for a particular graph analysis procedure where the first meta information identifies a set of one or more input parameters for passing graph information to the particular graph analysis procedure. The front end application registers using the first meta information the particular graph analysis procedure as an available command. The front end application also receives from an underlying graph processing system second meta information that identifies for each respective graph object of a set of one or more graph objects a respective set of graph characteristics. In response to receiving a request to apply the particular graph analysis procedure to the set of one or more graph objects the front end application enforces a set of one or more constraints based on the first meta information and the second meta information.

In some embodiments the front end application may further receive before the first meta information is received from the compiler source code for the particular graph analysis procedure. As an example the user may define a custom graph analysis procedure using a domain specific language DSL string and provide the string to the front end application. In response to receiving the DSL string for the particular graph analysis procedure front end application sends the string to a server. The server then invokes a compiler which compiles the DSL string to produce an executable binary of the graph analysis procedure as well as meta information for the procedure. After the custom graph analysis procedure is compiled the server returns the corresponding meta information to the front end application. In response the front end application stores the meta information and allows the custom graph analysis procedure to be invoked as if it were a built in procedure.

The techniques described herein including compiling graph analysis procedures loading the executables receiving meta information enforcing constraints and running the executable may all be performed during runtime of the front end application without the need to restart the application. Thus a user may perform exploratory graph analysis including defining and running custom procedures interactively and efficiently in a manner that does not interrupt data analysis.

Front end application generally comprises user interface data store registration logic and constraint enforcement logic . User interface is configured to receive input from user and to present information for further processing or display. The implementation of user interface may vary from embodiment to embodiment. In some embodiments user interface may comprise a command line interface CLI through which the user may issue commands and view command results through successive lines of text. In other embodiments user interface may comprise a graphical user interface GUI through which a user may interact with GUI objects such as icons and menus to issue commands and view command results. In other embodiments user interface may comprise an application programming interface API that defines a set of function inputs and outputs. User may be a human user such as a data scientist or a separate application.

Data store stores various meta information and data that may be used by front end application during graph analysis. The meta information and data includes procedure meta information graph object meta information graph object data and built in command meta information . Examples of meta information and graph object data are given in further detail below. Data store may be implemented in volatile memory non volatile memory or some combination thereof.

Registration logic includes logic for registering custom procedures with front end application . Once registered the custom procedures may be accessed and invoked through front end application . Constraint enforcement logic includes logic for applying a set of constraint rules to custom procedures when they are invoked. Examples constraints that may be applied are given in further detail below. The logic units may be implemented using computer or electrical hardware component s firmware a non transitory computer readable medium that stores instructions and or combinations of these components configured to perform one or more functions or actions as described further herein.

Graph processing server includes a set of back end applications that support exploratory graph analysis. The back end applications generally comprise compiler graph database services and procedure execution engine . Graph processing server further includes graph database which stores back end graph object data and back end graph meta information . Graph processing server may support a variety of functions provided to user through front end application . These functions may include without limitation 

In some embodiments front end application provides built in methods and commands for loading graph objects. A graph object in this context may be a dataset that is organized a set of nodes also referred to herein as vertices connected by edges. As an example a graph object may correspond to unordered pairs of vertices where each pair set represents an edge within a graph. As another example a graph object may correspond to a data structure such as an adjacency list or adjacency matrix in which a representation of a graph is stored. In an adjacency list of a graph G V E with vertices V and edges E the adjacency list is an array of lists one list for each vertex. The list for each vertex contains the names of all of the vertices adjacent to that vertex. In an adjacency matrix of a graph G V E the elements are all possible pairs of vertices. If an edge exists between a pair of vertices the element in the matrix is marked.

A graph object may also be dataset that represents a dependent object within a graph. Example dependent graph objects include

The manner in which graph object are loaded by front end application may vary from implementation to implementation. In some embodiments front end application supports command line interface commands to load graphs. TABLE 1 below depicts an example command for loading a graph object.

The command depicted in TABLE 1 causes front end application to load a graph object located at the specified path location path to graph info.json with the name my graph .

In addition or as an alternative to loading the graph through a command line interface front end application may provide a GUI for loading graph objects. As an example user may select a Load Graph icon menu item or other graphical object. In response front end application may open a GUI window that allows user to browse through different directories and select graph objects to load.

Front end application may support different types of graph objects. Examples of different types of graph objects include without limitation 

When loading a graph object front end application receives and or extracts meta information about the properties of the loaded graph object. Example meta information that may be received or extracted may include without limitation 

In some embodiments front end application provides built in methods and commands for manipulating a graph object and dependent objects that belong to the graph object. Example operations may include without limitation operations for creating deleting sorting and modifying dependent objects that belong to a loaded graph object.

The built in methods and commands may support operations at different granularities including at the level of individual node edge properties individual nodes edges or groups of nodes edges. As an example user may submit a command to create a new node a new collection of nodes or a new node property. In the context of a node property for instance user may create a new page rank property or some other property for nodes in a graph that model different webpages and set the value based on a page rank function. The node edge properties may be arbitrary in nature depending on the particular application.

In some embodiments the manipulations of graph objects may be committed to graph database . When a graph object is added deleted or otherwise modified via front end application the change may be propagated to graph database . In other embodiments the manipulations may happen locally within front end application without modifying back end graph object data or back end graph meta information . The change may occur to graph object data which may be performed for exploratory purposes but is not committed to graph database .

TABLE 2 depicts example built in operations and meta information maintained for various graph object types according to some embodiments.

In step graph database services receives the request to load the graph object from front end application . In response to receiving the request graph database services reads the requested graph object data and associated meta information if available from graph database . For example graph database services may retrieve a dataset corresponding to a graph collection of nodes collection of edges individual node or individual edge. The meta information may generally identify one or more characteristics of the target graph object. Example meta information is given in TABLE 2 above. Next in step graph database services returns the graph object and the associated meta information if available.

In step front end application receives the graph object and if available the associated meta information. Next in step front end application determines if the relevant meta information was received for the received graph object. If the meta information is not provided by the underlying graph processing system or the meta information is incomplete then front end application may extract the meta information in step by iterating over the graph object. By iterating over the nodes of a graph front end application may determine and generate meta information such as the following 

In step front end application stores the graph object and associated meta information in data store . Once the graph object and associated meta information is stored then user may begin graph analysis operations by issuing built in or custom commands. Thus in step front end application receives a request to perform a built in or custom operation on the graph object. In response the operation is applied to the loaded graph object at step .

In some embodiments front end application supports dynamic compilation of graph analysis procedures. User may provide front end application with source code for the high level procedure which are then compiled into a representation executable by front end application via commands. The compilation and execution of the functions may be performed via front end application during runtime and without the need to restart front end application .

The format of the source code submitted by user and supported front end application may vary from implementation to implementation. In some embodiments the source code may be written in a high level language such as a domain specific language that is specially designed for graph analysis. An example of such a DSL is Green Marl although other high level languages may be supported in addition or as an alternative to Green Marl.

In some embodiments front end application includes a shell that supports command line interface commands to compile graph analysis procedures. TABLE 3 below depicts an example command for compiling a graph analysis procedure.

The command depicted in TABLE 3 compiles a graph analysis procedure the source code for which is stored in the my procedure.gm file.

In addition or as an alternative to compiling a graph analysis procedure through a command line interface front end application may provide a GUI for compiling graph analysis procedures. As an example user may select a Compile Procedure icon menu item or other graphical object. In response front end application may open a GUI window that allows user to browse through different directories and select a graph analysis procedure to compile.

Once a command is submitted to compile a graph analysis procedure the following events may happen with respect to front end application

In some embodiments when a graph analysis procedure is registered with front end application help becomes available for the newly created command. The help may be displayed upon request by user through user interface . As an example TABLE 4 depicts an example structure for a graph analysis procedure with the name my proc .

The graph analysis procedure my proc has a signature that defines argument parameters as follows G Graph n Node weight edgeProp val nodeProp . The argument parameters include a graph a node an edge property and a node property.

Once a graph analysis procedure with the sample structure in TABLE 4 is compiled the procedure may become a shell command which can be invoked in the shell. Using meta information provided by the compiler and or user provided comments about the procedure the shell may display help messages such as depicted in TABLE 5.

Upon receiving a request for help targeting a particular graph analysis procedure front end application displays an explanation about the procedure based on a user provided comment. The input and output argument parameters and return value of the procedure are also determined based on the meta information provided by the compiler and displayed as part of the help message.

In step front end application receives source code defining a new custom graph analysis procedure. A new procedure in this context is one that is not currently available via front end application . In other words a command and executable for the new procedure have not been previously registered with front end application at this step. Next in step the source code for the graph analysis procedure is sent from front end application to compiler .

In step compiler receives the source code for the graph analysis procedure. Next in step compiler compiles the source code to generate an executable and procedure meta information for the graph analysis procedure. The manner in which the executable is generated may vary from implementation to implementation. In some embodiments the generation of the executable may be multi phased using multiple compilers. For instance a DSL compiler can generate a program in a different high level language such as Java first. A second compiler may then be invoked to generate a byte code or binary executable of the graph analysis procedure. The meta information that is generated by the compiler may also vary from implementation to implementation. Example procedure meta information may include without limitation 

In step front end application receives the meta information for the graph analysis procedure. Next in step registration logic registers the graph analysis procedure using the procedure meta information. Registering the command may include without limitation storing the procedure meta information in data store generating within the front end s interface a new command for invoking the executable associated with the graph analysis procedure and generating a help message that identifies a description argument parameters and a return value associated with the graph analysis procedure.

In some embodiments front end application may load up the compiled binary for a graph analysis procedure during runtime. For instance a shell application may use Java Reflection and Loader to import compiled byte code. Other applications may also be used to load or reload compiled graph analysis procedures at runtime.

Once a graph analysis procedure is compiled and registered with front end application user may invoke the graph analysis procedure. For example user may submit a command through a shell or select a corresponding GUI object to invoke the graph analysis procedure. TABLE 6 below depicts an example shell command for invoking a custom compiled procedure.

The command invokes the custom procedure with the name my proc and passes the graph entitled graph1 the node entitled node1 the edge property weight and the node property val as arguments for the corresponding argument parameters defined in the graph analysis procedure meta information.

When invoking the procedure user specifies which graph objects to use as arguments. As an example user may select a particular graph node edge node collection edge collection node property or edge property as an argument parameter to apply the graph analysis procedure to one or more graph objects. Other values such as integers strings etc. may be passed as arguments as well depending on the particular implementation and the argument parameters defined for the invoked graph analysis procedure.

Steps to of depict example steps for invoking a compiled graph procedure according to an embodiment. In step a request is received to apply a compiled graph analysis procedure to one or more graph objects. The request may specify the procedure names and arguments as previously indicated. Next in step constraint enforcement logic performs type checking and or other processing to enforce constraints for the compiled procedure. Example constraints that may be enforced may include without limitation

In step procedure execution engine loads the executable and executes the graph analytic procedure using the arguments specified by user thereby applying the graph analysis procedure to one or more graph objects. In some embodiments procedure execution engine may be an interpreter that processes a bytecode representation of the graph analysis procedure to just in time JIT compile the procedure. In step procedure execution engine returns the result obtained via execution of the graph analysis procedure to front end application . The result that is returned will vary depending on the particular graph analytic procedure and the arguments. For example the result may return nodes or edges whose properties satisfy some target value. As another example the result may include a value derived from applying a function to a set of node property values.

Using the meta information maintained for the graph objects and the graph analysis procedures front end application can enforce various type constraints. These constraints may include without limitation compatibility checks mutability checks and graph belongings checks. Enforcing the type constraints generally involves comparing the meta information associated with a graph analysis procedure against meta information for the graph object arguments. Based on the comparison constraint enforcement logic may determine whether user has invoked a graph analysis procedure in a manner that violates a constraint. If so an error message may be generated to indicate that a constraint was violated and how the constraint was violated. When an error is raised front end application may prevent execution of the graph analysis procedure. If no constraint is violated then front end application may cause the graph analysis procedure to be executed based on the received command.

In some embodiments constraint enforcement logic is configured to perform compatibility checks. For each argument passed to a graph analysis procedure constraint enforcement logic may check whether there is a compatible type in the underlying interpreter system that executes the graph analysis procedure. As an example if an integer is passed for a particular argument parameter to the graph analysis procedure and procedure meta information indicates that the argument parameter is expecting integer values then no error is raised. If however a non integer value is passed as an argument for the same parameter constraint enforcement logic may raise an error to warn user . In some cases constraint enforcement logic may perform property coercion if the data types do not match as described in further detail below.

In some embodiments constraint enforcement logic is configured to check the compatibility of a graph with a particular graph analysis procedure. Some graph analysis procedures may be defined for specific kinds of the graph e.g. for undirected graphs directed graphs bipartite graphs etc. Using the meta information about the graph and the meta information about the graph analysis procedure if the inappropriate graph is given as an argument the front end application raises an error. For instance if user loads a graph object corresponding to a directed graph and invokes a procedure defined for undirected graphs constraint enforcement logic may compare the meta information for the graph object and graph analysis procedure to determine that the loaded graph object is incompatible with the invoked procedure. Constraint enforcement logic may generate an error message indicating the incompatibility and prevent execution of the graph analysis procedure.

In some embodiments constraint enforcement logic is configured to perform immutability checks. To determine whether a property is immutable compiler provides meta information about how the argument parameters are used in the procedure as input or output. Graph object meta information has information about the mutability of graph objects. As an example some properties can be set as immutable when loaded from a consistent database. If such an immutable property is given to a procedure as an output argument the front end application raises an error.

In some embodiments constraint enforcement logic is configured to perform checks on the belongings of graph objects. Typically when a procedure involves a graph and a node as input the node should be a valid node that belongs to the corresponding graph referenced by the graph analysis procedure. As an example the graph analysis procedure entitled my proc depicted in TABLE 4 above may specify that the argument received for the node n parameter should belong to the graph received for the graph G parameter. If the sequence of commands depicted in TABLE 7 below is submitted by user then an error may be raised.

In the sequence of commands depicted in TABLE 7 the node node2 belongs to graph2 rather than graph1 . The graph analysis procedure however targets graph1 per the arguments passed by the user. Based on the procedure meta information maintained for my proc and the graph meta information maintained for graph1 and graph2 constraint enforcement logic may generate an error message notifies the user that node2 is not a valid node for graph1.

In step constraint enforcement logic performs a compatibility check for the selected argument. In the case of weight for example constraint enforcement logic may analyze the procedure meta information to determine that this argument should be of the data type double . Constraint enforcement logic may then compare the data type of the argument against the data type of the argument parameter defined in the procedure meta information. If the data types are compatible then the process continues to step . In some cases data types may be compatible even if they are not exact matches if property coercion is enabled as discussed further below. If the data types are not compatible then the process returns an error at step . If the process returns an error then the process may end or the process may continue checking for other errors depending on the particular implementation. For graph objects the compatibility check at this step may comprise checking the compatibility of the graph object argument with the graph analysis procedure. For instance if the user attempts to apply a procedure defined for bipartite graphs to a non bipartite graph object then an error may be raised at step .

In step constraint enforcement logic determines whether the selected argument is immutable. If the argument is immutable and the graph analysis procedure uses the argument as an output then an error is raised at step . In other words if a user is trying to change a graph property value that is immutable front end application may prevent the operation and generate an error message indicating the reason why the procedure could not be executed. If the argument is not immutable or the corresponding argument parameter is not given as an output per the procedure meta information then the process continues to step .

In step constraint enforcement logic determines whether the argument corresponds to a dependent graph object. If the argument corresponds to a dependent graph object such as a node or edge then the process continues to step and constraint enforcement logic performs a belongings check such as described above. If the dependent graph object that is passed to the graph analysis procedure by the user does not belong to the respective graph passed by the user then the process raises an error at step . If a dependent graph object is not involved or the argument passes the belongings check then the process continues to step .

In step constraint enforcement logic determine whether there are any remaining arguments in the graph analysis procedure for which type checking has not yet been performed. If any arguments remain then the process selects a new argument and repeats for the newly selected argument. If no arguments remain then the process ends at step .

In some embodiments front end application stores meta information about the unique identifier type for nodes and edges of the graph when the graph is loaded. Front end application may use the meta information to support references to nodes and edges using node or edge identifier ID values of the corresponding ID type. To illustrate TABLE 7 above depicts a command to apply the graph analysis procedure my proc and references the node object itself node2 . Instead of including a direct reference to the node itself user may instead reference the node2 using the node ID. The data type of the node ID is stored in the underlying meta information for the graph to which node2 belongs.

When invoking a procedure if the node edge ID value of the corresponding ID type is given in place of the node edge itself front end application looks up the node or edge from the ID value to automatically obtain a reference to the node or edge. If the reference exists front end application gives the reference as argument to the graph analysis procedure. As an example in the case of my proc defined above the node ID type of graph1 is an integer. User may then invoke my proc as indicated below in TABLE 8.

Upon receiving the command depicted in TABLE 8 front end application first looks up the node with ID 5698 and uses the corresponding reference as the argument. If there is no corresponding node front end application raises an error.

In some cases constraint enforcement logic may raise a type error if a property with a different value type is given as an argument. For instance if a double property is given in place of an integer property a shell may generate and display an error message. However front end application may be configured with a coercion mode turned on for properties causing front end application to apply coercion by creating temporary properties. As an example if a double property is given in place of an integer property in coercion mode front end application may automatically create a temporary property of integer values. Next front end application fills up the temporary integer value by applying coercion from double to integer for every element. Then the temporary property is passed into the procedure instead of the double property originally provided by the user.

A special case for coercion exists when a sparse property is applied in place of a dense property. In this case front end application may automatically create a temporary dense property and fill up the value either with the corresponding value from the sparse property if the value exists or a null value.

In step front end application determines the property coercion mode that is currently configured. In some embodiments front end application may be configured in one of the following coercion modes 

In step property coercion proceeds by copying values from the original node or edge property to a temporary node or edge property that matches the data type of the procedure signature. As an example if user passes a node having an integer value as an argument and the graph analysis procedure signature meta information indicates that the corresponding node argument parameter is a double then front end application may generate a new temporary double property for the node. The integer value or the original node provided by the user may then be copied into the temporary double property value. As a special case if the original property is sparse but the required property is dense the temporary property is created as a dense property. NULL values or default values are filled up for the elements whose property value is not defined in the sparse property.

In step the graph analysis procedure is executed using the temporary property. In the preceding example for instance the node property of data type double is passed to the execution engine rather than the original property having an integer value.

In step front end application determines based on the procedure meta information whether the node edge property serves as output for the invoked graph analysis procedure. If so then at step then front end application copies values from the temporary property back to the original property. Once the values have been copied to the original node or edge property or if the node edge property does not serve as output then in step the temporary node or edge property is deleted. The process then ends at step .

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

The term logic as used herein includes computer or electrical hardware component s firmware a non transitory computer readable medium that stores instructions and or combinations of these components configured to perform one or more functions or actions and or to cause one or more functions or actions from another logic method and or system. Logic may include a microprocessor controlled by executable code a discreet logic e.g. ASIC an analog circuit a digital circuit a programmed logic device a memory device containing instructions that when executed perform an algorithm and so on. Logic may include one or more gates combinations of gates or other circuit components. Where multiple logic units are described it may be possible to incorporate the multiple logic units into one physical logic component. Similarly where a single logic unit is described it may be possible to distribute the single logic unit between multiple physical logic components.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk optical disk or solid state drive is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operate in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical disks magnetic disks or solid state drives such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention and what is intended by the applicants to be the scope of the invention is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

