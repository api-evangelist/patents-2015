---

title: Restricted code signing
abstract: A method and system is provided for signing data such as code images. In one embodiment, the method comprises receiving, from a requestor, a request to sign the data according to a requested configuration selected from a first configuration, in which the data is for use with any of the set of devices, and a second configuration in which the data is for use only with a subset of a set of devices; modifying the data according to the requested configuration; generating a data signature using the modified data; and transmitting the generated data signature to the requestor. Another embodiment is evidenced by a processor having a memory storing instructions for performing the foregoing operations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652599&OS=09652599&RS=09652599
owner: ARRIS Enterprises, Inc.
number: 09652599
owner_city: Suwanee
owner_country: US
publication_date: 20150611
---
This application claims benefit of U.S. Provisional Patent Application No. 62 010 761 entitled RESTRICTED CODE SIGNING by Alexander Medvinsky Ali Negandar and Xin Qiu filed Jun. 11 2014 which application is hereby incorporated by reference herein.

The present invention relates to systems and methods for digitally signing data and in particular to a system and method for enforcing restrictions regarding the digital signing and use of code images.

Data signing is a process of digitally signing data to confirm that the author of the data is who it purports to be and to guarantee that the data has not been altered or corrupted since it was signed by use of a cryptographic hash. Data signing is particularly useful in cases wherein the data comprises software code such as executables and scripts as corrupted or hacked software code is particularly pernicious.

Armed with the code signing certificate the publisher is ready to sign the code. When the code is signed the original file is added to several pieces of information. This bundled information is used by the recipient s user agent to authenticate the publisher and check for code tampering.

A hash of the data hereinafter alternatively referred to as code is produced using a hashing module . The hashed code is a cryptographically unique representation of the code and is only reproducible by the recipient of the code using unaltered code and the same hashing algorithm that was used to create the hash. This hash is later signed using the publisher s private key A as described below. The reason the hash instead of the code is signed is that public key algorithms are inefficient for signing large objects and the hashing algorithm creates a fixed length digest of the code that is much smaller in side.

Next the hashed code is digitally signed using the publisher s private key A by the signing module A. This can be accomplished by passing the hash through a signing algorithm implemented by the signing module A using the publisher s private key A as an input. Information about the publisher and the CA may be drawn from the code signing certificate and incorporated into the signature. Next the original code signature and code signing certificate are bundled together. The code signing certificate is added to the bundle as the public key it contains is required to authenticate the code when it is verified .

The signature is verified as also shown in . First the original code is passed through the same hashing module implementing the same hashing algorithm described above to create hashed code. The public key B of the publisher is extracted from the bundle and applied to the signed hash information and applied to the signed hash by signature module B thus applying the public key B to reveal the hash that was calculated as described above when the file was signed. The two hashes hashed data and hashed data are compared if equal then the code has not changed and the signature is considered valid. Next the code signing certificate is checked to make sure that it was signed by a trusted CA and the expiry date of the code signing certificate is checked. The code signing certificate may also be checked against the revocation lists to be sure that it is valid. If the code signing certificate was signed by a trusted CA and has not been revoked the data or code is considered valid it is accepted for use by the user device. If the file is not considered valid or if the CA is not a trusted CA the user device may provide the option of accepting and executing the code from an unknown publisher or rejecting the code.

Some code signing formats are accepted by many different device models. For instance code signing compatible with the Data Over Cable Services Interface Specification DOCSIS is utilized in a number of different consumer premises equipment CPE devices which may include an embedded cable modem and other functionality such as a set top box STB integrated receiver decoder IRD used to receive media programs or a Voice Over Internet Protocol VoIP gateway. For all types of devices that include a DOCSIS cable modem a secure code download may be signed using the DOCSIS format. Furthermore each company or software publisher is generally issued one Code Verification Certificate CVC by a CA such as CABLE LABS for the purpose of DOCSIS code signing. Therefore a single signing key is utilized in that case to sign code destined for many different device models.

However it is sometimes undesirable for a particular employee of the publisher to have the ability to sign code downloads for many device models. This may be a concern for employees within the company or publisher that makes the corresponding devices and is even more of a concern for employees of a cable operator publishing new code which also desires to build and then sign code images using the same DOCSIS code signing format using a signing key which belongs to the device manufacturer.

What is needed is a system and method which restricts the ability to sign code based upon the status of a particular employee and or the devices for which the code is intended to be installed. Described below is a solution based on a code signing server which has different configurations assigned to employees which can sign code for any device vs. employees usually of other companies that are restricted go signing code only for specific configurations corresponding to specific device models.

To address the requirements described above the present invention discloses a method and apparatus for signing data. In one embodiment the method comprises receiving from a requestor a request to sign the data according to a requested configuration selected from a first configuration in which the data is for use with any of the set of devices and a second configuration in which the data is for use only with a subset of a set of devices modifying the data according to the requested configuration generating a data signature using the modified data and transmitting the generated data signature to the requestor. Another embodiment is evidenced by a processor having a memory storing instructions for performing the foregoing operations.

In the following description reference is made to the accompanying drawings which form a part hereof and which is shown by way of illustration several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.

As described above some code signing formats are accepted by many different device models. For example DOCSIS code signing as specified in Data Over Cable Service Interface Specifications DOCSIS 3.0 Security Specification CM SP SECv3.0 I04 070518 by CableLabs hereby incorporated by reference herein and hereinafter alternatively referred to as DOCSIS specification is utilized in a number of different CPE devices which may include an embedded cable modem and other functionality such as an STB or a VoIP gateway.

For all types of devices that include a DOCSIS cable modem a secure code download may be signed using the DOCSIS format defined in the DOCSIS specification. Furthermore each company is generally issued one CVC by CABLELABS for the purpose of DOCSIS code signing. Therefore a single signing key is utilized in that case to sign code for many different device models.

Previously device manufacturers have been the only entities signing code for their devices. In such situations the single code signing key provided to manufacturers may be shared across many device models. This may be a concern for employees within the company that makes the corresponding devices. Also network operators who s systems use such devices may author code image of their own for installation on the manufacturer s devices and want to use the manufacturer s code signing key to safely deliver the code to the devices using the same DOCSIS code signing format.

This specification describes a system and method that even with a common signing key enables restrictions to be placed upon code signing such that signed images work only on specific device models. This allows code signing paradigms to be implemented in which some individuals within the publisher or company may have the authorization to sign code that will work on all of the models which share the same signing key while other individuals will only be able to sign code images for specific device models.

Target devices may be delineated into one or more sets of target devices and each set of target devices may be further delineated into one or more subsets of target devices . A target device subset may be defined as a group of target devices with similar characteristics relevant to the code image to be provided to the target device . Target devices may be grouped into subsets for example by model number serial number range or software versions. Simply for purposes of illustration the following discussion defines the target device sets according to two model types Model A of which target device A is a member and target device B is not which are intended to accept and execute all code images signed by both privileged and unprivileged clients and Model B of which target device B is a member and target device A is not which are intended to accept only code images signed by privileged clients .

The following embodiments take advantage of an architecture where code signing is done on a secure CSS and where different users are authorized to sign the code image using different code signing configurations on that same server . Some code signing configurations result in signed images which work on all target devices while others are signed in such a manner that they will only execute successfully on selected subsets of the target devices for which a specific developer or requestor is authorized.

The process beings with an optional login procedure wherein the privileged client A logs into a CSS by transmitting a login request as shown in block . The login request may comprise credentials such as an identifier of the privileged client A making the login request user ID and a secret password. The use of a user ID and password prevents unauthorized users from using the CSS and in particular as a privileged client A. The privileged client A may log in to the DSS over a web interface using a standard browser like INTERNET EXPLORER GOOGLE CHROME or FIREFOX. Alternatively the login may be accomplished via an online transaction with a client application and without any user interaction.

The CSS receives the login request as shown in block checks the login credentials to verify that the privileged client A is authorized to request signature of an code image. If the privileged client A is so authorized the CSS transmits a message to the privileged client A indicating that the privileged client s login credentials have been accepted. This message is received by the privileged client A as shown in block . After verifying the privileged client A credentials of the user the DSS enters a state where it will accept code signing requests but only based on code signing configurations for which the client associated with the user ID and password is authorized. In the example presented in the client is a privileged client A and is authorized to request signature of code that is executable on all target devices .

The privileged client A then transmits a request to sign the code as shown in block . In one embodiment the request includes configuration data e.g. ConfigN describing a requested configuration which determines which code signing format and code signing key to be used in signing the code image.

The configuration data received from the clients may include a detailed description of whether the code is to be modified and how such modifications are to be made to the code before signing or may simply comprise a flag number or other artifice designating that a particular configuration be used with the detailed description of how the code is to be modified and signed obtained from a source other than the client .

In one embodiment the requested configuration is selected to be either a first configuration e.g. Config in which the code is intended for use with any of the set of target devices and a second configuration e.g. Config in which the code is for use with only a subset of a set of target devices . For example by associating Config with the request to sign the code e.g. by providing it with the request the client may make a request to sign a code image which can run on any target device model which accepts the specific signing key used in signing the code image e.g. on any DOCSIS CPE device belonging to a specific manufacturer . Typically such a request will only be fulfilled by the CSS if the client making the request is internal to the device manufacturer or privileged to do so and hence a privileged client A .

The privileged client A also provides the CSS access to the code to be signed either by transmitting it along with or in conjunction with the request itself or by transmitting an web address or other information that the CSS may use to access the code image to be signed.

In block the CSS receives the signature request. The CSS checks to determine if the client that transmitted the request is a client with sufficient privileges for the requested configuration. If the requesting client has insufficient privileges the request is denied. However if the requesting client has sufficient privileges e.g. the client is a privileged client A the CSS generates the requested signature according to the requested configuration.

The CSS generates the code signature by modifying the code to be signed according to the configuration requested by the client which may include leaving the code unmodified if the requested configuration indicates the code should be signed in unmodified form and generating the code signature using the potentially modified code.

In the example illustrated in the requesting client A is privileged and therefore authorized to issue signed code to either all of the target devices or a subset of such devices. Further the privileged client A has requested a configuration Config that indicates that the privileged client A desires that the code image it is submitting for signature is intended to be executable by all of the set of target devices and not merely the subset of devices . Responding to the privileged client s request the CSS signs the code code image without modification to create the signature signature . Since all of the devices are able to execute the unmodified code the CSS has thus created a signature that can be used to provide executable code to all device types.

The CSS returns the computed code signature to the privileged client A as shown in block . Although the CSS may also return the code image for example by concatenating the code image with the signature it is sufficient to return just the computed code signature since the code image is already known to the client A and was not modified by the server .

In block the privileged client A receives the signature. Then the code image together with the code signature is installed or uploaded to a code download server CDS typically controller or managed by a network operator. The signed image and code signature are then stored by the CDS for later provision to requesting target devices .

In block A target device A which is of a Model A type requests the code image. That request is received by the CDS in block and in response the CDS transmits the code and signature to the target device A as shown in block . That code and signature is received by target device A as shown in block A. The target device A verifies the code signature and if the code signature is correctly verified executes new code as shown in blocks A and A.

In block B target device B which is of a Model B type requests the code image. That request is also received by the CDS in block and in response the CDS transmits the code and signature to the target device B as shown in block . The requested code and signature is received by the target device B as shown in block B. Target device B verifies the code signature and if the code signature is valid executes the new code image as shown in blocks B and B.

Both target device types Model A and Model B can execute the code image because the code image was intended for use in by all target devices and the code image does not include any additions or modifications that will only be understood by a subset of the target devices A. An embodiment wherein the client is not permitted to provide code to all of the target devices but rather only a subset of such devices such as target device A but not target device B is discussed below.

Unprivileged client B may be an external user that is for example employed by or otherwise affiliated with the network operator that controls the CDS but has does not have privileges which permit them to provide code images to all of the target devices but rather only a subset of such target devices. For example some of the target device models may be targeted to competing network operators and it may be inappropriate to enable this external user for signing code that works in those target device models. For example it is possible for two network operators to use the same target devices to provide service to their network subscribers. However it is undesirable for subscribers of network A to be able to install a copy of software image intended for the target devices of network B on their devices. This is because different network operators may have different functional limitations and requirements e.g. bandwidth that are enforced by the software installed on the target devices . Further operators of target devices also may include their own branding and advertising for example target devices may be subscriber configurable using administrative pages that have network operator specific interfaces or splash screens.

The process beings with an optional login procedure wherein the unprivileged client B logs into a CSS by transmitting a login request as shown in block . The login request may comprise credentials such as an identifier of the unprivileged client B making the login request user ID and a secret password. The unprivileged client B may log in to the CSS over a web interface using a standard browser like IE or Firefox. Alternatively the login may be accomplished via an online transaction with a unprivileged client B application and without any user interaction.

The CSS receives the login request as shown in block checks the login credentials to verify that the unprivileged client B is authorized to request signature of an image. If the unprivileged client B is authorized the CSS transmits a message to the unprivileged client B indicating that the login credentials have been accepted. This message is received by the unprivileged client B as shown in block . After verifying the unprivileged client B credentials of the user the CSS enters a state where it will accept code signing requests but only based on code signing configurations for which a particular user of the unprivileged client B is authorized.

In block the unprivileged client B submits a software image code image to the CSS for signing and specifies a code signing configuration Config . This specific configuration Config specifies that the code image to be signed is intended for only a particular subset of the set of target devices . As described further below this is implemented by the CSS modifying the code to add additional header information described below that can only be properly interpreted by the subset of the target devices that are intended to receive the code image. The additional header information may include the name of the network operator controlling the CDS .

This request is received by the CSS as shown in block . The CSS examines the request to determine the requested configuration and determine if the requesting client B has sufficient privileges to have the code signed using the requested configuration. Once again if the requesting client has insufficient privileges to request the signing of the code according to the requested configuration the request is denied. If however the requesting client has sufficient privileges to request signing of the code according to the requested configuration the code is signed according to that requested configuration.

In the example illustrated in the unprivileged client B has requested that the code image Code Image be signed according to a second configuration Config thus indicating that the code image is to be executable by only a subset of the set of target devices e.g. those of Model A . The CSS reads the requested configuration and in response the CSS modifies the code image thereby creating Code Image such that only those subset of target devices can recognize and execute the code image. In one embodiment the code image is modified by adding data to the code image such as an additional header HDR . That additional header HDR may also include an identifier of the unprivileged client B such as an operator name oper . The code image may be modified by adding the HDR to the code image in a number of different ways. For example the HDR may be pre pended at the beginning of the code image or may be in the middle or at the end of the code image as well.

For additional flexibility the request that the code image be signed may include a model designation e.g. Model A indicating to the CSS that the code should be restricted only to the indicated model. Further a code signing configuration on CSS may designate a plurality of allowable models e.g. Model X and Y in addition to Model A in which case the CSS accepts and signs code requests for Config that specify any of Models A X or Y. This allows the administrator to occasionally add a new model to an existing configuration if the policy allows sharing the code image between such multiple models.

Hence the HDR is be added to the code image such that it is understood by target devices it is intended for e.g. target devices A that are members of the subset of devices such as those that are Model A but not understood by target devices the image is not intended for. For example the HDR may be added to the code image in a manner e.g. location and or protocol such that devices of type Model A target device A understand and operate on e.g. execute the code but devices of another type e.g. Model B or target device B do not understand and cannot operate on the code for example causing a crash or a software or hardware fault when the execution of the code is attempted . Model A target devices A may be newer devices that can recognize the added HDR in the code image as added data while Model B target devices B may be older devices which are not designed to be recognize the added HDR as added data and attempt to execute that data as if it were instructions as described above. As a result the added HDR would cause the model B target device B to operate incorrectly or crash.

The HDR may also comprise data that that is necessary for the use of the code image. For example the code image may comprise encrypted instructions and the HDR may include data that only the intended target devices can use to decrypt or otherwise decode the those encrypted instructions.

Returning to the CSS then computes the signature over the modified code image Code Image and transmits or returns it back to the unprivileged client B as shown in block . In one embodiment the CSS returns modified code image e.g. Code Image concatenated together with the signature computed over the modified code image. But the CSS may instead return just the signature and not the modified code image since the unprivileged client B should be able to construct the same modified code image code as well.

The code signature Signature along with the modified code image code image which includes the HDR with the value oper is then transmitted to the CDS for storage. Each target device can thereafter obtain a download of the new code from the CDS . Typically the CDS is managed and operated by the network operator.

In block A target device A which is of Model A transmits a request for an updated code image as shown in block A. That request may include information describing the target device A making the request such as its model designation or serial number. That request is received by the CDS as shown in block . The CDS then transmits the requested code image modified to include the HDR and signature generated from the modified code image to the requesting target device A as shown in block . In block A the target device A receives the modified code image and signature signature .

Target device A then verifies the code signature as illustrated in block A. If verification fails target device A does not install or execute the modified code image . If the signature is verified target device A Model A examines the code image to first check the HDR to make sure that it includes a correct or expected network operator name oper . After successful verification that the HDR includes the expected operator name the target device A successfully executes the new code image . Successful execution is made possible because target device A is configured to examine the received code image to extract and properly process the information in the HDR . For example if the HDR simply comprises the expected network operator name oper appended N bytes at the beginning of the code image target devices A of Model A may configured to regard the first N bytes as referencing the operator name and read those first N bytes as data instead of one or more instruction s then execute the remaining bytes of the code image normally.

In block B target device B Model B transmits a request for an updated code image. Likewise that request may include information describing the target device making the request such as its model designation or serial number. That request is received by the CDS as shown in block . The CDS transmits the requested code image modified to include the HDR and signature generated from the modified HDR to the requesting target device B as shown in block . In block B the target device B receives the code image and signature.

As was the case with target device A target device B then verifies the code signature as illustrated in block B. If verification fails target device B does not install or execute the modified code image. If the signature is verified target device B Model B attempts execution of the modified code image that includes HDR because target device B is not configured e.g. via logic or instructions to check the HDR to assure that identifies the proper operator oper and or to refrain from executing the HDR as if it were one of the instructions of the software image. Since target device B is not one of the target devices A that are configured to expect and properly process the code image modified to include the HDR target device B simply interprets the HDR portion of the modified code image as just part of the code image. Target device B eventually attempts executing HDR as if it were processor instructions which results in an exception which will likely halt or reset the device. If desired the HDR can be inserted into a portion of the code image that assures halting or resetting of the device or some other desired action. This is because the modified signed code image was only intended to run on target devices A of Model A. The attempt to load and execute that code image onto a target device B of Model B was unauthorized and therefore as intended resulted in that device halting or resetting.

Note that Model A target devices A which are configured understand that a portion of the code image includes and HDR and to properly process that HDR still check the HDR contents to make sure that the received code image was obtained from an expected network operator and not a different and perhaps untrusted source or network operator. If the network operator name included within the HDR e.g. oper doesn t match the expected network operator name then the modified code image is still rejected by that device and not executed even though such execution would not cause a crash or other processor fault.

The inclusion of the HDR within the signed code image can be used to prevent the code image from executing on legacy devices such as Model B devices target device B that are not aware of the new modified code image format that include the HDR and are not able to explicitly validate if the code image was signed with correct parameters that match a model of a specific device.

In the foregoing example the HDR included the network operator name so that the target device A could verify that the code image was from the network operator. However the network operator name is only one example of attributes that could be used. For example in addition to or in the alternative to the operator name the HDR may include a model designation e.g. Model A . Devices configured to search for and extract the HDR from the code image can verify that their device model matches the model name included in the HDR instead of or in addition to verifying the operator name.

For some devices after the code signature is already validated a secondary integrity check may be made to verify a checksum such as a CRC32 or a magic number predefined pattern at a fixed offset before executing the code image itself. This secondary check may performed to assure that the code image is of correct type and was built correctly for the particular target device model it is delivered to before execution of the code image is attempted. If this secondary check fails then the device will reject the newly downloaded code image and the code image will not be permanently stored or executed by the device even if the signature check passes.

In this case the extra header HDR may be intentionally placed at a memory location or offset used by legacy devices e.g. target devices B of Model B to perform this additional integrity check. For example when the code image is built a checksum may be calculated over the Instructions area that does not include HDR . But HDR is then added in such a way that a device validating the same checksum will try to calculate it over both HDR and the Instructions area which will fail since the original checksum value was calculated over the different set of data.

Similarly the operations depicted in the target device A transmits a request to receive the code image from the CDS as shown in block A. The CDS receives the request and transmits the code and signature to the target device A as shown in blocks and . The target device A receives the code image and signature and verifies the signature as shown in blocks A A.

After signature validation the code image is validated for integrity e.g. the code image is subject to an operation with the result compared to the checksum or integrity value and for a correct image type as shown in block A. In this case the signed image doesn t have HDR and this check on a new device passes. After this step if the code image was just downloaded in temporary memory it may be saved persistently in the device and executed as shown in block A.

A similar process occurs with respect to target device B. After requesting and receiving the code image and signature as shown in blocks B and B the received signature is validated as shown in block B. Next the code image is validated for integrity e.g. verified using the integrity value disposed in a code image portion such as the header or footer fields and for a correct image type. In this case the signed image doesn t have HDR and this check on a legacy device also passes. After this step if the code image was just downloaded it is also persistently stored in the device for execution.

Similarly the operations depicted in target device A transmits a request to receive the code image from the CDS as shown in block A. The CDS receives the request and transmits the code and signature to the target device A as shown in blocks and . The target device A receives the code image and signature and verifies the signature as shown in blocks A A.

After signature validation the code image is validated for integrity e.g. a checksum is generated and verified against the included checksum value and for a correct image type. In this case the signed image includes the HDR but this is a new device that knows the modified code image format and is able to skip HDR and still verify all the necessary fields. After this step if the code image was temporarily downloaded it will be saved persistently in the device for later execution. These operations are depicted in blocks A and B.

Also similarly the operations depicted in target device B transmits a request to receive the code image from the CDS as shown in block B. The CDS receives the request and transmits the code and signature to the target device as shown in blocks and . The target device B receives the code image and signature and verifies the signature as shown in blocks B B.

After signature validation the code image header or footer fields are validated for integrity e.g. checksum is verified and for a correct image type. In this case the signed image does include HDR in a location that interferes with this check and so the code image is rejected by the legacy device this is shown in block B. Because of the rejection shown in block B the code image is not saved in the legacy device. Instead the code image is erased and the device will resume its normal operation with the previously installed code image.

In one embodiment the computer operates by the general purpose processor A performing instructions defined by the computer program under control of an operating system . The computer program and or the operating system may be stored in the memory and may interface with the user and or other devices to accept input and commands and based on such input and commands and the instructions defined by the computer program and operating system to provide output and results.

Output results may be presented on the display or provided to another device for presentation or further processing or action. In one embodiment the display comprises a liquid crystal display LCD having a plurality of separately addressable pixels formed by liquid crystals. Each pixel of the display changes to an opaque or translucent state to form a part of the image on the display in response to the data or information generated by the processor from the application of the instructions of the computer program and or operating system to the input and commands. Other display types also include picture elements that change state in order to create the image presented on the display . The image may be provided through a graphical user interface GUI module A. Although the GUI module A is depicted as a separate module the instructions performing the GUI functions can be resident or distributed in the operating system the computer program or implemented with special purpose memory and processors.

Some or all of the operations performed by the computer according to the computer program instructions may be implemented in a special purpose processor B. In this embodiment some or all of the computer program instructions may be implemented via firmware instructions stored in a read only memory ROM a programmable read only memory PROM or flash memory within the special purpose processor B or in memory . The special purpose processor B may also be hardwired through circuit design to perform some or all of the operations to implement the present invention. Further the special purpose processor B may be a hybrid processor which includes dedicated circuitry for performing a subset of functions and other circuits for performing more general functions such as responding to computer program instructions. In one embodiment the special purpose processor is an application specific integrated circuit ASIC .

The computer may also implement a compiler which allows an application program written in a programming language such as COBOL C FORTRAN or other language to be translated into processor readable code. After completion the application or computer program accesses and manipulates data accepted from I O devices and stored in the memory of the computer using the relationships and logic that was generated using the compiler .

The computer also optionally comprises an external communication device such as a modem satellite link Ethernet card or other device for accepting input from and providing output to other computers.

In one embodiment instructions implementing the operating system the computer program and or the compiler are tangibly embodied in a computer readable medium e.g. data storage device which could include one or more fixed or removable data storage devices such as a zip drive floppy disc drive hard drive CD ROM drive tape drive or a flash drive. Further the operating system and the computer program are comprised of computer program instructions which when accessed read and executed by the computer causes the computer to perform the steps necessary to implement and or use the present invention or to load the program of instructions into a memory thus creating a special purpose data structure causing the computer to operate as a specially programmed computer executing the method steps described herein. Computer program and or operating instructions may also be tangibly embodied in memory and or data communications devices thereby making a computer program product or article of manufacture according to the invention. As such the terms article of manufacture program storage device and computer program product or computer readable storage device as used herein are intended to encompass a computer program accessible from any computer readable device or media.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with the computer .

Although the term computer is referred to herein it is understood that the computer may include portable devices such as cellphones portable MP3 players video game consoles notebook computers pocket computers or any other device with suitable processing communication and input output capability.

The foregoing describes a solution for code signing with a common signing key across many different device models such that legacy devices which do not understand the new code signing format will crash while trying to execute a signed code image targeted only for new device models with specific parameters.

This addresses a specific problem where a device manufacturer may no longer be the only entity requesting that code intended for it s devices be signed with the manufacturer s signing key that might be used across several models. The foregoing solution permits network operators to perform such code signing but only for the new devices in which network operator is specifically interested. Legacy devices which do not understand the additional information in the signed code image the HDR will encounter the HDR while trying to execute the code image it as if the HDR were one or more processor instructions causing such devices to crash.

At the same time the HDR contains parameters such as the operator name COMCAST for example that are checked by newer devices. If in the future device manufacturers were asked to provide code signing capabilities to other network operators such as COX or CHARTER each such network operator would have it s own specific operator name inside HDR and a device configured for one operator would reject code signed with another operator s name. This would be enforced by providing each operator access only to their own configuration with their own name on the code signing server .

Alternatively it may be possible on some legacy devices to reject a code image with HDR after the signature check while the device checks a newly downloaded code image for integrity or to make sure the header or footer fields match this device model. HDR can be placed in such a location in the code image such that legacy devices will fail this check and will not even save the downloaded code update. This allows legacy devices to reject code images that are not intended for that device model more gracefully than the first alternative.

This concludes the description of the preferred embodiments of the present invention. The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching.

For example although the foregoing embodiments are described for purposes of illustration as referring to the signing and transmission of software code or code images the same procedures may be used to transmit data of any time that is used or operated on by the target device upon receipt to generate output results. Hence the illustrated CSS may more generally comprise a data signing server and the CDS may more generally comprise a data download server. Further although reference is made below to the execution of code in some cases unsuccessfully analogous results may be obtained by using the target devices to operate on signed data in some cases unsuccessfully .

It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the apparatus and method of the invention. Since many embodiments of the invention can be made without departing from the scope of the invention the invention resides in the claims hereinafter appended.

