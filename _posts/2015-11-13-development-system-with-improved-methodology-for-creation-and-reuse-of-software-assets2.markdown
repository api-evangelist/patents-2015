---

title: Development system with improved methodology for creation and reuse of software assets
abstract: A development system with improved methodology for creation and reuse of software assets is shown and described. In one embodiment, for example, in a development system, a method is described for facilitating creation of a reusable application, the method comprises steps of: during development of the application, capturing knowledge and intent of the application's original developer alongside source code created for the application; producing an archival module storing the source code for the application together with metadata capturing the knowledge and intent of the original developer, the metadata including at least one script guiding subsequent developers in use and modification of the source code for the application; and consuming the archival module by a follow-on developer, including executing the at least one script for facilitating creation of a reusable version of the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600246&OS=09600246&RS=09600246
owner: Embarcadero Technologies, Inc.
number: 09600246
owner_city: Austin
owner_country: US
publication_date: 20151113
---
This application claims priority to and is a continuation of the co pending patent application Ser. No. 12 388 433 entitled DEVELOPMENT SYSTEM WITH IMPROVED METHODOLOGY FOR CREATION AND REUSE OF SOFTWARE ASSETS with filing date Feb. 18 2009 by Ravikumar Ramanathan and assigned to the assignee of the present invention the disclosure of which is hereby incorporated herein by reference in its entirety.

The application with Ser. No. 12 388 433 claims priority to the then co pending U.S. Provisional Patent Application with Ser. No. 61 030 209 filed Feb. 20 2008 entitled Development System with Improved Methodology for Creation and Reuse of Software Assets and assigned to the assignee of the present application. The application with Ser. No. 12 388 433 incorporated the Provisional Patent Application 61 030 209 in its entirety by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Computer Program Listing Appendix under Sec. 1.52 e This application includes a transmittal under 37 C.F.R. Sec. 1.52 e of a Computer Program Listing Appendix. The Appendix which comprises text file s that are IBM PC machine and Microsoft Windows Operating System compatible includes the below listed file s . All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.

Object Description SourceCode.txt size 80427 Bytes created Feb. 18 2009 3 23 58 PM Object ID File No. 1 Object Contents Source code.

The present invention relates generally to the creation of computer programs and more particularly to a development system with methodologies for capturing and facilitating reuse of software development knowledge and intent.

Before a digital computer may accomplish a desired task it must receive an appropriate set of instructions. Executed by the computer s microprocessor these instructions collectively referred to as a computer program direct the operation of the computer. Expectedly the computer must understand the instructions which it receives before it may undertake the specified activity.

Owing to their digital nature computers essentially only understand machine code i.e. the low level minute instructions for performing specific tasks the sequence of ones and zeros that are interpreted as specific instructions by the computer s microprocessor. Since machine language or machine code is the only language computers actually understand all other programming languages represent ways of structuring human language so that humans can get computers to perform specific tasks.

While it is possible for humans to compose meaningful programs in machine code practically all software development today employs one or more of the available programming languages. The most widely used programming languages are the high level languages such as C C Pascal Java or more recently Perl PHP and C . These languages allow data structures and algorithms to be expressed in a style of writing that is easily read and understood by fellow programmers.

A program called a compiler translates these instructions into the requisite machine language. In the context of this translation the program written in the high level language is called the source code or source program. The ultimate output of the compiler is a compiled module such as a compiled C object module which includes instructions for execution ultimately by a target processor or a compiled Java class which includes bytecodes for execution ultimately by a Java virtual machine. A Java compiler generates platform neutral bytecodes an architecturally neutral intermediate format designed for deploying application code efficiently to multiple platforms.

Integrated development environments such as Borland s JBuilder and C Builder are the preferred application development environments for quickly creating production applications. Such environments are characterized by an integrated development environment IDE providing a form painter a property getter setter manager inspector a project manager a tool palette with objects which the user can drag and drop on forms an editor a debugger and a compiler. In general operation the user paints objects on one or more forms using the form painter. Attributes and properties of the objects on the forms can be modified using the property manager or inspector. In conjunction with this operation the user attaches or associates program code with particular objects on the screen e.g. button object . Typically code is generated by the IDE in response to user actions in the form painter and the user then manipulates the generated code using the editor. Changes made by the user to code in the editor are reflected in the form painter and vice versa. After the program code has been developed the compiler is used to generate binary code e.g. Java bytecode for execution on a machine e.g. a Java virtual machine .

During the process of software development the developer uses the IDE to write a large amount of code. As a result most projects of even modest complexity will result in the creation of large sections of new source code. As software development today has remained a time and resource intensive task there is great interest in improving the efficiency of developers. Most of the efforts to date have focused on improving reusability that is the reuse of source code. For example application generators have long been used to generate scaffolding or boilerplate sections of code i.e. recurring common code functionality which may be dumped into a project in the IDE. Notwithstanding the efficiency gain realized by using application generators software development still remains a resource consuming task. Thus there is much interest in further improving the software development process.

Today the development of any particular program is heavily dependent on the knowledge of the individual or individuals doing the actual development. A persistent problem faced by all developers is how to transfer knowledge between team members such as transferring an architect s intent in code for subsequent developers to build on. Stating the problem more generally prior art development systems fail to capture developer intent and thus lose the opportunity to allow the developer s knowledge to be reused. If one member of the team developed special knowledge that knowledge remains in the developer s head and is not shared through the IDE with other team members. This leads to a situation where developers are constantly reinventing the same wheel. Once the developer leaves the team for example it is not uncommon for that developer s code to essentially become a black box that is code whose functionality is poorly understood by other team members. In that scenario the reusability of the code may be limited. In the real world this problem frequently arises when team members specialize in one area e.g. implementing the Web interface of an application need to know where to fix a problem in another area e.g. fixing the persistence layer . For instance where that is at what specific code snippets and reusable components do the Web interface team members even begin Do they have appropriate access to those items or are those items even available anymore 

Consider how much other people s code a Java developer faces. In Java programs it is not uncommon for 80 of the code to be support code i.e. scaffolding or boilerplate code with only about 20 of the code reflecting the program logic that the developer really wanted to write. Using a traditional IDE the developer can navigate the project in a file based hierarchical manner i.e. projects folders files etc. . However since the ratio between support code and custom code has become so lopsided the task of navigating the code in an IDE becomes burdensome. What the developer really wants is a sensible way to navigate the code in an application centric manner i.e. accounting payment system etc. not an IDE centric manner.

The fact of the matter is that applications are becoming more complex and involve increasing numbers of layers and frameworks. As a result developers are obliged to become specialists with detailed but tightly circumscribed knowledge of a small cadre of technologies that inhibits expertise or even exposure to technologies in other parts of the same application. The result is that knowledge becomes increasingly siloed and knowledge transfer is difficult and at times nearly impossible. Even within the same subteam members can find it difficult to leave useful bread crumb trails for developers who will come behind them. Likewise they have difficulty mining the knowledge of existing team members unless they work geographically close enough and can ask in person. As projects become more complex this problem emerges as a gating factor to timely product delivery correct functionality responsiveness to changing requirements and crucially the ability to promptly and properly resolve defects. Despite being pervasive the problem is little understood and until now inadequately addressed by prior art developer tools.

A development system with improved methodology for creation and reuse of software assets is shown and described. In one embodiment for example in a development system a method of the present invention is described for facilitating creation of a reusable application the method comprises steps of during development of the application capturing knowledge and intent of the application s original developer alongside source code created for the application producing an archival module storing the source code for the application together with metadata capturing the knowledge and intent of the original developer the metadata including at least one script guiding subsequent developers in use and modification of the source code for the application and consuming the archival module by a follow on developer including executing the at least one script for facilitating creation of a reusable version of the application.

In another embodiment for example a development system of the present invention that facilitates creation of a reusable application is described that comprises a development system operating on a computer having at least a processor and a memory a producer module for recording knowledge and intent of the application s original developer as the developer creates source code for the application and for storing the source code for the application together with metadata capturing the knowledge and intent of the original developer the metadata comprising information sufficient to facilitate reuse of the source code by subsequent developers and a module for consuming the source code and metadata by a follow on developer including executing based on the metadata instructions that specify coding sequences that facilitate creation of a reusable version of the application.

In yet another embodiment for example in a development system a method of the present invention is described for guiding development of an application by a plurality of developers the method comprises steps of during development of an application by a first developer capturing meta data describing instructions of the first developer for guiding subsequent developers in development and modification of the application as the first developer creates source code for the application exporting the application and captured meta data into at least one module which associates the application source code with instructions from the first developer and executing the at least one module during subsequent development and modification of the application by a second developer including executing instructions of the first developer during development and modification of the application source code.

The following definitions are offered for purposes of illustration not limitation in order to assist with understanding the discussion that follows.

Bytecode A virtual machine executes virtual machine low level code instructions called bytecodes. Both the Sun Microsystems Java virtual machine and the Microsoft .NET virtual machine provide a compiler to transform the respective source program i.e. a Java program or a C program respectively into virtual machine bytecodes.

Compiler A compiler is a program which translates source code into binary code to be executed by a computer. The compiler derives its name from the way it works looking at the entire piece of source code and collecting and reorganizing the instructions. Thus a compiler differs from an interpreter which analyzes and executes each line of code in succession without looking at the entire program. A Java compiler translates source code written in the Java programming language into bytecode for the Java virtual machine.

DOM The Document Object Model DOM is a platform and language neutral interface that allows programs and scripts to dynamically access and update the content structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page. For further information regarding the Document Object Model see e.g. Document Object Model DOM Activity Statement available from the World Wide Web consortium W3C the disclosure of which is hereby incorporated by reference. A copy of this document is available via the Internet e.g. currently at www.w3.org DOM .

Eclipse A multi language software development platform available from The Eclipse Foundation eclipse.org that includes an IDE and a plug in system to extend it. It is written primarily in Java and is used to develop applications in this language and by means of the various plug ins in other languages as well.

HTML HTML stands for HyperText Markup Language the authoring language used to create documents on the World Wide Web. HTML defines the structure and layout of a Web document by using a variety of tags and attributes. For further description of HTML see e.g. HTML 4.01 Specification a World Wide Web consortium recommendation dated Dec. 24 1999 the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet e.g. currently at www.w3.org TR REC htm140 .

Java Java is a general purpose programming language developed by Sun Microsystems. Java is an object oriented language similar to C but simplified to eliminate language features that cause common programming errors. Java source code files files with a java extension are compiled into a format called bytecode files with a class extension which can then be executed by a Java interpreter. Compiled Java code can run on most computers because Java interpreters and runtime environments known as Java virtual machines VMs exist for most operating systems including UNIX the Macintosh OS and Windows. Bytecode can also be converted directly into machine language instructions by a just in time JIT compiler. Further description of the Java Language environment can be found in the technical trade and patent literature see e.g. Gosling J. et al. The Java Language Environment A White Paper Sun Microsystems Computer Company October 1995 the disclosure of which is hereby incorporated by reference. For additional information on the Java programming language e.g. version 2 see e.g. Java 2 SDK Standard Edition Documentation version 1.4.2 from Sun Microsystems the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet e.g. currently at java.sun.com j2se 1.4.2 docs index.html .

JavaScript JavaScript was designed by Netscape as an easy to use object oriented scripting language that serves as an adjunct to the Java programming language. JavaScript is a small lightweight language that is designed to be embedded in other products and applications such as Web browsers. Inside a host environment JavaScript can be connected to the objects of its environment to provide programmatic control over such objects. JavaScript code can be added to standard HTML pages to create interactive documents and has found considerable use in the creation of interactive Web based forms. Most modern browsers including those from Microsoft and Netscape contain JavaScript support. For additional information on JavaScript see e.g. Core JavaScript Guide 1.5 from Netscape the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet e.g. currently at devedge.netscape.com .

Network A network is a group of two or more systems linked together. There are many types of computer networks including local area networks LANs virtual private networks VPNs metropolitan area networks MANs campus area networks CANs and wide area networks WANs including the Internet. As used herein the term network refers broadly to any group of two or more computer systems or devices that are linked together from time to time or permanently .

TCP TCP stands for Transmission Control Protocol. TCP is one of the main protocols in TCP IP networks. Whereas the IP protocol deals only with packets TCP enables two hosts to establish a connection and exchange streams of data. TCP guarantees delivery of data and also guarantees that packets will be delivered in the same order in which they were sent. For an introduction to TCP see e.g. RFC 793 Transmission Control Program DARPA Internet Program Protocol Specification the disclosure of which is hereby incorporated by reference. A copy of RFC 793 is available via the Internet e.g. currently at www.ietf.org rfc rfc793.txt .

TCP IP TCP IP stands for Transmission Control Protocol Internet Protocol the suite of communications protocols used to connect hosts on the Internet. TCP IP uses several protocols the two main ones being TCP and IP. TCP IP is built into the UNIX operating system and is used by the Internet making it the de facto standard for transmitting data over networks. For an introduction to TCP IP see e.g. RFC 1180 A TCP IP Tutorial the disclosure of which is hereby incorporated by reference. A copy of RFC 1180 is available via the Internet e.g. currently at www.ietf.org rfc rfc1180.txt .

UML UML standards for the Unified Modeling Language a standard graphical language for modeling object oriented systems. For further information on UML see e.g. OMG Unified Modeling Language Specification Version 1.5 March 2003 available from the Object Management Group Inc. the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet e.g. currently at www.omg.org .

Winsock Windows Sockets 2 Winsock is a Microsoft provided interface that enables programmers to create advanced Internet intranet and other network capable applications to transmit application data across the wire independent of the network protocol being used. With Winsock programmers are provided access to advanced Microsoft Windows networking capabilities such as multicast and Quality of Service QOS . Winsock follows the Windows Open System Architecture WOSA model it defines a standard service provider interface SPI between the application programming interface API with its exported functions and the protocol stacks. It uses the sockets paradigm that was first popularized by Berkeley Software Distribution BSD UNIX. It was later adapted for Windows in Windows Sockets 1.1 with which Windows Sockets 2 applications are backward compatible. Winsock programming previously centered around TCP IP. Some programming practices that worked with TCP IP do not work with every protocol. As a result the Windows Sockets 2 API adds functions where necessary to handle several protocols. For further information regarding Winsock see e.g. Winsock Reference available from Microsoft Corporation the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet e.g. currently at msdn.microsoft.com library defaultasp url library en us winsock winsock winsock reference.asp .

XML XML stands for Extensible Markup Language a specification developed by the World Wide Web Consortium W3C . XML is a pared down version of the Standard Generalized Markup Language SGML a system for organizing and tagging elements of a document. XML is designed especially for Web documents. It allows designers to create their own customized tags enabling the definition transmission validation and interpretation of data between applications and between organizations. For further description of XML see e.g. Extensible Markup Language XML 1.0 2nd Edition Oct. 6 2000 a recommended specification from the W3C the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet e.g. currently at www.w3.org TR REC xml .

Referring to the figures exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention which is implemented in desktop and or server software e.g. driver application or the like operating in an Internet connected environment running under an operating system such as the Microsoft Windows operating system. The present invention however is not limited to any one particular application or any particular environment. Instead those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms including Macintosh Linux Solaris UNIX FreeBSD and the like. Therefore the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation the corresponding apparatus element may be configured in hardware software firmware or combinations thereof.

The present invention may be implemented on a conventional or general purpose computer system such as an IBM compatible personal computer PC or server computer. is a very general block diagram of a computer system e.g. an IBM compatible system in which software implemented processes of the present invention may be embodied. As shown system comprises a central processing unit s CPU or processor s coupled to a random access memory RAM a read only memory ROM a keyboard a printer a pointing device a display or video adapter connected to a display device a removable mass storage device e.g. floppy disk CD ROM CD R CD RW DVD or the like a fixed mass storage device e.g. hard disk a communication COMM port s or interface s a modem and a network interface card NIC or controller e.g. Ethernet . Although not shown separately a real time system clock is included with the system in a conventional manner.

CPU comprises a processor of the Intel Pentium family of microprocessors. However any other suitable processor may be utilized for implementing the present invention. The CPU communicates with other components of the system via a bi directional system bus including any necessary input output I O controller circuitry and other glue logic . The bus which includes address lines for addressing system memory provides data transfer between and among the various components. Description of Pentium class microprocessors and their instruction set bus architecture and control lines is available from Intel Corporation of Santa Clara Calif. Random access memory serves as the working memory for the CPU . In a typical configuration RAM of sixty four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read only memory ROM contains the basic input output system code BIOS a set of low level routines in the ROM that application programs and the operating systems can use to interact with the hardware including reading characters from the keyboard outputting characters to printers and so forth.

Mass storage devices provide persistent storage on fixed and removable media such as magnetic optical or magnetic optical storage systems flash memory or any other available mass storage technology. The mass storage may be shared on a network or it may be a dedicated mass storage. As shown in fixed storage stores a body of program and data for directing operation of the computer system including an operating system user application programs driver and other support files as well as other data files of all sorts. Typically the fixed storage serves as the main hard disk for the system.

In basic operation program logic including that which implements methodology of the present invention described below is loaded from the removable storage or fixed storage into the main RAM memory for execution by the CPU . During operation of the program logic the system accepts user input from a keyboard and pointing device as well as speech based input from a voice recognition system not shown . The keyboard permits selection of application programs entry of keyboard based input or data and selection and manipulation of individual data objects displayed on the screen or display device . Likewise the pointing device such as a mouse track ball pen device or the like permits selection and manipulation of objects on the display device. In this manner these input devices support manual user input for any process running on the system.

The computer system displays text and or graphic images and other data on the display device . The video adapter which is interposed between the display and the system s bus drives the display device . The video adapter which includes video memory accessible to the CPU provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube CRT raster or liquid crystal display LCD monitor. A hard copy of the displayed information or other information within the system may be obtained from the printer or other output device. Printer may include for instance an HP LaserJet printer available from Hewlett Packard of Palo Alto Calif. for creating hard copy images of output of the system.

The system itself communicates with other devices e.g. other computers via the network interface card NIC connected to a network e.g. Ethernet network Bluetooth wireless network or the like and or modem e.g. 56K baud ISDN DSL or cable modem examples of which are available from 3Com of Santa Clara Calif. The system may also communicate with local occasionally connected devices e.g. serial cable linked devices via the communication COMM interface which may include a RS 232 serial port a Universal Serial Bus USB interface or the like. Devices that will be commonly connected locally to the interface include laptop computers handheld organizers digital cameras and the like.

IBM compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock Tex. Hewlett Packard of Palo Alto Calif. and IBM of Armonk N.Y. Other suitable computers include Apple compatible computers e.g. Macintosh which are available from Apple Computer of Cupertino Calif. and Sun Solaris workstations which are available from Sun Microsystems of Mountain View Calif.

A software system is typically provided for controlling the operation of the computer system . The software system which is usually stored in system memory RAM and on fixed storage e.g. hard disk includes a kernel or operating system OS which manages low level aspects of computer operation including managing execution of processes memory allocation file input and output I O and device I O. The OS can be provided by a conventional operating system Microsoft Windows NT Microsoft Windows 2000 Microsoft Windows XP or Microsoft Windows Vista Microsoft Corporation of Redmond Wash. or an alternative operating system such as the previously mentioned operating systems. Typically the OS operates in conjunction with device drivers e.g. Winsock driver Windows implementation of a TCP IP stack and the system BIOS microcode i.e. ROM based microcode particularly when interfacing with peripheral devices. One or more application s such as client application software or programs i.e. set of processor executable instructions may also be provided for execution by the computer system . The application s or other software intended for use on the computer system may be loaded into memory from fixed storage or may be downloaded from an Internet location e.g. Web server . A graphical user interface GUI is generally provided for receiving user commands and data in a graphical e.g. point and click fashion. These inputs in turn may be acted upon by the computer system in accordance with instructions from OS and or application s . The graphical user interface also serves to display the results of operation from the OS and application s .

The above described computer hardware and software are presented for purposes of illustrating the basic underlying computer components that may be employed for implementing the present invention. For purposes of discussion the following description will present examples in which it will be assumed that there exists a computer e.g. desktop computer or processing environment capable of hosting a development environment that implements and supports the methodologies of the present invention presented in detail below.

In accordance with the present invention a development environment for developing software applications includes a subsystem providing Application Factories. Application Factories represent an infrastructure that facilitates creation and reuse of specialized metadata driven templates for pre built applications. They contain a description of the application configuration information application development logic and breadcrumbs i.e. developer trail markers to use and build out each of the components that comprise an application. They are devised by architects or senior developers for either repetitive programs or one off applications in which the designer can specify all the information a more junior developer will need to write the final product. For the follow on e.g. junior developer the experience is vastly different from the typical prior art exercise of looking at abstract UML Unified Modeling Language diagrams or CRC Class Responsibility collaborator cards and figuring out what code needs to be written. Rather it is a navigation experience through rich development content provided by the Application Factories facility. This navigation consists of following the steps in the template reading the logic and explanation of constraints following the breadcrumbs to various resources and then writing the code.

More particularly Application Factories represent an automated facility for capturing the development process itself including development artifacts and behavior for reuse at a future point in time. Here the developer can push his or her knowledge i.e. knowledge gained from development activities back into the developer s integrated development environment i.e. IDE . In the currently preferred embodiment this captured knowledge is maintained as metadata stored alongside the application under development i.e. maintained alongside the source code and other files that comprise the application under development . Preferably the metadata is maintained as a metadata project and thus can be controlled with the IDE s existing project management tools e.g. version control . The IDE becomes a consumer of the metadata and adapts itself to the application under development that is transforming from an IDE centric approach focused on different subsystems of the IDE e.g. file based navigators project pane editors inspectors plug ins etc. to an application centric approach focused on the fundamental aspects of the application under development e.g. payment modules inventory modules etc. .

Artifacts are not development code per se but are in effect sidecar items or metadata that very much belong with the application and thus are desirable to capture and track as part of the application in an automated fashion. Artifacts may be manifested for example as scripts or templates to be filled in by the developer that guide additional development or maintenance of the program code. For example an application factory for a financial application could capture the original developer s intent into a script that when run by a follow on developer guides code development by the sample sequence of 1 Reuse the graphical interface module from the derivatives application at code derivapp mainUI.java and 2 Tie that module to the bond trading DB instead of the options system. 

Besides supporting scripts and templates Application Factories capture and track other useful artifacts such as architecture diagrams code completion metadata as well as various technologies for extending the application. Used this way Application Factories transform development into a series of actions that convert purpose designed artifacts and templates into straightforward coding sequences. The artifacts themselves can also be inserted into the code by developers as they work to indicate the reasons for implementation decisions with embedded suggestions on how to modify the code in the event future changes are necessary. Thus using Application Factories the original developer does not merely create a source code file but instead creates a content rich application module that includes not only the source code but also metadata capturing the trails and actions of that developer. This metadata is maintained alongside the source code so that the application s structure evolution and logic are readily accessible. By thoughtfully tracking and including these artifacts and visible behavior at the decision time the developers using the Application Factories facility can provide support for future maintainers and give them appropriate signposts by which they can navigate the code successfully.

By allowing developers to navigate an application based on an application centric approach Application Factories allow the developer to easily navigate an application in terms of its different functional parts e.g. payment module instead of requiring the developer to navigate based on an IDE centric approach e.g. project folders and individual source code files . The file system is preserved underneath but it is presented using an application centric navigational approach. This approach allows the developer to easily view and contemplate the application in terms of the application s structure evolution and logic rather than as a multitude of project folders and files. Moreover by capturing the trails and actions of earlier developers the barrier or learning curve for re creating a given development task e.g. create a PayPal checkout cart is substantially reduced. In this manner Application Factories provide a development environment in which applications along with attached metadata are shared as reusable software assets.

The Application Factories functionality introduces an application driven development paradigm where the structure evolution and logic behind the development of the application are checked into version control along with the source code for the application itself. Major software development processes use a bewildering array of frameworks and technologies to build even the simplest of applications. In addition many typical applications are built over and over again from the ground up resulting in duplicated efforts. Such methods involve a steep learning curve for developers requiring knowledge of the frameworks and technologies along with application specific models and behaviors. Due to the scope of this effort it is very common to have teams narrowly focused on the many aspects of the application. However it is absolutely required that each feature fit into the overall architecture. The problem multiplies over the age of the project as more features get added and teams are in flux. The Application Factories facility of the present invention fundamentally addresses this issue by attaching application specific metadata throughout the life of the application s development. Application Factories provide developers with the ability to attach actionable behavior to application modules. These behaviors go all the way from complete code generation to laying bread crumbs for newer developers to follow and implement as the Application Factories facility records a developer s intent when a particular piece of code was written. This allows the workings of the code to be easily ascertained at a later date.

Application Factories also facilitate the process of capturing the original developer s intent and context by providing in line IDE tools for making notes about code as well as creating bread crumb trails to project and file specific developer knowledge. This metadata stays attached to the code and can be opened by any subsequent developer to understand the context and purpose of code snippets methods and classes. Using a given Application Factory project system architects can develop templates that include Application Factory pointers. These pointers help developers understand the rationale and correct technique for implementing specific features. The system architect includes code and Application Factory tags that explain to the developer what custom code needs to be written and how to configure the application. With these templates in place sites can use application templates to quickly customize build and deploy applications.

The Application Factories functionality provides core tools to create 0069 Tags keywords associated with a piece of information 0070 Application Diagram visual representation of application architecture and functionality 0071 Scripts code generating templating mechanism providing a way to generate template code 0072 Readme overview of application functionality 0073 Cheat Sheet cheat sheet providing important steps for using the application and scripts

Each application can become an Application Factory Module also known as an application module by creating the Application Factory project for an application. Attached with the Module is Application Factory metadata in the form of an Application Factory project. Currently each workspace supports a single application which could include multiple projects and a single Application Factory project. A new project can be created using the new Application Factory wizard in the IDE available under File New Project or Other Application Factory . This wizard creates a template readme and cheat sheet along with an empty tag repository and application diagram. The project structure is created and global scripts and templates can be pulled into the new project as well.

The Application Factory project includes the Tags Application Diagram s and Application Module Scripts as the application s artifacts. A tag is a keyword associated with a piece of information. Tags are typically used to group related resources. The application module project contains a set of tags that provide an organizational and navigational mechanism for the application. This tag repository for an application is stored in the Application Factory project. Each tag is associated with multiple resources in the application defined as a set of projects in a workspace . Tags can have parent child relationships and can be related to each other. Each tag can have a description and associated notes. A Tag View is used to create and manage tags for an application. The Tag View provides the ability to focus the workspace on the file set associated with each tag. This provides an easy way to navigate through the application. Tags and selected resources can be marked as Application Diagram candidates. This allows the tags and associated relationships to be exposed in the Application Diagram associated with the module. For example a set of high level parent tags can be exposed via the Application Diagram to describe application functionality.

The Application Diagram describes application architecture and functionality. This diagram can include application architecture employed technologies third party dependencies and so forth. The diagram is useful as a tool to describe how the internals of the application work to a new user. The Application Diagram is stored in the Application Factory project. The diagram surfaces information from the tags mainly tags marked as diagram candidates. The diagram also displays description notes for tags. It also represents parent child relationships and related tags. The diagram provides a high level summary of the application. The Application Diagram can be displayed by using a context menu item right clicking on the Application Factory project file.

Application module scripts are code generation templating mechanisms that provide a way to generate template code. Template code can be a convenient starting point for new users. In the presently preferred embodiment the scripts are written using JavaScript and use FreeMarker template engine available from freemarker.org templates to perform the task of template code generation. This template code includes generation of new resources as well as modification of existing resources. Both scripts and templates are stored in the Application Factory project. Each script contains a description of script functionality and uses a standard Java API DOM to locate generate resources. The currently preferred scripting mechanism that is running scripts and so forth is based on Eclipse Monkey a JavaScript project within Eclipse. The currently preferred IDE i.e. JBuilder the commercial embodiment provides wizards to generate template scripts and script recipes that can be used to generate complex scripts templates. The generated scripts use standard UI widgets to prompt for parameters for example project names package names search replace patterns and so forth . Scripts can also be generated by mining VCS commit history for commonly used patterns. Script run history is available for the Application Factory project any file in the workspace and any script using the Archeology view.

The right hand side of includes Application Productivity which represents the means by which the Application Factories supports the creation and use of the modules . Application Productivity includes the various tools and features of the present invention that facilitate the transfer of domain expertise i.e. transfer of a developer s knowledge gained during development back into the IDE. As shown these tools include Architectural Diagram white boarding support Reusable Patterns and Trail Markers Architecture and Task based focused Navigation Notes and Documents support and Jump Start. These will be briefly described in turn.

The Architectural Diagram support is elevated in importance such that the developer s core architectural diagram s receives prominent attention in the project. Anytime the project is opened the architectural diagram s is displayed upfront i.e. displaying a white board about the application upfront allowing quick assimilation of the key aspects of an application s architecture. Reusable Patterns and Trail Markers incorporate developer knowledge in a manner that facilitates reuse. Using Application Factories one does not always have the burden of producing source code. Instead the expert producing developer may create skeleton code i.e. scaffolding together with to do items. The producing developer may create as much i.e. full fledged patterns or as little i.e. trail markers source code as appropriate for use by consuming developers for the task at hand. Architecture and Task based focused Navigation refers to the preferred method for navigating applications in the Application Factories environment. As previously described an application project is no longer presented merely as a collection of folders and files. Instead the application is presented in terms of its architecture and feature implementation. In this manner one can navigate the application project based on the application s own constructs rather than the IDE centric view of folders and files. Notes and Documents refer to the enhanced documentation available through use of metadata maintained with the application project. Finally Jump Start refers to the facility of Application Factories that supports a high level starting point e.g. shopping cart so that developers need not start from the beginning every time.

Application Factories make it possible to run scripts and capture changed artifacts as part of the script Archeology. In a typical scenario as an Application Factory is opened a developer goes to the first navigable item and then performs the following sequence 0083 Runs a script or s he could be prompted for a script to run 0084 The developer then switches to a snippet resolver phase for the changes made by the script which includes 0085 Reviewing each change and the reason why the change was made 0086 Making any in place edits to the changes performed by the script 0087 Tagging the changes as needed 0088 Scroll to the script line which produced the change and if need be customizing or modifying it 0089 Committing the changes to a changeset and 0090 Repeat as needed with other scripts.

The Application Factory Module Consumer uses previously created Application Factory Modules to rapidly build other applications. In this role the Consumer follow on developer would work with the application projects as any developer normally does. In addition the Consumer makes use of Application Factory scripts as needed. A Consumer can be defined as a team member who is new to Application Factory and who is mandated to work with Application Modules. This user starts by checking out or installing an Application Module. An Application Module could be a single project or multiple projects along with the Application Factory project for the application. The Consumer then proceeds to learn about the application using the application diagram tags and scripts. The Consumer can then proceed with assigned tasks. This might include adding tags scripts in this process which can then be re exported as a new Application Module to share with the rest of the team. The Consumer works with the application projects in the normal manner and makes use of Application Factory scripts as needed. Using the Application Factory the Consumer has a deployable application from the very beginning with an automatically created action trail. The Consumer learns while using Application Factory tools on action trails and tags and can choose to modify add tags. This knowledge along with the project itself can then be shared with the rest of the development team. When comfortable with the Application Factory functionality the Consumer can customize and create application specific behavior. The Consumer can use the extensive application creation tools Producer version only or the Consumer can use the script wizard to create a rich skeleton and work directly with scripts. After the Consumer enhances an Application Module it can be shared for reuse by exporting as an archive and publishing the Application Module Producer version only or by exporting the enhanced module through version control.

Operation of this mode Consumer mode is perhaps best described by demonstrating usage of the user interface. is a bitmap screenshot illustrating the development environment implementing Application Factories. Here the figure illustrates the Application Factories consumer perspective . Other perspectives described below include the producer perspective Producer mode and modeling perspective. In typical prior art development environments the developer at this point would be required to start a new project afresh. In the Application Factories environment of the present invention however that approach is eschewed in favor of the Application Factory Explorer left hand side of the interface which allows the developer to change the starting point of application development. The Application Factory Explorer provides a tree or hierarchical view of a configurable set of categorizations. Here the Explorer can accommodate any arbitrary set of categorizations thereby allowing users complete flexibility in how they categorize the various facets or aspects of the application under development. For the example shown categories include Application Kind License and Framework. As shown each category is associated with a user selectable checkbox allowing one to filter the particular application facets from display.

Upfront the Application Factories IDE provides four different views of the application under development an Application Preview a Diagrammatic white board View a Tag View and a Licensing View. is a bitmap screen shot illustrating the Application Preview feature of the present invention. This feature allows the developer user to immediately see a screen shot of the application under development. This gives the developer a good idea of what the application will look like before the developer has even written one line of code. Creation of the screen shot occurs during the producer mode described below . is a bitmap screenshot illustrating the Diagrammatic Application Diagram View or white board of an application under development as provided by the currently preferred embodiment of system of the present invention. This provides a white board built into the IDE that allows the producing developer to provide a high level view or overview of the application. This overview allows anyone coming into the application e.g. a new Consumer developer to be first presented with meaningful documentation of the application.

This approach is particularly important for complex applications. Consider for instance a 1 000 file application with various bits and pieces of the application scattered across a dozen or more projects. In that scenario navigation of the application using traditional file based IDE technique is woefully inadequate and inefficient. Using the tag based approach of the present invention in contrast the developer may immediately navigate to relevant pieces such as the presentation portion of an application the database portion of an application and so forth. Suppose this application is a banking application that has been in development for two years and a developer has just been hired to work on security related facets of the application. Instead of the new developer having to navigate among a thousand different files trying to sort out relevant code he or she may simply use the tag navigator e.g. select Security tag to select the appropriate facets of the application that pertain to security related matters as illustrated in . By using the metadata tagging facility of the present invention the expert producer developer i.e. the architect who has expert knowledge of the application may offload his or her knowledge of the application back into the IDE so subsequent i.e. downstream developers may immediately benefit from that. Additionally since the metadata is maintained as a separate project the tags are maintained in a repository that is subject to version control i.e. with the benefits of auditing .

Consider the task of changing the style i.e. Web application cascading stylesheet for this example Web based application. A traditional IDE by itself knows nothing about the application under development and thus would not be able to help with this task. However using Application Factories of the present invention once a given module is created the developer may add additional behavior that facilitates future development of the application. Thus in the present example of changing the application s style the producing architect developer may use built in support provided by the Application Factories to create behavioral scripts e.g. Scripts shown in that facilitate a desired action e.g. changing style . For example to facilitate the task of changing the style of the application the producing developer may create the Choose CSS Theme script as shown. In the currently preferred embodiment scripts are created using JavaScript. The follow on consuming developer may run a given script by selecting it e.g. double clicking on it in the user interface. For instance upon the developer selecting the Choose CSS Theme script the IDE launches the corresponding JavaScript applet as demonstrated in . Here the JavaScript applet displays an initial dialog box that allows the developer to select a new style simply by filling in selections presented by the dialog box. Once the developer has entered the desired choices the effect on the application may be determined by re launching the application with its new style as shown in . If the developer is happy with this change he or she may commit the change i.e. to the underlying project files as shown by the confirmation dialog box in . As also shown in the developer may invoke a Show Changes option to see exactly what source code is being changed.

The use of scripts in the system is not static but is instead a dynamic constantly evolving process. illustrates a Scripts Learn Resolve mode that is used to modify and or accept the scripts over time for learning the appropriate behavior. The Scripts Learn Resolve Commit view is a tree view list of files associated script s and snippet s that need to be resolved. This view is similar to the VCS synchronization view in Eclipse. Along with the entry in the Scripts Learn Resolve Commit a description for each change is displayed in a wrapped text format. The file list pane has a toolbar for various resolution options commit all changes discard all changes and so forth. The file list uses different markers to indicate missing resources and the level of confidence for the change. Double clicking on an entry in the file list tree view opens the script in the Script Editor in a right hand pane. The Diff view is displayed below the file list and Editor panes.

As shown the developer need not accept the provided scripts as they were originally written but may instead modify them as required. When the developer modifies a script the system indicates the file that is changing in the list the reason why the file is changing File Change Information and the specific source code changes themselves as shown by changed the source code .

Similarly the developer may invoke an Archaeology feature accessed by right clicking on a metadata node and selecting Archaeology to determine why certain code came into being. As shown in the Archaeology future displays an audit list of changes made to the source code files. The Archeology view displays script runs for a file runs for a single script and script runs for the Application Factory project. The Archeology view allows for navigation browser style to navigate between filtering contexts . The archeology viewer functionality allows one to display script runs for a file runs for a single script and script runs for the project. The script runs can be filtered by date author and script name. Display details for each script run are also provided. Such details include the list of files affected by a selected script run and the script associated with each file change with the script scrolled to the appropriate line which changed the file .

The foregoing example demonstrates execution of a script that provides behavior which is very specific to this particular application under development and which has been provided by the module producer e.g. architect or original developer . In other words instead of merely providing IDE specific tools the application project now includes application specific tools. In this manner the producing developer can offload back into the IDE his or her knowledge in the form of navigational aids and behavioral aids that capture developer intent. Any downstream developer may benefit from the use of these application specific aides.

To become a producer a developer basically wraps logical groups of functionality into scripts creates tags to completely reflect the application adds tag metadata and creates a white board diagram and any cheat sheet and then exports the application with metadata into modules. Thus the Producer mode substantially overlaps with the previously demonstrated Consumer mode with creation and use of scripts tags and metadata. However in Producer mode the developer explicitly exports or publishes modules for use by others. A producer can publish modules using the Export Application Module wizard File Export Application Factory Export Application Module . This wizard creates a Module ARchive .MAR file that includes all projects in the current workspace. Thus an Application Module is created by exporting one or more projects. For example as shown in an Export dialog is used to export one or more projects that are in the existing workspace. The Modules can either be in folders on a drive or out on the Web as ATOM RSS feeds. On Export the user can choose to export it as Atom RSS and on import the user can configure any number of feed locations to pull from.

Now the user wants to make the application reusable. To do this the user instructs the workspace to create a recipe script for the Application Factory. As shown in the user selects the menu command Script Recipe for Application Factory. This script forms the application s recipe that is containing all the necessary ingredients for re creating the application. The workspace now requests a user provided name for the script recipe together with an indication of which resources or ingredients from the current Welcome project are to be included in the recipe. In response to these inputs the workspace displays a list of Module Tasks as shown in . The user may select the menu command Create Script for Task as shown in but doing so at this point will simply re create the current application. Instead the goal is to re create a reusable application that is highly customizable.

To create a reusable application in accordance with the present invention it is not sufficient just to capture and rerun the current recipe i.e. the ingredients of what is to be re created . Instead users want to be able to use the development system in a manner that facilitates modification of the application as it is being re created. In accordance with the present invention this is achieved by introducing templates into the script recipe. This will now be demonstrated.

As shown in the Add Code to Change Workspace Files dialog provides an easy means to accomplish this task. Continuing with our example the user will now add additional modifications. As shown in the workspace displays a dialog that allows the user to customize the project by creating a modify code snippet to modify an existing file for example the user wants to change the text string 2005 to 2008 . This is an example of modifying an existing file. Similarly the user can create snippets for creating deleting and appending to files. Completing the example the user now tests the script shown in to confirm that it runs in a satisfactory manner. At this point the script shows at the UI which the end user will use to create reuse this Welcome application that is a completely reusable and highly customizable application. Now the Application Factory can be exported as a module. Refer back to and accompanying text for a discussion of the export process. When the application is re imported at a later time a factory project is created in a new workspace and the initial script Welcome.js runs automatically as it was configured to run during the export process. For further description of the process of importing or consuming modules refer to the prior discussion of Consumer mode and and accompanying text below. 

With an understanding of how the Application Factory module is structured one can now examine how the module is consumed internally. is a high level block diagram illustrating Application Factory module consumption . Here the user i.e. consumer begins by pointing his or her viewer at the Application Factory module a MAR file through any desired means as indicated at . This loads the module archive whereupon the user may now observe its various views such as Application Preview Structure Cheat Sheets or the like as indicated at . At this point the user is now ready to create an application i.e. spawn a new application from the Application Factory module. The Create Application process at yields the following results. First at an empty Application Factory project is created in the workspace. Next during typical use at the import script runs whereupon an actual application project is created e.g. shopping cart application accounting program etc. . Upon creation of the application project the system immediately proceeds to populate the newly created application factory project with the diagrams tags and scripts specified by the consumed Application Factory module archive as indicated at . All associated links are preserved e.g. the Welcome tag will point to Welcome.java Frame tag will point to Frame.java and so forth . The scripts are similarly carried over from the archive and are available in the Script View. Now when the user runs the scripts changes to the application are automatically tracked i.e. archaeology captured as indicated at

Once an application has been created two sets of resources are available 1 Tags and Application Diagram and 2 Scripts and Archaeology. is a block diagram illustrating use of Tags and Application Diagram resources beginning at . These are used for the organization structure and navigation of the application. The Application Diagram at is used to provide an overview of the application. As previously described the user developer need not navigate the project blindly using a file folder based approach but instead uses Tags to navigate in a focused application centric manner as indicated at . In other words the user navigates the project based on the organization of the module creator which is captured by the system thereby navigating the application in a much more application friendly way. Here current and downstream users are able to view navigate all of the styling features of an application together for example as they are related through organization and context as specified by tagging . Specifically the following navigation is provided. The user may employ browse mode at to browse through available tags or use parent child mode to create or use a hierarchy of the tags. The user may use cloud mode at to drill up or drill down through the tags representing the application s structure. Or the user can use a link mode to create associations through tags at . This latter mode is used in conjunction with a Link Editor at for creating dynamic pattern rules and quickly reorganizing tags as well as preparing large batch updates.

Blocks illustrate use of Recipes and Scripts. The first step in creating Recipes is identifying reusable patterns in one s code base as indicated at for example something as simple as changing a package name. A more complex example would be for instance changing a payment system from PayPal to MasterCard. Once reusable patterns are identified the user developer producer proceeds to create one or more corresponding Recipes at . This includes gathering all the input required for producing a script e.g. one that modifies a pattern within an existing file . Certain input or parameters will be fixed while others will be changing. Input subject to change is handled by creating a template at which contains a pattern that will be substituted with the real value by the downstream user developer Consumer . After creation of the templates the user developer Producer creates a script at . Different options are available at this point. The user developer can create a script that auto generates a customized user interface as indicated at . Or as indicated at the developer may create a script that creates modifies or deletes entire files or parts thereof e.g. such as the file modification example previously described above . Thus in this manner the developer has created his or her program code base application and scripts that enhance the feature set of that code including creating new pieces of code or adapting existing code for new functionality.

Application Factories of the present invention provide architects with many tools that enable them to build Application Modules that are as rich as needs dictate. Basic design of an Application Module can be done through wizards. These wizards are particularly useful for applications that have clearly defined and bounded functionality such as CRUD applications reports certain kinds of AJAX functionality POJO persistence and retrieval and the like. The included scripts can be written by hand or automatically generated. Palettes that offer management of existing artifacts enable architects to mine existing Modules for features they want so that reuse is maximized. In addition various portions of the Modules can be made read only or read write depending on whether the architect wishes to allow developers to change and update the templates and the Module design.

The Application Factories approach to creating templates easily and capturing the intent and knowledge of developers who implement an application provides a new model for designing software. It creates the possibility of rapidly deployable applications that consist of configuration data templates and some code. Starting from this base a developer can customize and build the application and have it ready for roll out in a matter of hours thereby greatly reducing the cost and overhead associated with the complexity of today s applications. The benefits of this approach are clear for developers that rely on frameworks such as Struts or Spring or on enterprise software such as Tomcat. The senior designers can create Application Factory artifacts as they code and so preserve their thinking for the use by other developers. This approach enables tutoring and mentoring as well.

While the invention is described in some detail with specific reference to a single preferred embodiment and certain alternatives there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention.

