---

title: Results generation for state machine engines
abstract: A state machine engine includes a storage element, such as a (e.g., match) results memory. The storage element is configured to receive a result of an analysis of data. The storage element is also configured to store the result in a particular portion of the storage element based on a characteristic of the result. The storage element is additionally configured to store a result indicator corresponding to the result. Other state machine engines and methods are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454322&OS=09454322&RS=09454322
owner: Micron Technology, Inc.
number: 09454322
owner_city: Boise
owner_country: US
publication_date: 20150630
---
The present application is a continuation of U.S. application Ser. No. 13 601 642 entitled Results Generation For State Machine Engines and filed Aug. 31 2012 now U.S. Pat. No. 9 075 428 which issued on Jul. 7 2015 the entirety of which is incorporated by reference herein for all purposes.

Embodiments of the invention relate generally to electronic devices and more specifically in certain embodiments to electronic devices with parallel devices for data analysis.

Complex pattern recognition can be inefficient to perform on a conventional von Neumann based computer. A biological brain in particular a human brain however is adept at performing pattern recognition. Current research suggests that a human brain performs pattern recognition using a series of hierarchically organized neuron layers in the neocortex. Neurons in the lower layers of the hierarchy analyze raw signals from for example sensory organs while neurons in higher layers analyze signal outputs from neurons in the lower levels. This hierarchical system in the neocortex possibly in combination with other areas of the brain accomplishes the complex pattern recognition that enables humans to perform high level functions such as spatial reasoning conscious thought and complex language.

In the field of computing pattern recognition tasks are increasingly challenging. Ever larger volumes of data are transmitted between computers and the number of patterns that users wish to identify is increasing. For example spam or malware are often detected by searching for patterns in a data stream e.g. particular phrases or pieces of code. The number of patterns increases with the variety of spam and malware as new patterns may be implemented to search for new variants. Searching a data stream for each of these patterns can form a computing bottleneck. Often as the data stream is received it is searched for each pattern one at a time. The delay before the system is ready to search the next portion of the data stream increases with the number of patterns. Thus pattern recognition may slow the receipt of data.

Hardware has been designed to search a data stream for patterns but this hardware often is unable to process adequate amounts of data in an amount of time given. Some devices configured to search a data stream do so by distributing the data stream among a plurality of circuits. The circuits each determine whether the data stream matches a portion of a pattern. Often a large number of circuits operate in parallel each searching the data stream at generally the same time. However there has not been a system that effectively allows for performing pattern recognition in a manner more comparable to that of a biological brain. Development of such a system is desirable.

Turning now to the figures illustrates an embodiment of a processor based system generally designated by reference numeral . The system e.g. data analysis system may be any of a variety of types such as a desktop computer laptop computer pager cellular phone personal organizer portable audio player control circuit camera etc. The system may also be a network node such as a router a server or a client e.g. one of the previously described types of computers . The system may be some other sort of electronic device such as a copier a scanner a printer a game console a television a set top video distribution or recording system a cable box a personal digital media player a factory automation system an automotive computer system or a medical device. The terms used to describe these various examples of systems like many of the other terms used herein may share some referents and as such should not be construed narrowly in virtue of the other items listed. 

In a typical processor based device such as the system a processor such as a microprocessor controls the processing of system functions and requests in the system . Further the processor may comprise a plurality of processors that share system control. The processor may be coupled directly or indirectly to each of the elements in the system such that the processor controls the system by executing instructions that may be stored within the system or external to the system .

In accordance with the embodiments described herein the system includes a state machine engine which may operate under control of the processor . The state machine engine may employ any automaton theory. For example the state machine engine may employ one of a number of state machine architectures including but not limited to Mealy architectures Moore architectures Finite State Machines FSMs Deterministic FSMs DFSMs Bit Parallel State Machines BPSMs etc. Though a variety of architectures may be used for discussion purposes the application refers to FSMs. However those skilled in the art will appreciate that the described techniques may be employed using any one of a variety of state machine architectures.

As discussed further below the state machine engine may include a number of e.g. one or more finite state machine FSM lattices e.g. core of a chip . For purposes of this application the term lattice refers to an organized framework e.g. routing matrix routing network frame of elements e.g. Boolean cells counter cells state machine elements state transition elements . Furthermore the lattice may have any suitable shape structure or hierarchical organization e.g. grid cube spherical cascading . Each FSM lattice may implement multiple FSMs that each receive and analyze the same data in parallel. Further the FSM lattices may be arranged in groups e.g. clusters such that clusters of FSM lattices may analyze the same input data in parallel. Further clusters of FSM lattices of the state machine engine may be arranged in a hierarchical structure wherein outputs from state machine lattices on a lower level of the hierarchical structure may be used as inputs to state machine lattices on a higher level. By cascading clusters of parallel FSM lattices of the state machine engine in series through the hierarchical structure increasingly complex patterns may be analyzed e.g. evaluated searched etc. .

Further based on the hierarchical parallel configuration of the state machine engine the state machine engine can be employed for complex data analysis e.g. pattern recognition or other processing in systems that utilize high processing speeds. For instance embodiments described herein may be incorporated in systems with processing speeds of 1 GByte sec. Accordingly utilizing the state machine engine data from high speed memory devices or other external devices may be rapidly analyzed. The state machine engine may analyze a data stream according to several criteria e.g. search terms at about the same time e.g. during a single device cycle. Each of the FSM lattices within a cluster of FSMs on a level of the state machine engine may each receive the same search term from the data stream at about the same time and each of the parallel FSM lattices may determine whether the term advances the state machine engine to the next state in the processing criterion. The state machine engine may analyze terms according to a relatively large number of criteria e.g. more than 100 more than 110 or more than 10 000. Because they operate in parallel they may apply the criteria to a data stream having a relatively high bandwidth e.g. a data stream of greater than or generally equal to 1 GByte sec without slowing the data stream.

In one embodiment the state machine engine may be configured to recognize e.g. detect a great number of patterns in a data stream. For instance the state machine engine may be utilized to detect a pattern in one or more of a variety of types of data streams that a user or other entity might wish to analyze. For example the state machine engine may be configured to analyze a stream of data received over a network such as packets received over the Internet or voice or data received over a cellular network. In one example the state machine engine may be configured to analyze a data stream for spam or malware. The data stream may be received as a serial data stream in which the data is received in an order that has meaning such as in a temporally lexically or semantically significant order. Alternatively the data stream may be received in parallel or out of order and then converted into a serial data stream e.g. by reordering packets received over the Internet. In some embodiments the data stream may present terms serially but the bits expressing each of the terms may be received in parallel. The data stream may be received from a source external to the system or may be formed by interrogating a memory device such as the memory and forming the data stream from data stored in the memory . In other examples the state machine engine may be configured to recognize a sequence of characters that spell a certain word a sequence of genetic base pairs that specify a gene a sequence of bits in a picture or video file that form a portion of an image a sequence of bits in an executable file that form a part of a program or a sequence of bits in an audio file that form a part of a song or a spoken phrase. The stream of data to be analyzed may include multiple bits of data in a binary format or other formats e.g. base ten ASCII etc. The stream may encode the data with a single digit or multiple digits e.g. several binary digits.

As will be appreciated the system may include memory . The memory may include volatile memory such as Dynamic Random Access Memory DRAM Static Random Access Memory SRAM Synchronous DRAM SDRAM Double Data Rate DRAM DDR SDRAM DDR2 SDRAM DDR3 SDRAM etc. The memory may also include non volatile memory such as read only memory ROM PC RAM silicon oxide nitride oxide silicon SONOS memory metal oxide nitride oxide silicon MONOS memory polysilicon floating gate based memory and or other types of flash memory of various architectures e.g. NAND memory NOR memory etc. to be used in conjunction with the volatile memory. The memory may include one or more memory devices such as DRAM devices that may provide data to be analyzed by the state machine engine . As used herein the term provide may generically refer to direct input insert issue route send transfer transmit generate give output place write etc. Such devices may be referred to as or include solid state drives SSD s MultimediaMediaCards MMC s SecureDigital SD cards CompactFlash CF cards or any other suitable device. Further it should be appreciated that such devices may couple to the system via any suitable interface such as Universal Serial Bus USB Peripheral Component Interconnect PCI PCI Express PCI E Small Computer System Interface SCSI IEEE 1394 Firewire or any other suitable interface. To facilitate operation of the memory such as the flash memory devices the system may include a memory controller not illustrated . As will be appreciated the memory controller may be an independent device or it may be integral with the processor . Additionally the system may include an external storage such as a magnetic storage device. The external storage may also provide input data to the state machine engine .

The system may include a number of additional elements. For instance a compiler may be used to configure e.g. program the state machine engine as described in more detail with regard to . An input device may also be coupled to the processor to allow a user to input data into the system . For instance an input device may be used to input data into the memory for later analysis by the state machine engine . The input device may include buttons switching elements a keyboard a light pen a stylus a mouse and or a voice recognition system for instance. An output device such as a display may also be coupled to the processor . The display may include an LCD a CRT LEDs and or an audio display for example. They system may also include a network interface device such as a Network Interface Card NIC for interfacing with a network such as the Internet. As will be appreciated the system may include many other components depending on the application of the system .

The configurable elements can be configured e.g. programmed to implement many different functions. For instance the configurable elements may include state machine elements SMEs shown in that are hierarchically organized into rows shown in and blocks shown in . The SMEs may also be considered state transition elements STEs . To route signals between the hierarchically organized SMEs a hierarchy of configurable switching elements can be used including inter block switching elements shown in intra block switching elements shown in and intra row switching elements shown in .

As described below the switching elements may include routing structures and buffers. A SME can correspond to a state of a FSM implemented by the FSM lattice . The SMEs can be coupled together by using the configurable switching elements as described below. Accordingly a FSM can be implemented on the FSM lattice by configuring the SMEs to correspond to the functions of states and by selectively coupling together the SMEs to correspond to the transitions between states in the FSM.

In an example the input block the output block and or the programming interface can be implemented as registers such that writing to or reading from the registers provides data to or from the respective elements. Accordingly bits from the image stored in the registers corresponding to the programming interface can be loaded on the SMEs . Although illustrates a certain number of conductors e.g. wire trace between a block input block output block and an inter block switching element it should be understood that in other examples fewer or more conductors may be used.

In an example the row includes a first and second plurality of row interconnection conductors . In an example an input of a GOT can be coupled to one or more row interconnection conductors and an output can be coupled to one or more row interconnection conductor . In an example a first plurality of the row interconnection conductors can be coupled to each SME of each GOT within the row . A second plurality of the row interconnection conductors can be coupled to only one SME of each GOT within the row but cannot be coupled to the other SME of the GOT . In an example a first half of the second plurality of row interconnection conductors can couple to first half of the SMEs within a row one SME from each GOT and a second half of the second plurality of row interconnection conductors can couple to a second half of the SMEs within a row the other SME from each GOT as will be better illustrated with respect to . The limited connectivity between the second plurality of row interconnection conductors and the SMEs is referred to herein as parity . In an example the row can also include a special purpose element such as a counter a configurable Boolean logic element look up table RAM a field configurable gate array FPGA an application specific integrated circuit ASIC a configurable processor e.g. a microprocessor or other element for performing a special purpose function.

In an example the special purpose element comprises a counter also referred to herein as counter . In an example the counter comprises a 12 bit configurable down counter. The 12 bit configurable counter has a counting input a reset input and zero count output. The counting input when asserted decrements the value of the counter by one. The reset input when asserted causes the counter to load an initial value from an associated register. For the 12 bit counter up to a 12 bit number can be loaded in as the initial value. When the value of the counter is decremented to zero 0 the zero count output is asserted. The counter also has at least two modes pulse and hold. When the counter is set to pulse mode the zero count output is asserted when the counter reaches zero. For example the zero count output is asserted during the processing of an immediately subsequent next data byte which results in the counter being offset in time with respect to the input character cycle. After the next character cycle the zero count output is no longer asserted. In this manner for example in the pulse mode the zero count output is asserted for one input character processing cycle. When the counter is set to hold mode the zero count output is asserted during the clock cycle when the counter decrements to zero and stays asserted until the counter is reset by the reset input being asserted.

In another example the special purpose element comprises Boolean logic. For example the Boolean logic may be used to perform logical functions such as AND OR NAND NOR Sum of Products SoP Negated Output Sum of Products NSoP Negated Output Product of Sume NPoS and Product of Sums PoS functions. This Boolean logic can be used to extract data from terminal state SMEs corresponding to terminal nodes of a FSM as discussed later herein in FSM lattice . The data extracted can be used to provide state data to other FSM lattices and or to provide configuring data used to reconfigure FSM lattice or to reconfigure another FSM lattice .

In an example a state machine element comprises a plurality of memory cells such as those often used in dynamic random access memory DRAM coupled in parallel to a detect line . One such memory cell comprises a memory cell that can be set to a data state such as one that corresponds to either a high or a low value e.g. a 1 or 0 . The output of the memory cell is coupled to the detect line and the input to the memory cell receives signals based on data on the data stream line . In an example an input at the input block is decoded to select one or more of the memory cells . The selected memory cell provides its stored data state as an output onto the detect line . For example the data received at the input block can be provided to a decoder not shown and the decoder can select one or more of the data stream lines . In an example the decoder can convert an 8 bit ACSII character to the corresponding 1 of 256 data stream lines .

A memory cell therefore outputs a high signal to the detect line when the memory cell is set to a high value and the data on the data stream line selects the memory cell . When the data on the data stream line selects the memory cell and the memory cell is set to a low value the memory cell outputs a low signal to the detect line . The outputs from the memory cells on the detect line are sensed by a detection cell .

In an example the signal on an input line sets the respective detection cell to either an active or inactive state. When set to the inactive state the detection cell outputs a low signal on the respective output regardless of the signal on the respective detect line . When set to an active state the detection cell outputs a high signal on the respective output line when a high signal is detected from one of the memory cells of the respective SME . When in the active state the detection cell outputs a low signal on the respective output line when the signals from all of the memory cells of the respective SME are low.

In an example an SME includes 256 memory cells and each memory cell is coupled to a different data stream line . Thus an SME can be programmed to output a high signal when a selected one or more of the data stream lines have a high signal thereon. For example the SME can have a first memory cell e.g. bit set high and all other memory cells e.g. bits set low. When the respective detection cell is in the active state the SME outputs a high signal on the output when the data stream line corresponding to bit has a high signal thereon. In other examples the SME can be set to output a high signal when one of multiple data stream lines have a high signal thereon by setting the appropriate memory cells to a high value.

In an example a memory cell can be set to a high or low value by reading bits from an associated register. Accordingly the SMEs can be configured by storing an image created by the compiler into the registers and loading the bits in the registers into associated memory cells . In an example the image created by the compiler includes a binary image of high and low e.g. 1 and 0 bits. The image can configure the FSM lattice to implement a FSM by cascading the SMEs . For example a first SME can be set to an active state by setting the detection cell to the active state. The first SME can be set to output a high signal when the data stream line corresponding to bit has a high signal thereon. The second SME can be initially set to an inactive state but can be set to when active output a high signal when the data stream line corresponding to bit has a high signal thereon. The first SME and the second SME can be cascaded by setting the output of the first SME to couple to the input of the second SME . Thus when a high signal is sensed on the data stream line corresponding to bit the first SME outputs a high signal on the output and sets the detection cell of the second SME to an active state. When a high signal is sensed on the data stream line corresponding to bit the second SME outputs a high signal on the output to activate another SME or for output from the FSM lattice .

In an example a single FSM lattice is implemented on a single physical device however in other examples two or more FSM lattices can be implemented on a single physical device e.g. physical chip . In an example each FSM lattice can include a distinct data input block a distinct output block a distinct programming interface and a distinct set of configurable elements. Moreover each set of configurable elements can react e.g. output a high or low signal to data at their corresponding data input block . For example a first set of configurable elements corresponding to a first FSM lattice can react to the data at a first data input block corresponding to the first FSM lattice . A second set of configurable elements corresponding to a second FSM lattice can react to a second data input block corresponding to the second FSM lattice . Accordingly each FSM lattice includes a set of configurable elements wherein different sets of configurable elements can react to different input data. Similarly each FSM lattice and each corresponding set of configurable elements can provide a distinct output. In some examples an output block from a first FSM lattice can be coupled to an input block of a second FSM lattice such that input data for the second FSM lattice can include the output data from the first FSM lattice in a hierarchical arrangement of a series of FSM lattices .

In an example an image for loading onto the FSM lattice comprises a plurality of bits of data for configuring the configurable elements the configurable switching elements and the special purpose elements within the FSM lattice . In an example the image can be loaded onto the FSM lattice to configure the FSM lattice to provide a desired output based on certain inputs. The output block can provide outputs from the FSM lattice based on the reaction of the configurable elements to data at the data input block . An output from the output block can include a single bit indicating a match of a given pattern a word comprising a plurality of bits indicating matches and non matches to a plurality of patterns and a state vector corresponding to the state of all or certain configurable elements at a given moment. As described a number of FSM lattices may be included in a state machine engine such as state machine engine to perform data analysis such as pattern recognition e.g. speech recognition image recognition etc. signal processing imaging computer vision cryptography and others.

Each of the nodes can be in either an active or an inactive state. When in the inactive state a node does not react e.g. respond to input data. When in an active state a node can react to input data. An upstream node can react to the input data by activating a node that is downstream from the node when the input data matches criteria specified by an edge between the upstream node and the downstream node . For example a first node that specifies the character b will activate a second node connected to the first node by an edge when the first node is active and the character b is received as input data. As used herein upstream refers to a relationship between one or more nodes where a first node that is upstream of one or more other nodes or upstream of itself in the case of a loop or feedback configuration refers to the situation in which the first node can activate the one or more other nodes or can activate itself in the case of a loop . Similarly downstream refers to a relationship where a first node that is downstream of one or more other nodes or downstream of itself in the case of a loop can be activated by the one or more other nodes or can be activated by itself in the case of a loop . Accordingly the terms upstream and downstream are used herein to refer to relationships between one or more nodes but these terms do not preclude the use of loops or other non linear paths among the nodes.

In the diagram the root node can be initially activated and can activate downstream nodes when the input data matches an edge from the root node . Nodes can activate nodes when the input data matches an edge from the node . Nodes throughout the diagram can be activated in this manner as the input data is received. A terminal node corresponds to a match of a sequence of interest in the input data. Accordingly activation of a terminal node indicates that a sequence of interest has been received as the input data. In the context of the FSM lattice implementing a pattern recognition function arriving at a terminal node can indicate that a specific pattern of interest has been detected in the input data.

In an example each root node standard node and terminal node can correspond to a configurable element in the FSM lattice . Each edge can correspond to connections between the configurable elements. Thus a standard node that transitions to e.g. has an edge connecting to another standard node or a terminal node corresponds to a configurable element that transitions to e.g. provides an output to another configurable element. In some examples the root node does not have a corresponding configurable element.

As will be appreciated although the node is described as a root node and nodes are described as terminal nodes there may not necessarily be a particular start or root node and there may not necessarily be a particular end or output node. In other words any node may be a starting point and any node may provide output.

When the FSM lattice is programmed each of the configurable elements can also be in either an active or inactive state. A given configurable element when inactive does not react to the input data at a corresponding data input block . An active configurable element can react to the input data at the data input block and can activate a downstream configurable element when the input data matches the setting of the configurable element. When a configurable element corresponds to a terminal node the configurable element can be coupled to the output block to provide an indication of a match to an external device.

An image loaded onto the FSM lattice via the programming interface can configure the configurable elements and special purpose elements as well as the connections between the configurable elements and special purpose elements such that a desired FSM is implemented through the sequential activation of nodes based on reactions to the data at the data input block . In an example a configurable element remains active for a single data cycle e.g. a single character a set of characters a single clock cycle and then becomes inactive unless re activated by an upstream configurable element.

A terminal node can be considered to store a compressed history of past events. For example the one or more patterns of input data required to reach a terminal node can be represented by the activation of that terminal node . In an example the output provided by a terminal node is binary for example the output indicates whether the pattern of interest has been matched or not. The ratio of terminal nodes to standard nodes in a diagram may be quite small. In other words although there may be a high complexity in the FSM the output of the FSM may be small by comparison.

In an example the output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of configurable elements of the FSM lattice . In another example the state vector can include the state of all or a subset of the configurable elements whether or not the configurable elements corresponds to a terminal node . In an example the state vector includes the states for the configurable elements corresponding to terminal nodes . Thus the output can include a collection of the indications provided by all terminal nodes of a diagram . The state vector can be represented as a word where the binary indication provided by each terminal node comprises one bit of the word. This encoding of the terminal nodes can provide an effective indication of the detection state e.g. whether and what sequences of interest have been detected for the FSM lattice .

As mentioned above the FSM lattice can be programmed to implement a pattern recognition function. For example the FSM lattice can be configured to recognize one or more data sequences e.g. signatures patterns in the input data. When a data sequence of interest is recognized by the FSM lattice an indication of that recognition can be provided at the output block . In an example the pattern recognition can recognize a string of symbols e.g. ASCII characters to for example identify malware or other data in network data.

The first FSM lattice A is configured to receive input data for example raw data at a data input block. The first FSM lattice A reacts to the input data as described above and provides an output at an output block. The output from the first FSM lattice A is sent to a data input block of the second FSM lattice B. The second FSM lattice B can then react based on the output provided by the first FSM lattice A and provide a corresponding output signal of the hierarchical structure . This hierarchical coupling of two FSM lattices A and B in series provides a means to provide data regarding past events in a compressed word from a first FSM lattice A to a second FSM lattice B. The data provided can effectively be a summary of complex events e.g. sequences of interest that were recorded by the first FSM lattice A.

The two level hierarchy of FSM lattices A B shown in allows two independent programs to operate based on the same data stream. The two stage hierarchy can be similar to visual recognition in a biological brain which is modeled as different regions. Under this model the regions are effectively different pattern recognition engines each performing a similar computational function pattern matching but using different programs signatures . By connecting multiple FSM lattices A B together increased knowledge about the data stream input may be obtained.

The first level of the hierarchy implemented by the first FSM lattice A can for example perform processing directly on a raw data stream. For example a raw data stream can be received at an input block of the first FSM lattice A and the configurable elements of the first FSM lattice A can react to the raw data stream. The second level implemented by the second FSM lattice B of the hierarchy can process the output from the first level. For example the second FSM lattice B receives the output from an output block of the first FSM lattice A at an input block of the second FSM lattice B and the configurable elements of the second FSM lattice B can react to the output of the first FSM lattice A. Accordingly in this example the second FSM lattice B does not receive the raw data stream as an input but rather receives the indications of patterns of interest that are matched by the raw data stream as determined by the first FSM lattice A. The second FSM lattice B can implement a FSM that recognizes patterns in the output data stream from the first FSM lattice A. It should be appreciated that the second FSM lattice B may receive inputs from multiple other FSM lattices in addition to receiving output from the FSM lattice A. Likewise the second FSM lattice B may receive inputs from other devices. The second FSM lattice B may combine these multiple inputs to produce outputs.

In an example the compiler includes an application programming interface API that allows software developers to create images for implementing FSMs on the FSM lattice . The compiler provides methods to convert an input set of regular expressions in the source code into an image that is configured to configure the FSM lattice . The compiler can be implemented by instructions for a computer having a von Neumann architecture. These instructions can cause a processor on the computer to implement the functions of the compiler . For example the instructions when executed by the processor can cause the processor to perform actions as described in blocks and on source code that is accessible to the processor .

In an example the source code describes search strings for identifying patterns of symbols within a group of symbols. To describe the search strings the source code can include a plurality of regular expressions regexs . A regex can be a string for describing a symbol search pattern. Regexes are widely used in various computer domains such as programming languages text editors network security and others. In an example the regular expressions supported by the compiler include criteria for the analysis of unstructured data. Unstructured data can include data that is free form and has no indexing applied to words within the data. Words can include any combination of bytes printable and non printable within the data. In an example the compiler can support multiple different source code languages for implementing regexes including Perl e.g. Perl compatible regular expressions PCRE PHP Java and .NET languages.

At block the compiler can parse the source code to form an arrangement of relationally connected operators where different types of operators correspond to different functions implemented by the source code e.g. different functions implemented by regexes in the source code . Parsing source code can create a generic representation of the source code. In an example the generic representation comprises an encoded representation of the regexs in the source code in the form of a tree graph known as a syntax tree. The examples described herein refer to the arrangement as a syntax tree also known as an abstract syntax tree in other examples however a concrete syntax tree or other arrangement can be used.

Since as mentioned above the compiler can support multiple languages of source code parsing converts the source code regardless of the language into a non language specific representation e.g. a syntax tree. Thus further processing blocks by the compiler can work from a common input structure regardless of the language of the source code.

As noted above the syntax tree includes a plurality of operators that are relationally connected. A syntax tree can include multiple different types of operators. For example different operators can correspond to different functions implemented by the regexes in the source code.

At block the syntax tree is converted into an automaton. An automaton comprises a software model of a FSM and can accordingly be classified as deterministic or non deterministic. A deterministic automaton has a single path of execution at a given time while a non deterministic automaton has multiple concurrent paths of execution. The automaton comprises a plurality of states. In order to convert the syntax tree into an automaton the operators and relationships between the operators in the syntax tree are converted into states with transitions between the states. In an example the automaton can be converted based partly on the hardware of the FSM lattice .

In an example input symbols for the automaton include the symbols of the alphabet the numerals 0 9 and other printable characters. In an example the input symbols are represented by the byte values 0 through 255 inclusive. In an example an automaton can be represented as a directed graph where the nodes of the graph correspond to the set of states. In an example a transition from state p to state q on an input symbol i.e. p is shown by a directed connection from node p to node q. In an example a reversal of an automaton produces a new automaton where each transition p q on some symbol is reversed q p on the same symbol. In a reversal start state becomes a final state and the final states become start states. In an example the language recognized e.g. matched by an automaton is the set of all possible character strings which when input sequentially into the automaton will reach a final state. Each string in the language recognized by the automaton traces a path from the start state to one or more final states.

At block after the automaton is constructed the automaton is optimized to reduce its complexity and size among other things. The automaton can be optimized by combining redundant states.

At block the optimized automaton is converted into a netlist. Converting the automaton into a netlist maps each state of the automaton to a hardware element e.g. SMEs other elements on the FSM lattice and determines the connections between the hardware elements.

At block the netlist is placed to select a specific hardware element of the target device e.g. SMEs special purpose elements corresponding to each node of the netlist. In an example placing selects each specific hardware element based on general input and output constraints for of the FSM lattice .

At block the placed netlist is routed to determine the settings for the configurable switching elements e.g. inter block switching elements intra block switching elements and intra row switching elements in order to couple the selected hardware elements together to achieve the connections describe by the netlist. In an example the settings for the configurable switching elements are determined by determining specific conductors of the FSM lattice that will be used to connect the selected hardware elements and the settings for the configurable switching elements. Routing can take into account more specific limitations of the connections between the hardware elements that placement at block . Accordingly routing may adjust the location of some of the hardware elements as determined by the global placement in order to make appropriate connections given the actual limitations of the conductors on the FSM lattice .

Once the netlist is placed and routed the placed and routed netlist can be converted into a plurality of bits for configuring a FSM lattice . The plurality of bits are referred to herein as an image e.g. binary image .

At block an image is published by the compiler . The image comprises a plurality of bits for configuring specific hardware elements of the FSM lattice . The bits can be loaded onto the FSM lattice to configure the state of SMEs the special purpose elements and the configurable switching elements such that the programmed FSM lattice implements a FSM having the functionality described by the source code. Placement block and routing block can map specific hardware elements at specific locations in the FSM lattice to specific states in the automaton. Accordingly the bits in the image can configure the specific hardware elements to implement the desired function s . In an example the image can be published by saving the machine code to a computer readable medium. In another example the image can be published by displaying the image on a display device. In still another example the image can be published by sending the image to another device such as a configuring device for loading the image onto the FSM lattice . In yet another example the image can be published by loading the image onto a FSM lattice e.g. the FSM lattice .

In an example an image can be loaded onto the FSM lattice by either directly loading the bit values from the image to the SMEs and other hardware elements or by loading the image into one or more registers and then writing the bit values from the registers to the SMEs and other hardware elements. In an example the hardware elements e.g. SMEs special purpose elements configurable switching elements of the FSM lattice are memory mapped such that a configuring device and or computer can load the image onto the FSM lattice by writing the image to one or more memory addresses.

Method examples described herein can be machine or computer implemented at least in part. Some examples can include a computer readable medium or machine readable medium encoded with instructions operable to configure an electronic device to perform methods as described in the above examples. An implementation of such methods can include code such as microcode assembly language code a higher level language code or the like. Such code can include computer readable instructions for performing various methods. The code may form portions of computer program products. Further the code may be tangibly stored on one or more volatile or non volatile computer readable media during execution or at other times. These computer readable media may include but are not limited to hard disks removable magnetic disks removable optical disks e.g. compact disks and digital video disks magnetic cassettes memory cards or sticks random access memories RAMs read only memories ROMs and the like.

Referring now to an embodiment of the state machine engine e.g. a single device on a single chip is illustrated. As previously described the state machine engine is configured to receive data from a source such as the memory over a data bus. In the illustrated embodiment data may be sent to the state machine engine through a bus interface such as a double data rate three DDR3 bus interface . The DDR3 bus interface may be capable of exchanging e.g. providing and receiving data at a rate greater than or equal to 1 GByte sec. Such a data exchange rate may be greater than a rate that data is analyzed by the state machine engine . As will be appreciated depending on the source of the data to be analyzed the bus interface may be any suitable bus interface for exchanging data to and from a data source to the state machine engine such as a NAND Flash interface peripheral component interconnect PCI interface gigabit media independent interface GMMI etc. As previously described the state machine engine includes one or more FSM lattices configured to analyze data. Each FSM lattice may be divided into two half lattices. In the illustrated embodiment each half lattice may include 24K SMEs e.g. SMEs such that the lattice includes 48K SMEs. The lattice may comprise any desirable number of SMEs arranged as previously described with regard to . Further while only one FSM lattice is illustrated the state machine engine may include multiple FSM lattices as previously described.

Data to be analyzed may be received at the bus interface and provided to the FSM lattice through a number of buffers and buffer interfaces. In the illustrated embodiment the data path includes data buffers an instruction buffer process buffers and an intra rank IR bus and process buffer interface . The data buffers are configured to receive and temporarily store data to be analyzed. In one embodiment there are two data buffers data buffer A and data buffer B . Data may be stored in one of the two data buffers while data is being emptied from the other data buffer for analysis by the FSM lattice . The bus interface may be configured to provide data to be analyzed to the data buffers until the data buffers are full. After the data buffers are full the bus interface may be configured to be free to be used for other purposes e.g. to provide other data from a data stream until the data buffers are available to receive additional data to be analyzed . In the illustrated embodiment the data buffers may be 32 KBytes each. The instruction buffer is configured to receive instructions from the processor via the bus interface such as instructions that correspond to the data to be analyzed and instructions that correspond to configuring the state machine engine . The IR bus and process buffer interface may facilitate providing data to the process buffer . The IR bus and process buffer interface can be used to ensure that data is processed by the FSM lattice in order. The IR bus and process buffer interface may coordinate the exchange of data timing data packing instructions etc. such that data is received and analyzed correctly. Generally the IR bus and process buffer interface allows the analyzing of multiple data sets in parallel through a logical rank of FSM lattices . For example multiple physical devices e.g. state machine engines chips separate devices may be arranged in a rank and may provide data to each other via the IR bus and process buffer interface . For purposes of this application the term rank refers to a set of state machine engines connected to the same chip select. In the illustrated embodiment the IR bus and process buffer interface may include a 32 bit data bus. In other embodiments the IR bus and process buffer interface may include any suitable data bus such as a 128 bit data bus.

In the illustrated embodiment the state machine engine also includes a de compressor and a compressor to aid in providing state vector data through the state machine engine . The compressor and de compressor work in conjunction such that the state vector data can be compressed to minimize the data providing times. By compressing the state vector data the bus utilization time may be minimized. The compressor and de compressor can also be configured to handle state vector data of varying burst lengths. By padding compressed state vector data and including an indicator as to when each compressed region ends the compressor may improve the overall processing speed through the state machine engine . The compressor may be used to compress match results data after analysis by the FSM lattice . In one embodiment the compressor and de compressor may be disabled e.g. turned off such that data flowing to and or from the compressor and de compressor is not modified.

As previously described an output of the FSM lattice can comprise a state vector. The state vector comprises the state e.g. activated or not activated of the SMEs of the FSM lattice and the dynamic e.g. current count of the counter . The state machine engine includes a state vector system having a state vector cache memory a state vector memory buffer a state vector intermediate input buffer and a state vector intermediate output buffer . The state vector system may be used to store multiple state vectors of the FSM lattice and to provide a state vector to the FSM lattice to restore the FSM lattice to a state corresponding to the provided state vector. Each state vector may be temporarily stored in the state vector cache memory . For example the state of each SME may be stored such that the state may be restored and used in further analysis at a later time while freeing the SMEs for further analysis of a new data set e.g. search term . Like a typical cache the state vector cache memory allows storage of state vectors for quick retrieval and use here by the FSM lattice for instance. In the illustrated embodiment the state vector cache memory may store up to 512 state vectors.

As will be appreciated the state vector data may be exchanged between different state machine engines e.g. chips in a rank. The state vector data may be exchanged between the different state machine engines for various purposes such as to synchronize the state of the SMEs of the FSM lattices of the state machine engines to perform the same functions across multiple state machine engines to reproduce results across multiple state machine engines to cascade results across multiple state machine engines to store a history of states of the SMEs used to analyze data that is cascaded through multiple state machine engines and so forth. Furthermore it should be noted that within a state machine engine the state vector data may be used to quickly configure the SMEs of the FSM lattice . For example the state vector data may be used to restore the state of the SMEs to an initialized state e.g. to search for a new search term to restore the state of the SMEs to prior state e.g. to search for a previously searched search term and to change the state of the SMEs to be configured for a cascading configuration e.g. to search for a search term in a cascading search . In certain embodiments the state vector data may be provided to the bus interface so that the state vector data may be provided to the processor e.g. for analysis of the state vector data reconfiguring the state vector data to apply modifications reconfiguring the state vector data to improve efficiency of the SMEs and so forth .

For example in certain embodiments the state machine engine may provide cached state vector data e.g. data stored by the state vector system from the FSM lattice to an external device. The external device may receive the state vector data modify the state vector data and provide the modified state vector data to the state machine engine for configuring the FSM lattice . Accordingly the external device may modify the state vector data so that the state machine engine may skip states e.g. jump around as desired.

The state vector cache memory may receive state vector data from any suitable device. For example the state vector cache memory may receive a state vector from the FSM lattice another FSM lattice e.g. via the IR bus and process buffer interface the de compressor and so forth. In the illustrated embodiment the state vector cache memory may receive state vectors from other devices via the state vector memory buffer . Furthermore the state vector cache memory may provide state vector data to any suitable device. For example the state vector cache memory may provide state vector data to the state vector memory buffer the state vector intermediate input buffer and the state vector intermediate output buffer .

Additional buffers such as the state vector memory buffer state vector intermediate input buffer and state vector intermediate output buffer may be utilized in conjunction with the state vector cache memory to accommodate retrieval and storage of state vectors while processing separate data sets with interleaved packets through the state machine engine . In the illustrated embodiment each of the state vector memory buffer the state vector intermediate input buffer and the state vector intermediate output buffer may be configured to temporarily store one state vector. The state vector memory buffer may be used to receive state vector data from any suitable device and to provide state vector data to any suitable device. For example the state vector memory buffer may be used to receive a state vector from the FSM lattice another FSM lattice e.g. via the IR bus and process buffer interface the de compressor and the state vector cache memory . As another example the state vector memory buffer may be used to provide state vector data to the IR bus and process buffer interface e.g. for other FSM lattices the compressor and the state vector cache memory .

Likewise the state vector intermediate input buffer may be used to receive state vector data from any suitable device and to provide state vector data to any suitable device. For example the state vector intermediate input buffer may be used to receive a state vector from an FSM lattice e.g. via the IR bus and process buffer interface the de compressor and the state vector cache memory . As another example the state vector intermediate input buffer may be used to provide a state vector to the FSM lattice . Furthermore the state vector intermediate output buffer may be used to receive a state vector from any suitable device and to provide a state vector to any suitable device. For example the state vector intermediate output buffer may be used to receive a state vector from the FSM lattice and the state vector cache memory . As another example the state vector intermediate output buffer may be used to provide a state vector to an FSM lattice e.g. via the IR bus and process buffer interface and the compressor .

Once a result of interest is provided by the FSM lattice the result e.g. a match result may be stored in a storage element such as a results memory . For example a match vector indicating a match e.g. detection of a pattern of interest may be stored in the results memory . The match result can then be provided to a match buffer for provision over the bus interface to a processor for example. As previously described the match results may be compressed.

Additional registers and buffers may be provided in the state machine engine as well. For instance the state machine engine may include control and status registers . In addition a restore buffer system e.g. restore and program buffers may be provided for configuring the SMEs of the FSM lattice initially or restoring the state of the SMEs in the FSM lattice during analysis. For example state vector data may be provided from the restore buffers to the state vector intermediate input buffer of the state vector system e.g. via the de compressor . The de compressor may be used to decompress state vector data provided to the state vector memory buffer and or the state vector intermediate input buffer . The state vector system may provide the state vector data to the FSM lattice to configure SMEs of the FSM lattice . Similarly a save buffer system e.g. save and repair map buffers may also be provided for storage of save and repair maps for setup and usage. For example state vector data may be provided from the state vector intermediate output buffer of the state vector system to the save buffers e.g. via the compressor . The compressor may be used to compress state vector data provided to the save buffers from the state vector memory buffer and or the state vector intermediate output buffer .

Row of may also include eight GOTs a special purpose element inputs inputs outputs a match element and a special purpose element routing line . The GOTs and the special purpose element illustrated in can be substantially similar to the GOTs and the special purpose element previously discussed with respect to . Accordingly each GOT has inputs and for activation of SMEs therein to allow for an analysis to be performed by the respective SMEs of each GOT e.g. a match in an analyzed data stream which may be utilized in conjunction with results from other GOTs .

The result provided by a GOT may be selectively provided from the GOT on output . In one embodiment the possible outputs of the GOT may include no output an output from SME of the GOT an output from SME of the GOT or a logical combination e.g. OR of the output of the first SME and the output of the second SME . Thus a GOT may be configured to provide a selected result from the GOT . This configuration may be accomplished for example based on initial programming performed during an initial configuration of the FSM lattice . Results from the GOTs may be provided to a match element which may operate to provide a selected result from the row for a given data stream analysis or a portion of a data stream analysis.

Additionally row may include row routing lines . In the present embodiment there are sixteen row lines that are selectively able to be coupled to eight GOTs and to the special purpose element . However it should be appreciated that fewer or more row routing lines may be utilized in conjunction with the row .

Each of the row routing lines may be utilized to provide activation signals to any of the SMEs of GOTs in row while each of row routing lines and may be utilized to provide activation signals to any of the SMEs of GOTs and each of row routing lines and may be utilized to provide activation signals to any of the SMEs of the GOTs . Accordingly through use of these row routing lines any particular detection cell for any particular SME e.g. SME may be activated. This may be accomplished by selectively coupling e.g. in accordance with a loaded image the respective row routing line s to the unified activation input of the particular SME . For example a GOT may transmit an output to the row routing line coupled thereto for example row routing line . It is then available to all the SMEs the Special Purpose Element and for row routing lines the Match Element on that same row . This output signal may also be transmitted into the intra block switch . The signal can then be output onto for example up to three block routing lines. From there it may be routed to different rows in the same block through additional intra block switches . It can also be routed to different blocks through inter blocks switches .

As illustrated in each of the row routing lines includes a plurality of intra row switching elements of which may be utilized to selectively couple any GOT to any other GOT or any GOT to any other element e.g. a special purpose element within the row or for that matter within another row and or another block . However these connections may be limited by available switching elements . For example each of row routing lines and may be utilized to activate any of the SMEs in the row . However each of row routing lines and also are selectively coupleable to the output of a respective different one of the GOTs . For example an output from any one of the GOTs may only be provided from that GOT on a respective one of the row routing lines and coupleable thereto. Thus in one embodiment because row routing lines and are coupleable to the outputs of the GOTs the row routing lines and may provide e.g. drive out signals to the intra block switch . In contrast in one embodiment row routing lines and may receive e.g. be driven by signals from the intra block switch that may be received from for example other rows or blocks .

In addition to row routing lines the row may include a special purpose element routing line coupled to a special purpose element . Similar to row routing lines and the special purpose routing line may provide e.g. drive out signals to the intra block switch and in one embodiment the special purpose element routing line may also be coupleable to the match element . For example if the special purpose element comprises a counter an output of the counter may be provided to the special purpose routing line . Similarly if the special purpose element includes a Boolean logic element such as a Boolean cell an output of the Boolean logic element may be provided to the special purpose routing line . Through the use of these special purpose elements repetitive searches e.g. find an element ten times or cascaded searches e.g. find elements x y and z may be simplified into a single output that can be provided by the special purpose routing line to either or both of the intra block switch and the match element .

A more detailed illustration of the match element is presented in . As illustrated the match element may include four data inputs and two outputs and six control inputs and . Moreover the match element may include two 2 to 1 multiplexers . While 2 to 1 multiplexers are illustrated it should be noted that other configurations such as a 3 to 1 multiplexer a 4 to 1 multiplexer or other elements may be utilized in place of the 2 to 1 multiplexers as desired for example to allow for flexibility in routing output configurations or as silicon space allows.

In one embodiment data input of the match element is coupled to row routing line data input is coupled to row routing line data input is coupled to special purpose routing line and data input is coupled to row routing line . Selection of these particular lines is illustrative only and has been chosen to demonstrate flexibility in receiving signals from the row . By choosing row routing line and row routing line as connecting to the match element parity between the GOTs can be established. For example a result of a first analysis performed on at least a portion of a data stream by one GOT in a first half of all the GOTs GOTs zero through three can be provided on routing line to the match element while a result of a second analysis performed by at least a portion of the data stream by another GOT in a second half of all the GOTs GOTs four through seven can be provided by routing line to the match element . Splitting the inputs this way can allow for reduced paths to provide results to the match element . Additionally by receiving a result from the special purpose element along special purpose routing line at the match element results of cascaded searches may be provided once to the match element . Finally selection of row routing line adds flexibility to the overall system of the row . However as noted these selections are merely illustrative.

As illustrated the data inputs of the match element may be coupled to the 2 to 1 multiplexer while the data inputs of the match element may be coupled to the 2 to 1 multiplexer . The 2 to 1 multiplexers may each also receive control signals from control inputs and which may for example be configured based on a loaded image performed during an initial configuration of the FSM lattice . In one embodiment the 2 to 1 multiplexer may receive a select signal S from control input a select signal S from control input and an output enable signal from control input . Similarly the 2 to 1 multiplexer may receive a select signal S from control input a select signal S from control input and an output enable signal from control input . The select signals S S may be utilized to select which of the data inputs are to be coupled to output and respectively for providing analysis results of a data search to for example output block . Furthermore use of multiple select lines providing the select signals S S may allow for each of the 2 to 1 multiplexers to be built without an inverter thus reducing the area required to implement the 2 to 1 multiplexers . However in one embodiment a single select line carrying a single select signal e.g. S may be utilized. Additionally in one embodiment the output enable signal may be deleted.

Additionally the output enable signals from control inputs and may be clocking signals or other enable signals that allow for signals on outputs and to be provided only when the signals on data inputs and should be stable. Additionally the output enable signals from control inputs and may be clocking signals or other enable signals that allow for outputs and to be provided only when the signals on data inputs and are stable. In other examples the output enable signals can be eliminated.

As noted above the signal provided by either output or of the match element may by any result based on the initial configuration of the FSM lattice . These results may be provided to a storage element for example the results memory . One embodiment of such a results memory is illustrated in .

The results memory may be divided into four memory elements and two of which each corresponds to a respective one of the half lattices of the FSM lattice . For example memory elements and may correspond to half lattice while memory elements and may correspond to half lattice . This setup may allow for simultaneous read and write operations to be executed for memory corresponding to a respective half lattice . For example memory element may have data written thereto while memory element is simultaneously has data read therefrom. In one embodiment each of the memory elements and may be DRAM memory elements or any other suitable storage devices. In one embodiment memory elements and are for example portions of a single memory chip element and memory elements and are portions of a separate memory chip element . In some embodiments the memory elements and may operate as initial buffers to buffer the results received from the FSM lattice as provided by results bus . The results memory may be configured to store a received result in a particular portion of the results memory based on a characteristic of the result such as an indication of a location in the FSM lattice from which the result was provided. For example storage locations in memory elements and may store matches provided by results bus from half lattice of the FSM lattice . Similarly storage locations in memory elements and may store matches provided by results bus from half lattice of the FSM lattice . This storage may be accomplished in conjunction with signals provided to the results memory from for example programming interface .

In one embodiment the results provided to the results memory may indicate that a final result has been found by the FSM lattice . For example the results may indicate that an entire pattern has been detected. Alternatively the results provided to the results memory may indicate for example that a particular state of the FSM lattice has been reached. For example the results provided to the results memory may indicate that one state i.e. one portion of a pattern search has been reached so that a next state may be initiated. In this way the result memory may store a variety of types of results.

In some embodiments IR bus and process buffer interface may provide data to multiple FSM lattices for analysis. This data may be time multiplexed. For example if there are eight FSM lattices data for each of the eight FSM lattices may be provided to all of eight IR bus and process buffer interfaces that correspond to the eight FSM lattices . Each of the eight IR bus and process buffer interfaces may receive an entire data set to be analyzed. Each of the eight IR bus and process buffer interfaces may then select portions of the entire data set relevant to the FSM lattice associated with the respective IR bus and process buffer interface . This relevant data for each of the eight FSM lattices may then be provided from the respective IR bus and process buffer interfaces to the respective FSM lattice associated therewith. In this manner data received by any FSM lattice of the state machine engine may be time multiplexed. Accordingly as noted above the results provided by analysis of this data may also be time multiplexed.

Thus the results memory may operate to correlate each received result with a data input that generated the result. To accomplish this a respective result indicator may be stored corresponding to and in some embodiments in conjunction with each result received from the results bus . In one embodiment the result indicators may be a single bit flag. In another embodiment the result indicators may be a multiple bit flag. If the result indicators may include a multiple bit flag the bit positions of the flag may indicate for example a count of the position of the results in input data stream the lattice that the results correspond to a position in set of results or other identifying information. These result indicators may allow for proper grouping and provision of results to output bus for example to compressor . Moreover the ability to identify particular results by their respective result indicators allow for selective output of desired results from the result memory . Thus only particular results provided by the FSM lattice may be selectively provided to output bus . In conjunction with e.g. before after or concurrently with determining that a result should be stored in a particular portion of the storage element the results memory can determine whether a storage location is available in that portion e.g. memory element . If the storage location is available in the determined portion the result can be stored in that portion.

Situations may arise however in which one of the memory elements or becomes full e.g. a storage location is not available in that portion of the results memory . In this situation the results memory may implement an overflow process. This overflow process may include switching the storage location of received results . For example while memory element is typically associated with stores results from half lattice of the FSM lattice if for example memory element becomes full one or more currently stored results in memory element may be copied to locations in memory element to make room for new results to be stored in memory . Alternatively or additionally results originally intended for memory may instead be stored in memory element when memory element is full. In either situation the result indicators associated with any results stored in an adjacent memory will allow for proper output of the respective results . Thus when this overflow process commences the results memory may be configured to search both memory elements and or and when looking to output a particular set of results . This may be accomplished based on for example instructions provided by the programming interface .

Additional situations may occur in which the above discussed overflow process is insufficient to overcome overflow of the results memory . For example both memory elements and may be full. In this situation the results memory may operate to halt analysis of data by a FSM lattice . For example the results memory may provide an indication to for example the FSM lattice the IR bus and process buffer interface and or the DDR3 bus interface to indicate that processing of data in the FSM lattice should halt. Once sufficient memory becomes available in the results memory i.e. one or more results are read out of the results memory a second indication may be provided from the results memory to for example the FSM lattice the IR bus and process buffer interface and or the DDR3 bus interface to indicate that analysis of data in the FSM lattice may resume. In this manner the results memory may include an analysis override for the state machine engine .

While the invention may be susceptible to various modifications and alternative forms specific embodiments have been shown by way of example in the drawings and have been described in detail herein. However it should be understood that the invention is not intended to be limited to the particular forms disclosed. Rather the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the following appended claims.

