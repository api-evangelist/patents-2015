---

title: Automatic malware signature extraction from runtime information
abstract: A computer system receives a file and instruments an original code of the file in memory. The resulting instrumented code allows for collection of runtime information of the original code. An unpacking routine that includes one or more instructions that execute several times, modify memory locations, and execute instructions in the modified memory locations is identified. The unpacking routine is deemed a malware signature and incorporated into a malware pattern. An unpacking behavior diagram can also be generated from the runtime information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09516055&OS=09516055&RS=09516055
owner: Trend Micro Incorporated
number: 09516055
owner_city: Tokyo
owner_country: JP
publication_date: 20150529
---
The present invention relates generally to computer security and more particularly but not exclusively to methods and systems for generating patterns for malware detection.

Various types of malware such as computer viruses worms Trojans rootkits and other malicious codes have plagued computer systems throughout the world. Malware may be detected by antivirus programs or other computer security software. An antivirus program may include malware patterns that contain signatures of known malware. The antivirus program may employ a pattern matching algorithm to scan files or other data format for content that match one or more malware signatures. Pattern matching is a relatively effective algorithm for detecting malware. However pattern matching is reliant on having access to up to date and accurate malware patterns.

Malware signatures may be extracted from sample data that contain malware. The malware signatures may be formed into patterns that are distributed to computers that employ compatible antivirus programs. A malware pattern may comprise a hash e.g. a cyclic redundancy check a manually created script or an automatically created script e.g. based on binary similarity . A major challenge facing today s antivirus researchers is how to generate effective malware patterns efficiently and quickly given the large number of sample data that potentially contain malware.

In one embodiment a computer system receives a file and instruments an original code of the file in memory. The resulting instrumented code allows for collection of runtime information of the original code. An unpacking routine that includes one or more instructions that execute several times modify memory locations and execute instructions in the modified memory locations is identified. The unpacking routine is deemed a malware signature and incorporated into a malware pattern. An unpacking behavior diagram can also be generated from the runtime information.

These and other features of the present invention will be readily apparent to persons of ordinary skill in the art upon reading the entirety of this disclosure which includes the accompanying drawings and claims.

In the present disclosure numerous specific details are provided such as examples of apparatus components and methods to provide a thorough understanding of embodiments of the invention. Persons of ordinary skill in the art will recognize however that the invention can be practiced without one or more of the specific details. In other instances well known details are not shown or described to avoid obscuring aspects of the invention.

Referring now to there is shown a schematic diagram of a computer system in accordance with an embodiment of the present invention. The computer system may be employed to generate malware patterns for an antivirus for example. The computer system may have fewer or more components to meet the needs of a particular application. The computer system may include one or more processors . The computer system may have one or more buses coupling its various components. The computer system may include one or more user input devices e.g. keyboard mouse one or more data storage devices e.g. hard drive optical disk Universal Serial Bus memory a display monitor e.g. liquid crystal display flat panel monitor a computer network interface e.g. network adapter modem and a main memory e.g. random access memory . The computer network interface may be coupled to a computer network which in this example includes the Internet.

The computer system is a particular machine as programmed with software modules which in the example of includes a malware pattern generator . The malware pattern generator may comprise computer readable program code stored non transitory in the main memory for execution by the processor . The malware pattern generator may automatically extract malware signatures from sample data e.g. files and generate corresponding malware patterns . The malware patterns may be released and distributed to one or more subscribing computers that include an antivirus program or other computer security module that employs the malware patterns to detect malware.

The malware pattern generator is depicted in as being implemented in software for illustration purposes only. In other embodiments the malware pattern generator may be implemented in hardware e.g. application specific integrated circuit logic circuit or combination of hardware and software.

In the example of the computer system includes or has access to a sample data store . In one embodiment the sample data store comprises a plurality of files obtained from user submissions computer security vendors honey pots and other sources of potentially malicious data. As will be more apparent below the computer system may retrieve a file from the sample data store collect runtime information of an original code of the file in memory automatically extract a malware signature of the file from the runtime information and generate a pattern that incorporates the extracted malware signature.

In the example of the pre filter receives the file see arrow and determines whether or not the file comprises malware. In one embodiment the pre filter queries a binary reputation service hosted by a remotely located computer system to determine a reputation of the file see arrow . The binary reputation service may maintain a database or other listing of reputations of known files. A file may have a good reputation i.e. known good file a bad reputation i.e. known bad file such as a file that comprises malware a suspicious reputation i.e. a file that is most likely bad but unconfirmed or an unknown reputation. The pre filter may generate a hash of the binary also referred to as an executable of the file and provide the hash to the computer system . The computer system may determine the reputation of the file by comparing the hash of the binary of the file to hashes of binaries of known files. The computer system may provide the reputation of the file to the pre filter of the computer system .

Generally speaking a packed file is a file that has been compressed to reduce the size of the file. The packed file includes an unpacking routine that decompresses the packed file into memory during runtime. That is the unpacking routine unpacks the file into the memory when the file is executed. The UPX Ultimate Packer for eXecutables program is an example of a well known file packer. The binary of a malware file may be packed to make the malware harder to detect. Accordingly the pre filter deems a packed file to be a suspicious file. The pre filter may employ an entropy deviation algorithm to identify a packed file. The pre filter may also employ other suitable algorithms for identifying packed files.

In the example of the pre filter optionally pre filters the files from the samples data store such that the malware pattern generation process is performed only on suspicious files i.e. files that have the characteristics of malware and are thus likely to be malware but have not been confirmed to be malware. Files confirmed to be malware may be presumed to already have corresponding malware patterns. In other embodiments the malware pattern generation process is performed on a different subset of files or on all files in the sample data store . In the example of the file is deemed to be suspicious and is accordingly passed on to the sandbox environment for further analysis.

The sandbox environment provides a safe computing environment where a target file which in this example is the file may be safely executed without compromising the computer system . The sandbox environment may be implemented using the CUCKOO SANDBOX malware analysis system for example. Other suitable sandboxes or tools for creating an isolated computing environment may also be employed. The sandbox environment may include a virtual machine for executing the instrumentation module and a target file. The sandbox environment may receive target files from the pre filter or other sources distribute the target files to the virtual machine for runtime analysis and collect runtime information of the target files from the instrumentation module .

In one embodiment the instrumentation module comprises a dynamic binary instrumentation tool. The instrumentation module may be implemented using the PIN instrumentation tool from the INTEL CORPORATION. Other suitable instrumentation tools may also be employed. When a target file is executed in the virtual machine the binary code of the target file which is also referred to herein as original code is loaded in memory for execution as a process. The instrumentation module inserts instrumentation code into the original code in memory to generate an instrumented code. The instrumentation code allows for monitoring of the process of the target file at runtime. More specifically the instrumentation code may collect runtime information of the original code such as the type of instructions generic stack operation memory read memory write memory read write executed instruction addresses instruction execution counts modified memory contents API application programming interface call records etc.

In the example of an original code to be instrumented is loaded into memory. The original code is the code of a target file. The instrumentation module inserts an instrumentation code into the original code to generate the instrumented code . In the example of the instrumentation code comprises a plurality of instructions that are inserted in various locations on the original code to collect information from the original code during runtime such as memory modifications made by the original code routines of the original code that are executed in loops API calls of the original code etc. In general the instrumentation module may insert an instruction before and or after particular instructions such as instructions that write to memory locations perform loops manipulate the instruction pointer etc.

Referring back to the pre filtered file is received in the sandbox environment see arrow . There the instrumentation module inserts instrumentation code into the original code of the file in memory to generate an instrumented code see arrow . The instrumented code is executed with the instrumentation code collecting runtime information therefrom. The collected runtime information is received by the sandbox environment see arrow . The collected runtime information may include instructions noted by the instrumentation code contents of modified memory locations number of times particular instructions are executed etc. see output . The collected runtime information may be received by the pattern creator see arrow which generates a malware pattern see arrow that includes a malware signature identified from the collected runtime information.

A clustering module may optionally cluster identified malware signatures to determine if a malware signature appears in a plurality of target files see arrow . For example the clustering module may generate a context triggered piecewise hashing CTPH hash of a malware signature identified from the file and compare the resulting CTPH hash to CTPH hashes of other malware signatures of other target files. This allows for determination as to whether or not the malware signature extracted from the file appears in more than one target file. If so the malware signature is most likely highly useful in identifying other malware. To generate a CTPH hash the clustering module may employ the SSDEEP CTPH hash generator for example. The clustering module may also employ other suitable hash generators.

An instrumentation code may perform different actions depending on the instruction type. For a memory modification instruction such as mov edi eax the instrumentation code may identify the instruction type e.g. IARG MEMORYREAD EA IARG MEMORYWRITE EA offset to current instruction e.g. EIP and memory address being modified. The memory address being modified may be consolidated on each pass into a modified range. For example with the following memory address modifications 

the modification range is from 0x01 to 0x03. The instrumentation code may also identify the execution count number of times the instruction is executed for loop identification when the instruction involves memory modification. For a general instruction the instrumentation code may identify the instruction type offset to current instruction and execution count.

In the example of a target file is received from a sample data store input . A binary reputation service is queried to determine a reputation of the target file step . The method ends i.e. a malware pattern is not generated for the target file when the target file does not have a suspicious reputation.

When the target file has a suspicious reputation the execution behavior of the target file is analyzed step . In one embodiment the execution behavior of the target file is analyzed by adding an instrumentation code in an original code of the target file as loaded in memory. The instrumentation code collects runtime information of the original code during execution output . The runtime information is analyzed to identify a suspicious code block step such as a code block containing one or more instructions that are executed several times that modify memory locations and execute instructions written in the modified memory locations. The suspicious code block may comprise an unpacking routine. The method ends when the original code of the target file does not have a suspicious code block.

When the original code of the target file has a suspicious code block the suspicious code block may be designated as the target file s malware signature. A CTPH hash of the code block is generated step and the similarity of the CTPH hash to other CTPH hashes of other malware signatures extracted from other files is determined step . The method ends when the CTPH hash comparison indicates that there are no other files with the same or similar malware signature as the target file.

When the CTPH hash comparison indicates that there are other files with the same or similar malware signature as the target file a corresponding malware pattern that incorporates the malware signature is generated step . The malware pattern may incorporate the malware signature as is or convert the malware signature into some other format that is compatible with an antivirus program or other computer security module that may employ the malware pattern to detect malware by pattern matching. The malware pattern may be checked against samples of known bad files to check for effectiveness and against samples of known good files to check for false positives step . The method ends when the malware pattern is ineffective e.g. cannot detect known malware or results in an unacceptable number of false positives. Otherwise the malware pattern is released for use by a compatible antivirus program e.g. see antivirus of or other computer security module to detect malware.

It is to be noted that packed files are not necessarily bad. However malware writers have been known to pack files to make malware more difficult to detect. In the case of known file packer programs such as the UPX program a computer security module may easily unpack and examine a packed file in a sandbox environment. However this is not the case when a file is packed using an unknown file packer. As can be appreciated from the foregoing embodiments of the present invention allow for detection of unknown unpacking routines which are most likely employed in malware.

Embodiments of the present invention may be employed not just for automatically identifying malware signatures and generating malware patterns but also in other computer security related applications. In one embodiment the unpacking behavior diagram generator see generates an unpacking behavior diagram from runtime information collected from an instrumented code see arrow . As its name implies an unpacking behavior diagram graphically illustrates the unpacking action of an original code allowing for faster and easier identification of suspicious unpacking routines.

Beginning with there is shown an unpacking behavior diagram generated from runtime information in accordance with an embodiment of the present invention. In the example of the unpacking routine which is shown in employs a simple XOR decoding algorithm. The behavior of the unpacking routine may be detected by instrumentation code comprising instructions before and after an XOR instruction. In the example of the collected runtime information indicates that an XOR instruction in location 0x4010F6 is executed 0xC1 times represented by the dashed line from left to right and modified the memory locations 0x401000 to 0x4010C0. This is indicative of an unpacking routine and would be highly suspicious if the unpacking routine is unknown. As can be appreciated although the behavior of an unpacking routine can be automatically detected by the malware pattern generator having a diagram that graphically shows the unpacking behavior is very helpful to a human antivirus researcher in analyzing the malware. As a particular example a pattern reviewer can readily identify the memory modification behavior of the unpacking routine from the unpacking behavior diagram.

While specific embodiments of the present invention have been provided it is to be understood that these embodiments are for illustration purposes and not limiting. Many additional embodiments will be apparent to persons of ordinary skill in the art reading this disclosure.

