---

title: Machine identity persistence for users of non-persistent virtual desktops
abstract: Examples perform creation of a non-persistent virtual machine with a persistent machine identity associated with the user of the virtual machine, to provide consistent virtual desktop sessions to the user. Some examples contemplate that the machine identity is inserted into a virtual machine created through cloning, forking, or from a virtual machine pool.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09513949&OS=09513949&RS=09513949
owner: VMware, Inc.
number: 09513949
owner_city: Palo Alto
owner_country: US
publication_date: 20150205
---
This application claims the benefit of U.S. Provisional Patent Application Ser. No. 62 041 045 filed Aug. 23 2014 entitled Machine Identity Persistence for Users of Non Persistent Virtual Desktops and U.S. Provisional Patent Application Ser. No. 62 041 044 filed Aug. 23 2014 entitled Rapid Suspend Resume for Virtual Machines via Resource Sharing both of which are incorporated by reference herein in their entireties.

This application is related to U.S. Non Provisional patent application entitled Rapid Suspend Resume for Virtual Machines via Resource Sharing filed concurrently herewith which is incorporated by reference herein in its entirety.

Non persistent virtual desktop infrastructure VDI designs create a pool of virtual desktops and assign users dynamically to any available machine in the pool at the point when users make a request for a remote session. Non persistent VDI designs e.g. pools direct users to random virtual machines VMs each time resulting in a new machine identity each time. Some software does not function properly in this context because it checks for a stable machine identity for licensing or security reasons. User installed applications that may be preserved using layering technology could lead to installation of applications that expect a stable machine identity at each application launch.

For example certain classes of software fail to function properly within these VDI designs because they expect a stable machine identity. Other types of software insist on seeing a stable and static machine name for licensing reasons and will embed the name of the machine on which they were originally installed into the Registry or other configuration file and check it at each application launch to validate that it is running on the same machine.

Some non persistent designs cannot accommodate such software and users needing these types of applications would need to be assigned to persistent virtual desktop. Some existing non persistent VDI designs do not accommodate the installation of applications by users themselves. The desktops are typically locked down from a security standpoint which prevent such installations and there is no way to preserve user changes across linked clone recompose operations anyway.

Some systems use layering technology to preserve user state across linked clone pool operations such as recompose refresh rebalance including any user installed applications UTA such as AppVolumes by VMware Inc. These layering approaches retain the storage efficiency enabled by linked clone based non persistent designs while offering persistent design functionality to users.

However the UIA capability available to non persistent designs also introduces some compatibility risks. Whereas previously the administrator was in a position to place users on the appropriate type of VDI desktop based on what type of applications they needed and whether their applications required a persistent machine identity in the UIA enabled non persistent designs it is entirely possible for users to themselves install an application of the type requiring a persistent machine identity and find out upon their next VDI login that the installed application won t function and throws errors related to the changed machine name of the new VM on which the user is placed.

One or more examples described herein enable the creation and retention of a machine identity associated with a user for use on a virtual machine operated on a non persistent desktop. A user logs into a VDI broker using a client device such as a laptop computer interface desktop or other device. The VDI broker creates a machine identity if none exists or retrieves the machine identity associated with the user from local or remote storage. The machine identity includes information such as a machine name security identifier SID globally unique identifier GUID or other operating system specific identity. The machine identity associated with the user is then saved after the user ends the session.

This summary introduces a selection of concepts in a simplified form that are described in more detail below. This summary is not intended to identify essential features nor is it to be used as an aid in determining the scope of the claimed subject matter.

Aspects of the disclosure manage machine identity to accommodate installation of applications to provide at least a seamless and robust desktop experience to users in the context of non persistent design with user installed applications UTA enabled. Examples of the disclosure insert the same machine identity to a virtual desktop infrastructure VDI desktop built on demand using cloning retrieved from a virtual machine VM pool or forked using shared storage with the result that users e.g. always receive a non persistent VM which has the same machine name even though the underlying VM has changed. With the present disclosure users can install more challenging applications in a non persistent VDI design including those that demand persistence of the machine identity.

While operable with any form of VM pool or VM creation some examples of the disclosure leverage the high speed of a hot cloning functionality referred to as VMFork by VMware Inc. to facilitate the insertion of a specific machine identity during the machine creation process that is coupled to the requesting user such that each time a user requests a desktop session on a non persistent pool a VM will be created using VMFork methods and the specific machine identity coupled to the requesting user will be inserted into the machine using guest customization operations.

Examples of the disclosure enable administrators to retain the benefits of a non persistent VDI pool while providing the functional benefits of a persistent VDI pool. Layering technologies that allow preservation of user installed applications within a non persistent pool now carry less risk because a broader range of applications can be properly handled with this invention. For example a state may be restored to the child VM where the state describes applications some of which may require the same machine identity as when installed or activated . Some examples of the disclosure enable use of a new VM on top of a built on demand or non persistent strategy yet still provide the user with user installed applications UTAs . The disclosure provides a stable machine identity across sessions.

Virtual persistence helps hide the underlying VDI architecture ensuring that users always have a seamless persistent user experience that offers broader application compatibility.

Some operations described herein are described in the context of forking operations such as those provided by VMFork from VMware Inc. Forking and VMFork in particular differs from linked clones for VM instantiation. Linked clones are a storage construct whereas VMFork is a memory construct and a storage construct. VMFork uses linked clones but also has a COW memory strategy such that all content is initially shared and changes are tracked as COW memory pages for each child VM. For example while some linked VM clones use small delta disks that reference a larger base disk of another VM these systems lack a mechanism for online customization of the instantiated VMs e.g. performed while the VMs are powered on . For example as linked VM clone functionality does not inherently include customization some of the existing systems rely on offline domain join techniques e.g. performed while the VMs are powered off . As another example these systems are unable to configure instantiated VMs with different states. Further many guest operating systems require rebooting or other operations with a high time cost to set identities within the instantiated VMs due to restrictions at the operating system level.

VMFork enables hot cloning of virtual machines. At a high level there is a notion of a parent VM which is loaded in memory within the hypervisor but no longer executing. The parent goes into this special suspended state when a command is issued to the hypervisor from a script running inside the parent VM itself. At some future point a command is issued to the same hypervisor to Fork a Child VM which results in a new VM definition being created on the hypervisor but which initially shares all of its memory pages with he suspended VM parent. The child starts executing at the point where the parent VM was frozen which means it will be continuing to execute the script that was the cause of the parent VM being suspended. The next operations in this same script typically do some cleanup work to prepare the child VM for usage such as cycling the network interface card NIC driver in order to pick up the new media access control MAC address and obtain a valid Internet Protocol IP address by dynamic host configuration protocol DHCP .

VMFork based VDI provisioning quickly creates child VMs. A child VM can be created in a little as 1 second in some operating systems and even with the overhead of addition tasks operating in other operating systems complete provisioning may occur within 3 4 seconds. The workflow for VMFork based provisioning avoids all reboots of the machine yet is able to assign each child VM its own machine identity. The VM is Forked early enough in the boot up process on the parent VM that it is before certain elements of the operating system OS have initialized and it is therefore possible to pass in the desired machine identity information right after the child VM is created in a way that is consistent with what the OS expects during a normal boot sequence. The dynamic insertion of the machine identity info such as machine name is part of the provisioning process which itself completes in seconds. This dynamic insertion capability that is part of the new VMFork based provisioning technology enables persistence of user installed applications within a non persistent VDI design.

A user who authenticates to a conventional VDI broker may wait perhaps 5 seconds before receiving access to their virtual desktop. However examples of the disclosure enable creating a virtual desktop fully on demand in response to the user s request for a session within this 5 second window. This means that there is now an opportunity to insert a static machine identity into the VM based on the identity of the requesting user such that the resultant machine will always have the same machine identity even though it is a new VM.

 Virtual Persistence may be described as a logical abstraction layout between VM and the OS machine identity that ensures a stable machine identity for users each time they access a desktop within a non persistent pool. The actual machine identity chosen for a given user may either be assigned manually by an administrator ahead of first use of the non persistent pool or it could be randomly assigned at first use of the pool and persisted thereafter by way of the Virtual Persistence mechanism. Upon assignment the key machine identity element bound to a given user is persisted in a database or lightweight directory access protocol LDAP mechanism for later lookup. Upon requesting a desktop session at some future time the user s identity drives a lookup to the LDAP or database mechanism and the key identity elements are inserted into our new VMFork based machine creation process.

The key machine identify elements inserted in some examples include 1 machine name 2 configuration settings e.g. Active Directory machine account information 3 GUID or SID and or the like. By restoring these elements during machine creation the process implements Virtual Persistence between users and the identity of their virtual desktop even though the underlying VDI pool remains non persistent and VMs themselves are ephemeral and will be destroyed at the end of the user s session.

Virtual Persistence is an on demand virtual desktop creation design whereby the OS machine identity is inserted to the virtual desktop based on the identity of the calling user in such a way that users obtain a more fully persistent desktop experience atop an underlying non persistent pool. Unlike a true persistent VDI design where users are always directed back to the same actual VM Virtual Persistence as enabled by the operations described herein allows users to be directed to a newly created VM which contains the same machine identity information across sessions. VMFork provisioning technology offers provisioning speed to avoid introducing appreciable delays between the user s request for a desktop session and their access to same.

In the context of user installed applications UIA functionality within non persistent pool design Virtual Persistence allows users to install a greater range of applications with less risk of incompatibilities even for challenging applications that need to see the same machine name each time they are launched. With the disclosure such applications simply function properly as intended because the machine name is set to be the same as it was when the user first installed it even though the underlying VM container has changed.

Virtual Persistence helps further bridge the gaps of the past between a traditional persistent VDI VM and the more efficient non persistent desktop designs. It helps administrators retain the efficiencies of a non persistent design while offering users a more seamless persistent desktop experience that encompasses even applications that have failed in past non persistent designs. This abstraction layer between the VM and its OS identity offers new flexibility and helps mask the underlying VDI architecture from the user.

Some aspects of the disclosure are operable with pre built VMs e.g. no VMFork . Some aspects of the disclosure are operable with VMs built on demand e.g. with VMFork . In either group of examples the VMs are customized on the fly on demand in response to criteria. Example criteria or stimulus include the user logging into a virtual desktop infrastructure VDI broker or other identity asset repository. The VDI broker communicates the user identity information to the guest customization process or component to enable customization of the VM.

Aspects of the disclosure ensure virtual persistence reduce the amount of data processing on the host increase the speed of the host and other devices reduce an amount of data being transferred over a local area network LAN and or a wide area network WAN improve the functioning of the host itself use less memory reduce power consumption use of memory takes power reduce processor load reduce network bandwidth usage improve operating system resource allocation and or increase efficiency.

Example operations associated with the insertion of a user specific machine identity into a VM are described in the context of a virtualized environment such as next described with reference to .

Host computing device may include a user interface device for receiving data from a user and or for presenting data to user . User may interact indirectly with host computing device via another computing device such as VMware s vCenter Server or other management device. User interface device may include for example a keyboard a pointing device a mouse a stylus a touch sensitive panel e.g. a touch pad or a touch screen a gyroscope an accelerometer a position detector and or an audio input device. In some examples user interface device operates to receive data from user while another device e.g. a presentation device operates to present data to user . In other examples user interface device has a single component such as a touch screen that functions to both output data to user and receive data from user . In such examples user interface device operates as a presentation device for presenting information to user . In such examples user interface device represents any component capable of conveying information to user . For example user interface device may include without limitation a display device e.g. a liquid crystal display LCD organic light emitting diode OLED display or electronic ink display and or an audio output device e.g. a speaker or headphones . In some examples user interface device includes an output adapter such as a video adapter and or an audio adapter. An output adapter is operatively coupled to processor and configured to be operatively coupled to an output device such as a display device or an audio output device.

Host computing device also includes a network communication interface which enables host computing device to communicate with a remote device e.g. another computing device via a communication medium such as a wired or wireless packet network. For example host computing device may transmit and or receive data via network communication interface . User interface device and or network communication interface may be referred to collectively as an input interface and may be configured to receive information from user .

Host computing device further includes a storage interface that enables host computing device to communicate with one or more datastores which store virtual disk images software applications and or any other data suitable for use with the methods described herein. In some examples storage interface couples host computing device to a storage area network SAN e.g. a Fibre Channel network and or to a network attached storage NAS system e.g. via a packet network . The storage interface may be integrated with network communication interface .

The virtualization software layer supports a virtual machine execution space within which multiple virtual machines VMs may be concurrently instantiated and executed. Hypervisor includes a device driver layer and maps physical resources of hardware platform e.g. processor memory network communication interface and or user interface device to virtual resources of each of VMs such that each of VMs has its own virtual hardware platform e.g. a corresponding one of virtual hardware platforms each virtual hardware platform having its own emulated hardware such as a processor a memory a network communication interface a user interface device and other emulated I O devices in VM . Hypervisor may manage e.g. monitor initiate and or terminate execution of VMs according to policies associated with hypervisor such as a policy specifying that VMs are to be automatically restarted upon unexpected termination and or upon initialization of hypervisor . In addition or alternatively hypervisor may manage execution VMs based on requests received from a device other than host computing device . For example hypervisor may receive an execution instruction specifying the initiation of execution of first VM from a management device via network communication interface and execute the execution instruction to initiate execution of first VM .

In some examples memory in first virtual hardware platform includes a virtual disk that is associated with or mapped to one or more virtual disk images stored on a disk e.g. a hard disk or solid state disk of host computing device . The virtual disk image represents a file system e.g. a hierarchy of directories and files used by first VM in a single file or in a plurality of files each of which includes a portion of the file system. In addition or alternatively virtual disk images may be stored on one or more remote computing devices such as in a storage area network SAN configuration. In such examples any quantity of virtual disk images may be stored by the remote computing devices.

Device driver layer includes for example a communication interface driver that interacts with network communication interface to receive and transmit data from for example a local area network LAN connected to host computing device . Communication interface driver also includes a virtual bridge that simulates the broadcasting of data packets in a physical network received from one communication interface e.g. network communication interface to other communication interfaces e.g. the virtual communication interfaces of VMs . Each virtual communication interface for each VM such as network communication interface for first VM may be assigned a unique virtual Media Access Control MAC address that enables virtual bridge to simulate the forwarding of incoming data packets from network communication interface . In an example network communication interface is an Ethernet adapter that is configured in promiscuous mode such that all Ethernet packets that it receives rather than just Ethernet packets addressed to its own physical MAC address are passed to virtual bridge which in turn is able to further forward the Ethernet packets to VMs . This configuration enables an Ethernet packet that has a virtual MAC address as its destination address to properly reach the VM in host computing device with a virtual communication interface that corresponds to such virtual MAC address.

Virtual hardware platform may function as an equivalent of a standard x86 hardware architecture such that any x86 compatible desktop operating system e.g. Microsoft WINDOWS brand operating system LINUX brand operating system SOLARIS brand operating system NETWARE or FREEBSD may be installed as guest operating system OS to execute applications for an instantiated VM such as first VM . Aspects of the disclosure are operable with any computer architecture including non x86 compatible processor structures such as those from Acorn RISC reduced instruction set computing Machines ARM and operating systems other than those identified herein as examples.

Virtual hardware platforms may be considered to be part of virtual machine monitors VMM that implement virtual system support to coordinate operations between hypervisor and corresponding VMs . Those with ordinary skill in the art will recognize that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit or scope of the disclosure. For example virtual hardware platforms may also be considered to be separate from VMMs and VMMs may be considered to be separate from hypervisor . One example of hypervisor that may be used in an example of the disclosure is included as a component in VMware s ESX brand software which is commercially available from VMware Inc.

The host computing device may include any computing device or processing unit. For example the computing device may represent a group of processing units or other computing devices such as in a cloud computing configuration. The computing device has at least one processor and a memory area . The processor includes any quantity of processing units and is programmed to execute computer executable instructions for implementing aspects of the disclosure. The instructions may be performed by the processor or by multiple processors executing within the computing device or performed by a processor external to computing device. In some examples the processor is programmed to execute instructions such as those illustrated in the figures.

The memory area includes any quantity of computer readable media associated with or accessible by the computing device. The memory area or portions thereof may be internal to the computing device external to the computing device or both.

The memory stores a plurality of VM templates . In some examples VM templates are arranged in a hierarchy such as a tree hierarchy. However aspects of the disclosure are operable with VM templates stored in any structure. In such examples VM templates include a plurality of powered on parent VM templates . The powered on parent VM templates may be created and maintained by computing fabric cloud service and or by cloud services or by any other computing device . The parent VM templates may be classified categorized or otherwise described as derived VM templates and standalone VM templates. Derived VM templates are derived from one of the parent VM templates and inherit one or more disk blocks e.g. common disk blocks from that corresponding parent VM template . The standalone VM templates lack any such inherited disk block from parent VM templates . Aspects of the disclosure are operable with any form of disk block inheritance such as via a redo log array level snapshots e.g. using block reference counting etc.

In some examples each parent VM template includes a virtual device state for one of VMs shown in and a memory state for that VM . Memory further stores data describing a plurality of powered on child VMs .

In some examples cloud service specifies whether to create a standalone template or a derived VM template e.g. from another parent VM template . Cloud service also creates a defined quantity of registered e.g. to the cloud operating system but powered off child VMs using the createChildren function call. The createChildren function call also takes as input a childProperties argument which defines for example the identities e.g. hostname IP MAC address etc. and particular processor and or memory sizes of the powered on child VMs . If the sizes are different from that of parent VM template computing fabric cloud service may either add those resources when powering on child VM e.g. a hot add or create a new parent VM template . In addition the childProperties argument also specifies how the created child VM behaves when powered on and or reset. For example when powered on the powered off child VM may act as an ephemeral entity that returns to the same original parent state or a regular VM that goes through a usual boot process.

In the execution phase powered off child VMs are instantiated using the powerOnChildren function call. The powerOnChildren function call leverages fast VM instantiation techniques such as those as described herein to quickly spawn VMs with minimal processor overhead. Powered on child VMs may also be powered off or reset using the powerOffChildren function call and the powerResetChildren function call.

In contrast to memory the example storage includes one or more disks. For example the storage stores data describing a plurality of powered off child VMs . Each of the powered off child VMs is instantiated on demand from one of the plurality of parent VM templates . Until then powered off child VMs use no memory resources. For example powered off child VMs are present in storage and when powered on the powered on child VMs share memory pages with powered on parent VM templates and enter into memory and the writes of the powered on child VMs are entered into memory as COW.

Child VMs have one or more properties characteristics or data associated therewith. Example child VM properties include but are not limited to hostname IP address MAC address domain identity processor size and or memory size. In some examples the child VM properties for each child VM e.g. second VM may be referred to as configuration data . Storage further stores parent VM disks and child VM disks e.g. .vmdk files for use by VMs .

After instantiation powered off child VMs are registered to a cloud operating system. The cloud operating system is executed by the computing device . Registration of one of the powered off child VMs includes identifying the powered off child VM to the cloud operating system and occurs before the powered off child VM is powered on or otherwise executed. In this manner the powered off child VM is said to be pre registered with the cloud operating system. In some examples the cloud operating system is the hypervisor . By registering the powered off child VMs the cloud operating system is no longer in the critical path when cloud services commission VMs thus reducing the amount of time needed for child VMs to become available. However aspects of the disclosure are also operable with registration occurring on the child VM instantiation path.

In some examples configuration data for the child VM is defined created received and or registered prior to receiving a request to fork the child VM e.g. from a management level application . In other examples configuration data is defined in response to receiving the request to fork the child VM. Configuration data may be defined from default values set by an administrator received in the request from the management level application and or populated with data from other sources. Example configuration data for a child VM includes an IP address a MAC address a hostname a domain identity a set of attributes and or any other state data to be applied when customizing the identity of the powered on child VMs . In some examples configuration data is stored in a file such as a .vmx file with one file per powered on child VM or powered off child VM . Configuration data may be registered with virtualization software such as the cloud operating system.

In some examples the computing device defines a virtual device state of the child VM based on virtual device state of the parent VM template . For example defining the virtual device state of the child VM includes copying virtual device state from the parent VM template . As another example defining the virtual device state of the powered on child VM or powered off child VM collectively child VM or includes creating a COW delta disk referencing virtual device state of the parent VM template . Alternatively the virtual device state depends for example on criteria associated with user e.g. user criteria the system capabilities or the applications the child VM is running.

The computing device in some examples defines creates receives and or registers persistent storage for the child VM or based on persistent storage .vmdk of the parent VM template . In some examples persistent storage for the child VM or is stored in a file such as a .vmdk file. For example defining the persistent storage for the child VM or includes referencing persistent storage of the parent VM template . In some examples referencing persistent storage of the parent VM template includes creating a read only base disk referencing persistent storage of the parent VM template and creating a COW delta disk associated with the child VM to store changes made by the child VM to the base disk.

In some examples computing device defines creates receives and or registers memory for the child VM or based on memory of the parent VM template . In some examples referencing memory of the parent VM template includes creating COW memory associated with the child VM to store changes made by the child VM to memory of the parent VM template . In this manner the child VM or shares memory state of the parent VM template with COW memory pages in contrast with linked clones that use COW delta disks.

The computing device executes e.g. powers on the powered off child VM which becomes powered on child VM . Execution of the powered off child VM includes configuring an identity of child VM or using configuration data . In some examples execution of the powered off child VM includes configuration and execution of a boot process or bootup process to access and apply configuration data to the powered off child VM . In this manner child VM or customizes itself during bootup. The now executing powered on child VM has a virtual device state that is a copy of virtual device state of the parent VM template with persistent storage referencing persistent storage of the parent VM template .

In some examples the bootup process is executed by a guest operating system shown in on child VM or . The bootup process includes for example a command to perform a synchronous remote procedure call RPC to the cloud operating system to obtain and apply configuration data . An example format for the RPC is rpc info get .

The forked child VM or may be configured in different ways dependent in part on a type of guest operating system executing on child VM or . One example for configuring an identity of the child VM or is next described.

In some examples of the disclosure the boot process applies customization to the powered on child VM . The boot process includes a blocking agent that prevents the child VM or from completing bootup until certain operations have completed. For example the blocking agent is injected into the boot process to prevent the guest operating system on the child VM or from accepting user level commands until the identity of the now powered on child VM has been configured.

The powered on child VM in some examples accesses configuration data which specifies a domain identity to be applied to the powered on child VM . The domain identity is one of a plurality or pool of previously created domain identities available to the child VM . The plurality of domain identities are created for example by an administrator before the virtual device state of the child VM and the persistent storage of the parent VM template are defined.

The domain identity is pre selected e.g. explicitly identified in configuration data in some examples or selected during execution of the bootup process e.g. based on characteristics of executing powered on child VM . The specified domain identity is from the pool of previously created identities. Then the obtained domain identity is applied to the powered on child VM . In some examples applying the obtained domain identity includes performing an offline domain join operation or any method that allows a computer system to join a domain without a reboot.

In operation preparing the parent VM template may be performed for example by a guest agent residing inside a guest operating system of the parent VM template . The guest agent issues a fork command to quiesce the parent VM template into the ready to fork state at an appropriate boot stage of the parent VM. As provisioning operations are initiated the one or more powered on child VMs are forked without a committed identity. As the boot process continues inside each powered on child VM the various identities are applied to the powered on child VMs . For example due to the forking process as described herein a copy of the guest agent from the parent VM template appears in each powered on child VM . The copy of the guest agent resumes execution inside each powered on child VM as part of the boot process of the guest operating system . In this post fork stage for each child VM or the guest agent obtains e.g. from a data store available to the guest operating system of the child VM or and applies one or more identities to the child VM or . For example the identities or other parameters are stored as part of configuration data in a .vmx file or other file stored by the cloud operating system and accessible via API from within the guest operating system . In operation the guest operating system synchronously requests and receives one of the identities from the cloud operating system to perform an offline domain join e.g. update the identity in place before proceeding through the tail end of the bootup process e.g. before the system launches the logon service .

The operations discussed above may be embodied as computer executable instructions stored on one or more computer readable media. The instructions when executed by processor configure an identity of a forked VM based on a pool of available domain identities.

The forking and state customization operations illustrated and described may be implemented using templates and API to configure and deploy the powered on child VM in response to a request from cloud service . In an example of such examples computing device creates and maintains a hierarchy of parent VM templates and child VMs or in some examples. For example computing device maintains a set of powered on parent VM templates and a set of powered off child VMs . Parent VM templates are created in some examples in response to a request from at least one of cloud services . Alternatively or in addition parent VM templates are created on demand by computing device after detecting patterns in VM provisioning requests from cloud services . Maintaining the set of parent VM templates includes for example powering on each of parent VM templates . Each child VM or is instantiated from one of parent VM templates in response to a request for the child VM or . Maintaining the set of child VMs or includes for example pre registering each instantiated child VM or to the cloud operating system e.g. before being initiated or otherwise powered on . Alternatively or in addition one or more of cloud services may create and maintain one or more of parent VM templates .

In the teardown phase parent VM templates and child VMs or may be destroyed using the destroyParentTemplate and destroyChildren function calls. Depending on whether parent VM template is part of the template hierarchy e.g. a derived VM template or a standalone template destroying the template may leave some of it on the disk. The destroyChildren function call turns off child VM e.g. power down and resets the child VM or properties such as identity etc.

In automatic mode rather than have parent VM templates be explicitly created via the function calls available in manual mode parent VM templates are automatically generated based on demand. For example cloud service uses the createChildrenAuto function call to create child VMs or . When a particular type of child VM or is requested repeatedly e.g. a plurality of requests are received for the same type of child VM or computing fabric cloud service creates a new powered on parent VM template deriving it from the appropriate parent VM template in the hierarchy. This optimization further simplifies the setup and teardown phases by eliminating the need for cloud services to explicitly create destroy and otherwise manage parent VM templates . In some examples the new parent VM template is created only if additional requests are expected for such VMs. For example if the request for a particular VM is a one off request the new parent VM template is not created.

VM instantiation operations are performed on VMs stored in one or more datastores. Example VM instantiation operations include but not limited to cloning copying forking and the like. VM instantiation operations may be performed by virtualization products such as VMware s ESX brand software e.g. in a kernel layer . In some examples VM instantiation operations implement fast suspend resume technology with COW page references e.g. rather than handing over pages entirely . While described in some examples herein with reference to VM forking routines those of ordinary skill in the art will note that the disclosure is not limited to these VM forking routines. Rather the disclosure is operable with any fast VM instantiation routines.

The VDI broker is in the example of connected to a VM pool . In the example illustrated by there are pre built VMs in the VM pool . These pre built VMs facilitate a shorter wait time between user request for a VM and delivery of the VM associated with the machine identity of user to user .

VDI broker also accesses usage rules in some examples. Usage rules include for example hours during which user is permitted to access the system amount of processing or memory resources user is entitled to applications user is permitted to install etc. Alternatively these usage rules are associated with the machine identity assigned to user .

In other examples VDI broker is not connected to a VM pool rather it is connected to a computing device which contains VM templates as illustrated in . In that example as user requests a VM the host computing device creates a child VM from the parent VM template . The child VM is created through any method known in the art for instance by cloning or by forking.

A machine identity associated with the user is determined at . As shown at in some examples the VDI broker optionally determines whether or not the user already has and or is associated with a machine identity. In some examples the user will not have a machine identity for example if it is the first time the user has used the system. If a machine identity does not exist for the user the VDI broker creates a machine identity for that user and associates the created machine identify with the user at . If the user has and or is associated with a machine identity the VDI broker retrieves the machine identity associated with the user from storage . The machine identity is stored locally in some examples externally or at a central repository in other examples. The machine identity is stored in the illustrated example on a database. It is stored in other examples on a Lightweight Directory Access Protocol LDAP directory.

The machine identity contains in some examples a machine name associated with the user an Active Directory accounts an SID or Windows brand operating system GUID or another unique identifier. The machine identity varies depending on the operating system OS . For instance the attributes which make up the machine identity vary for Windows Linux or MAC and the machine identity reflects those attributes. Further the machine identity in some examples contains rules for the user to access the system. For instance in some examples the machine identity contains rules prohibiting the user to access certain directories to access the system during certain hours or it prevents the user from editing various files. Further the machine identity in some examples maintains information about the applications installed or utilized by a user . In some examples this includes license keys and application specific user preferences. While the initial user desktop is selected when the user first requests a desktop from the VDI broker e.g. before the user ever logs into the desktop for the first time when the user installs an application configuration data e.g. a registry or other file or database is updated to include references to the machine identity of the user . The reference to the machine identity is in some examples persisted in a standard profile stored on a network or elsewhere such as on a user disk serviced by AppVolumes by VMware Inc. The application reads the machine identity each time the application queries the operating system.

A VM is then identified. For example in some examples the VM is created or retrieved from a VM pool for the user at . In some examples the computing device is associated with a VM pool . In this example the VDI broker inserts the machine identity into a VM retrieved from the VM pool . However in other examples the VM is created by cloning or forking a parent VM template through a process such as VMFork by VMWare Inc. At the machine identity is inserted into the created or retrieved VM and the VM is provided to the user at .

Five types of regions are illustrated on the machine pages . The first type of machine pages illustrated are boot pages illustrated with lines slanting upwards from left to right . Shared application pages shared app pages are illustrated with lines slanting downwards from left to right. Unmapped pages are illustrated by white area on the machine pages . Other pages created by the VMs are illustrated by cross hatches. Newly mapped pages are illustrated by horizontal lines.

After forking but before creating any new content the child VM or has no independent pages but rather relies on the stored pages of the parent VM template . The computing device tags marks configures or otherwise indicates that persistent storage of the parent VM template is COW. Tagging the persistent storage and memory of the parent VM template as COW prevents the parent VM template from modifying persistent storage or memory that the child VM or is relying upon. Instead if the parent VM template attempts to modify either persistent storage or memory a copy of that data is created for the parent VM template leaving the original persistent storage or memory intact.

Once the child VM or writes it creates its own copy of a page a copy on write COW version of that page. In the example of the child VM or writes to the shared app pages thus creating a COW page the newly mapped page in the figure. Once this new write has occurred the parent VM template still points to the shared app pages but the child VM or now points to its newly mapped page . reflects that after the COW pages are created the child VM or in this example does not point to the shared app pages of the parent VM template and thus the reference count for the shared app pages drop to 1. The reference counts for the newly mapped pages increase to 1 since the child VM or created that new page and now points to it. The reference counts for the boot pages and the other pages remain at 2 since in the example illustrated both the child VM or and the parent VM template still point to those pages.

After the child VM has created a newly mapped page it writes that page to the physical machine pages . After that newly mapped page is written there is one reference to it by the child VM or . In the example of there are two newly mapped pages created.

The first newly mapped page is a modification of an existing page stored by the parent VM template . In some examples the newly mapped page points back to the shared app pages which it modifies and only the changes made by the child VM or to the shared app pages are recorded on the newly mapped pages . In other examples the child VM or no longer relies on the parent VM template for the modified shared app pages and instead the child VM or only utilizes its newly created page.

The second newly mapped page is original content created by the child VM or . That newly mapped page does not indicate that it is a modification of any previously existing page. Instead that newly mapped page is solely tied to the child VM or and only the child VM or references it.

In the present disclosure upon request by a user or other initiating event a machine identity associated with the user is inserted into the child VM or . The child VM with the inserted machine identity is presented to the user . The machine identity installed on the child VM or ensures that the user has an experience which is consistent between virtual desktop sessions. For example the user will maintain license keys associated with applications the user is utilizing as part of the machine identity of the user . Consequently the user will not be required to reinstall applications on subsequent use or select preferences each time upon login. Rather this data in some examples is saved as part of the machine identity.

VMFork differs from linked clones for VM instantiation. Linked clones are only a storage construct whereas VMFork is a memory construct and a storage construct. VMFork uses linked clones but also has a Copy on Write memory strategy such that all content is initially shared and changes are tracked as Copy on write memory pages for each child VM. For example while some linked VM clones use small delta disks that reference a larger base disk of another VM these systems lack a mechanism for online customization of the instantiated VMs e.g. performed while the VMs are powered on . For example as linked VM clone functionality does not include customization some of the existing systems rely on offline domain join techniques e.g. performed while the VMs are powered off . As another example these systems are unable to configure instantiated VMs with different states. Further many guest operating systems require rebooting or other operations with a high time cost to set identities within the instantiated VMs due to restrictions at the operating system level.

VMFork based desktops have something unique unlike any existing VDI desktop it entails the ability to know at the hypervisor level which memory pages in the desktop VM are shared and which are unique. The VMFork parent VM initially shares all its memory pages with child VMs. Each memory page changed by the child VM is called a copy on write or COW memory page. Thus for VMFork based VMs a suspend operation by the hypervisor could write only these COW memory pages to disk rather than the full memory space of the VM. So long as the VMFork parent remains resident in memory on each ESX host a resume operation can load only the COW pages back into memory and re attach them to the VMFork parent logically. This is a form of logical deduplication. The VM is powered on by logically merging it with the contents of the replica on the fly presenting what looks like standalone disk and memory image for each VM.

VMFork based desktops initially share all of their memory pages but over time as users conduct their desktop activities more COW memory pages will be generated. For shorter running sessions or sessions where only a few applications are used the percentage of memory pages that remains shared with the VMFork parent remains high e.g. over 90 .

While described with reference to VMFork in some examples those skilled in the art will note that any infrastructure operations components and or configuration of hardware software and or firmware implementing the operations or their equivalents or variations described herein are within the scope of the disclosure. For instance the VMs are provided in alternative examples from a VM pool or through cloning as it is known in the art.

Aspects of the disclosure apply to any operating system capable of hosting virtual desktops including server operating systems and desktop operating systems.

Examples described herein fork and configure live child virtual machines VMs from a powered on parent VM with underlying memory and disk resource sharing. In some examples a script is executed to customize a state of each new forked VM to produce a child VM with a different state than the parent VM. For example based on a virtual device state of a suspended parent VM e.g. a first VM a virtual device state of the child VM e.g. a second VM is defined. Persistent storage of the child VM is also defined based on persistent storage of the parent VM.

Examples described herein further configure a state of each newly instantiated child VM based on configuration data for the child VM including configuring one or more identities on the fork path. The identities are configured without involving a reboot of the child VM despite any guest operating system level restrictions requiring reboot operations when configuring identities. Rebooting the child VM prevents the memory page sharing achieved by the forking operations described herein at least because the memory page sharing would be lost with the reboot. In this manner aspects of the disclosure are operable to instantly provision child VMs. Further eliminating reboot operations reduces overall provisioning time which reduces overall cost of ownership for users. The level of boot storm is also significantly reduced when customizing large quantities of child VMs thus reducing input output commands per second IOPS at the storage array level. Reducing IOPS reduces storage cost for users.

An example identity set includes but is not limited to one or more of the following items computer name domain machine account with domain join license client machine identifier with key management service KMS volume license activation media access control MAC address and or Internet Protocol IP address. For example a domain identity is selected at fork time from a pool of previously created domain identities. The selected domain identity is applied to the child VM in a way that does not confuse existing processes in the child VM. For example some examples prevent boot completion of the child VM until customization has finished.

In some examples the forking and identity configuration operations are implemented as part of a shared computing fabric cloud service that efficiently supports fast elastic and automatic provisioning of VMs for multiple cloud services e.g. tenants of computing fabric cloud service . Some examples of computing fabric cloud service present an application programming interface API that may be leveraged by many of cloud services to quickly scale in and scale out of VMs based on demand. In operation cloud services request resources and properties of the resources and computing fabric cloud service makes the resources available immediately instantaneously or otherwise faster than existing systems.

Aspects of the disclosure include a shared infrastructure e.g. computing fabric cloud service accessible via API that enables quick provisioning of VMs by managing a hierarchy of powered on templates and employing fast VM instantiation operations to quickly spawn VMs with desired properties. Some examples store parent VM templates in a tree hierarchy with each parent VM template representing a linked clone of its parent with its memory shared via copy on write COW . In some of those examples a set of child VMs pre registered to a cloud operating system is internally maintained for each template. The child VMs are created as a linked clone of the corresponding parent VM template. When one of cloud services commissions or otherwise requests provisioning of one or more VMs aspects of the disclosure create a COW share of a parent VM template memory to give to requesting cloud service.

In this manner and as described further herein computing fabric cloud service supports the instantaneous provisioning of VMs on demand allows for memory and disk content sharing across cloud services using parent VM templates common to cloud services and improves cloud service performance by eliminating use of hot spare VMs.

The operations described herein may be performed by a computer or computing device. The computing devices communicate with each other through an exchange of messages and or stored data. Communication may occur using any protocol or mechanism over any wired or wireless connection. A computing device may transmit a message as a broadcast message e.g. to an entire network and or data bus a multicast message e.g. addressed to a plurality of other computing devices and or as a plurality of unicast messages each of which is addressed to an individual computing device. Further in some examples messages are transmitted using a network protocol that does not guarantee delivery such as User Datagram Protocol UDP . Accordingly when transmitting a message a computing device may transmit multiple copies of the message enabling the computing device to reduce the risk of non delivery.

By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media are tangible non transitory and are mutually exclusive to communication media. In some examples computer storage media are implemented in hardware. Example computer storage media include hard disks flash memory drives digital versatile discs DVDs compact discs CDs floppy disks tape cassettes and other solid state memory. In contrast communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media.

Although described in connection with an example computing system environment examples of the disclosure are operative with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the disclosure include but are not limited to mobile computing devices personal computers server computers hand held or laptop devices multiprocessor systems gaming consoles microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Examples of the disclosure may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. The computer executable instructions may be organized into one or more computer executable components or modules. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the disclosure may be implemented with any number and organization of such components or modules. For example aspects of the disclosure are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other examples of the disclosure may include different computer executable instructions or components having more or less functionality than illustrated and described herein.

Examples described herein are operable with any cloud service such as those managing very large datasets e.g. big data those supporting virtual desktops and those providing a cloud computing platform as a service or other cloud service provider e.g. CLOUD FOUNDRY brand computer services . In part by creating and managing parent VM templates as described herein and performing the forking routines aspects of the disclosure are able to instantly provision e.g. under a second these and other cloud services with fully functional VMs with low e.g. minimal processor overhead. However those skilled in the art will note that some examples contemplate sourcing the VM from a VM pool.

Aspects of the disclosure transform a general purpose computer into a special purpose computing device when programmed to execute the instructions described herein.

The examples illustrated and described herein as well as examples not specifically described herein but within the scope of aspects of the invention constitute example means for implementing creation of a persistent machine identity for returning users.

At least a portion of the functionality of the various elements illustrated in the figures may be performed by other elements in the figures or an entity e.g. processor web service server application program computing device etc. not shown in the figures.

In some examples the operations illustrated in the figures may be implemented as software instructions encoded on a computer readable medium in hardware programmed or designed to perform the operations or both. For example aspects of the disclosure may be implemented as a system on a chip or other circuitry including a plurality of interconnected electrically conductive elements.

The order of execution or performance of the operations in examples of the disclosure illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and examples of the disclosure may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the disclosure.

When introducing elements of aspects of the disclosure or the examples thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements. The term exemplary is intended to mean an example of. 

Having described aspects of the disclosure in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the disclosure as defined in the appended claims. As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the disclosure it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

