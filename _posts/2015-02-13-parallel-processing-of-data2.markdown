---

title: Parallel processing of data
abstract: A data parallel pipeline may specify multiple parallel data objects that contain multiple elements and multiple parallel operations that operate on the parallel data objects. Based on the data parallel pipeline, a dataflow graph of deferred parallel data objects and deferred parallel operations corresponding to the data parallel pipeline may be generated and one or more graph transformations may be applied to the dataflow graph to generate a revised dataflow graph that includes one or more of the deferred parallel data objects and deferred, combined parallel data operations. The deferred, combined parallel operations may be executed to produce materialized parallel data objects corresponding to the deferred parallel data objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626202&OS=09626202&RS=09626202
owner: Google Inc.
number: 09626202
owner_city: Mountain View
owner_country: US
publication_date: 20150213
---
This application is a continuation of and claims the benefit of priority to U.S. patent application Ser. No. 14 033 145 filed on Sep. 20 2013 which is a Divisional of U.S. patent application Ser. No. 12 794 348 filed on Jun. 4 2010 now Issued U.S. Pat. No. 8 555 265 which claims the benefit of priority to U.S. Provisional Patent Application Ser. No. 61 331 148 filed on May 4 2010 the entire contents of which are hereby incorporated by reference.

Large scale data processing may include parallel processing which generally involves performing some operation over each element of a large data set. The various operations may be chained together in a data parallel pipeline to create an efficient mechanism for processing a data set.

In one aspect a system includes one or more processing devices and one or more storage devices. The storage devices store instructions that when executed by the one or more processing devices implement an application an evaluator an optimizer and an executor. The application includes a data parallel pipeline. The data parallel pipeline specifies multiple parallel data objects that contain multiple elements and multiple parallel operations that operate on the parallel data objects. The evaluator is configured based on the data parallel pipeline to generate a dataflow graph of deferred parallel data objects and deferred parallel operations corresponding to the data parallel pipeline.

Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet been performed on the input object.

The optimizer is configured to apply one or more graph transformations to the dataflow graph to generate a revised dataflow graph that includes one or more of the deferred parallel data objects and deferred combined parallel data operations. The executor configured to execute the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object.

Implementations of this aspect may include one or more of the following features. For example the deferred combined parallel data operations may include at least one generalized mapreduce operation. The generalized mapreduce operation may include multiple parallel map operations and multiple parallel reduce operations and be translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations. To execute the generalized mapreduce operation the executor may be configured to translate the combined mapreduce operation to the single mapreduce operation and execute the single mapreduce operation. To execute the single mapreduce operation the executor may be configured to determine whether to execute the single mapreduce operation as a local sequential operation or a remote parallel operation. To translate the generalized mapreduce operation to the single mapreduce operation the executor may be configured to generate a map function that includes the multiple map operations and a reducer function that includes the multiple reducer operations.

The pipeline further may include a single data object that contains a single element and the dataflow graph includes a corresponding deferred single data object. At least one of the multiple parallel operations in the pipeline may operate on the single data object and one of the multiple parallel data objects and the dataflow graph may include a corresponding deferred parallel operation that operates on a deferred single data object and a deferred parallel data object.

The executor may be configured to cache one or more results of the execution of the deferred combined parallel operations for use in a future execution of the data parallel pipeline.

In another aspect a method includes executing an application that includes a data parallel pipeline. The data parallel pipeline specifies multiple parallel data objects that contain multiple elements and multiple parallel operations that operate on the parallel data objects. The method further includes generating based on the data parallel pipeline a dataflow graph of deferred parallel data objects and deferred parallel operations corresponding to the data parallel pipeline. Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet been performed on the input object.

The method also includes applying one or more graph transformations to the dataflow graph to generate a revised dataflow graph that includes one or more of the deferred parallel data objects and deferred combined parallel data operations. In addition the method includes executing the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object.

Implementations of this aspect may include one or more of the following features. For example the deferred combined parallel data operations may include at least one generalized mapreduce operation. The generalized mapreduce operation may include multiple parallel map operations and multiple parallel reduce operations and be translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations. Executing the generalized mapreduce operation may include translating the combined mapreduce operation to the single mapreduce operation and executing the single mapreduce operation. Executing the single mapreduce operation may include determining whether to execute the single mapreduce operation as a local sequential operation or a remote parallel operation. Translating the generalized mapreduce operation to the single mapreduce operation may include generating a map function that includes the multiple map operations and a reducer function that includes the multiple reducer operations.

The pipeline further may include a single data object that contains a single element and the dataflow graph includes a corresponding deferred single data object. At least one of the multiple parallel operations in the pipeline may operate on the single data object and one of the multiple parallel data objects and the dataflow graph may include a corresponding deferred parallel operation that operates on a deferred single data object and a deferred parallel data object.

The method may include caching one or more results of the execution of the deferred combined parallel operations for use in a future execution of the data parallel pipeline.

In another aspect a system includes one or more processing devices and one or more storage devices. The storage devices store instructions that when executed by the one or more processing devices implement an executor. The executor is configured to access a dataflow graph that includes deferred parallel data objects and deferred combined parallel data operations. Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet been performed on the input object.

The executor is configured to execute the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object. For at least one of the deferred combined parallel operations the executor is configured to execute the at least one deferred combined parallel operation by determining an estimated size of data associated with the at least one deferred combined parallel operation determining whether the estimated size exceeds a threshold size if the estimated size is below a threshold size execute the at least one deferred combined parallel operation as a local sequential operation and if the estimated size exceeds a threshold size execute the at least one deferred combined parallel operation as remote parallel operation.

Implementations of this aspect may include one or more of the following features. For example the data associated with the at least one deferred combined parallel operation may include one or more of input data for the at least one deferred combined parallel operation intermediary data produced by the at least one deferred combined parallel operation or output data produced by the at least one deferred combined parallel operation. The at least one deferred combined parallel data operation may be a generalized mapreduce operation. The generalized mapreduce operation may include multiple parallel map operations and multiple parallel reduce operations and be translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations. To execute the generalized mapreduce operation the executor may be configured to translate the combined mapreduce operation to the single mapreduce operation and execute the single mapreduce operation. To execute the single mapreduce operation as a remote parallel operation the executor may be configured to cause the single mapreduce operation to be copied and executed on multiple different processing modules in a datacenter. To translate the generalized mapreduce operation to the single mapreduce operation the executor may be configured to generate a map function that includes the multiple map operations and a reducer function that includes the multiple reducer operations. To determine the estimated size the executor may be configured to access annotations in the dataflow graph that reflect an estimate of the size of the data associated with the at least one deferred combined parallel operation.

In another aspect a method includes accessing a dataflow graph that includes deferred parallel data objects and deferred combined parallel data operations. Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet been performed on the input object.

The method also includes executing the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object. For at least one of the deferred combined parallel operations executing the at least one deferred combined parallel operation includes determining an estimated size of data associated with the at least one deferred combined parallel operation determining whether the estimated size exceeds a threshold size if the estimated size is below a threshold size execute the at least one deferred combined parallel operation as a local sequential operation and if the estimated size exceeds a threshold size execute the at least one deferred combined parallel operation as remote parallel operation.

Implementations of this aspect may include one or more of the following features. For example the data associated with the at least one deferred combined parallel operation may include one or more of input data for the at least one deferred combined parallel operation intermediary data produced by the at least one deferred combined parallel operation or output data produced by the at least one deferred combined parallel operation. The at least one deferred combined parallel data operation may be a generalized mapreduce operation. The generalized mapreduce operation may include multiple parallel map operations and multiple parallel reduce operations and be translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations. Executing the generalized mapreduce operation may include translating the combined mapreduce operation to the single mapreduce operation and executing the single mapreduce operation. Executing the single mapreduce operation as a remote parallel operation may include causing the single mapreduce operation to be copied and executed on multiple different processing modules in a datacenter. Translating the generalized mapreduce operation to the single mapreduce operation may include generating a map function that includes the multiple map operations and a reducer function that includes the multiple reducer operations. Determining the estimated size may include accessing annotations in the dataflow graph that reflect an estimate of the size of the data associated with the at least one deferred combined parallel operation.

In one aspect a system includes one or more processing devices and one or more storage devices. The storage devices store instructions that when executed by the one or more processing devices implement an executor. The executor is configured to access a dataflow graph that includes deferred parallel data objects and deferred combined parallel data operations. Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet been performed on the input object.

At least one of the deferred combined parallel data operation is a generalized mapreduce operation. The generalized mapreduce operation includes multiple parallel map operations and multiple parallel reduce operations and is translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations.

The executor is further configured to execute the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object. To execute the generalized mapreduce operation the executor is configured to translate the combined mapreduce operation to the single mapreduce operation and execute the single mapreduce operation.

Implementations of this aspect may include one or more of the following features. For example to translate the generalized mapreduce operation to the single mapreduce operation the executor may be configured to generate a map function that includes the multiple map operations and a reduce function that includes the multiple reduce operations.

The executor may be configured to execute the single mapreduce operation as a remote parallel operation. To execute the single mapreduce operation as a remote parallel operation the executor may be configured to cause the single mapreduce operation to be executed by multiple worker processes on multiple different processing modules. To cause the single map reduce operation to be executed by multiple worker processes the executor may be configured to cause multiple map worker processes to be invoked for each of the map operations where each of the multiple map worker processes is assigned an index number. Each of the map worker processes may be configured to receive the map function that implements the multiple map operations one or more inputs associated with one of the map operations and the map worker process associated index select the map operation associated with the inputs based on the map worker process associated index and invoke the selected map operation on the one or more inputs.

To cause the single map reduce operation to be executed by multiple worker processes the executor may be configured to cause multiple reduce worker processes to be invoked for each of the reduce operations where each of the multiple reduce worker processes is assigned an index number. Each of the multiple reduce worker processes may be configured to receive the reduce function that implements the multiple reduce operations one or more inputs associated with one of the reduce operations and the reduce worker process associated index select the reduce operation associated with the inputs based on the worker process associated index and invoke the selected reduce operation on the one or more inputs.

In another aspect a method includes accessing a dataflow graph that includes deferred parallel data objects and deferred combined parallel data operations. Deferred parallel data objects for example can be data structures that include a pointer to the parallel data operation that operates on the parallel data objects rather than the elements stored in the parallel data object. Deferred parallel operations for example can be data structures that include a pointer to a parallel data object that is an input to the deferred parallel operation a pointer to a deferred parallel object that is an output of the deferred parallel operation and a function to be but has not yet.

At least one of the deferred combined parallel data operation is a generalized mapreduce operation. The generalized mapreduce operation includes multiple parallel map operations and multiple parallel reduce operations and being translatable to a single mapreduce operation that includes a single map function to implement the multiple parallel map operations and a single reduce function to implement the multiple parallel reduce operations and

The method also includes executing the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects. Materialized parallel data objects for example can be data structures that include the data or elements of the parallel data object. Executing the generalized mapreduce operation includes translating the combined mapreduce operation to the single mapreduce operation and executing the single mapreduce operation.

Implementations of this aspect may include one or more of the following features. For example translating the generalized mapreduce operation to the single mapreduce operation may include generating a map function that includes the multiple map operations and a reduce function that includes the multiple reduce operations. Executing the single mapreduce operation may include executing the single mapreduce operation as a remote parallel operation. Executing the single mapreduce operation as a remote parallel operation may include causing the single mapreduce operation to be executed by multiple worker processes on multiple different processing modules.

Causing the single map reduce operation to be executed by multiple worker processes may include causing the multiple map worker processes to be invoked for each of the map operations where each of the multiple map worker processes is assigned an index number. Each of the map worker processes may be configured to receive the map function that implements the multiple map operations one or more inputs associated with one of the map operations and the map worker process associated index select the map operation associated with the inputs based on the map worker process associated index and invoke the selected map operation on the one or more inputs.

Causing the single map reduce operation to be executed by multiple worker processes may include causing multiple reduce worker processes to be invoked for each of the reduce operations where each of the multiple reduce worker processes is assigned an index number. Each of the multiple reduce worker processes may be configured to receive the reduce function that implements the multiple reduce operations one or more inputs associated with one of the reduce operations and the reduce worker process associated index select the reduce operation associated with the inputs based on the worker process associated index and invoke the selected reduce operation on the one or more inputs.

In general the techniques described in this document can be applied to large scale data processing and in particular to large scale data parallel pipelines. Such large scale processing may be performed in a distributed data processing system such as a datacenter or a network of datacenters. For example large scale Internet services and the massively parallel computing infrastructure that support such services may employ warehouse sized computing systems made up of thousands or tens of thousands of computing nodes.

The datacenter includes multiple racks . While only two racks are shown the datacenter may have many more racks. Each rack can include a frame or cabinet into which components such as processing modules are mounted. In general each processing module can include a circuit board such as a motherboard on which a variety of computer related components are mounted to perform data processing. The processing modules within each rack are interconnected to one another through for example a rack switch and the racks within each datacenter are also interconnected through for example a datacenter switch.

In some implementations the processing modules may each take on a role as a master or slave. The master modules control scheduling and data distribution tasks amongst themselves and the slaves. A rack can include storage e.g. one or more network attached disks that is shared by the one or more processing modules and or each processing module may include its own storage. Additionally or alternatively there may be remote storage connected to the racks through a network.

The datacenter may include dedicated optical links or other dedicated communication channels as well as supporting hardware such as modems bridges routers switches wireless antennas and towers and the like. The datacenter may include one or more wide area networks WANs as well as multiple local area networks LANs .

The memory stores application software a mapreduce library a pipeline library and an operating system e.g. Linux . The operating system generally includes procedures for handling various basic system services and for performing hardware dependent tasks. The application software performs large scale data processing.

The libraries and provide functions and classes that may be employed by the application software to perform large scale data processing and implement data parallel pipelines in such large scale data processing. The mapreduce library can support the MapReduce programming model for processing massive amounts of data in parallel. The MapReduce model is described in for example MapReduce Simplified Data Processing on Large Clusters OSDI 04 Sixth Symposium on Operating System Design and Implementation San Francisco Calif. December 2004 and U.S. Pat. No. 7 650 331 both of which are incorporated by reference.

In general the MapReduce model provides an abstraction to application developers for how to think about their computations. The application developers can formulate their computations according to the abstraction which can simplify the building of programs to perform large scale parallel data processing. The application developers can employ the MapReduce model with or without using the mapreduce library . The mapreduce library however can manage many of the difficult low level tasks. Such low level tasks may include for example selecting appropriate parallel worker machines distributing to them the program to run managing the temporary storage and flow of intermediate data between the three phases synchronizing the overall sequencing of the phases and coping with transient failures of machines networks and software.

The MapReduce model generally involves breaking computations down into a mapreduce operation which includes a single map operation and a single reduce operation. The map operation performs an operation on each of the logical records in the input to compute a set of intermediate key value pairs. The reduce operation performs an operation on the values that share the same key to combine the values in some manner. Implicit in this model is a shuffle operation which involves grouping all of the values with the same key.

The mapreduce library may implement a map phase a shuffle phase and a reduce phase to support computations formulated according to the MapReduce model. In some implementations to use the mapreduce library a user program or another library such as pipeline library calls the mapreduce library specifying information identifying the input file s information identifying or specifying the output files to receive output data and two application specific data processing operators the map operator and the reduce operator. Generally the map operator specifies a map function that processes the input data to produce intermediate data and the reduce operator specifies a reduce function that merges or otherwise combines the intermediate data values. The mapreduce library then employs this information to implement that map phase the shuffle phase and the reduce phase.

The map phase starts by reading a collection of values or key value pairs from an input source such as a text file binary record oriented file or MySql database. Large data sets may be represented by multiple even thousands of files which may be referred to as shards and multiple file shards can be read as a single logical input source. The map phase then invokes the user defined function the map function or Mapper on each element independently and in parallel. For each input element the user defined function emits zero or more key value pairs which are the outputs of the map phase.

The shuffle phase takes the key value pairs emitted by the Mappers and groups together all the key value pairs with the same key. The shuffle phase then outputs each distinct key and a stream of all the values with that key to the next phase the reduce phase.

The reduce phase takes the key grouped data emitted by the shuffle phase and invokes the user defined function the reduce function or Reducer on each distinct key and values group independently and in parallel. Each Reducer invocation is passed a key and an iterator over all the values associated with that key and emits zero or more replacement values to associate with the input key. The Reducer typically performs some kind of aggregation over all the values with a given key. For some operations the Reducer is just the identity function. The key value pairs emitted from all the Reducer calls are then written to an output sink e.g. a sharded file or database.

To implement these phases the mapreduce library may divide the input pieces into M pieces for example into 64 megabyte MB sized files and start up multiple copies of the program that uses the library on a cluster of machines such as multiple ones of the processing modules . One of the copies may be a master copy and the rest may be worker copies that are assigned work by the master. The master selects idle workers and assigns each one a map task or a reduce task. There are M map tasks one for each input piece . The workers assigned to a map task use the Mapper to perform the mapping operation on the inputs to produce the intermediate results which are divided for example into R sets. When the intermediate results are divided into R sets there are R reduce tasks to assign. The workers assigned to a reduce task use the Reducer to perform the reduce operation on the intermediate values to produce the output. Once all map tasks and all reduce tasks are completed the master returns to the user program or library employing the mapreduce library . As a result the mapreduce operation is implemented as a set of parallel operations across a cluster of processing devices.

For Reducers that first combine all the values with a given key using an associative commutative operation a separate user defined Combiner function can be specified to perform partial combining of values associated with a given key during the map phase. Each map worker can keep a cache of key value pairs that have been emitted from the Mapper and use the Combiner function to combine locally as much as possible before sending the combined key value pairs on to the Shuffle phase. The Reducer may complete the combining step by combining values from different map workers.

By default the Shuffle phase may send each key and values group to arbitrarily but deterministically chosen reduce worker machine with this choice determining which output file shard will hold that key s results. Alternatively a user defined Sharder function can be specified that selects which reduce worker machine should receive the group for a given key. A user defined Sharder can be used to aid in load balancing. The user defined Sharder can also be used to sort the output keys into reduce buckets with all the keys of the ireduce worker being ordered before all the keys of the i 1st reduce worker. Coupled with the fact that each reduce worker processes keys in lexicographic order this kind of Sharder can be used to produce sorted output.

The pipeline library provides functions and classes that support data parallel pipelines and in particular pipelines that include chains or directed acyclic graphs of mapreduce operations. The pipeline library may help alleviate some of the burdens of implementing chains of mapreduce operations. In general many real world computations require a chain of mapreduce stages. While some logical computations can be expressed as a mapreduce operation others require a sequence or graph of mapreduce operations. As the complexity of the logical computations grows the challenge of mapping the computations into physical sequences of mapreduce operations increases. Higher level concepts such as count the number of occurrences or join tables by key are generally hand compiled into lower level mapreduce operations. In addition the user may take on the additional burdens of writing a driver program to invoke the mapreduce operations in the proper sequence and managing the creation and deletion of intermediate files holding the data.

The pipeline library may obviate or reduce some of the difficulty in producing data parallel pipelines that involve multiple mapreduce operations as well as the need for the developer to produce additional coordination code to chain together the separate mapreduce stages in such data parallel pipelines. The pipeline library also may obviate or reduce additional work to manage the creation and later deletion of the intermediate results in between pipeline stages. As a result the pipeline library may help prevent the logical computation itself from becoming hidden among all the low level coordination details thereby making it easier for new developers to understand the computation. Moreover making use of the pipeline library may help prevent the division of the pipeline into particular stages from becoming baked in to the code and difficult to change later if the logical computation needs to evolve.

In general the application software may employ one or both of the libraries or . An application developer may develop application software that employs the mapreduce library to perform computations formulated as a mapreduce operation.

The application developer may alternatively or additionally employ the pipeline library when developing a data parallel pipeline that includes multiple mapreduce operations. As discussed further below the pipeline library may allow the developer to code the computations in a more natural manner using the native programming language in which the pipeline library is implemented without thinking about casting the logical computation in terms of mapreduce operations or building an ordered graph of operations. The pipeline library can formulate the logical computation in terms of multiple mapreduce operations prior to execution and then execute the computation either by implementing the mapreduce operations itself or interfacing with the mapreduce library to implement the mapreduce operations.

Parallel data collection classes and operations present a simple high level uniform abstraction over many different data representations and over different execution strategies. The parallel data collection classes abstract away the details of how data is represented including whether the data is represented as an in memory data structure as one or more files or as an external storage service. Similarly parallel operations abstract away their implementation strategy such as whether an operation is implemented as a local sequential loop as a remote parallel invocation of the mapreduce library as a query on a database or as a streaming computation.

Rather than evaluate the parallel operations as they are traversed when the data parallel pipeline is executed the evaluator defers the evaluation of parallel operations. Instead the evaluator constructs an internal execution plan dataflow graph that contains the operations and their arguments. Once the execution plan dataflow graph for the whole logical computation is constructed the optimizer revises the execution plan for example by applying graph transformations that fuse or combine chains of parallel operations together into a smaller number of combined operations. The revised execution plan may include a generalized mapreduce operation that includes multiple parallel map operations and multiple parallel reduce operations for example the MapShuffleCombineReduce operation described further below but which can be translated to a single mapreduce operation with a single map function to implement the multiple map operations and a single reduce function to implement the multiple reduce operations. The executor executes the revised operations using underlying primitives e.g. MapReduce operations . When running the execution plan the executor may choose which strategy to use to implement each operation e.g. local sequential loop vs. remote parallel MapReduce based in part on the size of the data being processed. The executor also may place remote computations near the data on which they operate and may perform independent operations in parallel. The executor also may manage the creation and cleanup of any intermediate files needed within the computation.

The pipeline library may be implemented in any of a number of programming languages. The following describes examples of aspects of an implementation in the Java programming language.

The pipeline library provides a parallel data collection class referred to as a PCollection which is an immutable bag of elements of type T. A PCollection can either have a well defined order called a sequence or the elements can be unordered called a collection . Because they are less constrained collections may be more efficient to generate and process than sequences. A PCollection can be created by reading a file in one of several possible formats. For example a text file can be read as a PCollection and a binary record oriented file can be read as a PCollection given a specification of how to decode each binary record into an object of type T. When the pipeline library is implemented using Java a PCollection may also be created from an in memory Java Collection.

Data sets represented by multiple file shards can be read in as a single logical PCollection. For example 

In this example recordsOf . . . specifies a particular way in which a DocInfo instance is encoded as a binary record. Other predefined encoding specifiers may include strings for UTF 8 encoded text ints for a variable length encoding of 32 bit integers and pairsOf e1 e2 for an encoding of pairs derived from the encodings of the components. Some implementations may allow users to specify their own custom encodings.

A second parallel data collection class is PTable which represents an immutable multi map with keys of type K and values of type V. PTable may be just an unordered bag of pairs. Some of the parallel operations may apply only to PCollections of pairs and in Java PTable may be implemented as a subclass of PCollection to capture this abstraction. In another language PTable might be defined as a type synonym of PCollection.

The parallel data objects such as PCollections may be implemented as first class objects of the native language in which the library is implemented. When this is the case the objects may be manipulable like other objects in the native language. For example the PCollections may be able to be passed into and returned from regular methods in the language and may be able to be stored in other data structures of the language although some implementations may prevent the PCollections from being stored in other PCollections . Also regular control flow constructs of the native language may be able to be used to define computations involving objects including functions conditionals and loops. For example if Java is the native language 

Implementing the parallel data objects as first class objects in the native language of the library may simplify the development of programs using the library since the developer can use the parallel data objects in the same manner he or she would use other objects.

In addition to the parallel data collection classes the pipeline library can also include a single data collection class PObject to support the ability to inspect the contents of PCollections during the execution of a pipeline. In contrast to a PCollection which holds multiple elements a PObject is a container for a single object of type T for example a single native object e.g. Java object of type T and any associated methods of PObjects are designed to operate on a single element. Like PCollections PObjects can be either deferred or materialized as described further below allowing them to be computed as results of deferred operations in pipelines. Once a pipeline is run the contents of a now materialized PObject can be extracted using getValue .

For example in an implementation using Java an as SequentialCollection operation can be applied to a PCollection to yield a PObject which can be inspected once the pipeline runs to read out all the elements of the computed PCollection as a regular Java in memory Collection 

As another example the combine operation described below applied to a PCollection and a combining function over Ts yields a PObject representing the fully combined result. Global sums and maxima can be computed this way.

The contents of PObjects also may be able to be examined within the execution of a pipeline for example using an operate primitive provided by the pipeline library . The operate primitive takes a list of PObjects and an argument OperateFn which defines the operation to be performed on each PObject and returns a list of PObjects. When evaluated operate extracts the contents of the now materialized argument PObjects and passes them into the argument OperateFn. The OperateFn returns a list of native objects such as Java objects and operate wraps these native objects inside of PObjects which are returned as the results. Using this primitive arbitrary computations can be embedded within a pipeline and executed in deferred fashion. In other words operations other than ParallelDo operations described below which operate on PCollections that contain multiple elements can be included in the pipeline. For example consider embedding a call to an external service that reads and writes files 

This example uses operations for converting between PCollections and PObjects containing file names. The viewAsFile operation applied to a PCollection and a file format choice yields a PObject containing the name of a temporary sharded file of the chosen format where the PCollection s contents may be found during execution of the pipeline. File reading operations such as readRecordFileCollection may be overloaded to allow reading files whose names are contained in PObjects.

In much the same way the contents of PObjects can also be examined inside a DoFn described below by passing them in as side inputs to parallelDo . Normally a DoFn performs an operation on each element of a PCollection and just receives the PCollection as an input. In some cases the operation on each PCollection may involve a value or other data stored in a PObject. In this case the DoFn may receive the PCollection as an input as normal and a PObject as a side input. When the pipeline is run and the parallelDo operation is eventually evaluated the contents of any now materialized PObject side inputs are extracted and provided to the user s DoFn and then the DoFn is invoked on each element of the input PCollection to perform the defined operation on the element using the data from the PObject s . For example 

As described above data parallel operations are invoked on parallel data objects such as PCollections. The pipeline library defines some primitive data parallel operations with other operations being implemented in terms of these primitives. One of the data parallel primitives is parallelDo which supports elementwise computation over an input PCollection to produce a new output PCollection. This operation takes as its main argument a DoFn a function like object defining how to map each value in the input PCollection into zero or more values to appear in the output PCollection. This operation also takes an indication of the kind of PCollection or PTable to produce as a result. For example 

In this code collectionOf strings specifies that the parallelDo operation should produce an unordered PCollection whose String elements should be encoded using UTF 8. Other options may include sequenceOf elemEncoding for ordered PCollections and tableOf keyEncoding valueEncoding for PTables. emitFn is a call back function passed to the user s process . . . method which should invoke emitFn.emit outElem for each outElem that should be added to the output PCollection. Subclasses of DoFn may be included such as MapFn implementing a map and FilterFn implementing a filter to provide simpler interfaces in some cases.

The operation parallelDo can be used to express both the map and reduce parts of a MapReduce operation. The library also may include a version of parallelDo that allows multiple output PCollections to be produced simultaneously from a single traversal of the input PCollection.

DoFn functions may be prevented from accessing any global mutable state of the enclosing program if DoFn functions can be distributed remotely and run in parallel. DoFn objects may be able to maintain local instance variable state but there may be multiple DoFn replicas operating concurrently with no shared state.

A second primitive groupByKey converts a multimap of type PTable which can have many key value pairs with the same key into a uni map of type PTable where each key maps to an unordered collection of all the values with that key. For example the following computes a table mapping URLs to the collection of documents that link to them 

The operation groupByKey corresponds to the shuffle step of MapReduce. There may also be a variant that allows specifying a sorting order for the collection of values for each key.

A third primitive combineValues takes an input PTable and an associative combining function on Vs and returns a PTable where each input collection of values has been combined into a single output value. For example 

The operation combineValues is semantically a special case of parallelDo but the associativity of the combining function allows the operation to be implemented through a combination of a MapReduce Combiner which runs as part of each mapper and a MapReduce Reducer to finish the combining which may be more efficient than doing all the combining in the reducer.

A fourth primitive flatten takes a list of PCollections and returns a single PCollection that contains all the elements of the input PCollections. The operation flatten may not actually copy the inputs but rather just view the inputs as if the inputs were one logical PCollection.

A pipeline typically concludes with operations that write the final resulting PCollections to external storage. For example 

The pipeline library may include a number of other operations on PCollections that are derived in terms of the above described primitives. These derived operations may be the same as helper functions the user could write. For example a count operation takes a PCollection and returns a PTable mapping each distinct element of the input PCollection to the number of times the element occurs. This function may be implemented in terms of parallelDo groupByKey and combineValues using the same pattern as was used to compute wordCounts above. The code above can be simplified to the following 

Another operation join implements a join over two or more PTables sharing a common key type. When applied to a multimap PTable and a multimap PTable join returns a unimap PTable that maps each key in either of the input tables to the collection of all values with that key in the first table and the collection of all values with that key in the second table. This resulting table can be processed further to compute a traditional inner or outer join but it may be more efficient to be able to manipulate the value collections directly without computing their cross product.

4. Apply parallelDo to the key grouped table converting each Collection into a Pair of a Collection and a Collection.

Another derived operation is top which takes a comparison function and a count N and returns the greatest N elements of its receiver PCollection according to the comparison function. This operation may be implemented on top of parallelDo groupByKey and combineValues .

The operations mentioned above to read multiple file shards as a single PCollection are derived operations too implemented using flatten and the single file read primitives.

As described above the pipeline library executes parallel operations lazily using deferred evaluation. To that end the evaluator defers the evaluation of parallel operations and instead constructs an internal execution plan dataflow graph that contains the operations and the arguments of the operations. Each parallel data object such as a PCollection is represented internally either in deferred not yet computed or materialized computed state. A deferred parallel data object for example holds a pointer to the deferred operation that computes the parallel data object. A deferred operation in turn may hold references to the parallel data objects that are the arguments of the deferred operation which may themselves be deferred or materialized and the deferred parallel data objects that are the results of the operation. When a library operation like parallelDo is called the library creates a ParallelDo deferred operation object and returns a new deferred PCollection that points to the operation. In other words as the data parallel pipeline is executed the evaluator converts the parallel data objects and parallel operations into a directed acyclic graph of deferred unevaluated objects and operations. This graph may be referred to as the execution plan or execution plan dataflow graph.

The optimizer fuses chains or subgraphs of parallel operations in the dataflow graph together into a smaller number of operations some of which may be combined operations which the executor can then execute using an underlying primitive or other logic. The optimizer may be written for example as a series of independent graph transformations. In one implementation the optimizer performs a series of passes over the initial execution plan that reduces the number of overall operations and groups operations with the overall goal of producing the fewest MapShuffleCombineReduce MSCR operations.

An MSCR operation includes a combination of ParallelDo GroupByKey CombineValues and Flatten operations. An MSCR operation can be mapped to and run as a single mapreduce operation. An MSCR operation has M input channels each performing a map operation and R output channels each performing a shuffle a combine and a reduce . Each input channel m takes a PCollection as input and performs an R output ParallelDo map operation on that input to produce R outputs of type PTables. Each output channel R flattens its M inputs and then either a performs a GroupByKey shuffle an optional CombineValues combine and a O output ParallelDo reduce which defaults to the identity operation and then writes the results to Ooutput PCollections or b writes the input directly as the output. The former kind of output channel may be referred to as a grouping channel while the latter kind of output channel may be referred to as a pass through channel. A pass through channel may allow the output of a mapper be a result of an MSCR operation.

MSCR generalizes the MapReduce model by allowing multiple mappers and multiple reducers and combiners by allowing each reducer to produce multiple outputs by removing the requirement that the reducer must produce outputs with the same key as the reducer input and by allowing pass through outputs. Thus any given MSCR may include multiple parallel map operations that each operate on different inputs and multiple reduce operations that operate on the outputs of the map operations to produce multiple different outputs. Despite its apparent greater expressiveness each MSCR operation can be implemented using a single mapreduce operation that includes a single map function to implement the map operations on the different inputs and a single reduce function to implement the reduce operations to produce the multiple outputs.

Once the execution plan is revised by the optimizer the executor executes the revised execution plan dataflow graph. In one implementation the pipeline library performs batch execution. In other words the executor traverses the operations in the revised execution plan in forward topological order and executes each one in turn. Independent operations may be able to be executed simultaneously. Alternatively incremental or continuous execution of pipelines may be implemented where incrementally added inputs lead to quick incremental update of outputs. Further optimization may be performed across pipelines run by multiple users over common data sources.

The executor executes operations other than a MSCR by performing the appropriate computations that perform the operation. MSCRs are mapped to a single mapreduce operation which is then executed.

In some implementations the executor first decides whether the mapreduce operation should be run locally and sequentially or as a remote parallel mapreduce operation using for example mapreduce library . Since there is overhead in launching a remote parallel job local evaluation may be used for modest size inputs where the gain from parallel processing is outweighed by the start up overheads. Modest size data sets may be common during development and testing. Using local evaluation for these data sets may therefore facilitate the use of regular IDEs debuggers profilers and related tools easing the task of developing programs that include data parallel computations.

If the input data set appears large e.g. greater than or equal 64 Megabytes the executor may choose to launch a remote parallel MapReduce operation using the mapreduce library . The executor may use observations of the input data sizes and estimates of the output data sizes to automatically choose a reasonable number of parallel worker machines. Users can assist in estimating output data sizes for example by augmenting a DoFn with a method that returns the expected ratio of output data size to input data size based on the computation represented by that DoFn. Estimates may be refined through dynamic monitoring and feedback of observed output data sizes. Relatively more parallel workers may be allocated to jobs that have a higher ratio of CPU to I O.

The executor may automatically create temporary files to hold the outputs of each operation executed. Once the pipeline is completed all of these temporary files may be automatically deleted. Alternatively or additionally some or all of these temporary files may be deleted as soon as they are no longer needed later in the pipeline.

In general the pipeline library may be designed to make building and running pipelines feel as similar as possible to running a regular program in the native language for which the pipeline library was designed. When the native language is Java using local sequential evaluation for modest sized inputs is one way to do so. Another way is by automatically routing any output to System.out or System.err from within a user s DoFn such as debugging prints from the corresponding remote MapReduce worker to the main program s output streams. Likewise any exceptions thrown within a DoFn running on a remote MapReduce worker are captured sent to the main program and rethrown.

The library may support a cached execution mode. In this mode rather than recompute an operation the executor first attempts to reuse the result of that operation from the previous run if it was saved in a internal or user visible file and if the executor determines that the operation s result hasn t changed. An operation s result may be considered unchanged if a the operation s inputs haven t changed and b the operation s code and captured state haven t changed. The executor may perform an automatic conservative analysis to identify when reuse of previous results is guaranteed to be safe. Caching can lead to quick edit compile run debug cycles even for pipelines that would normally take hours to run. This may reduce the amount of time required to find a bug in a late pipeline stage fix the program and then reexecute the revised pipeline from scratch.

Once the evaluator has generated the dataflow graph the optimizer applies one or more graph transformations to the dataflow graph to generate a revised dataflow graph that includes the deferred parallel data objects or a subset and the deferred combined parallel data operations . The deferred combined parallel data operations may include one or more generalized mapreduce operations for example an MSCR which includes multiple map operations and multiple reduce operations but is translatable to a single mapreduce operation that includes a single map function to implement the map operations and a single reduce function to implement the reduce operations.

In one implementation the optimizer performs a series of passes over the dataflow graph applying the following graph transformations or annotations in the following order 1 sink flattens 2 lift CombineValues operations 3 insert fusion blocks 4 fuse ParallelDos and 5 fuse MSCRs.

The sink flattens transformation involves pushing a Flatten operation down through consuming ParallelDo operations by duplicating the ParallelDo before each input to the flatten. In other words h f a g b is equivalent to h f a h g b . This transformation creates opportunities for ParallelDo fusion described below .

The lift CombineValues operations annotation involves marking certain CombineValues operations for treatment as ParallelDos for ParallelDo fusion. If a CombineValues operation immediately follows a GroupByKey operation the GroupByKey records that fact. The original CombineValues is left in place and is henceforth treated as a normal ParallelDo operation and subject to ParallelDo fusion.

The insert fusion blocks annotation involves annotating the ParallelDos connecting two GroupByKey operations. If two GroupByKey operations are connected by a chain of one or more ParallelDo operations the optimizer chooses which ParallelDos should fuse up into the output channel of the earlier GroupByKey and which should fuse down into the input channel of the later GroupByKey. The optimizer estimates the size of the intermediate PCollections along the chain of ParallelDos identifies one with minimal expected size and marks that intermediate PCollection as a boundary blocking ParallelDo fusion that is marks the ParallelDos on either side of that PCollection as not being subject to fusion into one another .

The fuse ParallelDos transformation involves fusing ParallelDos together. One type of ParallelDo fusion that the optimizer may perform is referred to as producer consumer fusion. If one ParallelDo operation performs function and the result is consumed by another ParallelDo operation that performs function g the two ParallelDo operations may be replaced by a single ParallelDo that computes both and g . If the result of the ParallelDo is not needed by other operations in the graph fusion has rendered it unnecessary and the code to produce it may be removed as dead.

Another type of ParallelDo fusion is referred to as sibling fusion. ParallelDo sibling fusion may be applied when two or more ParallelDo operations read the same input PCollection. The ParallelDo operations can be fused into a single multi output ParallelDo operation that computes the results of all the fused operations in a single pass over the input. Both producer consumer and sibling fusion can apply to arbitrary trees of multi output ParallelDo operations.

As mentioned earlier CombineValues operations are special cases of ParallelDo operations that can be repeatedly applied to partially computed results. As such ParallelDo fusion may also be applied to CombineValues operations.

The fuse MSCRs transformation involves creating MSCR operations. An MSCR operation starts from a set of related GroupByKey operations. GroupByKey operations may be considered related if the operations consume possibly via Flatten operations the same input or inputs created by the same ParallelDo operations. The MSCR s input and output channels are derived from the related GroupByKey operations and the adjacent operations in the execution plan. Each ParallelDo operation with at least one output consumed by one of the GroupByKey operations possibly via Flatten operations is fused into the MSCR forming a new input channel. Any other inputs to the GroupByKeys also form new input channels with identity mappers. Each of the related GroupByKey operations starts an output channel. If a GroupByKey s result is consumed solely by a CombineValues operation that operation is fused into the corresponding output channel. Similarly if the GroupByKey s or fused CombineValues s result is consumed solely by a ParallelDo operation that operation is also fused into the output channel if it cannot be fused into a different MSCR s input channel. All the PCollections internal to the fused ParallelDo GroupByKey and CombineValues operations are now unnecessary and may be deleted. Finally each output of a mapper ParallelDo that flows to an operation or output other than one of the related GroupByKeys generates its own pass through output channel.

After all GroupByKey operations have been transformed into MSCR operations any remaining ParallelDo operations are also transformed into trivial MSCR operations with a single input channel containing the ParallelDo and an identity output channel. The final optimized execution plan contains only MSCR Flatten and Operate operations.

Once the revised dataflow graph is generated the executor executes the deferred combined parallel operations to produce materialized parallel data objects corresponding to the deferred parallel data objects . Executing the generalized mapreduce operation for example MSCR can include translating the generalized mapreduce operation to the single mapreduce operation and executing the single mapreduce operation. Before executing the single mapreduce operation the executor may decide whether to execute the single mapreduce operation as a local sequential operation or a remote parallel operation and then execute the single mapreduce accordingly. For example the executor may decide based on the size of the input data set as described above.

As the executor encounters non MSCR operations the executor executes those operations locally using logic included in the pipeline library . On the other hand when the executor encounters an MSCR operation the executor determines whether to execute the MSCR as a local sequential operation or instead as a remote parallel operation using the mapreduce library . For example the executor may determine an estimated size of data associated with the MSCR and determine whether the estimated size exceeds a threshold size. If the estimated size is below the threshold size executor may execute the MSCR as a local sequential operation . Conversely if the estimated size is equal to or exceeds the threshold size the executor may execute the MSCR operation as remote parallel operation by translating the MSCR into a single mapreduce operation and executing that mapreduce operation as a remote parallel operation using the mapreduce library .

For instance in one implementation the executor estimates the size of the input data for each input channel of the MSCR estimates the size of the intermediary data produced by each input channel and estimates the size of the output data from each output channel. If any of these size estimates is equal to or exceeds 64 megabytes MB then the MSCR is executed as a remote parallel operation using the mapreduce library .

When executing the MSCR as a local sequential operation the executor may perform the appropriate operations over the data is a sequential fashion. For example the executor may implement in memory for loops to access the data and perform the appropriate operations on the data.

When executing the MSCR as a remote parallel operation using the mapreduce library the executor may estimate the number of map worker processes and reduce worker processes needed to perform the associated processing based on the configuration of the input and output channels of the MSCR. For instance the executor may estimate the number of map worker processes for each input channel based for example on an estimated or known size of the input data for each input channel and similarly may estimate the number of reduce worker processes based for example on an estimated or known amount of data to be processed by each output channel. The executor may then add up the number of map worker processes and reduce worker processes and cause these worker processes to be invoked using the mapreduce library

Each map worker and each reduce worker is given an index number. For example if the MSCR includes two input channels one with 4 map worker processes and the other with 5 map worker processes then the 9 workers may be given an index number from 1 to 9. The same may occur for the reduce worker processes. These index numbers are used to associate a given map worker process or reduce worker process with a particular input or output channel respectively. Continuing the foregoing example index numbers 1 4 may be associated with the first input channel while index numbers 5 9 may be associated with the second input channel.

The executor also translates the MSCR into a single mapreduce operation by generating a single map function that implements the multiple map operations in the input channels of the MSCR and a single reduce function that implements the multiple reduce operations in the output channels of the MSCR. The map function uses the index of the map worker processes as the basis for selecting which map operation is applied to the input. For example an if then statement may be included as part of the map function with the index numbers of the map workers being the decision points for the if then statement.

Thus as the mapreduce library assigns a map task to a map worker process the worker s associated index is passed into the map function along with an identity of the file to be worked on. The index number then dictates which map operation parallelDo the map function invokes on the elements in the file and thereby which input channel the worker implements.

Similarly the reduce function uses the index of the reduce worker processes as the basis for selecting which reduce operation is applied to the input of the reduce worker process. As a reduce worker function is assigned a reduce task the worker s associated index is passed into the reduce function along with an identity of the file to be worked on which contains a single flattened stream of key grouped inputs . The index number then dictates which reduce operation the reduce function invokes on the elements in the file and thereby which output channel the worker implements. If the reduce worker process implements a grouping output channel the reduce worker process performs the CombineValues combine operation if any and then the ParallelDo reduce operation. If the reduce worker process implements a pass through output channel the reduce worker process performs an ungrouping operation that outputs key value pairs undoing the effect of the mapreduce library s implicit shuffle.

Each of the MSCR operation s input channels can emit key value pairs to any of its R output channels. For example input channel sends one output to output channel and another output to output channel and nothing to output channel .

The mapreduce library handles the shuffle on the data output by the map worker processes and then routes the output to the correct reducer worker. Each of the MSCR operation s input channels can emit key value pairs to any of its R output channels. For example input channel sends one output to output channel and another output to output channel and nothing to output channel . This is handled for example by the pipeline library by using an emitToShard key value shardNum primitive in the mapreduce library which allows the pipeline library to designate which reduce worker process a given output of a map worker process is sent to. When sending an output from a given map worker process to a particular output channel the pipeline library may compute the range of reduce worker indices corresponding to that output channel chooses one of them using a deterministic function and uses the emitToShard function to send the output to the chosen reducer worker. The deterministic function may include a hash on the key associated with the output values with the result of the hash determining which of the reduce worker processes within the range of indices for the output is chosen. This may ensure that all of the data associated with a particular key is sent to the same reduce worker process.

In one implementation the mapreduce library only directly supports writing to a single output. Moreover in one implementation of the mapreduce library if the reduce function s output expects key value pairs the keys written to this output must be the same as the keys passed in to the reduce function. In contrast in an implementation each MSCR output channel can write to zero one or several outputs with no constraints on keys. To implement these more flexible outputs the reduce function may write directly to the outputs bypassing the mapreduce library s normal output mechanism. If any of the MSCR s outputs satisfies the restrictions of a mapreduce library s output then that output can instead be implemented using the mapreduce library s normal mechanisms.

As each of the parallel operations is evaluated the executor populates the deferred objects with the appropriate data to materialize the objects until all operations are completed at which time the executor returns control back over to the application .

Referring to graph the ParallelDos M M and M are incorporated as MSCR input channels . Each of the GroupByKey operations becomes a grouping output channel . GBK s output channel incorporates the CV CombineValues operation and the R ParallelDo operation . The R ParallelDo operation is also fused into an output channel. An additional identity input channel is created for the input to GBK from non ParallelDo Op. Two additional pass through output channels shown as edges from mappers to outputs are created for the M. and M. PCollections that are used after the MSCR operation. The resulting MSCR operation has 4 input channels and 5 output channels .

While described as implemented as a library the functionality of the pipeline library may additionally or alternatively be implemented as a service that allows a client system to access the functionality over a network such as the Internet. For instance the functionality of the pipeline library can be implemented on a server system as a Web Service with a corresponding set of Web Service Application Programming Interfaces APIs . The Web Service APIs may be implemented for example as a Representational State Transfer REST based HTTP interface or a Simple Object Access Protocol SOAP based interface. Alternatively or additionally an interface such as a web page may be provided to access the service over the network.

Using the API or interface a user may send a program developed by the user to the service from a client system. The program for example may include a data parallel pipeline implemented using the parallel collection classes and parallel operations . Using the API or interface the user may designate data for the pipeline and send a message to the service to execute the program possibly with any arguments needed for the program. Once the message is received the service executes the program and implements the functionality of the evaluator the optimizer and the executor to implement that data parallel pipeline. The service then may return any outputs of the program to the client system. Alternatively or additionally the user program may execute on the client system with the program using the API to implement the data parallel pipeline using the functionality of the evaluator the optimizer and the executor implemented by the service.

The techniques described above are not limited to any particular hardware or software configuration. Rather they may be implemented using hardware software or a combination of both. The methods and processes described may be implemented as computer programs that are executed on programmable computers comprising at least one processor and at least one data storage system. The programs may be implemented in a high level programming language and may also be implemented in assembly or other lower level languages if desired.

Any such program will typically be stored on a computer usable storage medium or device e.g. CD Rom RAM or magnetic disk . When read into the processor of the computer and executed the instructions of the program cause the programmable computer to carry out the various operations described above.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be. Accordingly other implementations are within the scope of the following claims.

