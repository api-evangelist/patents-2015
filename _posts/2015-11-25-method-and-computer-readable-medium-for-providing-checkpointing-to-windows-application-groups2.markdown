---

title: Method and computer readable medium for providing checkpointing to windows application groups
abstract: A computer readable medium and method for providing checkpointing to Windows application groups. The checkpointing may be triggered asynchronously using Asynchronous Procedure Calls. The computer readable medium includes computer-executable instructions for execution by a processing system. The computer-executable instructions may be for reviewing one or more command line arguments to determine whether to start at least one of the application groups, and when determining to start the at least one of the application groups, creating a process table in a shared memory to store information about each process of the at least one of the application groups. Further, the instructions may be for registering with a kernel module to create an application group barrier, creating a named pipe for applications of the application group to register and unregister, triggering a checkpoint thread to initiate an application group checkpoint; and launching an initial application of the applications of the application group.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09547561&OS=09547561&RS=09547561
owner: Open Invention Network LLC
number: 09547561
owner_city: Durham
owner_country: US
publication_date: 20151125
---
The present application is a continuation of and claims the benefit of U.S. patent application Ser. No. 14 532 336 filed Nov. 4 2014 issued U.S. Pat. No. 9 201 737 issued Dec. 1 2015 which is a continuation of U.S. patent application Ser. No. 13 630 282 filed Sep. 28 2012 issued U.S. Pat. No. 8 881 171 issued Nov. 4 2014 which is a continuation of U.S. patent application Ser. No. 12 334 666 filed Dec. 15 2008 issued U.S. Pat. No. 8 281 317 issued Oct. 2 2012 incorporated by reference in their entirety herein.

A portion of the material in this patent document is subject to copyright protection under the copyright laws of the United States and of other countries. The owner of the copyright rights has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the United States Patent and Trademark Office publicly available file or records but otherwise reserves all copyright rights whatsoever. The copyright owner does not hereby waive any of its rights to have this patent document maintained in secrecy including without limitation its rights pursuant to 37 C.F.R. 1.14.

This invention pertains to enterprise computer systems computer networks embedded computer systems wireless devices such as cell phones computer systems computers and more particularly with methods systems and procedures i.e. computer readable media software or programming configured to be read and or executed by a processor on an electronic device described or depicted herein for providing high availability virtualization and checkpointing services for a computer application s running on Microsoft Windows Operating Systems herein referred to as Windows or Microsoft Windows .

Enterprise and wireless systems operating today are subject to continuous program execution that is 24 hours a day and 7 days a week. There is no longer the concept of overnight or planned downtime . All programs and data must be available at any point during the day and night. Any outages or deteriorated service can result in loss of revenue as customers simply take their business elsewhere and the enterprise stops to function on a global scale. Traditionally achieving extremely high degrees of availability has been accomplished with customized applications running on custom hardware all of which is expensive and proprietary. Traditionally no mechanisms have existed for protecting Windows applications. The problem is compounded by the fact that Microsoft Windows is a closed operating system without access to source code so all high availability must be provided external to the operating system.

One reference provides a background for understanding aspects of the current invention. U.S. patent application Ser. No. 11 213 678 filed on Aug. 26 2005 incorporated in its entirety which describes how to provide transparent and automatic high availability for applications.

A method system apparatus and computer readable medium are described for achieving checkpointing restoration virtualization and loss less migration of Windows applications. The invention provides transparent migration and fail over of Windows applications while ensuring that connected clients remain unaware of the migration. The client s connection and session are transparently transferred from the primary to the backup server without any client involvement.

The terms Windows and Microsoft Windows is utilized herein interchangeably to designate any and all versions of the Microsoft Windows operating systems. By example and not limitation this includes Windows XP Windows Server 2003 Windows NT Windows Vista Windows Server 2008 Windows Mobile and Windows Embedded.

The terms checkpointer checkpointing and checkpointing service are utilized herein interchangeably to designate a set of services which 1 capture the entire state of an application and store all or some of the application state locally or remotely and 2 restore the entire state of the application from said stored application state. The checkpointer may include the following components user space dynamic link library the checkpoint library loadable kernel module coordinator to monitor and coordinate an application group and a merge utility to merge full and incremental checkpoints. The checkpointing services run execute on all nodes where the application groups runs execute or can fail over to.

The term checkpoint file is utilized herein to describe the data captured by the checkpointing service. Generally the checkpoint files are written to local disk remote disk or memory.

The term node is utilized herein to designate one or more processors running a single instance of an operating system. A virtual machine such as VMWare or XEN VM instance is also considered a node . Using VM technology it is possible to have multiple nodes on one physical server.

The terms application independent application and windows application are utilized interchangeably herein to describe a set of one or more processes each with one or more threads that jointly provide a service. Operating systems generally launch an application by creating the application s initial process and letting that initial process run execute. In the following teachings we often identify the application at launch time with that initial process and then describe how to handle creation of new processes via the CreateProcess family of functions.

The term application group is utilized herein to describe a logical grouping of one or more independent applications that together or independently provide some service. The independent applications do not need to be running at the same time. A member of the application group can also load perform work and exit essentially joining and leaving the group.

In the following we use commonly known terms including but not limited to process process ID PID thread thread ID TID thread local storage TLS instruction pointer stack kernel kernel module loadable kernel module heap stack disk CPU CPU registers storage memory memory segments memory pages address space semaphore queues and signal . These terms are well known in the art and thus will not be described in detail herein.

The terms APC and Asynchronous Procedure Calls are used herein interchangeably to mean a function that executes asynchronously in the context of a particular thread . APC is provided as standard functionality on Microsoft operating systems with documentation available by searching for APC on Microsoft s Developers network msdn.microsoft.com .

The terms CreateProcess and NtCreateProcess are used to designate the family of Microsoft Windows functions used to create new processes. The terms TerminateProcess and NtTerminateProcess are used to designate the family of Microsoft Windows functions used to terminate processes. The family of functions is fully documented by Microsoft at msdn.microsoft.com.

In the following we also use commonly known terms and names of Windows internals including but not limited to ETHREAD EPROCESS Alertable NtContinue IOCTL I O control IRQL and APC LEVEL. These terms are well known in the art and are documented by Microsoft at their developer s support network msdn.microsoft.com.

The term coordinator is utilized for designating a special control process running as an element of the invention. The coordinator is generally responsible for sending out coordination events managing application group registration and for coordinating activities across all application in an application group. For the sake of simplicity the coordinator is often depicted as running on the same node as the application group however this is not a requirement as the coordinator can run on any node.

The term transport is utilized to designate the connection mechanism and or protocols used for communicating across a distributed application. Examples of transport include TCP IP Message Passing Interface MPI Myrinet FiberChannel ATM shared memory DMA RDMA system busses and custom backplanes. In the following the term transport driver is utilized to designate the implementation of the transport. By way of example the transport driver for TCP IP would be the local TCP IP stack running on the host.

The terms shell script and shell are used to designate the operating system mechanism to run a series of commands and applications. On Windows shell functionality is provided by cmd.exe and .bat files or Windows PowerShell. Examples of cross platform scripting technologies include JavaScript Perl Python and PHP. Throughout the rest of this document we use the terms shell and shell script to designate the functionality across all scripting technologies not just the scripting technologies provided by Microsoft.

The term interception is used to designate the mechanism by which an application re directs a system call or library call to a new implementation. On Windows interception can be achieved by modifying a process Import Address Table and creating Trampoline functions as documented by Detours Binary Interception of Win32 Functions by Galen Hunt and Doug Brubacher Microsoft Research July 1999 .

The term barrier and barrier synchronization is used herein to designate a type of synchronization method. A Barrier for a group of processes and threads is a point in the execution where all threads and processes must stop before being allowed to proceed. Barriers are typically implemented using semaphores mutexes locks event objects or other equivalent system functionality. Barriers are well known in the art and will not be described further here.

The term transparent is used herein to designate that no modification to the application group s applications are required. In other words the present invention works directly on the application binary without needing any customization source code modifications recompilation re linking special installation custom agents or other extensions.

In the following descriptions the product name Duration is utilized in referring to a system as described in the reference cited previously. It should be appreciated however that the teachings herein are applicable to other similarly configured systems.

By way of example consider an e Commerce service consisting of a WebLogic AppServer and an Oracle Database. In this case WebLogic and Oracle would be the independent applications and the application group would consist of WebLogic and the Oracle database together.

By way of example consider a cell phone with an address book and built in navigation system. In this case the address book and the navigation system would be the independent applications and the application group would consist of the address book and the navigation application.

By way of example consider a shell script running a series of applications and other scripts. In this case the script and all applications and scripts launched by the script comprise the application group and all the individual applications and other scripts called within the script are the independent applications.

In at least one embodiment the checkpointer is transparent to an application no changes to the application are required.

In at least one embodiment a method of checkpointing single process application groups and multi process application groups is provided. The method may include

creating at least one full checkpoint for each application process in an application group and may include creating at least one incremental checkpoint for each application process in the application group. Further the method may automatically merge each of the at least one available incremental application checkpoint against a corresponding full application checkpoint and synchronize checkpointing across all applications in the application group

In at least one embodiment the checkpointer periodically or on demand saves an application group s data and computation state to a set of checkpoint files on disk. The contents of an application s checkpoint file may then be loaded at a later point in time into a new instance of the application restoring the application to its previous state. An application group may be restored on any machine running the same Operating System kernel and system libraries.

In at least one embodiment the checkpointer may include the following application state in a checkpoint process thread attributes execution context instruction pointer stack pointer CPU registers etc. execution state running waiting etc. process and thread blocks wait and mutant lists APC queues environment blocks process cookie user address space data segments code segment descriptors heaps dynamically allocated segments file mapped segments thread stacks thread local storage TLS object state open files mutexes semaphores events etc. and object handles.

In at least one embodiment to launch applications protected by the checkpointer the checkpoint library is first loaded into the application before the application begins running. This is performed transparently without the need to recompile or re link the application. The checkpoint library s initialization function is called directly when the library is loaded instead of going through DllMain . DllMain is an optional entry point into a dynamic link library DLL that is called every time a thread or process is started or terminated. When a thread is created including the main thread the thread s initialization routine locks a mutex before calling DllMain . Threads created within DllMain would not be able to start until the main thread exits its DllMain and releases the mutex. As the checkpoint library needs to create its own thread the checkpoint library is initialized directly as described above. Once the checkpoint library has been initialized the application process main thread jumps to the application s entry point setting the application in motion. Alternatively if an application is to be restored from a checkpoint the main thread suspends itself and the checkpoint thread initiates the restoration of the process.

In at least one embodiment when the checkpoint library is loaded it creates a set of objects that are used to record the data and computation state of the process. The checkpoint library s objects are stored in a separate heap to keep its data isolated from the rest of the application. Arguments are passed to the checkpointer through specific environment variables. For example a restore is triggered by setting a checkpoint file to restore in the ET CPENV RESTORE FILE environment variable. The checkpoint library then registers with the coordinator and kernel module and creates a separate checkpoint thread. The checkpoint thread is responsible for initiating the process checkpoint as well as saving and restoring the state of the process.

In at least one embodiment to complete the initialization of the checkpointer the checkpoint library installs a set of function interceptors. Function interceptors redirect system library calls to an alternate implementation within the checkpoint library. This allows the checkpointer to perform a number of tasks when an application calls an intercepted function such as save and or modify data passed between the application and the kernel determine when processes threads and objects are created trap synchronization and I O events and prevent checkpoints during various system calls. Function interceptors are also used to virtualize elements of an application that cannot be restored to their previous values such process and thread IDs. Aside from intercepting functions the application may call the checkpoint library intercepts its process user exception dispatcher to catch segmentation violations triggered by the process threads.

In at least one embodiment the checkpointer s kernel module may perform the following tasks Signal an application s threads to start a checkpoint control the flow of execution during a checkpoint and restore and save and restore a process kernel attributes and objects.

In at least one embodiment the kernel module may be loaded and unloaded to from the kernel dynamically with no changes to the operating system kernel being necessary. When the kernel module is loaded into the kernel it registers a named device. The checkpoint library is then able to open this device when an application is launched. Commands are sent to the device via I O control IOCTL codes. Upon receiving a registration IOCTL command the kernel module creates a new process entry creates updates the application group s barrier and acquires the process security cookie which is used to encrypt function pointers. In another embodiment the checkpointer kernel module is built in to the operating system kernel.

In at least one embodiment the barrier allows the application group s threads to execute tasks in lock step during a checkpoint and restore. The size of the barrier determines the number of threads that are allowed to wait at the barrier. As threads arrive at a barrier they wait either blocking or non blocking for the total number of threads to arrive. The last thread to reach the barrier then releases all the threads waiting at the barrier. A single thread per process may also be allowed to wait for all other threads in the process to arrive at a specific barrier without awakening the other threads. This not only allows one thread per process to be running at any point in time it also allows one thread to be the only thread running at a specific location within the checkpointer.

In at least one embodiment the kernel module is responsible for saving and restoring the state of a process kernel attributes. A process kernel attributes are accessed through its EPROCESS block. The EPROCESS block is stored in kernel space and is therefore inaccessible from user space. An individual thread s attributes are accessed through its ETHREAD block also inaccessible from user space. Process and thread blocks cannot be directly restored in memory because kernel space is shared between all processes. Therefore on restore a process and thread s kernel attributes are reconstructed by restoring each element individually.

In at least one embodiment the kernel module is responsible for saving and restoring the state of a process open kernel objects. Kernel objects are created by user mode processes indirectly through system calls. The kernel assigns each object a handle that is returned to user space. User mode processes then access kernel objects through their user space handles. For example if a process calls CreateFile to create a file the kernel creates a file object in kernel space and returns the file s handle back to the process in user space. File operations are then performed by passing the file handle back to the kernel which access the file object referenced by the handle and operates on the object directly. Like a process kernel attributes on restore a kernel object is reconstructed by restoring each attribute individually.

In at least one embodiment to initiate an application group s checkpoint the coordinator wakes up each application process checkpoint thread from the checkpoint barrier. Upon awakening each checkpoint thread sends its process application threads a special kernel APC via the kernel module. Each thread is interrupted at IRQL APC LEVEL and enters the checkpoint APC handler within the kernel module whether or not it was executing in user or kernel space. Before being able to save the state of the process each of the application s threads must be in a restorable state. Because the kernel address space of a process cannot be directly restored in memory a thread cannot be active in kernel space when its state is saved. An active thread is utilized herein to mean a thread in a running ready or standby state. If a thread is active in kernel space at the time it receives the checkpoint signal a set of hooks are installed to detect when the thread arrives at a restorable state.

When all of the application s threads are in a restorable state they proceed in lock step throughout the checkpoint. An application s threads are responsible for saving their own state whereas an application process checkpoint thread is responsible for saving the state of the process attributes objects and user address space. The coordinator s checkpoint thread simply saves the state of the application group s process table. When an application group s checkpoint is complete each of the applications are resumed.

It should be noted that each of the application s thread are in the kernel module when their state is saved. This does not conflict with the aforementioned algorithm the checkpointer differentiates between elements of a thread s state that are a result of entering the checkpoint APC and elements that are not.

In at least one embodiment to restore an application group from a checkpoint the coordinator is passed a checkpoint file to restore instead of an application to start. The coordinator reads the process table contained in the checkpoint and launches each of its child processes and all orphaned processes in the application group. Before launching each process the coordinator sets the path of the process checkpoint file in an environment variable. Upon loading the checkpoint library checks for the checkpoint file environment variable and initializes the checkpoint library for restore if set.

On restore an application re registers with the coordinator and kernel module. An application then re launches its child processes and recreates its threads that existed at the time of the checkpoint. When all threads in the application group have been recreated each process restores their state in lock step. Each process checkpoint thread is responsible for restoring the process kernel attributes objects and user address space. Unlike a process kernel space components the segments of a process user address space are restored directly in memory. An application s threads are responsible for restoring their individual state. Once the application group has been restored all applications are resumed.

In at least one embodiment the checkpointer only saves the elements of a process that change after the previous checkpoint which can significantly reduce the time to take a checkpoint. A process must first take one full checkpoint after which all subsequent checkpoints may be taken incrementally. Each incremental checkpoint is merged with the process previous full checkpoint to produce a new full checkpoint. Merging is performed by a separate merge utility and may therefore be performed asynchronously. The merge utility is not required to be running on the same node as the application group.

In at least one embodiment applications may be added to an application group in two ways. The coordinator may launch a user specified application at any time or an application may create a new application by calling CreateProcess. CreateProcess creates a new running process with an image specified by the caller. The checkpoint library intercepts CreateProcess to launch the application with checkpointing support. Newly registered applications will be checkpointed and restored along with the rest of the applications in the application group.

In at least one embodiment applications are removed from an application group upon exit. To determine when an application process exits the checkpoint library intercepts TerminateProcess. Within the TerminateProcess interceptor the checkpointer unregisters the application from the coordinator before allowing the application to exit. The coordinator is then able to determine if a process has exited in a planned or unplanned fashion depending on whether or not it has unregistered by the time it terminates. A user defined policy governs whether or not an application group should be brought down if one of its processes exits in an unplanned fashion. Nevertheless the coordinator exits once every application of the group has terminated.

In at least one embodiment checkpointing services are configured for automatically performing a number of application services including injecting registration code into all applications in the application group during launch registering the group s application as they launch detecting execution failures and executing from backup nodes in response to application group failure application failure or node failure. The services can be integrated transparently into the system in that they are implemented on the system without the need of modifying or recompiling the application program without the need of a custom loader or without the need for a custom operating system kernel. In another embodiment a custom loader is used.

In at least one embodiment the checkpointing services support shell scripts where the core shell script application launches new independent applications in any order.

The present invention comprises a set of checkpointing services for application groups. The checkpointing services run on every node where the group application can run. One embodiment of the invention generally functions as an extension of the operating system and runs on all nodes. A coordination mechanism is utilized to ensure that the execution of the independent applications is coordinated at certain points.

By way of example and not of limitation the present invention implements checkpointing services for stateless applications e.g. sendmail stateful applications e.g. Voice over IP VOIP multi tier enterprise applications e.g. Apache WebLogic and Oracle Database combined wireless devices such as cell phones pages and PDAs and large distributed applications for example those found in High Performance Computing HPC such as seismic exploration and financial modeling.

According to one aspect of the invention the application group runs on a node with one or more of the independent applications running at any point in time. Each independent application is running independently but is protected and checkpointed together with all other independent applications in the application group.

According to one aspect of the invention the application group has one or more backup nodes ready to execute the independent application in the place of the original in the event of a fault. The protection of the application group is thus coordinated and guaranteed to be consistent across fault recovery.

An application group can be configured according to the invention with any number of independent applications. Each independent application runs on the primary node while the backup node for the applications stands ready to take over in the event of a fault and subsequent recovery. The primary and backup can be different nodes or the primary and backup can be the same node in which case the fault recovery is local.

The invention provides layered checkpointing services for application groups with checkpointing services provided both at the application group level and at the individual independent application level. High availability including fault detection and recovery for the individual independent application is provided by Duration s existing stateful High Availability Services. The invention layers a distributed fault detection and recovery mechanism on top of the local fault detection and ensures that fault detection and recovery is consistent across the entire grid.

By way of example and not of limitation the invention implements stateless or stateful recovery of application groups by recovering each independent application and ensuring all independent applications are recovered in a consistent state. The recovery is automatic without any application group or independent application involvement.

According to an aspect of the invention there is a clean separation of the application logic from the checkpointing services code. This allows application programmers to focus on writing their application code rather than on writing checkpointing code. An administrator can make applications highly available by simply configuring the desired settings such as by using a graphical configuration tool implemented according to the invention. The result is that high availability applications are developed easily and deployed quickly without the necessity of custom coding.

According to another aspect of the invention protection is provided against node faults network faults and process faults. The present invention provides user controlled system management automatic availability management and publish subscribe event management including notification of faults and alarms.

In various embodiments of the invention features are provided that are useful for application groups that must be highly available including but not limited to the following 

 a Stateful high availability and checkpointing for application groups scripts including high performance computing financial modeling enterprise applications web servers application servers databases Voice Over IP VOIP Session Initiation Protocol SIP streaming media Service Oriented Architectures SOA wireless devices such as cell phones and PDA.

The invention can be practiced according to various aspects and embodiments including but not limited to those described in the following aspects and embodiments which are described using phraseology which is generally similar to the claim language.

According to an aspect of the invention a method for achieving transparent integration of a application group program with a high availability protection program comprises a injecting registration code transparently and automatically into all independent applications when they launch without the need of modifying or recompiling the application program and without the need of a custom loader b registering the independent applications automatically with the high availability protection program c detecting a failure in the execution of the application group or any independent application within the group and d executing the application group with application group being executed from their respective backup servers automatically in response to the failure. The high availability protection program is preferably configured as an extension of the operating system wherein recovery of application groups can be performed without modifying programming within said application programs. The high availability protection can be configured for protecting against node faults network faults and process faults.

According to another aspect of the invention a method system improvement or computer program is provided for performing loss less migration of an application group including loss less migration of all independent applications from their respective primary nodes to their backup nodes and while being transparent to a client connected to the primary node over a TCP IP MPI system bus or other transport. The transport i.e. TCP IP MPI or system bus will optionally be flushed and or halted during checkpointing.

According to another aspect of the invention a method system improvement or computer program performs loss less migration of an application group comprising a 

migrating the independent applications within an application group without loss from their respective primary nodes to at least one backup node b maintaining transparency to a client connected to the primary node over a transport connection c optionally flushing and halting the transport connection during the taking of checkpoints and d restoring the application group including all independent applications from their checkpoints in response to initiating recovery of the application. The execution transparency to the client is maintained by a high availability protection program configured to automatically coordinate transparent recovery of distributed applications. Transparency is maintained by a high availability protection program to said one or more independent applications running on a primary node while at least one backup node stands ready in the event of a fault and subsequent recovery

According to another aspect of the invention a method system improvement or computer program performs fault protection for applications distributed across multiple computer nodes comprising a providing high availability application services for transparently loading applications registering applications for protection detecting faults in applications and initiating recovery of applications b taking checkpoints of independent applications within applications groups c restoring the independent applications from the checkpoints in response to initiating recovery of one or more the applications d wherein said high availability application services are provided to the independent applications running on a primary node while at least one backup node stands ready in the event of a fault and subsequent recovery and e coordinating execution of individual independent applications by a coordinator program which is executed on a node accessible to the multiple computer nodes.

According to another aspect of the invention a method system improvement or computer program performs loss less migration of an application group comprising a a high availability services module configured for execution in conjunction with an operating system upon which at least one application can be executed on one or more computer nodes of a distributed system and b programming within the high availability services module executable on the computer nodes for loss less migration of independent applications b i checkpointing of all state in the transport connection b ii coordinating checkpointing of the state of the transport connection across the application group b iii restoring all states in the transport connection to the state they were in at the last checkpoint b iv coordinating recovery within a restore procedure that is coupled to the transport connection.

According to another aspect of the invention there is described a method system improvement and or computer program for maintaining all transport connections across a fault. Transport connections will be automatically restored using Duration s virtual IP addressing mechanisms.

Another aspect of the invention is a method system improvement and or computer program that provides a mechanism to ensure that the independent applications are launched in the proper order and with the proper timing constraints during recovery. In one embodiment a mechanism is also provided to ensure that application programs are recovered in the proper order.

Another aspect of the invention is a method system computer program computer executable program or improvement wherein user controllable launch of independent applications for the application group is provided.

Another aspect of the invention is a method system computer program computer executable program or improvement wherein user controllable stop of independent applications and application group is provided.

Further aspects of the invention will be brought out in the following portions of the specification wherein the detailed description is for the purpose of fully disclosing preferred embodiments of the invention without placing limitations thereon.

Referring more specifically to the drawings for illustrative purposes the present invention will be described in relation to through . It will be appreciated that the system and apparatus of the invention may vary as to configuration and as to details of the constituent components and that the method may vary as to the specific steps and sequence without departing from the basic concepts as disclosed herein.

The context in which this invention is described is a multi process application group consisting of one or more threads per process. Each application group runs on the primary node and can be supported by one or more designated backup nodes. Without affecting the general case of multiple backups the following describes scenarios where each application group has one primary node and one backup node. Multiple backups are handled in a similar manner as a single backup. If the backup node is the same as the primary node all recovery is local.

The coordinator first launches the application process in a suspended state . Before allowing the application to run the coordinator fills a buffer with machine instructions to load the checkpoint library call the checkpoint library s initialization function and jump to the application s original entry point. The coordinator inserts the buffer into the address space of the application and changes the application s entry point to begin executing the first instruction contained in the buffer . The application is then resumed. Checkpointer information and policies are passed to the application through environment variables such as the coordinator s PID logical name of the application group and directory for storing checkpoints.

Upon starting the application executes the instructions contained in the inserted buffer to load the checkpoint library . The checkpoint library then initializes the checkpointer which includes registering with the coordinator and kernel module mapping the application group s process table creating the checkpoint thread and installing function interceptors. This is all performed before the application has executed any of its own code. Once the checkpointer has been initialized the checkpoint library passes control to the application by instructing the main thread to jump to the application s original entry point and the application proceeds to run.

There are three components to taking an application checkpoint the role of the coordinator is described in 3a the role of an application s checkpoint thread is described in 3b and the role of the applications individual threads are described in 3c.

While each application saves their state the checkpoint thread saves the group s process table to the coordinator s checkpoint file . The process table includes registration information PID virtual PID and binary pathname of each process in the application group. The name of the checkpoint file is a combination of the logical name of the application group PID and checkpoint count. The checkpoint thread then waits at the barrier for each process in the application group to complete their checkpoint . Once the application group has completed the collective checkpoint the coordinator s checkpoint thread releases all threads in the application group from the final barrier resuming each application of the group. The checkpoint thread then releases the checkpoint lock and goes back to waiting until it is time to take another checkpoint.

During a checkpoint the coordinator s main thread waits for process registration un registration and join messages . However the checkpoint lock must be acquired before a registration or un registration message is sent. Since the coordinator s checkpoint thread acquires the checkpoint lock before starting a checkpoint neither message will be sent during a checkpoint. Likewise join messages will not be serviced without first acquiring the checkpoint lock. Therefore join requests sent during a checkpoint are serviced once the application group s collective checkpoint has completed.

Once the application s threads have completed saving their state and are suspended at the barrier the checkpoint thread saves the state of the process kernel attributes and objects to the checkpointer s heap which are acquired through the process EPROCESS block. The checkpoint thread then saves the segments of the process user address space to the checkpoint file . The following list describes how the memory segments of a process are saved 

Before saving the state of the process each of the application s threads first ensure they were interrupted in a restorable state. A thread must not save its state if it was active in kernel space at the time it received the checkpoint signal because its state will not be able to be restored. Unlike a process private user address space kernel space is global and shared by all processes. Therefore the addresses of a thread s kernel components and kernel stack may not be available on restore. Each thread determines whether or not it was interrupted in a restorable state by examining its execution state at the time of the checkpoint signal. If a thread was either in a wait state or executing in user space it is already in a restorable state and proceeds to the next checkpoint barrier. Alternatively if a thread was active in kernel space at the time it received the checkpoint signal it installs a set of hooks to detect when it either enters a wait state or returns to user space.

To determine if and when a thread executing in kernel space returns to user space the thread s user mode instruction pointer is set to an invalid address before returning from the checkpoint signal handler . This will generate an exception as soon as the thread returns to user space which in turn will be caught by the checkpoint library s exception dispatcher interceptor . The interceptor ensures a checkpoint is in progress and directs the thread to the next checkpoint barrier in the kernel module as the thread has arrived in a restorable state.

To determine if and when a thread executing in kernel space enters a wait state a user mode APC is inserted at the front of the thread s APC queue before returning from the checkpoint signal handler . This will cause the thread to enter a user mode APC handler in the checkpoint library if the thread proceeds to wait. The APC handler in turn directs the thread to the next checkpoint barrier in the kernel module as the thread has arrived in a restorable state. Note for a user mode APC to trigger a thread must wait in an alertable state. The checkpoint library ensures this is the case by setting the Alertable flag within the interceptors of the wait functions. To prevent a thread from awakening prematurely from a wait state the thread did not intend to be alertable the checkpoint library intercepts all blocking functions and manages each thread s user mode APC queue.

Once all threads have arrived at the next checkpoint barrier they reset their user mode instruction pointer and remove the user mode APC from their APC queue if still queued. Each thread then proceeds to save its state to the checkpointer s heap by accessing its ETHREAD block. A thread s state includes but is not limited to its user mode context wait and mutant lists APC queues and control block. When each thread finishes saving its state it waits at the final barrier for the coordinator to release the application group from the checkpoint. When released all the application s threads return from the kernel module to resume where they left off before the checkpoint. Threads caught entering a wait state resume waiting from the checkpoint library s wait interceptors and threads caught exiting the kernel by the exception dispatcher interceptor resume from their valid user mode context by calling NtContinue .

There are three components to restoring an application from a checkpoint the role of the coordinator is described in 5a the role of an application s individual threads are described in 5b and the role of the application s checkpoint thread is described in 5c.

Upon creation the coordinator s checkpoint thread re acquires the checkpoint lock and waits for each application of the group to restore from their checkpoint . Once all applications of the group have been restored and their threads have arrived at the final barrier the checkpoint thread releases all threads from the barrier resuming the application group . The checkpoint thread then releases the checkpoint lock and goes back to waiting until it is time to take another checkpoint .

Each thread s kernel attributes are restored individually. Addresses of objects referenced by a thread s ETHREAD block are changed to reflect their new locations in memory. Various attributes within the ETHREAD block are left alone and must not be changed such as new thread IDs. Timed waits are also adjusted to coincide with the change in system time and incomplete I O operations are resumed. All threads then wait at the barrier for the coordinator to release the application group . Once released each thread exits the kernel module and resumes from its user mode context at the time of the checkpoint. Threads previously in a wait state resume waiting from the wait interceptor and threads caught in the exception dispatcher interceptor during a checkpoint resume from their valid user mode context by calling NtContinue . The restored application proceeds to run until it is time to take another checkpoint.

Kernel objects are recreated and their attributes are restored to their values at the time of the checkpoint . ID attributes are updated to reflect any new IDs assigned by the kernel on restore and object references are updated to reflect their new locations in memory. Each object s handle is virtualized by the checkpointer so the application may continue to use all its previous user space handles. Next the process kernel attributes are restored individually. Addresses of objects referenced by the EPROCESS block are changed to reflect their new locations in memory. Various attributes within the EPROCESS block are left alone and must not be changed such as new process and thread IDs. The checkpoint thread then proceeds to restore the user address space of the process. The following list describes how the memory segments of a process are restored 

Depending on whether or not the application process has already taken a checkpoint either a full or incremental checkpoint is taken 314. If the process has not yet taken a checkpoint it takes a full checkpoint . A full checkpoint contains the full state of the process as described above. Alternatively if the process has already taken at least one checkpoint it takes an incremental checkpoint . An incremental checkpoint only contains the state of the process that changed after the previous checkpoint except for thread stacks and checkpointer s heap which are saved at every checkpoint. A process kernel elements are written to the checkpointer s heap during a checkpoint as described above and are therefore saved at every checkpoint.

To facilitate taking an incremental checkpoint the checkpoint library maintains a page table to track changes to pages belonging to a process user address space. The checkpoint library creates a process page table when an application process is launched and populates it with the initial pages of the process user address space . All pages are initially marked dirty. The page table is updated when pages are modified and when pages are added and removed to from the process address space. The addition and removal of pages are detected by intercepting all memory allocation and de allocation functions before an application is allowed to run including functions that load libraries dynamically. When a new page is allocated the checkpointer adds a corresponding entry in the page table and marks the page dirty. Alternatively when a page is deallocated the checkpointer removes the corresponding entry from the page table.

To determine when an application s thread writes to a page in the process user address space the checkpointer write protects the process writable user space pages in memory after every checkpoint. Pages belonging to thread stacks and the checkpointer s heap are not write protected however they are saved at every checkpoint. When an application s thread writes to a write protected page one of two actions occur depending on whether or not the thread is in user or kernel mode at the time. If the thread is in user mode a segmentation violation exception will be raised by the kernel. The checkpoint library catches the segmentation violation with its exception dispatcher interceptor and first verifies the page has been write protected by the checkpointer. If so the checkpointer marks the page dirty in the checkpointer s page table restores the page s permissions and then re executes the instruction that triggered the exception. The thread will then proceed to write to the page as it is no longer write protected.

To handle when an application s thread writes to a write protected page in kernel mode via a system call the checkpoint library intercepts all system call wrappers that pass addresses of user space buffers as arguments to a system call. If a thread writes to a write protected page in kernel mode the kernel will return an error. The checkpointer either handles the error within the system call interceptors or prevents such errors from ever occurring depending on whether or not a system call may be re called without changing the application s behavior. If a system call can be re called without changing the application s behavior the system call s interceptor catches the error returned by the call verifies the page was write protected by the checkpointer marks the page dirty in the checkpointer s page table restores the page s permissions and then re executes the system call. Alternatively if a system call cannot be re called without changing the application s behavior the system call s interceptor restores the permissions of all user space pages referenced by the system call s arguments before the call is made marks the pages dirty in the checkpointer s page table and then executes the system call. The system call will then proceed to write to the user space pages referenced by the call s arguments as they are no longer write protected.

When it comes time to take an incremental checkpoint the checkpoint thread saves the process user space pages that are marked dirty in the checkpointer s page table . Pages belonging to thread stacks and the checkpointer s heap are not write protected and are therefore saved in full. Once an incremental checkpoint has been written the checkpointer sends the incremental checkpoint and previous full checkpoint files to the merge utility for merging . Before allowing the application to be released from the final barrier the checkpoint thread write protects the process dirty user space pages in memory and clears the corresponding dirty flags in the checkpointer s page table . The checkpoint thread then joins the application s threads at the final barrier and waits for the coordinator to release the application group from the checkpoint.

The merge utility merges an application process incremental checkpoint with its previous full checkpoint producing a new full checkpoint. All pages from the incremental checkpoint are copied to the new full checkpoint. A page from the previous full checkpoint is copied to the new full checkpoint if the page exists in the process address space at the time of the incremental checkpoint but does not exist in the incremental checkpoint. Merging is performed asynchronously an application does not need to wait for the merge to complete.

Upon receiving a join message the coordinator acquires the checkpoint lock to prevent a checkpoint from occurring while the new application process is being launched. The coordinator launches the application using the same method previously described for launching the initial application in . Once launched the new application registers with the coordinator. Upon receiving the registration message the coordinator adds a new process entry in the application group s process table and releases the checkpoint lock. The application is now a member of the application group and may proceed to run . The coordinator then goes back to waiting for new registration un registration and join requests.

On a successful launch the new application s checkpoint library first checks if a named file mapping is set in the environment. If set the checkpoint library maps the segment and copies its parent s data from shared memory into the process address space . The checkpoint library then proceeds to initialize the checkpointer and register with the coordinator as previously described. Once the application registers with the coordinator the checkpoint lock is released. The application is now a member of the application group and may proceed to run .

Referring once again to for illustrative purposes the case of migrating an application group from one node to another node is considered. The term migration is utilized to mean that the running application group is moved from server to server without first shutting down the application and the restarting the application from scratch on the new node.

Building on the disclosures above a loss less migration is achieved by first checkpointing an application group which includes one or more independent applications and then restoring the application group on a backup node. The migration is loss less which means that no data or processing is lost.

Migration of live applications is preferably activated in the anticipation of faults such as detecting that a CPU is overheating or because a server is running out of memory. Migration may also be activated when an administrator wants to re configure a set of servers or when servers currently being used have to be freed up.

Loss less migration of application groups can be viewed differently. The ability to checkpoint and migrate entire application groups makes an application location independent. Application groups can be moved started and stopped on any server at any point in time. The present teachings therefore show how to de couple a live running instance of an application from the underlying operating system and hardware. An application s execution has therefore been virtualized which enables live migration i.e. migration of a running application without any application involvement or knowledge thereof.

In the embodiments described herein an example programming environment was described for which an embodiment of programming according to the invention was taught. It should be appreciated that the present invention can be implemented by one of ordinary skill in the art using different program organizations and structures different data structures and of course any desired naming conventions without departing from the teachings herein. In addition the invention can be ported or otherwise configured for use across a wide range of operating system environments.

Although the description above contains many details these should not be construed as limiting the scope of the invention but as merely providing illustrations of some of the exemplary embodiments of this invention. Therefore it will be appreciated that the scope of the present invention fully encompasses other embodiments which may become obvious to those skilled in the art and that the scope of the present invention is accordingly to be limited by nothing other than the appended claims in which reference to an element in the singular is not intended to mean one and only one unless explicitly so stated but rather one or more. All structural and functional equivalents to the elements of the above described preferred embodiment that are known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the present claims. Moreover it is not necessary for a device or method to address each and every problem sought to be solved by the present invention for it to be encompassed by the present claims. Furthermore no element component or method step in the present disclosure is intended to be dedicated to the public regardless of whether the element component or method step is explicitly recited in the claims. No claim element herein is to be construed under the provisions of 35 U.S.C. 112 sixth paragraph unless the element is expressly recited using the phrase means for. 

