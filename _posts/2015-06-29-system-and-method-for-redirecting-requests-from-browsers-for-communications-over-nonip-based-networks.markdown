---

title: System and method for re-directing requests from browsers for communications over non-IP based networks
abstract: A method and system for deploying content to client applications is provided. Inbound messages are accepted from a client application running on a client device via a proxy IP/port. The inbound messages are packaged into an internal message format with an HTTP redirector. The packaged message is forwarded to a back-end server via a message router. A response is received form from a web server. The response is packaged into the internal message format with the back-end server. The response is then forwarded to the HTTP redirector via a message router. The response can then be transferred to the client application running on the client device, via the proxy IP/port.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09521185&OS=09521185&RS=09521185
owner: Telecommuncation Systems, Inc.
number: 09521185
owner_city: Annapolis
owner_country: US
publication_date: 20150629
---
The present application is a continuation of U.S. patent application Ser. No. 14 071 337 entitled System and Method for Re Directing Requests from Browsers for Communication Over Non IP Based Networks to Zombek et al. filed on Nov. 4 2013 which is a continuation application of U.S. patent application Ser. No. 13 492 080 entitled System and Method for Re Directing Requests from Browsers for Communication Over Non IP Based Networks to Zombek et al. filed on Jun. 8 2012 now U.S. Pat. No. 8 578 032 which is a continuation application of U.S. patent application Ser. No. 12 659 737 entitled System and Method for Re Directing Requests from Browsers for Communication Over Non IP Based Networks to Zombek et al. filed on Mar. 19 2010 now U.S. Pat. No. 8 200 829 which is a continuation application of U.S. patent application Ser. No. 11 327 413 entitled System and Method for Re Directing Requests from Browsers for Communication Over Non IP Based Networks to Zombek et al. filed on Jan. 9 2006 now U.S. Pat. No. 7 689 696 which is a continuation in part application of U.S. patent application Ser. No. 09 494 553 entitled A Messaging Method and Apparatus for Sending and Receiving Messages in a Client Server Environment Over Multiple Wireless Networks to Zombek et al. filed on Jan. 31 2000 which is a continuation in part application of U.S. patent application Ser. No. 09 694 297 entitled A Messaging Method and Apparatus for Sending and Receiving Messages in a Client Server Environment Over Multiple Wireless Networks to Zombek et al. filed on Oct. 24 2000 and a continuation in part application of U.S. patent application Ser. No. 09 698 181 entitled A System and Method for Re Directing Request from Browsers for Communication Over Non IP Based Networks to Zombek et al. filed on Oct. 30 2000 now U.S. Pat. No. 7 003 571 of common assignee to the present invention the contents of all of which are incorporated herein by reference in their entireties.

The present invention relates in general to the field of communications and more particularly to messaging between client devices and servers over multiple wireless networks that use different access protocols.

Recent advances in hardware and communication technologies have brought about an era of client computing over wired and wireless networks. The proliferation of powerful notebook computers and wireless client devices promises to provide client end users with network access at any time and in any location over various networks including the Internet. This continuous connectivity allows users to be quickly notified of changing events and provides them with the resources necessary to respond in realtime even when in transit. For example in the financial services industry online traders and financial professionals may be given the power to access information in real time using wireless client devices.

Conventionally however developers of complex wireless messaging solutions have been forced to develop applications that are specific to various device types and network access protocols in diverse enterprise architectures and platforms. In other words conventional client computing solutions have been largely platform specific network specific or both. For example messages may be generated by a wide variety of applications running on a wide variety of client devices such as Palm computing platform devices Windows CE devices paging and messaging devices laptop computers data capable smart phones etc. Depending on the type of network used by service providers the client generated messages may be transported over networks having various access protocols such as e.g. Cellular Digital Packet Data CDPD Mobitex dial up Internet connections Code Division Multiple Access CDMA Global System for Mobile Communications GSM and ReFlex. As a result current developers of client computing solutions must have intimate knowledge of specific network characteristics including e.g. wireless network characteristics protocol environments and wireless links channel characteristics. Therefore there exists a need to simplify wireless client and server application development environments to support the wide variety of device and network dependent architectures.

Messaging Application Programming Interface MAPI is a messaging architecture and an interface component for applications such as electronic mail scheduling calendaring and document management. As a messaging architecture MAPI provides a consistent interface for multiple application programs to interact with multiple messaging systems across a variety of hardware platforms. MAPI provides cross platform support through such industry standards as Simple Mail Transfer Protocol SMTP X.400 and common messaging calls. MAPI is also the messaging component of Windows Open Services Architecture WOSA .

Accordingly MAPI is built into such operating systems as e.g. Windows 95 Windows 98 Windows NT and Windows 2000 available from Microsoft Corporation of Redmond Wash. U.S.A. and can be used by 16 bit and 32 bit Windows applications. For example a word processor can send documents and a workgroup application can share and store different types of data using MAPI. MAPI separates the programming interfaces used by the client applications and the service providers. Every component works with a common Microsoft Windows based user interface. For example a single messaging client application can be used to receive messages from fax a bulletin board system a host based messaging system and a LAN based system. Messages from all of these systems can be delivered to a single universal inbox. 

Transmission Control Protocol TCP is a transport layer protocol used by an application in one host to communicate with an application in another host. This is accomplished by services provided by the protocol layers beneath the transport layer in both hosts. As a connection oriented protocol TCP requires the establishment of a connection between the two hosts before two applications are able to communicate. TCP manages the connection and once both applications have communicated all required information between themselves the connection is released as if the connection is two simplex connections as opposed to a single duplex connection. The information is transferred between applications on different hosts is a byte stream. The transport layer hides message transfer details such as segmentation ordering and duplication from the applications and provides end to end acknowledgement.

The Internet Protocol IP layer provides certain services to the transport layer protocol including hiding the details of the physical and data link layers and the services provided by them from the transport layer protocol. The IP layer provides a datagram delivery service. A datagram is a unit of data less than an entire message. A message may be for example a file which may be quite large. Since there is a maximum size for a message or file the message may have to be segmented and transferred in smaller units. These smaller units are thus called datagrams. Each datagram is sent over the network as a separate entity and may in fact follow separate paths to the destination host. At the destination host the datagrams are reassembled in proper order usually in a buffer area by the transport layer. Each node on the network sends any datagrams on to a next node only considering the final destination and only acknowledges receipt of the datagram to the preceding node. That is the IP layer does not provide end to end acknowledgement. End to end acknowledgement is a service of the transport layer protocol. Should any node to node acknowledgements not be received by the preceding node the datagram or datagrams unacknowledged will be retransmitted. The transport layer in the destination host will also acknowledge any duplicated datagrams else receipt of duplicate datagrams will continue resulting in a clogged network and ignore them.

Routing between network nodes is accomplished by means of routing tables. These routing tables can be static or dynamic and result in datagrams being forwarded from a source host to a destination host one node at a time. The intermediate nodes are often called hops. 

The acronym TCP IP is also used to refer to a five layer protocol model similar to the ISO OSI seven layer protocol model. The TCP IP model does not have the equivalent to layers 5 and 6 of the ISO OSI protocol model. A protocol model defines the protocol layers and the interfaces between the layers. When implemented in software hardware or firmware or possibly field programmable gate arrays FPGAs the implementation provides the actual services. This layered approach allows for ease of upgrading so long as the interface to the layer immediately above or below is not altered. Layering also allows for complete substitution. For example should a new physical medium become available then so long as the interface between layer two and layer one remain the same an old physical layer implementation module can be removed and a new implementation module substituted. In the alternative the new implementation module could be added as another option. That is the protocol suite defines the rules and the implementation provides the services that allow the communications to take place between applications on different hosts. The implementation of the TCP layer provides for the application to require a certain Quality of Service QOS as specified by a set of parameters including but not limited to priority transmission delay throughput etc.

Another well known transport layer protocol is known as User Datagram Protocol UDP which is a connectionless transport protocol. The basic data transfer unit is the datagram. A datagram is divided into header and data areas as it is for the IP layer. An additional header over and above the IP header is used. The UDP header contains source and destination addresses ports a UDP length field the length includes the 8 byte header and the data and a UDP checksum. The UDP data includes the IP header and data. The IP layer supports UDP as a connectionless transport protocol for use in transmitting for example one time request reply type messages or applications where time is of greater importance than accuracy.

TCP is used by applications on different hosts to communicate over an assumed unreliable network. To accomplish such communication much is added to the protocol in order to ensure that the information transferred over the network is valid. This addition has a cost and that cost is increased overhead with the attendant increase in bandwidth. A UDP header is eight bytes the TCP header is 24 bytes and an IP header is a minimum of 20 bytes. Therefore UDP IP headers are a minimum of 28 bytes and TCP IP headers are a minimum of 44 bytes. This is fairly large in terms of overhead and bandwidth utilization particularly over wireless networks. There are other significant problems with using standard TCP IP over wireless networks principally in the area of flow control. The UDP IP protocol combination while not offering any guarantees to users is expected to be reliable. Wireless networks tend however by their nature to be lossy. Several solutions have been proposed when the network is not homogeneous. That is when the network has both wireless and wireline portions. One suggestion is to use indirect TCP and another is to use snooping.

Other protocols such as Serial Line IP SLIP and Point to Point Protocol PPP have been developed. SLIP is not a standard and both are for point to point connections only so are not available for uses in networks. CDPD vendors indicate that they provide an integrated TCP IP stack but it is not known the cost in terms of bandwidth overhead.

Conventionally the existing wireless protocols do not provide an end to end solution over multiple networks and multiple client devices. Therefore in addition to the need for a common architecture through a single user friendly methodology for providing effective and reliable wireless data solutions for hand held and laptop computing devices wireless networks and legacy systems there also exists a need to efficiently and reliably communicate data using minimum bandwidth.

The present invention features a system method and computer program product that in an exemplary embodiment is operative to provide a multi network transport programming interface that can enable client server applications to be written easily where such applications can allow client applications running on client devices to communicate messages with server applications across one or more wireless and wire line networks. Moreover the present invention in an exemplary embodiment offers features for communicating such messages over wireless networks efficiently without requiring significant bandwidth a valuable resource in wireless networks.

Briefly the present invention in an exemplary embodiment includes a system for communicating messages in a client server environment over one or more wireless networks that can support different network protocols. In an exemplary embodiment the system of the invention includes a client device operative to execute a client application and a back end server BES operative to execute a server application. In an exemplary embodiment a protocol gateway PG can encapsulate an underlying network protocol of the plurality of wireless networks. In an exemplary embodiment a client application and the server application can communicate messages with each other through the PG independently of the underlying network protocol of the wireless network used for such communication.

Conventional session based transport protocols e.g. TCP are designed for LAN based systems with little network latency. These session based transport protocol implementations are extremely chatty and were not designed to consider the amount of bytes sent over the network to maintain the state of a connection.

Advantageously the present invention in an exemplary embodiment features a highly optimized semi reliable data transport protocol simple network transport layer SNTL . The transport protocol implementation in an exemplary embodiment can optimize the over the air communication by using a connectionless send and receive mechanism. In addition or alternatively in an exemplary embodiment the present invention can provide multiple compression mechanisms to reduce the amount of information that needs to be sent over the air. In an exemplary embodiment in order to provide a reliable mechanism over a connectionless environment the transport protocol implementation can provide for message segmentation and reassembly message retries or message ACK and NACK service for each supported wireless network. In an exemplary embodiment message segments that are not acknowledged by the peer protocol layer within the configurable time frame can be retried automatically by the transport protocol implementation. In order to facilitate the request and provision of services the interfaces between layers can be clearly defined for peer to peer communication between corresponding layers of both sides of a connection. That is the protocol stack on each side client and server can be symmetrical. This can allow two machines to specify how they communicate with one another on a level to level basis rather than having to negotiate one giant protocol for the entire network. This means that logical communications can occur at the peer protocol layer. On the client side for wireless communications this can be called a peer wireless protocol layer. In an exemplary embodiment the client or server applications do not need to be concerned with segmenting the message and performing message retries. In addition to performing message retries the transport protocol implementation can support message duplication detection. In an exemplary embodiment to support this reliable mechanism over a connectionless environment the transport protocol implementation can add only four to six bytes to each application message. In an exemplary embodiment SNTL can include a novel and non obvious hybrid protocol including many of the advantages of TCP but connectionless as is UDP. Further in an exemplary embodiment there can be less overhead than is required by conventional TCP.

The present invention in an exemplary embodiment can also use a wireless connectivity middle layer gateway which can be developed using a wireless software development environment. The environment can insulate a developer from the complexities of the underlying details related to devices and protocols.

In an exemplary embodiment the environment can be packaged advantageously as a software development toolkit SDK . The developer can work at the application layer by using the SDK. The SDK in an exemplary embodiment can include e.g. software libraries for client and or server application development. The present invention in an exemplary embodiment can support solutions and software engineering using technologies such as e.g. Windows NT 95 98 2000 Open Database Connection ODBC compliant databases Palm OS and Windows CE client devices and CDPD Mobitex and dial up networks.

Advantageously wireless technologies and client devices can remain transparent to the data source through the use of client and server application programming interfaces APIs that can support multiple operating environments including for example Palm OS RIM Windows 95 98 2000 CE and NT UNIX Linux and other variations of UNIX etc. These well defined APIs can use a set of portable class libraries to aid in rapid application development. Access to the intelligent messaging network of the present invention can be via wireless client devices or via a dial up or leased line or other wireline connection coupled via e.g. an Internet service provider ISP a network service provider NSP a private network or a virtual private network VPN . That is enterprise support can be provided for and to wireless clients and clients that need to access the intelligent messaging network of the present invention via a wired connection or dial up line. This latter group of clients can be called Internet proxy clients i.e. clients that can use a proxy server for access to the Internet. As client devices and wireless network technologies evolve this system can ensure that data solutions are supported.

In an exemplary embodiment a method and system for deploying content to client applications is provided. Inbound messages are accepted from a client application running on a client device via a proxy IP port. The inbound messages are packaged into an internal message format with an HTTP redirector. The packaged message is forwarded to a back end server via a message router. A response is received form from a web server. The response is packaged into the internal message format with the back end server. The response is then forwarded to the HTTP redirector via a message router. The response can then be transferred to the client application running on the client device via the proxy IP port.

In another embodiment a wireless device for communicating with a server via a wireless network is provided. The wireless device can include a browser generating a request. A redirector can receive the request via a proxy IP port. The redirector may then package the request with a protocol used by the wireless network.

The request may be fulfilled by the wireless network and transmitted to the wireless device. In one embodiment the request may be an HTTP request. The HTTP request can be sent from a proxy server to an appropriate web server. A response is received to the request. The response may then be packaged into a message format used by the wireless network. The packaged response is sent to a redirector. The packaged response can be unpacked with the redirector and provided the to a web browser.

In another exemplary embodiment a method of deploying content from one of a plurality of servers through a message router and over a wireless network to a client application which is running on one or more of a plurality of client devices is provided. An inbound message can be created with a redirector at the client device. The inbound message may include a message key. The inbound message can be sent from the client device and accepted at the message router. The inbound message may be forwarded to a selected one of the plurality of servers based on the message key.

A further embodiment includes a messaging system. The messaging system may comprise. A client device having a web browser and a redirector communicating with the web browse. The redirector can package messages from the web browser in a fundamental network protocol. A plurality of wireless networks each of which is adapted to communicate messages between the client device and a server and support one or more wireless network protocols may be provided. A protocol gateway can encapsulate the fundamental network protocol which underlies each of the one or more wireless network protocols. Also means for communicating messages between the web browser and the server over a selected wireless network protocol through the protocol gateway independent of the selected wireless network protocol should be included.

A computer useable information storage medium storing computer readable program code may be provided to carry out the method. For example an embodiment of the invention may include a computer useable information storage medium storing computer readable program code for causing a computer to perform the steps of 

Further features and advantages of the invention as well as the structure and operation of various exemplary embodiments of the invention are described in detail below with reference to the accompanying drawings. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digits in the corresponding reference number.

A preferred embodiment of the invention is discussed in detail below. While specific implementations are discussed it should be understood that this is done for illustration purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without parting from the spirit and scope of the invention.

As described in detail below the communication system can support an intelligent messaging network architecture hereafter referred to as intelligent messaging network according to the present invention. The intelligent messaging network advantageously can incorporate a middleware service in accordance with the present invention that can allow for the development of client and server applications independent of the underlying network protocols and device configurations. The basic middleware services offered by the intelligent messaging network architecture can include e.g. client server connectivity platform transparency network transparency application tool support through the use of APIs network management interaction with other network services scalability and high availability.

A number of the protocol gateways PGs and collectively PGs can be configured to support a specific network access protocol. The PGs in an exemplary embodiment can act as an interface between a network and wide area local area networks WANs LANs and . The PGs can provide the flexibility to support multiple present and future wireless access protocols such as e.g. GPRS. Networks collectively including networks and as shown can be coupled to network by e.g. a router and can be protected from unauthorized access through a firewall . Networks can include e.g. a wide area network WAN local area network LAN and or the global Internet. Among other things networks can include e.g. one or more back end servers BESs and collectively BESs that can run server applications that can communicate messages with client applications running on the client devices . Via one or more message routers MRs and collectively MRs these messages can be routed between the BESs and the PGs and other network components. From the BESs messages can be transmitted or delivered to e.g. a content provider . A specific type of BES shown as an HTTP Proxy BES can be used to send messages to an internet server such as a web server. It should be noted that although the present invention is described with reference to a specific exemplary architecture a wide variety of WANs and LANs that can support wired and wireless environments are possible.

The PGs can be responsible for sending and receiving application messages between client applications and a BES that can support the service type of the application message. The message can be routed to the BES via the MR as will described further below with reference to . For each network access protocol that the intelligent messaging network supports a corresponding PG can support that network access protocol. PGs can communicate directly with one or more MRs using e.g. conventional TCP IP communications or a modification of TCP IP to address flow control between wireless and wireline networks. In an exemplary embodiment of the invention the PGs can use clustering for e.g. redundancy scalability and load balancing of incoming IP traffic across all the nodes within a configured cluster. In an exemplary embodiment PGs can provide load balancing by providing traffic to MRs in e.g. a round robin fashion which can e.g. transmit to least recently used MR . Under this arrangement client applications can be configured to communicate to a single virtual IP address of the PG cluster. Advantageously this can provide the intelligent messaging network the flexibility to dynamically start and stop the PGs without disrupting service. Typically the PGs can run outside of the firewall . However the intelligent messaging network architecture of the present invention does not preclude the PGs from running inside an enterprise firewall . It will be apparent to those skilled in the art that alternative configurations can also be used within the spirit and scope of the present invention.

The BESs and MRs can each have access to corresponding BES and MR databases DBs and respectively which can store server application and message routing parameters. Alternatively a shared database can be used to store information on an auxiliary memory device such as e.g. a storage area network SAN . The BES DB and MR DB can each maintain a common pool of information amongst the entire group of network servers. In an exemplary embodiment this information which can be independent of any specific messaging application can be stored and accessed from a structured query language SQL database.

In order to assist network administrators in managing the intelligent messaging network the intelligent messaging network architecture can incorporate one or more simple network management protocol SNMP management consoles and collectively SNMP console as the mechanism for network management. SNMP is a standard network management protocol widely used in conventional TCP IP networks. The console e.g. can receive SNMP alerts. In an exemplary embodiment a customer s SNMP console can be hooked into including such data as might reside in e.g. a management information base MIB . The SNMP console can be used to easily and effectively manage the intelligent messaging network of the present invention. In addition to providing SNMP support the intelligent messaging network can provide network administrators a tool to monitor the health of the network. An SNMP console can be placed in a network operations center NOC to advantageously centrally manage the intelligent messaging network of the present invention.

An HTTP Redirector can enable off the shelf web browsers such as e.g. browser to send and receive requests such as e.g. hypertext transfer protocol HTTP requests over the intelligent messaging network. As described later the HTTP Redirector can work by intercepting HTTP requests from the browser and can redirect them over the intelligent messaging network for fulfillment by an intelligent messaging network HTTP proxy back end server or collectively HTTP proxy back end servers HBES which in turn can forward messages on to e.g. other Internet servers . While the intelligent messaging network can provide a set of advanced services the network can also offer support for external legacy services that might already be in use by an organization. By supporting other vendor services such as e.g. security and databases the intelligent messaging network can fit into an existing legacy networking environment thereby allowing organizations to use their existing networking environment.

In an exemplary implementation embodiment of the present invention the Intelligent Messaging Network of the present invention can use an Aether Intelligent Messaging AIM Network also referred to as AIM.net developed by Aether Systems Inc. of Owings Mills Md. U.S.A. the assignee of the present invention.

In an exemplary implementation embodiment the BES can be an Aether Back End Server ABES available from Aether Systems Inc. of Owings Mills Md. U.S.A.

In an exemplary implementation embodiment the PG can be an Aether Protocol Gateway APG also previously referred to as a frontend server FES available from Aether Systems Inc. of Owings Mills Md. U.S.A.

In an exemplary implementation embodiment the MR can be an Aether Message Router AMR available from Aether Systems Inc. of Owings Mills Md. U.S.A.

An exemplary embodiment of the MR DB is an AIM database available from Aether Systems Inc. of Owings Mills Md. U.S.A.

In an exemplary implementation embodiment the SNMP Console can be an Aether SNMP Network Management Console available from Aether Systems Inc. of Owings Mills Md. U.S.A. which can include an SNMP compliant network management application and hardware system platform.

In an exemplary implementation embodiment the HTTP Proxy Back End Server can be an Aether HTTP Proxy Back End Server available from Aether Systems Inc. of Owings Mills Md. U.S.A.

It will be apparent to those skilled in the relevant art that alternative implementations incorporating alternative or additional components systems operating systems and applications could also be used within the spirit and scope of the present invention.

The intelligent messaging network in an exemplary embodiment can provide multiple software development kits SDKs to assist e.g. engineers in developing client and server applications. The SDKs can contain a consistent set of APIs and a set of platform specific libraries for all intelligent messaging network supported platforms and networks. In addition to the SDKs the intelligent messaging network can provide developers a resource kit including a set of tools to assist the developers when designing implementing and testing their client and server applications.

As described later in detail the intelligent messaging network can provide in an exemplary embodiment a mobile client and server SDK environment to assist engineers developing client applications and BESs . The SDKs can provide an easy to use API and a set of platform specific libraries to perform e.g. compression network management services server to server communication server registration de registration and reliable message transport services.

In an exemplary embodiment all of the servers PGs MRs BESs can use e.g. Windows NT 4.0 as their operating system available from Microsoft Corporation of Redmond Wash. U.S.A. Although alternative operating systems can be used in alternate embodiments as will be apparent to those skilled in the art functionality of the present invention will be described in an exemplary Windows NT v.4.0 environment. All the servers provide a set of common services including e.g. 

The intelligent messaging network server SDK can encapsulate the implementation of these core functions via application programming interfaces APIs to insulate application developers from the hardware software and protocol details of the underlying platforms. Provided below is a description of exemplary common services.

All intelligent messaging network servers can support the standard SNMP GET SET and GET NEXT operations. In addition the intelligent messaging network servers can generate SNMP traps for notifying a network administrator of a critical event. The intelligent messaging network Server SDK can provide a common MIB for basic control and status handling that is shared by all the intelligent messaging network servers. In addition the intelligent messaging network server SDK can provide a MIB for each supported server type i.e. PG MR HTTP Proxy Back End Server and BES . Developers developing BESs can define custom MIBs to support functions specific to their application needs and can register the custom MIBs in a registered MIBs database . Registration of a custom MIB with the SNMP console can be encapsulated by a set of network management APIs provided by the intelligent messaging network server SDK.

All intelligent messaging network servers can log critical information e.g. start stop time and critical errors to the NT event log on a corresponding platform on which they are running. Developers developing BESs can log application specific events to the NT event log via APIs provided by the intelligent messaging network server SDK.

All intelligent messaging network servers can optionally log inbound outbound and system events on the platform on which they are running. Developers developing BESs can log application specific information to an application info log via APIs provided by the intelligent messaging network server SDK. In this way developers are not required to know the implementation details of how to log a message to the inbound outbound or system info logs.

In an exemplary embodiment of the invention all intelligent messaging network servers can run as NT services. Rather than having each server implement the necessary code to run as an NT service a utility program called AimServiceAny can be that can wrap NT service functionality around each intelligent messaging network server executable. The benefits of running a server as an NT service can include the following advantages 

Each server to server connection can include a TCP connection. As indicated in block diagram PGs can be coupled to MRs MRs can be coupled to PGs and BESs or HBESs and BESs or HBESs can be coupled to MRs . Server startup logic can include e.g. starting the servers and in any order as each server can attempt to find the server s of the required type to which it is to be coupled. The server start sequence in an exemplary embodiment can proceed as follows 

In step the PG can use registration services provided by e.g. the intelligent messaging network server SDK to register the PG with the intelligent messaging network by adding an entry to a RegisteredServers table in the MR database .

In step the PG can use registration services provided by the intelligent messaging network server SDK to enumerate the list of all the MRs registered with the intelligent messaging network in e.g. the same domain. From step flow can continue with step .

In step using an IP address and listener port for each of the MRs the PG can use communication services provided by the intelligent messaging network server SDK to establish and manage a TCP IP connection with each of the MRs contained in the enumerated list. When a PG couples itself to the MR the MR can add the PG to its RegisteredServers cache and can begin to start forwarding messages to the PG . If a connection attempt fails the PG can re attempt to connect to the MR according to an exemplary embodiment of the present invention.

In step the MR can use registration services provided by the intelligent messaging network server SDK to register itself with the intelligent messaging network by adding an entry to the RegisteredServers table in the MR database . It will be apparent to those skilled in the art that an alternative database could be used. From step diagram can continue with step .

In step the MR can use registration services provided by the intelligent messaging network server SDK to enumerate a list of e.g. all PGs and BESs registered with the intelligent messaging network. From step diagram can continue with step .

In step using the IP Address and listener port for each PG the MR can use communication services provided by the intelligent messaging network server SDK to establish and manage a TCP IP connection with e.g. each PG contained in the enumerated list. When a MR couples to a PG the PG can add the MR to its Server Connections cache and can begin to start forwarding messages to the Message Router. From step diagram can continue with step .

In step using the IP address and listener port for each BES the MR can uses communication services provided by the intelligent messaging network server SDK to establish and manage a TCP IP connection with each BES contained in the enumerated list. When a MR couples to a BES the BES can add the MR to its Server Connections cache and can begin to start forwarding messages to the MR .

In step the BES can use the registration services provided by the intelligent messaging network server SDK to register itself with the intelligent messaging network by adding an entry to the RegisteredServers table in the MR database . From step diagram can continue with step .

In step the BES can use registration services provided by the intelligent messaging network server SDK to enumerate the list of e.g. all MRs registered with the intelligent messaging network. From step diagram can continue with step .

In step using the IP address and listener port for each MR the BES can use the communication services provided by the intelligent messaging network server SDK to establish and manage a TCP IP connection with each MR contained in the enumerated list. When a BES can couple to a MR the MR can add the BES to its RegisteredServers cache and can begin to start forwarding messages to the BES . If the connection attempt fails the BES can reattempt to connect to the MR .

If two peer intelligent messaging network servers are started at approximately the same time it is possible that each will attempt to connect to the other thus establishing two connections between them rather than a desired single connection. The possibility of colliding connection requests is the reason that during the connection handshake the servers exchange unique database registration IDs. Each server can use the unique database registration ID to keep track of which servers it is already connected to so that if server A establishes a connection to server B and due to race conditions server B immediately establishes another connection to server A server A can use the unique database registration ID passed by server B to realize that it already has a connection to server B and thus can drop the new connection.

When an intelligent messaging network server is started it can register itself with the network by adding an entry to a RegisteredServers table in the intelligent messaging network MR database . This can enable other intelligent messaging network servers to locate one another on the network. An API provided by the intelligent messaging network server SDK can allow for registering the following server attributes in the intelligent messaging network MR database 

When an intelligent messaging network server is stopped it can de register itself from the network by removing its entry from the RegisterServers table in the intelligent messaging network MR database . An API can be provided by the intelligent messaging network server SDK to de register a server in the intelligent messaging network MR database .

In an exemplary embodiment of the invention intelligent messaging network servers can communicate with each other over a TCP IP socket connection. APIs provided by the intelligent messaging network server can encapsulate the creation management and sending receiving of data over the socket connection.

In addition to the above described common set of services each server can also provide additional services that can be specific to the functionality of the server. Thus in an exemplary embodiment the intelligent messaging network architecture can include various core software components that can run on e.g. 

Using the registration services provided by the intelligent messaging network server SDK the PGs can follow a predefined start up sequence to register itself with the intelligent messaging network. Each PG can add an entry to the RegisteredServers table in the intelligent messaging network MR database and can enumerate the list of all MRs registered with the network in the same domain. Based on the IP address and listener socket for each MR the PG can establish and manage a TCP IP connection with each MR contained in the enumerated list. When a PG connects to an MR the MR can add the PG to its RegisteredServers cache and can begin forwarding messages to the PG . If however the connection attempt fails e.g. there is a timeout the PG can re attempt to connect to the MR after a configurable time period.

In addition to the above described common services the PGs can be responsible for supporting the following specific services 

Each PG can encapsulate the underlying wireless network access protocol so that it is transparent to MR and BESs . As a result when the MR receives a message from a PG it is unaware of the underlying network access protocol used for communicating the message.

All messages to be transmitted over the network that exceed a predefined segment size can be segmented into multiple message segments.

All incoming message segments except the last segment to complete the message received including duplicate segments can be immediately acknowledged back to the peer wireless protocol layer and can be queued pending receipt of all message segments via an inbound message map. When the last segment to complete the message is received the PG does not immediately send an acknowledgment to the peer wireless protocol layer. Instead the message segments can be assembled into a complete message which can be forwarded to an appropriate BES via an MR . When the BES successfully receives the message and acknowledges the same to the PG via MR then the PG can acknowledge the last segment received thus completing the acknowledgment of the entire message. An inbound message map can manage a separate inbound message map for each unique link station ID of a sender.

When a message segment has been received for a segmented message the PG can check to make sure the message segment has not been already received i.e. a duplicate message segment . If the message segment is a duplicate the segment can be acknowledged to the peer wireless protocol layer discarded and conditionally logged.

When all message segments have been received for a message the segments can be assembled into a complete message. If the message ID of the assembled message has been already received duplicate message then the message can be acknowledged to a corresponding peer wireless protocol layer discarded and conditionally logged. Each PG can keep track of the last n message IDs received for each unique link station ID.

Any message that is bound for a client device can be segmented into a number of segments greater than a segmented pacing threshold and can be sent at a pacing interval. The threshold and interval can be configurable prior to a gateway protocol startup. Each PG can automatically retransmit any message segment transmitted over the network that is not acknowledged by a corresponding peer wireless protocol layer within a configurable amount of time. The PG can retry a configured number of times before notifying a BES that the message could not be delivered to a client application.

When a message segment is transmitted over the network each PG can retain knowledge of all outstanding message segments pending acknowledgment message segments that have not been acknowledged by the peer wireless protocol layer via a pending acknowledgment map. The pending acknowledgment map can maintain information pertaining to message segments that have been successfully transmitted and are pending acknowledgment from the peer wireless protocol layer. If an acknowledgment positive or negative is received for a message segment that is not pending acknowledgment the segment can be discarded and conditionally logged.

When all message segments have been positively acknowledged by the peer wireless protocol layer the PG can sen as shown in step of an ACK control message to the BES via MR provided that the BES has requested such notification to indicate the message has been successfully delivered to the client application. If the number of transmission attempts for the message segment exceeds a configurable number of retry attempts the PG can send an NACK control message to the BES to indicate that the message could not be delivered to the client application.

Each MR can communicate with the PGs and BESs . Upon start up the MR can use the registration services provided by the intelligent messaging network server SDK to register the MR itself with the intelligent messaging network by adding an entry to the RegisteredServers table in the MR database . The MR can also use the registration services to enumerate the list of all the PGs and BESs that are registered with the intelligent messaging network. Using the IP address and listener port or socket for each PG the MR can establish and manage a TCP IP connection with each PG contained in the enumerated list. When an MR connects to a PG the PG can add the MR to its Server Connections cache and can begin to start forwarding messages to the MR . Based on the IP address and listener port for each BES the MR can also establish and manage a TCP IP connection with each BES contained in the enumerated list. See . When a MR connects to a BES the BES can also add the MR to its Server Connections cache and can begin to start forwarding messages to the MR .

Each MR can also use the registration services provided by the intelligent messaging network server SDK to de register itself from the intelligent messaging network by removing its entry from the RegisteredServers table in the MR database . The MR can close the TCP IP connection with each PG . Each PG can also remove the MR from its Server Connections cache and can immediately stop forwarding messages to the terminating MR . Then the MR can clean up any previously allocated resources and can terminate.

MRs and BESs can communicate via a TCP IP connection. As shown BES can be registered for service type 7 and message type 5. BES can be registered for service type 7 and all message types as illustrated by an asterisk wildcard character. Each BES can have a unique server ID and service type combination. The only server ID that can be shared is 0 zero .

The client device can communicate with PG and can send a message including a unique message key. The unique message key can include in an exemplary embodiment a server identifier ID a service type and a message type as shown. The PG can provide the MR the message over network

PG in an exemplary embodiment can route to a least recently used MR providing a round robin load balancing function. In an exemplary embodiment redundancy can be provided by using e.g. multiple PGs and multiple MRs . Similarly when an MR has a message to route to a PG in the case of an alert or a response the MR can similarly use a round robin load balancing method to route the message to a least recently used PG supporting the protocol of the client device associated with the message.

Also MR can route a message received from the PG to a BES or HBES . MR can route the message in an exemplary embodiment according to a set of semantic rules. In an exemplary embodiment the message can be routed to the BES which most specifically corresponds to the contents of the message key. In an exemplary embodiment if more than one BES corresponds specifically to the message key the least recently used BES can be used by checking a time stamp identifying the last access to the BES .

As an illustrative example suppose client device sends a message containing a message key server ID 0 service type 7 and message type 5 to a BES . In the exemplary illustration PG would forward the message to the least recently used MR . MR could look at the message key 0 7 5 to determine how to route the message. Based on the example registrations described above for BES 0 7 5 BES 0 7 and BES 1 7 MR could route the message to BES since the BES most specifically corresponded to the message key by having the exact service type and message type as the message key. It is important to note that BES with a wild card asterisk for supported message type could also support the message if BES was not available. The semantic rules could use the BES as an alternative routing destination if BES is unavailable.

For purposes of sending follow on messages to a particular BES in an exemplary embodiment a specific server ID can be placed in a message. In an exemplary embodiment only one BES will have a specific combination of server ID and service type.

In addition to the common services that all intelligent messaging network servers support the MRs are responsible for supporting the following specific services 

The MR can be responsible for determining that the sender of a message is an authorized customer of the intelligent messaging network. When the source of a message is a client device the MR can use the device s source address e.g. IP address or Mobitex MAN number of the client device as the means of identifying authorized access.

When each MR receives a client message it can check the device address against a local cache of authorized devices . If the source address is not found locally the MR can then check the MR DB . If the device address is an authorized client device in an exemplary embodiment and the customer has permission rights to the requested service type and the requested service type is not in use by the customer s account with a different source address the MR can cache the device address customer identifier and requested service type to ensure fast authentication of additional messages from the same source. Then the message can be considered authentic and can be forwarded to the proper BES . Each MR also can pass the customer identifier to the BES to use as a key to search for customer specific information.

In order to support dial up access in an exemplary embodiment message authentication based on the device s source address is not used because during a dial up access the source address that can be seen by an MR is the IP Address of the ISP provider. Each subscriber that desires wire line access can have a User ID and Password which can be selected by the subscriber at the time they subscribe to a service and can be saved as part of the MR DB .

Each MR can initially follow the same procedure to authenticate a dial up message as it does when authenticating a wireless message. However in case a message is received from a dial up connection the MR can issue an authentication challenge to the message source. On receiving the challenge the client application can prompt the user to enter the user ID and password of the user which can be forwarded encrypted to the MR as an authentication request and can proceed with authentication process.

Once a message source has been authenticated the MR can check the service type and source address of subsequent messages against its authentication cache and can allow disallow the message as appropriate. Preferably in an exemplary embodiment the MR does not keep the cached mapping between a source address and valid customer indefinitely. A configurable timeout period may be specified after which cached entries can be removed. The timeout interval can be the length of time that has passed between successive messages from a cached client device . When a client device times out due to inactivity the MR can remove it from its cache. For dial up devices the MR can also decrement a device s authentication count within the intelligent messaging network MR database . The authentication count can indicate how many other MRs have heard from the client device . When a dial up device s authentication count drops to zero the device address can be removed from the MR DB .

According to an exemplary embodiment of the invention there can be several ways in which an MR can route a client message to a BES including e.g. 

Indirect Routing via an indirect routing table that can map message keys service type and message ID to a registered BES that supports the message key and

The form of routing can be determined based on the contents of an intelligent messaging message header. The intelligent messaging message header or message key can be pre fixed to every application message.

a 1 byte Server ID that can identify a specific server of the given service type. The value 0 can be reserved to indicate that indirect routing is desired. A non zero value can indicate that the message is directed at a specific BES 

a 12 bit Service Type Identifier which can be used by both indirect and direct routing can identify the type of service e.g. MarketClip FX etc. associated with the messages and

a 12 bit Message Type Identifier that can uniquely identify the message within the context of the specified service type required for direct routing.

When an MR receives an incoming message from a client application it can check the Server ID field contained in the intelligent messaging message header portion of the message. If the Server ID field of the intelligent messaging message header is zero the MR can route the message to the proper BES by consulting a routing table that can map message keys Service Type and Message ID to the IP address of one or more connected BESs as described above with reference to .

During server registration all BESs can be required to register a list of supported message keys. To minimize the number of entries that are made in the routing table if a given BES supports the majority of messages for a specific Service Type it need only register a single root message key including only the Service Type. The small subset of service messages not supported by that BES would be registered as individual message keys by a different BES of the same Service Type. The MR can route messages based on the most specific key value Service Type Server ID and Message ID found in the table. If no specific mapping is found the MR can use the Service Type portion of the key to look for root message entries. If the MR locates more than one BES that satisfies the message key match it can use a round robin scheduling procedure to pick which target BES to route to. For example the timestamp of last access of the BES can be consulted to determine a least recently used BES .

Consider e.g. two third party services MarketClip and FX Reuters news service solutions for real time reporting on equities and foreign exchanges with messages for each application supported by a corresponding BES . Under the configuration of the invention each application BES could only have to register its root service type e.g. MktMon or FX in order for its messages or responses for client devices to be routed correctly by the MR . Suppose that two BESs currently support news requests independently of one another i.e. there is no common news BES that both of them use but a separate news BES can be created to handle ALL news requests. Ideally no new software should be sent to service providers so that all future news messages for either application are tagged to go to the new news server. Rather the new news BES upon registration can add the specific news message keys previously handled by the MarketClip and FX BESs to the MRs message routing table.

It should be noted that the original BESs do not need to change because the news BES message keys can contain the service types and message IDs specific to the two applications. Each MR can do its primary routing based on the more specific table entries the same news messages that would have formerly been routed to the two BESs could get routed to the new news BES . Thus the BESs can be designed around specific services rather than a suite of services that comprise an application some of which may be common to other applications. Under this arrangement overall response performance can improve as specific services are assigned to their own BES . This is because a client application not using a given service does not have to wait while the BES is accessing process requests for a different service.

BESs that can maintain state information about a particular client device can often require direct routing. For a client to ensure that a message reaches a specific BES the intelligent messaging network message header portion of the message can contain a non zero value in the Server ID field. When an MR sees a non zero value in the Server ID field it can route the message to the proper BES by consulting a routing table that maps server keys Service Type Message ID Server ID to the IP address of a connected BES .

Specifying a Server ID alone can be not sufficient to ensure that the message is delivered to the proper BES . Even when using direct routing a BES can register the service types and message IDs it can handle and the service type message ID of a direct route message can match those types registered by the BES with the specified Server ID. Management of BES IDs can be the responsibility of the application. If an application runs more than one BES with the same Server ID then messages with that Server ID can be routed to the BES whose message routing table can contain the most specific match with the messages service type and Message ID. If two BESs can map the same Server ID Service Type and Message ID then as in indirect routing the MR can use round robin scheduling to pick a target BES .

A BES may use both direct and indirect routing on an as needed basis. To illustrate this consider a BES that for the most part is stateless but has one or two logical operations that can require several targeted client server messages to complete. If the BES can initiate an operation that can require a targeted response it can place its Server ID in the intelligent messaging network message header portion of the message it sends to the client application. When the client application responds it uses the same Server ID in the response message to assure that the response is sent to the original Server. All other stateless messages can be sent with a Server ID of 0 so that they can be indirectly routed.

BES messages sent to a client application can pass through the MR . Each MR can decide which PG to which to forward the message. The MR can choose the proper PG based on e.g. the communications type e.g. CDPD Mobitex ISP Dialup etc. used by a subscriber s service provider. The mapping of communication type to client device address can be maintained by the MR based on fixed entries in the MR DB that can map source address of a client device or used ID and password to a specific communication type. Each PG can also indicate the communication type of the PG during the server registration process. If a PG could not deliver a message to the client application the PG can send a network control non acknowledgement NACK message to the BES that originated the message indicating that the message could not be delivered.

When a BES sends a message to a client application in response to a received request message the client device address referred to as its clientDeviceInfo which is a part of the received request message can be known to the BES . In response the BES can provide the clientDeviceInfo as part of the AIMSvrPacket sent to the MR . Consequently the MR can then simply pass this information to the appropriate PG which can then send the message to that client device address.

At times a BES may need to asynchronously send a message to a subscriber e.g. MarketClip Alert . Since this message is not in response to an incoming client message the clientDeviceInfo may not be readily available to the BES . Rather than forcing the BES to keep a mapping between client identifiers and their LinkStationIDs a BES may send a message to a client based solely on the customer ID. In this case the AIMSvrPacket sent to a MR contains a NULL LinkStationID and a valid client ID. The receiving MR can search it s authenticated device cache for an active device associated with the specified client ID and then can use the device s LinkStationID to forward the message to an appropriate PG .

A BES is an application specific server that can implement logic to process messages specific for that type of server. For example an FX BES can handle requests related to foreign exchange functions. A BES can communicate directly with one or more MR . Typically BESs can run behind the firewall . However the intelligent messaging network architecture cannot preclude BESs from running outside the firewall .

Excluding the application logic which may be complex the development effort to implement a BES can be relatively straightforward. The intelligent messaging network Server SDK can encapsulate those functions that are common to all BES thereby insulating developers from e.g. details of transport control compression registering and de registering with the MR DB .

Similar to other servers the BESs can use the registration services provided by the intelligent messaging network server SDK to register themselves with the intelligent messaging network by adding an entry to the RegisteredServers table in the MR DB . Each BES can establish a TCP IP connection with each registered MR using a corresponding IP address. When a BES connects to an MR the MR can add the BES to its RegisteredServers cache and can begin to start forwarding messages to the BES . When de registering itself from the network each of the BESs remove its entry from the RegisteredServers tables in the intelligent messaging network MR database . The BES can notify each MR of its impending shutdown. This can allow each MR to remove the BES from its RegisteredServers cache and can immediately stop forwarding messages to the terminating BES .

In addition to the common services the BESs can be responsible for supporting the following specific functions 

From the perspective of the BES the BES can directly with a client application. In reality however a BES can communicate with one or more MRs . In the intelligent messaging network architecture only the BESs can have knowledge of the application content required to communicate with a client application.

In the exemplary embodiment intelligent messaging network can provide an Adaptive Huffman base compression service. The intelligent messaging network architecture can provide the necessary hooks to enable 3party OEM compression mechanisms. If a BES has specific compression requirements for its application data that are not addressed by intelligent messaging network supplied compression services i.e. Adaptive Huffman the BES can be responsible for providing the compression mechanism.

The architecture can provide the necessary hooks to enable 3party OEM security mechanisms. If a BES has specific security requirements for its application data the BES can be responsible for providing the security mechanism.

When a client message is delivered to the BES the BES can send a network control acknowledgement ACK message to a PG that originally received the message. When the PG receives the network control ACK message from the BES it can send a transport level ACK message to the client device s peer wireless protocol layer indicating that the message was delivered successfully to the BES .

In an exemplary embodiment of the present invention an intelligent messaging network database can use an AIM Database available from Aether Systems of Owings Mills Md. U.S.A. which can maintain a common pool of information between intelligent messaging network servers. This information which is independent of any specific messaging application can be stored and accessed from a SQL database known as e.g. the MR DB or the BES DB . In an exemplary embodiment the MR DB can be shared by all intelligent messaging network servers and . The following sections describe the tables that comprise the intelligent messaging network MR database schema. It will be apparent to those skilled in the art that the schema could also be used for another database such as e.g. BES DB .

The ServiceTypes table is a list of all the service types supported by the intelligent messaging network.

This stored SQL procedure allows customer service to enter a new customer using a wireless CDPD device to the database. User Id and Password are entered as NULL.

Most industry standard browsers support the ability to be configured to access the Internet via a proxy server instead of communicating directly with an HTTP Web Server. The Intelligent messaging network HTTP Proxy Back End Server is responsible for handling incoming HTTP requests sending the request over the Internet to the target Web HTTP Server and transmitting the response back to the client device. The Intelligent messaging network HTTP Proxy Back End Server supports various versions of the HTTP protocol specification. The HTTP Proxy Back End Server is also responsible for communicating with a target HTTP Web Server. In order to handle each inbound HTTP request the HTTP Proxy Back End Server creates and manages a TCP IP socket connection to the target Web HTTP Server. When the HTTP Proxy Back End Server receives the response from the Web HTTP Server it creates an HTTP response message and formats it for transmission back to the client application running on a client device.

Browsers can typically communicate directly to an HTTP Web Server via TCP IP. TCP IP however is a chatty LAN protocol requiring significant overhead that is not a cost effective way for browsing the Internet wirelessly. According to one embodiment of the invention an HTTP Redirector can intercept raw HTTP requests from the browser and can redirect the request over the intelligent messaging network for fulfillment by an HTTP Proxy Back End Server . When the HTTP Redirector receives a response from the HTTP Proxy Back End Server it can simply pass the response to the browser to process.

As mentioned above browsing the Internet using a standard version of a conventional browser is not ideal in a wireless environment. Standard versions of browsers send HTTP requests over TCP IP which is a chatty LAN protocol. TCP IP is not cost effective in terms of bandwidth usage in a wireless environment. Furthermore a standard version of browser can require an IP based network and conventionally does not work with non IP based wireless networks such as Mobitex. The redirector can address these issues and can provide a method of using a standard Web browser in a wireless network.

Referring to in an exemplary embodiment browser of a client device can typically allow access to resources such as e.g. a destination Web server such as an Internet server on a network such as e.g. the global Internet through a Proxy IP port instead of communicating directly with the destination Web server . In the environment of the present invention the Proxy IP port can fulfill a request on behalf of the client device to the destination Web server . The redirector can act as a client side proxy. The HTTP Redirector can sit on top of standard mobile libraries provided by the intelligent messaging network. These mobile libraries can be optimized for the specific wireless protocol supported by the specific client device 

The HTTP Redirector can intercept all requests from browser . The raw HTTP request can then be packaged into an intelligent messaging network message and transmitted through the intelligent messaging network to the BES designed to handle HTTP requests.

The HTTP BES can forward the request to a Web server of a content provider such as e.g. destination web server which can provide a response. The content provider can be a third party in an exemplary embodiment. The communication to the content provider can occur via the network of . A network depicted in can include the intelligent messaging network of the present invention e.g. the underlying LAN network and the PGs the firewall router and the MR .

When the HBES receives the response from the destination Web server HBES or BES not shown can package the response into an intelligent messaging network message and can transmit the response back to the requesting client device via the PG via the MR .

When the message arrives at the client device it can be passed up to the redirector where the message can be unpacked from its intelligent messaging network format into an HTTP response and can be sent to the browser . The HTTP redirector can maintain all connections with the browser throughout this process so that from the perspective of the browser the browser appears to be communicating directly to the Web server .

The mobile libraries can be optimized for the underlying wireless protocol. The HTTP Redirector can sit on top of the libraries providing the browser with the same benefits without any modifications to the browser . Since the HTTP Redirector packages HTTP requests and responses into intelligent messaging network messages the raw payload of the messages can be compressed. Most conventional Web traffic deals with straight text in the form of HTML so the amount of data transmitted can be greatly reduced by using standard compression techniques. The compression techniques can result in an increase in data throughput and a reduction of airtime.

In addition to compression in an exemplary embodiment performance can be enhanced by the fact that TCP IP is not used over the wireless network where the SNTL transport protocol of the present invention is rather used.

Turning briefly to an exemplary embodiment of a network communications layered architecture is depicted. includes block diagram which is described further below following the description with reference to .

The flow of any messages within the network can include authentication by the MR via authentication challenge success failures client application request to BES BES response to client application and BES alert to client application.

In step the simple network transport layer SNTL application can segment the message into multiple segments can encapsulate the segments with an SNTL segment header and can transmit the message initially to PG . An exemplary embodiment of a message header is illustrated below with reference to . As will be apparent to those skilled in the relevant art due to a high bit error rate in wireless communication links it can be expected that not all transmissions to PG will be received from the client device . From step the flow diagram can continue with step .

In step the PG can send to client device an acknowledgement ACK of receipt of the transmitted messages at the PG . As shown in the exemplary embodiment receipt of only segment is acknowledged. Receipt of segment is not acknowledged. From step the flow diagram can continue with step .

In step in an exemplary embodiment client device can automatically retry or retransmit segment of the message to the PG since acknowledgement was not received for segment in step . User datagram protocol UDP is an efficient communication protocol however it is unreliable lacking provision to segment messages and retransmit unacknowledged messages. In the exemplary embodiment the peer protocols of the SNTL layers on the client device and PG can work in coordination with UDP to provide highly optimized and reliable wireless communication while using efficient connectionless i.e. unlike TCP UDP communication. In an exemplary embodiment the SNTL layers can provide other useful transport functions such as e.g. pacing congestion control and other functionality without requiring an entire TCP transport stack. The SNTL layer can include in an exemplary embodiment a 4 bytes wide header 6 bytes wide for multi segment messages as discussed with reference to . From step flow diagram can continue with step .

In step PG can transmit the complete multi segment message to MR . From step flow diagram can continue with step .

In step MR can route the message to BES as discussed above with reference to . From step flow diagram can continue with step .

In step BES can send an acknowledgement of receipt of the multi segment message to MR . From step flow diagram can continue with step .

In step MR can send acknowledgement of receipt of the multi segment message at the BES on to PG . From step flow diagram can continue with step .

In step BES can transmit a multi segment message intended for a client device to MR . From step flow diagram can continue with step .

In step the simple network transport layer SNTL application running on the PG can segment the message into multiple segments can encapsulate the segments with an SNTL segment header and can transmit the segments of the message to the client device . An exemplary embodiment of a message header is illustrated below with reference to . As will be apparent to those skilled in the relevant art due to a high bit error rate in wireless communication links it can be expected that potentially not all transmissions from PG will be received at the client device . From step the flow diagram can continue with step .

In step client device can send to the PG an acknowledgement ACK of receipt of the transmitted messages at the client device . As shown in the exemplary embodiment receipt of only segment is acknowledged. Receipt of segment is not acknowledged. From step the flow diagram can continue with step .

In step in an exemplary embodiment PG can automatically retry or retransmit segment of the message to the client device since acknowledgement of receipt was not received for segment in step . From step flow diagram can continue with step .

In step client device can transmit the complete multi segment message to PG . From step flow diagram can continue with step .

In step PG can send an acknowledgement of receipt of the multi segment message to MR . From step flow diagram can continue with step .

In step MR can send acknowledgement of receipt of the multi segment message at the client on to the BES . From step flow diagram can immediately end.

The flow diagram can be used in one exemplary embodiment to send a response from BES to a request originating from client . In another exemplary embodiment flow diagram can be used to generate an unsolicited response also commonly referred to as an alert or a push. It is important to note that acknowledgement of receipt of a response message as shown for example in flow diagram is optional. For example in the case of some client devices such as e.g. with some paging devices it may be impossible to send back from the client devices an acknowledgment.

In step BES can send a hybrid alert message to MR for a client user who can have multiple client devices . In an exemplary embodiment the hybrid alert can include XML query conditions. The query can query e.g. the MR DB to determine the status of particular conditions. For example the client user could have multiple devices and the client user s client record can indicate that redundant alerts should be sent to all devices at once. Alternatively the client user s client record could indicate e.g. that a message should be sent to a primary or highest priority device first and if the BES receives no acknowledgement of receipt of the message from the primary device then a message can be sent to a secondary or lower priority device and so on in the event that the client user has multiple client devices. From step flow diagram can continue with step or

In an exemplary embodiment the MR can route the hybrid alert message to any of client devices that match the query conditions. In one exemplary embodiment the hybrid alert message can be sent to all devices . Suppose the criterion are such that the hybrid alert is to be sent to both client devices and . The hybrid alerts can be sent in parallel or sequentially.

In step PG can route the hybrid alert message to client device . From step flow diagram can continue with step

In step PG can route the hybrid alert message to client device . From step flow diagram can continue with step

In step in one embodiment client device can send back to PG a message acknowledging receipt of the hybrid alert message. Acknowledgment of receipt of an alert can be optional. From step flow diagram can continue with step

In step in one embodiment client device can send back to PG a message acknowledging receipt of the hybrid alert message. Acknowledgment of receipt of an alert can be optional. From step flow diagram can continue with step

In step in an exemplary embodiment the PG can forward on the acknowledgement of receipt at the client device to MR . From step flow diagram can continue with step

In step in an exemplary embodiment the PG can forward on the acknowledgement of receipt at the client device to MR . From step flow diagram can continue with step

In step BES can attempt to send an alert to MR intended for client device . From step flow diagram can continue with step .

In step MR can route the alert to a PG associated with client device . From step flow diagram can continue with step .

In step according to the exemplary embodiment suppose client device is unavailable to receive and thus a negative acknowledgement of receipt NACK can be sent to MR . In one embodiment the PG can be aware that an alternate path can be available i.e. that another client device with which the BES can communicate. From step flow diagram can continue with step .

In step the negative acknowledgement NACK of receipt at client device can be forwarded on from the MR to BES . BES can be notified in the NACK in one embodiment that the BES can send the alert using a hybrid alert such as e.g. that depicted in flow diagram of to reach the client user using client device not shown in .

In step the client device can send a request message to a PG . From step flow diagram can continue with step .

In step BES can send a response message intended for client device to MR . From step flow diagram can continue with step .

In step MR can route the response message to a PG associated with intended recipient client device . From step flow diagram can continue with step .

In step suppose that the PG determines that client device is unavailable to receive a message so a negative acknowledgment of receipt of the response message at the client device can be sent to MR . From step flow diagram can continue with step .

In step MR can forward on the NACK message to BES notifying BES that the response message was not received by client device . In an exemplary embodiment BES can be notified that the client user can be reached using another client device . BES can be notified in the NACK that the BES can send the response message using a hybrid alert such as e.g. that depicted in flow diagram of to reach the client user using client device not shown in . VII. Software Development Kits

The Mobile client SDK is comprised of the following set of platform specific libraries. Each of the following exemplary libraries exports an easy to use API 

An exemplary embodiment of the invention includes a utility library providing compression services. By keeping the transport library independent from both the utility and security implementation details new compression and security mechanisms can be added without the knowledge of the transport library. The independence eliminates the need to regression test the transport library as well as all application users of the transport library when adding a new compression or security mechanism. Because the compression and security solutions may not meet the need for all intelligent messaging network enabled applications when new applications are developed any specific compression or security requirements of such applications may be accommodated transparent to the transport library individually on a component basis. By providing wrapper APIs that encapsulate the default implementation of the utility and or security libraries developers could choose to write to the wrapper APIs or directly to the utility and or security APIs.

The utility library of the intelligent messaging network can provide applications with functions to perform via an easy to use API. The following section summarizes the major functions provided by the utility library.

Provides functions to assist developers with handling application messages that are streaming in and out two ways . Serial in and out functions are provided for most of the common data types supported by the target platform. The streaming functions manage the big endian little endian issues on behalf of the application.

Applications can optionally compress encode application messages prior to transmitting the message to a target destination. If the encode algorithm determines that it is not optimal to encode the message the message is not encoded. Also applications can optionally decode application messages prior to processing the message. In order to determine if a message needs to be decoded applications can check the encode flag contained in the message header.

Every application message is pre fixed with the intelligent messaging network message header prior to being sent to its target destination. The intelligent messaging network utility library provides applications with functions to set get the contents of the intelligent messaging network message header. It also provides functions to serial out and serial in the contents of the intelligent messaging network message header. Applications are not required to know the internal data representation of the intelligent messaging network message header.

In order to access the intelligent messaging network via an ISP dialup connection the intelligent messaging network requires that the user provide security credentials to identify themselves. The intelligent messaging network utility library provides functions to build the intelligent messaging network authentication request message. Applications are not required to know the internal data representation of the intelligent messaging network authentication request message likewise for the intelligent messaging network authentication response message. Functions are provided to determine the authentication status of the request.

The transport library provides reliable optimized data communication over various wireless networks such as the CDPD and Mobitex wireless networks as well as ISP dialup wire line access to enabled the intelligent messaging network client applications via an easy to use API. The following section summarizes the major functions provided by the mobile client transport library.

A layered architecture can be used for developing the transport library. Under this arrangement each layer excluding the bottom can encompass certain functions can request services from the layer directly below it and each layer excluding the top can provide services to the layer directly above it. In order for a layer to do the job it is assigned to perform layer N employs the services of layer N 1. The division of the network into logical layers can allow a higher level to make use of the more primitive functions of lower levels without having the layer concern itself with the implementation details of those primitives.

The function of application layer layer 7 of the OSI stack is to provide an interface between the application and the transport protocol layer by which client applications can send and receive messages across multiple wireless networks or via dial up ISP access without having knowledge of the communication implementation.

In an exemplary embodiment of the present invention layers 4 can include e.g. applications such as e.g mail file transfer and other applications such as e.g. end user applications.

This layer logically represents layer 4 of the reference model for the present invention. This layer provides the control structure for managing the communications between two communicating peer transport layers. The following sections detail the functions provided by this protocol layer.

The highest layer is the application layer. Layer 4 is the transport layer and in an exemplary embodiment includes a connectionless UDP like transport protocol that has many of the features and advantages of TCP. That is the transport layer is connectionless like UDP but has many of the features of TCP including but not limited to message segmentation message segment reassembly message retries and message duplication but has only a four to six byte header.

In an exemplary embodiment of the present invention layers 4 can include e.g. the simple network transport layer SNTL protocol of the present invention.

The network layer layer 3 such as e.g. the Internet Protocol IP layer is responsible for providing network protocol layer functionality and hiding the details of this functionality from the transport layer. Below the network protocol layer is the data link protocol layer layer 2 and finally the physical protocol layer which handles modulation and radio transmission.

In an exemplary embodiment of the present invention layers 1 and 2 can include any of e.g. the PSTN CDPD Mobitex Ardis GPRS and other and future protocols and GSM

All messages to be sent over the network that exceed the maximum segment size configurable are segmented into multiple message segments. The segment size is configured prior to the client application opening the transport library. The default maximum segment size is 512 bytes.

A transport header is prefixed to every outbound message segment. The transport header is encoded in network byte order. It is the sole responsibility of the application to encode any application specific data in network byte order prior to calling the AeTransportSend interface function. The diagram below details the transport header fields.

The transport protocol layer retains knowledge of all outstanding message segments pending acknowledgment message segments that have not been acknowledged by the peer wireless protocol layer via a pending acknowledgment queue. The pending acknowledgment queue maintains information pertaining to message segments that have been successfully transmitted and are pending acknowledgment from the peer wireless protocol layer. If an acknowledgment positive or negative is received for a message segment that is not pending acknowledgment the ACK is discarded and conditionally logged.

When all message segments have been positively acknowledged by the peer wireless protocol layer the application is notified if requested with a message type of AIM ACK MESSAGE and the message ID value associated with the sent message. If the number of transmission attempts for the message segment has exceeded the configured number of retry attempts the application is notified with a message type of AIM NACK MESSAGE the message ID value associated with the sent message and the 2 byte error code containing the reason why the message was not delivered. In order to re send a message that has been negatively acknowledged the application calls a AeTransportSend interface function.

All message segments not acknowledged by the peer wireless protocol layer within the configured time are automatically re transmitted. The time to wait for an acknowledgment from the peer wireless protocol layer is configured prior to the client application opening the transport library. The default time to wait for an acknowledgment from the peer wireless protocol layer can for example be 15 seconds.

The transport protocol layer retries the configured number of times before notifying the application that the message could not be delivered negative acknowledgment . The number of times to retry is configured prior to the client application opening the transport library. The default number of retry attempts is 3.

All incoming message segments received including duplicate segments are immediately acknowledged back to the peer wireless protocol layer and are queued pending receipt of all message segments via the inbound message queues. The incoming message queues manages a separate inbound message queue for each different LinkStationID of the sender.

When all message segments have been received for a message the segments are assembled into a complete message. If the message ID of the assembled message has been already received duplicate message the message is discarded and conditionally logged. This layer keeps track of the last n message IDs received for each unique LinkStationID. The number of message IDs to contain in the message look back queue is configured prior to the client application calling AeTransportOpen to open the transport library. The default number of message IDs to maintain in the message look back queue may be set to 10 for example.

The exemplary message header of includes segment number field which can be used to identify the segment number of a multi segment message. For multiple segment messages an additional field not shown can be used to identify the total number of segments in a message. In an exemplary embodiment the total number of segments field could be 2 bytes wide. Advantageously according to an exemplary embodiment of the present invention the simple network transport layer SNTL can use the information in the total number of segments field to determine which segments of the total number sent were received as acknowledged or are required to be retransmitted. The reader is directed to above illustrating transmitting a multi segment message and retrying where a segment is not acknowledged.

The security library provides encryption and decryption services to the intelligent messaging network enabled applications via an easy to use API. The initial security mechanism is based on Certicon s implementation. The following section summarizes the major functions provided by the security library.

The Intelligent messaging network provides a server SDK environment to assist engineers developing PGs and BESs . The server SDK is comprised of an easy to use C API and a set of Windows NT 4.0 libraries. The SDK can be logically divided into the following two categories of classes 

The AeServer class is the base class for all of the other Server classes and encapsulates those functions that are common to all Servers. These include 

All the intelligent messaging network developed PGs are derived from the AeFEServer class. Derived PGs provide the following functions 

The server user interface class hierarchy parallels the Server class hierarchy and provides the following types of functionality 

AeServerApp is the base class for all of the other Server GUI apps. All Server applications are complete windows based executable programs. AeServerApp expects its subclasses to provide it with an instance of an AeServer subclass. Of the five areas of functionality listed above AeServerApp provides the following 

AeFEServerApp is derived from AeServerApp and provides the following additional user interface features 

These classes provide a standard GUI for BESs . Both are derived from AeServerApp and both provide the same set of user interface features. CBEServerSampleApp came first and was actually written before there was an AeServerApp although the current version derives from AeServerApp . The difference between the two classes is that CBEServerSampleApp also derives from AeBEServer while AeBEServerApp has a AeBEServerApp member inheritance vs aggregation . Other than that the two classes provide the same set of features 

In a well known manner intelligent messaging network can also provide tools that work in conjunction with the Microsoft Visual Developer Studio framework. These tools assist engineers developing client and BES applications as well as stress test and monitor the health of the intelligent messaging network.

The Intelligent messaging network Message Wizard makes it easy for developers to define their application specific data content of the intelligent messaging network messages. The wizard makes it easier for the developer to focus on adding business value to their application instead of having to worry about the tedious and error prone task of writing the serialization code to transfer message content between server and client. It also automatically generates the code needed to serialize the message content between a client application and a BES application.

The BES App Wizard can make it easy for developers to create BES applications. The BES App Wizard generates the Visual Studio C project and its associated program and header files to create a BES executable. BES developers would then need to add program logic to support their application protocol.

In order to assist engineers developing a BES Ping application the intelligent messaging network Ping App Wizard makes it easy for developers to create a Ping BES executable. The Ping App Wizard generates the Visual Studio C project and its associated program and header files to send an application defined heart beat message to a BES . BES developers may want to use this tool as a way to monitor the health of their BES .

In order to assist engineers developing BES the intelligent messaging network can also provide a client simulation application. Developers can use the client simulation application to simulate multiple clients and to generate BES specific message traffic. The client simulation application supports the following major functions 

From the forgoing description it may be appreciated that the present invention provides protection against technology obsolescence by supporting seamless integration of information sources with multiple wireless networks and client devices. As such the invention provides a reliable method of data transfer while optimizing bandwidth constraint of wireless data services and providing end to end security. This invention allows for system growth by incorporating the new devices and wireless network technologies as they become available without the need to modify client and server applications.

The above described environment which has a messaging base architecture serves as the framework for implementation of the invention. This environment can provide client server connectivity which can provide an enabling mechanism for application network connection connectivity. The architecture can support messaging. Platform transparency can be provided enabling platform independence of client devices . Network transparency can be provided by an enabling mechanism for network independence by hiding the underlining network protocol. The SDK can provide an easy to use developers tool kit and environment for the design development of each aspect of the application the client device and server.

While various exemplary embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

