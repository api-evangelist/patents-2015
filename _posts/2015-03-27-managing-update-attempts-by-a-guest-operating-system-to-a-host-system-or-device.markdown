---

title: Managing update attempts by a guest operating system to a host system or device
abstract: Attempts to update confirmation information or firmware for a hardware device can be monitored using a secure counter that is configured to monotonically adjust a current value of the secure counter for each update or update attempt. The value of the counter can be determined every time the validity of the firmware is confirmed, and this value can be stored to a secure location. At subsequent times, such as during a boot process, the actual value of the counter can be determined and compared with the expected value. If the values do not match, such that the firmware may be in an unexpected state, an action can be taken, such as to prevent access to, or isolate, the hardware until such time as the firmware can be validated or updated to an expected state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09349010&OS=09349010&RS=09349010
owner: Amazon Technologies, Inc.
number: 09349010
owner_city: Reno
owner_country: US
publication_date: 20150327
---
This application is a continuation of U.S. application Ser. No. 14 094 642 entitled Managing Firmware Update Attempts filed Dec. 3 2013 and issuing as U.S. Pat. No. 8 996 744 which is a continuation of U.S. patent application Ser. No. 12 555 455 entitled Managing Firmware Update Attempts filed Sep. 8 2009 and issuing as U.S. Pat. No. 8 601 170 each of which is incorporated herein by reference for all purposes.

As an increasing number of applications and services are being made available over networks such as the Internet an increasing number of content application and or service providers are turning to technologies such as cloud computing. Cloud computing in general is an approach to providing access to electronic resources through services such as Web services where the hardware and or software used to support those services is dynamically scalable to meet the needs of the services at any given time. A user or customer typically will rent lease or otherwise pay for access to resources through the cloud and thus does not have to purchase and maintain the hardware and or software needed for such resources.

In some cases users may want special hardware or full access to specific resources. Such access comes with risks for providers of those resources however as in a cloud or other shared environment there typically will be other users sharing those resources at various times and a modification of the resource by one user can potentially be detrimental to subsequent users. In order to ensure that one user does not alter the hardware software or configuration information in an inappropriate way that will affect other users such as by altering firmware to inject malicious code it can be necessary to re image the resource after each user. Such an approach might be acceptable in situations where users have dedicated access to a resource for an extended period of time but in a cloud or similar environment where the user of a resource could change several times over a short period of time such an approach can be too expensive and resource intensive. Further in order to determine whether the firmware has been altered it can be necessary to validate the firmware before provisioning a new user which can be a time intensive process that consumes resources that could be dedicated to other tasks.

Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more of the aforementioned and other deficiencies experienced in conventional approaches to managing resources in an electronic environment. In various embodiments users are provided with full or substantially full or native access to one or more hardware resources in a network cloud or other shared environment. In other embodiments users have access to only one or more devices or components such as a network interface card NIC or graphics processing unit GPU on a peripheral component interconnect PCI bus on a host machine. In a situation where the users having access to such a resource can change frequently it can be desirable to prevent users from modifying or at least track the modifying of firmware or other configuration information for the resource which can affect an ability of a subsequent user to effectively or securely utilize the resource.

In some embodiments at least one secure monotonic counter is implemented that is configured to monotonically update a current value upon each update or attempted update of firmware or other configuration information for a hardware device. Such a counter thus can either increment or decrement by one count or other such value for each update or attempted update. For a host machine that includes a number of hardware components such as peripheral devices for example there can be one counter for the host one for the set of peripheral devices a counter for each individual device or any other appropriate combination implemented in hardware and or software. Each time a valid state of firmware or configuration information for a device is verified the current value of the corresponding counter can be determined and stored in a secure location. At a subsequent time such as during a boot process or prior to the provisioning of a new user the actual value of the counter can be compared with the expected value that is stored securely and inaccessible to guest users of the host. If the numbers match the firmware has likely not been modified as any update would have incremented or decremented the counter and the processes on the host can continue. If the numbers do not match then the firmware or other configuration information may have been changed or otherwise compromised at which point one or more actions can be taken. In some embodiments this can include isolating the host and provisioning the user on other hardware. In other embodiments this can include setting a flag that indicates the firmware is to be validated or flashed before provisioning a new user on the hardware. Any of a number of other such remedial actions can be taken as well as described herein. Such an approach can be desirable in a number of situations as a quick determination can be made as to whether firmware or other such information might have been compromised and it can be much easier to detect that something has changed than to attempt to prevent all mechanisms for making the change in the first place.

In embodiments where a host machine hardware device or group of machines and or devices include multiple secure counters a current value of these counters can be aggregated using what is referred to herein as a master counter. In one embodiment the value of the master counter can be incremented each time one of the respective counters is incremented. In another embodiment the master counter is computed perhaps upon request as the bitwise concatenation of the individual counters. Other embodiments or combinations thereof can be constructed depending on various security and hardware design criteria as long as the master counter preserves the monotonic quality. Where the master counter aggregates values of the individual counters each counter can be configured to count monotonically in the same direction e.g. each counter increases or decreases the count upon an update or update attempt such that the aggregated value accurately represents a current state of the system. The current value of the master counter can be compared to an expected value for the master counter and if the numbers match then it can quickly be determined that the configuration information e.g. firmware for all monitored devices is in the expected state. For example a technician might verify the current value of a master counter as displayed on the outside of a server rack where the master counter reflects the state of the configuration information for each host switch and or device in that rack. The technician then can quickly verify whether the components of the rack are in an expected state or whether further investigation is needed to determine which configuration information may have changed. The counter information can be aggregated using a secure channel that is inaccessible to the user and the information can be aggregated to a master counter internal or external to the monitored component s .

The illustrative environment includes at least one application server and a plurality of resources servers hosts instances routers switches data stores and or other such components defining what will be referred to herein as a data plane although it should be understood that resources of this plane are not limited to storing and providing access to data. It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides admission control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HTML XML or another appropriate structured language in this example. In some embodiments the Web server application server and similar components can be considered to be part of the data plane. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code can be executed on any appropriate device or host machine as discussed elsewhere herein.

The environment also includes a development and or testing side which includes a user device allowing a user such as a developer data administrator or tester to access the system. The user device can be any appropriate device or machine such as is described above with respect to the client device . The environment also includes a development server which functions similar to the application server but typically runs code during development and testing before the code is deployed and executed on the production side and is accessible to outside users for example. In some embodiments an application server can function as a development server and separate production and testing storage may not be used.

The data stores of the data plane can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data plane illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data plane also is shown to include a mechanism for storing testing data which can be used with the user information for the testing side. It should be understood that there can be many other aspects that may need to be stored in a data store such as for page image information and access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data plane . The data plane is operable through logic associated therewith to receive instructions from the application server or development server and obtain update or otherwise process data instructions or other such information in response thereto. In one example a user might submit a search request for a certain type of item. In this case components of the data plane might access the user information to verify the identity of the user and access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable medium storing instructions that when executed by a processor of the server enable the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

An environment such as that illustrated in can be useful for various content providers or other such entities wherein multiple hosts and various types of resources might be used to perform tasks such as serving content authenticating users allocating resources or performing any of a number of other such tasks. Some of these hosts may be configured to offer similar functionality while other servers might be configured to perform at least some different functions. The electronic environment in such cases might include additional components and or other arrangements such as those illustrated in the configuration of discussed in detail below.

Systems and methods in accordance with one embodiment provide at least one resource access gateway or control plane either as part of the data environment or in a path between the user and the data plane that enables users and applications to access shared and or dedicated resources while allowing customers administrators or other authorized users to allocate resources to various users clients or applications and ensure adherence to those allocations. Such functionality enables a user to perform tasks such as storing processing and querying relational data sets in a cloud without worry about latency degradation or other such issues due to other users sharing the resource. Such functionality also enables guest users to obtain access to resources to perform any appropriate functionality such as to render and or serve streaming media or perform any of a number of other such operations. While this example is discussed with respect to the Internet Web services and Internet based technology it should be understood that aspects of the various embodiments can be used with any appropriate resources or services available or offered over a network in an electronic environment. Further while various examples are presented with respect to shared access to disk data storage hosts and peripheral devices it should be understood that any appropriate resource can be used within the scope of the various embodiments for any appropriate purpose and any appropriate parameter can be monitored and used to adjust access or usage of such a resource by any or all of the respective users.

A resource gateway or control plane can be used in some environments to provide and or manage access to various resources in the data plane . In a cloud computing environment this can correspond to a cloud manager or similar system that manages access to the various resources in the cloud. In one embodiment a set of application programming interfaces APIs or other such interfaces are provided that allow a user or customer to make requests for access to various resources. Once access is established a resource is allocated etc. a user can communicate directly with the resource to perform certain tasks relating to that resource such as data storage or processing. The user can use direct interfaces or APIs to communicate with the data instances hosts or other resources once access is established but uses the control plane component s to obtain the access.

The control plane can include one or more resource allocation managers each responsible for tasks such as validating the user or client associated with the request and obtaining or allocating access to the appropriate resource s . Such a system can handle various types of request and establish various types of connection. Such a system also can handle requests for various types of resources such as specific graphic processors or other types of hardware or hardware functionality and can provide access to the appropriate resource s . Components of the data plane or the resource layer of the cloud can perform the necessary tasks to provide the resource. For access to a data instance for example this can include tasks such as provisioning a data store instance allocating a volume of off instance persistent storage attaching the persistent storage volume to the data store instance and allocating and attaching a DNS address or other address port interface or identifier which the customer can use to access or otherwise connect to the data instance. For tasks such as obtaining processing of an instruction using a particular type of hardware for example the components of the data plane in conjunction with the control plane can perform actions such as provisioning a device for a user and providing shared and or dedicated access to the resource for a period of time at a particular level of access to the resource. In this example a user can be provided with the DNS address and a port address to be used to access a resource. A user then can access the resource directly using the DNS address and port without having to access or go through the control plane .

The control plane in this embodiment also includes at least one monitoring component . When a data instance or other resource is allocated created or otherwise made available in the data plane information for the resource can be written to a data store accessible to the control plane such as a monitoring data store . It should be understood that the monitoring data store can be a separate data store or a portion of another data store. A monitoring component can access the information in the monitoring data store to determine information such as the past usage of resources by various users a current number or type of threads or resources being allocated to a user and other such usage information. A monitoring component also can call into components of the data environment to determine information such as the number of active connections for a given user in the data environment and aspects about the usage of each connection. A monitoring component can constantly monitor the usage of each resource by a user client etc. having an allocation provided through the connection manager. A monitoring component also can access information stored in an administrative Admin or similar data store which can store information such as the general allocation granted to a user throttling or limiting information for a user resource permissions for a user or any other such information that can be specified and or updated by an administrator or other such user.

In an example where users request connections to various data instances each instance in the data environment can include at least one data store and a host manager component for the machine providing access to the data store. A host manager in one embodiment is an application or software agent executing on an instance and or application server such as a Tomcat or Java application server programmed to manage tasks such as software deployment and data store operations as well as monitoring a state of the data store and or the respective instance. A host manager can be responsible for managing and or performing tasks such as setting up the instances for a new repository including setting up logical volumes and file systems installing database binaries and seeds and starting or stopping the repository. A host manager can monitor the health of the data store monitoring the data store for error conditions such as I O errors or data storage errors and can restart the data store if necessary. A host manager can also perform and or manage the installation of software patches and upgrades for the data store and or operating system. A host manager also can collect relevant metrics such as may relate to CPU memory and I O usage.

The resource manager can communicate periodically with each host manager for which a connection has been established or to an administration server or other component of the resource environment to determine status information such as load usage capacity etc.

As discussed once a resource is provisioned and a user is provided with an IP address derived from DNS mappings or other address or location the user can communicate directly with components or resources of the data plane through the network using a Java Database Connectivity JDBC or other such protocol to directly interact with that resource . In various embodiments as discussed the data plane takes the form of or at least includes or is part of a computing cloud environment or a set of Web services and resources that provides data storage and access across a cloud or dynamic network of hardware and or software components. An IP address derived from DNS mappings is beneficial in such a dynamic cloud environment as instance or availability failures for example can be masked by programmatically remapping the IP address to any appropriate replacement instance for a use. A request received from a user or application for example can be directed to a network address translation NAT router or other appropriate component which can direct the request to the actual resource or host corresponding to the mapped address of the request. Such an approach allows for instances to be dynamically moved updated replicated etc. without requiring the user or application to change the IP address or other address used to access the instance. In some cases a resource such as a data instance can have at least one backup instance or copy in persistent storage.

As discussed a resource can be shared among multiple users clients applications etc. either concurrently or at different times with varying levels of access or allocation. When a user has dedicated access to a machine or resource the user might also have native or bare metal access to the resource for a period of time depending on the type of access needed and other such factors. Providing this level of access to a resource comes with potential risks for a provider of the resource as a user having native access to the device can have the ability to modify firmware or other configuration information for the resource which can affect the ability of a subsequent user to utilize the resource without first re imaging or otherwise verifying the state of the resource.

Systems and methods in accordance with various embodiments enable a provider to grant a user or customer with substantially full access to a hardware resource with a reasonable level of security. This native level access to remote hardware can be provided for resources such as servers hosts and cluster instances for example. For resources such as cluster instances customers may have native access to a subset of the hardware resources such as may include peripheral devices connected using a component such as a peripheral component interconnect PCI bus. These peripheral devices can include network interface cards NICs graphics processing units GPUs and similar devices that would often be virtualized in a current cloud environment. In the some cases a customer might have full access to an entire machine or groups of machines including any or all devices incorporated therein. For a group of machines such as a rack of servers a user might be granted substantially full access to the entire rack including any switches or other devices or components provided as part of the rack.

Certain providers present such hardware resources as a virtualized abstraction such that management of the physical hardware can occur in a more trustworthy execution context and can provide additional benefits such as the ability to migrate customers to different resources without interrupting execution and since customers or guests are not tied to specific hardware the ability for vendors to compete to provide the best utility computing value for price. Also fewer and more simple guest instance images can be used as guests do not need a multitude of hardware specific drivers. Such virtualization can come with potentially significant costs however as virtualization can incur order of magnitude performance penalties for hardware that does not include native acceleration for virtualization and virtualization of a particular hardware device can consume substantial resources unrelated to that device e.g. a processor and or memory used to virtualize a network interface . Also virtualization support can lag years behind commodity availability of new hardware e.g. video cards and certain appliance hardware is often too specific or niche to ever warrant compelling virtualization support. There are potentially large market opportunities in supporting high margin niche appliances or in being the first to market for cloud support of new hardware types. Providing such support through native access however can leave vulnerable various aspects of the internal cloud such as provisioning technology billing resource utilization and balancing and the network layer 2 layout for example and can violate threat models well beyond customer requirements.

Systems and methods in accordance with various embodiments can provide for partial or substantially full access to a resource such as a host server by providing users with native access to the host hardware or specific devices such as cards plugged into a peripheral control bus or similar datapath. In certain embodiments where specific levels of performance are an issue technology such as an input output memory management unit I O MMU can be used to assign peripheral devices to guest operating systems e.g. virtualization technology for directed I O Intel s VT D effectively giving guests native access to only those peripheral devices. As should be apparent to one of ordinary skill in the art a guest operating system OS can refer to different systems in different embodiments such as a virtual machine hosting a running OS with at least partial non virtualized access to some hardware or machine state that the OS or hypervisor depends upon including BIOS configuration etc. that is not under the administrative control of the hosting provider. In other embodiments the guest OS might refer to an OS that is not under the administrative control of the hosting provider running without full virtualization. In one embodiment an MMU can logically connect a direct memory access DMA capable I O bus e.g. a PCI bus to main memory on a host and can manage mapping of I O devices to physical addresses to regulate the flow of information from a guest to various PCI or similar devices. These devices can include for example graphics processing unit GPU co processors high performance NICs disk controllers or other niche co processing devices such as cryptographic cards or hardware codecs. In some instances virtualization or other such technology can be used to provide a level of separation between guests and host machines from the central system hardware e.g. CPU memory etc with native access potentially being available for specific devices on a given host. In other embodiments native access can be provided to any hardware included in or available for a specific host.

One of the main issues with providing customers with native access to specific hardware is that customers may have the ability to modify privileged configuration or BIOS basic I O system settings or other firmware images on host hardware. These changes can persist across a reboot of the physical system such that the hardware may not return to the same state that the hardware was in before that customer was granted access to the device s . In the case of configurable settings for a virtual machine monitor VMM such as a Ring 1 hypervisor for example the changes would in general not persist across reboot but could persist across instantiations of guest operating systems in a virtualized environment e.g. chipset settings to support IOMMU technology . This ability for a customer to modify settings or firmware that otherwise should be immutable can have serious security implications. For example malicious software e.g. Trojans or viruses can be inserted into firmware for various devices. Even if firmware changes do not involve intentionally malicious programming however the changes still can still be unintentionally damaging by causing performance and or compatibility issues. Firmware flashing can potentially physically destroy the hardware irreparably a.k.a. bricking the hardware . Certain technologies have been developed that may address at least some of these challenges particularly for motherboard chipsets. These technologies include for example Trusted Platform Module TPM LaGrande Technology LT from Intel measured boot technology trusted boot technology Dynamic Root of Trust DRTM and Static Root of Trust SRTM technology. None of these solutions however address various issues specific to device firmware entire hosts and other such hardware aspects.

Systems and methods in accordance with various embodiments can prevent and or monitor the access and or manipulation of configuration or firmware information by guests in a cloud or similar electronic environment. In certain embodiments a customer can be provided with dedicated guest access to a hardware resource for any desired period of time such as a matter of hours or even minutes. illustrates an example of a configuration that can be used to provide such native access to a customer in accordance with one embodiment. This example will be discussed with respect to granting a user access to a peripheral device in a host machine using conventional PCI based technology but it should be understood that this is merely an example and that approaches within the scope of the various embodiments can be used with any appropriate hardware software and protocols currently used or subsequently developed for such purposes.

This example configuration includes a set of host devices such as servers or similar devices that each can have a series of network ports . Some of these ports can function as production ports which connect each host to at least one smart network switch capable of processing and routing network traffic to from each device. In a data center example there might be one smart switch for each rack of servers for example. At least one of these network ports can be used by a guest operating system for a host where the guest is effectively operating on top of at least one central processing unit CPU in the allocated or partitioned host device e.g. server that has access to this production network port. The host device also can have at least one console port and a console controller which can connect to a separate console network . In some embodiments at least some of these ports can be merged but logically separated e.g. muxed on the same physical port . Each host device also can have one or more dedicated power supply units PSUs which can be accessed by the console controller and or the main CPU whereby the machine can be powered off via either the host CPU or a device on the network for example. The power supply for every server in a rack can be connected to a rack power distribution unit PDU which can be connected by a higher power cable to one or more data center PDUs each of which can support multiple rack PDUs. In some cases the hosts can be powered on and off by running a line to the console controller from the rack PDU with relays or other such components to power cycle each device.

At least one router can connect the host devices to one or more provisioning systems and the switch and or router can manage access to these provisioning systems. In some embodiments network traffic within a rack is aggregated in order to minimize the number of cables leaving each rack. In some embodiments a capability such as a preboot execution environment PXE exists on a host machine at the production network port such that power can be cycled using the console and when the machine boots the PXE code can execute on the network port. When the switch is configured to connect a host machine to the provisioning systems the PXE can connect the device to the provisioning systems and boot the machine into a RAM random access memory disk or other block of storage for example which enables control operations such as firmware flashing or provisioning of a new customer image. A RAM disk with specialized drivers in one embodiment can be used to boot and or run an untrusted or unknown image which might not otherwise be able to boot on a specific machine. Provisioning images thus can be received over the network to the PXE which contain provisioning code or firmware flashing code. Once provisioning is completed authorized customer networks can interact with the devices via the switch . The provisioning and control systems can control the switch in real time with no humans involved as the automatic switching of that path can be based on provisioning events and external coordination for example. The coordination can be provided and or managed by an external system such as a cloud manager database and system or other such control plane or control system as discussed elsewhere herein which can instruct the provisioning system s console network and rack components to perform certain actions. The cloud manager can include one or more workflow systems that work with a central database in one embodiment to perform various aspects of resource management.

When providing guest access in such an environment there can be various challenges relating to the secure delivery of customer payloads as well as the controlling of access to the network and the underlying hardware. On a conventional device with a standard operating system a user having full access can operate view and update the firmware on any device or component in the machine. A modern server can have several embedded processors or similar components that each perform a specific task and each of these components can have firmware and other configuration information that can be modified. Since devices in a cloud or other shared resource environment can be subsequently provisioned to another user a guest could for example perform malicious actions such as injecting firmware in the network card to capture packets transmitted for subsequent users of that device. These captured packets then could be sent to any address or party etc. as set forth in the modified firmware. A user could also for example make modifications to the device to optimize performance for that user s applications where such optimizations may cause performance degradation for other users. It thus can be desirable to design or configure I O devices and other bits of firmware on a machine in such way that combined with aspects such as time to provisioning these malicious or inadvertently detrimental acts would not be possible or would at least be very difficult to implement without being detected.

Systems and methods in accordance with various embodiments can attempt to minimize and or monitor the opportunity for guests with access to a resource to modify the firmware or otherwise modify particular aspects of those resources. In some embodiments once the operating system or other such software is on a host device permissions can be set such that users cannot access and or modify specific aspects of the host such as the firmware of various devices. Typically a device will expose certain special calls and or ports that are used for firmware flashing and there is some level of control as to whether the device opens those ports and or allows those events. Even if ports and events are exposed to a guest user various approaches can be used to monitor and or address specific actions taken by that user.

In various embodiments at least one secure counter or other monotonic counting hardware mechanism can be implemented to track a number of changes and or attempted changes to configuration information such as firmware in a hardware device. Such a counter can be used to verify that changes have not been made since last known good or verified state such as by using standard cryptographic techniques including hashing and signing state information. In embodiments where a guest operating system is loaded onto a host device that includes a plurality of different hardware devices such as peripheral cards there can be a counter for one or more of these devices such that update attempts can be tracked for any or all of the hardware devices on a host. Each secure counter can be positioned and or configured such that any attempt to update firmware or other configuration information for a respective device can cause a value of the counter to be adjusted. Using such an approach a current state of the information for any hardware device can be verified and any attempted changes can be acted upon as appropriate. For example the firmware or configuration information can be verified to correspond to an expected state. In other embodiments an alert can be triggered any time a change in the counter is detected or the value of the counter is in an unexpected state. Various other variations exist within the scope of the various embodiments.

In some embodiments a user application guest OS or other source can have access to update the configuration information such as the firmware of the NIC firmware on a graphics processing unit GPU firmware for the central processing unit firmware for the Basic Input Output System BIOS of the host machine or any other component of the host machine . Each counter such as a counter for the NIC or counter for the GPU can be used to determine attempts to update specific firmware such that it can readily be determined whether the firmware is in the expected state or may have been modified. For example a cloud manager or provisioning system can communicate with the host to obtain the current count or value from the counter . In some cases this can be done during a time such as an initial boot phase where the user or guest OS will not be able to modify the value returned from the counter. In other cases this value can be analyzed each time a user is to be provisioned onto the host but before the provisioning process to ensure that any or all components are in an expected state. If a counter does not return an expected value an appropriate remedial action can be taken as discussed elsewhere herein. A master counter also can be used as discussed elsewhere herein to aggregate the values of each counter or at least increment when any associated counter is updated to provide a single point for determination of firmware state for components of the host machine.

A secure counter in such an embodiment thus can allow for fast hardware reuse across administrative boundaries. If the counter is incremented the slow process of hardware analysis can be performed the hardware can be reset or re initialized into some known good state or another remedial action can be performed. The counter can avoid such a lengthy process and allow more efficient re use when the counter is determined to be unchanged. The reset process on some devices also introduces wear some memory systems like FLASH have a limited number of write cycles such that the ability to avoid unnecessary resetting based on the secure counter provides yet another advantage.

In one embodiment the secure counter is a flash based counter that cannot be modified by a user operating system OS central processing unit CPU or other aspect of the host machine. The value of the counter can be incremented automatically each time a user application or other source updates or otherwise attempts to write the firmware or other configuration information. A value of the counter can be stored each time the state of the firmware is validated or updated by an authorized source. As long as the value of the counter does not change in at least some embodiments the state of the firmware can be trusted to be in the expected state. If an authorized source does not update the firmware but the value of the counter has changed then the firmware on the device can be handled as being in a potentially unknown state. The value of the counter can be determined at any appropriate time such as at machine boot restart power on or any other appropriate time. In some embodiments a network component can periodically poll the counter for the current value in order to ensure that no updates have been made and or attempted since a previous polling validation etc. In some embodiments the administrative networking component performs this polling in a way that cannot be intercepted by the main CPU or otherwise by hardware that may be have been compromised by a user. This can be accomplished in one example using a dedicated port on a peripheral device and a secure channel from this port over the internal hardware interconnect e.g. PCI bus to the device being polled. In other embodiments a separate dedicated port can be used for each device being polled such that the secure channel is contained entirely within the device being polled. Various other combinations and variations can be utilized within the scope of the various embodiments as should be apparent to one of ordinary skill in the art in light of the teachings and suggestions contained herein.

In some embodiments the counter is physically built into the hardware such as into a trusted platform module TPM or as a chip on the motherboard or as part of a hardware device. In certain embodiments there can be a counter for each piece of mutable firmware on a host machine such as on a device in the BIOS or in the CPU as well as for any device or component that can be flashed or otherwise updated by a user guest OS or other such source. In some embodiments a device can be configured such that each time an attempt to change the BIOS or firmware is detected for example the counter is updated automatically as part of the flashing process. In such an embodiment the counter does not necessarily have to be a physical counter in hardware such as part of a chipset that drives the firmware for example but can be a virtual counter controlled using software and stored to an appropriate location. In some embodiments the counter can be incremented any time information goes to the firmware or other component corresponding to the counter while in other embodiments the counter will only be incremented when certain operations or attempts are detected such as an update to the firmware.

One or more counters can be used in the various embodiments to track communications to any of a number of components. As illustrated in any of the peripheral cards or other components can have a dedicated counter. illustrates an example configuration wherein a single counter is used for any or all components e.g. a NIC or CPU connected to a bus such as a PCI bus managed by an I O hub or similar component. In this example the counter is shown to reside on a path between the I O hub and PCI components although in some cases the counter can be included as part of the I O hub itself. Using such an approach the counter can monitor one or more paths along the bus. If there are five components connected to the bus for example there can be five separate counters monitoring the bus path to each component. In other embodiments there can be a single counter for each path along the PCI bus at least along each path to mutable firmware or other such information. In this way the counter can be incremented any time a user guest OS CPU or other source attempts to modify firmware for any of the devices on the bus.

As discussed in certain embodiments a master counter can be used that increments each time an associated counter is incremented. In a host machine a master counter can be configured to communicate with each counter over a secure channel inaccessible to a user of the host machine or CPU on the host machine such that the master count cannot be modified at least by an unapproved actor. For a group of machines such as a rack of servers a single master counter can be used to aggregate counter information for each machine. The current count of a master counter can be determined using approaches discussed herein for dedicated counters such as by querying the value over a secure channel while in some embodiments the master counter can also or alternatively provide a display such as an LED display at a visible exterior location such that a technician or other person at the physical location of the hardware can quickly determine whether the configuration information for the entire group is in the expected state. Such an approach can simplify the verification process in some embodiments as a single number can be verified for all the components along the bus in a host machine in a server rack etc. As discussed in some embodiments the counter value can be obtained by the CPU while in other embodiments there can be a path external to the CPU that connects with a network component such as a cloud manager system which can obtain a current counter value and compare that value to the expected value to determine whether any of the monitored components might have been modified. Several other variations exist as well as should be apparent.

In some embodiments the firmware for a given hardware device can be immutable to the CPU or other host components and can only be updated via an external channel. For example illustrates an update port as part of the NIC which can allow a cloud manager provisioning system or other such component to modify the firmware which cannot be modified from the host machine itself. In such an embodiment a counter still can be used to monitor the activity of a user or guest on the host such that a provider can be informed when a user attempts to update the firmware and can take an appropriate remedial action. In some cases a user having the machine provisioned will be unaware of the update attempt and such an approach can allow the user to be informed of the use which might violate policy agreements etc. An update port also can be used to obtain the actual value of the counter independent of other components on the host.

In many of these embodiments the counter is a secure counter that is independent of the CPU or other such processing component of the host device. Such a configuration can prevent the CPU from modifying the value of the counter such as to change the value back to a previous value after an update or update attempt. For example if the expected counter value is twelve and the CPU is able to modify the counter the CPU could update the firmware on a device which would cause the counter to increment to thirteen which would indicate that the firmware might have been modified. The CPU then could adjust the value of the counter back to twelve however which would cause the host to appear to a monitoring system as if the firmware is in the expected state. In some cases a CPU controlling the counter could simply prevent the counter from being implemented on an update. For similar reasons various embodiments enable the count value to be obtained without passing through the CPU such that the CPU could potentially intercept the actual value and replace that value with the expected value etc. Since a CPU in some embodiments is a component that can be relatively easily compromised it can be desirable in at least some of those embodiments to implement the counter and the retrieval of the count independently of the CPU or other such component s .

In order to utilize such a counter effectively the expected counter values can be determined accurately and managed securely in various embodiments. In one embodiment firmware is only updated by an authorized provider and is never allowed to be updated from the user. In such an embodiment the counter value can be determined after each flashing or updating of a device and can be stored to a secure location such as a central database for a cloud manager or similar system external to the host and not exposed to guest users. Since the user is not allowed to update the firmware the count value should always correspond to the expected value stored in the central location. In some embodiments the expected value can be stored on the hardware itself in a secure location that is not accessible to the user such as in static RAM or FLASH memory that does not have a mapping exposed to the user or in an inaccessible portion of the I O hub. In some embodiments the expected value can be digitally signed encrypted or otherwise cryptographically secured such that the value is not easily determined and or modified by a guest user. In cases where an encrypted or signed value is stored on the device but the value cannot properly be retrieved such as where modified or deleted by a user the state of the hardware can be treated as if the actual and expected values do not match and a validation or authentication process can be executed.

The value stored in the counter can be verified at any of a number of times using any of a number of approaches in accordance with the various embodiments. In some embodiments the machine can be configured to verify the value at startup boot or any other such time such as by comparing the expected value of the counter stored in a secure location with the current value of the counter. If the values do not match an appropriate remedial action can be taken such as to halt booting of the machine or send a notification that the values do not match. In some cases the hardware device can be configured to push the value to an appropriate component at startup at regular intervals upon specific actions e.g. changes in value or at any other appropriate time. In some embodiments this can include sending the value to a cloud manager system that is able to verify the current value against the expected value and take appropriate actions where the values do not match. In other embodiments a component such as a cloud manager can be configured to periodically poll the hardware for the current value which then can be compared to the expected value. Other mechanisms for comparing the actual and expected value can be used as well within the scope of the various embodiments.

Various other actions can be taken upon a determination that the actual and expected values do not match which can depend at least in part upon the embodiment s . For example if it is determined that the values do not match for a peripheral device that is currently provisioned to a particular user the action might involve storing a flag or other identifier for that hardware that the firmware for that device should be flashed before provisioning another user. In other embodiments a notification might be sent to a central provisioning system or cloud manager to move the guest to another hardware instance where the firmware is in an expected state. In other embodiments the peripheral device for example can be disabled and only the hardware that is in the expected state will be provisioned to subsequent users for example the rest of the hardware on the host without the peripheral device. In some embodiments any current process can be halted and the host or device isolated. In other embodiments the difference in values can trigger a validate or similar process wherein the actual state of the firmware is compared with the expected state of the firmware such as by performing a hashing or other such process known for comparing two pieces of information to determine whether that information is the same. It can be the case in various embodiments that multiple different configurations can be considered valid. In other words there can be a catalog of valid states any of which can be considered to be valid by the validation process. Thus changes in some case can actually correspond to valid changes. Likewise the firmware image can be changed to a configuration that is identical to the previous state i.e. the counter can be triggered but the firmware or configuration state did not effectively change . If the firmware is validated the current value of the counter can be stored as the expected value and operation of the device can continue. If the firmware is not what is expected an action can be taken such as those discussed above. In some cases any change in the value will cause a human to be paged or otherwise notified who can examine the hardware to determine if anything has changed unexpectedly and can fix or place the machine back into an expected state. This could require physical access to the host hardware for example such as to reset a hardware switch or other such mechanism.

In some embodiments a user can be authorized to update the firmware as desired. In such an embodiment the value of any counters can be used to determine which pieces of firmware or other such information may have been changed such that the process of flashing the devices before provisioning a new guest can be simplified to only include those components with incremented counter values. In some embodiments a user can apply approved updates and must notify the provider of each update such that the provider can update the expected value of the counter. In this way the expected and actual values will match as long as the user always notifies the central managing component or system and applies approved updates.

In some embodiments such as in a cloud environment users might be provisioned to a device at a rate no higher than every 5 15 or 60 minutes for example such that for a 32 bit count register included on chip within a microcontroller for example it will be unlikely that the counter will reach the maximum value during the lifetime of the counter. For smaller counters however there may need to be procedures in place to reset the counter at certain times. This can include notifying a human to do a manual reset requiring physical access to the device resetting the counter in software or performing any other such procedure for resetting a counter as known or subsequently developed for such purposes. In some embodiments resetting the counter may require cryptographic authorization or procedures known for such purposes. In some embodiments undesired action such as rollover aliasing can be addressed by permanently preventing further changes to firmware or other configuration information once the counter is maxed out such as in the case of blowing a fuse. In such cases physical access to the machine can be required to reset a counter to enable a data center or other employee to reset a device without allowing a user having locked up a device to be able to remotely reset the device.

As discussed above the various embodiments can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Various aspects also can be implemented as part of at least one service or Web service such as may be part of a service oriented architecture. Services such as Web services can communicate using any appropriate type of messaging such as by using messages in extensible markup language XML format and exchanged using an appropriate protocol such as SOAP derived from the Simple Object Access Protocol . Processes provided or executed by such services can be written in any appropriate language such as the Web Services Description Language WSDL . Using a language such as WSDL allows for functionality such as the automated generation of client side code in various SOAP frameworks.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

