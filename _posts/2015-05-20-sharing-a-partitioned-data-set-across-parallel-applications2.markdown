---

title: Sharing a partitioned data set across parallel applications
abstract: Provided are techniques for sharing a partitioned data set across parallel applications. Under control of a producing application, a partitioned data set is generated; a descriptor that describes the partitioned data set is generated; and the descriptor is registered in a registry. Under control of a consuming application, the registry is accessed to obtain the descriptor of the partitioned data set; and the descriptor is uses to determine how to process the partitioned data set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542246&OS=09542246&RS=09542246
owner: International Business Machines Corporation
number: 09542246
owner_city: Armonk
owner_country: US
publication_date: 20150520
---
With the ever increasing amount of data available to be processed and analyzed and the availability of multi processor e.g. Central Processing Unit CPU core systems more and more data processing applications are being built to process data using parallel data processing techniques. A common technique for processing data in parallel is to partition data into subsets and run many instances of the application s processes or threads to operate on the subsets simultaneously i.e. in parallel .

Often the data that was created in one parallel processing system is moved to or through one or more other parallel processing systems. In the current state of art these parallel processing systems typically do their parallel processing in a proprietary manner and interface with other parallel processing systems using a lowest common denominator type of approach. With such an approach the first application partitions the data in a first manner e.g. into 4 partitions then the data is serialized and written to a sequential file on disk or passed through a sequential Application Programming Interface API to the second application and the second application re partitions the data in a second manner e.g. into 2 partitions . This interaction between parallel processing systems introduces bottlenecks into the overall processing of the data reducing the benefits gained by using these parallel processing systems.

Some products in the market have developed special functionality to improve on this. For example one implementation works if the data is moving from application A to application B but different implementations are needed to move data from application B to application A or from application A to application C. Thus when specific functionality is added to allow for parallel data exchange each interaction is a one off custom implementation.

The following example is provided to clarify existing solutions. This example has a set of records forming data. For example in a data integration scenario a job is designed to get a two letter option code of each record to a single line for all the records with the same key. First the records are sorted. Then a task loops through each subgroup of records grouped by the key extracts the option code of each of the records and concatenates the option codes into a single line.

When there are a large number of records a first application e.g. an Apache Hadoop application or a JavaScript Object Notation JSON Query Language JAQL application may be used to perform the sort while a second application e.g. an Extract Transform and Load ETL application is used to perform the looping and option code extraction. Apache Hadoop is a registered trademark of the Apache Software Foundation in the United States and or other countries. JavaScript is a registered trademark of Oracle Corporation in the United States and or other countries. In processing the output of the first application will be used as the input for the second application.

To process the records in parallel the first application partitions the records. For example the first application partitions the records in n ways while the second application partitions the records in m ways. The second application reads n streams of input records from the first application. Thus the second application expects n streams of records from the first application and assumes the records are sorted. The second application does not rely on any constraint or correlation between the n streams. The second application runs m instances of the job m ways of data partitioning against the n streams of records generated by the first application.

Although a typical data set has a large number of records the following example has been simplified with a small data set for illustration to enhance understanding while avoiding the complexities of processing a large number of records. The records to be processed include a key the option code and other fields. For simplicity two fields the key and the option code field are used to describe this example. The simplified sample data without showing the large volume looks like the following.

For this example assume that the first application partitions the records in 4 ways n 4 and that the second application partitions the records in 2 ways m 2 .

In phase 1 of the processing the first application sorts the records. In the above example data there is skew in the data there are many rows with the key of 3 but the skew is not manifesting itself in an imbalance because the skewed data is spread over a number of reducers in a map reduce system . The following shows the output of the first application with each of the partitions of sorted records 

In phase 2 of the processing the second application receives the partitioned records and loops through each sorted group of records to extract and concatenate the option codes. In this example the second application runs in 2 ways getting records output by the first application in two streams. Stream A gets partition 1 and partition 3 records while stream B gets partition 2 and partition 4 records. Then the second application generates the following results 

However the result is not correct. The correct result should not have one key spread across more than one row i.e. there are two rows for key 3 . The correct result should look like the following 

Because there is no sharing of information about data between applications passing parallel data from one parallel processing application to another parallel processing application often results in serializing the data and forcing sequential processing by both applications.

If applications make an attempt to take advantage of existing data partitioning assumptions may be made about the partitioning characteristics which may lead to errors.

Provided is a method for sharing a partitioned data set across parallel applications. The method comprises under control of a producing application generating a partitioned data set generating a descriptor that describes the partitioned data set and registering the descriptor in a registry and under control of a consuming application accessing the registry to obtain the descriptor of the partitioned data set and using the descriptor to determine how to process the partitioned data set.

Provided is a computer program product for sharing a partitioned data set across parallel applications. The computer program product comprises a computer readable storage medium having program code embodied therewith the program code executable by at least one processor to perform under control of a producing application generating a partitioned data set generating a descriptor that describes the partitioned data set and registering the descriptor in a registry and under control of a consuming application accessing the registry to obtain the descriptor of the partitioned data set and using the descriptor to determine how to process the partitioned data set.

Provided is a computer system for sharing a partitioned data set across parallel applications. The computer system comprises one or more processors one or more computer readable memories and one or more computer readable tangible storage devices and program instructions stored on at least one of the one or more computer readable tangible storage devices for execution by at least one of the one or more processors via at least one of the one or more memories to perform under control of a producing application generating a partitioned data set generating a descriptor that describes the partitioned data set and registering the descriptor in a registry and under control of a consuming application accessing the registry to obtain the descriptor of the partitioned data set and using the descriptor to determine how to process the partitioned data set.

The descriptions of the various embodiments of the present invention have been presented for purposes of illustration but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments the practical application or technical improvement over technologies found in the marketplace or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.

The producing application also referred to as a producer application may be described as a first application that produces or outputs data one or more partitioned data sets while the consuming application also referred to as a consumer application may be described as a second application that consumes or processes the data the one or more partitioned data sets output by the first application . Also the producing application may be said to be upstream from the consuming application and the consuming application may be said to be downstream from the producing application .

Although one producing application and one consuming application are shown there may be any number of producing applications and or consuming applications processing the data the one or more partitioned data sets . Also although three computing devices are shown there may be any number of computing devices coupled to each other that access the registry and process the partitioned data sets .

In addition although the registry is shown at a central computing device in various embodiments the registry may be located at the computing device executing the producing application or at the computing device executing the consuming application . In certain embodiments the producing application the consuming application and the registry may be located at one computing device.

In certain embodiments the number of partitioned data sets output by the producing application is different from the number of partitioned data sets used by the consuming application . In certain embodiments the producing application obtains the original data set from another computing device and performs processing to generate the partitioned data set .

With embodiments when handling partitioned data sets across multiple applications the data set partition information is stored in the registry and provided to and understood by the downstream consuming applications that will use that information and take actions accordingly e.g. to use the data as it is partitioned without serializing the data into a file and re partitioning the data . In certain embodiments the registry may also store other useful information e.g. case sensitivity or collation for specific languages as applications may sort or compare strings by default using different case sensitivity or different language specific collation order or equality .

Embodiments allow a producing application to describe parallel data sets that it creates enabling consuming applications to understand the characteristics of the data set and to use information to reliably take advantage of the partitioning of the data set.

The registry provides a shared directory of partitioned data sets and associated descriptors. In certain embodiments there is one descriptor for each partitioned data set. A descriptor has a set of properties that are used for understanding the associated partitioned data set. The registry is used by producing applications that are producing partitioned data sets to publish or share information about the data set. Similarly consuming applications that consume partitioned data sets read the information from the registry to understand the structure of the partitioned data sets. In certain embodiments the registry provides an API for both producing applications and consuming applications to interface with the registry . This creates an environment in which producing applications and consuming applications do not need to be closely integrated to enable efficient processing of partitioned data sets by both applications.

In different embodiments various formats may be used to represent the descriptor e.g. property value list eXtensible Markup Language XML Structured Query Language SQL table etc.

The consuming application that is about to read the partitioned data set calls into the registry using the consumer API. The consuming application provides the URI and the name of the partitioned data set that it will be reading via the consumer API and the registry provides the descriptor to the consuming application . The consuming application may make decisions with application logic on how to take best advantage of the partitioned data set s structure. The consuming application knows the URI e.g. knows that the full path is a file system or a connect string to a database etc. .

Embodiments enable parallel processing applications to take advantage of partitioned data sets created by any application without the applications being tightly coupled.

In various embodiments the registry may be in a database a file system or some other type of repository. Using APIs to call into the registry insulates both the producing application and the consuming application from the registry implementation detail.

With embodiments the registry is managed so that data is in sync across the producing application the consuming application and the registry itself.

Merely to enhance understanding of embodiments and example is provided herein. However embodiments are not intended to be limited to this example.

With this example a database is used to host the registry. The following is the schema of the table that stores the descriptor information 

The columns of the table are DataSourceName DataSetName Count isOrdered Files FieldDelimiter PartitionMethod and PartitionSorted.

The DataSourceName column stores the URI of the partitioned files e.g. iishd010.svl.ibm.com 8080 data controller dfs OC . The DataSetName column stores the identifier of the data set to be consumed e.g. option code . The Count column stores the number of partitions of the data set.

If each record in each partition is sorted the isOrdered column indicates whether the numbering of the partitions reflects the order of the sorted records in the whole data set. That is if isOrdered is true a whole sorted data set may be created by concatenating partition 1 partition 2 partition 3 etc.

If the data are written in files the Files column stores the full path file names delimited with commas. If the data are in sequential files the FieldDelimiter column stores the field delimiter between the records. The PartitionMethod column stores how the data is partitioned e.g. by Key or Balanced . The PartitionSorted column indicates whether data is sorted in each partition. Note that this example does not use the optional PartitionKeys and PartitionSortKeys properties of the descriptor .

In this example a data integration scenario involves two applications a producing application and a consuming application. This example focuses on how the producing application generates and then stores the data partitioning information in the registry and how the consuming application retrieves the information from the registry and uses the information to make informed decisions.

To simplify the example the operations are divided in two phases phase 1 sorting the data with the producing application and phase 2 extracting concatenating option codes with the consuming application followed by additional processing . illustrates a sequence of operations for data integration processing in accordance with embodiments. The producing application may be any application that can invoke and orchestrate a sequence of operations across multiple applications.

In this example in phase 1 the producing application may invoke JAQL a high level language for invoking Map Reduce jobs to carry out the tasks using a JAQL connector to sort the data. The results of sorting may be placed in a file system e.g. an Apache Hadoop File System HDFS . When sorting is complete the results are partitioned data files that are stored in the file system. In addition the producing application generates and stores a descriptor with the data partitioning information in the registry. illustrates pseudo code for storing a descriptor of a partitioned data set into a registry in accordance with certain embodiments.

With this example once phase 1 is completed phase 2 starts. First the consuming application queries the registry and retrieves the descriptor. Then the consuming application retrieves the sorted data from the file system and extracts and concatenates the option codes with further processing in phase 2. With embodiments the consuming application uses the information in the descriptor to decide on how to process the data. illustrates pseudo code for retrieving a descriptor of a partitioned data set from a registry in accordance with certain embodiments.

Merely to enhance understanding of embodiments the following examples of data partitioning methods are provided. However embodiments are not intended to be limited to these examples.

With the first example the partitioning method is Key partition. In this example the data partitioning method is Key . illustrates a descriptor of a partitioned data set in accordance with certain embodiments. As shown in the descriptor the data is partitioned in 4 ways the partitioned data are ordered so partition 1 comes first and partition 2 comes second and so on the data are written to 4 files each corresponding to a partition the field delimiter is the character the partitioning method is Key the partitioning key is column 1 the data in each partition is sorted and the data in each partition is sorted by column 1.

With the second example the partitioning method is Balanced partitioning. illustrates a descriptor of data for balanced partitioning in accordance with certain embodiments. As shown in the descriptor the data is partitioned in 4 ways the partitioned data are ordered so partition 1 comes first and partition 2 comes second and so on the data are written to 4 files each corresponding to a partition the field delimiter is the character the partitioning method is Balanced the partitioning key is column 1 the data in each partition is sorted and the data in each partition is sorted by column 1.

Based on the data partitioning information in the descriptor when the producing application partitions the data the producing application also tries to avoid data skew. That is if there are too many rows with the same key some of these rows may be spilled to the next partition. So the partitioned data that the producing application writes to the file system may have rows with the same key spread across more than 1 partition. When the consuming application reads in that data based on the descriptor the consuming application starts 4 Big Data File Connector BDFC instances each retrieving rows from a different partition. When the BDFC instances send the data to the downstream Transformer stage the consuming application applies the parallel sort merge function to ensure that the data will go to the right partition. Note this process does not require the data to be sorted again. With the information in the data descriptor the downstream consuming application leverages the sorted data by its upstream producing application i.e. by applying a parallel sort merge function .

Thus embodiments provide a simple way for parallel applications to share partitioned data sets in such a way that multiple applications may process the data in a more efficient manner.

The descriptor defines the properties that are used by other applications to understand the partitioned data sets and creates a standard contract between producing and consuming applications. The descriptor is stored in a registry where the data partition information may be added or updated and retrieved by the producer and consuming applications via APIs. This allows for applications to build efficient mechanisms for processing partitioned data sets without having to build special one off implementations for each producer consumer pair. The registry provides a common directory of partitioned data sets where applications can share and obtain the properties of data sets.

In certain alternative embodiments a pluggable framework is used such that a plug in may be implemented by the consuming application to understand the data partitioning information of the partitioned data sets generated by the producing application. With this approach a plug in is implemented for each different kind of data source rather than storing information in the registry. For example in a data integration environment with heterogeneous data sources multiple plug ins are implemented and managed.

Embodiments allow applications that share partitioned data sets with a way to propagate partition information so that the applications can process the data optimally. In particular embodiments use a common registry and APIs to allow applications to share metadata describing partitioned data sets.

It is understood in advance that although this disclosure includes a detailed description on cloud computing implementation of the teachings recited herein are not limited to a cloud computing environment. Rather embodiments of the present invention are capable of being implemented in conjunction with any other type of computing environment now known or later developed.

Cloud computing is a model of service delivery for enabling convenient on demand network access to a shared pool of configurable computing resources e.g. networks network bandwidth servers processing memory storage applications virtual machines and services that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics at least three service models and at least four deployment models.

On demand self service a cloud consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with the service s provider.

Broad network access capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones laptops and PDAs .

Resource pooling the provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or datacenter .

Rapid elasticity capabilities can be rapidly and elastically provisioned in some cases automatically to quickly scale out and rapidly released to quickly scale in. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS the capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser e.g. web based email . The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS the capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly application hosting environment configurations.

Infrastructure as a Service IaaS the capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on premises or off premises.

Community cloud the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns e.g. mission security requirements policy and compliance considerations . It may be managed by the organizations or a third party and may exist on premises or off premises.

Public cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.

Hybrid cloud the cloud infrastructure is a composition of two or more clouds private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

A cloud computing environment is service oriented with a focus on statelessness low coupling modularity and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes.

Referring now to a schematic of an example of a cloud computing node is shown. Cloud computing node is only one example of a suitable cloud computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless cloud computing node is capable of being implemented and or performing any of the functionality set forth hereinabove.

In cloud computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients handheld or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in computer system server in cloud computing node is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor .

Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the invention as described herein.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

Referring now to illustrative cloud computing environment is depicted. As shown cloud computing environment comprises one or more cloud computing nodes with which local computing devices used by cloud consumers such as for example personal digital assistant PDA or cellular telephone A desktop computer B laptop computer C and or automobile computer system N may communicate. Nodes may communicate with one another. They may be grouped not shown physically or virtually in one or more networks such as Private Community Public or Hybrid clouds as described hereinabove or a combination thereof. This allows cloud computing environment to offer infrastructure platforms and or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices A N shown in are intended to be illustrative only and that computing nodes and cloud computing environment can communicate with any type of computerized device over any type of network and or network addressable connection e.g. using a web browser .

Referring now to a set of functional abstraction layers provided by cloud computing environment is shown. It should be understood in advance that the components layers and functions shown in are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted the following layers and corresponding functions are provided 

Hardware and software layer includes hardware and software components. Examples of hardware components include mainframes in one example IBM zSeries systems RISC Reduced Instruction Set Computer architecture based servers in one example IBM pSeries systems IBM xSeries systems IBM BladeCenter systems storage devices networks and networking components. Examples of software components include network application server software in one example IBM WebSphere application server software and database software in one example IBM DB2 database software. IBM zSeries pSeries xSeries BladeCenter WebSphere and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide .

Virtualization layer provides an abstraction layer from which the following examples of virtual entities may be provided virtual servers virtual storage virtual networks including virtual private networks virtual applications and operating systems and virtual clients.

In one example management layer may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment and billing or invoicing for consumption of these resources. In one example these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement SLA planning and fulfillment provide pre arrangement for and procurement of cloud computing resources for which a future requirement is anticipated in accordance with an SLA.

Workloads layer provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include mapping and navigation software development and lifecycle management virtual classroom education delivery data analytics processing transaction processing and partitioned data set processing.

Thus in certain embodiments software or a program implementing partitioned data set processing in accordance with embodiments described herein is provided as a service in a cloud environment.

In certain embodiments the computing devices have the architecture of computing node . In certain embodiments the computing devices are part of a cloud environment. In certain alternative embodiments the computing devices are not part of a cloud environment.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

