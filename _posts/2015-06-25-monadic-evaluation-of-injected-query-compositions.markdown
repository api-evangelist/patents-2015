---

title: Monadic evaluation of injected query compositions
abstract: Embodiments enable the evaluation of injected queries within a monad. One or more operators with closures are received from a first process. The operators with closures represent one or more functions to be applied by a second process. The second process evaluates the received operators with closures to apply the functions within the monad. During evaluation, the second process converts the closures to simply typed closures. Further, the second process binds the converted closures within the monad to restrict execution of the functions. In some embodiments, the queries (e.g., sequences of one or more operators with closures) are composed using a set of query operators from the language integrated query (LINQ) framework encoded in uniform resource locators (URLs) in the representational state transfer (REST) style.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503505&OS=09503505&RS=09503505
owner: Microsoft Technology Licensing, LLC
number: 09503505
owner_city: Redmond
owner_country: US
publication_date: 20150625
---
Data exchange among computers can take the form of client server communications peer to peer communications process to process communications and the like. Some existing systems attempt to anticipate data queries to be received by one device from another device by pre programming those data queries. Such systems however require significant resources and cannot anticipate every possible data query. Other existing systems allow devices to create imperative queries such as in the JAVASCRIPT scripting language. With these systems however queries are difficult to compose serialize and parse because of their length and syntactic complexity. Further imperative queries expose security vulnerabilities at least because they contemplate the execution of code from untrusted sources e.g. the performance of unrestricted allocation and copying . As such these existing systems fail to prevent or contain the execution of malicious queries injected into communications sent over transport protocols such as the hypertext transfer protocol HTTP .

Embodiments of the disclosure enable bi directional dynamically programmable injection of operations into communications between a first process and a second process. A sequence of one or more operators with closures is received from a first process by a second process. The closures represent one or more functions to be applied within a monad by the second process. The second process evaluates the received operators with closures to execute the functions. During evaluation the closures are converted to simply typed closures. Further evaluation of the operators with converted closures is bound within a monad to restrict execution of the functions.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Referring to the figures embodiments of the disclosure enable monadic evaluation of dynamically programmable composable non imperative queries. In some embodiments declarative closures using a set of query operators are implemented in a scripting language for bi directional query injection in web applications and mobile applications.

While some examples herein are discussed with reference to lambda expressions aspects of the disclosure are not limited to lambda expressions but instead operable with any form of closures or other closed expressions. For example embodiments are operable with anonymous inner classes.

Aspects of the disclosure include a set of query operators that enable composable queries over enumerable data collections e.g. whose elements are available in memory at a given time or asynchronous data collections e.g. whose elements arrive at different times . Enumerables represent data distributed over a space domain whereas observables represent data distributed over a time domain. As an example enumerables may span a space domain that includes memory local disk storage remote databases and more. With enumerables an application is written as if all the data were available in memory at one time even though the data may be physically distributed over multiple devices. In the observable model the application is written as if the data were distributed unpredictably over time even though some or all of the data may be available in portions at particular times.

By being programmable the queries in aspects of the disclosure enable application developers to use the data resources of a server or web application in unanticipated ways. For example a server does not have to be preprogrammed with all possible queries that a client might ever want. Because some of the unanticipated ways may be malicious aspects of the disclosure contemplate sandboxing type checking timeout restart and other means for preventing execution of malicious functions. As such aspects of the disclosure enable programmable web services such as web service . For example the composable queries are modular and easy to build in graphical user interfaces e.g. buttons drop down lists menus etc. . The queries are composed of a pipelined sequence of one or more operators with lambda expressions e.g. a query pipeline or a monadic pipeline . Each stage in the pipelined sequence includes at least one operator with at least one lambda expression. Because these operators with lambda expressions are short and declarative processing is simplified at least because operators with lambda expressions are sent signed logged parsed processed analyzed rewritten compiled sandboxed and archived inexpensively. The queries may be processed by servers using websockets and or event based input output environments.

In some embodiments the queries are packaged into hypertext markup language HTML e.g. encoded with uniform resource locators and or digitally signed with public key cryptography systems PKCS in hypertext transfer protocol HTTP POST bodies. The queries may also be parsed into JAVASCRIPT object notation for interoperability with programming languages such as C .

Each operator with lambda expressions has a monadic expression to the left of the dot . . For example if M is a monadic expression then M.Select x x

The queries may be composed using the set of query operators from the language integrated query LINQ framework although other query based frameworks are contemplated. Compositions or pipelines of query operators with lambda expressions may be embedded in uniform resource locators URLs according to the representational state transfer REST style.

The queries are bi directional at least in that the queries may be injected from a client into a server or from a server into a client. The queries are also push pull in that both push style expressions e.g. based on IObservable and pull style expressions e.g. based on IEnumerable may be written using many of the same LINQ operators and lambdas. In some cases the query pipelines for an IEnumerable data collection e.g. distributed over space are identical in syntax to the query pipelines for an IObservable data collection e.g. distributed over time .

In embodiments using LINQ the queries include one or more of the query operators shown in the categories in Table 1 below. In the example operators the argument someLambda represents any lambda expression e.g. x xx 7 y 32 4 x y and the like .

Referring next to an exemplary block diagram illustrates a first process communicating with a second process to obtain data with query injection. The first process and second process may be executed by separate computing devices communicating via a network For example the first process may be executed by a client device and the second process may be executed by a web service or other cloud service see . In another example the first process may be executed by the web service and the second process may be executed by the client device . In still another example the first process may be executed on a device that is a peer to a device executing the second process . Alternatively the first process and the second process may be executed by the same computing device as shown as optional in . For example the first process may be associated with one thread executing on the computing device and the second process may be associated with another thread executing on the same computing device .

The first process desires data from the second process . The requested data may be any data accessible by at least the second process including but not limited to data generated by execution or evaluation of a query by the second process . The requested data may also be data generated by execution of one or more functions. In some embodiments the request is to apply a filter to a collection of data to produce a subset of the data. For example the first process may request electronic mail messages calendar data product information map data retail store names and locations and the like that meet one or more criteria defined in the request. The request may also include a request to subscribe to updates available from the second process .

In some embodiments rather than access the requested data directly the first process prepares or produces at least one query describing the desired data. In some embodiments the query takes the form of a sequence of operators with lambda expressions. In embodiments in which the ordering of operators is significant or intentional the query takes the form of a sequence or other ordered collection with duplicates allowed instead of a set or other unordered collection with duplicates not allowed .

The operators with lambda expressions may be ordered for execution by the first process or may be capable or rearrangement by the second process before execution or evaluation. While described with reference to lambda expressions or derivations thereof aspects of the disclosure are not limited to operators with lambda expressions or to lambda expressions alone and are operable with other query representations.

The first process injects the query into a message sent from the first process to the second process . The query may also be injected into a message sent by a process other than the first process . The second process performs the query to produce the requested data and then returns the requested data to the first process for consumption. In this manner the first process offloads or delegates query processing to the second process thereby reducing the computational burden complexity and memory use by the first process . The second process may store the injected query and execute it on future data flows from the second process to the first process . The injected query thus may be executed just once or may be stored as a standing query to be executed repeatedly until replaced or expiry after a specified time.

Referring next to an exemplary flow chart illustrates operation of the second process to evaluate received operators with closures. The second process may receive or otherwise access one or more operators with closures produced by the first process . In other embodiments a process other than the second process receives the operators with closures e.g. a process performing communications . In such embodiments the second process accesses the received operators with closures from for example a location in memory.

If the second process receives the operators with closures at the second process evaluates the closures at . Evaluation includes for example evaluating and or executing each of the operators with closures. A scheduler or optimizer associated with the second process determines whether the operators with closures are to be evaluated in sequence one at a time whether the operators with closures are to be rearranged to optimize evaluation and or whether one or more of the operators with closures may be evaluated concurrently e.g. if the second process is multi threaded while other operators with closures are being evaluated.

Evaluating the received operators with closures to execute the functions or queries defined therein includes converting each of the closures to simply typed closures at . A simply typed calculus stands in contrast to other forms of expressions. Converting the closures to simply typed includes but is not limited to preventing or prohibiting self application and or recursive evaluation of the closures. For example the second process prevents recursive execution and self application of the closures. In another example the second process prohibits evaluation of expressions such as function x x x function x x x .

During evaluation the second process binds each of the converted closures within a monad to restrict execution of the functions or queries at . While discussed with reference to monads aspects of the disclosure are operable with other execution proxies for detecting and preventing execution of malicious queries such as stepping e.g. monitor memory access by each of the closures endorsement buddy execution abstract execution host timeout authentication and the like.

Binding the closures within the monad includes in some embodiments applying the same function to data output from execution of each of the functions associated with the closures. For example the output of each evaluated operator with a closure may be placed into or converted to a particular data container structure. In some embodiments evaluating the closures within the monad may be described as sandboxing the evaluation or the closures. As an example binding the operators within the monad includes applying each operator X with one or more closures to the data produced by the operators that precede X in the query pipeline. The first item in the query pipeline is an expression of monadic type and every subsequent operator with closures in the chain is type checked to insure that all data remains in the monad. The closures attached to the operators inspect and transform the individual values inside the monad but the closures and the operators to which the closures are attached are not permitted to leak those individual values outside the monad except in cases such as with the First operator or the ElementAt operator .

Binding within the monad handles any side effects from evaluation of each of the operators with closures. In some embodiments evaluating the operators with closures within a monad enhances security by preventing the injected queries e.g. received from unverified sources from accessing system resources or system calls and from requesting unresolved references. For example monadic execution allows queries to call only functions available within a defined set of functions. Monadic execution may also prohibit one or more of the following writing to a file system or to other memory unbounded memory allocations networking display unrestricted loading of libraries and access to free variables outside the context of the query e.g. those variables in the body of a function that are not in a parameter list for the function . However in some embodiments the second process may also permit query evaluation to access one or more read only global variables.

In some embodiments binding the converted closures within the monad creates what is known in category theory as a Kleisli composition.

Referring next to an exemplary block diagram illustrates the client device communicating with the web service to obtain data with query injection. The client device represents any device capable of communication with the web service . Examples of client devices are described with reference to below. The client device injects a query into a message sent from the client device to the web service . The web service evaluates the query and provides return data to the client device . In some embodiments the client device executes a browser that embeds the query into a URL sent to the web service . The web service e.g. a website evaluates the embedded query to generate the return data.

In some embodiments the web service represents an enumerable data producer exposing enumerators. The client device represents a data consumer that calls methods on the enumerators to obtain data. Further the web service may act as an observable data producer to accept subscriptions from the client devices as observers. The web service calls methods in the client devices to push data.

For example the client device calls a function GetEnumerator on an IEnumerable to get an Enumerator which has the following exemplary methods 

An example of the web service evaluating a query embedded in a URL is described next with reference to .

Referring next to an exemplary flow chart illustrates monadic processing of queries embedded as operators with lambda expressions in URLs . If the second process or other process receives the URL from the first process at the operators with lambda expressions embedded in the URL are extracted at . For example the URL is received via a network and stored in a memory area accessible to the second process . At the extracted operators with lambda expressions may be optimized for evaluation or execution.

The operators with lambda expressions are evaluated at by the second process to generate the data requested by the first process . Evaluation includes converting the lambda expressions to simply typed lambda expressions at . Evaluation of each of the simply typed lambda expressions further includes binding the operators with converted lambda expressions within a monad to encapsulate data generated from each of the lambda expressions at . For example binding the lambda expressions within the monad includes applying at least one operation to the data generated from each of the lambda expressions as the lambda expressions are evaluated.

Referring next to an exemplary block diagram illustrates computer executable components on the computing device for monadic processing of injected queries. In the example of the computing device is associated with a user and represents a system for bi directional push pull dynamically programmable injection of operations into communications between the first process and the second process . In some embodiments the computing device corresponds to the second process or the device for processing the lambda expressions.

The computing device represents any device executing instructions e.g. as application programs operating system functionality or both to implement the operations and functionality associated with the computing device . The computing device may include a mobile computing device or any other portable device. In some embodiments the mobile computing device includes a mobile telephone laptop tablet computing pad netbook gaming device and or portable media player. The computing device may also include less portable devices such as desktop personal computers kiosks and tabletop devices. Additionally the computing device may represent a group of processing units or other computing devices.

The computing device has at least one processor the scheduler and a memory area. The processor includes any quantity of processing units and is programmed to execute computer executable instructions for implementing aspects of the disclosure. The instructions may be performed by the processor or by multiple processors executing within the computing device or performed by a processor external to the computing device . In some embodiments the processor is programmed to execute instructions such as those illustrated in the figures e.g. and . Alternatively or in addition aspects of the disclosure contemplate an execution engine capable of executing the operators with the lambda expressions in customized hardware or microcode.

The scheduler includes any process for analyzing the operators with lambda expressions and determining the order and timing of evaluation of each. The scheduler executes to optimize evaluation of the lambda expressions.

The computing device further has one or more computer readable media such as the memory area. The memory area includes any quantity of media associated with or accessible by the computing device . The memory area may be internal to the computing device as shown in external to the computing device not shown or both not shown .

The memory area stores among other data one or more applications . The applications when executed by the processor operate to perform functionality on the computing device . Exemplary applications include mail application programs web browsers calendar application programs address book application programs messaging programs media applications location based services search programs recommender services and the like. The applications may communicate with counterpart applications or services such as the web service via a network. For example the applications may represent downloaded client side applications that correspond to server side services executing in a cloud.

An example structure of the application designed to implement aspects of the disclosure is next described. The exemplary application is implemented in a middle tier server with websockets using a framework such as the .NET framework. While websockets preserve the option to provide unsolicited updates from the web service to the client device aspects of the disclosure are also operable with other transport mechanisms such as the hypertext transfer protocol HTTP . An OnNext method of the client device is added as a listener to a websocket. The OnNext method analyzes and applies a query from the client device and then provides output data from application of the query to the client device .

In embodiments in which the operators with lambda expressions are embedded in a URL such as URL the memory area further stores the URL . In embodiments in which the operators with lambda expressions are included via public key cryptography standards PKCS or included in a script such as in the JAVASCRIPT scripting language the memory area stores the PKCS package or JAVASCRIPT object notation. In some embodiments PKCS provides source authentication e.g. who sent the queries tamper proofing e.g. no middle party has modified the queries non repudiation e.g. the original sender may not claim that it did not send the query and or privacy e.g. only the intended recipient can decrypt the queries .

The memory area further stores one or more computer executable components. Exemplary components include a communications interface component a script component a type checking component and an encapsulation component . Execution of these components performs operations such as those illustrated in . In the example shown in the script component type checking component and encapsulation component represent the second process . In other examples not shown the second process further provides the functionality associated with the communications interface component .

The communications interface component when executed by the processor causes the processor to receive from the first process a communication having a sequence of operators with lambda expressions injected therein. The operators with lambda expressions represent one or more functions to be performed by the second process to generate output data. In some embodiments the communications interface component includes a network interface card and or computer executable instructions e.g. a driver for operating the network interface card.

The script component when executed by the processor causes the processor to statically analyze by the second process the operators with lambda expressions to convert the lambdas into simply typed form to reorder the sequence of operators with lambda expressions for optimization or for any other reason and to execute the functions to generate the output data. For example the script component executes the functions over a monadic data collection representing one or more of the following an enumerable data collection a collection of data items distributed over space and an observable stream representing a collection of data distributed over time. In this example the operators with lambda expressions represent a pipelined sequence of expressions. Some embodiments of the script component contemplate inclusion of the type checking component and the encapsulation component . In other embodiments the type checking component and the encapsulation component are separate from yet in communication with the script component .

The type checking component when executed by the processor causes the processor to convert each of the lambda expressions to simply typed lambda expressions. The encapsulation component when executed by the processor during run time causes the processor to apply the operators with lambda expressions converted during the static analysis within a monad to the results of each prior stage of the reordered pipeline of operators with lambda expressions to contain the execution of the functions. For example the encapsulation component creates a container data structure for encapsulating the data output from evaluation of each of the operators with lambda expressions. Creating the container data structure may include applying at least one operation to each of the operators with converted lambda expressions as the operators with lambda expressions are evaluated. The same operation or set of operations is applied to the output of each stage in the pipeline of the evaluated operators with lambda expressions.

In some embodiments an encapsulation checking component not shown performs static checks to confirm that each stage of a monadic pipeline maintains monadic integrity by having an appropriate monadic type. This provides some assurance that the encapsulation component does not violate monadic integrity during run time.

After evaluation of the operators with lambda expressions by the script component the communications interface component provides the generated output data to the first process .

Listed below is an example of a monadically sandboxed function that displays the string Hello World using lambda expressions.

In some embodiments a query embedded by the first process may correspond to a filter for examining items in a data collection to produce a potentially smaller data collection. For example in a database of various phonetic alphabets for verbal spelling over noisy phone and radio channels e.g. alpha bravo charlie delta etc. the first process may interested only in the phonetic alphabets adopted by the International Civil Aviation Organization ICAO . An exemplary query composed of lambda expressions using LINQ operators is shown below 

In another example the user is interested in codewords in the phonetic alphabets that contain the letter r . An exemplary query composed of lambda expressions using LINQ operators is shown below 

In a bi directional example the second process subscribes to a periodic stream of location updates or occasional interest updates from the first process . Similarly the first process subscribes to sporadic offers from businesses in the geographic vicinity of the client device that match particular interests. Exemplary code on the second process is shown below.

In some embodiments queries may be dynamically programmable e.g. the queries from one process may be altered by the other process . In an example the second process injects a slow down e.g. flow control into the first process in the form of an instruction to send only every n th observation. The following query written in the form of operators with lambda expressions illustrates the query from the first process injected with another lambda expression by the second process . The injected operator with lambda expression is .Where tick tick 2 0 .

In another example the client device is a mobile device that wants to discover nearby pizza restaurants. The following query is composed by the client device 

At least a portion of the functionality of the various elements in and may be performed by other elements in and or or an entity e.g. processor web service server application program computing device etc. not shown in and or .

In some embodiments the operations illustrated in and may be implemented as software instructions encoded on a computer readable medium in hardware programmed or designed to perform the operations or both. For example aspects of the disclosure may be implemented as a system on a chip.

While no personally identifiable information is tracked by aspects of the disclosure embodiments have been described with reference to data monitored and or collected from users. In such embodiments notice is provided to the users of the collection of the data e.g. via a dialog box or preference setting and users are given the opportunity to give or deny consent for the monitoring and or collection. The consent may take the form of opt in consent or opt out consent.

Exemplary computer readable media include flash memory drives digital versatile discs DVDs compact discs CDs floppy disks and tape cassettes. By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media exclude propagated data signals. Exemplary computer storage media include hard disks flash drives and other solid state memory. In contrast communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media.

Although described in connection with an exemplary computing system environment embodiments of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the invention include but are not limited to mobile computing devices personal computers server computers hand held or laptop devices multiprocessor systems gaming consoles microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments of the invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. The computer executable instructions may be organized into one or more computer executable components or modules. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the invention may be implemented with any number and organization of such components or modules. For example aspects of the invention are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other embodiments of the invention may include different computer executable instructions or components having more or less functionality than illustrated and described herein.

Aspects of the invention transform a general purpose computer into a special purpose computing device when configured to execute the instructions described herein.

The embodiments illustrated and described herein as well as embodiments not specifically described herein but within the scope of aspects of the invention constitute exemplary means for processing query operators embedded in a scripting language in URLs using monads and exemplary means for monadic evaluation of the operators with lambda expressions by web services such as web service .

The order of execution or performance of the operations in embodiments of the invention illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and embodiments of the invention may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the invention.

When introducing elements of aspects of the invention or the embodiments thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

Having described aspects of the invention in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the invention as defined in the appended claims. As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

