---

title: Application programming interfaces for data parallel computing on multiple processors
abstract: A method and an apparatus for a parallel computing program calling APIs (application programming interfaces) in a host processor to perform a data processing task in parallel among compute units are described. The compute units are coupled to the host processor including central processing units (CPUs) and graphic processing units (GPUs). A program object corresponding to a source code for the data processing task is generated in a memory coupled to the host processor according to the API calls. Executable codes for the compute units are generated from the program object according to the API calls to be loaded for concurrent execution among the compute units to perform the data processing task.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477525&OS=09477525&RS=09477525
owner: Apple Inc.
number: 09477525
owner_city: Cupertino
owner_country: US
publication_date: 20151221
---
This application is a continuation of U.S. application Ser. No. 14 163 404 filed Jan. 24 2014 now issued as U.S. Pat. No. 9 250 697 issued Feb. 2 2016 which is a continuation of U.S. application Ser. No. 13 646 552 filed Oct. 5 2012 now issued as U.S. Pat. No. 8 806 513 issued Aug. 12 2014 which is a continuation of U.S. application Ser. No. 12 264 896 filed on Nov. 4 2008 now issued as U.S. Pat. No. 8 286 198 issued Oct. 9 2012 which is related to and claims the benefits of U.S. Provisional Patent Application No. 61 059 739 filed on Jun. 6 2008 which is hereby incorporated by reference herein in its entirety.

The present invention relates generally to data parallel computing. More particularly this invention relates to application programming interfaces APIs for data parallel computing across both CPUs Central Processing Units and GPUs Graphical Processing Units .

As GPUs continue to evolve into high performance parallel computing devices more and more applications are written to perform data parallel computations in GPUs similar to general purpose computing devices. Today these applications are designed to run on specific GPUs using vendor specific interfaces. Thus these applications are not able to leverage processing resources of CPUs even when both GPUs and CPUs are available in a data processing system. Nor can processing resources be leveraged across GPUs from different vendors where such an application is running.

However as more and more CPUs embrace multiple cores to perform data parallel computations more and more processing tasks can be supported by either CPUs and or GPUs whichever are available. Traditionally GPUs and CPUs are configured through separate programming environments that are not compatible with each other. Most GPUs require dedicated programs that are vendor specific. As a result it is very difficult for an application to leverage processing resources of both CPUs and GPUs for example leveraging processing resources of GPUs with data parallel computing capabilities together with multi core CPUs.

Therefore there is a need in modern data processing systems to overcome the above problems to allow an application to perform a task using any available processing resources such as CPUs and one or more GPUs capable of performing the task.

An embodiment of the present invention includes methods and apparatuses for a parallel computing program calling APIs in a host processor to perform a data processing task in parallel among compute units including central processing units CPUs and graphic processing units GPUs coupled to the host processor. A program object corresponding to a source code for the data processing task is generated in a memory coupled to the host processor according to the API calls. Executable codes for the compute units are generated from the program object according to the API calls to be loaded for concurrent execution among the compute units to perform the data processing task.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.

A method and an apparatus for data parallel computing on multiple processors are described herein. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

A Graphics Processing Unit GPU may be a dedicated graphics processor implementing highly efficient graphics operations such as 2D 3D graphics operation and or digital video related functions. A GPU may include special programmable hardware to perform graphics operations e.g. blitter operations texture mapping polygon rendering pixel shading and vertex shading. GPUs are known to fetch data from a frame buffer and to blend pixels together to render an image back into the frame buffer for display. GPUs may also control the frame buffer and allow the frame buffer to be used to refresh a display e.g. a CRT or LCD display Either a CRT or an LCD display is a short persistence display that requires refresh at a rate of at least 20 Hz e.g. every 1 30 of a second the display is refreshed with data from a frame buffer . Usually GPUs may take graphics processing tasks from CPUs coupled with the GPUs to output raster graphics images to display devices through display controllers. References in the specification to GPU may be a graphics processor or a programmable graphics processor as described in Method and Apparatus for Multithreaded Processing of Data in a Programmable Graphics Processor Lindholdm et al. U.S. Pat. No. 7 015 913 and Method for Deinterlacing Interlaced Video by A Graphics Processor Swan et al. U.S. Pat. No. 6 970 206 which are hereby incorporated by reference

In one embodiment a plurality of different types of processors such as CPUs or GPUs may perform data parallel processing tasks for one or more applications concurrently to increase the usage efficiency of available processing resources in a data processing system. Processing resources of a data processing system may be based on a plurality of physical computing devices such as CPUs or GPUs. A physical computing device may include one or more compute units. In one embodiment data parallel processing tasks or data parallel tasks may be delegated to a plurality types of processors for example CPUs or GPUs capable of performing the tasks. A data parallel task may require certain specific processing capabilities from a processor. Processing capabilities may be for example dedicated texturing hardware support double precision floating point arithmetic dedicated local memory stream data cache or synchronization primitives. Separate types of processors may provide different yet overlapping groups of processing capabilities. For example both CPU and GPU may be capable of performing double precision floating point computation. In one embodiment an application is capable of leveraging either a CPU or a GPU whichever is available to perform a data parallel processing task.

In another embodiment selecting and allocating a plurality of different types of processing resources for a data parallel processing task may be performed automatically during run time. An application may send a hint including desired list of capability requirements for a data processing task though an API to a runtime platform of a data processing system. In accordance with the hint received the runtime platform may determine a plurality of currently available CPUs and or GPUs with capabilities matching the received hint to delegate the data processing task for the application. In one embodiment the list of capability requirements may depend on the underlying data processing task. A capability requirement list may be applicable across different groups of processors or compute units including for example GPUs and multi core CPUs from different vendors and of different versions. Consequently an application may be insulated from providing programs targeting a particular type of compute unit such as a CPU or GPU.

Furthermore in another embodiment allocating and grouping multiple threads to execute in parallel among selected compute units may be performed according to underlying problem space for a data parallel task. An analysis of representations for source codes to be executed in selected compute units may determine how a processing task should optimally be partitioned and distributed among the selected compute units. API interfaces may allow an application to specify how a data parallel task should be performed by executing an executable in groups of threads among selected compute units. In addition an application may retrieve using APIs suggestions on an optimal partitioning of a data parallel task based on resource requirements for performing the task among selected compute units.

In one embodiment the hosting systems may support a software stack. The software stack can include software stack components such as applications a compute platform layer e.g. an OpenCL Open Computing Language platform a compute runtime layer a compute compiler and compute application libraries . An application may interface with other stack components through API calls. One or more threads may be running concurrently for the application in the hosting systems . The compute platform layer may maintain a data structure or a computing device data structure storing processing capabilities for each attached physical computing device. In one embodiment an application may retrieve information about available processing resources of the hosting systems through the compute platform layer . An application may select and specify capability requirements for performing a processing task through the compute platform layer . Accordingly the compute platform layer may determine a configuration for physical computing devices to allocate and initialize processing resources from the attached CPUs and or GPUs for the processing task. In one embodiment the compute platform layer may generate one or more logical computing devices for the application corresponding to one or more actual physical computing devices configured.

The compute runtime layer may manage the execution of a processing task according to the configured processing resources for an application for example based on one or more logical computing devices. In one embodiment executing a processing task may include creating a compute program object representing the processing task and allocating memory resources e.g. for holding executables input output data etc. An executable loaded for a compute program object may be a compute program executable. A compute program executable may be included in a compute program object to be executed in a compute processor or a compute unit such as a CPU or a GPU. The compute runtime layer may interact with the allocated physical devices to carry out the actual execution of the processing task. In one embodiment the compute runtime layer may coordinate executing multiple processing tasks from different applications according to run time states of each processor such as CPU or GPU configured for the processing tasks. The compute runtime layer may select based on the run time states one or more processors from the physical computing devices configured to perform the processing tasks. Performing a processing task may include executing multiple threads of one or more executables in a plurality of physical computing devices concurrently. In one embodiment the compute runtime layer may track the status of each executed processing task by monitoring the run time execution status of each processor.

The runtime layer may load one or more executables as compute program executables corresponding to a processing task from the application . In one embodiment the compute runtime layer automatically loads additional executables required to perform a processing task from the compute application library . The compute runtime layer may load both an executable and its corresponding source program for a compute program object from the application or the compute application library . A source program for a compute program object may be a compute program source. A plurality of executables based on a single compute program source may be loaded according to a logical computing device configured to include multiple types and or different versions of physical computing devices. In one embodiment the compute runtime layer may activate the compute compiler to online compile a loaded source program into an executable optimized for a target processor e.g. a CPU or a GPU configured to execute the executable.

An online compiled executable may be stored for future invocation in addition to existing executables according to a corresponding source program. In addition the executables may be compiled offline and loaded to the compute runtime using API calls. The compute application library and or application may load an associated executable in response to library API requests from an application. Newly compiled executables may be dynamically updated for the compute application library or for the application . In one embodiment the compute runtime may replace an existing compute program executable in an application by a new executable online compiled through the compute compiler for a newly upgraded version of computing device. The compute runtime may insert a new executable online compiled to update the compute application library . In one embodiment the compute runtime may invoke the compute compiler when loading an executable for a processing task. In another embodiment the compute compiler may be invoked offline to build executables for the compute application library . The compute compiler may compile and link a compute kernel program to generate a compute program executable. In one embodiment the compute application library may include a plurality of functions to support for example development toolkits and or image processing. Each library function may correspond to a compute program source and one or more compute program executables stored in the compute application library for a plurality of physical computing devices.

A computing device may include one or more compute processors or compute units such as Processor  and Processor L . A local memory may be coupled with a compute processor. Local memory shared among threads in a single thread group running in a compute processor may be supported by the local memory coupled with the compute processor. Multiple threads from across different thread groups such as thread and thread N may share a compute memory object such as a stream stored in a computing device memory coupled to the computing device . A computing device memory may include a global memory and a constant memory. A global memory may be used to allocate compute memory objects such as streams. A compute memory object may include a collection of data elements that can be operated on by a compute program executable. A compute memory object may represent an image a texture a frame buffer an array of a scalar data type an array of a user defined structure or a variable etc. A constant memory may be read only memory storing constant variables frequently used by a compute program executable.

In one embodiment a local memory for a compute processor or compute unit may be used to allocate variables shared by all thread in a thread group or a thread group. A local memory may be implemented as a dedicated local storage such as local shared memory for Processor  and local shared memory for Processor L. In another embodiment a local memory for a compute processor may be implemented as a read write cache for a computing device memory for one or more compute processors of a computing device such as data cache for compute processors in the computing device . A dedicated local storage may not be shared by threads across different thread groups. If the local memory of a compute processor such as Processor  is implemented as a read write cache e.g. data cache a variable declared to be in the local memory may be allocated from the computing device memory and cached in the read write cache e.g. data cache that implements the local memory. Threads within a thread group may share local variables allocated in the computing device memory when for example neither a read write cache nor dedicated local storage are available for the corresponding computing device. In one embodiment each thread is associated with a private memory to store thread private variables that are used by functions called in the thread. For example private memory may not be seen by threads other than thread .

At block in one embodiment the processing logic of process may build a data structure or a computing device data structure representing multiple physical computing devices associated with one or more corresponding capabilities. Each physical computing device may be attached to the processing system performing the processing logic of process . Capabilities or compute capabilities of a physical computing device such as CPU or GPU may include whether the physical computing device support a processing feature a memory accessing mechanism a named extension or associated limitations. A processing feature may be related to dedicated texturing hardware support double precision floating point arithmetic or synchronization support e.g. mutex .

Capabilities of a computing device may include a type indicating processing characteristics or limitations associated with a computing device. An application may specify a type of required computing device or query the type of a specific computing device using APIs. Examples of different types of computing devices are shown in the following table 

Additionally capabilities of a computing device may include for example configuration values as shown in the following table 

A memory accessing mechanism for a physical processing device may be related to a type of variable cache e.g. no support read only or read write a type of compute memory object cache size of cache support a dedicated local memory support or associated limitations. Memory accessing limitations may include a maximum number of compute memory objects that can be simultaneously read or written by a compute program executable a maximum number of compute memory objects that can be allocated or a maximum size along a dimension of a multi dimensional compute memory object for example a maximum width of a compute memory object for a 2D two dimensional image. A system application of the data processing system may update the data structure in response to attaching a new physical computing device to a data processing system. In one embodiment the capabilities of a physical computing device may be predetermined. In another embodiment a system application of the data processing system may discover a newly attached physical processing device during run time. The system application may retrieve the capabilities of the newly discovered physical computing device to update the data structure representing the attached physical computing devices and their corresponding capabilities.

According to one embodiment the processing logic of process may receive a compute capability requirement from an application at block . The application may send the compute capability requirement to a system application by calling APIs. The system application may correspond to a platform layer of a software stack in a hosting system for the application. In one embodiment a compute capability requirement may identify a list of required capabilities for requesting processing resources to perform a task for the application. In one embodiment the application may require the requested processing resources to perform the task in multiple threads concurrently. In response the processing logic of process may select a group of physical computing devices from attached physical computing devices at block . The selection may be determined based on a matching between the compute capability requirement against the compute capabilities stored in the capability data structure. In one embodiment the processing logic of process may perform the matching according to a hint provided by the capability requirement.

The processing logic of process may determine a matching score according to the number of compute capabilities matched between a physical computing device and the compute capability requirement. In one embodiment the processing logic of process may select multiple physical computing devices with highest matching scores. In another embodiment the processing logic of process may select a physical computing device if each capability in the capability requirement is matched. The processing logic of process may determine multiple groups of matching physical computing devices at block . In one embodiment each group of matching physical computing devices are selected according to a load balancing capability of each device. At block in one embodiment the processing logic of process may generate a computing device identifier for each group of physical computing devices selected at block . The processing logic of process may return one or more of the generated computing device identifiers back to the application through the calling APIs. An application may choose which processing resources to employ for performing a task according to the computing device identifiers. In one embodiment the processing logic of process may generate at most one computing device identifier at block for each capability requirement received.

At block in one embodiment the processing logic of process may allocate resources to initialize a logical computing device for a group of physical computing devices selected at block according to a corresponding computing device identifier. A logical computing device may be a computing device group including one or more physical computing devices. The processing logic of process may perform initializing a logical computing device in response to API requests from an application which has received one or more computing device identifiers according to the selection at block . The processing logic of process may create a context object on the logical computing device for an application. Commands that operate on compute memory object compute program objects and or compute program executables for a context object may be executed in order e.g. synchronously or out of order e.g. asynchronously according to parameters specified in API requests when creating the context object. Profiling commands that operate on compute memory objects compute programs or compute kernels may be enabled for a context object using API requests. In one embodiment a context object is associated with one application thread in a hosting system running the application. Multiple threads performing processing tasks in one logical computing device or across different logical computing devices concurrently may be based on separate context objects.

In one embodiment the processing logic of process may be based on multiple APIs including clCreateContext clRetainContext and clReleaseContext. The API clCreateContext creates a compute context. A compute context may correspond to a compute context object. The API clRetainContext increments the number of instances using a particular compute context identified by a context as an input argument to clRetainContext. The API clCreateContext does an implicit retain. This is very helpful for third party libraries which typically get a context passed to them by the application. However it is possible that the application may delete the context without informing the library. Allowing multiple instances to attach to a context and release from a context solves the problem of a compute context being used by a library no longer being valid. If an input argument to clRetainContext does not correspond to a valid compute context object clRetainContext returns CU INVALID CONTEXT. The API clReleaseContext releases an instance from a valid compute context. If an input argument to clReleaseContext does not correspond to a valid compute context object clReleaseContext returns CU INVALID CONTEXT.

When allocating a compute memory object the processing logic of process may determine where the allocation should reside according to specifications in an API. For example a compute memory object may be allocated out of a host memory such as a host memory for the hosting systems of and or a computing device memory such as a global memory or a constant memory of . A compute memory object allocated in a host memory may need to be cached in a computing device memory. The processing logic of process may asynchronously load data into allocated compute memory objects using non blocking API interfaces e.g. based on generated event objects which include synchronization data indicating whether data has been loaded into a compute memory object. In one embodiment the processing logic of process may schedule memory access operations when reading from or writing to allocated compute memory objects. The processing logic of process may map an allocated stream memory to form a logical address of an application. In one embodiment the processing logic of process may perform operations at block based API requests from an application running in a host processor such as applications of .

At block according to one embodiment the processing logic of process may create a compute program object for the logical computing device e.g. a computing device group . A compute program object may include a group of compute kernels representing exported functions or entry points of a data parallel program. A compute kernel may include a pointer to a compute program executable that can be executed on a compute unit to perform a data parallel task e.g. a function . Each compute kernel may be associated with a group of function arguments including compute memory objects or streams allocated for function inputs or outputs such as the streams allocated at block .

The processing logic of process may load a compute program binary and or a compute program source into the compute program object at block . A compute program binary may include bits that describe a compute program executable that will be run on a computing device. A compute program binary may be a compute program executable and or an intermediate representation of a compute program source to be converted into a compute program executable. In one embodiment a compute program executable may include description data associated with for example the type of target physical computing devices e.g. a GPU or a CPU versions and or compilation options or flags such as a thread group sizes and or thread group dimensions. A compute program source may be the source code where a compute program executable is compiled from. The processing logic of process may load multiple compute program executables corresponding to a compute program source at block . In one embodiment the processing logic of process may load a compute program executable from an application or through a compute library such as compute application library of . A compute program executable may be loaded with the corresponding compute program source. The processing logic of process may set up function arguments for a compute program object at block . In one embodiment the processing logic of process may perform operations at blocks and according to API requests from an application.

At block the processing logic of process may update an execution queue to execute the compute kernel object with a logical computing device. The processing logic of process may execute a computer kernel in response to API calls with appropriate arguments to a compute runtime e.g. compute runtime of from an application or a compute application library such as applications or compute application library of . Executing a compute kernel may include executing a compute program executable associated with the compute kernel. In one embodiment the processing logic of process may generate a compute kernel execution instance to execute a compute kernel. API calls to a compute runtime such as compute runtime of to execute a compute kernel may be asynchronous in nature. An execution instance may be identified by a compute event object that may be returned by a compute runtime such as compute runtime of . A compute kernel execution instance may be added to an execution queue to execute a compute kernel instance.

In one embodiment API calls to a compute runtime to execute a compute kernel may include the number of threads that execute simultaneously in parallel on a compute processor as a thread group. An API call may include the number of compute processors to use. A compute kernel execution instance may include a priority value indicating a desired priority to execute the corresponding compute program executable. A compute kernel execution instance may also include an event object identifying a previous execution instance and or expected total number of threads and number of thread groups to perform the execution. The number of thread groups and total number of threads may be specified in the API calls. In one embodiment an event object may indicate an execution order relationship between the execution instance that includes the event object and another execution instance identified by the event object. An execution instance including an event object may be required to be executed after another execution instance identified by the event object finishes execution. An event object may be referred to as a queue after event object. In one embodiment an execution queue may include multiple compute kernel execution instances for executing corresponding compute program executables. One ore more compute kernel execution instances for a compute program executable may be scheduled for execution in an execution queue. In one embodiment the processing logic of process may update the execution queue in response to API requests from an application. The execution queue may be hosted by the hosting data systems where the application is running.

At block the processing logic of process may select a compute kernel execution instance from the execution queue for execution. In one embodiment the processing logic of process may select more than one compute kernel execution instances to be executed concurrently according to the corresponding logical computing devices. The processing logic of process may determine whether a compute kernel execution instance is selected from the execution queue based on its associated priority and dependency relationships with other execution instances in the execution queue. A compute kernel execution instance may be executed by executing its corresponding compute kernel object according to an executable loaded to the compute kernel object.

At block in one embodiment the processing logic of process may select one of the plurality of executables loaded to the compute kernel object corresponding to the selected compute kernel instance for execution in a physical computing device associated with the logical computing device for the compute kernel object. The processing logic of process may select more than one executables to be executed in more than one physical computing devices in parallel for one compute kernel execution instance. The selection may be based on current execution statuses of the physical computing devices corresponding to the logical computing device associated with the selected compute kernel execution instance. An execution status of a physical computing device may include the number of threads running the local memory usage level and the processor usage level e.g. peak number of operations per unit time etc. In one embodiment the selection may be based on predetermined usage levels. In another embodiment the selection may be based on the number of threads and number of thread groups associated with the compute kernel execution instance. The processing logic of process may retrieve an execution status from a physical computing device. In one embodiment the processing logic of process may perform operations to select a compute kernel execution instance from the execution queue to execute at blocks asynchronously to applications running in hosting systems.

At block the processing logic of process may check the execution status of a compute kernel execution instance scheduled for execution in the execution queue. Each execution instance may be identified by a unique compute event object. An event object may be returned to an application or a compute application library such as application or compute application library of which calls APIs to execute the execution instance when the corresponding compute kernel execution instance was queued according to a compute runtime such as the runtime of . In one embodiment the processing logic of process may perform the execution status checking in response to API requests from an application. The processing logic of process may determine the completion of executing a compute kernel execution instance by querying a status of the compute event object identifying the compute kernel execution instance. The processing logic of process may wait until the execution of a compute kernel execution instance is complete to return to API calls from an application. The processing logic of process may control processing execution instances reading and or writing from various streams based on compute event objects.

At block according to one embodiment the processing logic of process may retrieve results of executing a compute kernel execution instance. Subsequently the processing logic of process may clean up processing resources allocated for executing the compute kernel execution instance. In one embodiment the processing logic of process may copy a stream memory holding results of executing a compute kernel executable into a local memory. The processing logic of process may delete variable streams or image streams allocated at block . The processing logic of process may delete a kernel event object for detecting when a compute kernel execution is completed. If each compute kernel execution instance associated with a specific compute kernel object has been completely executed the processing logic of process may delete the specific compute kernel object. In one embodiment the processing logic of process may perform operations at block based on API requests initiated by an application.

If there are existing compute kernel objects selected process may determine if any of the selected compute kernel executables is optimized for a physical computing device at block . The determination may be based on for example the version of the physical computing device. In one embodiment process may determine that an existing compute kernel executable is optimized for a physical computing device if the version of target physical computing device in the description data matches the version of the physical computing device.

At block in one embodiment process may build a new compute kernel executable optimized for a physical computing device from the corresponding computer kernel source using an online compiler such as compute compiler of . Process may perform the online build if none of the selected compute kernel executables are found to be optimized for the physical computing device at block . In one embodiment process may perform the online build if none of existing compute kernel executables are found to be compatible with the physical computing device at block . The compute kernel source may be available from an application or through a compute library such as compute application library of .

If the build at block is successful in one embodiment process may load the newly built compute kernel executable into the corresponding compute kernel object at block . Otherwise process may load the selected compute kernel executables to the kernel object at block . In one embodiment process may load a compute kernel executable to a compute kernel object if the compute kernel executable has not yet been loaded. In another embodiment process may generate an error message if none of existing compute kernel executables for a compute kernel object are compatible with a physical computing device and the corresponding compute kernel source is not available.

At block in one embodiment process may select a compute kernel execution instances for execution from multiple scheduled compute kernel execution instances without any outstanding dependency condition. The selection may be based on a priority level assigned to an execution instance. In one embodiment the selected compute kernel execution instance may be associated the highest priority level among the plurality of compute kernel execution instances without outstanding dependency conditions. At block process may retrieve a current execution status for one or more of the physical computing devices corresponding to the selected compute kernel execution instance. In one embodiment execution status of a physical computing device may be retrieved from predetermined memory locations. In another embodiment process may send a status request to a physical computing device to receive an execution status report. Process may designate one or more of the physical computing devices to execute the selected compute kernel execution instance based on the retrieved execution statuses at block . In one embodiment a physical computing device may be designated for execution according to a load balancing consideration with other physical computing devices. The selected physical computing device may be associated with an execution status satisfying one or more specified e.g. predetermined criteria such as below a predetermined processor usage level and or memory usage level. In one embodiment the predetermined criteria may depend on the number of threads and the number of thread groups associated with the selected compute kernel execution instance. Process may load separate compute kernel executables for the same execution instance or multiple instances to one or more designated physical computing devices to execute in parallel in multiple threads.

The processing logic of process may analyze and or traverse an intermediate representation of executable codes compiled from a source code targeting a compute unit to determine required resources to execute the executable codes in the target compute unit. During the analysis the processing logic of process may identify a portion of a source code based on matching optimization conditions to recompile the identified portion of the source code to reduce the required resources for execution in the target compute unit. For example the processing logic of process may replace a variable in a source code with a constant value The processing logic of process may identify a dimension of a data parallel task according to an analysis of the corresponding executable codes. When an identified dimension differs from a dimension specified for example using APIs the processing logic of process may select one of the identified dimension and the specified dimension according to for example a system setting.

At block in some embodiment the processing logic of process may determine optimal thread group sizes for executing executable codes in parallel among multiple compute units according to the determined resource requirements. A group of threads may execute an executable code compiled concurrently in a target compute unit. An optimal thread group size may be the number of threads in a thread group to execute an executable code in a compute unit to maximize resource usage within the compute unit. Resource usage of a compute unit may be measured in terms of the amount of time to accomplish a data parallel task. In some embodiments the processing logic of process may retrieve current resource usage status from a compute unit to determine an optimal thread group size for an executable code. An optimal thread group size may be based on a dimension associated with the data parallel task for an executable code to perform. A dimension may be a number specifying an iterative computation along more than one measures for a data parallel task. For example an image processing task may be associated with a dimension of 2 along an image width and an image height.

At block according to one embodiment the processing logic of process may determine a total number of threads to execute in parallel among multiple compute units one or more executable codes or compute kernels compiled from a single source to accomplish a data parallel task or function . The processing logic of process may receive an API request from an application running in a host processor or host processing unit such as applications in hosting systems of . An API request may include a global thread number having a multi dimensional value as an array of N integers G G . . . G . Integer N may be a dimension associated with the data parallel task. The processing logic of process may count the number of integers in an array from a multi dimensional value to determine a dimension. In response to the API request the processing logic of process may determine the total number of threads that will execute the executable codes among the multiple compute units according to a product of N integers as G G. . . G.

In one embodiment the processing logic of process may verify whether a local thread group number has been specified at block . A local thread group number may have a multi dimensional value specified as an array of N integers L L . . . L . In one embodiment the dimension of a local thread group number may be equal to the dimension of a total thread number for performing a data parallel task. The processing logic of process may retrieve a local thread group number from a program kernel object which is associated with a source code and or an executable code compiled from the source code for a target compute unit. In one embodiment a local thread group number may be specified using APIs to compile a source code. If a local thread group number can be retrieved the processing logic of process may verify the local thread group number has already been specified. In some embodiments a local thread group number may be specified using an API request from an application running in a hosting processor. An API request may include both a multi dimensional global thread number and a multi dimensional local thread group number.

At block if a local thread group number has been specified the processing logic of process may designate a thread group size for a compute unit according the specified local thread group number. In one embodiment a thread group size corresponding to a local thread group number having a multi dimensional value L L . . . L may be equal to a product of N integers as L L . . . L. Executable codes compiled for different compute units may be associated with different local thread group numbers. If a local thread group number has been specified for an executable code the processing logic of process may designate thread group sizes according to determined optimal thread group sizes for multiple compute units such as for example based on the determination of optimal thread group sizes at block .

The processing logic of process may check the designated thread group sizes against allowable thread group sizes during run time for the target compute units. For example a compute unit may be limited by a maximum runtime thread group size depending on available resources. The processing logic of process may adjust designated thread group sizes to satisfy the runtime resource constraints of targeting computing devices. In some embodiment the processing logic of process may perform the determination to identify optimal thread group sizes at block when a multi dimensional local thread group number has not been specified.

At block the processing logic of process may partition the total number of threads according to thread group sizes to execute concurrently in multiple compute units for a data parallel task. An executable code may execute in parallel in a compute unit as a group of threads having a size equal to the corresponding thread group size. The size of a group of threads may be the number of threads in the group. The processing logic of process may decompose a data parallel task into appropriate multi dimensional blocks or thread groups that can be executed concurrently across one or more compute units.

In one embodiment a thread that executes an executable code may be identified by two distinct thread variables a global thread ID identifier and a local thread ID. A global thread ID may be specified with a multi dimensional value starting at 0 0 . . . 0 and goes to G 1 G 1 . . . G 1 based on a global thread number G G . . . G . Similarly a local thread ID may be specified with a multi dimensional value starting at 0 0 . . . 0 and goes to L 1 L 1 . . . L 1 based on a local thread group number L L . . . L . A global thread ID and a local thread ID for a thread may be multi dimensional values of the same dimension.

At block process A may store the source code of the API function into an API library with corresponding executables compiled for the designated target physical computing devices. One or more API functions for a single executable may be exported from an API library to accommodate source codes of host applications such as applications of running in a host processor. For example an application may execute executable codes or compute kernel using OpenCL API as a regular C function call. In one embodiment each executable may be stored with description data including for example the type version and vendor of the target physical computing device and or compilation options. The description data may be retrieved by a process during run time such as process of .

Turning now to processing operations to allocate and load array memory objects may be performed by the processing logic of process at block of . The processing operation to create a compute program object may be performed by the processing logic of process at block of . Processing operation may load a compute program source such as example of to the compute program object created. Processing operation may explicitly build a compute program executable from the loaded compute program source. In one embodiment processing operation may load an already built compute program executable to the created compute program object. Subsequently processing operation may create a compute kernel object pointing to the built compute program executable for scheduling an execution on a computing device.

Turing now to in one embodiment processing operation may attach variables and compute memory objects as function arguments for the created compute kernel object. Processing operation may be performed by the processing logic of process at block of . Processing operation may execute the created compute kernel object. In one embodiment processing operation may be performed by the processing logic of process at block of . Processing operation may cause an execution queue to be updated with a compute kernel execution instance corresponding to the created compute kernel object. Processing operation may synchronously wait for a completion of executing the create compute kernel object. In one embodiment processing operation may retrieve a result from executing the compute kernel object. Subsequently processing operations may clean up allocated resources for executing the compute kernel object such as an event object the created compute kernel object and the allocated memories. In one embodiment processing operation may be performed asynchronously based on whether a kernel event object is set. Processing operation may be performed by process at block of .

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s such as CPUs and or GPUs a ROM Read Only Memory volatile RAM and a non volatile memory . The microprocessor may retrieve the instructions from the memories and execute the instructions using Cache to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory. The display controller coupled with a display device may optionally include one or more GPUs to process display data. Optionally GPU memory may be provided to support GPUs included in the display device .

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless networking interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

An article of manufacture may be used to store program code for example including multiple tokens. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. using a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

