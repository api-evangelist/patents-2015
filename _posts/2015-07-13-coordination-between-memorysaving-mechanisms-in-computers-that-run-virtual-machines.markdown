---

title: Coordination between memory-saving mechanisms in computers that run virtual machines
abstract: A method includes running in a computer a hypervisor that allocates physical memory pages of the computer to a Virtual Machine (VM). A guest Operating System (OS), a virtual memory and a virtual storage device run in the VM. The guest OS maps the allocated physical memory pages to respective virtual memory pages, retains virtual memory pages that are frequently-accessed by the VM in the virtual memory, and swaps-out virtual memory pages that are rarely-accessed by the VM to the virtual storage. In the hypervisor, one or more of the physical memory pages allocated to the VM are selected, and the corresponding virtual memory pages preventing from being swapped-out by the guest OS, by marking the corresponding virtual memory pages in the guest OS as accessed thus causing the guest OS to regard the corresponding virtual memory pages as frequently-accessed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09390028&OS=09390028&RS=09390028
owner: STRATO SCALE LTD.
number: 09390028
owner_city: Herzlia
owner_country: IL
publication_date: 20150713
---
This application claims the benefit of U.S. Provisional Patent Application 62 065 688 filed Oct. 19 2014 whose disclosure is incorporated herein by reference.

The present invention relates generally to computer memory management and particularly to methods and systems for memory management in computers that run Virtual Machines VMs .

Computers that run Virtual Machines VMs employ various mechanisms for making efficient use of memory. Some commonly used mechanisms comprise for example deduplication ballooning host swapping and guest swapping. Some mechanisms are typically carried out by the computer hypervisor whereas other mechanisms are typically carried out by the VM guest Operating System OS .

An embodiment of the present invention that is described herein provides a method including running in a computer a hypervisor that allocates physical memory pages of the computer to a Virtual Machine VM . A guest Operating System OS a virtual memory and a virtual storage device run in the VM. The guest OS maps the allocated physical memory pages to respective virtual memory pages retains virtual memory pages that are frequently accessed by the VM in the virtual memory and swaps out virtual memory pages that are rarely accessed by the VM to the virtual storage. In the hypervisor one or more of the physical memory pages allocated to the VM are selected and the corresponding virtual memory pages preventing from being swapped out by the guest OS by marking the corresponding virtual memory pages in the guest OS as accessed thus causing the guest OS to regard the corresponding virtual memory pages as frequently accessed.

In some embodiments marking the virtual memory pages as accessed includes causing the guest OS to regard at least one virtual memory page as frequently accessed even though the virtual memory page is rarely accessed. In an embodiment selecting the physical memory pages includes selecting at least one physical memory page that was deduplicated by the hypervisor. Additionally or alternatively selecting the physical memory pages includes selecting at least one physical memory page that was swapped out by the hypervisor from a physical memory of the computer to a physical non volatile storage device of the computer.

In some embodiments marking the virtual memory pages as accessed includes modifying by the hypervisor page access information maintained by the guest OS. In alternative embodiments marking the virtual memory pages as accessed includes reporting the selected physical memory pages to a driver running in the VM and marking the virtual memory pages as accessed by the driver. Marking the virtual memory pages as accessed may include modifying by the driver page access information maintained by the guest OS. Alternatively marking the virtual memory pages as accessed may include accessing the virtual memory pages by the driver.

There is additionally provided in accordance with an embodiment of the present invention a computer including a physical memory and a Central Processing Unit CPU . The CPU is configured to run a hypervisor that allocates physical memory pages of the physical memory to a Virtual Machine VM to run in the VM a guest Operating System OS a virtual memory and a virtual storage device wherein the guest OS maps the allocated physical memory pages to respective virtual memory pages retains virtual memory pages that are frequently accessed by the VM in the virtual memory and swaps out virtual memory pages that are rarely accessed by the VM to the virtual storage to select by the hypervisor one or more of the physical memory pages allocated to the VM and to prevent the corresponding virtual memory pages from being swapped out by the guest OS by marking the corresponding virtual memory pages in the guest OS as accessed thus causing the guest OS to regard the corresponding virtual memory pages as frequently accessed.

There is also provided in accordance with an embodiment of the present invention a computer software product the product including a tangible non transitory computer readable medium in which program instructions are stored which instructions when read by a Central Processing Unit CPU of a computer cause the processor to run a hypervisor that allocates physical memory pages of a physical memory of the computer to a Virtual Machine VM to run in the VM a guest Operating System OS a virtual memory and a virtual storage device wherein the guest OS maps the allocated physical memory pages to respective virtual memory pages retains virtual memory pages that are frequently accessed by the VM in the virtual memory and swaps out virtual memory pages that are rarely accessed by the VM to the virtual storage to select by the hypervisor one or more of the physical memory pages allocated to the VM and to prevent the corresponding virtual memory pages from being swapped out by the guest OS by marking the corresponding virtual memory pages in the guest OS as accessed thus causing the guest OS to regard the corresponding virtual memory pages as frequently accessed.

The present invention will be more fully understood from the following detailed description of the embodiments thereof taken together with the drawings in which 

Embodiments of the present invention that are described herein provide improved methods and systems for making efficient use of a computer s memory resources. In some embodiments a computer runs a hypervisor that allocates physical resources of the computer to one or more Virtual Machines VMs . In particular the hypervisor allocates physical memory pages of the computer s physical memory to a VM and the VM maps the allocated physical memory pages to respective virtual memory pages also referred to as guest pages or guest physical pages in the VM s address space.

In general both the computer s hypervisor and the VM s guest Operating System OS may deploy various mechanisms for saving memory. For example the hypervisor may identify and deduplicate physical memory pages having identical content and or swap out rarely accessed physical memory pages to physical disk. The VM s guest OS may swap out rarely accessed virtual memory pages to its virtual disk. The VM may also lend memory pages to the hypervisor in a process referred to as ballooning.

Each of the memory saving mechanisms described above is highly effective when deployed individually. When two or more of these mechanisms are deployed at the same time however they may conflict with one another. Such conflicts may degrade the net memory saving or degrade the overall performance of the system. Conflicts are likely to occur for example when the hypervisor and the guest OS apply memory saving mechanisms to the same memory pages without coordination. In some embodiments of the present invention the hypervisor avoids such conflicts by enforcing coordination between the memory saving mechanisms deployed by the hypervisor and those deployed by the VM s guest OS without requiring modifications in the guest OS.

In some embodiments the hypervisor selects one or more physical memory pages that were allocated to a VM and decides that the corresponding virtual memory pages should not be swapped out by the VM. The selected physical memory pages may comprise for example pages that were swapped out or deduplicated by the hypervisor. The hypervisor causes the selected memory pages to be marked in the guest OS as frequently accessed regardless of their actual access frequency. As a result the guest OS will typically refrain from swapping out the memory pages in question.

The hypervisor may use various techniques to mark memory pages as frequently accessed in the guest OS. In some embodiments the guest OS maintains a data structure referred to as a page table. Among other attributes the page table holds a respective access bit that is used by the guest OS to classify each memory page allocated to the VM as frequently accessed by the VM or rarely accessed by the VM. In an example embodiment the hypervisor accesses the guest OS page table directly and sets the access bits of the selected memory pages in a manner that causes the guest OS to regard these memory pages as frequently accessed by the VM. 

Alternatively the hypervisor may communicate with a driver running in the guest OS e.g. a ballooning driver and notify the driver of the selected memory pages. The driver may in turn mark the memory pages in question as accessed in the page table or simply access the memory pages so as to cause the guest OS to mark them as accessed. In either case this marking again causes the guest OS to regard the memory pages in question as frequently accessed by the VM. 

By enforcing coordination between the memory saving mechanisms deployed by the hypervisor and the guest OS the disclosed techniques prevent conflicts that degrade the net memory saving and performance. As a result the computer may host a larger number of VMs run larger and more complex VMs and improve performance.

In the embodiment of computer comprises a Central Processing Unit CPU a volatile memory and a non volatile storage device . Volatile memory is also referred to as Random Access Memory RAM physical RAM or physical memory and non volatile storage device is also referred to as a physical disk. Computer may also comprise other elements such as a physical Network Interface Card NIC for connecting to a computer network.

CPU runs a virtualization layer referred to as a hypervisor which allocates physical resources of computer to one or more Virtual Machines VMs . Physical resources may comprise for example CPU resources volatile memory e.g. physical RAM resources non volatile storage e.g. physical disk resources and networking resources.

The internal VM structure is shown in only for one of VMs for the sake of clarity. Generally however the other VMs have similar internal structures. Typically each VM emulates a respective physical machine. In the present example each VM runs a virtual CPU VCPU not shown in the figure that in turn runs a virtual operating system OS referred to as a guest OS . The VM further comprises a virtual RAM VRAM that emulates a physical volatile memory and a virtual disk VDISK that emulates a physical non volatile storage device.

In some embodiments guest OS maintains a page table that holds information regarding physical memory pages that were assigned to the VM. The information may comprise for example a mapping from virtual addresses to physical addresses in the guest OS address space Guest Virtual Addresses GVA to Guest Physical Addresses GPA . The pages in the VM address space are also referred to as Guest Frame Numbers GFN .

In addition page table typically holds page access information i.e. information indicative of which of the allocated memory pages are accessed by the VM. In the present example the page access information comprises a respective access bit that is set by the VCPU whenever the page is accessed and is reset periodically by the guest OS. The access is bit thus indicative of whether the corresponding memory page is frequently accessed or rarely accessed by the VM. Alternatively any other suitable type of page access information may be used. Guest OS may use any suitable techniques for defining and updating the page access information of the various memory pages.

Guest OS may also run a balloon driver also referred to as a para virtual driver which is used for temporarily lending back to the hypervisor memory pages that have been allocated to the VM. The functions of driver are addressed in greater detail below.

The configurations of computer and VMs shown in are example configurations that are chosen purely for the sake of conceptual clarity. In alternative embodiments any other suitable configurations can be used. RAM may comprise any suitable number and types of volatile memory devices such as one or more Dynamic RAM DRAM or Static RAM SRAM devices. Physical disk may comprise any suitable number and types of non volatile storage devices such as one or more Solid State Disks SSDs or Hard Disk Drives HDDs .

The disclosed techniques are typically implemented in software but may also be implemented in hardware or using a combination of software and hardware elements. Typically CPU comprises one or more general purpose processors which are programmed in software to carry out the functions described herein. The software or components thereof e.g. hypervisor VM software guest OS or other software components may be downloaded to the processors in electronic form over a network for example or it may alternatively or additionally be provided and or stored on non transitory tangible media such as magnetic optical or electronic memory.

Hypervisor and guest OS may run various mechanisms for making efficient use of physical memory . Example memory saving mechanisms outlined below are referred to as deduplication ballooning host swapping and guest swapping.

In a typical deduplication mechanism hypervisor identifies physical memory pages in the hypervisor s physical address space having identical content. Such duplicate memory pages may be identified both per VM and across different VMs. Upon identifying a group of duplicate pages the hypervisor retains only a single instance of the content in RAM . The deduplicated page is write protected. If a VM attempts to modify the content the hypervisor performs copy on write.

In a typical ballooning process hypervisor communicates with balloon driver in guest OS . Driver is able to temporarily allocate memory pages which were allocated to the VM back to the hypervisor. If the hypervisor is in temporary shortage of memory for example it may request memory pages from ballooning driver . In response driver requests and receives memory page allocations from guest OS using the guest OS memory management Application Programming Interface API and transfers the memory page addresses e.g. GFNs to the hypervisor. The hypervisor then unmaps the corresponding physical memory pages so they cannot be read or written by the guest OS and may use these pages for any suitable purpose. The hypervisor returns memory pages to the VM by first mapping the physical memory to the guest OS physical addresses that were previously allocated by the balloon driver. The balloon driver then de allocates the corresponding page addresses e.g. GFNs using the guest OS memory management API. The pages are now again available for use by the guest OS.

In a typical host swapping process hypervisor copies the content of one or more physical memory pages which were allocated to one or more VMs from physical RAM to physical disk . The hypervisor then unmaps the guest pages so they cannot be read or written by the VMs. If a VM attempts to access a host swapped memory page whose content now resides on disk and not in RAM the VM VCPU will typically trap the hypervisor because the page was previously unmapped. In response the hypervisor will load the page content from disk place the content in a physical memory page in RAM map the guest page again and resume execution of the guest.

In a typical guest swapping process guest OS copies the content of one or more rarely accessed guest physical pages virtual memory pages from VRAM to a guest swap partition or file on VDISK emulated by the hypervisor . The guest OS can then use the swapped out pages to store data that is frequently accessed by the VM. The guest OS unmaps the virtual addresses pointing to the guest physical pages. Thus if these virtual addresses are accessed by some process in the VM the guest OS can load the content back from VDISK and map them back. The hypervisor is typically unaware of guest swapping and is usually not involved in this mechanism.

The four memory saving mechanisms described above are depicted purely by way of example. In alternative embodiments the hypervisor and or guest OS may implement these mechanisms in other suitable ways implement only a subset of these mechanisms and or implement any other suitable memory saving mechanism.

As noted above memory saving mechanisms may conflict with one another and cause performance degradation. Several non limiting examples of potential conflicts are outlined below.

Conflict between deduplication and guest swapping Consider a scenario in which hypervisor decides to deduplicate three physical memory pages denoted VM1.GFN1 VM1.GFN2 and VM3.GFN1. VM1.GFN1 and VM1.GFN2 have been allocated to a VM denoted VM1 VM3.GFN1 has been allocated to a VM denoted VM3 and all three pages were found to have the same content. In this example VM1.GFN1 is rarely accessed by VM1 and is therefore a good candidate for guest swapping by the guest OS of VM1. VM1.GFN2 and or VM3.GFN1 on the other hand are frequently accessed by their respective VMs.

If guest OS of VM1 decides to apply guest swapping VM1.GFN1 it will copy the content of VM1.GFN1 to VDISK of VM1 and use the page to hold other content. However because VM1.GFN1 was actually deduplicated in hypervisor with VM1.GFN2 and VM3.GFN1 the new content will force a copy on write by the hypervisor.

The hypervisor will thus be forced to allocate a new physical memory page in RAM for storing the new content of VM1.GFN1. The end result is an unnecessary waste of memory space in RAM because the guest OS of VM1 is unaware of the fact that it has guest swapped a memory page that was deduplicated by the hypervisor.

As noted above hypervisor is typically unaware of guest swapping and is not involved in this mechanism. However when the hypervisor uses ballooning it may indirectly cause the guest OS to perform guest swapping. For example when requested by hypervisor balloon driver will attempt to allocate pinned pages back to the hypervisor. If VRAM does not contain a sufficient number of free memory pages to serve this request the guest OS may decide to apply guest swapping to rarely accessed or cache memory. This sequence of events gives rise to the above described conflict between deduplication and guest swapping.

Conflict between host swapping and guest swapping Consider a scenario in which a page VM1.GFN1 is accessed rarely. Therefore hypervisor decides to apply host swapping to this page i.e. move its content from RAM to disk . VM1 is unaware that this page was swapped out by the hypervisor. Therefore if memory pressure develops in VM1 the guest OS of VM1 may decide to apply guest swapping to VM1.GFN1 because it is rarely accessed .

In such a case the guest OS will try to read VM1.GFN1 and store it in its swap partition disk in VDISK . This attempt will force the hypervisor to load the content of VM1.GFN1 back from disk into RAM and then the guest OS will copy the content from VRAM to VDISK . This problem referred to as double swapping occurs because guest OS is unaware host swapping by hypervisor .

In other cases VM1.GFN may be actually used to cache data that is stored on disk and the guest OS will not actually read the content because it can simply discard it. However the guest OS will still overwrite the content write to VM1.GFN to store frequently accessed data. Thus the guest OS will still force the hypervisor to load VM1.GFN into RAM while in fact the content of VM1.GFN can be discarded.

As noted above the hypervisor is typically unaware of guest swapping and is not involved in this mechanism. Nevertheless when the hypervisor uses ballooning it may indirectly cause the guest OS to perform guest swapping. For example when requested balloon driver will try to allocate pinned pages back to the hypervisor. If VRAM does not contain a sufficient number of free memory pages to serve this request the guest OS may decide to apply guest swapping to rarely accessed or cache memory. This sequence of events gives rise to the above described conflict between host swapping and guest swapping.

The four example conflicts described above are depicted purely by way of example. Additionally or alternatively various other conflicts may arise between memory saving mechanisms and various other such conflicts may be resolved or avoided by the disclosed techniques.

In some embodiments of the present invention hypervisor avoids conflicts between memory saving mechanisms by enforcing coordination between the memory saving mechanisms deployed by hypervisor and those deployed by the VM s guest OS .

In some embodiments hypervisor selects one or more physical memory pages that were allocated to a certain VM and decides that the corresponding virtual memory pages should not undergo guest swapping by guest OS of the VM. The selected physical memory pages may comprise for example pages that underwent host swapping or deduplication by hypervisor . Hypervisor causes the selected memory pages to be regarded by guest OS as frequently accessed regardless of their actual access frequency. As a result the guest OS will typically refrain from applying guest swapping to the memory pages in question.

At a page table accessing step hypervisor accesses page table directly in the internal memory of guest OS . Hypervisor sets the access bits of the host swapped and or deduplicated memory pages to indicate accessed. This setting is performed regardless of whether the memory pages in question are indeed frequently accessed or not. By marking memory pages as accessed in the page table the hypervisor causes the guest OS to regard them as frequently accessed by the VM even though they may not be. Thus at least in some cases the hypervisor causes the guest OS to regard a memory page as frequently accessed by the VM even though in reality the page is rarely accessed by the VM.

Hypervisor may access page table directly since the table is physically stored in memory pages in RAM that were allocated to VM . The hypervisor may for example access a control register e.g. CR3 in the 86 architecture that points to the page tables. Since the page table maps virtual addresses to physical addresses finding the appropriate page table entries to modify may involve reverse traversal of the table.

As a result of the hypervisor setting the access bits of the selected memory pages to accessed guest OS typically refrains from applying guest swapping to these memory pages at a guest OS operation step .

In the present embodiment however the hypervisor does not access page table directly. Instead at a reporting step the hypervisor notifies balloon driver of the host swapped and or deduplicated memory pages.

In response balloon driver marks the memory pages in question in the page table as accessed at a driver marking step . Alternatively the balloon driver may access e.g. read the memory pages which in turn causes the guest OS to mark them in the page table as accessed. As a result guest OS typically refrains from applying guest swapping to the marked memory pages at a guest operation step .

The examples above refer to a specific structure of page table purely by way of example. In alternative embodiments the hypervisor may modify or cause the guest OS to modify any other suitable page access information stored in the guest OS in any suitable way.

It will thus be appreciated that the embodiments described above are cited by way of example and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather the scope of the present invention includes both combinations and sub combinations of the various features described hereinabove as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art. Documents incorporated by reference in the present patent application are to be considered an integral part of the application except that to the extent any terms are defined in these incorporated documents in a manner that conflicts with the definitions made explicitly or implicitly in the present specification only the definitions in the present specification should be considered.

