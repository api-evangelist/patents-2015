---

title: Function-based action sequence derivation for personal assistant system
abstract: A method is provided for recommending a desired func sequence to a user. The method includes obtaining a user intention list including at least one user intention; separating the user intention into a plurality of tasks; and creating a task flow graph for the plurality of tasks based on user usage data. Each vertex in the task flow graph represents a task and indicating an importance of the task. The method also includes creating a func flow graph based on the user usage data and temporal sequences of the tasks and funcs, and each vertex in the func flow graph represents a func and indicating an importance of the func. Further, the method includes determining a desired func sequence to fulfill the user intention based on the user usage data, the task flow graph, and the func flow graph; and recommending the desired func sequence to the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619283&OS=09619283&RS=09619283
owner: TCL RESEARCH AMERICA INC.
number: 09619283
owner_city: San Jose
owner_country: US
publication_date: 20150728
---
The present invention generally relates to the field of information technology and user interface technologies and more particularly to methods and systems for user recommendation based on function.

The number of apps short for applications has grown exponentially. It becomes more challenging to help users manage the apps and better assist them to fulfill their intention with these apps. Instead of providing only one entry to an entire app more app companies are opening up their APIs to allow a third party to have access to the functions in apps instead of the app as a whole. For example when a user queries a search engine with Panda Express the search engine may offer the Panda Express page in Yelp instead of providing the entry to Yelp. Another example of accessing to function is when users take a photo the users don t have to navigate through the WeChat entry and the search engine will provide us with the exact take photo page in WeChat. Thus functions can be both informational and functional.

However although the direct access to functions can potentially bring convenience to users the tremendous number of functions makes it very hard to perform. Further the existing recommendation systems often only recommend a single function page or an app which makes it even harder for the user to find desired apps. The disclosed methods and systems are directed to solve one or more problems set forth above and other problems.

One aspect of the present disclosure includes a method for recommending a desired func sequence to a user. The method includes obtaining a user intention list including at least one user intention separating the user intention into a plurality of tasks and creating a task flow graph for the plurality of tasks based on user usage data. Each vertex in the task flow graph represents a task and indicating an importance of the task. The method also includes creating a func flow graph based on the user usage data and temporal sequences of the tasks and funcs and each vertex in the func flow graph represents a func and indicating an importance of the func. Further the method includes determining a desired func sequence to fulfil the user intention based on the user usage data the task flow graph and the func flow graph and recommending the desired func sequence to the user.

Another aspect of the present disclosure includes a system for recommending a desired func sequence to a user. The system includes at least a memory for storing user usage data and a processor coupled to the memory. The processor is configured to obtain a user intention list including at least one user intention to separate the user intention into a plurality of tasks and to create a task flow graph for the plurality of tasks based on the user usage data. Each vertex in the task flow graph represents a task and indicating an importance of the task. The processor is also configured to create a func flow graph based on the user usage data and temporal sequences of the tasks and funcs with each vertex in the func flow graph representing a func and indicating an importance of the func to determine a desired func sequence to fulfil the user intention based on the user usage data the task flow graph and the func flow graph and to recommend the desired func sequence to the user.

Other aspects of the present disclosure can be understood by those skilled in the art in light of the description the claims and the drawings of the present disclosure.

Reference will now be made in detail to exemplary embodiments of the invention which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

According to the present disclosure one approach to resolve the difficulty facing a large number of functions is to favor more frequently used functions and to analyze the function usage pattern of large population of users to build ordered structure for the available functions.

Further for most of the time a user intention is often fulfilled by a function sequence instead of a single function. For example when a user requests I want to eat at Red Lobster an ideal recommendation would be a function sequence the OpenTable app to make seat reservation the Uber app to make request to that specific place and then the Yelp app to review page. That is a function sequence over different apps instead of a single function or a single app may be desired to satisfy the user intention.

Accordingly the present disclosure provides a function sequence recommendation model for deriving and ranking the function sequences based on the user text request and for recommending the user the desired or optimal function sequence to fulfill the user intention. The function sequence recommendation model can also be called FuncRank in short. More specifically based on a function flow network of the user navigation history the recommendation model may first compute a function importance model across the function flow network and then to derive an optimal function sequence based on the generated function importance model and graph theoretical algorithms.

Terminal also known as the terminal device may refer to any appropriate user terminal with certain computing capabilities such as a personal computer PC a work station computer a server computer a hand held computing device tablet a smartphone or mobile phone or any other user side computing device. In certain embodiments terminal may be a mobile terminal device such as a smartphone a tablet computer or a mobile phone etc. Terminal may be implemented on any appropriate computing platform. Terminal may be used by user to connect to network and make requests to server . The terminal may obtain webpages from any appropriate sources such as from a local storage device from a wired or wireless network device of a service provider or from the Internet.

Further the server may refer to one or more server computers configured to provide certain web server functionalities e.g. search server . The server may include one or more processors to execute computer programs in parallel. The server may store webpages to be access by terminals and each of these webpages has a unique web address. The unique web address is also called Uniform Resource Locator URL . The server may also provide various apps to the terminal as requested by the user and or may make various recommendations to the user about the web pages and or apps and app functions. The server may also be a cloud server.

Terminal and server may communicate with each other through communication network such as a cable network a phone network and or a satellite network etc. Although one terminal and one server are shown in any number of terminals and or network devices may be included.

Terminal and or network device may be implemented on any appropriate computing circuitry platform. shows a block diagram of an exemplary computing system capable of implementing terminal and or server .

As shown in computing system may include a processor a storage medium a display a communication module a database and peripherals . Certain devices may be omitted and other devices may be included.

Processor may include any appropriate processor or processors. Further processor can include multiple cores for multi thread or parallel processing. Storage medium may include memory modules such as ROM RAM flash memory modules and mass storages such as CD ROM and hard disk etc. Storage medium may store computer programs for implementing various processes when the computer programs are executed by processor .

Further peripherals may include various sensors and other I O devices such as keyboard and mouse and communication module may include certain network interface devices for establishing connections through communication networks. Database may include one or more databases for storing certain data and for performing certain operations on the stored data such as database searching.

In operation user may through terminal or a browser on terminal intend to use certain applications apps or mobile apps available on the terminal or online from various servers. A mobile app may have a home page or other direct access point that may be used to achieve a certain function. The mobile app access point may include an entrance to the function on the mobile device or web a type of the function and other relevant information such as location status and nature of the function etc. The function may include a native mobile app a web app and a customized function as a cloud application programming interface API .

A native mobile app may refer to a mobile device application that is coded in a specific programming language for a particular operating system. The native mobile app is installed directly on a mobile device. A web app may refer to a website that is tailored to function via a web browser on a mobile device. The entrance to function and the type of the entrance may include a variety of configurations. For example an access point may include a link to a web app page a link to a customized function a link or shortcut to an installed native app page a link to a page of a compressed version of a native app a link to the action of native app download and installation and a link to an app guideline page that suggests the user to open an alternative app etc.

For the sake of convenience the term FUNC or func may be used to represent the access point of an app i.e. a function of the app. Each func may be a function level operation flow which is associated with a function or service that satisfies a user s specific need. For a same need different users may use different func in different mobile apps for example a user may use Facebook to share a picture and another user may use WeChat for the same purpose according to the user s habits or preferences. Because the func provides an entrance to a native app a web app or a customized function the func may be used to make transition from one mobile app to the other mobile app to achieve a function sequence.

Based on the func concept a functional flow of user s action can be built up more smoothly without using the app level operations. The app level operations refer to certain operations that are performed among multiple mobile apps or web services by frequently using the home page and thus more user interactions screen touches or key presses may be required and it may be more difficult to implement a function sequence.

Further server may provide a FuncRank recommendation system based on the FuncRank recommendation model i.e. a recommendation model ranking the importance of the function to make app recommendations to the user to fulfil a user request or inquiry. illustrates an exemplary FuncRank recommendation system .

As shown in the FuncRank recommendation system may include an input module a user intention deduction module a FuncRank recommendation module and an output module . Other modules may also be included.

The input module may be provided to obtain a user request for apps to provide certain needs or functions or to receive a user inquiry for apps to provide the certain needs or functions. The request or inquiry may be in any appropriate format such as text format voice format image format etc. The user intention deduction module may be configured to take the user request e.g. a text request as input and output an intention list to be fed into the FuncRank recommendation module .

Further the FuncRank recommendation module may be configured to receive the user intention list as an input and to derive and rank func sequences to fulfill the user intention. The output module may be configured to present the ranked func sequences to the user. For example the output module may recommend the ranked func sequences to the user by display the recommendations on the browser or other places on the display screen of the terminal . The output module may also provide the ranked func sequences to another application program for further processing.

The FuncRank recommendation module may include a FuncRank model a personalized graph based ranking algorithm to derive and rank the func sequences given the user intention list. The personalized top ranked func sequences may then be recommended to users to fulfill their intention. In other words instead of ranking individual apps the FuncRank model derives and ranks the func sequences thus providing users with a personalized solution to meet their personal need.

Further the user intention may be separated into a plurality of tasks which is a basic unit in fulfilling a user intention . When the intention list includes more than one intentions each intention may be processed independently and the processing results for each intention may be combined at the end of the processing. For example a sequence of intentions deduced from user text request may be inputted to the FuncRank recommendation model.

The tasks for an intention may be predefined or may be defined in real time. Also the predefined tasks may be a fixed number of tasks or may be variable number of tasks to be combined for a particular intention. In other words for each intention the tasks to fulfill each intention have been pre defined. For example the cooking at home is an intention. To fulfill this intention the tasks may include find a supermarket go to the supermarket buy the material pay go home find recipe prepare food and cooking .

Although the plurality of tasks are pre defined no particular order or sequence may be defined regarding the plurality of tasks. Thus there may be multiple task sequences to fulfill each intention. That is the plurality of tasks may implement multiple task sequences.

Each task can be implemented by one func or different funcs while each func can fulfill one task or a set of tasks. For example taking photo is a task and can be implemented by taking photo function page either in WeChat or in Poco Food Camera . Also for example while Panda Express page in Yelp is a func fulfilling both tasks of dish review and find the address . Therefore each intention is fulfilled by a set of tasks while each task can be implemented by various funcs.

Thus by driving task sequences based on the user intention the func sequences can also be derived based on the user intention. For example the user log may include temporal sequences of tasks and funcs that users choose to fulfill the tasks. Further such deriving process may also be a continuous or active learning process. The more frequently the funcs and tasks are visited by the user the more popular and important the funcs and tasks may become. The task and func importance learning is an active learning process and the FuncRank recommendation module may use a user log to record users and the tasks and corresponding funcs used by the user. illustrates an exemplary user log.

As shown in User used task and corresponding func tasks and corresponding func and task and corresponding func etc. User used task and corresponding func task and corresponding func task and corresponding func etc.

Thus during the learning process of the FuncRank model it may start with limited user selected funcs and tasks traversal links more real user usage data is then obtained from the user log as shown in . The real usage data is then fed into the learning process for more accurate personalization.

Returning to after the intention is separated into tasks a func flow graph may be created for modeling based on user usage data . illustrates an exemplary func flow graph for a user intention related to for example going out to a restaurant. The func flow graph may be created based on user usage data such as user history browsing navigation history and user selection history etc. For example the func flow graph may be created based on the user log shown in .

The user log may include temporal sequences of tasks and funcs users choose to fulfill the tasks. The func importance can then be derived from the user log and the task importance can be derived similarly.

As shown in from the user log the func flow graph may be first constructed. In func flow graph each vertex is a func and funcs are linked to each other if a traversal from one to another has been found consecutively in the user log. The funcs in the func flow graph corresponding to the tasks associated with the user intention. The edge weight is the total count of traversal record which may be obtained from the user log. Two funcs are consecutive if they happened in sequential order in a user log and within a certain time duration.

After the func flow graph is constructed the func importance may be derived based on the func flow graph using a graph based ranking algorithm. The traversal frequency may be taken into consideration in the ranking algorithm. illustrates an exemplary graph based ranking algorithm.

Because different users may have different navigation preference among funcs both the general and personal weights are included to enable personalization. As shown in the general and personal weights are denoted as wand w respectively.

The personalized func importance may be defined as follows. Let F be the func set and T be the task set. F is the number of funcs and T is the number of tasks. For each func F T f denotes all the tasks that f can fulfill and for each task t T F t denotes all the possible funcs that can implement the task.

For each func F let Prev f be the set of funcs that precede f in user log and Post f be the set of the funcs that follow f. Let wand wbe the general and personal traversal frequency from func to func . The func importance FR may be defined as 

Where 0 1 determined by empirical experience and set by default or by the user. The task traversal frequency from the user log is used to enhance recommendation accuracy and the func importance calculation is personalized through which decides how much the personal preference can influence the final result. The func importance is record in each vertex and the task can be implemented by the func is also included as the parenthesis text in the vertex.

Similarly the personalized task flow graph and the personalized task importance may also be learned or derived for all the tasks associated with the user intention . For each task t T let Prev t be the set of tasks that precede t in user log and Post t be the set of the tasks that follow t. Let

Where 0 1 determined by empirical experience and set by default or by the user. illustrates an exemplary learned task flow graph. As shown in each vertex represent a task and the task importance is indicated as the number in each vertex. The task traversal frequency is also shown between different tasks and such weights of edges of task flow graph can be obtained from the user log. That is in task flow graph each vertex is a task and tasks are linked to each other if a traversal from one to another has been found consecutively in the user log. The edge weight is the total count of traversal record which may be obtained from the user log. Two tasks are consecutive if they happened in sequential order in a user log and within a certain time duration.

Returning to based on the user intention list obtained from the user intention deduction module and the func and task flow graphs the ranked func sequence may be generated . Specifically the ranked func sequences may be generated by two parts task sequence mining and func sequence generation based on the func and task importance.

That is based on the intention list and the task flow graph each intention specific task sequences may be mined e.g. data mined through a predetermined algorithm such as an Extended Floyd Algorithm and mined results may be put together to form the overall task sequences for the intention list. and illustrate exemplary task sequence mining and the ranked task sequence generation.

As shown in the user intention list includes two intentions intention I and intention I . The intention specific task sets can be obtained from predefined task set not ordered . For example for intention I the task set is task T task T and task T e.g. I has T T T and for intention I the task set is task T task T task T and task T e.g. I has T T T T.

Further based on the user log the possible starting point and ending point of tasks associated with user intention may be generated. For example for user intention I the starting point is T and the ending point is T and for user intention I the starting points are T and T and the ending point is T.

Further the task flow graph is analyzed and a sub graph including the tasks associated with the user intention may be generated with the starting point and the ending point. The sub graph may include only the points of relevant tasks. For example for user intention I the sub graph is generated to include the starting point T point T and the ending point T and for user intention I the sub graph is generated to include the starting points T and T point T and the ending point T.

In the task flow graph or sub graph corresponding to the user intention the edge weight may be defined as log 1 w . Provided that p S E is defined to be a set of paths for a fixed pair of starting point S and ending point E the goal is to find the optimal path p S E that maximize the multiplied traverse probability of all the segments in the path that is

Hence the problem of finding the most probable path can be mapped to finding the shortest path because the exponential function is monotonic which can be solved by e.g. a Floyd Warshall algorithm.

As shown in in this process the most probable task sequences for each of the pair of starting and ending tasks may be determined based on the score of the possible task sequences i.e. probability score . That is the possible task sequences and associated score may be obtained and the optimal task sequence with the highest probability for this specific pair of starting and ending tasks is chosen. In other words for each pair of starting and ending points in the sub graph an optimal path may be determined. For example for the sub graph of the user intention I two possible task sequences are used T and T and T T and T with scores of 0.8 and 0.2 respectively and the task sequence T and T is chosen.

For the sub graph of the user intention I four possible task sequences are used T T and T with a score of 0.8 T and T with a score of 0.4 T T and T with scores of 0.2 and T T and T with a score of 0.1 and the task sequences T T and T and T and T are chosen i.e. task sequences with a score greater than a predetermined threshold .

Further the result of the process is constructed by assembling each of the optimal task sequence together. Thus the top two combined task sequences for the two intentions are T T T T and T with a score of 1.6 and T T T and T with a score of 1.2.

Returning to after the desired task sequence is determined the most likely corresponding func sequence may also be determined . For example a Viterbi Algorithm may be used to determine the most likely sequence of underlying hidden states from an observation states in time order. illustrates an exemplary derivation process.

As shown in the observation states may be the tasks while the hidden states are the funcs. Let t t t . . . t denote the observation states i.e. tasks and f f f . . . f denote the hidden states i.e. funcs the transition probability from fto f m n 1 F can be calculated as 3 

Returning to after the desired func sequence is derived the func sequence or a number of funcs in the func sequence may be recommended to the user to resolve the current needs of the user . Once the user selects the func sequence the system may automatically execute the func sequence including direct transition from one func to another func. Or if the user selects a particular func or funcs the system may bring the func or funcs up. The selection of the user including the sequences used by the user may be logged in the user log and the FuncRank model may be adjusted periodically based on the user log to improve accuracy of the recommendation.

Thus by using the disclosed FuncRank model to derive and rank the func sequences according to user text request the capacity to automatically generate the optimal func sequences for recommendation can be established. Such approach builds upon user historical data for personalization of the func sequence derivation and an intermediate concept of task is used to bridge the gap between the user intention and final func sequences for recommendation which enables derivation of optimal func sequences through applications of desired algorithms including the Extended Floyd Algorithm and Viterbi algorithm.

Other steps may be referred to above descriptions with respect to the system for scalable user intent mining. Other applications advantages alternations modifications or equivalents to the disclosed embodiments are obvious to those skilled in the art.

