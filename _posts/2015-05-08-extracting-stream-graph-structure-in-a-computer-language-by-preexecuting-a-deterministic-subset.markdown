---

title: Extracting stream graph structure in a computer language by pre-executing a deterministic subset
abstract: Compile-time recognition of graph structure where graph has arbitrary connectivity and is constructed using recursive computations is provided. In one aspect, the graph structure recognized at compile time may be duplicated at runtime and can then operate on runtime values not known at compile time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454350&OS=09454350&RS=09454350
owner: International Business Machines Corporation
number: 09454350
owner_city: Armonk
owner_country: US
publication_date: 20150508
---
The present application relates generally to computers and computer applications and more particularly to programming languages and compilers.

The end of frequency scaling has driven computer architects and developers to parallelism in search of performance improvements. Since multi core processors can be inefficient and power hungry many have turned to specialized accelerators including GPUs and other architectures such as programmable architecture. For example the importance of power dissipation makes the compilation of applications directly into reconfigurable hardware Field Programmable Gate Arrays FPGAs a potential commercial target. Compilation of applications on a wide scale requires leveraging the skills of current software developers. But there is a large gap between the abstractions presented by high level programming languages and those used in hardware design.

Reconfigurable hardware can deliver impressive performance for some applications when a highly static hardware design closely matches application logic. Obligated to express efficient static hardware structures hardware designers cannot currently employ abstractions using dynamic features of modern programming languages.

A method for extracting a stream graph for a hardware circuit from a program written in a programming language in one aspect may comprise receiving a program. The method may also comprise analyzing the program for one or more constructs in the programming language that builds the stream graph for programming the hardware circuit. A node in the stream graph represents a computation to be performed the computation expressed in the programming language. An edge in the stream graph represents data flowing from the node to another node in the stream graph. The method may also comprise outputting one or more artifacts representing the stream graph. The stream graph can be compiled for the hardware circuit to execute and produce a result with different node initialization values and different streaming data values that are presented in an execution of the program not known at compile time. The stream graph can be built using recursive computation and the connectivity of the stream graph can be arbitrary.

A system for extracting a stream graph for a hardware circuit from a program written in a programming language in one aspect may comprise a programming language compiler operable to execute on a processor and further operable to analyze a program for one or more constructs in the programming language that builds the stream graph for programming the hardware circuit a node in the stream graph representing a computation to be performed the computation expressed in the programming language and an edge in the stream graph representing data flowing from the node to another node in the stream graph. The programming language compiler may be further operable to output one or more artifacts representing the stream graph. The stream graph can be compiled for the hardware circuit to execute and produce a result with different node initialization values and different streaming data values that are presented in an execution of the program not known at compile time. The stream graph can be built using iterative computation and the connectivity of the stream graph can be arbitrary.

A computer readable storage medium storing a program of instructions executable by a machine to perform one or more methods described herein also may be provided.

Further features as well as the structure and operation of various embodiments are described in detail below with reference to the accompanying drawings. In the drawings like reference numbers indicate identical or functionally similar elements.

Designs for reconfigurable hardware may involve dataflow graphs also known as stream graphs . Each node of such graph encapsulates a computation and the nodes exchange data over wires and queues. In software languages like Java can be used to express what should happen inside the nodes. Such languages would also be usable to express all possible connections of nodes by simply making this interconnection executable delayed until runtime . However compilation to FPGAs in the near term is very time consuming and hence the graph structure should be known at compile time rather than at runtime.

A methodology and a system may be provided for design and implementation of new features in a programming language that admit construction of stream graphs of arbitrary shape using an imperative object oriented language. In such a programming language a programmer may mark computations destined for hardware and the compiler of the programming language statically checks these computations for repeatable structure. The repeatable structure may be extracted as the static structure needed for hardware synthesis.

A methodology in one embodiment of the present disclosure may analyze deterministic computations in a programming language. An example of a programming language is Lime Liquid Metal language . If all inputs to a deterministic computation are compile time constant the result of deterministic execution is repeatable. In one embodiment a methodology of the present disclosure may apply a process of ensuring and snippet evaluation to make a stream graph structure for hardware design available for ahead of time compilation. Ensuring may include checking the stream graph construction for repeatability. Snippet evaluation compile time evaluation of portions of the program may be applied to ensured stream graph construction expressions to find the necessary information to drive ahead of time compilation. A methodology of the present disclosure in one embodiment may also improve the kinds of stream graphs that can be extracted by relaxing the repeatability requirement so that each node of the graph can have an initialization expression that is not repeatable.

Language constructs may be provided that allow a programmer to use an object oriented language technique to construct stream graphs yet still allow the compiler to extract static shape information needed to compile to a reconfigurable processor logic such as an FPGA. The methodologies presented herein may be utilized in programming and compiling hardware and may also be useful in other domains for instance which would benefit from analysis of complex static structures built with general purpose language abstraction.

In a stream graph the nodes represent computations to be performed. The edges of a stream graph are labeled and represent data flowing from one node to the next. The nodes may be given values at the beginning of execution to initialize their states referred to as node initialization . Those values usually are not known at compile time. Data streams through the graph and comprises values not known at compile time referred to as streaming data values .

The programming language may have the following characteristics the computations to be performed in the nodes of a stream graph are expressed in the programming language the executable steps to connect the nodes to each other are expressed in the programming language and can include recursive computations the connectivity of the graph can be arbitrary. Executable steps may include constructs of the language that can be used in a program for example if then else do while subroutine calls object constructions etc. Those constructs may be combined in any way to form the graph.

Referring to at a program is received. For instance a programmer may write recursive and iterative programs to build graphs using a computer programming language. An aspect of the present disclosure provides a support in the programming language for ensuring that graphs can be built in a deterministic and repeatable fashion.

At the program is analyzed. Computations that construct the graph are evaluated and those that are repeatable are identified. For example isolation constructs of the programming language may identify the computations that are repeatable. Those computations are executed at compile time. The techniques of analyzing the program are described below.

At artifacts representing one or more stream graphs constructed by the program are output. Artifacts may include executable program elements. For a program written to be able to run on mixed hardware artifacts may include Java bytecodes or the like and native binaries to run on a general purpose processor e.g. the main central processing unit CPU and bitfiles as they are called or the like to be loaded into the Field Programmable Gate Array FPGA or the like reconfigurable hardware logic. The stream graphs when compiled for suitable hardware are capable of executing and producing a correct answer with all possible node initialization values and all possible streaming data values that may be presented in any execution of the program. The stream graph so produced may be the same graph that would have been constructed at runtime hence a methodology of the present disclosure in one embodiment enables a complier of the programming language to statically compile that graph for reconfigurable processor or logic such as FPGA e.g. achieve ahead of time compilation of the dataflow graphs for reconfigurable targets.

An example of programmable architecture is reconfigurable hardware in the form of Field Programmable Gate Arrays FPGAs . Compiling a program directly into hardware eliminates layers of interpretation which can dramatically improve performance power or energy consumption.

FPGA developers rely exclusively on low level hardware description languages HDLs such as VHDL and Verilog. These HDLs provide low level abstractions such as bits arrays of bits registers and wires. With low level abstractions and tools FPGA development takes much more expertise time and effort than software development for comparable functions.

HDL designs derive their efficiency from hardware structures tailored to closely match application logic. The structure of a hardware design represents a dataflow graph where each node encapsulates some behavior and the nodes exchange data over wires and queues. An HDL design implements a data flow graph by instantiating hardware modules and explicitly connecting individual wires between modules. These hardware structures must be static the design must fully elaborate all hardware structures at synthesis time when tools compile an HDL design to a binary circuit representation. Synthesis often takes hours to complete and may entail exploration of a configuration space of tuning options.

To improve programmer productivity describing data flow graph computations several software systems provide language support for stream programming. Some streaming systems provide restricted self contained languages to describe data flow graphs so that their structure can be analyzed statically. Other approaches embed operators as first class objects in a general purpose language without however enabling static extraction of their structure.

Embedding streaming constructs in a general purpose language has many advantages. Specifically the programmer can use the full power of the language to describe stream graphs exploiting modern language features and abstractions. For example modern language features such as higher order functions and parameterized types allow the developer to encapsulate design patterns in reusable libraries and software components.

However when compiling stream graphs to an FPGA the power of a general purpose language cuts as a double edged sword. Modern software patterns tend to abstract and obscure structural information which must be elaborated statically to synthesize efficient hardware.

A number of previous projects have adopted streaming programming abstractions for reconfigurable hardware. These projects require a separate compile time language to express stream graphs often with restricted topologies. Currently the inventors are not aware of any previous work that supports stream graphs as first class objects in a modern general purpose language and yet still can compile efficient hardware for an FPGA.

In the present disclosure new features in a programming language e.g. Lime a Java derived language may be provided which combine the benefits of first class streaming language constructs with the ability to synthesize efficient hardware. In this programming language in one embodiment of the present disclosure stream graphs are first class objects which can be manipulated with the full power of the language. Briefly in programming language design a first class object refers to an entity that can be constructed at run time stored in variables and data structures passed as an argument or parameter to a subroutine returned as the result of a subroutine.

In general using a programming language the programmer may to express graphs whose structure cannot be known until run time. However the programmer can denote certain graph expressions for relocation to hardware in which case the language enforces additional invariants using simple local constraints based on compositional language features. When a stream graph construction type checks as relocatable the language guarantees that the compiler can extract static structure needed to synthesize efficient hardware. In one aspect a programming language compiler co design in the present disclosure may allow for extracting a static structure e.g. without aggressive program analysis and without symbolic execution.

Consider a simple example a stream evaluator for a polynomial. Given a polynomial f x when presented a stream of inputs x x . . . the program should produce the stream f x f x . . . . Assume a non functional requirement a pipelined implementation is needed on an FPGA which consumes and produces one value per cycle.

Consider the polynomial f x x 3x 4x 7. shows the structure of a pipelined implementation to evaluate f x according to Horner s rule. Each pipeline stage performs one multiply add which is assumed to be synthesized in one cycle. If presented one value x per cycle this pipeline produces one value f x per cycle.

The following describes how one could express this stream graph in a programming language that produces hardware code. The following description refers to the Lime programming language with reference to the methodologies of the present disclosure. However it should be understood that the methodologies may apply to another programming language which for example provide similar capabilities.

Lime is based on the Java Programming Language but adds a number of constructs to express invariants helpful when compiling programs to hardware. Here those Lime constructs needed to understand the example above are described.

Briefly the Lime type system includes various types that enforce immutability and restrict side effects. In one aspect any method marked with the local qualifier has no side effects and can be considered a pure function. Additional the Lime tuple types may be used the syntax x y z indicates a tuple with three elements and the syntax int int int specifies the type meaning tuples of three integers . Lime supports type inference for local variables the programmer can elide the type in a local variable declaration and simply use var or final instead.

Lime supports a streaming dataflow programming model a Lime program constructs a stream graph by creating tasks and composing them into an acyclic graph. A Lime program applies the task operator to a method description to produce a Lime task a node in a stream dataflow graph.

The full Lime language supports a number of syntactic forms for method descriptions which correspond to instance methods and support object state for stateful tasks. The following describes stateless Lime tasks constructed from static methods. However all the concepts presented in the present disclosure may translate naturally to the full Lime language including stateful tasks.

Definition 1 Task Construction Let T0 Foo.m T1 . . . Tk be the signature of a static method m declared on class Foo which takes parameters of types T1 through Tk and returns a value of type T0. If all of the types T0 . . . Tk are value types then the expression task Foo.m T1 . . . Tk 

If the signature without parameter types Foo.m is unambiguous then task Foo.m is accepted as shorthand for the full signature.

A task construction constructs an object of type Task which represents a node in a stream graph. The constructed task takes k inputs whose types are T1 through Tk. If T0 is void the task returns zero outputs. If T0 is a tuple type of cardinality m the task produces m outputs with types corresponding to the tuple components. Otherwise the task produces one output of type T0. Each time it activates the constructed task consumes inputs applies the pure function represented by method m and outputs the result.

Task is an abstract type the language provides subclasses of Task that describe its shape. For example class Filter extends Task is a commonly used subtype that describes a task that consumes an input of type IN and produces an output of type OUT. Task and all its subclasses are value types.

The program can eagerly bind curry one or more input arguments to a task by specifying the bound values in the task construction expression. The curried expression is evaluated once at task initialization time.

Definition 2 Task Initializer Let t task Foo.m T1 . . . Tk be a valid task construction. Let e be a valid expression of type Tj for 1 j k. Then the expression t which substitutes e for Tj in t 

is a valid task construction. In t e is called a task initializes. The meaning of t is the same as t where the value of the jth parameter is statically bound to the value of e.

Lime programs compose tasks into simple stream graphs using the connect operator. If tand tare tasks the expression t tdescribes a stream graph where the outputs of tflow to the inputs of t.

The resultant pipeline matches the structure described in . Each instance of the update task statically binds the coef input to an appropriate integer coefficient value.

In Table 2 the structure of the stream graph meaning its shape and the implementation of each task is static and clearly evident from the code. When compiling to hardware the compiler elaborates this structure statically in order to synthesize an efficient hardware design that produces one value per cycle.

Consider another example. Suppose one wishes to write a library which can generate circuits for arbitrary polynomials represented by strings. In software general purpose languages support this style of library. An abstract data structure may be built that represents a polynomial and an evaluation engine may be built which interprets the data structure at runtime. In the present disclosure a similar library routine may be written that generates Lime stream graphs.

Returning to the example let s represent a polynomial by an array of int so the polynomial f x x 3x 4x 7 corresponds to int f 1 3 4 7. A parse method that converts a string representing a polynomial to an array of coefficients and a method pipeline that constructs a Lime task graph from an array of integers may be built.

Table 3 sketches a simple implementation in Lime. Table 3 elides the details of the parse method which implements basic string processing using imperative operations.

The Line code shown in Table 3 generates a pipeline to evaluate a polynomial represented by an array of int.

The code in Table 3 correctly expresses the necessary logic in Lime. However in contrast to Table 2 the code in Table 3 does not minor the structure of the resultant stream graph for any polynomial. The structure of the stream graph depends on the contents of a string line relatively complex imperative parsing code line and a loop lines that constructs a task graph.

The Lime runtime system may build and interpret this task graph at runtime running in software. When running in software the system can construct and interpret fully dynamic graphs at run time. To exploit reconfigurable hardware the compiler uses more static information. To generate hardware efficiently the compiler may determine the structure of the stream graph at compile time.

To determine the structure of a stream graph for the polynomial example the compiler requires that the string line which determines the polynomial be known at compile time. However even when the string is known extracting the stream graph structure from Java code in Table 3 represents a program analysis challenge. Effectively the compiler must partially evaluate the stream graph constructor for a given input which carries all the inherent difficulties of binding time and side effect analysis for Java.

The present disclosure in one aspect provides for a language compiler co design that makes this problem tractable. Language extensions for example Lime language extensions may be presented to add e.g. small but powerful type constraints that allow the compiler to extract the relevant stream graph structure without intensive program analysis. The language may remain sufficiently general to express rich structured and unstructured stream graphs.

Table 4 shows an example Lime code to construct the pipeline using the new language extensions of the present disclosure in one embodiment e.g. similar code as in Table 3 enhanced with new Lime language constructs. The revised code may rely on the following language e.g. Lime concepts 

In the present disclosure repeatability is further generalized and relocation brackets are provided as a additional feature in the programming language.

The constraints involving relocation brackets and local methods is described in more detail below. For this example it suffices to note that if the expression in relocation brackets is repeatable then it satisfies the constraints. In one aspect other scenarios may relax the restriction to increase expressive power. That aspect is also described in more detail below. In Table 4 the expression in relocation brackets at line is repeatable the type Task returned by pipeline is a value type as is the argument and the function is local .

In the present disclosure language constructs are introduced which allow the programmer to write a relatively complex stream graph generating library using all the imperative facilities of Java or the like computer language. In order to guarantee that the compiler can determine the relevant graph structure statically the present disclosure introduces simple type constraints at the library boundary.

In one aspect all the type constraints may be simple local properties which can be checked in a modular fashion. Compile time evaluation of repeatable expressions would be inter procedural and arbitrarily complicated if done by conventional means however the language design permits a simple concrete evaluator to run at compile time to evaluate repeatable expressions. No complex analysis is required.

The examples codes of Tables 1 4 are shown that can use arbitrary imperative code to define stream graphs. While only a simple pipeline graph structure is presented the same mechanisms work for all reducible graph structures which include operators to split and join dataflow tokens.

The well known FFT butterfly stream graph for the decimation in time FFT algorithm differs fundamentally from the graphs considered previously in many streaming languages. The FFT butterfly graph is irreducible it cannot be expressed as a composition of pipelines splits and joins.

The present disclosure in one embodiment may extend a programming language e.g. Lime with the ability to define stream graphs with manual connections. The programmer may be allowed to construct stream graphs with an unstructured graph construction application programming interface API which allows arbitrary connections between tasks.

As long as the graph construction code obeys the constraints imposed by relocation brackets the compiler can extract the relevant structure even for irreducible graphs created through the programmatic graph API. This property holds even for recursive graph construction routines which arise frequently in complex graph construction logic.

This facility allows a programming language e.g. Lime to express a richer graph language than previous streaming languages which are restricted to reducible graphs. An enhanced programming language of the present disclosure in one embodiment can statically extract complex graph structures such as systolic arrays and FFT and compile the graph structures to hardware.

The following illustrates some aspects of an example programming language that may be enhanced with the capabilities described above of building dataflows graphs for hardware during compile time in one embodiment of the present disclosure.

Lime is a superset of Java adding additional language features to express parallelism and locality to exploit heterogeneous architectures. Lime language features utilized in the present disclosure are reviewed below before introducing the new language contributions in subsequent sections.

Lime introduces a category of value types which are immutable like the primitive types but are declared similarly to reference types with fields and methods . One merely adds the value modifier to a type declaration to revise the semantics and obtain additional checking to enforce deep immutability. The fields of a value type are implicitly final and must themselves be value types. For example Lime provides the library type bit as a value enum with possible values zero and one. The primitive types inherited from Java are redefined to be value types. A special array declarator allows some arrays to be values. The type bit is a mutable array of bits and the type bit is an immutable array of bits a value type .

The language defines a non null default type for every non abstract value type and prohibits null values for such types.

The construction rules for values prohibit cycles so each value represents a tree that can be linearized and passed by value.

Lime introduces the local modifier on methods which can be used to enforce invariants regarding side effects and isolation. The local modifier asserts that a method does not access mutable static fields and only calls other local methods. Type checking these rules requires only simple intra procedural scanning.

The rules give no general guarantee that a local method is free of side effects since it can modify instance fields in its receiving object or mutable objects reachable from method arguments. However if a local method has only values as arguments and return type then it is easy to establish that the method is pure.

Note that a local method established to be pure is not obligated to call only pure methods. It is free to call methods that are merely local since any mutations that may occur inside those methods must be limited to objects created in the activation stack of the outermost local method. Any such mutable objects must all die before the outermost method returns since the outermost pure method must return a value and cannot write to mutable static data structures.

Local methods are allowed to read certain static fields if they are final and repeatable. Repeatable expressions are further described in detail below.

The Lime task constructors and task initializers which can be used to build stream graph pipelines were introduced above. Lime also provides a set of system tasks called splitters one input many outputs and joiners many inputs single output which can be connected to form a rich set of possible graph structures.

In order to express irreducible graphs such as the FFT butterfly example described above a programming language e.g. Lime is extended to support construction of arbitrary stream dataflow graphs.

Table 5 shows an API methods for the TaskGraph class which provides a programmatic interface for stream graph construction. The TaskGraph.add method adds a task to a graph and the connect method connects an output of one task to the input of another.

In one embodiment of the present disclosure TaskGraph is a value class it is deeply immutable. Thus the add and connect methods create a new TaskGraph value and do not mutate a graph in place. The immutability of tasks plays a key role when reasoning about repeatability of task construction code described in more detail later.

Similarly the Task class itself is also immutable. However in many complex graphs such as systolic arrays the program must build up a network which contains many copies of a particular task. In order to support this each Task instance may have a unique string identifier. The method Task.named string id creates a new copy of a task but with a different string identifier. The string identifier dictates object identity for task objects which allows the programmer to distinguish between copies of a functional unit when building complex graphs.

Table 6 shows program e.g. Lime code to build a graph equivalent to task twice task twice. Although this simple graph is reducible it should be clear that a program can use the TaskGraph API to build an arbitrary graph structure.

In one embodiment a programming language e.g. Lime may only accepts acyclic graphs. When the manually constructed portion of the graph is further connected using the result is checked for acyclicity. In general this will result in a run time exception but if the graph is being relocated the evaluation technique presented below finds the error at compile time.

A repeatable expression has no side effects can be evaluated any number of times and will always produce the same result. The class of repeatable expressions are those built from repeatable terms composed with pure functions.

The base repeatable terms those containing no operations are a superset of the set regarded as compile time constant in Java. First all literals of value types are repeatable. This includes the primitive type literals defined in Java plus the literals added by Lime for bits ordinal types discussed below value enums and string literals.

Generalizing Java s rule for constants a simple name reference is repeatable if it is a reference to a final field or variable that has an explicit repeatable initializer. A qualified name reference like Foo.a is repeatable if it is a reference to static final field that has an explicit repeatable initializer.

A programming language e.g. Lime includes a set of built in operators which represent pure functions. e.g. . If expression e has a pure operator applied to arguments that are all repeatable then e is repeatable.

In one embodiment of the present disclosure the set of repeatable expressions may be increased with two capabilities not supported for constants in Java. First the local invariants may be exploited to reason about calls to user methods that must be pure functions. So a method invocation produces a repeatable result if the method is pure and all of its actual arguments are repeatable.

Second a value creation with the new operator may be regarded as repeatable if the constructor is pure and all the actual arguments are repeatable.

If e is a repeatable expression and evaluation of e terminates then e evaluates to the same value in all possible executions. This can be shown by structural induction over the forms of repeatable expressions.

When compiling to an FPGA or the like reconfigurable logic the generated design must fit in limited physical resources and cannot exploit a virtual address space. For this reason the compiler should often be able to compute the size of arrays at compile time in order to use scarce logic resources efficiently.

To help the compiler reason about array sizes a programming language e.g. Lime may include bounded array types. Informally the type int N where N is an integer represents an array of exactly N integers. More generally Lime supports ordinal types where the type ordinal N represents the set of non negative integers i where i

Table 7 sketches a recursive implementation of merge sort using ordinal type parameters. The type parameter N line indicates the size of the input array. Note that the code constructs a new ordinal type HALF used in the divide and conquer recursion.

Observe that the type system ensures that sort is a pure function. Thus when sort is invoked on a repeatable input line the type system ensures that all type parameters used in the recursive expansion of sort are also repeatable. Thus the compiler can statically determine the bounds of all arrays used in the call to sort at line . Furthermore since sort is pure the result b at line is also repeatable and can be computed at compile time.

Although Table 7 shows simple single threaded code the same concepts apply when onstructing stream graphs from generic methods with bounded array inputs and outputs. This pattern arises frequently in stream graphs for Lime programs on FPGAs. Repeatable bounded array types are a key feature in being able to statically bound space usage in hardware designs for complex stream graphs.

Lime provides no guarantee that a repeatable expression will terminate without throwing an exception or even terminate at all. However the behavior terminating or not will be reproducible and can be monitored at compile time. When the compiler evaluates repeatable expressions it checks for exceptions and imposes a time out. Should evaluation not terminate normally in a reasonable interval the compiler reports the failure as a compile time error.

Invariants for local methods and constructors guarantee freedom from side effects but not necessarily determinism. It may be assumed that such methods cannot contain any non deterministic operations. This assumption is true today in Lime because Lime has no core language constructs that are non deterministic. The type system prevents local methods from calling native code or across a foreign function interface.

The current definition of repeatability includes two pragmatic compromises. First it may be insisted as with Java compile time constants that any final fields must first have an explicit initializer before it is considered whether that initializer is repeatable. Second qualified names like Foo.a may be limited to the case where they denote a static field. It may be possible to relax both restrictions.

The following describes the language constructs in one embodiment of the present disclosure that guarantee that the compiler can extract static information about stream graphs needed in order to relocate a stream graph computation from software onto an FPGA.

If e is a language e.g. Lime expression the syntax e is introduced which is called a relocation expression using relocation brackets syntax.

A relocation expression type checks whether a e is repeatable or b e satisfies additional constraints specific to unrepeatable task initializers Definition 2 for stream graphs. Each case is discussed below and the additional constraints which define case b are explained.

If e is a relocation expression which generates a stream graph then the compiler guarantees that it can extract static structural information hereafter called stream graph structure sufficient to enable hardware synthesis.

Definition 3 Stream Graph Structure Let g be an object of type Task i.e. a stream graph . A stream graph s structure may comprise 

For part 4 above the actual value bound to the parameter is not considered part of graph structure in one embodiment of the present disclosure. Therefore the stream graph structure does not completely determine the function to be executed in each node. The code is determined by part 3 above the curried signature is refined by part 4 but the task initializers see Definition 2 are still unknown.

When a stream graph expression is repeatable the compiler can fully evaluate the expression and walk the resultant data structure to determine the graph structure. Implementation details in one embodiment of the present disclosure relating to the compile time repeatable graph evaluator is described below. An example of a repeatable graph is illustrated in the polynomial example described above.

Tasks are designed as immutable values allowing to reason about repeatability for library methods that produce and consume Task objects.

If one wants to use connect in a repeatable or relocatable expression then the type system must establish that connect is a pure function. Recall that there is this guarantee for local methods that produce and consume values. Thus Lime Task objects are deeply immutable.

In a pipelined implementation for polynomial evaluation described above the degree and coefficients to the polynomial were static. In this case both the stream graph structure and all the task initializers are repeatable so all the node functions were completely determined. However a methodology in one embodiment of the present disclosure can also efficiently support hardware stream graphs where the stream graph structure is repeatable but the functions of individual nodes in the graph depend on dynamic data provided through unrepeatable task initializers. The present language extensions to support this are now described.

Consider a variant of the polynomial pipeline for functions of the form f x ax ax ax a where the degree of the polynomial is fixed at 3 but the coefficients of the polynomial are unknown at compile time.

Table 8 shows a program Lime code to build a stream graph for this problem. In this case it is assumed that the coefficient array a is not repeatable.

The relocated expression in Table 8 is not repeatable. To allow this expression to type check the type checking rules may be relaxed.

Definition 4 Relocatable Expressions no calls . A legal Lime expression e is relocatable if and only if one of the following holds 

Case 2 allows a relocatable expression to use unrepeatable expressions as task initializers recall Definition 2.1 . This case allows the stream graph in Table 8 to type check as relocatable. Specifically the unrepeatable coefficients a i appear only inside expressions of the form task e.

This definition of relocatable constrains the code such that the stream graph structure is repeatable but the logic that implements each user task in the graph can use runtime values. The system can implement this pattern efficiently in hardware by laying out the stream graph statically and laying down wires to route the dynamic values to the appropriate functions at runtime.

Next the definition of relocatable expressions may be extended to support procedure calls so stream graph constructions can be encapsulated in a library even when they employ unrepeatable values as task initializers.

Table 9 shows the library method encapsulation for the running example. Note that the expression in relocation brackets at line now contains a procedure call.

In one embodiment additional type qualifiers are added that pass constraints about relocatable expressions across procedure boundaries but still allow modular local type checking. In one embodiment the task keyword may be re used for this purpose allowing the task keyword as a type qualifier on formal parameters lines and in Table 9 .

When a task qualifier decorates a formal parameter p of a method m p is called a dynamic parameter. In one embodiment of the present disclosure there may exist only two legal ways p can appear in expressions inside m 

Definition 5 Relocatable procedure calls A procedure call expression M.foo p1 . . . pk is relocatable if and only if for each j 1 j k 

In one embodiment of the present disclosure an expression e may be defined to be oblivious if during the evaluation of e every conditional expression evaluated is repeatable. If an expression is oblivious then its evaluation will follow the same control flow branches in every possible environment.

In one embodiment of the present disclosure all relocatable expressions may be oblivious. This property is simple to establish with structural induction on the shape of relocatable expressions. If a relocatable expression is repeatable it is oblivious. Otherwise it suffices to note that in each syntactic form listed in definitions 4 and 5 no unrepeatable values can affect control flow.

Next a key property in one embodiment of the present disclosure may be established that allows the compiler to extract the shape of relocatable expressions without aggressive program analysis.

Repeatable Structure Property. Suppose a call expression e M.foo e1 . . . p . . . ek is relocatable where all actual parameters except p are repeatable and p corresponds to a dynamic parameter of M.foo of type T. Assume the evaluation of e terminates without an exception producing the stream graph object g. Now let e2 M.foo e1 . . . p2 . . . ek be the expression e substituting any value p2 of type T for p. Then evaluating e2 terminates without an exception producing a stream graph object g. Furthermore gand ghave the same stream graph structure.

Informally this property may be established with an argument based on information flow. The body of M.foo may be considered as a function with k inputs where the ith input inis the dynamic parameter corresponding to actual parameter p. In one embodiment of the present disclosure the type checking rules for dynamic parameters guarantee that no statement in M.foo can be control dependent on in and only task constructions can be data dependent on in. Thus the effects of in on the object resulting from evaluating either e1 or e2 must be confined to task constructions. Thus the stream graph structure must be repeatable.

This key property allows a system of the present disclosure to evaluate relocatable expressions that produce stream graphs at compile time substituting place holders during evaluation for any dynamic parameters. The structure of the resultant stream graph does not depend on dynamic parameters instead dynamic parameters may only flow untouched to task initializers. With this property the compiler can establish the stream graph structure for relocatable graphs with a relatively simple concrete evaluator which is described below.

Nested Task Graphs in Table 9 the method thirdDegree is also decorated with a task qualifier. This qualifier adds additional constraints in particular a task method can only execute a certain restricted class of task graphs that are isolated and deterministic. These restrictions allow the Lime program to execute task graphs while evaluating expressions that construct task graphs without losing the benefits of relocatable expressions. The constraints imposed by the task qualifier may be a superset of constraints imposed by local.

The following describes implementation factors associated with design of compiler support to extract graph structure in one embodiment of the present disclosure. Considerations associated with repeatable expressions are presented and then considerations associated with partial evaluation for relocatable expressions with unrepeatable sub expressions are presented.

In a functional language which represents programs as values a repeatable expression evaluator would not be challenging e.g. eval e in Lisp . However a programming language considered in the present disclosure e.g. Lime e.g. an imperative language based on Java does not represent programs as values. Like a Java compiler the Lime compiler generates JVM bytecodes. So the compiler can employ the JVM to evaluate repeatable expressions at compile time.

Namely a compiler of the present disclosure in one embodiment generates bytecode representations of repeatable expressions called snippets. The snippet evaluator implementation considers the following design factors 

The program e.g. Lime compiler in one embodiment of the present disclosure generates bytecode representations of all user code before running any snippet evaluation. So the snippet evaluator can run with a JVM classpath that includes all the generated bytecode. This classpath reflects the anticipated runtime environment at the granularity of packages and visible classes.

In order to reproduce within class scoping of names that appear in the expression the compiler constructs a snippet method which represents a repeatable expression. In one embodiment of the present disclosure a snippet method has no parameters and is declared in the class in which the repeatable expression occurs. To build a snippet method the compiler of the present disclosure in one embodiment may first creates a single return statement with a copy of the expression. That is if the expression is i j then the snippet method starts out as

This method will not type resolve since i and j are variables with arbitrary bindings. The second step visits all the names in the expression and determines that the correct i and or j will actually be in scope or replays the declaration s of i or j inside the method. Since all names are resolved at this point this analysis can be done accurately.

From the definition of repeatability any qualified names e.g. b.i denote static fields. If a name refers to a static repeatable field then no additional steps are required since the scope already binds the name. If a simple name refers to a local variable the compiler in one embodiment of the present disclosure replays the variable declaration inside the snippet method. If a simple name refers to an instance field defined in the encompassing class or one of its supertypes then the compiler in one embodiment of the present disclosure generates an equivalent local variable declaration in place of the field declaration. When a variable or instance field declaration is replayed it might trigger transitive replay of other variables or instance fields referenced in the declaration.

The replay strategy is sound for the following reasons. If the snippet is based on a fully repeatable expression i and j must denote final variables or fields with explicit repeatable initializations. If the expression contains unrepeatable task initializers they are replaced by placeholders which have repeatable behavior and don t include name references .

Supporting non static qualified names may complicate the analysis e.g. it is far more difficult to replay the sequence of declarations backing such names since some segments represent objects whose creations have already occurred while others are just field references. In general one might not even have the source for the class that defines the type of the object or in which the object was created.

Translating a runtime value back into a compile time representation is simplified by the fact that repeatable expressions always produce programming language e.g. Lime values which are containment trees with no cycles or internal aliases. Translation from runtime back to a compile time representation can use any of the following techniques.

The present implementation in one embodiment of the present disclosure uses the reconstruction technique for the stream graph structure and uses the literal or default technique or their array generalizations for any repeatable task initializers it finds. Unrepeatable task initializers and those repeatable ones that can only be encoded by reconstruction are handled using the technique of the next section Partial Evaluation . More repeatable task initializers may be handled by reconstruction yielding more efficient code.

The above defined relocatable expressions so that the stream graph structure was required to be repeatable but task initializers could be unrepeatable. The Repeatable Structure Property allows to use the snippet evaluator for all relocatable expressions even with some unrepeatable parameters any legal value of the correct type can be substituted for a dynamic parameter and the resulting objects from evaluation will have the same stream graph structure. So in snippet evaluation an embodiment of the present disclosure may generate a unique placeholder value for each unrepeatable parameter and run the snippet with an unmodified JVM. In the resulting object the placeholders may flow to task initialization parameters but from the Repeatable Structure Property cannot affect any other aspect of the computation.

As a result the evaluated object must have the same stream graph structure as the stream graph that will arise at runtime. The implementation may or may not choose to evaluate repeatable parameters that flow to task initializers. Dynamic parameters will be clearly identified by placeholder values in the resultant stream graph object. When interpreting the resultant stream graph object the compiler maps placeholder values to the appropriate expressions in the generated code which causes dynamic parameters to flow to generated tasks at runtime.

As discussed above a programmer may write programs that build stream graphs for programming a hardware circuit e.g. FPGA synthesis using a programming language e.g. an object oriented programming language and associated compiler incorporating the above described methodologies. The programming language an example of which was illustrated with reference to the Lime language may support stream graph construction using rich abstractions and control flow constructs that comprise conditionals loops and recursion. The language permits compact graph construction code using a number of idioms which may be factored into library methods. Graph construction may be parameterized in terms of size via repeatable parameters and function via tasks as first class values. The compiler succeeds in extracting the task graphs and synthesizes the code into FPGA circuits.

Such programming language may handle multiple different coding patterns in identifying and extracting stream graphs. Examples of different coding patterns may include 

In one embodiment of the present disclosure the ability to treat stream graphs and tasks as first class objects may allow to factor the graph construction idioms into library utility methods. Examples are illustrated below.

Graphs may be built using a recursive idiom. Table 10 shows an example that builds a sequence of tasks that perform the encryption required by DES. In this sequence all but the last task behave identically modulo the curried encryption key a KeySchedule . The last stage performs a bit reversal indicated by the curried task initializer expression round 15.

At each level of the recursion the graph grows by one task. Although it is convenient to express graph construction in this way it is often easier to create an array of filters and chain them together using a common utility method. This is illustrated in Table 10 makeFilters creates the array and the library method Idioms.pipeline constructs the pipeline.

The graph extracted from recursive new KeySchedule 15 is structurally equal to that constructed with the following expression Idioms.pipeline makeFilters new KeySchedule .

Divide and conquer extends the recursive idiom with parameterized ordinal types. An example of a library utility is presented which exploits first class task values with higher order logic. Table 11 shows a generic method Idioms.dnc parameterized by the type V of the values flowing between tasks and the input size N. This method builds a graph that divides the input recursively until the base case is reached connects a task t to perform the desired computation and inserts joiners to combine the results from each level of recursion.

The mergesort benchmark uses this idiom to construct its task graph as in Idioms.dnc task Merge.sort where task Merge.sort creates a task to sort a given merged array of integers.

The example relies on programming language Lime matchers which appear as in the code. The simplest matchers as in this example perform aggregation to convert a stream of V to V n or deaggregation for the reverse conversion. Lime provides type inference across the connect operator so that the left or right side of the conversion may be omitted.

Iterative and recursive construction serve to construct sequences of connected tasks. An alternate idiom uses multitask constructors which construct vectors of tasks not directly connected to each other.

Table 12 shows an example drawn from the beamformer benchmark and simplified for exposition. The makeBeams method initializes an array of tasks and then returns the multitask composition of the array elements. The Lime map operator permits a more concise encoding as

Two classes of multitasks may be distinguished those that operate on partitioned streams and constructed using map and those that operate on a repeated stream. In the former a single stream is split and distributed to each of the tasks. In the latter the values in a stream are repeated k times immediately before the splitter. The end result is that each of the connected tasks observe and operate on the same values.

A library utility method may be implemented called Idioms.repeat that accepts a multitask and returns a graph having a task that repeats values the required number of times and connects it to a splitter multitask and joiner. The example Table 12 illustrates another feature of matchers i.e. the repeat count . The matcher repeats every value it consumes N times on every invocation.

The preceding examples all exhibit reducible graph topologies. Other topologies may only be expressed with manual connections. These include not only irreducible graphs but also use cases that are simply easier to express using a richer programmatic interface. A manual connection API supported by a programming language e.g. the Lime manual connection API may be provided or used. Using manual connection library utilities may be created to express a variety of graph shapes. These may include butterfly networks systolic arrays and reduction trees. In each case the library utilities establish the desired shape parameterized by a small number of values and allow the programmer to pass in tasks as first class values to connect internally.

A programming language e.g. Lime s properties may be relied on to encapsulate complex manual graph construction algorithms in libraries using higher order functions while still enjoying parameterized types and sizes type safety and repeatable graph shapes. The ability to write the graph construction code in the same language and semantic domain as the rest of the application also means a single development and debugging environment can be used. This is especially helpful for the construction of irreducible graphs where the code is relatively more complex compared to idioms illustrated above.

A compiler of the programming language e.g. Lime may extract relocatable graphs for hardware synthesis from a program code e.g. code patterns examples illustrated above . In one example the extracted graphs in Lime code may be synthesized by a hardware specific compiler into circuits suitable for programming a hardware e.g. FPGA . In one aspect a hardware specific compiler may partition a task graph into the largest non overlapping subgraphs and synthesize each partition independently. In another aspect an entire extracted graph may be compiled into one large circuit.

The graph extraction and relocation methodologies illustrated herein enable synthesizing task graphs into hardware circuits e.g. FPGA circuits from high level object oriented code. For instance the stream graph construction may be embedded in a general purpose object oriented language. Such language may also support irreducible stream graphs constructed with complex code which can still be synthesized to an FPGA or the like.

Programming language constructs in one embodiment of the present disclosure can be viewed as binding time annotations which specify a division to drive off line partial evaluation of certain program constructs. The programming language of the present disclosure may support solely off line specialization. The programming language of the present disclosure may target code generation for devices such as FPGAs where runtime specialization is not practical with current synthesis technology. The programming language may restrict the relevant code to oblivious expressions amenable to off line evaluation. In the partial evaluation literature a program or expression is oblivious if the program always follows the same execution path in terms of if then else or other conditional execution constructs in every possible execution.

In another aspect the programming language s binding time annotations may be fully integrated into the type system which provides safe modular checking. Additionaly the programming language may restrict the static division to oblivious code sequences which can include holes for values but where dynamic values cannot affect control flow.

At the compiler identifies one or more datatypes in the program that are immutable and one or more methods that are local. For identifying immutable datatypes and or local methods techniques described in co pending and co owned U.S. patent application Ser. No. 12 870 980 filed Aug. 30 2010 entitled EXTRACTION OF FUNCTIONAL SEMANTICS AND ISOLATED DATAFLOW FROM IMPERATIVE OBJECT ORIENTED LANGUAGES may be used. The content of that application is incorporated herein by reference. Other technique may be used also.

At the compiler also identifies one or more parameters of one or more local methods that are intended for task initialization. Those parameters are also referred to herein as being dynamic. 

At the compiler checks that task initialization parameters are not used in a way that affects a control flow within the method in which those parameters are used . One example way of checking this as described above is to allow them to appear only in stream graph node constructions in positions that syntactically denote them as initializations with all other uses being disallowed. However other forms of checking may be employed.

At the compiler identifies expressions that are repeatable e.g. as defined above. In one aspect repeatability is defined entirely using immutability and localness as checked at .

At the compiler also identifies stream graph constructions that are relocatable. For example a stream graph construction may be identified as being relocatable if they are built from the nodes that are immutable and connection operations that are functional. A stream graph constructions may be also identified as being relocatable if they are repeatable except for the possible presence of task initializations which are allowed to be unrepeatable e.g. see Definition 4 discussed above . In one aspect a stream graph constructions may be also identified as being relocatable even if the stream graph construction may include calls to unrepeatable local methods as long as the unrepeatable parts are only passed as task initialization parameters e.g. see Definition 5 discussed above .

In one embodiment the compiler may automatically identify all possible relocatable stream graph constructions. In another embodiment a programmer may identify which subgraphs should be relocated e.g. by using a predefined annotation in the compiler.

At the compiler creates a modified form of the task creation expression in which unrepeatable initializations are replaced by marker values. For example a default value for a datatype may be used e.g. the compiler language such as the Lime language guarantees a default for every value type . However any method for distinguishing the unrepeatable initializations from the repeatable ones may be used.

At the compiler executes the task creation at compile time within an environment that mimics the runtime environment and captures the stream graph that is produced. Because unrepeatable initializations were marked prior to execution the markers appear in the result and it is known which initializations are unrepeatable.

At the stream graph captured at is converted into a suitable compiler intermediate representation and compiled to produce the necessary bitfiles and or other artifacts to synthesize for the target platform e.g. reconfigurable hardware.

The computer system may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. The computer system may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

The components of computer system may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor . The processor may include a compiler module that performs the methods described herein. The module may be programmed into the integrated circuits of the processor or loaded from memory storage device or network or combinations thereof.

Bus may represent one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system may include a variety of computer system readable media. Such media may be any available media that is accessible by computer system and it may include both volatile and non volatile media removable and non removable media.

System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory or others. Computer system may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media e.g. a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces.

Computer system may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system and or any devices e.g. network card modem etc. that enable computer system to communicate with one or more other computing devices. Such communication can occur via Input Output I O interfaces .

Still yet computer system can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system. Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment a software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages a scripting language such as Perl VBS or similar languages and or functional languages such as Lisp and ML and logic oriented languages such as Prolog. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The computer program product may comprise all the respective features enabling the implementation of the methodology described herein and which when loaded in a computer system is able to carry out the methods. Computer program software program program or software in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation and or b reproduction in a different material form.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements if any in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Various aspects of the present disclosure may be embodied as a program software or computer instructions embodied in a computer or machine usable or readable medium which causes the computer or machine to perform the steps of the method when executed on the computer processor and or machine. A program storage device readable by a machine tangibly embodying a program of instructions executable by the machine to perform various functionalities and methods described in the present disclosure is also provided.

The system and method of the present disclosure may be implemented and run on a general purpose computer or special purpose computer system. The terms computer system and computer network as may be used in the present application may include a variety of combinations of fixed and or portable computer hardware software peripherals and storage devices. The computer system may include a plurality of individual components that are networked or otherwise linked to perform collaboratively or may include one or more stand alone components. The hardware and software components of the computer system of the present application may include and may be included within fixed and portable devices such as desktop laptop and or server. A module may be a component of a device software program or system that implements some functionality which can be embodied as software hardware firmware electronic circuitry or etc.

The embodiments described above are illustrative examples and it should not be construed that the present invention is limited to these particular embodiments. Thus various changes and modifications may be effected by one skilled in the art without departing from the spirit or scope of the invention as defined in the appended claims.

