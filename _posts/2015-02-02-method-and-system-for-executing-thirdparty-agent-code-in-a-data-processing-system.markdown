---

title: Method and system for executing third-party agent code in a data processing system
abstract: In one embodiment, agent routines are executed in a first thread, each agent routine being invoked by one of coroutines. A agent processor executes in a second thread the agents associated with the one or more agent routines, including receiving a first yield signal from a first of the coroutines indicating that a first of the agent routines yields to perform a first action that requires an action simulation, in response to the first yield signal, suspending the first coroutine, selecting a second of the coroutines from a head of a first agent queue maintained by the agent processor, and executing the second coroutine by assigning the execution lock to the second coroutine. In a third thread, a simulator simulates the first action on behalf of the first coroutine and signals the agent processor to resume the first coroutine after completing the simulation of the first action.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09516100&OS=09516100&RS=09516100
owner: 
number: 09516100
owner_city: Alameda
owner_country: US
publication_date: 20150202
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 936 246 filed Feb. 5 2014 which is incorporated by reference herein in its entirety.

Embodiments of the present invention relate generally to code execution of a data processing system. More particularly embodiments of the invention relate to executing third party agent code in a data processing system.

Traditionally there has been considerable overhead for anyone who wants to get into an online gaming field by writing an agent. Some of the common uses of agents include agent based modeling or simulations which is usually of individuals in social scenarios. For example such simulations include simulations of the classic Prisoner s Dilemma. To run the simulations a user is required to install a software package on his local computer. To create an agent for use in the simulation the user must write it in a specific programming language sometimes a difficult programming language. If the simulation is competitive e.g. Prisoner s Dilemma the user runs his agent against agent s written by other authors. So the user must seek out others who have written agents and then trust that those agents do not threaten his computer system.

In video game simulations video games providers often allow their users to write new game code mods and link it to the game running on the user s computer. Users can write mods to customize the behavior of characters in the game i.e. can write agents. However a game requires extraordinary technical ability. It also exposes the user s computer to security risks if the user installs a mod from an untrusted party.

To submit an agent a user must write and deploy server software that communicates each move via a custom protocol when a central client program requests the agent s move. The same issues arise repeatedly the user must have technical proficiency the user must know a particular programming language other users agents are hard to find and insecure to run. In short the user who has an agent behavior in mind and wants only to put it into code and run it is required to engage in a great deal of infrastructure. Such requirements are difficult for some users to develop and deploy.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to some embodiments an agent execution system or platform agent processor is utilized which runs the routines of multiple heterogeneous agent code libraries equitably and securely such that the agents can interact with a common simulation and with each other. Each agent code library represents an agent and each agent may contain one or more agent routines. The agent code may be developed or provided by different developers or vendors which may be developed in the same or different programming languages. The agent code may also be developed or provided by different developers or vendors. The agent code may include coroutines that are provided by a simulation developer instead of an agent author. Each agent routine may be executed in a separate thread upon reaching an action that the simulation must simulate the routine suspends itself until the action simulation is complete. The agent processor can return control to the routine at different time by maintaining the states of the corresponding threads. Each of the agent routines can be assigned or allocated with similar amounts of processing resources e.g. central processing unit or CPU time memory storage or networking during the execution.

In one embodiment an agent or agent routine is a program that operates autonomously in a given environment to realize a set of goals or perform tasks. Although an agent has a high level goal provided by its operator the steps an agent takes to realize the goal are left up to the agent which may employ arbitrarily sophisticated algorithms or other techniques to realize that goal. Examples of agents include controlling an airplane to win an air battle simulation moving elevators in a building to efficiently deliver passengers to their floors playing the Prisoner s Dilemma a seminal non zero sum game in the field of game theory playing poker controlling each ant in an ant colony to maximize the colony s population and controlling a tower in a tower defense game to maximize the player s score. The environment in which the agent acts is a world simulated in software referred to herein as a simulation or model. As seen by the examples above simulations can range from simple multi player card games to complex socio economic or biological simulations. An agent is able to interact with the simulation by controlling a part of it that part is referred to as an actor. 

Server system may include or represent any type of server or a cluster of one or more servers e.g. Web or cloud servers . For example the agent code may be part of an online game hosted by server as a game server where the agent code may represent certain agents in a game or game simulation developed by various game developers. For the purpose of illustration throughout this application a gaming environment is utilized to demonstrate the embodiments of the invention described herein. However embodiments of the invention can also be applicable to other situations.

According to one embodiment server includes one or more processors e.g. central processing units or CPUs and memory providing an execution engine or platform to execute agent code or agent routines. In one embodiment one or more agent processors an action simulator and one or more agent instances are executed from memory by processor to provide services to clients over network . Server may further include other components such as an operating system local storage device and network interface etc.

According to one embodiment each agent routine is hosted and invoked by a coroutine . A coroutine generally is a computer program component that generalizes a subroutine for non preemptive multitasking. As opposed to a thread whose subroutine is suspended arbitrarily by a separate authoritative process a coroutine allows a subroutine to determine when to suspend itself yield and to allow another coroutine to resume. It is therefore well suited to cooperative sharing of resources. Specifically in this embodiment agent routine may invoke a function action that represents the behavior of an actor in the simulation the action in turn invokes the coroutine which hosts the agent routine instructing it to yield. After simulator indicates that the action is complete agent processor resumes coroutine . Coroutine allows the action function to exit for example by successfully returning or by raising an exception. Agent routine executes its next instruction. It may perform another action after the previous action has exited.

Multiple agent routines can be maintained by an agent instance logically representing an agent which may be in a form of an agent library or agent object. Multiple agent instances e.g. instances of the same agent or different agents are hosted or managed by an agent processor or processing unit. An agent processor coordinates the execution of agent routines which represent an actor e.g. a player of a game or group of actors e.g. a team of players in a game . There can be multiple agent processors managing their respective agent instances but any given agent may not be managed by multiple agent processors. In addition simulator is provided to simulate the action s requested by agent routine s . In one embodiment coroutine and the associated agent routine agent processor and simulator may be executed in separate threads interacting with each other for example through shared memory and or an application programming interface API . In one embodiment agent processor hosting agent instance s may be running within one thread while simulator may be running in another thread.

When agent routine hosted by coroutine invokes action action determines whether it is a blocking action that requires a simulation performed by simulator . If the action is a blocking action it sets up proper states in a corresponding action object to indicate a simulation is required. Coroutine then suspends by yielding the control execution lock to agent processor . While the initial coroutine is suspended agent processor then selects and resumes another coroutine which is waiting for resumption or if there are none waits for a coroutine to indicate it is waiting for resumption . At some time thereafter simulator examines the actor to determine whether there is any pending action that requires simulation. In this example simulator detects that the actor represented by agent instance has an action awaiting simulation. Simulator performs the simulation for a period of simulated time. The action may or may not be completely simulated after this period. If the action is complete simulator indicates such completion status on the actor represented by agent instance . Thereafter agent processor resumes the suspended coroutine to continue.

Note that some or all of the components as shown and described above e.g. agent processor action simulator and coroutine may be implemented in software hardware or a combination thereof. For example such components can be implemented as software installed and stored in a persistent storage device which can be loaded and executed in a memory by a processor not shown to carry out the processes or operations described throughout this application. Alternatively such components can be implemented as executable code programmed or embedded into dedicated hardware such as an integrated circuit e.g. an application specific IC or ASIC a digital signal processor DSP or a field programmable gate array FPGA which can be accessed via a corresponding driver and or operating system from an application. Furthermore such components can be implemented as specific hardware logic in a processor or processor core as part of an instruction set accessible by a software component via one or more specific instructions.

An action object may include data members and function members. In one embodiment an action includes a query function such as a time forecast function to allow an external routine to query an amount of time required to simulate the corresponding action for example by simulator as well as other attributes or metadata associated with the action e.g. type of action speed of action unit of work or time of the action the result of the action etc. .

In one embodiment agent instance also simply referred to as an agent includes a coroutine manager configured to manage coroutines A B. Coroutine manager may be responsible for communicating with or providing an interface to agent processor and or simulator on behalf of coroutines A B or vice versa. Agent instance further maintains a coroutine stack to store coroutine identifiers IDs identifying some of the coroutines A B when they are suspended and pending to resume while other operations such as simulations or actions of another coroutine are being performed in another thread. Note that each of coroutines A B may be executed in a separate thread e.g. first threads also referred to as coroutine thread or agent routine thread since it hosts or invokes an agent routine. Agent processor may be executed in a separate thread e.g. a second thread and simulator may be executed in another thread e.g. a third thread . These threads may be executed in parallel as part of a multi threading operating environment.

In one embodiment coroutine stack is a first in last out stack. An agent may indicate to the simulator that it wants a certain agent routine in this example agent routine B its event handler to be notified when a certain condition becomes true in the simulation an event . When such an event occurs the simulator notifies the agent processor . The agent processor introduces a new coroutine in this example coroutine B which hosts the event handler routine. The agent processor pushes this new coroutine such as a coroutine identifier of the new coroutine onto the top of coroutine stack belonging to agent instance . When the agent processor determines to give control to the agent instance it examines the coroutine stack and finds coroutine B on top thus it resumes that coroutine B. When the agent routine B exits the agent processor removes its coroutine B from the coroutine stack .

In one embodiment agent processor includes an agent manager for managing one or more agent instances . Each of agent instances may be represented by a respective one of agent objects whose pointers or addresses are maintained by agent processor . Agent processor also maintains an agent queue to store agent instance identifiers e.g. pointers of agent objects pending to be processed or executed by agent processor . Although agent processor may manage multiple agent instances and or coroutines A B only one of the coroutines A B of one of agent instances is active. That is only one of coroutines A B can be actively executed at a time per agent processor while the remaining coroutines are in a suspension or sleep mode. Each of coroutines A B assigned or allocated with execution lock or execution token which represents the right to performed or be executed at the point in time. Each of coroutines A B is allocated with a similar set of processing resources e.g. CPU time memory time slot for execution by agent processor .

In one embodiment for the purpose of illustration when coroutine A invokes agent routine A and agent routine A calls action A to be performed coroutine A determines that action A may be a blocking action that requires a stimulation. An action may be designed or developed by a developer or vendor associated with the simulation. A blocking action is a function call in an agent routine which is expected not to return immediately it represents a simulated action that will take simulated time to complete and the function call will not return until that action s simulation is complete for example to simulate that the action is taking time to perform. In other words the agent routine cannot proceed until the action is simulated so the simulation of the action blocks the agent routine. If it is determined that action A is a blocking action coroutine A sets up the necessary information such as states in corresponding agent instance or its actor indicating that there is a pending action that requires a simulation. Thereafter coroutine A yields the control back to agent processor which in turn selects and executes another coroutine.

Meanwhile simulator runs its simulation in short intervals of simulated time. In each interval starting at simulated time A and ending at simulated time B the state of each simulated object is updated from its state as of time A to its state at time B. The actor represented by each agent instance is a simulated object. For each actor simulator performs the necessary simulation according to the specific action or actions which may be specified in an action object of each action. For example an attribute of an action object may specify the type of the action that may be used to indicate that the corresponding action requires a simulation as well as how the corresponding simulation should be performed. Once the simulation of a particular action of a particular coroutine is completed simulator informs agent processor by adding an identifier of agent instance or the actor into the tail of agent queue . In one embodiment agent queue is a first in first out FIFO buffer. As described above agent processor is running in a separate thread referred to an agent processor thread. When a coroutine yields it wakes up agent processor . Agent processor then selects a coroutine that is pending from the head of agent queue and resumes or executes the selected coroutine.

Note that as shown in there may be multiple agent processors A B each managing multiple agent instances e.g. agent instances A D . Each agent instance represents or manages multiple coroutines e.g. coroutines A D hosting their respective agent routines e.g. agent routines A D . Each agent instance maintains its own coroutine stack e.g. coroutine stacks A D and coroutine manager e.g. coroutine managers A D . Similarly each agent processor maintains its own agent queue agent manager and execution lock or execution token. Each agent processor represents an actor or player or alternatively a group of actors or team of players.

Also note that in an object oriented programming environment each of the components as shown in may be associated with a data structure such as an object or class. Each object includes certain data members and function members to implement its functionalities and to maintain its states or attributes or metadata. For example each of agents A D is associated with an agent object having a list or array of coroutines hosted therein and its associated coroutine stack. The agent object may further include a function member representing an associated coroutine manager. Similarly an action has its action object a coroutine has its own coroutine object an agent processor has its own agent processor object etc. Some of these objects may maintain the addresses of other objects for accessing.

In one embodiment agent processor may be executed in a separate thread with respect to simulator . By releasing the execution lock or token back to agent processor it wakes up agent processor . In response agent processor selects a next coroutine that has been pending for resumption from the head of agent queue or if no coroutine is pending resumption the agent processor waits until a coroutine is inserted into the agent queue . Agent queue is utilized to prioritize the pending coroutines which a coroutine near or at the head of agent queue has a higher priority than the one located at or near the tail of agent queue . Assuming the next coroutine is coroutine B which is located at the head of agent queue . In this example agent processor retrieves an identifier e.g. address handle or pointer of a corresponding coroutine or coroutine object of coroutine B from agent queue and executes or causes coroutine B to be executed by assigning the execution lock to coroutine B. Note that although not shown coroutine B operates in a manner similar to coroutine A. For example coroutine B has the same relationship as A i.e. instead of a different path it may have paths Yield and Resume just like coroutine A. In one embodiment coroutine B may have previously yielded for example by a blocking action. By assigning the execution lock agent processor indicates that the action has completed thus is no longer blocking. It wakes up coroutine B so that coroutine B can resume.

Meanwhile according to one embodiment simulator which is executed in another thread runs its simulation in short intervals of simulated time and updates either through shared memory or a specific API call all of the coroutine objects in this example coroutine objects A B associated with coroutines A B. For example simulator examines states A B of action objects A B to determine which of the actions of the coroutines require simulation. As described above prior to yield a coroutine has set up its states as well as other information in the action object to indicate that a simulation of an action is needed. For those actions that require simulation simulator performs the necessary simulation for the specific action or actions. Optionally via path simulator communicates with each action object in this example action A to obtain any specific information concerning the associated simulation. Alternatively simulator communicates with the corresponding coroutine hosting the action for the simulation information. For example simulator may obtain the amount of time for the simulation for action A. Note that each action may have different parameters such as an amount of time to simulate how long that particular action takes.

Once the simulation is completed simulator signals the end of an action by writing that information to the action A or its associated actor. However simulator also talks to agent processor via path when there is a simulated event. In one embodiment simulator calls an API provided by agent processor for an event notification by passing an event identifier identifying the event. In response based on the event identifier agent processor determines which of agents corresponding to coroutines A B are interested or have registered to receive event notification of that particular event. In one embodiment an agent or agent object includes an attribute or data member storing information indicating which of the events the corresponding agent is interested in receiving a notification.

In response to the event notification agent processor spawns a new coroutine to invoke an agent routine that has been specifically configured to handle an event e.g. event handler . In addition agent processor pushes or causes the corresponding agent to push a coroutine identifier of the new coroutine into the top of a coroutine stack of the corresponding agent object. Once the new agent routine completes the event handling the associated coroutine identifier is then popped from the coroutine stack such that the previously suspended coroutine can resume accordingly.

Subsequently agent processor receives the execution lock for example released or yielded from coroutine B via path . In response agent processor retrieves a coroutine identifier from the head of agent queue in this example coroutine A. Agent processor then wakes up coroutine A to resume by assigning the execution lock to it via path .

In one embodiment an agent routine invoked in response to an event may raise an abort signal by calling a special abort function on the agent s actor object e.g. an abort function of a corresponding agent instance object . The abort signal indicates that all other agent routines which belong to the same agent and which currently block on an action function should disengage from their action function as soon as possible regardless of whether the action s simulation has been completed. In response to the abort signal the agent processor is configured to examine or walk through the list of coroutines that have been pending in the corresponding coroutine stack of the agent to inform each coroutine that an abort signal has been raised or an abort event has occurred.

In one embodiment in response to the abort signal agent processor selects each coroutine in the agent s coroutine stack starting with the routine directly below the routine which raised the abort and continuing down to the routine at the bottom of the stack. For each coroutine the agent processor sets an abort marker in the coroutine e.g. an attribute of a coroutine object . Thereafter when each coroutine is granted the execution lock it checks for an abort marker. If the abort marker exists or is set to a predetermined value the coroutine clears the marker and immediately exits the action function by raising an abort exception. This returns the control to the agent routine which is expected to handle the abort exception by an event handler of the agent routine. In this way all agent routines hosted in the agent s coroutine stack stop blocking on their action functions as soon as possible and have a chance to respond to new information introduced by the original event.

Action simulations for example for game actions can be a variety of simulations. One of the common action simulations is to simulate an amount of time an action is required to take or perform. In one embodiment when the simulator is to perform a time simulation the simulator communicates with each of the actions or coroutines pending for simulations to determine the specific amount of simulation time and to calculate the minimum simulation time interval or increment amongst all pending actions. From this information and from other functions for example prediction of collision between two simulated actors which would trigger agent notification of an event the simulator calculates the best amount of time it can simulate without agent interaction. For example this might be the most possible simulated time before an agent would be notified of an event and before any current action completes. During each scanning period or iteration of the simulation thread the minimum simulation time interval may decrease for each action such that each of the actions can age out or expire at different time based on the specific type of the actions or a time requirement of the actions. Note that in this example as shown in a coroutine yields to give up the execution control back to agent processor voluntarily. In another embodiment agent processor may further include monitoring logic to monitor the operations of the coroutines A B. If a certain condition occurs e.g. holding the execution lock too long agent processor may interrupt or terminate the coroutine to regain the execution lock.

According to one embodiment query logic queries via agent processor which in turn communicates with actions via APIs from actions to receive the required simulation time assuming in this example all actions require an action simulation. Once the simulation time is received from each of actions according to one embodiment time interval calculator calculates the minimum time interval amongst all simulation time of actions . For example it is assumed that simulator sets up timer object having 5 second simulation time while timer object has 10 seconds and timer object has 15 seconds. The minimum time interval would be 5 seconds. Accordingly for the current scanning or inspection period time simulation logic simulate 5 seconds and deducts or decrements the minimum time interval in this example 5 seconds from each of the timer objects . It is assumed that 5 seconds is enough simulated time to complete action to complete so when the time interval is simulated simulator will determine that action is complete. Simulator updates or sets its timer to zero sets its state to indicate completion and notifies the agent processor to resume the coroutine which yielded on the action . In addition an identifier of a coroutine corresponding to action or an identifier of an agent instance associated with the coroutine will be inserted into agent queue of the corresponding agent processor to resume subsequently as described above. On the next iteration query logic will query again and time interval calculator will recalculate the minimum time interval since action has already completed and there may be an additional action requiring simulation and its simulation time may be different.

In another example timer objects may all have 5 seconds remaining but the time interval calculator may determine that after 2 seconds of simulated time an event will occur for example two simulated actors may collide with each other or a new interesting object may be introduced into the simulation. For example to predict a collision event collision logic in the simulator analyzes the trajectories of simulated moving actors and reports that two actors will collide in two seconds. If any agent has requested to be notified of the event then the simulation interval is set to 2 seconds. The 2 second interval is simulated and then the simulator notifies the agent processor of the event for example via an API for notification purpose with an event identifier that identifies a specific event. In response the agent processor spawns one or more new coroutines each of which runs an agent routine. Each agent routine may introduce a new action to be queried for its time forecast.

The techniques described throughout this application can be applied to a variety of situations. One of them can be a gaming application. As a gaming platform provider or designer you may want to design a simulation sim e.g. a game. The sim code performs operations to 1 simulate objects interacting with each other and with the simulated environment 2 administer the rules of a game etc. A game designer would want to allow other people users to write code e.g. agent code which can make decisions and control certain objects e.g. actors in the game. Although the agent decides what to make the actor perform an action the sim determines whether the actor can legally perform that particular action how long it takes and what effect it has on the rest of the simulation. The agent code runs in real time along with the sim. The game designer would want to run many agents from many sources e.g. different agent code developers at the same time and would want to run them all in the game designer s hosted software environment.

The question is how someone can implement the actor so that 1 the action invocations block for the amount of time it takes to simulate the action and 2 the sim can let the agent know events in the meantime and let the agent respond while it s blocking on another action. Each instance of WorkerAgent is assigned a program or agent instance which may be a data structure that represents the execution of one or more agent routines on behalf of the agent instance. The program embodies some functions of a coroutine and some functions of an event handler.

In one embodiment the simulation is running in one or more threads of execution and the agent is running in any number of separate threads as described above. However at most one agent thread runs at a time. Each agent should be allocated with roughly the same amount of processor time to make its decisions. However in simulations or games where multiple agents cooperate on the same team each team should obtain roughly the same amount of processor time. An agent processor represents a pool of processing resources such as processor time. Agents spend most of their time performing actions e.g. acting . While they are doing the actions the action call in the agent code is blocking. Eventually the call returns and the agent must spend time in deciding what to do next e.g. thinking . It is assumed that thinking lasts a small amount of time relative to acting. Within each agent processor only one program or agent instance at a time is given programming resources for thinking. This permission i.e. an execution lock is passed amongst all coroutines in all programs that belong to a single agent processor. Thus all agent routines are inactive their threads are suspended except for the one which holds the execution lock. The agent processor s job is to give the execution lock to a program which is ready to do some thought.

According to one embodiment as described above there are at least three threads running in parallel 1 an agent routine thread which runs agent code 2 an agent processor thread which determines who gets the execution lock and 3 a simulation thread which carries out the effects of the agents decisions.

Within an agent routine thread according to one embodiment following operations may occur dependent upon the specific game design. The first operation is to represent create or allocate the action as a stateful object where an action is represented or associated with an action object.

The agent routine thread then identifies the coroutine whose thread has invoked actor.work . The agent instance or program maintains a stack of coroutines such that the currently running thread always corresponds to the top most recently added or pushed coroutine on the stack. Coroutines are added to the stack as part of Event response below.

In this example program.coroutines.peek is a function member of the corresponding program or agent instance that returns a handle or pointer of a coroutine sitting on the top of the coroutine stack. In one embodiment program.coroutines.peek pops and returns the handle or pointer of the coroutine from the coroutine stack. The agent routine thread then registers this new action with the simulation s timer. This will be utilized or examined by a simulation thread as described above for simulation.

In this example agentProcessor.coroutine.signal wakes up the corresponding agent processor and coroutine.yield releases the execution lock and processing control. The sim runs in another thread e.g. simulation thread continually updating the action until it is done aborted or failed or until the entire program is terminated. This thread eventually resumes. The processing logic of the thread will check for exceptional conditions.

In one embodiment a special method abort is also implemented for an agent to call. This registers an abort on all the coroutines in the program or agent instance so that an agent routine pending high in the coroutine stack responding to a more recent event can invalidate other routines pending lower in the coroutine stack responding to older events . In that case the lower pending routines do not spend any more sim time executing and they do not complete. This communication is across all coroutines. One coroutine is aborted due to another coroutine that has ordered the abort via the following function which sets flags on the aborted coroutine and queues it for resumption 

An agent processor which is running in an agent processor thread manages all the coroutines from one or more agent instances or programs. It shares an execution lock or token with its agent routines and alternately runs its own management logic then runs an agent routine until the agent routine yields then runs its own management logic again etc. In one embodiment an agent processor thread is shown as follows 

It is in the best interest of each agent to think quickly and yield the execution lock as soon as possible so that other coroutines and other agents on its team can be effective. According to one embodiment the system may spawn an additional monitoring thread which does not require or share the coroutines execution lock from the agent processor. That monitor tracks how long each coroutine holds the lock. If the time exceeds a first predetermined threshold the monitor warns it by setting a flag on the agent object and if it exceeds a second e.g. higher threshold the monitor forcibly terminates the coroutine. Such a monitoring logic may be a global monitoring logic shared by all agent processors. Alternatively each agent processor maintains its own monitoring logic for monitoring the coroutines it manages. For example the monitoring logic may be implemented as part of an agent manager of an agent processor.

As described above the simulation itself runs in another thread. It simulates the progress and result of each actor s action as time moves forward in the simulation. Let s use the WorkAction example where of course the logic is trivial but it tracks time and the effect of the work 

This design lets the system run the simulation timing in a valuable way where a game designer does not have to quantize time into equally sized intervals. Instead the game designer can compute each interval so that it is as long as possible and yet it ends exactly when an agent s action is complete. In other words the simulation advances its clock along the vertices of each action s start time and end time not by a fixed interval. The simulator can call each action s forecastEndTime to determine how long each action is expected to take.

According to one embodiment the simulator first calculates the length of time that the simulation can run by itself with all agents acting and none thinking.

This calculation is deterministic because by definition no agent can think until the end of the interval. The interval should also end when some event would cause an agent s listener to be run e.g. two moving actors collide with each other or when a random simulated event occurs. The time of these events is deterministic as long as no agent is thinking so the sim determines them in advance and then it would have all available information to forecast the interval s end time.

If there s a human player interacting with the simulation too then a human player action may happen the simulator can convert the time of the action to the simulation time and include it in the timer s inputs. The agent s actions may have to be rolled back for one interval depending on how the human input is integrated into the simulation. After determining the timing interval the simulator simulates each actor for that length of time 

The simulator carries out the appropriate portion of the action. If the simulation deems that the action can t happen via an ActionFailure exception it sets flags on the aborted coroutine and marks it completed so it will be queued for resumption.

The simulator tells the processor to queue the coroutine for resumption if it has finished successfully or otherwise .

According to one embodiment at the start of the simulation the simulation sets up all its state and then its starts the agents.

Throughout the simulation events occur and agents have implemented event listeners in this example LunchtimeListener is an event listener interface . When the simulation originates the event it determines which programs want to handle those events.

Then the processing logic such as a coroutine manager adds this to the program s coroutine stack and schedules it for resumption. Because it s on top of the program s coroutine stack it will run actions lower on the stack won t run until this one has exited successfully or otherwise .

As described above an agent routine or agent code may be developed by one developer while a coroutine may be developed by another developer. An agent processor may process multiple coroutines and each coroutine may invoke multiple agent routines developed by different developers or vendors. A game may involve multiple agent processors representing multiple actors or teams of actors. As a result code may contains malfunction code compiled therein unintentionally or intentionally. For the security purpose each of the agent routines or coroutine may be hosted in a sandboxed operating environment such as a virtual machine VM such that a malfunction of a routine will not have a significantly impact on other routines or the operating system in general.

In one embodiment the agent execution processes run in a Java virtual machine JVM which listens for requests to simulate. The JVM has an active security manager not shown . The engine s security policy prohibits direct access to the structure of the simulation and to the computer s operating system. Agents not written in Java run in Java based interpreters e.g. a Python agent runs in a Python interpreter implemented in Java which converts Python code into Java objects. The entire interpreter is subject to almost the same security restrictions as Java agents. However the interpreter needs some security privileges to convert the agent code into Java objects. Thus an embodiment of the invention uses a customized version of the interpreter which prevents the agent code from enjoying the same privileges.

The JVM runs in a jailed process on the computer s operating system such as a Linux operating system. If an agent gains control of JVM jailed process ensures that it cannot access any computing resources other than those necessary to run the simulation nor any data stored on the computer . Computer itself is a slave dedicated only to serving requests to run the simulation. None of the owner s data or other programs reside on computer and the computer s networking is configured so that it cannot initiate any connection over the network.

The agents themselves the program source code or compiled object code that dictates agent behavior are not stored on slave computer nor are the results of the simulation. Instead all requests to simulate originate on master computer which stores the agents . The master determines when a simulation is to be run retrieves the agent software and converts it to a serial format. The master initiates a connection to the slave transmitting the serialized agents along with the request to run the simulation. The slave simulates and returns results to the master. The master stores the results and terminates the connection.

Another security consideration involves runaway code. The interruptible coroutine design as described above lets the agent code decide when to give up control. An agent may never give up control either by malice or by accident. So the engine monitors the agent to ensure it gives up control within a maximum amount of time. If it does not it tries to warn the agent and then forcibly terminates it.

An agent that runs in this environment is of potential value to anyone in the world the customer who takes an interest in its simulation. Customers may or may not have programming skill. The invention provides a marketplace where customers can find the agent that has the most desirable behavior in the simulation. The agents performance in the simulation is analyzed and the agents are profiled according to different metrics which guide the customer s selection. The customer may be charged a payment for the use of the agent. Because the agent code is executed by the simulation and not directly by the customer a number of licensing options are available without further work to enforce licenses in the software. An agent s author may charge for example a flat fee for unlimited use of the agent by the customer a flat fee following a free trial subscription period a fee every time the agent runs in the simulation or a fee only when the agent successfully completes a certain task in the simulation.

In one embodiment system includes processor memory and devices via a bus or an interconnect . Processor may represent a single processor or multiple processors with a single processor core or multiple processor cores included therein. Processor may represent one or more general purpose processors such as a microprocessor a central processing unit CPU or the like. More particularly processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processors such as an application specific integrated circuit ASIC a cellular or baseband processor a field programmable gate array FPGA a digital signal processor DSP a network processor a graphics processor a network processor a communications processor a cryptographic processor a co processor an embedded processor or any other type of logic capable of processing instructions.

Processor which may be a low power multi core processor socket such as an ultra low voltage processor may act as a main processing unit and central hub for communication with the various components of the system. Such processor can be implemented as a system on chip SoC . Processor is configured to execute instructions for performing the operations and steps discussed herein. System may further include a graphics interface that communicates with optional graphics subsystem which may include a display controller a graphics processor and or a display device.

Processor may communicate with memory which in one embodiment can be implemented via multiple memory devices to provide for a given amount of system memory. Memory may include one or more volatile storage or memory devices such as random access memory RAM dynamic RAM DRAM synchronous DRAM SDRAM static RAM SRAM or other types of storage devices. Memory may store information including sequences of instructions that are executed by processor or any other device. For example executable code and or data of a variety of operating systems device drivers firmware e.g. input output basic system or BIOS and or applications can be loaded in memory and executed by processor . An operating system can be any kind of operating systems such as for example Windows operating system from Microsoft Mac OS iOS from Apple Android from Google Linux Unix or other real time or embedded operating systems such as VxWorks.

System may further include IO devices such as devices including network interface device s optional input device s and other optional IO device s . Network interface device may include a wireless transceiver and or a network interface card NIC . The wireless transceiver may be a WiFi transceiver an infrared transceiver a Bluetooth transceiver a WiMax transceiver a wireless cellular telephony transceiver a satellite transceiver e.g. a global positioning system GPS transceiver or other radio frequency RF transceivers or a combination thereof. The NIC may be an Ethernet card.

Input device s may include a mouse a touch pad a touch sensitive screen which may be integrated with display device a pointer device such as a stylus and or a keyboard e.g. physical keyboard or a virtual keyboard displayed as part of a touch sensitive screen . For example input device may include a touch screen controller coupled to a touch screen. The touch screen and touch screen controller can for example detect contact and movement or break thereof using any of a plurality of touch sensitivity technologies including but not limited to capacitive resistive infrared and surface acoustic wave technologies as well as other proximity sensor arrays or other elements for determining one or more points of contact with the touch screen.

IOdevices may include an audio device. An audio device may include a speaker and or a microphone to facilitate voice enabled functions such as voice recognition voice replication digital recording and or telephony functions. Other IO devices may further include universal serial bus USB port s parallel port s serial port s a printer a network interface a bus bridge e.g. a PCI PCI bridge sensor s e.g. a motion sensor such as an accelerometer gyroscope a magnetometer a light sensor compass a proximity sensor etc. or a combination thereof. Devices may further include an imaging processing subsystem e.g. a camera which may include an optical sensor such as a charged coupled device CCD or a complementary metal oxide semiconductor CMOS optical sensor utilized to facilitate camera functions such as recording photographs and video clips. Certain sensors may be coupled to interconnect via a sensor hub not shown while other devices such as a keyboard or thermal sensor may be controlled by an embedded controller not shown dependent upon the specific configuration or design of system .

To provide for persistent storage of information such as data applications one or more operating systems and so forth a mass storage not shown may also couple to processor . In various embodiments to enable a thinner and lighter system design as well as to improve system responsiveness this mass storage may be implemented via a solid state device SSD . However in other embodiments the mass storage may primarily be implemented using a hard disk drive HDD with a smaller amount of SSD storage to act as a SSD cache to enable non volatile storage of context state and other such information during power down events so that a fast power up can occur on re initiation of system activities. Also a flash device may be coupled to processor e.g. via a serial peripheral interface SPI . This flash device may provide for non volatile storage of system software including a basic input output software BIOS as well as other firmware of the system.

Storage device may include computer accessible storage medium also known as a machine readable storage medium or a computer readable medium on which is stored one or more sets of instructions or software e.g. module unit and or logic embodying any one or more of the methodologies or functions described herein. Module unit logic may also reside completely or at least partially within memory and or within processor during execution thereof by data processing system memory and processor also constituting machine accessible storage media. Module unit logic may further be transmitted or received over a network via network interface device .

Computer readable storage medium may also be used to store the some software functionalities described above persistently. While computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The terms computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media or any other non transitory machine readable medium.

Module unit logic components and other features described herein can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition module unit logic can be implemented as firmware or functional circuitry within hardware devices. Further module unit logic can be implemented in any combination hardware devices and software components.

Note that while system is illustrated with various components of a data processing system it is not intended to represent any particular architecture or manner of interconnecting the components as such details are not germane to embodiments of the present invention. It will also be appreciated that network computers handheld computers mobile phones servers and or other data processing systems which have fewer components or perhaps more components may also be used with embodiments of the invention.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as those set forth in the claims below refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. Such a computer program is stored in a non transitory computer readable medium. A machine readable medium includes any mechanism for storing information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices .

The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software e.g. embodied on a non transitory computer readable medium or a combination of both. Although the processes or methods are described above in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

Embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

