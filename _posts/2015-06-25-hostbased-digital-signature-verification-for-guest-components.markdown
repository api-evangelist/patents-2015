---

title: Host-based digital signature verification for guest components
abstract: Examples perform external verification of authenticity of software components loaded onto virtual machines (VM). A processor, external to the VM, reads the loaded software component from the VM, and restores the loaded software component to its disk image state by undoing any changes made to load the software component. The digital signature is read from the restored disk image of the software and compared to the verified digital signature of the publisher of the software component. Some examples contemplate marking the software component as verified or unverified, and preventing unverified software components from making global changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09531547&OS=09531547&RS=09531547
owner: VMware, Inc.
number: 09531547
owner_city: Palo Alto
owner_country: US
publication_date: 20150625
---
Benefit is claimed under 35 U.S.C. 119 a d to Foreign application Serial No. 1810 CHE 2015 filed in India entitled HOST BASED DIGITAL SIGNATURE VERIFICATION FOR GUEST COMPONENTS on Apr. 6 2015 by VMware Inc. which is herein incorporated in its entirety by reference for all purposes.

Verifying digital signatures of software components ensures the authenticity and integrity of the software component. Some commercial operating systems include built in support for verifying the digital signature of software components. Unfortunately this verification support is not always enabled in those operating systems and it can also be explicitly disabled on a compromised operating system.

Usually verification of digital signature occurs internally when a guest operating system operating on a virtual machine VM verifies the software component which the guest operating system has loaded in a form of self verification by the guest operating system. However this method of self verification is susceptible to tampering. In some examples a disk copy of the software component is tampered with and the operating system digital signature verification system may be disabled. In another example the guest operating system s digital signature verification happens however the loaded copy is tampered with after the guest operating system s signature verification is complete. Such compromises to the security of the digital signature would be undetectable.

The disclosure provides examples of techniques for verifying that software components loaded by a guest operating system on a virtual machine VM are valid. Some virtual machines load software components which may be corrupted unverified or otherwise compromised. The disclosure provides examples of verification of loaded software components by an element external to the virtual machine or guest operating system loading the software component. In some examples a software component is valid if has not been altered since leaving the publisher.

While various guest operating systems have built in verification systems those systems are susceptible to corruption and to errors created when the verification systems are disabled. The verification system described herein shifts the verification to the host or hypervisor which operate external to the guest operating system. For example aspects of the disclosure enable the host or hypervisor to confirm that the digital signature of a software component is authentic. As part of the signing process when a software component is created it is digitally signed by its publisher. The digital signature of a program is created by taking a hash also known as a message digest of the program binary bits and then encrypting this hash with a private key of the publisher of the software component. The private key is only known to the publisher. Corresponding to the private key there is a public key that is self contained in the executable itself. The encrypted hash which can be decrypted using the public key is stored in the signature block itself. Once decrypted the hash is used to verify if the sender is the one that is expected.

In one example after a portable executable is generated a publisher uses signing tools such as signtol.exe to sign the portable executable PE . As part of the signing process a digital signature is generated and appended to the end of the PE and one of the section headers in the PE format points to the location of the signature. In the present example the signature is a standard PKCS7 SignedData structure. The PKCS 7 SignedData structure contains the PE file s hash value a signature created by the software publisher s private key and the certificates that bind the software publisher s signing key to a legal entity.

Aspects of the disclosure enable a virtual machine manager VMM to read the loaded copy of the software component. The VMM provides the loaded copy of the software component to a digital signature verifier which converts the loaded software component to its disk copy state. The digital signature verifier calculates discovers or otherwise obtains the digital signature of the software component from the version of the software component in its disk state. In examples in which the signature is part of the executable the signature verifier does not need anything beyond the loaded software component and signature block to perform the verification. Subsequently the digital signature verifier uses a public key to decrypt the digital signature of the software component to verify that the hash associated with the software component matches that of the publisher of the software component. The digital signature is in some examples part of the executable of the software component. The verification of the digital signature typically involves computing the hash of the executable and matching it with the encrypted hash stored in the signature. The encrypted hash is decrypted using the public key of the publisher which is also stored as part of the signature. In some example the digital signature verifier informs an external policy framework of the outcome of the comparison which decides what to do when the verification fails. Alternatively or in addition the digital signature verifier notifies the guest operating system of the outcome of the comparison.

External verification of the integrity of the software component by the host or hypervisor is more reliable than internal verification by the VM or the guest operating system because the host or hypervisor does not rely on information or processes located on the guest operating system other than the loaded software component to verify the software component. Consequently the methods of verifying software components described in this document are more reliable less prone to tampering and not as easy to disable in contrast to verification systems which operate internally on the VM. With verification systems that operate internal to the VM it is difficult to ensure that those systems have not been compromised. In some examples the software component is not loaded on a VM but rather is loaded on a container or other type of data compute node.

In this example the guest operating system has loaded SC . The software component is unverified. In some examples all newly loaded SCs are automatically marked as unverified. If SC is unverified in this example it is unknown whether SC has been tampered with or whether the origin of SC in some examples the publisher is legitimate. The digital signature verification proxy operating on the guest operating system notifies the VMM that SC has been loaded on the guest operating system . This notification may occur via a hypercall to the VMM . The hypercall includes in some examples information about the argument block linear address of the loaded software component and the length of that argument block linear address. The argument block carries in some examples meta information about the SC . The meta information includes in some examples the start and length of the loaded SC the start and length of the digital signature of the SC and any other information that may be required by the digital signature verifier .

The VMM located on the hypervisor responds to the notification of a newly loaded SC by initiating verification of SC through the digital signature verifier also located in this example on the hypervisor. The digital signature verifier utilizes the information provided in the hypercall to read the argument block. Subsequently the information in the argument block is used to read the data the argument block points to. The VMM and the digital signature verifier communicate through an API. In some examples such as in the digital signature verifier is located on the host computing device separately from the hypervisor .

Initially the GOS operating on the VM loads a software component from the software component s disk. The GOS in some examples using the digital signature verification proxy makes a hypercall notifying the VMM that a SC has been loaded. The hypercall includes the argument block linear address and length of the loaded SC . In response the VMM marks the SC as unverified and reads the argument block linear address. In some examples an SC is automatically marked as unverified when it is loaded. An SC is unverified when the GOS has not yet verified the publisher of the SC and that the SC has not been tampered with. Reading the argument block linear address provides the VMM with the load address of the SC and the size of the SC . The VMM reads the location of the SC until it has read the entire length of the SC from that location. After completely reading the SC and the signature from the GOS the VMM creates a copy of the loaded SC abbreviated in the Figures as LSC .

The VMM furnishes the loaded SC to the digital signature verifier . As will be described in further detail below the digital signature verifier working backwards from the loaded SC undoes all of the changes made by the GOS to create the loaded SC . As part of this process in some examples the starting address and length of the loaded copy of the SC and the digital signature are passed in an argument block. The digital signature verifier reads the guest memory occupied by the loaded copy of the SC and the digital signature and generates the disk copy which includes the digital signature. The result is that the loaded SC is restored to its original disk copy state of the SC abbreviated as DSC in the Figures in order to allow the digital signature verifier to read the digital signature from the original disk copy state of the SC since the loaded copy of the SC does not include the digital signature. That is the digital signature verifier reads the LSC and reads the signature using information specified in the argument block. Relocations are de applied and resolutions are imported along with other state changes on the LSC to combine with the signature and generated the DSC.

The digital signature verifier then computes the hash of the executable of the SC . In some examples this computed has is referred to as the discovered digital signature or the first digital signature. The digital signature verifier also decrypts the hash stored in the digital signature using the public key of the SC publisher. The decrypted hash in some examples is referred to as the known digital signature or the second digital signature. The public key of the SC is in some examples extracted from the digital signature. After computing the hash of the executable and decrypting the hash stored in the digital signature the digital signature verifier compares the hash of the digital signature of the disk copy state of the SC to the known digital signature of the publisher to confirm that the disk copy state of the SC is authentic and that it has not been tampered with. That is the hash is computed in the same way that it would have been computed previously and then it is compared with the decrypted hash. The result of this comparison is transmitted back to the GOS in some examples but other examples contemplate no notification being sent to the GOS . The SC is in some examples marked or flagged with the results of the comparison. Possible results include that the digital signature is verified as authentic verified as not authentic or that the verification was performed but the authenticity is not known . In some examples the results are dirty or clean trusted or untrusted valid or invalid or any other result description which indicates that the digital signature of the publisher and the integrity of the SC was evaluated by the digital signature verifier .

In some examples the loaded SC does not have the signature mapped. In such examples the loaded SC reads the signature back from the disk and passes the start length of the loaded SC and the signature block in the argument block.

When the GOS loads the SC it makes a hypercall to the VMM which in some examples is operated by the hypervisor . The hypercall includes information about the loaded SC in an argument block. The information passed to the VMM includes the start address where the SC is loaded the size of the SC excluding the digital signature the start address of the digital signature the size of the digital signature and any other information which may be required by the digital signature verifier . The VMM utilizes this information to read the loaded state of the SC .

In response to receiving the hypercall from the GOS the VMM marks the SC as unverified at . In some examples the SC is marked as unverified upon loading. The GOS does not make any global changes or effect any other GOSs or VMs while awaiting verification. The SC is not permitted to operate in an unverified state. At the VMM identifies the location of the SC . The VMM reads this information from the argument block linear address provided by the GOS . The information read at the argument block linear address includes any relevant information about the SC including the size and address of the SC .

In some examples the signature block is not mapped in the address space of the loaded SC . In these examples the SC reads the signature block and passes the start length of the loaded SC and signature block. The digital signature verifier arrives at the DSC using the loaded SC and the signature block.

Once the memory region of the SC has been fully read the VMM creates a copy of the loaded SC referred to as LSC in the figures at . The copy created by the VMM from the read content duplicates the SC as it exists on the GOS . The VM transmits the copy of the loaded SC to the digital signature verifier at . At after receiving the copy of the loaded SC the digital signature verifier restores it to the disk copy state of the SC . The operations performed by the digital signature verifier to restore the copy of the loaded SC to its disk copy state referred to in the Figures as DSC are illustrated in and described in the detailed description of .

When the software component was created a hash of the program binary bits was taken and encrypted with a private key of the publisher of the SC to make the digital signature. The digital signature verifier partially recreates this step by computing the hash of the executable it reads from the disk copy state of the SC in some examples referred to as the discovered digital signature or first digital signature . The digital signature verifier also uses a public key to decrypt the digital signature on the disk copy state of the SC to get a second hash in some examples referred to as the known digital signature or second digital signature . The digital signature verifier compares the computed hash to the decrypted hash at . In some examples for instance in WINDOWS brand operating systems the digital signature is not part of the loaded SC . Instead in that example the digital signature needs to be read explicitly by the software component and its memory location is reported as part of the argument block. In some examples the digital signature verifier compares tokens hashes bits or any other identifying information known in the art to verify the authenticity of the SC . For example the digital signature verifier may compute the hash of the executable using the algorithm for hashing stored in the signature block and decrypt the hash stored in the signature block using the public key of the publisher and match the decrypted hash with the computed hash. The public key in that example is available in the certificate that is part of the signature.

If the two hashes also described as the discovered digital signature and the known digital signature match the SC is marked as verified by the digital signature verifier and the verification is that the digital signature and thus the SC are authentic at . However if the discovered digital signature and the known digital signature do not match then although the SC has been verified by the digital signature verifier it is marked as not authentic at . In some examples the digital signature verifier is unable to authenticate the digital signature and the SC is marked as verified but unknown. For example the known digital signature may be unavailable or the discovered digital signature may be corrupted.

In this example all SCs which have been examined by the digital signature verifier are marked as verified so that they are not inadvertently sent through the process again. However if the discovered digital signature does not match the known digital signature of the publisher the SC is marked as not authentic so that the GOS or the host computing device or hypervisor may take appropriate actions. In some examples the GOS host computing device hypervisor user or administrator removes the SC quarantines the GOS permanently locks the GOS or takes other action in response to a verification that the SC is not authentic.

While the outcome of these operations is described in terms of verification and authenticity any other descriptive terms are interchangeable. For example SCs may be described as invalid or valid clean or dirty known or unknown safe or unsafe trusted or untrusted or any other descriptive taxonomy.

At the VMM marks the SC as unverified. In some examples an unverified SC is prohibited from making any changes to global variables the VM running the GOS which loaded the unverified SC is quarantined the GOS is locked or the unverified SC and its associated VM and GOS are otherwise prevented from affecting other components of the system. In some examples the host computing device or hypervisor implements policies regarding unverified SCs .

At the VMM reads the memory region of the GOS containing the loaded SC . in some examples the VMM iteratively reads the memory region until the entire loaded SC is read. After the entire loaded SC is read the VMM creates a copy of the loaded SC referred to as LSC in the Figures at . In some examples the VMM begins to create a copy of the loaded SC while still reading the memory region where the loaded SC is located. After creating the copy of the loaded SC the VMM transits the copy of the loaded SC to the digital signature verifier at .

First the digital signature verifier de applies any relocations on the copy of the loaded SC at . This returns the copy of the loaded SC to its position before the GOS relocated it at the conclusion of loading it. At the digital signature verifier de applies on the copy of the loaded SC any import resolutions that the GOS performed on the SC . If any global state changes were made when the SC was installed the digital signature verifier de applies those global state changes at . The digital signature verifier evaluates the copy of the loaded SC for any requirements specific to its executable type at . For instance if any operations were performed to load the SC those operations would be reversed based on the type of executable at . In some examples the GOS performed additional operations in loading the SC which are not illustrated in . Those operations are also reversed to reach a disk state copy of the loaded SC .

At after the digital signature verifier has reversed all the operations performed by the GOS on the copy of the loaded SC the digital signature verifier discovers the digital signature of the disk state copy of the loaded SC . Discovering the digital signature in some example includes the loaded SC reading the signature block from the disk and informing where in memory the loaded SC and the signature block are accessible. The digital signature verifier computes the hash e.g. H in the same way the hash would have been computed previously e.g. by a signing tool . The hash e.g. H stored in the signature is then decrypted using the public key of the publisher of the SC which is also available in the signature block. The digital signature verifier compares the discovered digital signature e.g. with the known digital signature e.g. H . If the discovered digital signature and the known digital signature e.g. the two hashes match the SC is marked as verified and authentic at . If the discovered digital signature and the known digital signature do not match the SC is marked as verified and not authentic. Marking the SC in some examples includes notifying the GOS or other components of the result of the digital signature verification. In some examples the known digital signature of the publisher of the software component is stored by the host computing device and accessed by the digital signature verifier . In other examples the digital signature verifier requests from the publisher of the SC the known digital signature of the publisher.

The VMM also initiates the digital signature verification by contacting the digital signature verifier . In the example illustrated in the VMM is located on the hypervisor while the digital signature verifier is located on the host computing device . In some examples both the VMM and the digital signature verifier are located on the hypervisor . In other examples both the VMM and the digital signature verifier are located on the host computing device . The location of the VMM and the digital signature verifier may vary however they must always be outside of the GOS and the VM in order to provide more reliable digital signature verification with less opportunity for corruption.

The digital signature verifier invokes an API e.g. ReadDriverMemory that reads the copy of the loaded SC from the VMM . The digital signature verifier invokes a second API e.g. ReadDriverSignature which requests the digital signature of the loaded SC from the VMM . Once the digital signature verifier has the entire copy of the loaded SC the digital signature verifier invokes any API e.g. GenerateDiskImage to create a disk state copy of the copy of the loaded SC . The digital signature verifier then invokes an API e.g. VerifyDigitalSignature to compare the discovered digital signature with the known digital signature and further invokes an API e.g. NotifyResult to notify other elements for instance the GOS of the results of the comparison.

Certain examples described herein involve a hardware abstraction layer on top of a host computer e.g. server . The hardware abstraction layer allows multiple containers to share the hardware resource. These containers isolated from each other have at least a user application running therein. The hardware abstraction layer thus provides benefits of resource isolation and allocation among the containers. In the foregoing examples VMs are used as an example for the containers and hypervisors as an example for the hardware abstraction layer. Each VM generally includes a guest operating system in which at least one application runs. It should be noted that these examples may also apply to other examples of containers such as containers not including a guest operating system referred to herein as OS less containers see e.g. www.docker.com . OS less containers implement operating system level virtualization wherein an abstraction layer is provided on top of the kernel of an operating system on a host computer. The abstraction layer supports multiple OS less containers each including an application and its dependencies. Each OS less container runs as an isolated process in user space on the host operating system and shares the kernel with other containers. The OS less container relies on the kernel s functionality to make use of resource isolation CPU memory block I O network etc and separate namespaces and to completely isolate the application s view of the operating environments. By using OS less containers resources can be isolated services restricted and processes provisioned to have a private view of the operating system with their own process ID space file system structure and network interfaces. Multiple containers can share the same kernel but each container can be constrained to only use a defined amount of resources such as CPU memory and I O.

In one example traces are installed on all memory blocks of the SC while performing verification. The traces are marked as read only. If at attempt is made to modify the in memory blocks the hypervisor is notified. Such notification may include marking the SC as unverified again requiring that the digital signature verification is performed or implementing a quarantine or locking policy.

In another example policies exist for implementation depending on the result of the digital signature verification. For instance the hypervisor may have a policy requiring quarantine of any SC marked as not authentic after digital signature verification.

Host computing device may include a user interface device for receiving data from a user and or for presenting data to user . User may interact indirectly with host computing device via another computing device such as VM ware s vCenter Server or other management device. User interface device may include for example a keyboard a pointing device a mouse a stylus a touch sensitive panel e.g. a touch pad or a touch screen a gyroscope an accelerometer a position detector and or an audio input device. In some examples user interface device operates to receive data from user while another device e.g. a presentation device operates to present data to user . In other examples user interface device has a single component such as a touch screen that functions to both output data to user and receive data from user . In such examples user interface device operates as a presentation device for presenting information to user . In such examples user interface device represents any component capable of conveying information to user . For example user interface device may include without limitation a display device e.g. a liquid crystal display LCD organic light emitting diode OLED display or electronic ink display and or an audio output device e.g. a speaker or headphones . In some examples user interface device includes an output adapter such as a video adapter and of an audio adapter. An output adapter is operatively coupled to processor and configured to be operatively coupled to an output device such as a display device or an audio output device.

Host computing device also includes a network communication interface which enables host computing device to communicate with a remote device e.g. another computing device via a communication medium such as a wired or wireless packet network. For example host computing device may transmit and or receive data via network communication interface . User interface device and or network communication interface may be referred to collectively as an input interface and may be configured to receive information from user .

Host computing device further includes a storage interface that enables host computing device to communicate with one or more datastores which store virtual disk images software applications and or any other data suitable for use with the methods described herein. In some examples storage interface couples host computing device to a storage area network SAN e.g. a Fibre Channel network and or to a network attached storage NAS system e.g. via a packet network . The storage interface may be integrated with network communication interface .

Host computing device includes a hardware platform such as an x86 architecture platform. Hardware platform may include processor memory network communication interface user interface device and other input output I O devices such as a presentation device not shown . A virtualization software layer also referred to hereinafter as a hypervisor is installed on top of hardware platform .

The virtualization software layer supports a virtual machine execution space within which multiple virtual machines VMs may he concurrently instantiated and executed. Hypervisor includes a device driver layer and maps physical resources of hardware platform e.g. processor memory network communication interface and or user interface device to virtual resources of each of VMs such that each of VMs has its own virtual hardware platform e.g. a corresponding one of virtual hardware platforms each virtual hardware platform having its own emulated hardware such as a processor a memory a network communication interface a user interface device and other emulated I O devices in VM . Hypervisor may manage e.g. monitor initiate and or terminate execution of VMs according to policies associated with hypervisor such as a policy specifying that Vis are to be automatically restarted upon unexpected termination and or upon initialization of hypervisor . In addition or alternatively hypervisor may manage execution VMs based on requests received from a device other than host computing device . For example hypervisor may receive an execution instruction specifying the initiation of execution of first VM from a management device via network communication interface and execute the execution instruction to initiate execution of first VM .

In some examples memory in first virtual hardware platform includes a virtual disk that is associated with or mapped to one or more virtual disk images stored on a disk e.g. a hard disk or solid state disk of host computing device . The virtual disk image represents a file system e.g. a hierarchy of directories and files used by first VM in a single file or in a plurality of files each of which includes a portion of the file system. In addition or alternatively virtual disk images may be stored on one or more remote computing devices such as in a storage area network SAN configuration. In such examples any quantity of virtual disk images may be stored by the remote computing devices.

Device driver layer includes for example a communication interface driver that interacts with network communication interface to receive and transmit data from for example a local area network LAN connected to host computing device . Communication interface driver also includes a virtual bridge that simulates the broadcasting of data packets in a physical network received from one communication interface e.g. network communication interface to other communication interfaces e.g. the virtual communication interfaces of VMs . Each virtual communication interface for each VM such as network communication interface for first VM may be assigned a unique virtual Media Access Control MAC address that enables virtual bridge to simulate the forwarding of incoming data packets from network communication interface . In an example network communication interface is an Ethernet adapter that is configured in promiscuous mode such that all Ethernet packets that it receives rather than just Ethernet packets addressed to its own physical MAC address are passed to virtual bridge which in turn is able to further forward the Ethernet packets to VMs . This configuration enables an Ethernet packet that has a virtual MAC address as its destination address to properly reach the VM in host computing device with a virtual communication interface that corresponds to such virtual MAC address.

Virtual hardware platform may function as an equivalent of a standard x86 hardware architecture such that any x86 compatible desktop operating system e.g. Microsoft WINDOWS brand operating system LINUX brand operating system SOLARIS brand operating system NETWARE or FREEBSD may be installed as guest operating system OS in order to execute applications for an instantiated VM such as first VM . Virtual hardware platforms may be considered to be part of virtual machine monitors VMM that implement virtual system support to coordinate operations between hypervisor and corresponding VMs . Those with ordinary skill in the art will recognize that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit or scope of the disclosure. For example virtual hardware platforms may also be considered to be separate from VMMs and VMMs may be considered to be separate from hypervisor . One example of hypervisor that may be used in an example of the disclosure is included as a component in VMware s ESX brand software which is commercially available from VMware Inc.

The operations described herein may be performed by a computer or computing device. The computing devices communicate with each other through an exchange of messages and or stored data. Communication may occur using any protocol or mechanism over any wired or wireless connection. A computing device may transmit a message as a broadcast message e.g. to an entire network and or data bus a multicast message e.g. addressed to a plurality of other computing devices and or as a plurality of unicast messages each of which is addressed to an individual computing device. Further in some examples messages are transmitted using a network protocol that does not guarantee delivery such as User Datagram Protocol UDP . Accordingly when transmitting a message a computing device may transmit multiple copies of the message enabling the computing device to reduce the risk of non delivery.

By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media are tangible non transitory and are mutually exclusive to communication media. In some examples computer storage media are implemented in hardware. Exemplary computer storage media include hard disks flash memory drives digital versatile discs DVDs compact discs CDs floppy disks tape cassettes and other solid state memory. In contrast communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media.

Although described in connection with an exemplary computing system environment examples of the disclosure are operative with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with aspects of the disclosure include but are not limited to mobile computing devices personal computers server computers hand held or laptop devices multiprocessor systems gaming consoles microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Examples of the disclosure may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. The computer executable instructions may he organized into one or more computer executable components or modules. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. Aspects of the disclosure may be implemented with any number and organization of such components or modules. For example aspects of the disclosure are not limited to the specific computer executable instructions or the specific components or modules illustrated in the figures and described herein. Other examples of the disclosure may include different computer executable instructions or components having more or less functionality than illustrated and described herein.

Aspects of the disclosure transform a general purpose computer into a special purpose computing device when programmed to execute the instructions described herein.

The examples illustrated and described herein as well as examples not specifically described herein but within the scope of aspects of the disclosure constitute exemplary means for verifying by a host or hypervisor the digital signature of a software component operating on a guest operating system. Verification of the software component by an element external to the VM for instance the host or hypervisor increases the validity of the verification. Some examples contemplate creating a disk state copy of the software component by reversing any changes made in loading the software component. The digital signature of the disk state copy of the software component may then be verified by comparing it to a known digital signature of the publisher of the software component.

At least a portion of the functionality of the various elements illustrated in the figures may be performed by other elements in the figures or an entity e.g. processor web service server application program computing device etc. not shown in the figures.

In some examples the operations illustrated in the figures may be implemented as software instructions encoded on a computer readable medium in hardware programmed or designed to perform the operations or both. For example aspects of the disclosure may be implemented as a system on a chip or other circuitry including a plurality of interconnected electrically conductive elements.

The order of execution or performance of the operations in examples of the disclosure illustrated and described herein is not essential unless otherwise specified. That is the operations may be performed in any order unless otherwise specified and examples of the disclosure may include additional or fewer operations than those disclosed herein. For example it is contemplated that executing or performing a particular operation before contemporaneously with or after another operation is within the scope of aspects of the disclosure.

When introducing elements of aspects of the disclosure or the examples thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements. The term exemplary is intended to mean an example of .

Having described aspects of the disclosure in detail it will be apparent that modifications and variations are possible without departing from the scope of aspects of the disclosure as defined in the appended claims. As various changes could be made in the above constructions products and methods without departing from the scope of aspects of the disclosure it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

