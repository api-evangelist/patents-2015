---

title: Method, apparatus and server for identity authentication
abstract: The disclosure relates to a method, apparatus and server for identity authentication, related to communication technique to solve system overload problem caused by invalid access ID attack. The method may include: a server receiving an API calling request from third party developer, the API calling request carrying access ID generated in advance by server and assigned to the third party developer; searching for a version character carried in the access ID; based on a version character generation rule, verifying whether the version number marked by the version character being the same as a version number of the check character generation rule used by the server; when the version character being verified successfully, searching for at least a check character carried in the access ID; and based on the check character generation rule, verifying respectively on the at least a check character. The disclosure is applied to API calling request process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09444806&OS=09444806&RS=09444806
owner: TENCENT TECHNOLOGY (SHENZHEN) COMPANY LIMITED
number: 09444806
owner_city: Shenzhen
owner_country: CN
publication_date: 20150219
---
This application is a U.S. continuation application under 35 U.S.C. 111 a claiming priority under 35 U.S.C. 120 and 365 c to International Application No. PCT CN2014 082448 filed on Jul. 18 2014 which claims the priority benefit of Chinese Patent Application No. CN2013103139187 filed on Jul. 24 2013 which are hereby incorporated herein by reference in its entirety.

The present disclosure relates to the field of communication techniques and in particular to a method an apparatus and a server for identity authentication.

As internet technology rapidly progresses network side servers opening the cloud platform to the third party developers has become a trend in information construction. The network side servers provide the third party developers with an application programming interface API for requesting resource. The third party developers execute API calls to the servers when requesting resources and use the servers API to process the related data.

To ensure the security of API calls prior to calling API the network side server must authenticate the identity of the third party developer. Only after the authentication is successful the server will allow the third party developer to call API. In general prior to calling API the server will assign an access identity access ID and an encryption key to an authorized third party developer. When calling API the calling request from the third party developer carrying the access ID and a digital signature generated according to the encryption key will be transmitted to the server. During identity authentication the server executes the replay attack calling frequency and digital signature on the calling request of the third party developer. The server will only provide API to the third party developer after passing all the above verifications. Specifically after receiving API calling request the server visits a storage system to verify whether the request is a replay attack. If the request is not a replay attack the server further verifies whether the calling frequency of the request. After passing calling frequency verification the server transmits the API data involved in the request to an API audit system for auditing and updates the calling frequency record in a frequency control system. In digital signature verification the server visits the storage system to retrieve the encryption key corresponding to the access ID generates a server side digital signature according to the encryption key and compares the generated server side digital signature against the digital signature carried by the API calling request. If the same the server provides the API to the third party developer.

In realizing the above identity authentication process the known technique shows the following disadvantage. The server must visit API audit system frequency control system and storage system during authentication process. If an unauthorized third party developer or a malicious hacker creates a large number of invalid access IDs to attack the server the server will visit the above three system frequently which leads to system performance bottleneck or even denial of service DoS to cause the system breakdown.

The present disclosure is to provide a method an apparatus and a server for identity authentication able to solve the problem of system overload caused by attack of a large number of invalid access IDs.

A method for identity authentication at a server may include receiving an API calling request from a third party developer the API calling request carrying an access ID generated in advance by the server and assigned to the third party developer searching for a version character carried in the access ID the version character being for marking a version number of a check character generation rule based on a version character generation rule verifying whether the version number marked by the version character being the same as a version number of the check character generation rule used by the server when the version character being verified successfully searching for at least a check character carried in the access ID based on the check character generation rule verifying respectively on the at least a check character.

An apparatus for identity authentication may include a receiving unit configured to receive an API calling request from a third party developer the API calling request carrying an access ID generated in advance by a server and assigned to the third party developer a searching unit configured to search for a version character carried in the access ID received by the receiving unit the version character being for marking a version number of a check character generation rule a first verification unit configured to verify whether the version number marked by the version character found by the searching unit being the same as a version number of the check character generation rule used by the server based on a version character generation rule the searching unit also configured to search for at least a check character carried in the access ID when the version character being verified successfully by the first verification unit a second verification unit configured to verify respectively on the at least a check character found by the searching unit based on the check character generation rule.

A server may include an input output circuit a memory a processor and a bus for connecting the input output circuit the memory and the processor wherein the input output circuit is configured to receive an API calling request from a third party developer the API calling request carrying an access ID generated in advance by the server and assigned to the third party developer the memory is configured to store a version character generation rule a check character generation rule and a version number of the check character generation rule and the processor is configured to search for a version character carried in the access ID received by the input output circuit the version character being for marking a version number of a check character generation rule based on the version character generation rule stored in the memory verify whether the version number marked by the version character being the same as the version number of the check character generation rule stored in the memory when the version character being verified successfully search for at least a check character carried in the access ID and based on the check character generation rule stored in the memory verify respectively on the at least a check character.

The method the apparatus and the server for identity authentication provided by various embodiments of the present disclosure are able to perform identity authentication on the access ID carried in the API calling request before performing replay attack verification on the API calling request. The server searches for the version character for marking the version number of the check character generation rule and based on the version character generation rule verifies whether the version number marked by the version character is the same as the version number of the check character generation rule used by the server. The verification operation is to verify the version of the check character generation rule. If the version number marked by the version character is different from the version number of the check character generation rule used by the server in generating the access ID the access ID is an unauthorized access ID. If the verification result shows the two version numbers are the same the version character verification is successful and then the server performs verification on the at least a check character in the access ID. The server searches for the at least a check character in the access ID and based on the check character generation rule performs verification respectively on the at least a check character. When each of the at least a check character is successfully verified the access ID is an authorized ID. Compared to the known technique where the replay attack verification is directly performed according to the API calling request the embodiments of the present disclosure can eliminate API calling requests carrying unauthorized access ID before performing the step of replay attack verification to the access ID and only performs the replay attack verification when the access ID in the API calling request is authorized. As such the number of visits to the API audit and other systems by the server is reduced so as to eliminate the impact on the system load caused by the large number of malicious invalid access IDs from the third parties.

The embodiment of the present disclosure can be implemented in numerous ways including as a process an apparatus a system a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the disclosure may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the disclosure. Unless stated otherwise a component such as a processor or a memory described as being configure to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

The following refers to drawings in the embodiments to provide a clear and complete description of the techniques disclosed in the embodiments. Apparently the embodiments described below show only some exemplary embodiments instead of all embodiments of the present disclosure. Based on these embodiments of the present disclosure all other embodiments which may be easily obtained by those having ordinary skills in the art without paying any creative effort all also within the scope of the present disclosure.

A brief introduction of the API calling process is explained before describing the embodiments. As shown in after receiving an API calling request from a third party developer the server first verifies whether the API calling request is a replay attack. For replay attack verification the server must visit the storage system. If the API calling request is a replay attach then the process reports error and returns. If not a replay attack the server performs the next verification of calling frequency. The object of calling frequency verification is to restrict the number of calling requests by an Internet Protocol IP address. For example when an IP address executes 60 calling requests within a minute the 61st calling request by the IP address will not pass the calling frequency verification and the process reports error and returns. If the calling request passes the calling frequency verification the server will report the data of the calling request to the API audit system and frequency control system and proceeds to the digital signature verification. During digital signature verification the server obtains a digital signature in the calling request provided by the third party developer and then visits the storage system to obtain the encryption key corresponding to the access ID in the calling request and to generate a digital signature according to the obtained encryption key. Finally the server compares the generated digital signature against the digital signature provided by the third party developer. If the two digital signatures are the same the server assigns API to the third party developer otherwise the process reports error and returns.

As shown in the above process when the third party developer requests API calling the server must visit the API audit system frequency control system and storage system a plurality of times. If the third party developer issues a large number of API calling requests carrying malicious invalid access IDs to the server the server must visit the above systems frequency which may lead to system performance bottleneck or even breakdown.

To eliminate the impact on the system load caused by large number of invalid API calling requests the present disclosure provides a method for identity authentication. The method is applicable to the server side and is to authenticate the access ID before performing replay attack verification. As shown in the method may include following steps 

The third party developer issues an API calling request to the network side server to request for calling the related source data of API. The API calling request carries an access ID generated in advance by the server and assigned to the third party developer.

Before the third party developer requests for calling API the server must generate an authorized access ID in advance and assign to the authorized third party developer. When issuing calling request the third party developer adds the access ID assigned by the server to the API request and the server performs identity authentication on the access ID.

In the instant embodiment only the access ID issued by the authorized third party developer can pass the authentication performed by the server. Because the access ID such as randomly generated access ID issued by the unauthorized third party developer is different from the access ID generated by the server the unauthorized access ID will not be able to pass the authentication and the server will not perform subsequent replay attack and other verifications to the corresponding API calling request. As such the system load caused by the invalid API calling request is eliminated.

When the server generates the access ID for authorized third party developer the server will dispose a version character and at least a check character in the access ID wherein the version character is for marking the version number of the check character generation rule and the check character is for verifying the other characters in the access ID the version character in addition to marking the version number is also able to verify a part of characters in the access ID . When the server generates access ID the server generates a version character based on the version character generation rule and generates at least a check character based on the check character generation rule. Then the server disposes the version character and the check characters into predefined positions in the access ID.

In the instant embodiment the server can store a plurality of version character generation rules and a plurality of check character generation rules in advance and during access ID generation the server selects a version character generation rule and a check character generation rule according to the configuration of the network administrator or a script program. The instant embodiment imposes no restriction on the type and number of the version character generation rules and check character generation rules.

When the third party developer issues API calling request the server performs verification on in the order of the version character and then the check character in the access ID. In other words based on the version character generation rule the server first verifies whether the version number of the check character generation rule is the same as the version number of the check character generation rule used by the server. Then based on the check character generation rule the server verifies sequentially to each of the at least a check character. The object of the step is to search for the version character before verification in order to perform subsequent verification.

In step based on the version character generation rule the server verifies whether the version number marked by the version character being the same as a version number of the check character generation rule used by the server.

According to the version character generation rule used in generating version character the server analyzes the version character to obtain the version number of the check character generation rule. If the obtained version number is different from the version number of the check character generation rule used by the server the access ID carried in the API calling request is unauthorized and the server reports error and returns. If the two version numbers are the same the server continues to execute step . For example in generating access ID the server generates two check characters based on the check character generation rule 4 and generates a version character based on the version character generation rule 1 and the version number 4 of the check character generation rule. When authenticating access ID if the server obtains the version number is 4 based on the version character generation rule 1 the version character verification is successful. If the server obtains the version number is 3 instead of 4 based on the version character generation rule 1 the version character verification failed.

In actual application the possibility of verification failure of version character exists. For example the server uses check character generation rule 4 to generate the check characters. After sending off the generated access ID to the third party developer the check character generation rule 4 is maliciously hacked and the server uses a new check character generation rule such as check character generation rule 3 to generate the new access ID and send to the third party developer. If the third party developer uses the invalid access ID i.e. the access ID generated by the check character generation rule 4 in calling API the version character verification in this step will fail.

In step after successful version character verification the server searches for the at least a check character in the access ID.

After the version character verification is successful the server will perform verification on the at least a check character based on the check character generation rule used in generating access ID. The object of this step is to find the check characters for subsequent verification.

In step the server verifies each of the at least a check character based on the check character generation rule.

In generating access ID for example if the server uses check character generation rule 2 to generate the check character. In this step the server performs verification the server then performs verification on each of the at least a check character based on the check character generation rule 2 in this step. If each of the at least a check character is successfully verified the access ID in the API calling request is authorized access ID and the server continues to execute replay attack verification on the API calling request. If any of the at least a check character fails the verification the server reports error and returns. In the instant embodiment the statement that each of the at least a check character is successfully verified means the check character is successfully verified when there is only one check character and all the check characters are successfully verified when there are two or more check characters.

In the instant embodiment the check character is obtained according to the other characters in the access ID and the check character is related to the other characters. If the check character is successfully verified the characters in the access ID from the third party developer will be respectively the same as the characters in the access ID generated by the server for the authorized third party developer and therefore the access ID is authenticated. If the check character fails the verification at least one of the characters in the access ID from the third party developer will be different from the corresponding character in the access ID generated by the server for the authorized third party developer and therefore the access ID is unauthenticated. The aforementioned other characters described in the instant embodiment refer to the characters in the access ID other than the version character and the check character. In the following description the other characters are referred to as secondary characters.

The method for identity authentication provided by the embodiments of the present disclosure authenticate the access ID in the API calling request before performing replay attack verification. During authentication the server first verifies the version character in the access ID. After the version character is verified successfully the server proceeds to verify the check character in the access ID. When each of the check characters is verified successfully the access ID is authenticated. Compared to the known technique wherein the replay attack verification on the API calling request is directly executed the present disclosure can authenticate the access ID in the API calling request before performing replay attack verification and stops the subsequent verification processes if the access ID fails the authentication. As such the impact on system load caused by large number of invalid API calling requests will be eliminated to ensure system normal operation.

In addition the method for identity authentication provided by the embodiments of the present disclosure can also effectively prevent the unauthorized third party developer or hacker from decoding access ID by brute force. Take the 32 character access ID as an example. Besides the version character and the check character each secondary character may randomly hold the value of 1 9 a z and A Z i.e. 62 different values . If the access ID includes a version character and two check characters the brute force approach must perform 62iterations i.e. about 10 to crack the access ID. Furthermore the hacker must also obtain the version character generation rule and the check character generation rule for cracking the access ID. Even without considering the generation rules the computation speed of the current computers will take a time longer than the expiration time of the access ID to compute. Therefore the result is preventive.

Furthermore for expansion on the method disclosed in the present disclosure further provides another embodiment of the method for identity authentication. The method is also applicable to the server side and for authenticating the access ID before replay attack verification. As shown in the method may includes following steps 

In step the server generates an access ID based on a version character generation rule and a check character generation rule.

The server first generates a valid access ID for an authorized third party developer so that the third party developer can request API from the server based on the access ID. In the instant embodiment step and step are for the server to generate and assign the access ID before authenticate the access ID.

Specifically take 32 character access ID as an example. The process of the server generating the access ID may include 

As shown in the server first generates a 32 character access ID wherein no specific value is assigned to each character. Then the server selects a character as version character and at least a character as check character. In the instant embodiment one version character and two check characters are selected.

The server can select the version character and the check character according to the configuration of the network administrator or default script program. For example three characters can be randomly selected as version character and check characters respectively. Alternatively the server can select one character every 10 characters. For example as shown in Figure the server selects the character at position 3 referred to as character 3 as version character and character 14 and character 28 as check characters.

In step the server selecting a plurality of characters from an initialized character array as the value held in each of the secondary characters in the access ID.

As aforementioned the secondary characters refer to the characters in the access ID other than the version character and the check character. In characters 1 2 characters 4 13 characters 15 27 and characters 29 32 are secondary characters.

The initialized character array is for generating specific character value for the access ID which is constructed by the server in advance. As shown in the initialized character array includes numbers 0 9 low case letters a z and upper case letters A Z a total of 62 character values. The initialized character array shown in is only for illustrative purpose. In actual application the present disclosure imposes no specific restriction on the content and the order of the character values in the initialized character array.

The server selects a character value from the initialized character array for each secondary character of the access ID according to a default rule. In the instant embodiment the default rule is random selection. The server randomly selects a character value for character 1 and so on until all the secondary characters hold a character value as shown in .

In step the server dividing the plurality of secondary characters into at least two character generation groups.

The at least two character generation groups include a version character generation group and a check character generation group. In the instant embodiment the server divides the 29 secondary characters into a version character generation group and two check character generation groups.

Specifically the server divides the secondary characters to obtain at least two character generation groups based on the number of the secondary characters the number of the version character and the number of check characters. In the instant embodiment the number of the secondary characters is 29 the number of the version character is 1 and the number of check characters is 2. For example the server first assigns the number of characters in each character generation group and then starts with the first character in the access ID excluding the version character and the check characters to assign the secondary characters to the version character generation group and the check character generation group. The version character generation group and the check character generation group obtained by the server are shown in .

To further increase the difficulty of hacking in a preferred embodiment of the present disclosure the server assigns the number of characters to each group uniformly for example the version character generation group and the check character generation group shown in . If the server uses the division in the hack needs to perform iterations while iterations are required for using the division in . As shown the uniform division approach requires more iterations to crack than the non uniform division approach. For example 1 2 9 18 non uniform division and 4 4 4 64 uniform division . Apparently the number of combinations of a uniform division is larger than the number of combinations of a non uniform division.

In step the server generates the version character based on the version character generation group and the version character generation rule.

Step 1a in the version character generation group the server multiplies a numerical position of each character and the American Standard Code for Information Interchange ASCII code corresponding to the character to obtain a first order version value.

The number of digits numerical position of the character can be either the numerical position of the character in the access ID or the numerical position of the character in the initialized character array. For example for character c the numerical position of the character in the access ID is 1 but the numerical position of the character in the initialized character array is 13. The instant embodiment uses the numerical position of the character in the initialized character array for description.

For the version character generation group shown in the server obtains 9 first order version values 13 99 c 1287 16 102 f 1632 3 50 2 150 20 106 j 2120 7 54 6 378 9 56 8 504 28 114 r 3192 2 49 1 98 5 52 4 260 wherein the number to the left of the multiplication sign is the numerical position of the character in the initialized character array the number to the right of the multiplication sign is the corresponding ASCII code and the number inside the parentheses is the character.

The instant embodiment uses the decimal ASCII code as example for description. In actual application the hexadecimal or octal ASCII code can also be used. No specific restriction is imposed by the present disclosure.

Step 2a the server performs summation and modulus of 62 on the plurality of first order version values to obtain a second order version value.

The server computes the sum of the 9 first order version values to obtain 1278 1632 150 2120 378 504 3192 98 260 9621 

Step 3a the server performs summation and modulus of 62 on the second order version value and the version number of the check character generation rule to obtain a third order version value.

For example the server uses check character generation rule 4 in generating access ID i.e. the check character generation rule has a version number of 4. The server uses the following equation to obtain a third order version value 11 4 62 15 wherein the operator indicates the modulus operation.

Step 4a the server searching for the character in initialized character array having the same numerical position as the third order version value and using the character as the version character.

The server finds the 15th character e in the initialized character array of and uses e as the version character of the access ID. The access ID with confirmed version character is shown in .

In step the server generates at least a check character according to at least a check character generation group and the check character generation rule.

After generating the version character the server uses the check character generation rule 4 to generate two check characters. Specifically 

Step 1b in a check character generation group the server multiplying a numerical position of each character and the American Standard Code for Information Interchange ASCII code corresponding to the character to obtain a first order check value.

For the first check character generation group shown in to obtain the first check character the server obtains 10 first order check values 10 57 9 570 21 107 k 2247 27 113 q 3051 11 97 a 1067 4 51 3 204 38 66 B 2508 36 122 z 4392 62 90 Z 5580 8 55 7 440 23 109 m 2507 wherein the number to the left of the multiplication sign is the numerical position of the character in the initialized character array the number to the right of the multiplication sign is the corresponding ASCII code and the number inside the parentheses is the character.

Step 2b the server performing summation and modulus of 62 on the plurality of first order check values to obtain a second order check value.

The server computes the sum of the 10 first order check values to obtain 570 2247 3051 1067 204 2508 4392 5580 440 2507 22566 

Step 3b the server searching for the character in initialized character array having the same numerical position as the second order check value and using the character as the first check character.

The server finds the 60th character X in the initialized character array of and uses X as the first check character of the access ID.

Then the server executes step 1b and step 2b to obtain the second check character D . The access ID with confirmed check characters is shown in wherein the access ID is a complete access ID.

The server sends the generated access ID to the third party developer for subsequent API calling request by the third party developer.

When the third party developer issues an API calling request the server retrieves the access ID in the API calling request. The access ID is the access ID assigned to the authorized third party developer by the server in step .

Based on the version character generation rule in step the server confirms that the third character e in the access ID as the version character.

In step based on the version character generation rule the server verifies whether the version number marked by the version character being the same as the version number generated by the server based on the check character generation rule.

In step the server uses a reverse rule of the version character generation rule to analyze the version character e to obtain a version number.

The server first finds the position of character e as 15 in the initialized character array and then follows step 1a and step 2a of step to compute the sum of the multiplications of each character in the version character generation group and corresponding ASCII code followed by computing the modulus of 62 to obtain the second order version value 11. The server then subtracts the second order version value 11 from the position 15 of character e to obtain the version number as 4. In the instant embodiment if the subtraction results in a negative number the value 62 is added to the negative number to obtain the version number.

In step the server determines whether the analyzed version number is the same as the version number generated by the server using the check character generation rule and obtaining a result.

In the instant embodiment because the third party developer requesting API calling is an authorized third party developer the access ID is an authorized ID and the version number 4 analyzed by the server is the same as the version number of the check character generation rule t4 used in step . When an unauthorized third party developer or a hacker try to crack the access ID through brute force the version number analyzed by the server will be different from the version number used by the server as long as any character in the version character generation group used by the hacker is different from the version character generation group used by the server.

In the instant embodiment the version character verification can also verify the 9 characters in the version character generation group in addition to verifying whether the marked version number is the same as the version number used by the server.

When the server determines the analyzed version number is the same as the version number used by the server the method proceeds to execute step to verify the check characters. When the server determines the analyzed version number is different from the version number used by the server the method confirms that the access ID from the third party developer is an unauthorized access ID and the server reports error and returns.

Based on the check character generation rule in step the server confirms that the 14th character X and the 28th character D in the access ID as the first and the second check character respectively.

In step the server verifies each of the at least a check character based on the check character generation rule.

The object of the check character verification is to verify the secondary characters in the access ID. Because a check character is generated according to 10 secondary characters the check character analyzed by the server will be different from the generated check character if any of the 10 secondary characters is different from the secondary characters generated by the server. Therefore this step can detect the correctness of the access ID. Take verifying the first check character as example 

Step 1c the server analyzing to obtain the check character based on the check character generation rule.

Based on the check character generation rule 4 used when generating the check character the server analyzes to obtain the check character. Specifically the server obtains 11th 21st characters from the access ID excluding 14th character check character i.e. the first check character generation group shown in . Then the server follows steps 1 3 of step to analyze the obtained first check character generation group to obtain the first check character X .

Step 2c the server comparing the analyzed check character against the check character generated when generating the access ID.

In this step the objects compared by the server are the analyzed check character from step 1 and the check character generated by the server respectively wherein the check character generated by the server is also the 14th character X in the access ID. It should be noted that the analysis in step 1 is not merely to obtain the check character which can be retrieved directly from the 14th character X in the access ID. Instead the analysis by the server is to independently verify the access ID based on the check character generation rule which is unknown to the third party developer. If the analysis results in the same check character the secondary characters in the access ID are proven to be the same as the secondary characters in the generated access ID. In the instant embodiment the description is based on the authorized access ID from the third party developer and therefore the check character from the access ID analyzed by the server must be the same as the generated check character. In other words the check character resulted from the analysis of the server is the 14th character X in the access ID. However when the access ID from the third party developer is an invalid access ID the significance of the analysis and comparison can be clearly shown. For example the third party developer randomly generates an access ID shown in . Because the characters in access ID do not correspond to the characters in the access ID generated by the server the server can determines that the access ID is not an authorized access ID because the analyzed check character from the 11th 21st characters of the access ID excluding 14th character and the check character generation rule is different from the check character generated by the server.

After comparing the 14th character i.e. the first check character the server follows steps 1 2 to verify the 28th character i.e. the second check character . When any of the check characters is different from the respective generated check character the server determines the access ID is invalid and reports error and returns. When both check characters are verified successfully the server determines the access ID is authorized.

Furthermore in a preferred embodiment when the check character generation rule 4 used by the server is hacked by the third party developer the server can use a new check character generation rule to generate a new access ID wherein in the new access ID the new version character will be used for marking the version number of the check character generation rule. Then the new access ID will be assigned and sent to the authorized third party developer. As aforementioned the server stores a plurality of check character generation rules. In a preferred embodiment when a previously used check character generation rule is cracked by a third party developer the server can used a new check character generation rule such as check character generation rule 2 to generate a new access ID. In the new access ID the version number of the check character generation rule 2 is realized in the new version character. For the third party developer cracked the check character generation rule 4 in the access ID generated according to the check character generation rule 4 the version number marked by the version character is the no longer valid version number 4. When an API calling request having the access ID arrives the server will reports error and returns during the version character verification. As such the access ID can be updated.

Furthermore in an optional solution after executing step and the access ID is determined to be an authorized access ID the server can follow the process outlined in to perform replay attack verification calling frequency verification and digital signature verification and so on. The realization details will not be repeated here. When all the subsequent verification processes are successful the server calls API for the third party developer.

The method for identity authentication provided in the embodiments uses the version character to verify the version number of the check character generation rule used by the access ID. When the version verification succeeds the check character verification is executed. Because the check character is generated from the secondary characters each of the secondary characters is also indirectly verified to achieve the identity authentication of the access ID. In addition because the version character is also generated through the secondary characters the version character verification can also verify the secondary characters in generating the version character in addition to verifying the version number of the check character generation rule.

Furthermore the method for identity authentication provided in the embodiments can switch to another check character generation rule when the current check character generation rule is cracked and puts the version number of the new rule in the new access ID to assign to the authorized third party developer in order to invalidate the old access ID. As such the difficulty of cracking access ID is increased.

The following analyzes the feasibility of the method in the embodiments. To crack the rules of the access ID requires knowing the exact numbers and positions of the version character and the check characters as well as the numbers of the version character generation group and the check character generation groups. Take the embodiment with 32 character access ID a version character two check characters a 9 character version character generation group and two 10 character check character generation groups as an example. Without considering the positions of the version character and the check characters and the combination of the character generation groups the probability of a successful hacking is about 

In addition because the number of version characters the number of check characters the number of characters in version character generation group and the number of characters in check character generation group are all variable the probability of successful hacking is even lower. Besides in actual application the version character generation rule and the check character generation rule can also be flexibly changed. As a result the hacking becomes extremely difficult.

Referring to the realization of the method in the present disclosure further provides an apparatus for identity authentication. The apparatus may be disposed inside the network side server for realizing the method shown in . As shown in the apparatus may include a receiving unit a searching unit a first verification unit and a second verification unit wherein 

the receiving unit is configured to receive an API calling request from a third party developer the API calling request carries an access ID generated in advance by a server and assigned to the third party developer 

the searching unit is configured to search for a version character carried in the access ID received by the receiving unit the version character is for marking a version number of a check character generation rule 

the first verification unit is configured to verify whether the version number marked by the version character found by the searching unit is the same as a version number of the check character generation rule used by the server based on a version character generation rule 

the searching unit is also configured to search for at least a check character carried in the access ID received by the receiving unit when the version character is verified successfully by the first verification unit and

the second verification unit is configured to verify respectively on the at least a check character found by the searching unit based on the check character generation rule.

Furthermore as shown in the apparatus further may include a generation unit and a assigning unit wherein 

the generation unit is configured to generate the access ID based on the version character generation rule and the check character generation rule before the receiving unit receives the API calling request from the third party developer and

the assigning unit is configured to assign the access ID generated by the generation unit to the third party developer.

In addition as shown in the generation unit may include a confirmation sub unit a selection sub unit a division sub unit a first generation sub unit and a second generation sub unit wherein 

the confirmation sub unit is configured to confirm a position of a version character and a position of at least a check character 

the selection sub unit is configured to select a plurality of characters from an initialized character array as secondary characters in access ID wherein the secondary characters are the characters in the access ID other than the version character and the check character confirmed by the confirmation sub unit 

the division sub unit is configured to divide a plurality of secondary characters selected by the selection sub unit into at least two character generation groups and the at least two character generation groups may include a version character generation group and at least a check character generation group 

the first generation sub unit is configured to generate the version character according to the version character generation group divided by the division sub unit and the version character generation rule and

the second generation sub unit is configured to generate the at least a check character according to the check character generation group divided by the division sub unit and the check character generation rule.

the construction sub unit is configured to construct an initialized character array before the confirmation sub unit confirming the positions of the version character and the position of at least a check character and the initialized character array may include digits 0 9 lower case letters a z and upper case letters A Z a total of 62 characters.

Furthermore the division sub unit divides the plurality of secondary characters to obtain at least two character generation groups according to the number of the secondary characters a the number of version characters b and the number of check characters c.

in the version character generation group multiply a position of each character and the American Standard Code for Information Interchange ASCII code corresponding to the character to obtain a first order version value 

perform summation and modulus of 62 on the plurality of first order version values to obtain a second order version value 

perform summation and modulus of 62 on the second order version value and the version number of the check character generation rule to obtain a third order version value and

search for the character in initialized character array having the same position as the third order version value and using the character as the version character.

in a check character generation group multiply a position of each character and the American Standard Code for Information Interchange ASCII code corresponding to the character to obtain a first order check value 

perform summation and modulus of 62 on the plurality of first order check values to obtain a second order check value and

search for the character in initialized character array having the same position as the second order check value and using the character as the first check character.

Furthermore as shown in the first verification unit may include a first analysis sub unit and a determination sub unit wherein 

the first analysis sub unit uses a reverse rule of the version character generation rule to analyze the version character to obtain a version number 

the determination sub unit determines whether the analyzed version number obtained by the first analysis sub unit is the same as the version number generated by the server using the check character generation rule and obtains a result 

when the determination result is the same the first verification unit further instructs the second verification unit to perform check character verification and

when the determination result is different the first verification unit determines the access ID is an unauthorized access ID.

a second analysis sub unit configured to analyze to obtain at least a check character based on the check character generation rule 

a comparison sub unit configured to compare the at least a check character obtained by the second analysis sub unit against the at least check character generated in generating the access ID respectively 

when each of the at least a check character being the same the second verification unit further confirming the access ID being an authorized access ID and

when any of at least a check character being different the second verification unit further determining the access ID being an unauthorized access ID.

Furthermore after the assigning unit sends the access ID to the third party developer the generation unit further uses a new check character generation rule to generate new access ID when the previously used check character generation rule is cracked wherein the new access ID may include a new version character to mark a version number of the new check character generation rule and

the assigning unit sends the new access ID generated by the generation unit to the third party developer.

The third verification unit is configured to perform replay attack verification on the API calling request received by the receiving unit after the second verification unit verifies the access ID is an authorized access ID.

The apparatus for identity authentication provided in the embodiment uses the version character to verify the version number of the check character generation rule used by the access ID. When the version verification succeeds the check character verification is executed. Because the check character is generated from the secondary characters each of the secondary characters is also indirectly verified to achieve the identity authentication of the access ID. In addition because the version character is also generated through the secondary characters the version character verification can also verify the secondary characters in generating the version character in addition to verifying the version number of the check character generation rule.

Furthermore the apparatus for identity authentication provided in the embodiment can switch to another check character generation rule when the current check character generation rule is cracked and puts the version number of the new rule in the new access ID to assign to the authorized third party developer in order to invalidate the old access ID. As such the difficulty of cracking access ID is increased.

Referring to the realization of the method in the present disclosure further provides a server for identity authentication. As shown in the server may include an input output circuit a memory a processor and a bus for connecting the input output circuit the memory and the processor wherein 

the input output circuit is configured to receive an API calling request from a third party developer the API calling request carrying an access ID generated in advance by the server and assigned to the third party developer 

the memory is configured to store a version character generation rule a check character generation rule and a version number of the check character generation rule 

the processor is configured to search for a version character carried in the access ID received by the input output circuit the version character being for marking a version number of a check character generation rule based on the version character generation rule stored in the memory verify whether the version number marked by the version character being the same as the version number of the check character generation rule stored in the memory when the version character being verified successfully search for at least a check character carried in the access ID and based on the check character generation rule stored in the memory verify respectively on the at least a check character.

The server for identity authentication provided in the embodiment uses the version character to verify the version number of the check character generation rule used by the access ID. When the version verification succeeds the check character verification is executed. Because the check character is generated from the secondary characters each of the secondary characters is also indirectly verified to achieve the identity authentication of the access ID. In addition because the version character is also generated through the secondary characters the version character verification can also verify the secondary characters in generating the version character in addition to verifying the version number of the check character generation rule.

Furthermore the server for identity authentication provided in the embodiment can switch to another check character generation rule when the current check character generation rule is cracked and puts the version number of the new rule in the new access ID to assign to the authorized third party developer in order to invalidate the old access ID. As such the difficulty of cracking access ID is increased.

Embodiments within the scope of the present disclosure may also include computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media may include RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to carry or store desired program code means in the form of computer executable instructions or data structures. When information is transferred or provided over a network or another communications connection either hardwired wireless or combination thereof to a computer the computer properly views the connection as a computer readable medium. A tangible computer readable medium expressly excludes software per se not stored on a tangible medium and a wireless air interface. Thus any such connection is properly termed a computer readable medium. Combinations of the above should also be included within the scope of the computer readable media.

Computer executable instructions include for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. Computer executable instructions also include program modules that are executed by computers in stand alone or network environments. Generally program modules include routines programs objects components and data structures etc. that performs particular tasks or implement particular abstract data types. Computer executable instructions associated data structures and program modules represent examples of the program code means for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represents examples of corresponding acts for implementing the functions described in such steps. Program modules may also include any tangible computer readable medium in connection with the various hardware computer components disclosed herein when operating to perform a particular function based on the instructions of the program contained in the medium.

The above descriptions are only preferred embodiments of the present disclosure and are not intended to limit the present disclosure. Any amendments replacement and modification made to the above embodiments under the spirit and principle of the present disclosure should be included in the scope of the present disclosure.

