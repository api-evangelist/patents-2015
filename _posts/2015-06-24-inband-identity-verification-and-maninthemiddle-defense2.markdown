---

title: In-band identity verification and man-in-the-middle defense
abstract: A variety of techniques for performing identity verification are disclosed. As one example, a verification request is received from a remote user. The verification request pertains to a cryptographic key. In response to receiving a confirmation from a local user of the local device, a verification process is initiated. A result of the verification process is transmitted to the remote user. As a second example, a verification request can be received at the local device, from a local user of the device. A verification process with respect to the local user is initiated, and a result of the verification process is transmitted to a remote user that is different from the local user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09584530&OS=09584530&RS=09584530
owner: Wickr Inc.
number: 09584530
owner_city: San Francisco
owner_country: US
publication_date: 20150624
---
This application claims priority to U.S. Provisional Patent Application No. 62 018 505 entitled IN BAND IDENTITY VERIFICATION AND MAN IN THE MIDDLE DEFENSE filed Jun. 27 2014 which is incorporated herein by reference for all purposes.

Users of electronic devices increasingly desire to communicate privately and securely with one another. Unfortunately existing approaches to securing communications can be difficult and or cumbersome to use. As one example some approaches to data security make use of digital certificates or keys or pre shared passwords which can be tedious to manage. Further existing approaches are often susceptible to interception e.g. eavesdropping and man in the middle attacks forensic analysis and impersonation. Improvements to digital communication techniques are therefore desirable.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Users of client devices such as client devices communicate securely with one another using techniques described herein. As shown in client devices include personal computers laptop computers tablets and mobile telephony devices . Some client devices e.g. tablet device make use of techniques described herein via a messaging application also referred to as an app obtained from a software distribution server . Examples of software distribution servers which can comprise a single server or multiple servers working in cooperation include app stores e.g. provided by Apple Google Blackberry Microsoft Amazon and or other entities and other webservers offering app and or other software downloads. Client devices can also make use of a web interface e.g. provided by platform instead of or in addition to a dedicated messaging application installed on the device. Other types of devices not depicted in can also be used in conjunction with the techniques described herein such as game consoles camera video recorders video players e.g. incorporating DVD Blu ray Red Laser Optical and or streaming technologies and other network connected appliances as applicable.

Communications are exchanged via one or more networks depicted collectively in as network cloud . Such networks can include wired wireless cellular and satellite networks. And such networks can be closed private networks as well open networks e.g. the Internet . Further as used herein communications and messages can take a variety of forms including text messages documents audiovisual files SMSes and voice and video calls. Further in addition to personal business or other types of conversations the content can pertain to electronic transactions such as credit card security password protection directories and storage drive protection video on demand security online gaming gambling electronic distribution of music videos documents online learning systems databases cloud storage and cloud environments bank transactions voting processes military communications security of medical records communication between medically implanted devices and doctors etc. As will be described in more detail below the exchange of communications is facilitated by security platform or embodiments thereof as applicable .

As will be described in more detail below a variety of entities can operate embodiments of platform . Further multiple embodiments of platform can exist simultaneously in an environment with those multiple embodiments operated by a single entity or different entities with the techniques described herein adapted as applicable. For example platform can be operated by a non profit organization or an individual a company or any other appropriate type of entity or set of entities for use by the general public e.g. with arbitrary members of the public able to use platform to exchange communications . As another example an enterprise organization can operate an embodiment of platform exclusively for use by the employees of the enterprise and as applicable other individuals such as vendors . As yet another example a company or other entity or entities can operate one or multiple instances of platform on behalf of multiple organizations such as small business or companies schools charitable organizations etc.

Suppose a user of client device hereinafter referred to as Alice would like to send a secure message to her friend Bob a user of client device in accordance with techniques described herein. In some embodiments in order to send a message to Bob Alice first obtains a copy of a messaging application suitable for her device. For example if Alice s tablet device runs iOS she could obtain an app for her tablet from the Apple App Store an example of software distribution server . Bob similarly obtains an appropriate application suitable for his client device e.g. an Android based smartphone from an appropriate location e.g. the Google Play store or Amazon Appstore . In some embodiments client devices make use of a web based application e.g. made available by platform through interface instead of or in addition to a dedicated installed application.

In embodiments where platform is operated on behalf of specific groups of individuals e.g. on behalf of employees of a company students teachers at a school company stockholders members of a club premium customers etc. the app can be obtained from a publicly accessible software distribution server as Alice and Bob do above e.g. from the Google Play store can be obtained from a privately operated software distribution server e.g. made available only to company issued devices or devices otherwise authorized to communicate with the private server can be provisioned by support personnel associated with the group e.g. by being directly installed by the support personnel or included in a device image etc. as applicable. For example suppose an embodiment of platform is operated by ACME University on behalf of its students and faculty staff. As mentioned above the university can itself operate an embodiment of platform or can contract with a third party to make available the embodiment of platform for university users. Freshmen and other new students employees as applicable at ACME University can be provided with instructions for downloading and installing an ACME University specific embodiment of the secure messaging application from a university server in conjunction with their new student orientation. As another example new employees of Beta Corporation can be issued company phones and or other devices such as laptops with an embodiment of the secure messaging application pre installed and pre configured by support personnel for Beta Corporation e.g. where Beta Corporation operates an embodiment of platform on behalf of its employees and business partners . As yet another example business partners of Beta Corporation e.g. vendors can be provided with instructions for provisioning a Beta Corporation specific embodiment of the secure messaging application via email or via a website. And the Beta Corporation specific embodiment of the secure messaging application can be made available via email a website or any other appropriate mechanism.

Returning to the example of Alice a member of the public using an embodiment of platform made available to the public once Alice s tablet has obtained a copy of the secure messaging app the app is installed and Alice is able to register for an account. An instance of a messaging app usable in conjunction with the techniques described herein is depicted in as app installed on device . Examples of events that can occur during an installation initialization registration process are illustrated in and will now be described. While the events will be described in one order events can also be performed in other orders and or in parallel instead of in sequence in other embodiments. Further various events can be added or omitted in some embodiments as applicable. For example where an embodiment of platform is made available by an enterprise for use by its employees or a school on behalf of its student staff faculty etc. account creation and initialization may at least partially be performed by support personnel and or may be performed at least partially in an automated manner based on a new employee member workflow instead of being performed by an end user. As a further example administrators e.g. in the school or enterprise scenarios can pre configure privacy list information described in more detail below on behalf of users.

In some embodiments process is performed on a client device such as Alice s client device . The process begins at when a pool of public private keypairs for the application is generated on client device e.g. using RSA ECDH or any other appropriate asymmetric encryption algorithms . As one example the keypairs can be generated using Eliptic Curve Algorithm with Diffie Helman Key Exchange ECDH . Other cryptographic standards can also be used such as RSA. In some embodiments the keypairs are randomly seeded. As will be described in more detail below each message Alice sends whether to Bob or anyone else can be encrypted with a unique random key that is used only once then destroyed forensically by Alice the sender s device. The forensic destruction ensures that the deleted keys cannot be recovered from Alice s device even via digital forensics methods.

At a pool of keys i.e. a number of keypairs equal to the size initialized at is generated on client device . As mentioned above the keypairs can be generated using Eliptic Curve Algorithm with Diffie Helman Key Exchange ECDH . Other cryptographic standards can also be used such as RSA.

At a reference value is assigned for each of the respective keypairs. As one example suppose fifty keypairs are generated at portion of process . At fifty respective reference values are assigned to each of the respective keypairs. The reference values will be used to distinguish the various keys in the pool of keys from one another and can be assigned to the keypairs in a variety of ways. As one example a six digit random number can be generated by device as the first reference value for the first keypair and each subsequent reference value can be selected as an increment of the first reference value. As another example every reference value can be randomly selected. Other schemes for selecting assigning reference values can be employed at as applicable.

At the private keys and reference values are stored e.g. in a secure database residing on device . As will be described in more detail below the corresponding public keys will be transmitted to platform along with the associated reference values and platform will designate one of the public keys in the pool as a reserve key.

Returning to at a random server seed is generated and at a random local seed is generated. The seeds are used in conjunction with cryptographic key generation and in some embodiments the seeds are determined based on captured hardware information described in more detail below .

At a device identifier deviceID is created from captured hardware information. Examples of captured hardware information include hard drive identifiers motherboard identifiers CPU identifiers and MAC addresses for wireless LAN Bluetooth and optical cards. Combinations of information pertaining to device characteristics such as RAM CACHE controller cards etc. can also be used to uniquely identify the device. Some or all of the captured hardware information is run through a cryptographic hash algorithm such as SHA 256 to create a unique deviceID for the device. The captured hardware information can also be used for other purposes such as to seed cryptographic functions.

At Alice is asked via an interface provided by app to supply a desired username. Alice enters Alice into the interface. A determination is made as to whether the username is available. As one example app can supply a cryptographic hash of Alice to platform for checking. If platform does not already have a record for that hash the username Alice is available for Alice to use. If platform already has a record of that hash Alice is instructed by the interface to pick an alternate username. Once Alice has selected an available username she is asked to supply a password. As mentioned above in some embodiments portions of process may be omitted or performed by other entities as applicable . For example where a university student at ACME University is getting set up to use an ACME University specific embodiment of platform the user s name may be preselected or otherwise issued by the University rather than being selected by the user.

At an application identifier appID is created. The appID is a unique identifier for the particular installation of the messaging app. If Alice installs the messaging app on multiple devices each of her devices will have its own unique appID. And each of her devices will also have its own unique deviceID. In some embodiments the appID is created by hashing Alice s selected password and other information such as device information.

Finally at Alice s public keys and reference values deviceID and appID are sent to platform in a secure manner. As one example in some embodiments app is configured to communicate with platform via TLS.

As mentioned above alternate versions of processes and or can be used in accordance with the techniques described herein. As one example username password selection can be performed prior to other portions of process and can be performed by an entity other than the end user of the messaging application e.g. where an employer determines a username for an employee . As another example the random server seed generation and random local seed generation can be performed prior to the keypair generation e.g. with the local seed being used in conjunction with the generating of the keypairs. As yet another example portions of processes and or can be combined and or omitted as applicable. For example instead of generating a pool of fifty key pairs assigning reference values to the pool as a batch operation and storing the keys values as a batch operation fifty iterations of a process that generates a key pair assigns a reference value and stores the information can be performed.

As mentioned above security platform is configured to facilitate the exchange of communications e.g. among any all of client devices . Also as mentioned above platform can be operated by a variety of entities on behalf of a variety of end users. For example one embodiment of platform can be made available to members of the public whether as a public service or for a fee. As another example another embodiment of platform can be made available by a business by a school by a charitable organization etc. and its use limited to its employees students members etc. as applicable. Additional detail regarding various aspects of embodiments of platform will now be provided.

Security platform includes one or more interface s for communicating with client devices such as client devices . As one example platform provides an application programming interface API configured to communicate with apps installed on client devices such as app app app and app . Platform can also provide other types of interfaces such as a web interface or stand alone software programs for desktops and laptops running on various Operating Systems OSes . The web interface can allow users of client devices such as client devices and to exchange messages securely whether with one another or other users without the need for a separately installed messaging application. The stand alone software program allows users to exchange secure messages via software that is downloaded by each user. As will be discussed in more detail below e.g. in Section G in various embodiments platform makes available e.g. via one or more interface s a master clock time. The master clock time can be used in various embodiments to enforce secure time to live TTL values of messages. The TTL values can be used to enforce e.g. on behalf of a message sender time constraints on message access e.g. by a recipient .

Security platform also includes a database . Included in database is a record for each user of platform . Each record has associated with it information such as the user s public key pool and associated reference values deviceID s appID s privacy mode and privacy list entries and messages. As shown in database is relational and stores information in a variety of tables including a table of hashed usernames a table of public keys and reference values a table of deviceIDs a table of appIDs and a table of messages . Other techniques can also be used to store the information used by platform . For example messages can be stored in a separate storage instead of being stored within database . As will be described in more detail below additional information can be securely stored on platform whether in database or another appropriate location such as user verification information and user verification settings described in more detail below.

Finally security platform includes a processing engine which performs a variety of tasks including interacting with database on behalf of interface s . As will be described in more detail below one task performed by platform e.g. by processing engine is to designate one of the keys in the pool of public keys e.g. received from Alice at the conclusion of portion of process as a reserve key. Another task performed by platform e.g. processing engine is to facilitate the addition of new keys to a user s key pool as the keys are used. Yet another task performed by platform e.g. processing engine is to dynamically adjust the size of a user s key pool as needed. Yet another task performed by platform in various embodiments is confirming whether mutual privacy settings permit a given user to communicate with another user described in more detail in Section H and providing keys for communications only where privacy settings permit.

The embodiment of platform depicted in comprises standard commercially available server hardware e.g. having a multi core processor s G of RAM gigabit network interface adaptor s and hard drive s running a typical server class operating system e.g. Linux . In various embodiments platform is implemented across a scalable infrastructure comprising multiple such servers solid state drives and or other applicable high performance hardware.

Whenever platform is described as performing a task either a single component or a subset of components or all components of platform may cooperate to perform the task. Similarly whenever a component of platform is described as performing a task a subcomponent may perform the task and or the component may perform the task in conjunction with other components.

Returning back to Alice s desire to send a message to Bob at the conclusion of Section A above Alice has successfully registered her username Alice with security platform . And Bob is also a user of platform . Suppose Alice would like to send a message to Bob. She starts app and is presented with an interface that includes a compose option. Alice selects the compose option and is presented with a message composition interface.

An example message composition interface is shown in . In particular depicts interface as rendered on an example tablet device connected to the Internet via an appropriate connection such as 3G 4G or higher cellular connection WiFi satellite wireless or wired LANs Bluetooth etc. Tablet device includes a touchscreen. An on screen keyboard is provided for Alice in region . Alice can enter the usernames of one or more recipients in region . As will be described in more detail below e.g. in Section H in some embodiments any names that Alice enters into region are checked against Alice s privacy list and the privacy lists of the recipients to confirm that privacy settings allow Alice to message the recipient s . As will also be described in more detail below e.g. in Section I additional checks can be performed as applicable such as where Alice has turned on advanced identity verification. She can enter message text in region . Alice can optionally add attachments by interacting with buttons shown in region . Examples of attachments include but are not limited to documents pictures and audiovisual clips. By selecting button Alice can specify various message control options such as the lifetime expiration of the message the enforcement of which is described in more detail below in Section G on which device s it can be unencrypted read and sharing saving forwarding recalling and deleting options.

If Alice is satisfied with her message she can send it to Bob by clicking the send button . If she wishes to cancel out of composing the message she can click the cancel button . Suppose Alice clicks send button after composing the message shown in interface . An example of the events that occur in some embodiments in conjunction with Alice sending a message is illustrated as process in and will now be described.

At a random symmetric encryption key is generated e.g. by app on device . As one example the symmetric key is an AES 256 bit key. At the symmetric encryption key is used to encrypt the message body any attachments and any message control options. In some embodiments Alice s own information e.g. public key s and associated reference value s deviceID s and appID s is included in the DSB as well. Finally at the symmetric key is encrypted with the particular public key of each recipient obtained from the pool of public keys . A DSB encapsulation is then generated and contains the aforementioned components and reference values of the public keys used to encrypt the symmetric key. Examples of the DSB format are provided in Section D below.

In some cases a user may own multiple devices. For example Bob may be the owner of devices and both of which are configured with secure messaging apps. Each of Bob s installations will have its own deviceID and appID. When the DSB is created each of Bob s devices will be considered a separate device under the same username account.

The generated DSB is securely transmitted to platform e.g. by being encrypted with a symmetric key shared by the app and platform and also encapsulated by TLS as an additional security layer . Irrespective of how many recipients Alice designates for her message and e.g. how many recipients there are or how many devices Bob has only one DSB will be created and transmitted to platform . Upon receipt of the DSB processing engine opens the DSB and determines the recipients of the message. Specifically the processing engine performs a match against the deviceIDs in a cryptographic hash and camouflaged representation included in the DSB and the deviceIDs stored in database as well as the username in a cryptographic hash and camouflaged representation in the DSB and the ones stored in the database . A cryptographic hash and camouflaged representation means that the hash algorithm i.e. SHA256 that is used for the deviceID username and appID values is further camouflaged in some embodiments by taking multiple hashes of the result values i.e. multiple rounds of SHA256 of the previous SHA256 value i.e. SHA SHA SHA SHA . . . . . Processing engine also creates an entry for the received DSB in message table and notifies the recipient s that a new message is available. In various embodiments other actions are also performed by platform with respect to the DSB. As one example platform can be configured to remove the DSB as soon as the recipient successfully downloads it. As another example platform can enforce an expiration time e.g. seven days by which if the DSB has not been accessed by the recipient the DSB is deleted. Where multiple recipients are included in a DSB platform can be configured to keep track of which recipients have downloaded a copy of the DSB and remove it once all recipients have successfully downloaded it or an expiration event has occurred .

DSB also includes for each message recipient 1 n the key Ekencrypted by each of the recipient s respective particular public keys as shown in region . Further DSB includes a combination of each recipient s respective deviceID hashed username appID and the reference value associated with the particular public key collectively denoted HWk in region . These constituent parts are also referred to herein as parameters. Additional detail regarding the parameters is shown in namely a plurality of parameters such as hashed username deviceID and appID are encrypted using SK2 which is a symmetric key generated by the client and shared with platform .

In some embodiments e.g. as is shown in a spreading function is used to spread the encrypted symmetric keys inside the DSB as shown in region by spreading the bits of the encrypted key in a spreading function generated pattern with the default function being a sequential block or data. The spreading function also contains the cryptographic hashed representation of the recipient usernames that are used by the server to identify the recipients of the message and to set the message waiting flag for each of them. Finally the DSB is itself encrypted using key Ek encrypted portion which is a symmetric key shared between app and platform . Additional detail regarding portions and are shown in where SK1 in is Ekin and represents the symmetric encryption key shared by the app and platform and where UserPubkey in is Ekin and represents the recipient s particular public key e.g. selected from the pool of public keys generated at .

As mentioned above Bob is also a user of platform . When Bob loads his copy of the messaging app on his smartphone i.e. app on device the app communicates with platform e.g. via interface to determine whether Bob has any new messages. As will be described in more detail below platform will also determine how many additional keypairs Bob s device should generate to replenish his pool and facilitate the generation of those keypairs. Since Alice has sent a message to Bob since he last used app a flag is set in database indicating to app that one or messages are available for download.

At i.e. assuming the decryption was successful hardware binding parameters are checked. As one example a determination is made as to whether device information i.e. collected from device can be used to construct an identical hash to the one included in the received DSB. If the hardware binding parameters fail the check i.e. an attempt is being made to access Alice s message using Bob s keys on a device that is not Bob s contents of the DSB will be inaccessible preventing the decryption of Alice s message. If the hardware binding parameter check is successful the device is authorized to decrypt the symmetric key e.g. using Bob s private key generated at which can in turn be used to decrypt Alice s message . As will be described in more detail below e.g. in Section G additional controls can be applied e.g. by Bob s app to Bob s ability to access Alice s message.

The following are examples of processes that can be performed by various entities present in environment such as platform and devices and in various embodiments whether as alternate versions of or additional processes to those described above . The processes can also be performed outside of environment e.g. by other types of platforms and or devices.

At a number of keypairs is generated. In this example a number of asymmetric keypairs equal to the initialization value received at e.g. fifty is generated. In some embodiments the keypairs are randomly seeded.

At reference values e.g. usable to uniquely identify each of the key pairs and described in more detail above are assigned for each of the keypairs generated at .

At the private key portion of the key pairs i.e. the fifty private keys and associated reference values are securely stored locally e.g. on device . As one example the private keys are inserted into a database resident on device and secured using an AES key derived from the password selected by Alice at portion in process .

Finally at the public key portion of the key pairs i.e. the fifty public keys and associated reference values are securely transmitted to platform . As mentioned above platform will designate one of the fifty keys as a reserve key e.g. by setting a flag associated with that particular key .

At a public key is received e.g. by device from platform along with the reference value associated with the key.

At the received public key is used to encrypt information such as a message or other information e.g. a symmetric key which in turn is used to encrypt the message . The key reference value associated with the received public key is included in the message metadata or otherwise incorporated into the message payload.

Finally at device sends the message e.g. to platform for retrieval by Alice . Note that using techniques described Alice s device s need not be online e.g. connected to platform at the time Bob composes and or sends messages to her.

For each retrieved message at read the respective key reference value e.g. included in the respective message as metadata retrieve the appropriate private key i.e. having the key reference value from local storage on device and decrypt the message s .

At device generates additional keypairs i.e. to replenish public keys used from the pool on platform by Bob . The number of keys to be generated can be determined in a variety of ways. As one example device can generate a number of new keypairs equal to the number of messages she received at . As another example device can be instructed whether by platform or local instructions to generate the lesser of A the number of messages downloaded at V where V is a variable impacting the desired expansion rate of the server cache size e.g. 0.9 or B the initialization value e.g. 50 keys as discussed at in process .

At similar to reference values e.g. usable to uniquely identify each of the key pairs and described in more detail above are assigned for each of the keypairs generated at .

At similar to the private key portion of the key pairs i.e. the new private keys and associated reference values are securely stored locally e.g. on device . As one example the private keys are inserted into a database resident on device and secured using the password selected by Alice at in process .

Finally at similar to the public key portion of the key pairs i.e. the new public keys and associated reference values are securely transmitted to platform . In this example suppose Alice s reserve key was not depleted. The key originally designated as her reserve key remains present on platform and remains designated as the reserve key. Now suppose Alice s reserve key was depleted e.g. because Bob and or other users of platform sent Alice more than fifty messages prior to her connecting to platform . The first 49 messages addressed to Alice would make use of those public keys in her pool not designated as the reserve key. Any additional messages sent to Alice before she can replenish her pool will all make use of her reserve public key i.e. messages 50 51 and 52 whether from Bob or others will all make use of the same public key for Alice her reserve key . As will be explained below when Alice s pool has been deleted i.e. her reserve key is being used a flag will be set on platform indicating that in conjunction with her next execution of process or portions thereof as applicable a new key should be designated as the reserve key and the existing reserve key be destroyed. Additional actions can also be taken e.g. by platform in response to Alice depleting her key pool such as by increasing the size of her pool.

At the device receives the current server key cache count i.e. the number of keys presently in the platform s pool for the user . At the device generates an appropriate number of keypairs and reference values and stores transmits them in accordance with the techniques described above. Further in the event the server key cache count is zero i.e. the reserve key is being used by platform due to key pool depletion one of the newly generated keys will be designated by the server as a replacement reserve key and the old reserve key will be destroyed.

As mentioned above one example of a message control a sender can specify for a message is a limit on the time period also referred to herein as a time to live or TTL during which a recipient is able to access the message e.g. to view listen to or otherwise interact with the message and any attachments . In scenarios such as where the sender is using an embodiment of platform operated by an enterprise on behalf of its employees the TTL may be selected by an entity other than the sender e.g. based on a default corporate policy or based on administrator configurable rules implemented by an enterprise specific version of the secure messaging application . For example messages sent by employees to one another e.g. as specified on a privacy list can have a first default TTL and messages sent by employees to vendors also using the enterprise specific application can have a second default TTL. As another example messages sent by certain employees e.g. within a particular department such as the legal department or having certain titles or positions and e.g. as specified on a privacy list can be given different default TTLs. In various embodiments the default TTL can be overridden if permitted by an administrator configuration.

The TTL is encrypted and sent together with the secure message. When the recipient opens the message e.g. taps or clicks on the message in an app the message is decrypted and displayed on the recipient s device. The corresponding TTL is decrypted and in some embodiments converted into a message expiry time by adding the TTL e.g. expressed in seconds to the current time. In various embodiments the TTL is stored in the recipient s device s secure database and encrypted to prevent tampering with the secure TTL by the device s user. As will be described in more detail below the current time can also be secured e.g. against attempts by the recipient to thwart the TTL by adjusting a clock on the recipient s device . Once the TTL has expired the message is no longer accessible to the recipient e.g. is removed from the recipient s viewing interface and deleted from the recipient s device s secure database along with any associated decryption keys .

The sender or sender s application as applicable e.g. where configured by an enterprise administrator can specify time limits in a variety of ways. As one example the sender can set a maximum duration e.g. a one day limit with the time limit countdown commencing when the recipient first opens the message. The time limit countdown can also be commenced when the sender sends the message. As another example the sender can specify a fixed start time e.g. for embargo purposes before which the recipient is unable to access the message even if the recipient is already in possession of the message. Once the embargo period ends as with above a TTL value can control how long the recipient is able to view the message once opened. This allows for example a company to release company news to multiple shareholders in a secure time controlled manner with each shareholder having the same opportunity to open the message at the same start time. This also allows an enterprise to implement rules e.g. via an enterprise specific version of the secure messaging application platform that only allow employees to open messages during certain periods of the day. E.g. hourly workers can only read messages during business hours salaried workers have no such prohibition. As yet another example the sender can specify a fixed end time after which the recipient is unable to access the message irrespective of whether the message was also given an upon opening TTL e.g. of ten minutes . Further in various embodiments a sender of the message can shorten a limit on an already sent message. For example if Bob sends Alice a message with a one day limit and Alice opens that message Bob can subsequently revoke Alice s ability to continue to read the message even though the day has not passed by interacting with his app e.g. by long pressing on the sent message as it appears to Bob and selecting an expire now immediately expiring the message or expire faster expiring the message at a new time picked by Bob option as applicable .

At the message expiration time Expire Time is set as the Current Time determined at with the TTL e.g. 3600 seconds added. Thus for example when Alice opens message e.g. at 1 26 pm a Current Time is obtained from platform or another appropriate external time source and a TTL of is added to the Current Time resulting in an Expire Time of 2 26 pm.

At a determination is made as to whether the Current Time is greater than the Expire Time. If not Alice is able to view the message and after a period of time e.g. one second elapsing another check of the Current Time vs. the Expire Time is performed . In various embodiments the Current Time continues to be obtained from an external source e.g. device contacts platform every second . In other embodiments app is responsible for maintaining the Current Time at least a portion of the time after performing an initial check with platform of the Current Time upon message open. In some embodiments if a Current Time cannot be obtained from an external source e.g. platform or another server during the ongoing checking of portion the message will cease being available to Alice. So for example if Alice temporarily loses connectivity during the one hour window of time Bob has allowed her to read message Alice will be unable to read message during that portion of the hour. In some embodiments the TTL countdown continues irrespective of whether Alice is offline meaning that Alice will not be given additional time to view the message to compensate for the period her device lacked connectivity. Eventually e.g. after one hour has elapsed the Current Time will exceed the Expire Time at which point the message is deleted .

Traditional messaging systems typically allow all users of the system to generate and send a message to an arbitrary recipient. If the recipient does not want to receive messages the recipient must either rely on spam filters or delete the messages after they arrive as applicable. The sender in a traditional system is not prevented from sending messages to a recipient that does not wish to receive messages thus wasting money creating congestion on the network s wasting bandwidth wasting processing power and annoying the recipient etc.

In contrast using techniques described herein users of embodiments of platform or their representatives as applicable are able to edit privacy lists which allow would be recipients to control from whom they receive messages. In various embodiments the user s privacy list is stored in database e.g. in encrypted form with username entries stored as hashes and is globally applied across all of the user s devices where the user has multiple devices configured to use platform . As will be described in more detail below in some embodiments the privacy settings are mutual meaning that if a first user chooses not to receive messages from a second user the first user will symmetrically be unable to send messages to the second user. In various embodiments users are able to select from and switch between one of two privacy modes a block mode and a whitelist mode. Based on which mode the user is in the user s privacy list will have different effects. In some embodiments instead of having a single list treated differently based on which mode the user is in the user has a respective list for a respective mode. As one example where platform is operated on behalf of an entity such as a school certain user accounts e.g. announcements or campus policy can be included in a universal whitelist applicable to all users irrespective of individual user settings. In such a scenario students or other users of the school specific platform are otherwise able to operate in allow or block mode and make individual choices about which usernames to include in their individual privacy list. In various embodiments the user can only be in one privacy mode at a time e.g. preventing the user from inadvertently misconfiguring the user s settings to prevent all users of the system from messaging the user .

Suppose Alice has been receiving unwanted messages from a user of platform Charlie. Alice would like to prevent Charlie from sending any more messages to her. Alice can use the block mode to provide a list of specific users such as Charlie who should be blocked from sending her messages. Charlie once blocked by Alice will be unable to send messages to Alice because platform will not provide Charlie with Alice s public key. In Alice has selected to be in block mode by clicking on region as indicated by the checkmark . Charlie is the first user Alice has decided to block and she enters his username in region . Alice can later un block Charlie if desired by clicking on region . Alice can add additional users to be blocked by clicking region and providing their usernames if desired. When a user e.g. Alice is in block mode the user will be able to receive messages from any users not appearing on the list also referred to herein as a privacy list such as the list of just Charlie shown in . The privacy setting is mutual meaning that Alice will also be unable to message Charlie if she adds him to her privacy list while in block mode i.e. Alice will symmetrically be unable to obtain Charlie s public key from platform while she has blocked Charlie .

An alternate way for Alice to prevent Charlie from sending her messages is for Alice to enter whitelist mode. In whitelist mode also referred to herein as allow mode only those users whose usernames Alice has added to her privacy list will be able to obtain her public key and thus send her messages. And in some embodiments symmetrically Alice will only be able to send messages to i.e. obtain the public keys of those users appearing in her privacy list while in whitelist mode. In Alice has selected to be in whitelist mode by clicking on region as indicated by the checkmark . Alice likes communicating with Bob and so has entered his name in region indicating that Bob is allowed to send her messages i.e. obtain her public key . Alice can remove Bob from her privacy list by clicking on region and can add additional users to her privacy list by clicking on region .

In various embodiments an entity other than the end user of platform or embodiments of platform has control over that end user s privacy list or as applicable can configure a supplemental privacy list for the user . As one example suppose an embodiment of platform is made available to families as a service. Parents of children using the service are able to customize e.g. through a password protected interface on their child s app whether their child s app should operate in block mode or whitelist mode. Those parents can further configure which usernames should appear on their child s privacy list e.g. resulting in a messaging app that allows the child to communicate with family members and known friends only . As another example where platform is operated on behalf of a University the University specific embodiment of the secure messaging app can be configured to support a predefined whitelist e.g. such that all University specific secure messaging apps will always allow communications from certain University accounts such as campus police to be sent and permit students to optionally configure their own individual block lists e.g. of other students they do not want to receive messages from if desired.

At a determination is made as to whether the sender is allowed to send the message to the recipient based on a privacy list. As one example at platform determines whether Bob is in block mode or in whitelist mode. Platform also determines whether Bob s privacy list contains an entry for Alice. In various embodiments platform also determines whether Alice is in block mode or whitelist mode and further determines whether Alice s privacy list contains an entry for Bob. Specific examples of how the determination at can be performed are described in more detail in conjunction with .

Finally at the sender receives a response to the send request based on the determination made at . For example where a determination is made at that the sender is allowed to send a message to the recipient at platform sends a public key of the recipient to the sender. Where a determination is made at that the sender is not allowed to send a message to the recipient at platform does not send the public key of the recipient to the sender. In various embodiments an applicable rejection message e.g. as shown in interface is shown to the sender.

At a determination is made as to whether the sender is in block mode. As one example at platform examines database for information about which privacy mode the sender is in. In various embodiments a user defaults to being in the block mode with an empty privacy list. As mentioned above a user can change which mode the user is in and add or remove other users from a privacy list by interacting with interfaces such as are shown in . Manipulations of a user of interfaces and are transmitted to platform which updates database and its encrypted entries accordingly.

If the sender is in block mode a determination is made at as to whether the recipient is in the sender s privacy list. This indicates that the sender is attempting to send a message to a recipient that the sender has prevented from sending messages to the sender. Accordingly in some embodiments due to the mutual symmetric nature of privacy controls the sender will be prevented from sending the message to the recipient i.e. the sender will not be sent the recipient s public key at .

If the sender is not in block mode the sender is instead in allow mode and a determination is made at as to whether the recipient is in the sender s privacy list. If the recipient is not in the sender s privacy list this indicates that the sender has not whitelisted the recipient as someone who can message the sender. Accordingly in some embodiments due to the mutual symmetric nature of privacy controls the sender will be prevented from sending the message to the recipient i.e. the sender will not be sent the recipient s public key at .

In the event the sender is in block mode and the recipient is not blocked by the sender i.e. the recipient is not on the sender s privacy list or in the event the sender is in allow mode and the recipient is in the sender s privacy list i.e. the recipient is explicitly allowed by the sender s list process next examines the recipient s privacy settings. In particular at a determination is made as to whether the recipient is in block mode. If so at a determination is made as to whether the sender is in the recipient s privacy list. If not the sender will be provided with the recipient s public key at and can send a message to the recipient . If so the sender will not receive the recipient s public key at and cannot send a message to the recipient .

In the event the recipient is not in block mode at a determination is made as to whether the sender is in the recipient s privacy list. If so at the sender will be provided with the recipient s public key and can send a message to the recipient . If not at the sender will not receive the recipient s public key and cannot send a message to the recipient .

As explained above in the event the sender is unable to obtain the recipient s public key due to privacy settings the sender can be presented with an appropriate message in the secure messaging application such as message or message as applicable.

Disclosed herein are techniques for generating dynamic verification content in which a reading of a representation of a public key is blended with additional dynamic information such as the would be verified person s name and current date time. A variety of actions can be taken e.g. based on user preferences or in the case of enterprise or other applicable implementations administrator settings in response to a verification process being performed. For example if a verification by a first user of a second user hasn t been performed or has expired the first user can be given the option to receive no indication of the lack of verification to receive a warning or e.g. to block communications to from the second user until successful verification takes place.

Suppose that one user hereinafter referred to as Robert of platform or an embodiment thereof would like to exchange messages with his friend Chris. Robert has a secure messaging application installed on his smartphone . Chris is personally known to Robert e.g. he is someone that Robert has met in person and or attributes such as his physical likeness and or voice are otherwise already known to Robert . Robert believes that Chris s username on platform is Chris and so he sends an initial message to Chris e.g. using an embodiment of interface with a message of Hi this is Robert and a supplied username of Chris as the recipient. Robert receives a response back that says Hi Robert The user with whom Robert is corresponding might be Robert s friend Chris. However the user might instead be an imposter another person coincidentally named Chris who also knows someone named Robert or is interested in meeting someone new etc.

Using techniques described herein key signature verification also referred to herein as fingerprint verification can be performed between Robert and Chris as well as an audiovisual physical verification so that Robert can confirm that he is securely communicating with his friend Chris. For example Robert e.g. via app can ask Chris to verify himself e.g. via app . Robert can likewise be asked by Chris to verify himself and or Robert can also spontaneously send a volunteered verification of himself to Chris. As will be described in more detail below the verification can include a human generated content aspect e.g. an audiovisual recording of the person to be verified and a digital content aspect e.g. the incorporation of one or more digital fingerprints or representations thereof . As one example Chris can be guided to record a video in which he is prompted to read out loud a fingerprint or other representation corresponding to a public key associated with Chris e.g. a cryptographic hash of Chris s public key . Through this approach Robert can verify both that the Chris with whom he is communicating is in fact his friend Chris e.g. can verify to his satisfaction Chris s identity and also that keys purporting to belong to Chris e.g. obtained from platform and used in accordance with the principle of first trust in fact do i.e. no man in the middle or other tampering with communications has occurred .

The identity verification is performed individually e.g. one for each user entry in Robert s friend list address book etc. . In some embodiments the status of a given contact as being verified by a user is stored on the user s device inside a database resident on the device and secured using an AES key derived from the password selected by Alice at portion in process .

Verification can be performed at the time a contact is initially added as a contact can be performed the first time a user sends a message to that contact can be performed on demand either spontaneously by someone sending their own verification or in response to a request made by the other user or otherwise initiated. Re verification can be requested of any contact at any time. Re verification can also be automatically required after a period of time has elapsed. For example Robert can adjust a setting in his app that forces a re verification to take place every six months. In that scenario once six months have elapsed after a given verification has been performed app removes the verified status associated with the verified contact e.g. in the secure database stored on his device and Robert can re initiate a verification of that contact.

In some embodiments where a user has multiple devices any verifications performed on one device e.g. verifications performed by Robert of Chris and by Robert of Dave may be propagated between the verifier s devices. One way to accomplish this is for the local secure database used by his app or portions of the contents therein to be securely backed up e.g. in encrypted form on server . When Robert enrolls a second device with server a copy of the secure database or portions of the contents as applicable can be downloaded to the second device. Server can similarly be used to keep the data in sync e.g. with each of Robert s devices pushing updates to the backup stored on server whenever a verification change has been made . In some embodiments Robert must independently verify contacts on each of his devices. According to some embodiments whether or not verifications are propagated is configurable by Robert or an administrator as applicable e.g. where the app is used in an enterprise context .

Identity verification techniques described herein can be used in conjunction with other techniques described herein e.g. secure messaging provided by platform and can also be incorporated into other systems e.g. other than platform or embodiments thereof . As will be described in more detail below a digital fingerprint component and an audiovisual component can be combined e.g. in a verifier s display . The audiovisual portion is tamper resistant allowing it to be transmitted in band even if the sender person to be verified or receiver verifier is currently being subjected to a man in the middle attack.

Robert can turn on the send to verified apps only option by sliding button to the right. When this mode is turned on app will only allow Robert to send receive messages to from users that have successfully verified themselves described in more detail below . One way this can be performed is for app to maintain a list of users Robert has verified e.g. in a local encrypted database and treat that list as a whitelist. If a user is not on the whitelist the only kind of message Robert can send receive to from that user is a verification request or verification e.g. Robert cannot write arbitrary messages to the user or receive arbitrary messages from the user . When the send to verified apps only mode is turned off as shown in app will also allow Robert to communicate with unverified users. The send to verified apps only mode can also be configured to operate differently in various embodiments and or can be joined by replaced by other modes of operation . For example incoming messages can be checked for compromise by making sure that the key used to decrypt the message is signed with a private component of a previously verified sender s public key. If not a warning can be shown to the user e.g. instead of blocking the message entirely . As another example a check can be made as to whether a public component of message encryption key was signed with a private component of a previously verified receiver s public key. If not take an appropriate action such as warning the user not sending a message with that key etc. As yet another example instead of blocking communications to from unverified users Robert can be given the option to allow such messages but require they include a warning element. Examples of warning elements include popup warnings e.g. displayed to Robert before he is presented with a message the addition of a warning symbol indicator inline with the message e.g. a hazard symbol message text being rendered in different colors based on verification e.g. green or black text for messages with verified users red text for unverified users etc. .

In various embodiments the status of a given user s verification can be presented to Robert irrespective of whether option is turned on or off. For example verified users can have their usernames e.g. as shown in an address book or in places such as region highlighted in green unverified users can have their usernames highlighted in red and users from which a verification has been requested but not yet received can have their usernames highlighted in orange.

If Robert clicks on the text in region a message requesting that Chris identify himself will be transmitted to the user Chris. The message can be sent in accordance with the secure messaging techniques described above. In various embodiments the message sent to Chris in response to Robert clicking in region is automatically created by the system e.g. Robert is not asked to supply any additional text and includes a flag e.g. included as one of the message controls that indicates to Chris s own application that the incoming message from Robert is a verification request message. When Chris opens an identity request message he will be asked by a dialogue in his own app whether he would like to provide an identification. If he selects no a further verification process will not occur. If he selects yes additional processing is performed as described in more detail below .

Suppose Robert scrolls down in interface . He will then see a view as depicted in . If Robert clicks on region he will be presented with an interface that guides him through generating a verification of himself and his digital fingerprint to send to Chris described in more detail below. If he clicks on region app will provide a copy of Robert s fingerprint to a native or other SMS application on Robert s phone allowing Robert to send the fingerprint to his friend Chris by supplying his friend Chris s phone number e.g. entering the number in or selecting it from the native device address book . If he clicks on region app will provide a copy of Robert s fingerprint to a native or other email application on Robert s phone allowing Robert to send the fingerprint to his friend Chris by supplying his friend Chris s email address e.g. entering the address in or selecting it from the native device address book . The following is an example of a fingerprint signature that can be sent via SMS or in email by Robert to Chris My wickr identity is WCOMFZAIQEY7YDW6NY776ACF6HTYG3 SJHA2LAQ4LVAPJEHTJOSXQ. 

If Robert s friend Chris SMSes emails or otherwise provides Robert with a verification of Chris s fingerprint outside of app Robert can enter the provided fingerprint by clicking the text in region which will then present Robert with a dialogue box into which he can paste type or otherwise enter Chris s fingerprint. App will compare the value entered by Robert to the fingerprint of the key already stored by app and if the values match Chris s key will be marked as verified. If the values do not match the verification has failed indicating a possible man in the middle attack and Chris s key will be marked as falsely verified or not verified as applicable .

Suppose Robert decides to verify himself to Chris by using the in band identity verification functionality provided by app e.g. by clicking on the text in . Robert is in some embodiments presented with interface as shown in which provides him with a set of tips for creating a verification message of himself for Chris. When Robert clicks on the text in region he is prompted to begin recording a video with his face clearly visible on the screen. An example interface for capturing Robert s verification is shown in . In the example shown audiovisual information is captured by Robert s device e.g. his phone s microphone and front facing camera are turned on . The recording time elapsed is shown in region . A dynamic script for Robert to follow is shown in region as is the video currently being captured. Robert is prompted to state information such as his name whether legal name nickname etc. and can also be prompted to state additional information such as the current date and time which can optionally be displayed to him as he starts recording .

After an appropriate amount of time has elapsed for Robert to state such information e.g. five seconds a representation of Robert s digital fingerprint is displayed to Robert and Robert is prompted to read the information out loud. As mentioned above the verification techniques described herein can be used in a variety of contexts whether in conjunction with other functionality provided by embodiments of platform or not. Accordingly the fingerprint to be verified by Robert can vary based on the context in which the verification technique is employed. In the following example suppose at the time Robert creates an account on platform a master public private keypair is generated on his behalf e.g. at . The master private key can be used for a variety of purposes such as signing messages attachments and any additional keys generated on behalf of the user e.g. in accordance with process . The corresponding master public key can be included in DSBs sent by Robert e.g. as described in conjunction with portion of process .

As shown in a representation of a cryptographic hash of Robert s public key generated locally on Robert s device and shared with platform is displayed to Robert in app and Robert is prompted to read it. In some embodiments the full cryptographic hash of Robert s public key i.e. a fingerprint is displayed. In other embodiments a portion of the fingerprint or other representation associated with the fingerprint is displayed. As one example suppose the fingerprint comprises a 32 byte SHA value. Instead of requiring Robert to read the entire value out loud a transformation can be used by app and similarly used by other apps such as app and to programmatically reduce the 32 byte SHA value to an easier to read size. As one example a 12 byte sub portion of the 32 byte SHA value can be displayed to Robert to read. An example of a sub portion of a 32 byte SHA value is illustrated in region of . In some embodiments a fully populated grid is initially presented to Robert. In other embodiments a blank grid of squares is initially presented. The grid then populates with the selected sub portion of the 32 byte SHA value which Robert is asked to read as the grid is populated. For example the squares can be populated every certain number of seconds one at a time left to right row by row to allow Robert to pace himself and clearly read each of the characters presented.

The recording concludes e.g. after a set amount of time such as 30 seconds or when Robert clicks on button . The captured audiovisual content is then transmitted to the user Chris e.g. as a message attachment encapsulated in a DSB using techniques described above . In various embodiments additional information is also included in the message for example the contents of the grid displayed to Robert that Robert was instructed to read out loud can be saved into the audiovisual recording of Robert e.g. as a saved overlay or supplied as an additional attachment. As another example a SHA 256 file signature can be taken of the audiovisual recording and included in the DSB to prove that the recording has not been altered or replaced in transit.

At a verification routine is initiated. As one example where Robert has decided to spontaneously verify himself to Chris the verification routine is initiated at when Robert clicks on Continue button and the script of what Robert should say during the audiovisual recording commences . Similarly where Chris is verifying himself in response to a request from Robert the verification routine is initiated when Chris selects a method of verification option from an interface that corresponds to region of interface . Finally at a result of the verification routine is transmitted to a remote user. As one example where Robert is spontaneously verifying himself to Chris when Robert s audiovisual recording e.g. made using interface completes it is packaged into a DSB as explained above and transmitted to Chris e.g. via platform at . As another example where Chris has accepted a request from Robert to verify himself once Chris s audiovisual recording has completed the recording is similarly packaged into a DSB and transmitted to Robert at . Where instead of choosing to make an audiovisual recording e.g. by selecting option Chris or Robert instead chooses to verify himself using an SMS or email portion of process occurs when the applicable SMS or email message is sent e.g. in accordance with techniques described above .

Alternate examples of interfaces for generating and viewing verification video and other data are shown in respectively. is an example of an interface shown to the person recording the video in this example Bob . The sub portion of Bob s fingerprint to be spoken out loud is 3AF6 and is indicated to Bob both in conjunction with a dynamic script in region and by an indication of where within the whole fingerprint the sub portion was extracted . Alice s app has a key stored for Bob and is able to display the local copy of his stored key shown in the bottom portion of Figure of B at against the verification transmission shown in the top portion of at . In some embodiments Alice is given controls such as a set of checkmarks that she can tick as she verifies Bob s information. In some embodiments Alice is required to re enter her app password in conjunction with ticking the checkmarks.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

