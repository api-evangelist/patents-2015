---

title: Incremental block level backup
abstract: Disclosed are systems, computer-readable mediums, and methods for incremental block level backup. An initial backup of a volume is created at a backup server, where creating the initial backup includes retrieving an original metadata file from a metadata server, and retrieving a copy of all data of the volume based on the original metadata file. A first incremental backup of the volume is then created at the backup server, where creating the first incremental backup includes retrieving a first metadata file, where the first metadata file was created separately from the original metadata file. A block identifier of the first metadata file is compared to a corresponding block identifier of the original metadata file to determine a difference between the first and original block identifiers, and a copy of a changed data block of the volume is retrieved based on the comparison of the first and original block identifiers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09558073&OS=09558073&RS=09558073
owner: NETAPP, INC.
number: 09558073
owner_city: Sunnyvale
owner_country: US
publication_date: 20150413
---
The present application is a continuation of U.S. patent application Ser. No. 14 057 145 filed Oct. 18 2013 the entire contents of which are incorporated herein by reference in its entirety.

The following description is provided to assist the understanding of the reader. None of the information provided is admitted to be prior art.

In data storage architectures a client s data may be stored in a volume. A unit of data for example a file or object is comprised of one or more storage units e.g. bytes and can be stored and retrieved from a storage medium such as disk or RAM in a variety of fashions. For example disk drives in storage systems are divided into logical blocks that are addressed using logical block addresses LBAs . As another example an entire file can be stored in a contiguous range of addresses on the storage medium and be accessed given the offset and length of the file. Most modern file systems store files by dividing them into blocks or extents of a fixed size storing each block in a contiguous section of the storage medium and then maintaining a list or tree of the blocks that correspond to each file. Some storage systems such as write anywhere file layout WAFL logical volume manager LVM or new technology file system NTFS allow multiple objects to refer to the same blocks typically through a tree structure to allow for efficient storage of previous versions or snapshots of the file system. In some cases data for a single file or object may be distributed between multiple storage devices either by a mechanism like RAID which combines several smaller storage media into one larger virtual device or through a distributed storage system such as Lustre General Parallel File System or GlusterFS.

At some point it is desirable to backup data of the storage system. Traditional backup methods typically utilize backup software that operates independently of the data storage system and manages the backup process. Backup methods exist to backup only the differences since the last full backup e.g. a differential backup or to backup only the changes since the last backup e.g. an incremental backup . However due to inefficiency of backup software many administrators are shifting away from traditional backup processes and moving towards data replication methods. Though replication requires the use of a second data storage system for replication purposes which can be costly. Also with replication comes the issue of replicating a mistake for example a wrongly deleted file. High bandwidth is required for both replication and backup solutions and neither methods are particularly well suited to scale efficiently for long term archiving.

In general one aspect of the subject matter described in this specification can be embodied in a system that includes a backup server comprising one or more processors configured to create an initial backup of a volume and create a first incremental backup of the volume. Creating the initial backup includes retrieving an original metadata file from a metadata server where the metadata file comprises an ordered list of block identifiers for data blocks of the volume where each block identifier is used to access a data block stored on a block server and where the block identifier is a hash based on content of a corresponding data block. Creating the initial backup further includes retrieving a copy of all data of the volume based on the original metadata file. Creating the first incremental backup of the volume includes retrieving a first metadata file where the first metadata file was created separately from the original metadata file. Creating the first incremental backup further includes comparing a block identifier of the first metadata file to a corresponding block identifier of the original metadata file to determine a difference between the first and original block identifiers where the difference indicates that a data block corresponding to the first block identifier has changed and retrieving the changed data block based on the comparison of the first and original block identifiers.

Another aspect of the subject matter described in this specification can be embodied in methods for creating an initial backup of a volume at a backup server and creating a first incremental backup of the volume at the backup server. Creating the initial backup includes retrieving an original metadata file from a metadata server where the metadata file comprises an ordered list of block identifiers for data blocks of the volume where each block identifier is used to access a data block stored on a block server and where the block identifier is a hash based on content of a corresponding data block. A copy of all data of the volume is retrieved based on the original metadata file. Creating the first incremental backup of the volume at the backup server includes retrieving a first metadata file wherein the first metadata file was created separately from the original metadata file comparing a block identifier of the first metadata file to a corresponding block identifier of the original metadata file to determine a difference between the first and original block identifiers where the difference indicates that a data block corresponding to the first block identifier has changed and retrieving the changed data block based on the comparison of the first and original block identifiers. In alternative embodiment the method further includes creating a second incremental backup including retrieving a second metadata file where the second metadata file was created separately from the first metadata file. A block identifier of the second metadata file is compared to a corresponding block identifier of the first metadata file to determine a difference between the second and first block identifiers where the difference between the second and first block identifiers indicates that a data block corresponding to the second block identifier has changed. The changed data block corresponding to the second block identifier is retrieved based on the comparison of the second and first block identifiers. Other implementations of this aspect include corresponding systems apparatuses and computer readable media configured to perform the actions of the method.

Another aspect of the subject matter described in this specification can be embodied in a non transitory computer readable medium having instructions stored thereon that when executed by a computing device cause the computing device to perform operations including creating an initial backup of a volume at a backup server and creating a first incremental backup of the volume at the backup server. Creating the initial backup includes retrieving an original metadata file from a metadata server where the metadata file comprises an ordered list of block identifiers for data blocks of the volume where each block identifier is used to access a data block stored on a block server and where the block identifier is a hash based on content of a corresponding data block. A copy of all data of the volume is retrieved based on the original metadata file. Creating the first incremental backup of the volume at the backup server includes retrieving a first metadata file wherein the first metadata file was created separately from the original metadata file comparing a block identifier of the first metadata file to a corresponding block identifier of the original metadata file to determine a difference between the first and original block identifiers where the difference indicates that a data block corresponding to the first block identifier has changed and retrieving the changed data block based on the comparison of the first and original block identifiers.

The foregoing summary is illustrative only and is not intended to be in any way limiting. In addition to the illustrative aspects implementations and features described above further aspects implementations and features will become apparent by reference to the following drawings and the detailed description.

Described herein are techniques for an incremental block level backup system. In the following description for purposes of explanation numerous examples and specific details are set forth in order to provide a thorough understanding of various implementations. Particular implementations as defined by the claims may include some or all of the features in these examples alone or in combination with other features described below and may further include modifications and equivalents of the features and concepts described herein.

In general client layer includes one or more clients . Clients include client processes that may exist on one or more physical machines. When the term client is used in the disclosure the action being performed may be performed by a client process. A client process is responsible for storing retrieving and deleting data in system . A client process may address pieces of data depending on the nature of the storage system and the format of the data stored. For example the client process may reference data using a client address. The client address may take different forms. For example in a storage system that uses file storage client may reference a particular volume or partition and a file name. With object storage the client address may be a unique object name. For block storage the client address may be a volume or partition and a block address. Clients communicate with metadata layer using different protocols such as small computer system interface SCSI Internet small computer system interface ISCSI fibre channel FC common Internet file system CIFS network file system NFS hypertext transfer protocol HTTP hypertext transfer protocol secure HTTPS web based distributed authoring and versioning WebDAV or a custom protocol.

Metadata layer includes one or more metadata servers . Performance managers may be located on metadata servers . Block server layer includes one or more block servers . Block servers are coupled to storage which stores volume data for clients . Each client may be associated with a volume. In one implementation only one client accesses data in a volume however multiple clients may access data in a single volume.

Storage can include multiple solid state drives SSDs . In one implementation storage can be a cluster of individual drives coupled together via a network. When the term cluster is used it will be recognized that cluster may represent a storage system that includes multiple disks that may not be networked together. In one implementation storage uses solid state memory to store persistent data. SSDs use microchips that store data in non volatile memory chips and contain no moving parts. One consequence of this is that SSDs allow random access to data in different drives in an optimized manner as compared to drives with spinning disks. Read or write requests to non sequential portions of SSDs can be performed in a comparable amount of time as compared to sequential read or write requests. In contrast if spinning disks were used random read writes would not be efficient since inserting a read write head at various random locations to read data results in slower data access than if the data is read from sequential locations. Accordingly using electromechanical disk storage can require that a client s volume of data be concentrated in a small relatively sequential portion of the cluster to avoid slower data access to non sequential data. Using SSDs removes this limitation.

In various implementations non sequentially storing data in storage is based upon breaking data up into one more storage units e.g. data blocks. A data block therefore is the raw data for a volume and may be the smallest addressable unit of data. The metadata layer or the client layer can break data into data blocks. The data blocks can then be stored on multiple block servers . Data blocks can be of a fixed size can be initially a fixed size but compressed or can be of a variable size. Data blocks can also be segmented based on the contextual content of the block. For example data of a particular type may have a larger data block size compared to other types of data. Maintaining segmentation of the blocks on a write and corresponding re assembly on a read may occur in client layer and or metadata layer . Also compression may occur in client layer metadata layer and or block server layer .

In addition to storing data non sequentially data blocks can be stored to achieve substantially even distribution across the storage system. In various examples even distribution can be based upon a unique block identifier. A block identifier can be an identifier that is determined based on the content of the data block such as by a hash of the content. The block identifier is unique to that block of data. For example blocks with the same content have the same block identifier but blocks with different content have different block identifiers. To achieve even distribution the values of possible unique identifiers can have a uniform distribution. Accordingly storing data blocks based upon the unique identifier or a portion of the unique identifier results in the data being stored substantially evenly across drives in the cluster.

Because client data e.g. a volume associated with the client is spread evenly across all of the drives in the cluster every drive in the cluster is involved in the read and write paths of each volume. This configuration balances the data and load across all of the drives. This arrangement also removes hot spots within the cluster which can occur when client s data is stored sequentially on any volume.

In addition having data spread evenly across drives in the cluster allows a consistent total aggregate performance of a cluster to be defined and achieved. This aggregation can be achieved since data for each client is spread evenly through the drives. Accordingly a client s I O will involve all the drives in the cluster. Since all clients have their data spread substantially evenly through all the drives in the storage system a performance of the system can be described in aggregate as a single number e.g. the sum of performance of all the drives in the storage system.

Block servers and slice servers maintain a mapping between a block identifier and the location of the data block in a storage medium of block server . A volume includes these unique and uniformly random identifiers and so a volume s data is also evenly distributed throughout the cluster.

Metadata layer stores metadata that maps between client layer and block server layer . For example metadata servers map between the client addressing used by clients e.g. file names object names block numbers etc. and block layer addressing e.g. block identifiers used in block server layer . Clients may perform access based on client addresses. However as described above block servers store data based upon identifiers and do not store data based on client addresses. Accordingly a client can access data using a client address which is eventually translated into the corresponding unique identifiers that reference the client s data in storage .

Although the parts of system are shown as being logically separate entities may be combined in different fashions. For example the functions of any of the layers may be combined into a single process or single machine e.g. a computing device and multiple functions or all functions may exist on one machine or across multiple machines. Also when operating across multiple machines the machines may communicate using a network interface such as a local area network LAN or a wide area network WAN . In one implementation one or more metadata servers may be combined with one or more block servers or backup servers in a single machine. Entities in system may be virtualized entities. For example multiple virtual block servers may be included on a machine. Entities may also be included in a cluster where computing resources of the cluster are virtualized such that the computing resources appear as a single entity.

One or more backup servers can interface with the metadata layer . Backup servers can interface directly with block servers . Backup servers are coupled to storage which stores backups of volume data for clients . Storage can include multiple hard disk drives HDDs solid state drives SSDs hybrid drives or other storage drives. In one implementation storage can be a cluster of individual drives coupled together via a network. Backup servers can store backup copies of the data blocks of storage according to any number of formats in storage and translation from the format of the data blocks of storage may occur. Data may be transferred to and from backup servers using different protocols such as small computer system interface SCSI Internet small computer system interface ISCSI fibre channel FC common Internet file system CIFS network file system NFS hypertext transfer protocol HTTP hypertext transfer protocol secure HTTPS web based distributed authoring and versioning WebDAV or a custom protocol. Compression and data de duplication may occur in backup servers 

As discussed above the servers of metadata layer store and maintain metadata that maps between client layer and block server layer where the metadata maps between the client addressing used by clients e.g. file names volume object names block numbers etc. and block layer addressing e.g. block identifiers used in block server layer . In one embodiment the metadata includes a list of block identifiers that identifies blocks in a volume. The list may be structured as an ordered list corresponding to a list of blocks. The list may also be structured as the leaves of a hash tree. The block identifiers of the metadata are the same block identifiers as used throughout system as described above. The block identifiers may be hexadecimal numbers but other representations may be used. Additional metadata may also be included such as inode numbers directory pointers modification dates file size client addresses list details etc. The block identifiers uniquely identify the data of a block and are a hash based on the content of the data block. Backup servers are generally configured to create backups of block level data of a volume that is stored in storage of block server layer . Backup servers may create backups of all of the volume data of block server layer or backup servers may create backups of one or more particular volumes e.g. a volume of a client . Backups may be full backups of all data or they may be incremental backups e.g. data that has changed since a previous backup .

During an initial backup operation a backup server retrieves a copy of metadata from metadata server for a client volume. The metadata includes a list of block identifiers associated with data blocks of the volume. In an implementation the metadata includes an ordered list structure of block identifiers. In another implementation the ordered list is structured as the leaves of a hash tree e.g. a Merkle tree etc. and the metadata includes the hash tree. The metadata is used by backup server to retrieve a copy of all of the data blocks of the client volume in order to create an initial backup of the data blocks. The data blocks are retrieved from storage by sending a request for the data to a metadata server . The requested data is based on the data block identifiers. A request may include a list of the block identifiers of blocks desired to be backed up. In one implementation backup server may calculate the LBAs of blocks desired to be backed up. For example because each block identifier can represent a known amount of data e.g. a 4 k block etc. an LBA of a block can be calculated based on the location of the block identifier in the ordered list of block identifiers associated with the volume. For example the position of a block identifier in the ordered list can be used along with the block size to determine the LBA of the data block. As described below the tree structure can also be used to determine the data blocks that have changed after a previous backup. In this example the number of leaf nodes to the left of a changed leaf node can be used to calculate the LBA of the data block. In implementations where LBAs are calculated a request from backup server may include a list of LBAs of blocks to be backed up. The metadata server routes the request to a block server which provides the requested data to metadata server . Metadata server then routes the requested data to the backup server . This arrangement allows the servers of metadata layer to facilitate data transmission between block server layer and the backup servers . In another implementation backup servers may be configured to communicate directly with servers of block server layer . Upon retrieval of the requested data the backup server stores the data in storage . The data may be stored in storage according to any of the methods discussed herein. Backup server may create and maintain statistics and snapshot data corresponding to a particular backup operation. The snapshot data may be used later during a data restoration operation or during a future backup operation. Backup server can also store a copy of the metadata used during a particular backup operation. In another embodiment the metadata is not stored on the backup server . Rather the metadata is stored on another storage device for example one or more metadata servers one or more block servers or one or more devices remote from the backup system. As a result of the initial backup operation a complete backup of the data of a client volume is created and stored in storage .

During an incremental backup operation a backup server retrieves the current metadata from metadata server for a client volume. The backup server can then compare the current metadata from metadata server with a version of stored metadata on backup server e.g. the version of metadata stored during the most recent backup operation or the initial version of the metadata stored during the initial backup etc. . In an implementation where the metadata includes an ordered list of block identifiers the backup server can compare the block identifiers of the two versions of metadata node by node. For example the current list node corresponding to a first block of data is compared to the stored list node corresponding to the first block of data and each node of the ordered list is traversed and compared. Since the block identifiers are hashes based on content of a corresponding data block a difference in hash values for corresponding nodes indicates that the data of the block has been changed updated since the prior backup. As the block identifiers are integral to storage system and maintained as described herein the block identifiers can be compared in their native format and immediately used without the need to compute the hash values. In an implementation where the metadata includes a hash tree and the ordered list of block identifiers are structured as the leaves of the hash tree additional performance gains may be realized. Such a hash tree is generally a tree data structure in which every non leaf node includes the hash of its children nodes. This structure is particularly useful because it allows efficient determination of which data blocks have been updated since a prior backup without the need to compare every node of the list of block identifiers. The determination of changed data blocks by using a hash tree will be discussed in further detail below with reference to . Upon determination of which particular blocks of data have changed since the previous backup backup server can retrieve the updated blocks of data from storage by sending a request for the changed data block to the metadata server . As discussed above the metadata server can facilitate the transfer of data from the block server layer . Upon retrieval of the requested changed data blocks the backup server stores the data in storage . The backup server also stores the current metadata from metadata server used in the incremental backup operation. As a result of the incremental backup operation only the data of a volume that has changed since a previous backup operation is backed up again. This provides a number of advantages including increasing the efficiency of the data backup procedure and decreasing the overall amount of data being transferred during the backup procedure. Further any number of incremental backup operations may be performed during which the current metadata from metadata server may be compared to previously stored metadata on backup server e.g. the stored metadata from a prior backup operation .

Backup servers may also provide an application programming interface API in order to allow clients or traditional data backup software to interface with the backup systems described herein. For example the API may allow backup servers to send statistics related to backed up data and backup operations to and from clients or traditional backup software. As another example the API may allow backup servers to receive a request to initiate a backup operation. The API can also allow for backup operations to be scheduled as desired by clients or as controlled by data backup software. Other API functionality is also envisioned.

Referring to a hash tree is shown in accordance with an illustrative implementation. The hash tree may be a hash tree that is provided by a metadata server to a backup server in an initial or incremental backup operation as discussed above. Although depicted as a binary hash tree hash tree and hash trees described herein may have any number of child nodes branches. Hash tree represents the data of a particular volume and can be provided along with additional metadata describing details related to the tree structure. For example the metadata may include statistics regarding node counts leaf node counts tree depth indexes to sub trees etc. Backup server may store the additional metadata for future use. Hash tree includes leaves internal nodes and root node . Leaves store block identifies B B respectively. In an implementation leaves may be structured as an ordered list that is indexed by its parent nodes which in this example are internal nodes . Block identifiers B B are identifiers as described herein e.g. a hash of the corresponding data block s content and each uniquely identify a particular data block of the volume. Hash tree further includes non leaf internal nodes and non leaf root node . The value stored by each non leaf node is the hash of that node s children values. For example hash H is the hash of block identifiers B and B hash H is the hash of block identifiers B and B and hash H is the hash of hashes H and H. During an initial backup operation backup server can walk the tree or traverse the ordered list of leaves to determine that the data blocks corresponding to block identifiers B B should be retrieved to be backed up. A copy of hash tree and any accompanying metadata is stored by backup server when a backup operation is performed.

Referring to the hash tree of is shown at a later time instance as hash tree . For example hash tree may have been provided by metadata server during an initial backup operation and stored by the backup server and hash tree may have been provided by metadata server during a subsequent incremental backup operation. Both hash trees represent the data stored on a particular volume. As depicted the block identifier B of leaf node has changed to become block identifier B at some time since the previous backup. For example new or updated data may have been written to the block referenced by block identifier B. Because of the structure of the hash tree the change of block identifier from B to B causes updates in hashes to propagate upward through the parent node to the root node. Specifically hash H is recalculated to become H and hash H is recalculated to become to H . During a backup operation backup server may walk the hash tree and compare the nodes of hash tree to corresponding nodes of hash tree . A difference between corresponding non leaf node hashes indicates that a block identifier and therefore block data below that non leaf node has changed. If the hashes of corresponding non leaf nodes are equal this indicates that the block identifiers below that non leaf node have not changed and therefore corresponding block data has also not changed . Thus the subtree of nodes below an unchanged non leaf node can be skipped from further processing. In this manner a performance increase may be realized as the entire hash tree does not need to be traversed in every backup operation. As an example with reference to backup server may compare hash tree to hash tree as follows although analysis performed by backup server is not limited to the following operations or order of operations 

After performing the above sample analysis backup server may proceed to retrieve the data based on the block identifier s that indicate data has changed and has not yet been backed up. In this example backup server may send a request to a metadata server for the data block identified by block identifier B . Upon receipt of the data block backup server stores the data block as a backup and stores hash tree along with any accompanying metadata for use in future backup and or restoration operations.

In one implementation using trees backup server may retrieve the metadata from a metadata server by requesting only child nodes whose parent node has changed. For example starting with the root if the root node has changed the children of the root node can then be requested. These nodes can then be compared to corresponding nodes in the previously stored tree to determine if those have changed. Children of any node that has changed can then be retrieved. This process can be repeated until leaf nodes are retrieved. For example with reference to hash tree may be the current metadata from metadata server and hash tree may be stored metadata from a previous backup operation. Backup server may first retrieve root node and analyze it to determine that hash H is different from its previous value of H. In response backup server may then request nodes from interior node level . Node is analyzed to determine that hash H has not changed and leaf nodes may be skipped from further requests analysis. Node is analyzed to determine that hash H is different from its previous value of H and thus backup server may proceed to request appropriate nodes of leaf level leaves . Analysis may then continue as described above to determine that block identifier B is different from its previous value of B and that the data block corresponding to block identifier B needs to be backed up. This implementation may allow for performance increases by minimizing data that is transmitted between backup server and metadata server during the retrieval of metadata.

At some point it may be desirable by clients or an administrator of system to increase the volume size assigned to a client by adding more data blocks of storage space. In this situation with backup servers implementations configured to utilize metadata of an ordered list of block identifiers any newly added block identifiers corresponding to the new data blocks may be appended to the end of the ordered list. Thus during a backup operation if a backup server receives metadata of an ordered list that has more elements than that of metadata from a prior backup operation backup server can determine the newly added data blocks that must be backed up based on the additional list elements. The backup operation may proceed as described above with respect to the remaining elements.

At some point it may be desirable by clients or an administrator of system to reduce the volume size assigned to a client by removing data blocks of storage space. In this situation with backup server implementations configured to utilize metadata of an ordered list of block identifiers any removed block identifiers corresponding to removed data blocks may be removed from the end of the ordered list. Thus during a backup operation if a backup server receives metadata of an ordered list that has fewer elements than that of metadata from a prior backup operation backup server can determine the backed up data blocks that may be removed based on the additional list elements in the stored list from the prior backup. The backup operation may proceed as described above with respect to the remaining elements. With backup server implementations configured to utilize metadata of a hash tree including leaves that are a list of block identifiers the backup server may compare the trees e.g. depth of the trees leaf node count etc. to determine that there has been a change in volume size. In another implementation the size of the volume can be part of the metadata received by the backup servers and this metadata can be compared to a previously received volume size to determine that a change in volume has occurred. The backup server may then determine the position of the current tree within the stored hash tree. After locating the position of the current root node the leaf nodes and corresponding parent nodes that are not within the subtree of the current root node can be ignored. Once the corresponding root nodes have been determined the backup operation may then proceed as described above with respect to the remaining nodes.

In another embodiment the retrieval of the metadata and the comparison of the metadata to other metadata is performed by a device other than the backup server e.g. by one or more devices of the storage system . For example a storage device remote from the backup server may access metadata on the storage device or may retrieve the metadata from another device for example from the metadata server. The storage device may analyze the metadata to determine changes in block identifiers as discussed above. Based on any changed block identifiers found during the analysis an incremental backup can be created by transferring data to the backup server. For example based on the identifiers of the changed data blocks the storage device may transfer only the changed data blocks to the backup server to be backed up. The backup server may store received data blocks as described herein. The metadata used for the incremental backup can be stored by the storage device or can be transferred to another device e.g. the metadata server to be stored for future use.

One or more flow diagrams have been used herein. The use of flow diagrams is not meant to be limiting with respect to the order of operations performed. The herein described subject matter sometimes illustrates different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality and any two components capable of being so associated can also be viewed as being operably couplable to each other to achieve the desired functionality. Specific examples of operably couplable include but are not limited to physically mateable and or physically interacting components and or wirelessly interactable and or wirelessly interacting components and or logically interacting and or logically interactable components.

With respect to the use of substantially any plural and or singular terms herein those having skill in the art can translate from the plural to the singular and or from the singular to the plural as is appropriate to the context and or application. The various singular plural permutations may be expressly set forth herein for sake of clarity.

It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations . Furthermore in those instances where a convention analogous to at least one of A B and C etc. is used in general such a construction is intended in the sense one having skill in the art would understand the convention e.g. a system having at least one of A B and C would include but not be limited to systems that have A alone B alone C alone A and B together A and C together B and C together and or A B and C together etc. . In those instances where a convention analogous to at least one of A B or C etc. is used in general such a construction is intended in the sense one having skill in the art would understand the convention e.g. a system having at least one of A B or C would include but not be limited to systems that have A alone B alone C alone A and B together A and C together B and C together and or A B and C together etc. . It will be further understood by those within the art that virtually any disjunctive word and or phrase presenting two or more alternative terms whether in the description claims or drawings should be understood to contemplate the possibilities of including one of the terms either of the terms or both terms. For example the phrase A or B will be understood to include the possibilities of A or B or A and B. 

The foregoing description of illustrative implementations has been presented for purposes of illustration and of description. It is not intended to be exhaustive or limiting with respect to the precise form disclosed and modifications and variations are possible in light of the above teachings or may be acquired from practice of the disclosed implementations. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents.

