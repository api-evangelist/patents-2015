---

title: Automated generation of transformation chain compatible class
abstract: Automatically generating a software class that is compatible with a transformation chain class library. Such may be used to further populate the transformation chain class library with additional classes of software that was not originally generated as a transformation chain. In response to receiving a software representation, a dependency is identified in the software representation. It is then determined that the dependency corresponds to a dependency element of a transformation chain class of the transformation class library. Then, a software class is generated that corresponds to the software representation and that includes a dependency element that corresponds to the identified dependency, and that is recognized by a merging module as being compatible with the dependent element of the transformation chain class of the transformation chain class library. The software class may then be added to the transformation chain class library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09658836&OS=09658836&RS=09658836
owner: Microsoft Technology Licensing, LLC
number: 09658836
owner_city: Redmond
owner_country: US
publication_date: 20150702
---
Computing technology has revolutionized the way we work play and communicate. Computing functional is obtained by a device or system executing software or firmware. The typical paradigm for application preparation is that the application is drafted well in advance of its use and the functionality of the patent application is relatively predetermined.

There are some exceptions to the predetermined functionality. For instance patches may be made to software application in order to provide repair of previously unknown bugs in the software. Furthermore updates to software applications may be provided in order to add new functionality to the software application. In some cases software may be configured and customized for a particular user. However the application itself defines how far it can be customized. Users can also affect applications by providing commercial feedback on software performance. However it can take years before user feedback is properly incorporated into an application.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.

At least some embodiments described herein relate to mechanisms for automatically generating a software class that is compatible with a transformation chain class library. Such may be used to further populate the transformation chain class library with additional classes of software that was not originally generated as a transformation chain.

In response to receiving a software representation one or more dependencies are identified in the software representation. For each of at least one of the one or more dependencies it is then determined that the dependency corresponds to at least one dependency element of at least one transformation chain class of the transformation class library. Then a software class is generated that corresponds to the software representation and that includes a dependency element that corresponds to the identified dependency and that is recognized by a merging module. In other words the dependency element is structured to be interpretable by a merging module as being compatible with the at least one corresponding dependent element of the at least one transformation chain class of the transformation chain class library. The software class may then be added to the transformation chain class library.

This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

At least some embodiments described herein relate to mechanisms for automatically generating a software class that is compatible with a transformation chain class library. Such may be used to further populate the transformation chain class library with additional classes of software that was not originally generated as a transformation chain.

In response to receiving a software representation one or more dependencies are identified in the software representation. For each of at least one of the one or more dependencies it is then determined that the dependency corresponds to at least one dependency element of at least one transformation chain class of the transformation class library. Then a software class is generated that corresponds to the software representation and that includes a dependency element that corresponds to the identified dependency and that is recognized by a merging module. In other words the dependency element is structured to be interpretable by a merging module as being compatible with the at least one corresponding dependent element of the at least one transformation chain class of the transformation chain class library. The software class may then be added to the transformation chain class library.

First the concept of transformation chains will be described with respect to . Then an architecture for supporting a universe of transformation chains and their operation will be described with respect to . Thereafter an example operation of transformation chains will be described with respect to . Because transformation chain based applications represent a paradigm shift this description will go into significant detail on potential operations of the transformation chain based applications. The automatic generation of new classes to add to a library of transformation chain classes will then be described with respect to . Thereafter an example computing system that may support aspects described herein will be described with respect to .

The principles described herein operate using a transformation chain. A transformation chain is an interconnected set of nodes that each may represent data sources and or data targets. There are links between the nodes each link representing a transformation. For any given link the associated transformation receives copies of values of one or more data sources situated at an input end to the link and generates and provides resulting values at one or more data targets located at the output end of the link. For any given transformation when a value at one or more of the data sources at its input end changes the transformation is automatically reevaluated potentially resulting in changes in value s of one or more data targets at the output end of the transformation.

In one embodiment regardless of how complex the transformation chain is the transformations may be constructed from declarative statements expressing equations rules constraints simulations or any other transformation type that may receive one or more values as input and provide resulting one or more values as output. An example of a transformation chain is a spreadsheet program where any of the cells can be a data source or a data target. An equation i.e. a transformation may be associated with any cell to cause that cell to be a data target where results of the equation are placed.

As an example only illustrates a simple transformation chain in which there is but a single link . In the drawing notation used throughout this description a link will be illustrated as an arrow with the input end being represented as the tail of the arrow and the output end being represented as the head of the arrow. In cases in which there are multiple data sources at the input end of the link the arrow will be represented with multiple tails. Copies of the values of the data source s at the tail s of the arrow represent input to the transformation. In cases in which there are multiple data targets affected by resulting value s of the transformation the arrow will be represented with multiple heads. The values of the data target s at the head s of the arrow represent output from the transformation.

For instance illustrates a simple transformation chain that includes a data source a data target and a single link . The link represents a transformation performed on a copy of the value at the data source in order to generate a value at the data target . Should the value change the transformation represented by link is automatically reevaluated potentially resulting in a change in the value in the data target .

While the example transformation chain includes just two links transformation chains may be quite complex and involve enumerable nodes and associated links connecting those enumerable nodes. The principles described herein may operate regardless of the complexity of the transformation chains.

The example transformation chains A through D are relatively simple in order to avoid obscuring the broader principles described herein with an overly complex example. That said the principles described herein apply regardless of how complex the transformation chain and regardless of the number of transformation chains and associated devices that are within the environment and forming the compound application.

In the notation of the nodes that belong to the transformation class N where N ranges from A through D are represented using the suffix N. For instance in the transformation chain A includes nodes A A A and A. The remaining elements B C and D do not end with the A suffix and thus are not nodes within the transformation chain A. Instead the elements B C and D represent dependencies with other transformation chains.

Throughout to emphasize those elements that are dependency elements rather than nodes in the transformation chain itself dependency elements are represented with dashed lined boundaries. Data does not flow from a node to a dependency element unless the transformation chain is joined with another transformation chain that includes a node represented by the dependency element. The fact that data cannot flow along a particular transformation is represented throughout the figures by the link being marked with an X .

For instance element B in transformation chain A represents a dependency with node B in the transformation chain B. The dependency element B is bordered with dashed lines and all links leading to or from that dependency element B are marked with an X since at this stage the transformation chain A is not joined with the transformation chain B. Element C in transformation chain A represents a dependency with node C in transformation chain C. Element D in transformation chain A represents a dependency with node D in transformation chain class D.

On its own the transformation chain instance A can function as an application. For example a copy of a value or copies of values from data source A may be used to form a transformed result as a value or values of data target A. Furthermore a copy of a value or copies of values from data sources A and A may be transformed to result in a value or values of data target A. If the transformation chain instance A is on its own the transformations leading to and from the elements B C and D are not evaluated.

The transformation chain B includes three nodes B B and B. However the transformation chain B also includes dependency elements A A C and C that reference a node in a different transformation chain. Again the transformation chain instance B may operate independently as a single application. For example a copy of a value or copies of values from data source B may be provided through a transformation to generate a resulting value or values for data target B. A copy of a value or copies of values from the data source B may be provided through a transformation to generate a resulting value or values for data target B.

Though the transformation chain instances A and B may operate independently illustrates a joined transformation chain A that includes transformation chain A joined with transformation chain B. Where appropriate dependency elements in each of the transformation chains are now replaced with the actual node referred to. For example dependency element B of is now node B in and dependency elements A and A of are now nodes A and A respectively in . Thus all of the nodes that have the suffix A or B are nodes within the transformation chain A and only those nodes that have suffixes C or D are dependency elements. For example nodes A A A A B B and B are nodes within the augmented transformation chain A and the functionality of the compound application becomes somewhat better more complete or at least different than the sum of the functionality of the individual transformation chains A and B on their own.

The transformation chain C includes three nodes C C and C. However the transformation chain C also includes dependency elements A B and B that reference a node in a different transformation chain. Again the transformation chain instance C may operate independently as a single application. For example a copy of a value or copies of values from data source C may be provided through a transformation to generate a resulting value or values for data target C. Likewise a copy of a value or copies of values from the data source C may also be provided through a transformation to generate a resulting value or values for data target C.

Though transformation chain instances A and C may operate independently illustrates a joined transformation chain B that includes transformation chain A joined with transformation chain C. Dependency elements in each of the transformation chains are now replaced with the actual node referred to the extent that the dependency element refers to a node within any of transformation chains A or C. Now all of the nodes that have the suffix A or C are nodes within the transformation chain and only those nodes that have suffixes B or D are dependency elements. For example nodes A A A A C C and C are nodes within the augmented transformation chain B. The functionality of the compound application becomes better more complex or at least different than the sum of the functionalities of the individual transformation chain instances A and C.

The transformation chain D includes two nodes D and D. However the transformation chain D also includes a single dependency element A referencing a node in a different transformation chain class A. Again instances of the transformation chain class D may operate independently as a single application. For instance a copy of a value or copies of values from data source D may be provided through a transformation to generate a resulting value or values for data target D.

Though transformation chain instances A and D may operate independently illustrates a joined transformation chain D that includes transformation chain A joined with transformation chain D. Dependency elements in each of the transformation chains are now replaced with the actual node referred to the extent that the dependency element refers to a node within any of transformation chains A or D. Now all of the nodes that have the suffix A or D are nodes within the transformation chain and only those nodes that have suffixes B or C are dependency elements. For instance nodes A A A A D and D are nodes within the augmented transformation chain D and the functionality of the compound application becomes somewhat better than the sum of the functionality of the individual transformation chain A and D.

Note that illustrate all of the possible permutations involving two and only two of the transformation chains A B C and D. The transformation chains B and D are not joined directly in a two transformation chain combination since neither transformation chain has a dependency element referring to a node in the other transformation chain. Furthermore transformation C and D are not joined directly in a two transformation chain combination since neither has a dependency reference to the other.

Accordingly given the transformation chains A B C and D in the environment there are 8 possible compound applications that may be formed corresponding to the transformation chains of and . Thus as the transformation chains of various devices are joined into and decoupled from the environment the very transformation chain itself changes and the structure of the compound application thereby changes. For instance a change in the value of data source A might have a very different impact on the transformation chain as the effects of that change are automatically propagated through one or more transformations depending on whether that data source A is within transformation chain A alone within transformation chain A within transformation chain B within transformation chain D within transformation chain A within transformation chain B within transformation chain C or within transformation chain .

Any of the nodes of a transformation chain may have zero or more input endpoints where inputs are received from an endpoint interface entity and zero or more output endpoints where outputs are provided to an endpoint interface entity. In this description and in the claims an endpoint interface entity is defined as a hardware entity and zero of more environmental criteria. In the case of there being zero environmental criteria associated with an endpoint interface entity the endpoint interface is simply a hardware entity such as a device or computing system . In the description and in the claims a hardware entity refers to any single or combination of physical items that have the capability to potentially interface with an endpoint. For instance a hardware entity that provides input or receives input might be a data store or a location in a data store a user device a microphone or microphone array a camera or camera array three dimensional sensors image recognizers or the like. If the hardware entity and corresponding one or more environmental criteria together define an endpoint interface entity then the hardware entity is indeed the endpoint interface entity so long as the environmental criteria are satisfied. However if the environmental criteria cease to be satisfied then the hardware entity would lose its status as an endpoint interface entity.

In this description the terms endpoint interface entity and hardware entity may frequently be used interchangeably on the assumption that if the endpoint interface entity does have environmental criteria that those criteria remain satisfied in that case. Furthermore when the term environmental criteria is mentioned with respect to a hardware entity or an endpoint interface entity the environmental criteria for the hardware entity becoming the endpoint interface entity may be different than the environment criteria for the hardware entity ceasing to be the endpoint interface entity. Thus there may be some hysteresis built into the environmental criteria to avoid rapid changes in whether or not a particular hardware entity qualifies as a particular endpoint interface entity.

Examples of environmental criteria will now be provided with the understanding that the principles described herein are not limited to any particular environment criteria. One environmental criterion might be that the hardware entity has an associated identified user or identified group of users. For instance if a given user or group of users is using a hardware entity then the hardware entity may become an endpoint interface entity. If another user or group of users is using the hardware entity then perhaps the hardware entity does not act as an endpoint interface entity. Other examples of environmental criteria might include the position vantage point or orientation of a user or group of users within an environment and or with respect to a hardware entity the position of an audio source in the environment background noise levels whether an audio signature is present whether a security zone surrounding the environment has been violated whether an individual has fallen in the environment the temperature of the environment the available network connections in the environment a lighting level and or configuration a time of day or week or month or year and so on for any imaginable environmental criteria.

As an example a mounted flat panel display having multiple viewers oriented to be able to see the flat panel display might be an appropriate endpoint interface device but if there is but a single viewer and the node has input endpoints perhaps a touchscreen device in the hands of the single viewer might be the better endpoint interface device for a given endpoint. As a second example suppose that there was output was being displayed on a television and a security system is activated the activation of the security system might be an environmental criteria that causes some or all of the information displayed on the television to be obscured or perhaps even cause the television to stop being an endpoint interface entity and thus disconnect from the application.

The general concept of the transformation chains has been described with respect to with respect to specific examples of transformation chains that have particular nodes and particular dependency elements. However the principles described herein apply to any transformation chain having any number of nodes and any number of dependency elements regardless of the function of the node and identity of the dependency element. Accordingly the principles described herein may be applied to a limitless variety of transformation chains performing a limitless variety of functions. One or more endpoint interface entities have credentials to interface with the endpoints of a transformation chain instance or portions thereof. Such credentials may include credentials to provide input to some or all of the endpoints of one or more or all nodes of a transformation chain instance credentials to receive output from some or all of the endpoints of one or more or all nodes of a transformation chain instance or even the power to delegate credentialed power to one or more delegate endpoint interface entities.

In accordance with the principles described herein an architecture is described in which transformation chains may be combined incrementally forming dynamically changing functions at runtime thereby changing the concept of what an application is. With the benefit of reading this description transformation chains are like molecules floating within an environment and with the proper impetus such molecules combine resulting in a compound that operates differently from its constituent parts. For instance given the right impetus two hydrogen molecules may combine with an oxygen atom to formulate a molecule of water. While liquid hydrogen and liquid oxygen cannot be consumed by humans liquid water can and must be consumed by human beings. Thus the principles described herein allow molecules of transformation chains to be joined dynamically and incrementally to formulate customized applications that provide customized functionality that is suitable to the impetus experienced. Such applications may be so customized that there may be times that a particular application is only constructed once.

The principles described herein also allow a delegator endpoint interface entity to delegate power to another delegate endpoint interface entity to interface with certain endpoints without the delegator endpoint interface entity giving up control of how the delegate endpoint interface affects the transformation chain instance. Accordingly the principles described herein also allow a transformation chain to be safely split.

Through atomic and molecular composition a seemingly infinite variety of animate and inanimate objects and entire worlds have formed. Currently there are only 115 known elements in the periodic table of the elements from which an infinite variety of animate and inanimate objects throughout the universe are composed. Using only a limited number of transformation chains that may be combined in certain ways there is a substantially limitless variety of applications of a substantially limitless variety of functions that may be generated in a universe of possible applications. Accordingly the principles described herein describe a new organic paradigm in incrementally building application and sharing split applications to suit the very present circumstances. Furthermore the principles described herein allow for the careful tracking of credentials of which endpoint interface entity may interact with which endpoint of which nodes of which transformation chains and allows for temporary or even permanent delegation of such credentials to other endpoint interface entities. Accordingly a wide variety of collaboration scenarios are enabled in such an organic application environment.

The runtime architecture also includes a supporting architecture that includes modules and components that operate outside of the observable universal canvas to ensure the appropriate formation combination sharing operation and extinguishing of the transformation chain instances. The supporting architecture itself can receive input and provide output at represented by bi directional arrow . The supporting architecture may also provide access to services as represented by bi directional arrow . The supporting architecture also interacts with the universal canvas as represented by the bi directional arrow for purposes of instantiating transformation chains combining transformation chain instances altering transformation chain instances enforcing credentialed use of the transformation chain instances by appropriate endpoint interface entities extinguishing transformation chain instances and the like.

The precise physical platform on which the universal canvas is run is not critical. In fact there can be great flexibility and dynamic change in the physical platform on which the universal canvas is operated. Some nodes of some transformation chains may be operated by one physical platform such as a device endpoint interface entity system or cloud while other nodes operate another physical platform . In one embodiment the universal canvas operates in a cloud computing environment such as a private cloud a hybrid cloud or a public cloud. As an example the universal campus may be within a local network in a peer to peer computing network in a cloud computing environment in any other network configuration or in any combination of the above. Even so as previously mentioned the universal canvas interfaces with the physical world through the endpoints of the various nodes of the transformation chain instances.

Likewise the supporting architecture may be operated in any computing environment in peer to peer computing network in a local network any other network configuration or in any combination of these. In the case where the transformation chain instances within the universal campus operate fully or primarily or even party in a cloud computing environment it may be this same cloud computing environment that operates the supporting architecture.

In this description and the following claims cloud computing is defined as a model for enabling on demand network access to a shared pool of configurable computing resources e.g. networks servers storage applications and services . The definition of cloud computing is not limited to any of the other numerous advantages that can be obtained from such a model when properly deployed.

For instance cloud computing is currently employed in the marketplace so as to offer ubiquitous and convenient on demand access to the shared pool of configurable computing resources. Furthermore the shared pool of configurable computing resources can be rapidly provisioned via virtualization and released with low management effort or service provider interaction and then scaled accordingly.

A cloud computing model can be composed of various characteristics such as on demand self service broad network access resource pooling rapid elasticity measured service and so forth. A cloud computing model may also come in the form of various service models such as for example Software as a Service SaaS Platform as a Service PaaS and Infrastructure as a Service IaaS . The cloud computing model may also be deployed using different deployment models such as private cloud community cloud public cloud hybrid cloud and so forth. In this description and in the claims a cloud computing environment is an environment in which cloud computing is employed.

The supporting environment includes a number of modules . One of the modules is a summoning module that interprets input and in response determines that a class of a transformation chain is to be instantiated. For instance the input may be received directly from input from arrow to the supporting environment or via input from a transformation chain instance running in the universal canvas itself. Input that may be received from either source will be referred to herein as general input . Summoning criteria are used for recognizing that certain general input is to result in a transformation chain instance being created. Summoning criteria may be also any environmental criteria at all. For instance the summoning criteria may take into account not just verbal conversations or explicit user input directed at a hardware entity but may also take into consideration other environmental factors. For instance whether a particular user is sitting down moving away looking somewhere being near a device with a touch screen and so forth may also be environmental criteria used as summoning criteria for summoning an instance of a transformation chain class to be created within the universal canvas .

The modules also includes a chain class module that instantiates transformation chain instances in response to determinations made by the summoning module and or in response to general input.

The modules also includes a chain class maintenance module that maintains a copy of each transformation chain class. The chain class maintenance module may add to the library of available transformation chain classes in response to a determination made by the summonsing module and or in response to general input. Thus the chain class maintenance module may maintain a registry of transformation chain classes. For instance the chain class maintenance module might merge classes along their appropriate points of dependency or perhaps create a transformation chain class that represents a redacted or truncated version of a pre existing transformation chain class. Some transformation chain classes may be created temporarily whilst others may have more lasting persistence. Furthermore authentication and authorization may be imposed so as to restrict which entities may instantiate transformation chains of certain classes.

A merging module merges instances of transformation chains to be operated in the universal canvas in an appropriate way given the dependencies of the transformation chains. Such merging occurs in response to determinations made by the summoning module and or in response to other general input. The merging criteria may also be any general environment criteria. Again the merging criteria may take into account not just verbal conversations or explicit user input directed at a hardware entity but may also take into consideration other environmental factors that are deemed appropriate for the merging to occur.

An endpoint interface entity registry module maintains a registry of all possible endpoint interface entities hardware entities and potentially associated user criteria as well as which endpoint interface entities are presently active and available given a particular instantiated transformation chain operating within the universal canvas .

An environmental module detects when endpoint interface entities become active or inactive for a given instantiated transformation chain operating within the universal canvas . For instance the environmental module might detect when an initiating set of environment criteria for a hardware entity of a particular endpoint interface entity begin to be met resulting in the endpoint interface entity being available for the application for interacting with the endpoints of the application . Likewise the environment module might detect when a terminating set of one or more environmental criteria for the hardware entity of the particular entity is met resulting in the endpoint interface entity no longer being available for the application.

An endpoint matching module determines which active endpoint interface entities for an instantiated transformation chain are capable of and credentialed to provide input for each input endpoint of that transformation chain that is capable of receiving input from the physical world and determining a proper form of the input given that endpoint interface entity. The endpoint matching module also determines which active endpoint interface entities for an instantiated transformation chain are capable of and credentialed to receive output for each output endpoint of the transformation chain that is capable of presenting output into the physical world.

The modules includes a presentation module that when there are multiple eligible endpoint interface entities that are capable of providing input into an input endpoint decides which endpoint interface entity is to provide that input and potentially decides that multiple endpoint interface entities are capable of providing input into that input endpoint. Furthermore when there are multiple eligible endpoint interface entities that are capable of rendering output from an output endpoint the presentation module decides which endpoint interface entity is to provide that input and potentially decides which of multiple endpoint interface entities are to render the output received from the output endpoint.

The presentation module also decides whether any restrictions are to be imposed when a particular endpoint interface module provides input to an input endpoint of a transformation chain. The presentation module may also decide whether there are any restrictions that are to be imposed when a particular endpoint interface module renders output from an output endpoint of a transformation chain. When that output is visualizations the presentation module may decide how visualized information is to be formatted and or laid out on the display of the endpoint interface entity.

The modules also includes a delegation module that allows and facilitates credentialed endpoint interface entity to delegate power to a delegee endpoint interface entity with respect to receiving output from or providing input to particular endpoints of a transformation chain instance. As such delegation module facilitates splitting of transformation chain application thereby allowing dynamic movement into and out of collaborative scenarios. There may be other modules within the modules as represented by the ellipses .

The modules includes a compatibility module that functions to automatically generate software classes that are compatible with the transformation chain class library as will be described below with respect to . There may be other modules within the modules as represented by the ellipses .

Having now described transformation chain applications and an architecture that facilitates operation of transformation chain applications with respect to example operations of the transformation chains and the supporting architecture will now be described with respect to . First the dynamic building of transformation chain instances will be described.

The dynamic building of transformation chain instances will now be described. In accordance with the principles described herein transformation chains may be combined incrementally and with ease of effort forming dynamically changing functions at runtime. Transformation chains are like molecules floating within an environment and with the proper impetus such molecules combine resulting in a compound that operates differently from its constituent parts. Thus the principles described herein allow instances of transformation chains to be joined dynamically and incrementally to formulate customized applications that provide customized functionality that is suitable to the impetus experienced.

As a concrete example suppose that there is a transformation chain that extracts received orders from a database. A verbal command to show me my orders by a sales representative might instantiate that transformation chain class filter by the user that stated the verbal command and visualize the filtered list or orders. A subsequent join instruction might be Fetch me my customers which might then cause another transformation chain to automatically join with the prior transformation chain to match customers with orders and visualize the orders by customers. The user might then state add order exceptions for customers causing perhaps yet another transformation chain to join the existing transformation chain aggregation and or cause input to be made to an existing node of the current aggregation of transformation chains. At each stage the user may determine based on the current state of the aggregated transformation chain what is lacking and state or input further joining instructions from which yet other transformation chains may be join in the growing customized application chain. In essence the application is built as the user thinks and expresses intuitively what he or she wants and the application is built in a manner that is sensitive to the environment.

Responsive to the detected environment event s the transformation class corresponding to the input is selected act . For instance the summoning module or the chain class module may select which of the available transformation chain classes maintained by the chain class maintenance module corresponds to the detected environmental event s .

An instance of the transformation chain class is then created act . For instance the chain class module might instantiate an instance of the identified transformation chain class. When instantiating the transformation chain class the endpoint interface entity matching module may provide appropriate credentials to one or more appropriate endpoint interface entities so that such entities are credentialed to receive output from and or provide input to one or more endpoints of the transformation chain instance.

Optionally the instance may then be operated act . For instance in the instance of the transformation chain class may be deployed and operated within the universal canvas .

As part of this operation act the environmental module detects which of the registered endpoint interface entities are active for the given instantiated transformation chain. Furthermore the endpoint interface entity matching module determines which active endpoint interface entity endpoints for the instantiated transformation chain should provide input for each endpoint of each node of the transformation chain that is capable of receiving input from the physical world and what forms of input are acceptable. Furthermore the endpoint interface entity matching module determines which active endpoint interface entities for the instantiated transformation chain should receive output for each output endpoint of each node of the transformation chain that is capable of realizing e.g. visualizing rendering sounding storing actuating and the like output into the physical world and what forms of output are acceptable.

At some point further environmental event s are detected such as user input which directs that an instance of another transformation chain class is to be combined with an existing transformation chain instance. Accordingly illustrates a flowchart of a method for responding to further detected environment event s to thereby combine transformation chain instances. The method is initiated by detecting further environmental event s act that is constituent with combination of two instances of transformation classes.

As an example a transformation chain instance may be combined with the instance created in method or perhaps may be combined with an instance of a transformation chain created by a previous performance of the method of . Although not required the instance to which the transformation chain instance is to be joined may have previously operated as an application already. Thus the method may be repeatedly performed in order to build a sophisticated and customized transformation chain in response to various detected environmental events.

The detected environment events of act may be an expressed instruction to join. For instance the user might have a user interface that allows explicit selection of a desired application chain class to be instantiated. Alternatively the detected environment events of act may simply be an implicit indication that two transformation chain instances should be joined. For instance the detected environment events might be any activity such as particular speech that is consistent with the joining of two instances of different transformation chain classes. Such input could include gestures requests and the like. For instance as previously mentioned a sales representative might state fetch me my customers in the context of the representatives corresponding orders already being visualized. The system may even guess at what transformation chain the user might want based on history and current context. In that case the user establishing the current context could be the environmental event s that cause the new transformation chain to be instantiated that the system guesses may be desired at some future point. For instance perhaps the system knows that when in a particular conversation the users keep talking about a particular order the system might join transformation chain instances used to acquire that order in anticipation of showing that order. Whatever form the joining environment event s takes the summoning module of detects appropriate environmental event s that corresponds to the instantiation of a transformation chain class as described with respect to or the joining of two transformation instances as will be described with respect to .

The method then includes determining from the further detected environmental event s that an instance of one transformation chain class is to be joined with an instance of another transformation chain class act . For instance as described above there are class level restrictions in which the transformation chain class author expressly makes it possible at least under some conditions for instances of two transformation chain classes to be joined. For instance the dependency elements of are an example of such class level restrictions and authorizations.

However there may also be instance level authorization. As an example the act may involve consulting a set of one or more rules defining one or more conditions for joining an instance of the first transformation chain class and the second transformation chain class. This set of rules may be dynamic and change over time. For instance the joining logic may learn over time that certain gestures or other user activity is or is not indicative of a user intent or anticipated future user intent to combine such instances. Accordingly the supporting architecture may observe a history associated with each of multiple users in order to over time more accurately predict user intention depending on a history of a particular user or group of users and thereby formulate an appropriate set of summoning and merging criteria. The act may be performed by for instance by the chain class module with reference to the transformation chain classes known to the class maintenance module . The endpoint interface entity matching module may reevaluate which endpoint interface entities have credentials to interface with which endpoints of the composite aggregated transformation chain instance.

The author of a transformation chain class might also express restrictions at the granularity of a single dependency. For instance in the dependence element B of transformation chain class A the author might express that joining is authorized on that dependency element only if the transformation chain into which it is joined does not include an identified transformation chain class authored by a competitor. The author might also control data that is flowed out of the transformation chain to another joined transformation chain by writing restrictions or conditions into the transformation that would bridge the dependency itself e.g. between nodes A and dependency element B .

However even though transformation chain classes may interoperate that does not mean that the user wants their particular instance of that transformation chain class to join with other instances of other transformation chain classes. After all the data itself e.g. the instance state might be sensitive to the user. Accordingly the method also may include determining that instances of different transformation chain classes are to be joined.

The joining criteria for authorizing two instance of different transformation chain classes to join may include one or more of the following whether or not the user is on a meeting attendee list a relationship e.g. family social network friend or the like of users of the various devices a communication capability e.g. near field between the devices a proximity of the respective devices e.g. in the same conference room the request of the users of the like. For instance the joining criteria might include some business criteria such as the associated users of the instances are on the same team. As another example one device might be a kiosk in a retail space or hotel where a customer uses the kiosk and a shop assistant or concierge can automatically use their device to join their transformation chain with that of the kiosk to thereby interact with the customer using the compound application. Conditions may be applied to the joining criteria. For instance a bellhop s device might be able to join a customer s application if the concierge is not around perhaps detected by the concierge not actively using the pairable application to join with that of customers or being off network .

In some embodiments the first transformation chain class used to instantiate the first of the two instances to be joined may be derived from an existing transformation chain class. As an example the first transformation chain class may be the same as the first transformation chain class except with one or more nodes of the transformation chain removed.

In response to the act of determining that the two instances are to be joined act the two instances are joined act so as to establish connections across one or more flow dependencies of the instance thereby creating new avenues for data flow and new application functionality. For instance this joining may be accomplished by the merging module . The joined instance may thereafter be operated act .

In one embodiment the instances themselves are directed joined without defining any new combined transformation chain classes. For instance illustrates a flowchart of a method A for joining two instances and represents an example of the act of . The first instance of the first transformation chain class is instantiated act A and perhaps operated act . Furthermore the second instance of the second transformation chain class is instantiated act A and perhaps operated act . Thereafter the two instances are joined act A .

In other embodiments the transformation chain classes themselves are aggregated to define a new combined class and an instance of that aggregated class is instantiated to thereby accomplish act . The combined instance may exist temporarily may be kept for the benefit of a limited number of one or more users or may even be added to the library of transformation chain classes that are available for more widespread use. For instance illustrates a flowchart of a method B that represents another example of the act of . The first transformation chain class is accessed act B and the second transformation chain class is accessed act B . The two classes are then combined act B . An instance is then created from the combined transformation chain class act .

As an example only perhaps method or act A of method A might be employed to create an instance of a transformation chain of . Now suppose that environmental event s are detected that suggest combination of instances of transformation chains of . Method may then be performed to create the instance of the transformation chain of . In that case act A of method would instantiate from the transformation chain class of and act A of method would instantiate from the transformation chain class of . The result may be thought of as an instantiation of the aggregated class of the classes of which is represented in .

Now suppose that environmental event s are detected that suggest combination of instances of transformation chains of . The method may then be performed to create the instance of the transformation chain of . In that case act A of method A would be used to instantiate in which the result from the prior performance of the method to create the transformation chain instance of could be viewed as instantiating from the aggregated classes of an instance of . Furthermore act B of method would be used instantiate from the transformation chain class of . The result may be thought of as an instantiation of the aggregated class of the classes of which is represented in .

Now suppose that environmental events are detected that suggests combination of instances of transformation chains of . The method may then be performed to create the instance of the transformation chain of . In that case act A of method A would be used to instantiate an instance of . Furthermore act B of method would be used instantiate from the transformation chain class of . The result may be thought of as an instantiation of the aggregated class of the classes of which is represented in .

Having now described the general principles of transformation chains the environment in which they may operate and their principles of aggregation this description will now address how a delegator endpoint interface entity having credentials on a transformation chain instance may delegate power to a delegee endpoint interface entity to receive output from particular endpoint s and or provided input to particular endpoint s . Accordingly application splitting and sharing is made possible in this organic universal canvas of transformation chain instances.

As illustrated in the example transformation chain A includes six nodes through . Each of the nodes may have zero or more input endpoints and zero or more output endpoints. However to keep the diagram cleaner the endpoints are not illustrated for the example transformation chain A of . Likewise the endpoints are not illustrated for the example transformation chain B in .

In the initial state A of a particular endpoint interface entity referred to herein as a first endpoint interface entity is credentialed to provide input to and receive output from endpoints of transformation chain A. The scope of this credential is represented by the dashed lined boundary .

Now suppose that the application represented by the transformation chain A is to be split. That is suppose that the first endpoint interface entity provides interaction or input suggesting that a transformation chain instance representing a portion of the larger transformation chain instance A is to be created. There may be several reasons for performing such a split. One reason might be simply because the first endpoint interface entity is to use another instance of just that portion of the larger transformation chain class. Another reason might be to delegate input and or output privileges associated with one some or all of the endpoints of those nodes that are part of the portion to another endpoint interface entity. In other words the first endpoint interface entity assigns the portion of the transformation chain at least temporarily to the second endpoint interface entity. A redaction and share gesture may be used to express this intent to delegate. For instance a user might cross over a certain portion of the user interface indicating that the target endpoint interface entity is not to have the ability to view or input into those fields and then indicate a share gesture.

In any case interaction and or environmental event s are detected that are representative of splitting an instance of a smaller class off of the larger transformation chain class act thereby initiating the method of . Based on the detected environment event s the system determines that a portion transformation chain class is to be created act that represents a portion of the larger transformation chain class. This determination might be made by for instance the delegation module of . For instance referring to suppose that a portion transformation chain class is to be created that is represented only by nodes and . In response an instance of the portion transformation chain class is instantiated act and operated act . For instance the second endpoint interface entity may be instructed by the first endpoint interface entity and or by the delegation module to interact with the endpoints of the instantiated portion transformation chain class. The instantiated portion transformation chain class may be sent to the second endpoint interface entity.

In the embodiment A of the node is illustrated with as a solid circle representing that all endpoints of the node have been instantiated and made available to the second endpoint interface entity. Meanwhile the node is illustrated with a dashed lined circle representing that only a portion of the endpoints of the node have been instantiated and made available to the second endpoint interface entity.

In the embodiment B of the node is illustrated with as a solid circle representing that all endpoints of the node have been instantiated and made available to the second endpoint interface entity. Meanwhile the node is illustrated with a dashed lined circle representing that only a portion of the endpoints of the node have been instantiated and made available to the second endpoint interface entity.

In the embodiment C of the nodes and are both illustrated with a dashed lined circle representing that only a portion of the endpoints of each of the nodes and have been instantiated and made available to the second endpoint interface entity.

In the embodiment D of the nodes and are both illustrated as a solid circuit representing that all of the endpoints of each of the nodes and have been instantiated and made available to the second endpoint interface entity.

Note that there need be no change to the instance of the transformation chain that is in state A from the perspective of the first endpoint interface entity. In that case whatever endpoints are created for nodes and for the second endpoint interface entity may simply be cloned endpoints. During operation if a cloned input endpoint received inconsistent input from both the first endpoint interface entity and the second interface entity merging criteria may resolve the inconsistency. For instance perhaps inconsistencies are resolved in favor of the delegating endpoint interface entity. Merging operations may be provided by for instance the delegation module of .

In an alternative embodiment a remainder instance may be created that represents a logical remainder when the portion instance B is subtracted from the larger instance A and thus no endpoint are cloned at all. For instance in the case of in which the second endpoint interface entity is given access to all endpoints of the nodes and a remainder instance may be created with just the nodes through . In the case of the remainder instance might include nodes through and a limited form of node and with only the endpoints that were not included with the node of the remainder instance being included in the portion instance A. In the case of the remainder instance might include nodes through and a limited form of node with only the endpoints that were not included with the node of the remainder instance being included within the portion instance B. In the case of the remainder instance might include nodes through and a limited form of node and with only the endpoints that were not included with the nodes and of the remainder instance being included within the portion instance B.

In operation the delegation module may allow the first endpoint interface entity to maintain control or supervision over the actions of the second endpoint interface entity in interacting with the portion B of the transformation chain A. For instance the second endpoint interface entity may be credentialed through the first endpoint interface with respect to the portion B such that data flows to and from the instance of the portion transformation class B are approved by and or channeled through the remainder of the transformation chain A controlled by the first endpoint interface entity. Furthermore the access of the second endpoint interface entity to data such as a data service is strictly controlled. Data for nodes that are not within the portion transformation chain class are provided via the approval of the first endpoint interface entity.

The larger transformation chain instance A is similar to the transformation chain A of except that the first endpoint interface entity A may access only a portion of the endpoints of the node now referred to as node A since it now has more limited interfacing capability with the first endpoint interface entity A and node now referred to as node A since it now has more limited interface capability with the first endpoint interface entity A . The ability of the first endpoint interface entity A to interface with the larger transformation chain instance A is represented by bi directional arrow A.

The portion transformation chain instance B is similar to the portion transformation chain B of except that similar to the case of the second endpoint interface entity B may access only a portion of the endpoints of the node now referred to as node B since it now has more limited interfacing capability with the second endpoint interface entity B and node now referred to as node B since it now has more limited interface capability with the second endpoint interface entity B . The ability of the second endpoint interface entity B to interface with the portion transformation chain instance B is represented by bi directional arrow B.

The proxy service provides a point of abstraction whereby the second endpoint interface entity B may not see or interact with the nodes through of the larger transformation chain instance A nor may the second endpoint interface entity B interface with any of the endpoints of the nodes and that are assigned to the first endpoint interface entity A. As an example the proxy service may be established by the delegation module of at the time that a portion of transformation chain instance is assigned to another endpoint interface instances.

The proxy service keeps track of which endpoints on node are assigned to each node A and B and which endpoints on node are assigned to each node A and B. When the proxy service receives input transformations from the larger transformation chain e.g. node the proxy service directs the transformation to each of the nodes A and B as appropriate depending on which values are affected by the input transformations. Furthermore when output transformations are provided by the nodes A and B to the node the proxy service merges the outputs and provides the merged transformations to the node . For the perspective of the node it is as though the node is interacting with node just as the node did prior to application splitting. Accordingly performance and function are preserved while enabling secure application splitting by maintaining appropriate information separation between the first and second endpoint interface entities A and B. Such merging of output transformations and splitting of input transformations are performed by component of the proxy service .

The proxy service may also include a recording module that evaluates inputs and outputs made to endpoints in each of the nodes A B A and B and records such inputs and outputs. The recording module also may record the resulting transformations made between nodes. Such recordings are made into a store . A replay module allows the actions to be replayed. That may be particular useful if the portion transformation chain is assigned to another i.e. a third endpoint interface entity later on and a user of that third endpoint interface entity wants to see what was done. That third endpoint interface may come up to speed with what happened during the tenure of the second endpoint interface entity with the portion transformation chain. Another reason to replay might be to check and approve commit or ratify some action. For instance imagine an order editing scenario where a number of users are seeking to postpone or move back some deliveries. A first user might ask a second user to help with this. However the first user does not want the second user to edit the order in a way that causes permanent side effects e.g. some shipping slot gets released and some now slot gets booked due to a service call . The first user might want to replay what the second user did and if the first user like was she sees then accept and commit the actions taken. Here the replay mechanism additionally simulates the side effecting service calls for the second users. Then on replay the first user may cause those service calls to be bound to the actual services. The proxy service further ensures that the limited credentials of the second endpoint interface entity are enforced. For instance endpoints on the nodes B and B may not receive proprietary data owned by the first endpoint interface entity from a service and likewise may not change such proprietary data at least not without the consent of the first endpoint interface entity.

The splitting of transformation chain instances as described herein allows for a wide variety of scenarios. For instance by only allowing output endpoints to be cloned in the portion transformation chain provided to the second endpoint interface entity and retaining input and output endpoints with the first endpoint interface entity the second endpoint interface entity may have a shared view on what the first endpoint interface entity is doing. Of course the first endpoint interface entity may restrict which output endpoints are provided in the portion transformation chain and thus such view sharing can even be restricted. Furthermore collaborative and co use scenarios are enabled by dividing input endpoints between the first and second endpoint interface entities. Several instances and versions of a portion transformation chain may be split off of the main transformation chain to allow such scenarios across more than two endpoint interface entities. Each split may have an associated proxy service that maintains proper information separation and functioning of the transformation chain.

Now suppose that the user provides a selection user interaction with respect to the user interface or more specifically provides a selection user interaction with respect to the orders object . Such selection user interaction might include a gesture. For instance in the state A the user has circled with gesture the orders object . This results in selection of the orders object.

In a subsequent state B is shown in which the user has provided a redaction user interaction with respect to the user interface or more specifically with respect to a subportion of the selected portion. In this example the user has redacted field by entering a cross out gesture with respect to the user interface corresponding to that subportion i.e. by crossing out field .

In a subsequent state C is shown in which the user has selected a target for sharing the selecting portion minus the redacted subportion and has initiated sharing with that target portion. In particular the user has interacted with element causing sharing to occur of the order object with the field redacted. Such is an example of one of an enumerable variety of sharing that may be accomplished using the principles described herein.

For each of the applications the content of box is performed. Specifically at least one endpoint interface entity selected from the endpoint interface registry is identified act as to interface with the application or a portion thereof . This selection may include determining that the identified endpoint interface entity is credentialed to interface or correspond with the application or the portion thereof . As part of this identification it is determined that the environmental event s if any are satisfied with respect to the endpoint interface entity act . For instance in this identification may be made by the endpoint matching module .

The identified endpoint interface entity is then allowed act to interface with the application or the portion thereof . In other words within the scope of the application or the portion thereof the identified endpoint interface entity is permitted to interface with the corresponding application endpoints within that scope. In the case of a split application in which different endpoint interface entities are to interface with different portions of the application the delegation module operates as described above.

In the event that there are multiple endpoint interface entities that are available for a given application the identification of an appropriate endpoint interface entity act might also include determining that 1 an output endpoint for rendering at the hardware entity of the identified endpoint interface entity is efficiently perceivable to at least one a plurality of user that satisfies y the user criteria of the identified endpoint interface entity or has some specific characteristic helpful or required to complete a portion of a user s task intent or delivery the appropriate action in response to some implicit event in the environment and 2 does not conflict with at least one other output endpoint rendered at the hardware entity so as to adversely affect perception of at least one user that satisfies the user criteria. Similarly the identification of an appropriate endpoint interface entity act might also include determining that 1 an input endpoint for inputting at the hardware entity of the identified endpoint interface entity is capable of receiving input from at least one a plurality of active endpoint interface entities or has some specific characteristic helpful or required to complete a portion of a user s task intent or delivery the appropriate action in response to some implicit event in the environment and 2 an input endpoint for inputting at the hardware entity of the identified endpoint interface entity does not conflict with at least one other input endpoint rendered at the hardware entity so as to adversely affect ability to input of at least one user that interfaces with another endpoint interface entity. Through these determinations with respect to all input and output endpoints of the application an appropriate distribution of interfacing may be determined.

When the application is thereafter operated act various interaction is performed at the endpoints. The presentation module tailors the interaction act of the hardware entities with the endpoints by for each endpoint restricting the interaction capability of the endpoint perhaps according to the input and output hardware capabilities of the hardware entities. For instance if an object is to be displayed on a large display that has no touch input a prompt to touch here to perform some function may be removed whereas if the object is being displayed on a touch screen that prompt may be present. If information is being displayed via a particular output endpoint on a high fidelity display perhaps more detail may be displayed on the high fidelity display as compared to for instance a watch having a smaller display. Thus the interaction capability of an endpoint may be restricted. In other words the input to an endpoint may be restricted according to capabilities of the hardware entity and output from an endpoint may be restricted according to capabilities of the hardware entity.

Furthermore restrictions may be made depending on detection of environmental event s associated with a hardware entity. For instance if most users are further away from the display less detail might be displayed in favor of enlargement of visualizations. The rules for determining how to restrict an endpoint may be based on at least in part on 1 the interaction capabilities of the hardware entities 2 anticipated interference in the capabilities of the hardware entities 3 a position of one or more users with respect to at least one or more of the hardware entities and 4 a control of one or more users with respect to one or more of the hardware entities.

One benefit of the split application configuration described with respect to is that data flows and interactions of the portion of the application assigned to a delegee endpoint interface entity are recorded. Thus data flows to that portion that are synchronous in nature may be converted into asynchronous communications by recording of the same. This allows the recordings to be replayed or transferred to another hardware entity. Thus the principles described herein allow smooth transitioning of communications from synchronous to asynchronous.

If during this monitoring act data flow is detected Yes in decision block the data flow is recorded act and the method returns to continue monitoring act . If during this monitoring act interactions between the second hardware entity and the second portion of the application are detected Yes in decision block the interactions are recorded act and the method returns to continue monitoring act . At times when there are no data flows detected No in decision block and no interactions detected No in decision block the monitoring simply continues as long as the application is split.

The recordings are made in a manner that they can be replayed e.g. by the second hardware entity that is assigned to the second portion of the application or reassigned e.g. from the second hardware entity to a third hardware entity . illustrates a flowchart of a method for transitioning to asynchronous communications in the context of synchronous communications being recorded. First a request is received or appropriate environment event s are detected suggesting that it would be helpful to replay the recorded communications act after which the requested replay is performed act . For instance if the second endpoint interface entity was not readily prepared for the synchronous communication from the first endpoint interface entity the second endpoint interface entity may simply replay the communications to come up to speed.

In another scenario the first endpoint interface entity may reassign the split portion of the application from the second endpoint interface entity to a third endpoint interface entity without the first endpoint interface entity having to redo the communication and being able to take advantage of what input the second endpoint interface entity was able to provide. illustrates a flowchart of a method for reassigning the split portion of an application to another endpoint interface entity. Specifically a request is detected or appropriate environment event s are detected suggesting that it would be helpful to move the split portion of the application act . For instance illustrates an environment in which such a move request may be made. The first portion of an application had been communicating as represented by arrow with a second portion of the application. A first hardware entity is interacting as represented by arrow with endpoints of the first portion of the application. A second hardware entity at least has the capability of interacting as represented by arrow with endpoints of the second portion of the application. During these communications the recorded information i.e. the recorded data flow represented by arrow and the recorded interactions represented by arrow is also maintained.

In response to the move request act a third endpoint interface entity is permitted to interact with the second portion of the application act and the recorded information is provided to the third endpoint interface entity act . This transfer of control and recorded information regarding the second portion of the application from the second endpoint interface entity to the third endpoint interface entity is represented by arrow in . Thereafter the first portion of the application may communicate as represented by arrow with the second portion of the application that has now been reassigned to the third endpoint interface entity .

Formatting of displayed information becomes challenging in this environment due to the many degrees of freedom that could affect how information is formatted and laid out. For instance the application itself may grow and be split as previously described and thus the application itself may change dynamically over even a short period of time. This affects the number and nature of the output endpoints that result in visualizations. Furthermore there may be multiple hardware entities rendering visualizations of an application each with varying capability to display. In addition changing environmental conditions may change the availability of a hardware entity to render information. For instance due to enforcement of user criteria changing conditions may cause endpoint interface entities to dynamically become available and unavailable.

Examples of triggers that might change the layout include but are not limited to 1 the first application changes to a second application due to growth or splitting of the application 2 a change in allocation of output between multiple displays 3 a change in users of the display 4 a change in position of one or more users with respect to the display 5 a change in control of one or more users with respect to the display 6 a change in authorization of one or more users with respect to the display or the information displayed.

Rather than simply applying to layout the method of could be applied to all forms of output and all forms of input. For instance as for output some parts of the output may be spoken. Some endpoint interface entities may light up or vibrate or more to convey information e.g. a screen swivels just a tad to suggest urgency or an accompanying drone maneuvers in a certain noticeable way . Different parts of the output may be sequenced rather than juxtaposed perhaps by creating an animation on the same or multiple endpoint interface entities. For input as an example a particular input menu may be lit up on one display rather than another. One microphone may be switched on rather than another with a light on the microphone indicating which microphone is active . Of course these are just examples.

Accordingly transformation chain classes represent a new paradigm in applications especially when considering how such classes and or instances thereof may be automatically combined to formulate customized applications almost as quickly as the user imagines what the user would like an application to do. Such applications may be constructed based on available classes of a transformation chain class library. Such a library may be populated by application authors that author transformation chain classes directly. However there is a large quantity of legacy software that has not been drafted in transformation chain class form. In accordance with the principles described herein software classes that are compatible with the transformation chain class and thus may be added to the transformation chain class library may be automatically generated based on legacy software.

The method begins by accessing e.g. receiving a software representation act . The software representation may be legacy software that is to be converted into a form that is compatible with a transformation chain class library. For instance as mentioned above the chain class maintenance module has access to and maintains a library of transformation chain classes. The software representation may be legacy software for which it is desired to generate a class that may be added to that library of transformation chain classes. The software representation may be for instance an object class application class function module or any other piece of software that can be analyzed for dependencies.

Referring to the software representation may be accessed via an input interface by the transformation module . As an example the input interface may be an Application Program Interface API . Much of the remainder of the method of may be performed by the transformation module .

One or more and potentially multiple dependencies of the software representation are then identified act . For instance in such identification may be performed by the transformation module . In the example software representation two dependencies A and B are illustrated as being within the software representation . However the ellipses C represent that there may be any number of dependencies identified within the software representation. The identification may be performed with the assistance of markup within the software representation. Such markup may for instance expressly identify dependencies and the nature of the dependency. Dependencies and their nature might also be identified by static and or dynamic analysis of the software representation. The markup might also identify aspects of sharability of the software. For instance the markup might indicate which portions may be read from or written to and under what circumstances and by whom.

It is also determined that a dependency element corresponds to at least one dependency element of at least one transformation chain class of the transformation chain class library act . Referring again to this may be performed by the transformation module . As an example suppose that the transformation chain class is one of the transformation chain classes of the transformation chain class library. The transformation module may determine that the dependency B of the software representation corresponds as represented by the dotted line to a dependency element of the transformation chain class . The correspondence is facilitated by the transformation module identifying the dependency and its characteristics act . The act may be performed to identify multiple of such correspondences between dependencies of the software representation and dependency elements of one or more transformation chain classes in the transformation chain class library.

The method then includes generating a software class that corresponds to the software representation and that includes a dependency element that corresponds to the identified corresponding dependency act . If there are multiple identified corresponding dependencies then there may be multiple corresponding dependency elements in the generated software class. The dependency element of the generated software class is structured to be interpretable by a merging module as being compatible with the dependency element of the transformation chain class of the transformation chain class library.

For instance in the transformation module generates a new software class that includes a dependency element . The dependency element is structured to be interpreted by a merging module as being compatible as represented by the dashed line with the dependency element of the transformation chain class . The merging module referenced may be the merging module of and the compatibility of dashed line might represent that the merging module could potentially join an instance of the new class with an instance of the transformation chain class at the dependency elements and in perhaps a similar manner as described above for .

The generated class may be for instance a transformation chain class having at least one node having endpoints. The generated class might also be a transformation chain class having multiple nodes in the case in which the transformation module finds sufficient information to determine internal data and transformations of the software representation . The transformation module may provide the new class via an output interface which may also be an API.

The software class may then be added to the transformation chain class library act . For instance in the software class may be added to the transformation chain library maintained by the chain class maintenance module of . Thus the software class may benefit the ecosystem of the universal canvas by itself or its instances being subject to merging sharing and so forth as described in detail above.

Accordingly a robust and organic application model has been described on the basis of transformation chains. The concept of transformation chains was first described with respect to . An example supporting architecture was then described with respect to . Thereafter various operations of the transformation chains including joining splitting delegation endpoint restriction formatting and so forth were described with respect to . The automatic generation of new classes to add to a library of transformation chain classes was then described with respect to . Of course all of these functions are supported by computing technology. Accordingly a general computing system will now be described for the sake of completeness with respect to .

Computing systems are now increasingly taking a wide variety of forms. Computing systems may for example be handheld devices appliances laptop computers desktop computers mainframes distributed computing systems or even devices that have not conventionally been considered a computing system. In this description and in the claims the term computing system is defined broadly as including any device or system or combination thereof that includes at least one physical and tangible processor and a physical and tangible memory capable of having thereon computer executable instructions that may be executed by the processor. The memory may take any form and may depend on the nature and form of the computing system. A computing system may be distributed over a network environment and may include multiple constituent computing systems.

As illustrated in in its most basic configuration a computing system typically includes at least one hardware processing unit and memory . The memory may be physical system memory which may be volatile non volatile or some combination of the two. The term memory may also be used herein to refer to non volatile mass storage such as physical storage media. If the computing system is distributed the processing memory and or storage capability may be distributed as well. As used herein the term executable module or executable component can refer to software objects routings or methods that may be executed on the computing system. The different components modules engines and services described herein may be implemented as objects or processes that execute on the computing system e.g. as separate threads .

In the description that follows embodiments are described with reference to acts that are performed by one or more computing systems. If such acts are implemented in software one or more processors of the associated computing system that performs the act direct the operation of the computing system in response to having executed computer executable instructions. For example such computer executable instructions may be embodied on one or more computer readable media that form a computer program product. An example of such an operation involves the manipulation of data. The computer executable instructions and the manipulated data may be stored in the memory of the computing system . Computing system may also contain communication channels that allow the computing system to communicate with other message processors over for example network .

The computing system also may potentially include output rendering components such as displays speakers lights actuators or the like. The computing system may also include input components such as a keyboard pointer device such as a mouse or tracking pad voice recognition devices and possibly also physical sensors e.g. thermometers global positioning systems light detectors compasses accelerometers and so forth .

Embodiments described herein may comprise or utilize a special purpose or general purpose computer including computer hardware such as for example one or more processors and system memory as discussed in greater detail below. Embodiments described herein also include physical and other computer readable media for carrying or storing computer executable instructions and or data structures. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer readable media that store computer executable instructions are physical storage media. Computer readable media that carry computer executable instructions are transmission media. Thus by way of example and not limitation embodiments of the invention can comprise at least two distinctly different kinds of computer readable media computer storage media and transmission media.

Computer storage media includes RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other storage medium which can be used to store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.

A network is defined as one or more data links that enable the transport of electronic data between computer systems and or modules and or other electronic devices. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a transmission medium. Transmissions media can include a network and or data links which can be used to carry desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer readable media.

Further upon reaching various computer system components program code means in the form of computer executable instructions or data structures can be transferred automatically from transmission media to computer storage media or vice versa . For example computer executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module e.g. a NIC and then eventually transferred to computer system RAM and or to less volatile computer storage media at a computer system. Thus it should be understood that computer storage media can be included in computer system components that also or even primarily utilize transmission media.

Computer executable instructions comprise for example instructions and data which when executed at a processor cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be for example binaries or even instructions that undergo some translation such as compilation before direct execution by the processors such as intermediate format instructions such as assembly language or even source code. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather the described features and acts are disclosed as example forms of implementing the claims.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers desktop computers laptop computers message processors hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers mobile telephones PDAs pagers routers switches and the like. The invention may also be practiced in distributed system environments where local and remote computer systems which are linked either by hardwired data links wireless data links or by a combination of hardwired and wireless data links through a network both perform tasks. In a distributed system environment program modules may be located in both local and remote memory storage devices.

Accordingly the principles described herein provide a new application paradigm in which compound and customized applications may be built dynamically as the need arises by the users themselves based on input from the user or other detected environmental event s . Furthermore the applications may be shared securely. Also as described herein new classes may be automatically generated based on legacy software and added to the transformation chain class library.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

