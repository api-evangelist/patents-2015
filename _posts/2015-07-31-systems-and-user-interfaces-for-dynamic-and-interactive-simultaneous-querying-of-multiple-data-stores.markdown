---

title: Systems and user interfaces for dynamic and interactive simultaneous querying of multiple data stores
abstract: Embodiments of the present disclosure relate to a computer system and interactive user interfaces configured to enable efficient and rapid access to multiple different data sources simultaneously, and by an unskilled user. The unskilled user may provide simple and intuitive search terms to the system, and the system may thereby automatically query multiple related data sources of different types and present results to the user. Data sources in the system may be efficiently interrelated with one another by way of a mathematical graph in which nodes represent data sources and/or portions of data sources (for example, database tables), and edges represent relationships among the data sources and/or portions of data sources. For example, edges may indicate relationships between particular rows and/or columns of various tables. The table graph enables a compact and memory efficient storage of relationships among various disparate data sources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514200&OS=09514200&RS=09514200
owner: PALANTIR TECHNOLOGIES INC.
number: 09514200
owner_city: Palo Alto
owner_country: US
publication_date: 20150731
---
Any and all applications for which a foreign or domestic priority claim is identified in the Application Data Sheet as filed with the present application are hereby incorporated by reference under 37 CFR 1.57.

This application is a continuation of U.S. patent application Ser. No. 14 504 103 filed Oct. 1 2014 and titled SYSTEMS AND USER INTERFACES FOR DYNAMIC AND INTERACTIVE SIMULTANEOUS QUERYING OF MULTIPLE DATA STORES which application claims benefit of U.S. Provisional Patent Application No. 61 893 080 filed Oct. 18 2013 and titled TABLE GRAPH. The entire disclosure of each of the above items is hereby made part of this specification as if set forth fully herein and incorporated by reference for all purposes for all that it contains.

Embodiments of present disclosure relate to systems and techniques for accessing one or more databases in substantially real time to provide information in an interactive user interface. More specifically embodiments of the present disclosure relate to user interfaces for automatically and simultaneously querying multiple different data sets and or different electronic collections of data.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

Traditional database queries are generated and used by skilled computer programmers to access data from a data source such as a database. Traditional database queries are useful in many fields for example scientific fields financial fields political fields and or the like . Typically a computer programmer must determine the proper format for the query based on the type of database accessed and must determine the parameters of the query users or analysts that are familiar with the requirements of the data needed. Some man machine interfaces for generating reports in this manner are software development tools that allow a computer programmer to write and test computer programs. Following development and testing of the computer program the computer program must be released into a production environment for use. Thus this approach for generating queries may be inefficient because an entire software development life cycle for example requirements gathering development testing and release may be required even if only one element of the query requires changing or one aspect of the database has changed. Furthermore this software development life cycle may be inefficient and consume significant processing and or memory resources.

Further traditional queries must be formatted specifically as required by the type of data source accessed. Accordingly traditional methods of database querying have difficulties with handling queries to various types of data sources at the same time.

The systems methods and devices described herein each have several aspects no single one of which is solely responsible for its desirable attributes. Without limiting the scope of this disclosure several non limiting features will now be discussed briefly.

Embodiments of the present disclosure relate to a computer system and interactive user interfaces configured to enable efficient and rapid access to multiple different data sources simultaneously and by an unskilled user. For example the unskilled user may provide simple and intuitive search terms to the system and the system may thereby automatically query multiple related data sources of different types and present results to the user. Accordingly the system may enable efficient unskilled user interactions with complex and disparate data sources and efficient presentation of data including search results to the user.

In various embodiments data sources in the system may be efficiently interrelated with one another by way of a mathematical graph referred to herein as a table graph in which nodes represent data sources and or portions of data sources for example database tables and edges represent relationships among the data sources and or portions of data sources. For example edges may indicate relationships between particular rows and or columns of various tables. The table graph enables a compact and memory efficient storage of relationships among various disparate data sources. By comparison to previous methods in which data from disparate sources of different types were usually re copied to common data sources and or updated to a common type the present disclosure describes a system in which these steps need not be performed and thus the system is more efficient from both processor usage and memory usage perspectives.

Further embodiments of the present disclosure relate to a computer system designed to provide interactive graphical user interfaces also referred to herein as user interfaces for enabling non technical users to quickly and dynamically generate edit and update search queries. The user interfaces are interactive such that a user may make selections provide inputs and or manipulate outputs. In response to various user inputs the system automatically accesses one or more table graphs formulates necessary database queries traverses and queries associated data sources obtains search results and or displays the search results to the user.

Various embodiments of the present disclosure enable search query generation and display in fewer steps result in faster creation of outputs such as search results consume less processing and or memory resources than previous technology permit users to have less knowledge of programming languages and or software development techniques and or allow less technical users or developers to create outputs such as search results than previous systems and user interfaces. Thus in some embodiments the user interfaces described herein are more efficient as compared to previous user interfaces and enable the user to cause the system to automatically access and query multiple different data sources.

In some embodiments of the present disclosure user interfaces are generated that enable a user to efficiently relate various different data sources in a mathematical graph.

In some embodiments the system may automatically perform queries of data sources related in the table graph in parallel. Accordingly the present system may be even more efficient over previous systems as the table graph enables parallel and automatic querying of multiple data sources so as to provide search results to the user with even greater speed and frees up processor resources for other tasks.

Further as described herein in some embodiments the system may be configured and or designed to generate user interface data useable for rendering the various interactive user interfaces described. In these embodiments the user interface data may be used by the system and or another computer system device and or software program for example a browser program to render the interactive user interfaces. The interactive user interfaces may be displayed on for example electronic displays including for example touch enabled displays .

According to an embodiment a search system is disclosed that is configured to execute a search query the search system comprising one or more computing devices having hardware processors configured to execute instructions in order to access a first data store of a first type storing at least a first data table access a second data store of a second type different than the first type the second data store storing at least a second data table execute a table graph having a first node associated with the first data table a second node associated with the second data table and a link between the first node and the second node the link indicating a first field of the first data table that is associated with a second field of the second data table said executing comprising looking up first information associated with a search query in the first data store look up second information associated with the first information in the second data store provide the second information for display or processing by the search system.

According to an aspect at least one of the first field and the second field are full text searchable.

According to another aspect the link between the first node and the second node is a bi directional link.

According to yet another aspect the first type and the second type each include one or more of a relational data store an object oriented data store a proprietary data store a file based data store a hierarchical data store a network data store and an elastic search data store.

According to another aspect the table graph is executed via an application programming interface configured to format the second information as one or more data objects wherein the data objects further comprise attributes and values defined by a user.

According to another aspect the table graph further comprises a third node associated with a third data table and wherein executing the table graph further comprises concurrently looking up the first information in the first data table and looking up a third information in the third data table.

According to yet another aspect the lookups in the first data table and the third data tables are executed concurrently in response to the one or more computing devices automatically determining that the lookups are suitable for concurrent execution based on at least one of query dependency query complexity history of query execution duration usage statistics of the first second and or third data stores and or predicted usage demand of the first second and third data stores.

According to another embodiment a table graph system is disclosed that is configured to electronically communicate with at least one data store the table graph system comprising one or more physical computing devices having hardware processors configured to execution instructions in order to receive instructions to add a first data table as a first node in a table graph receive instructions to add a second data table as a second node in the table graph wherein the first data table and the second data table are of different types upon receiving instructions to add a relationship between the first and second nodes add the relationship wherein the relationship indicates a first field of the first data table is to be associated with a second field of the second data table wherein the table graph is executable in order to access data stored in the first data table and subsequently data in the second data table based at least partly on the data stored in the first data table.

According to an aspect the one or more physical computing devices are further configured to receive instructions to add a third node linked with the first node and or the second node receive instructions to indicate the first node and the third node as concurrently processable wherein the first node and the third node are executable concurrently in response to execution of the table graph.

According to another aspect the one or more physical computing devices are further configured to receive instructions to add a third node linked with the first node and or the second node receive instructions to execute at least two of the nodes concurrently automatically determine an order of executing the at least two of the nodes concurrently.

According to yet another aspect the one or more physical computing devices are further configured to automatically add one or more relationships between the first and second nodes.

According to another aspect the one or more physical computing devices are further configured to receive instructions to change the relationship between the first and second nodes from a one directional link to a bi directional link.

According to yet another aspect the first data table and the second data table are located remotely from each other.

In order to facilitate an understanding of the systems and methods discussed herein a number of terms are defined below. The terms defined below as well as other terms used herein should be construed to include the provided descriptions the ordinary and customary meaning of the terms and or any other implied meaning for the respective terms. Thus the descriptions below do not limit the meaning of these terms but only provide exemplary definitions.

Ontology Stored information that provides a data model for storage of data in one or more databases. For example the stored data may comprise definitions for object types and property types for data in a database and how objects and properties may be related.

Database A broad term for any data structure for storing and or organizing data including but not limited to relational databases Oracle database mySQL database etc. spreadsheets XML files and text file among others. It is also called a data store or a data structure herein.

Data Object or Object A data container for information representing specific things in the world that have a number of definable properties. For example a data object can represent an entity such as a person a place an organization a market instrument or other noun. A data object can represent an event that happens at a point in time or for a duration. A data object can represent a document or other unstructured data source such as an e mail message a news report or a written paper or article. Each data object may be associated with a unique identifier that uniquely identifies the data object. The object s attributes e.g. metadata about the object may be represented in one or more properties.

Object Type Type of a data object e.g. person event or document . Object types may be defined by an ontology and may be modified or updated to include additional object types. An object definition e.g. in an ontology may include how the object is related to other objects such as being a sub object type of another object type e.g. an agent may be a sub object type of a person object type and the properties the object type may have.

Properties Attributes of a data object that represent individual data items. At a minimum each property of a data object has a property type and a value or values.

Property Type The type of data a property is such as a string an integer or a double. Property types may include complex property types such as a series data values associated with timed ticks e.g. a time series etc.

Property Value The value associated with a property which is of the type indicated in the property type associated with the property. A property may have multiple values.

Link A connection between two data objects based on for example a relationship an event and or matching properties. Links may be directional such as one representing a payment from person A to B or bidirectional.

Table Graph Set of multiple nodes and edges between two or more of the nodes. A node in a table graph may represent a data table or a portion of a data table. An edge in a table graph may represent a relationship between two nodes in the table graph. A relationship may represent for example a mapping between a data field of a node and a data field of another node.

To provide a framework for the following discussion of specific systems and methods described herein an example database system using an ontology will now be described. This description is provided for the purpose of providing an example and is not intended to limit the techniques to the example data model the example database system or the example database system s use of an ontology to represent information.

In one embodiment a body of data is conceptually structured according to an object centric data model represented by ontology . The conceptual data model is independent of any particular database used for durably storing one or more database s based on the ontology . For example each object of the conceptual data model may correspond to one or more rows in a relational database or an entry in Lightweight Directory Access Protocol LDAP database or any combination of one or more databases.

Different types of data objects may have different property types. For example a person data object might have an Eye Color property type and an Event data object might have a Date property type. Each property as represented by data in the database system may have a property type defined by the ontology used by the database .

Objects may be instantiated in the database in accordance with the corresponding object definition for the particular object in the ontology . For example a specific monetary payment e.g. an object of type event of US 30.00 e.g. a property of type currency taking place on 3 27 2009 e.g. a property of type date may be stored in the database as an event object with associated currency and date properties as defined within the ontology .

The data objects defined in the ontology may support property multiplicity. In particular a data object may be allowed to have more than one property of the same property type. For example a person data object might have multiple Address properties or multiple Name properties.

Each link represents a connection between two data objects . In one embodiment the connection is either through a relationship an event or through matching properties. A relationship connection may be asymmetrical or symmetrical. For example person data object A may be connected to person data object B by a Child Of relationship where person data object B has an asymmetric Parent Of relationship to person data object A a Kin Of symmetric relationship to person data object C and an asymmetric Member Of relationship to Organization data object X. The type of relationship between two data objects may vary depending on the types of the data objects. For example person data object A may have an Appears In relationship with Document data object Y or have a Participate In relationship with Event data object E. As an example of an event connection two person data objects may be connected by an Airline Flight data object representing a particular airline flight if they traveled together on that flight or by a Meeting data object representing a particular meeting if they both attended that meeting. In one embodiment when two data objects are connected by an event they are also connected by relationships in which each data object has a specific relationship to the event such as for example an Appears In relationship.

As an example of a matching properties connection two person data objects representing a brother and a sister may both have an Address property that indicates where they live. If the brother and the sister live in the same home then their Address properties likely contain similar if not identical property values. In one embodiment a link between two data objects may be established based on similar or matching properties e.g. property types and or property values of the data objects. These are just some examples of the types of connections that may be represented by a link and other types of connections may be represented embodiments are not limited to any particular types of connections between data objects. For example a document might contain references to two different objects. For example a document may contain a reference to a payment one object and a person a second object . A link between these two objects may represent a connection between these two entities through their co occurrence within the same document.

Each data object can have multiple links with another data object to form a link set . For example two person data objects representing a husband and a wife could be linked through a Spouse Of relationship a matching Address property and one or more matching Event properties e.g. a wedding . Each link as represented by data in a database may have a link type defined by the database ontology used by the database.

As illustrated in a variety of database types may be data sources of a table graph. In the embodiment of a table graph API is configured to interface between the table graph and multiple data sources such as the data sources illustrated in including a proprietary database an elastic search database a SQL database an ODBC database an object oriented database not shown in this figure a file based data store not shown in this figure a key value store not shown in this figure and so forth. The table graph API is capable of parsing data from various heterogeneous databases using one or more parsers and or transformers. In some embodiments a parser may communicate with a data source such as an external data store an internal data store a proprietary database etc. and parse the data received from the data source. In some embodiments a transformer will further transform the data into a format that can be easily read by the table graph API such as an object or another type of data. Depending on the embodiment if there is an unspecified data source that the table graph API has not previously interacted with the table graph API may first automatically detect or determine a set of rules to parse data from the unspecified source and or a user may manually provide translation data so that data sources of that type may later be accessed by table graphs.

The data access system may be used to generate table graphs such as table graph . Users such as data analysts database administrators IT administrators testing engineers QA engineers database and or software developers who have sufficient privilege to interact with the data access system may generate table graphs. They may also share the generated table graphs with other end users analysts engineers administrators and so forth. An end user a data analyst or other users who do not have to be familiar with the underlying system may be able to easily interact with table graphs through the data access system .

In the example in a user may through the data access system submit a request to add a first data table as a first node in a table graph . The user may further add other data tables as nodes in the table graph . The user may also specify set of relationships to add between the tables as edges of the table graph. In the example of table graph five nodes A B C D and E which may each be associated with different tables possibly from multiple data sources or some may represent a common table are added to table graph . The edge between nodes A and B is a bi directional edge where the direction s of edges indicate the direction of data flow between nodes. The other edges in the table graph are one directional edges. A bi directional edge may represent that there is a two way relationship between a data field in one node and a data field in another node. For example the ID field of a first node may be mapped to the fromID field in a second node. In addition the toID field of the second node may be mapped to the ID field of the first node. However in some embodiments a bi directional edge may also be represented as two one directional edges. A one directional edge represents a one way relationship from a data field in one node to a data field in another node which in some situations may mean that data from one data field in one node may be used to match a data field in another node. In some embodiments the user that creates the table graph may be a system administrator database administrator or a database or system developer. In some other embodiments the user may be an end user or a user of the table graph system. In some situations there may be a user that creates the table graph and other users that have access to the table graph or have privileges to edit remove and or execute queries using the table graph . In some embodiments applications may also interact with data access system . For example a data quality monitoring system may need to query a table graph and process the returned results. The application in this example would be the data quality monitoring system. In another example the application may be a part of an integrated system that detects fraud security breaches and so forth and the application may receive search queries and or instructions to create and or configure various table graphs for various purposes.

As shown in the example in the Customer Info table also referred to in as T includes three data fields ID Customer and Occupation. The ID field is represented in this example as numbers such as 213 214 215 etc. The Customer field may store names of the customers such as John Doe Jane Doe and James Bond and so forth. The Transactions table also referred to as T in includes five data fields Trans. No. fromID toID Item and Cost. The fromID and toID fields in the table represent the identities of the people who are involved in the transaction in a given row in the Transactions table. For example Trans. No. 90 is a transaction from a person 213 to a person 215 that involves a printer. The printer s cost is 107.99.

Two edges which can also be represented in some embodiments as a single bi directional edge connect the customer info node and the transactions node . From the customer info node an edge represents a relationship between the ID field in the customer info node and the fromID field in the transactions node . From the transactions node an edge represents a relationship between the toID field in the transactions node and the ID field in the customer info node . With the edges establishing table lookups a user may be able to quickly search for transactions and identities of the people involved in the transactions without performing the intermediate search steps.

In one example a user may wish to search for all the transactions from John Doe to James Bond. Traditionally such a query may have to be carried out in several steps possibly using different search functionality for different data sources and or using a complicated search term.

In the embodiment of using a table graph the search may be significantly easier for the user to execute because intermediate steps of parsing query results and making further queries based on previous queries are transparent and hidden from the user. After creating the table graph with the two tables as nodes and edges established between the two tables queries may be easily carried out. The received search query may be received by the data access system and carried out by accessing multiple data sources via the table graph API for example. Because the ID field in the customer info node is linked to the fromID field in the transactions node and the toID field in the transactions node is linked to the ID field of the customer info node the table graph search may be executed directly which may involve sending over the ID of 213 and receiving a set of transactions satisfying the search criteria James Bond which corresponds to toID 215 and the transaction detail Trans. No. 00090 from ID 213 toID 215 Item printer Cost 107.99 . In some embodiments the results will be parsed and presented to the user as an object or a set of objects. The user however does not need to parse any intermediate results such as searching for the ID related to a name searching for a name that is related to an ID or searching for a transaction that is related to the IDs.

In the second stage of the search the table graph may automatically repeat the table graph using the customer information returned from a previous execution of the table graph such as to not only find transactions initiated by James Bond but to also find transactions initiated by others involved in transactions with James Bond. Traditionally such a query may have to be carried out in several steps or using a complicated search term. Through the use of the table graph rather than the user needing to parse the results and find out that the toID of the transaction involving James Bond fromID 215 is 214 and then executing queries of the various tables to find transactions involving ID 214 the recursive searching according to the table graph arrangement is automated. For example the customer ID of 215 returned in the first stage top half of of the search which corresponds to James Bond may be used in a second execution of the table graph bottom half of in order to receive a set of transactions satisfying the search criteria Jane Doe which corresponds to ID 214 and the transaction detail Trans. No. 00091 from ID 215 toID 214 Item rice Cost 4.50 . In some embodiments the results will be parsed and presented to the user as an object or a set of objects. Such recursive execution of table lookups and other features are easily implemented using table graphs.

Depending on the embodiment results of a search may be displayed in the example user interface or in a separate interface. For purposes of illustration illustrates search results that may be returned by executing the table graph of although additional results may be obtained if recursive execution of the table graph is continued . In the example as shown a direct hit is displayed A transaction for 107.99 was found between John Doe and James Bond for a Printer Transaction No. 00090 . In addition an indirect hit e.g. a transaction of an indication associated with John D rather than John D himself may also be displayed such as the one in the example user interface A transaction for 4.50 was found between James Bond and Jane Doe for Rice Transaction No. 00091 . In this example the indirect hit may be found by the search because John Doe has transacted with James Bond who also transacted with Jane Doe.

In some embodiments instead of displaying search results in formatted text the user interface may display all or a subset of the search results as data field values unparsed results objects and or files. The results may also be offered as downloadable files formatted in various ways for the convenience of the user.

The process begins at block wherein the data access system accesses a table graph such as a table graph selected by the user or a default table graph associated with a particular search functionality that the user wishes to perform whether or not the user even knows that table graphs are being used to execute the search functionality . For purposes of the example in a table graph having two nodes such as in is assumed although table graphs may include any quantity of nodes in various configurations. In some embodiments accessing the table graph may also include obtaining information regarding the nodes and edges in the table graph such as the names properties relations index types and data fields involved in the nodes and edges.

The process then proceeds to block and a first data store storing data of a first type is accessed. Depending on the embodiment the first data store may be a database of several different types such as a proprietary database a SQL database an elastic search database an ODBC database a JDBC database an open source database and so forth. Moreover the data of the first type as stored in the first data store may be of any type. For example the data may be of one or more following types string float long integer binary Boolean text object BLOB BigInt char numeric Date DateTime real SmallInt Time Timestamp Varbinary Varchar and so forth. The structure of the data does not need to be specified before the data is accessed. For instance in some embodiments if an unknown data structure is encountered the API may be programmed to analyze and find out the data structure. In some embodiments the API may notify an administrator or user that an unknown data structure is encountered and receive the administrator or user s instructions.

The process then proceeds to block and a second data store storing data of a second type is accessed. The second data store may be a data store that is either internal or external to the first data store. For example the second data store may be a database maintained by the same or a different organization at a different location as the first data store. Moreover the second data store may store data that is of a different type than the first store. For example if the first data store is a SQL database the second data store may be a database of a proprietary type and the two data stores may or may not be able to directly share query terms with each other. For example the first data store may be a data store maintained by Company A that stores information related to consumers including their names identities and so forth. The first data store may be implemented as a MySQL database. The second data store may be a data stored maintained by a department store B. The second data store may use the Microsoft Access format to store its transaction information related to department store customer transactions. In some embodiments the first and second data stores are not accessed blocks until data is actually requested from the data stores such as when the table graph is executed block .

The process then proceeds to block and a search query is received. In some embodiments the search query may be submitted by a user through an application. In some other embodiments the user may directly interact with a table graph system. The search query may be processed by the data access system which interacts with the table graphs and may be further be in contact with the table graph API in order to access the various data sources.

The process then proceeds to block and the search query may be executed using the table graph. In some embodiments the data access system and or the API may analyze the search query to parse information such as the nodes and edges relevant to this search query. The data access system and or the API may also generate one or more queries to the relevant data stores which may include information such as search terms data fields name of the data tables etc. Because the one or more queries formatted by the data access system are transparent to the user the user does not need to specify the various search queries e.g. the exact query language used by the various data stores details regarding how to join tables how to parse intermediate results or other details regarding the actual search execution. Moreover as discussed previously if the search query involves the look up of more than one tables nodes and the operation to be performed on one table depends on the intermediate results received from another table such details may be transparent to the user. The user does not need to parse the intermediate results obtained at each node of the search query.

For purposes of the example in a table graph having two nodes such as in is generated although table graphs may include any quantity of nodes in various configurations. The process begins at block wherein instructions to add a first table as a node are received from a user or an administrator. The first table may be physically located in a database that is remote from the user. Although the word table is used the data in the first table may be in any other data container and or formatter either structured or unstructured. For example data in the table may be in an XML like format or a user defined format. The data may also be in a traditional database format an object oriented database format and so forth. In some embodiments the instructions to add a first table to a table graph as a node may also include additional information such as an alias for the node. For example an alias for the customer info node may be Domain.DB.T. The received instructions may also include in some embodiments information regarding how the data in the first table may be structured.

The process then proceeds to block and instructions to add another table as a node is received. In some embodiments the additional table that is added to the table graph may be in the same database as the first table. However in some other instances the additional table may belong to a database that is not directly related to the first table. It could even be of a type that cannot normally directly communicate with the first table because they might be of different database types.

The process then proceeds to block and instructions to add a relationship between the tables are received. Depending on the embodiment the received relationship may be of a type that is bi directional or one directional. When the received instructions are to create a relationship that is bi directional a bi directional edge between the tables are added to the table graph. In some other embodiments instead of creating a bi directional edge two one directional edges are created and added to the table graph. The edges between the tables denote the relationship that is added to the table graph. One common type of relationship that may be added between the two nodes in a table graph is a mapping. For example the ID column in one node may be mapped to the toID column in another node. In another example the name column in one node may be mapped to the full name column in another node.

The creation of an edge may not indicate that there is a one to one relationship between the data records stored in the two nodes. Instead a variety of scenarios may exist. For example the ID column in one node may correspond to the toID column in another node but there may be multiple records with the same toID values in the other node. Moreover the ID column in the one node may be sequential unique and non negative integer values. The toID column in the other node may have redundancy and or non integer values. Details such as these may be transparent to a user who queries the table graph which adds to the efficiency and ease of use to the system.

As another example the name column or any other field in one node may contain both first name and last name or other combinations of data . The full name column in the other node however may have incomplete data records such as James B. instead of James Bond. The edge between these two nodes therefore may based on user request include an exact mapping of data records in the two nodes or a mapping that include partial matches or accommodate data ranges elastic matches and so forth.

The process then proceeds to a decision block which determines whether additional tables may be added as nodes to the table graph. If the user wishes to add another table as a node to the table graph then the answer to the question in the decision block is yes. In some embodiments instructions may be received from an administrator or a user with sufficient privilege to add a plurality of tables as nodes in a table graph then the answer to the question in the decision block is also yes. Accordingly the process proceeds to block wherein instructions to add another table as a node in the table graph is received. The process then proceeds to block wherein the computing system receives instructions to add a relationship between nodes in the table graph.

However if the user does not want to add more nodes to the table graph or if all the tables have been added as nodes as instructed then the answer to the question in the decision block is no. Accordingly the process proceeds to block wherein the table graph is built and stored. In some embodiments the table graph may be built and stored in a local computing device of the user or administrator that creates the table graph such as in a computer a tablet device a handheld device and so forth. In some other embodiments the table graph may be built and stored in a remote computing device.

Moreover building the table graph may include indexing fields and or columns that may be relevant to edges in the table graph and or fields that should be indexed according to the instruction of a user. For example in the customer info node an index may be created for the ID column. Depending on the embodiment various types of indexing methods and indices may be used. In addition the Customer column may also be indexed.

Depending on the embodiments the indexing methods used may present full text searchability and matching capability for regular expression and fuzzy matches. For example instead of requiring an exact match to a customer s name James Bond may be considered a match for a search term James B . Also the user may specify that a search should satisfy the requirement of Jame B d wherein the wildcard represents any character. Additional regular expression type of matching capabilities may also be accommodated and made possible by the indexing methods and or query techniques used by a table graph.

Moreover in some embodiments the edges between the nodes in a table graph are tolerant of data quality issues. For example instead of James Bond a data record in the database may include the name Jomes Bond with a typo in Jomes . A fuzzy matching capability may identify this record as potentially the same as James Bond and the edge between two tables in which a name field is used as part of a relationship may still identify a data record containing the record Jomes Bond. 

In another example the table graph may automatically perform record matches in various ways. For example if a phone number is given as 123 456 7890 this may automatically be matched with other formats for phone numbers such as 123.456.7890 123 456 7890 and or the like.

In one embodiment nodes and or edges may be added via command line instructions. For example a node in a table graph may be added using syntax such as Node customer new CustomerNode . In another embodiment a node be also added using syntax such as graph.addNode customer . These syntaxes are presented for illustrative purposes only.

The user interface may also allow users to configure the edge types between among the nodes in the table graph. For example the example user interface of shows nodes and selected by the user indicated by the bold outline of the nodes in this example such that a relationship between those selected nodes can be created and or updated. In this example a user may choose to add a bi directional edge between node node A and node node B by dragging an edge between two nodes in the table graph. The type of an edge can also be configured and or edited. For example a user may choose to change a bi directional edge into a one directional edge. A user may also remove an existing edge.

The user interface may also allow a user to select certain fields to index in order to complete the configuration of an edge. For example the edge between nodes A and B may be configured to be between the Last Name field in node A and the Surname field in node B . In the example of with nodes and selected drop down menus and are populated with fields of the respective tables associated with nodes and such that the user can selected corresponding index nodes of the two tables. For example a user may choose to change the relationship between the two nodes by choosing the appropriate data field in a drop down menu for node A and the drop down menu for node B . In some other embodiments other types of interface elements may be generated and presented in order for users to choose the data fields to index.

In some embodiments if a user wishes to add a data table as a node into an existing or a new table graph the user may drag a table and drop it into the table graph at which time the table is inserted as a node in the table graph. In the example user interface a user has dragged and dropped three tables as nodes into the table graph node DB.T node DB.T and node DB.T . Edges may also be added between the tables. A user may also click on an edge and create indices on the tables and make further configurations as to the mapping between data fields in the nodes.

A table graph that includes at least two nodes that are configured to be executed in parallel may be called a parallel table graph. In some embodiments one or more nodes in a table graph may be included in a group so that searches related to the nodes in the group may be executed in parallel making the searches even more efficient. For instance in the example table graph the nodes may be grouped automatically and or manually into five different groups. In this example Group 1 includes node A and node B . Group 2 includes node C and node E . Group 3 only includes one node which is node D . Group 4 includes only one node node F . Finally group 5 includes two nodes node G and node H . In one embodiment the nodes that belong to the same group may be executed in parallel because the search queries involving each of these nodes may be configured to be executed independently.

In some instances there could be more than one way to partition a table graph into multiple groups. A table graph may be partitioned into several sub graphs in multiple ways. Therefore besides automatically grouping several nodes together into one group a user may choose to alter the grouping of nodes e.g. an automatic grouping provided by the table graph generation software for a parallel table graph for reasons of execution efficiency data quality and so forth. A user may utilize an interface such as the example user interface and edit the existing grouping of nodes for parallel table graph execution. If after the user s configuration certain nodes assigned into the same group by the user cannot be executed in parallel the example user interface may display a warning message to the user and let the user know that the current assignment of nodes into a group would not result in a viable parallel table graph execution.

The following is an example of parallel table graph execution Suppose a parallel table graph includes 3 tables nodes including Table 1 that links a customer name to a customer ID Table 2 that links a customer ID to a phone number and Table 3 that links a customer ID to an address. In a search for a customer name an initial search of Table 1 may be performed. However one a customer ID corresponding to the customer name is determined a parallel search of Tables 2 and 3 may be performed. Accordingly in this example a parallel table graph execution may be performed automatically on nodes corresponding to Tables 2 and 3.

The process begins at block wherein a table graph is accessed. Accessing a table graph may include receiving information regarding the edges and nodes in the table graph and the data fields that may be involved in the edges and nodes.

The process proceeds to block and instructions regarding executing some nodes in the table graph in parallel are received. As discussed previously the instructions to execute certain nodes in parallel may be received from a user and or automatically determined. In some other embodiments such instructions may be received from an application or a physical computing device that have instructions stored on it to execute a search query using a table graph. For example an application that interacts with a table graph regularly such as a program that periodically queries a table graph and reports updated results may include instructions to query the table graph in parallel. A user or an administrator may set up such instructions as part of the application. Alternatively the table graph system may automatically determine that particular nodes may be queried in parallel and may automatically execute the particular nodes in parallel when a search query is received.

The process then proceeds to block and the order of executing the nodes in the table graph are determined. Depending on the embodiments the determination may be made automatically based on the dependencies of the search queries and or other factors such as expected time for executing a query the complexity of a query records of past search query execution duration amount of data potentially involved in a search query or in a node database usage statistics search demand predictions and so forth. The factors may further be weighted in order to plan the search queries in a cost effective way. For example queries that may be repeated periodically can be scheduled to take place at certain times when the demand on a database server is low. In another example nodes involved in search queries that according to statistics may take a long time to finish may be executed with more priority than other search nodes involving other nodes even if both could be executed in parallel.

In some other embodiments the determination of the order of executing the nodes may also be made by a user who may arrange the order of executing the nodes by assigning certain nodes into the same or various different execution stages and or groups. Also depending on the embodiment the determination may be made by a combination of user input and automatic determination. A user may modify the automatic parallel table graph execution arrangement. A user s parallel table graph execution arrangement may undergo sanity checks performed automatically or as part of a program.

The process then proceeds to block and at least some of the nodes in the table graph are executed in parallel according to the determined order. In some embodiments a user interface may also be executed and created to the user so that the user may monitor the execution of the table graph as it happens. In some other embodiments performance statistics may be gathered for the table graph search in order to further optimize future parallel table graph searches.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems server computer systems portable computer systems handheld devices networking devices or any other device or combination of devices that incorporate hard wired and or program logic to implement the techniques.

Computing device s are generally controlled and coordinated by operating system software such as iOS Android Chrome OS Windows XP Windows Vista Windows 7 Windows 8 Windows Server Windows CE Unix Linux SunOS Solaris iOS Blackberry OS VxWorks or other compatible operating systems. In other embodiments the computing device may be controlled by a proprietary operating system. Conventional operating systems control and schedule computer processes for execution perform memory management provide file system networking I O services and provide a user interface functionality such as a graphical user interface GUI among other things.

For example is a block diagram that illustrates a computer system upon which the processed discussed herein may be implemented. For example a table graph generation user interface may be generated and displayed to a user by a first computer system while a search query using one or more table graphs may be executed by another computer system or possibly the same computer system in some embodiments . Furthermore the data sources may each include any portion of the components and functionality discussed with reference to the computer system .

The example computer system includes a bus or other communication mechanism for communicating information and a hardware processor or multiple processors coupled with bus for processing information. Hardware processor s may be for example one or more general purpose microprocessors.

Computer system also includes a main memory such as a random access memory RAM cache and or other dynamic storage devices coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk optical disk or USB thumb drive Flash drive etc. is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT or LCD display or touch screen for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane. In some embodiments the same direction information and command selections as cursor control may be implemented via receiving touches on a touch screen without a cursor.

Computing system may include a user interface module to implement a GUI that may be stored in a mass storage device as executable software codes that are executed by the computing device s . This and other modules may include by way of example components such as software components object oriented software components class components and task components processes functions attributes procedures subroutines segments of program code drivers firmware microcode circuitry data databases data structures tables arrays and variables.

In general the word module as used herein refers to logic embodied in hardware or firmware or to a collection of software instructions possibly having entry and exit points written in a programming language such as for example Java Lua C or C . A software module may be compiled and linked into an executable program installed in a dynamic link library or may be written in an interpreted programming language such as for example BASIC Perl or Python. It will be appreciated that software modules may be callable from other modules or from themselves and or may be invoked in response to detected events or interrupts. Software modules configured for execution on computing devices may be provided on a computer readable medium such as a compact disc digital video disc flash drive magnetic disc or any other tangible medium or as a digital download and may be originally stored in a compressed or installable format that requires installation decompression or decryption prior to execution . Such software code may be stored partially or fully on a memory device of the executing computing device for execution by the computing device. Software instructions may be embedded in firmware such as an EPROM. It will be further appreciated that hardware modules may be comprised of connected logic units such as gates and flip flops and or may be comprised of programmable units such as programmable gate arrays or processors. The modules or computing device functionality described herein are preferably implemented as software modules but may be represented in hardware or firmware. Generally the modules described herein refer to logical modules that may be combined with other modules or divided into sub modules despite their physical organization or storage

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor s executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor s to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term non transitory media and similar terms as used herein refers to any media that store data and or instructions that cause a machine to operate in a specific fashion. Such non transitory media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of non transitory media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge and networked versions of the same.

Non transitory media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between nontransitory media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN or WAN component to communicated with a WAN . Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

Each of the processes methods and algorithms described in the preceding sections may be embodied in and fully or partially automated by code modules executed by one or more computer systems or computer processors comprising computer hardware. The processes and algorithms may be implemented partially or wholly in application specific circuitry.

The various features and processes described above may be used independently of one another or may be combined in various ways. All possible combinations and subcombinations are intended to fall within the scope of this disclosure. In addition certain method or process blocks may be omitted in some implementations. The methods and processes described herein are also not limited to any particular sequence and the blocks or states relating thereto can be performed in other sequences that are appropriate. For example described blocks or states may be performed in an order other than that specifically disclosed or multiple blocks or states may be combined in a single block or state. The example blocks or states may be performed in serial in parallel or in some other manner. Blocks or states may be added to or removed from the disclosed example embodiments. The example systems and components described herein may be configured differently than described. For example elements may be added to removed from or rearranged compared to the disclosed example embodiments.

Conditional language such as among others can could might or may unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without user input or prompting whether these features elements and or steps are included or are to be performed in any particular embodiment.

The term comprising as used herein should be given an inclusive rather than exclusive interpretation. For example a general purpose computer comprising one or more processors should not be interpreted as excluding other computer components and may possibly include such components as memory input output devices and or network interfaces among others.

Any process descriptions elements or blocks in the flow diagrams described herein and or depicted in the attached figures should be understood as potentially representing modules segments or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process. Alternate implementations are included within the scope of the embodiments described herein in which elements or functions may be deleted executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved as would be understood by those skilled in the art.

It should be emphasized that many variations and modifications may be made to the above described embodiments the elements of which are to be understood as being among other acceptable examples. All such modifications and variations are intended to be included herein within the scope of this disclosure. The foregoing description details certain embodiments of the invention. It will be appreciated however that no matter how detailed the foregoing appears in text the invention can be practiced in many ways. As is also stated above it should be noted that the use of particular terminology when describing certain features or aspects of the invention should not be taken to imply that the terminology is being re defined herein to be restricted to including any specific characteristics of the features or aspects of the invention with which that terminology is associated. The scope of the invention should therefore be construed in accordance with the appended claims and any equivalents thereof.

