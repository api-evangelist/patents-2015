---

title: Client-side rendering for virtual mobile infrastructure
abstract: A virtual mobile infrastructure performs client-side rendering by intercepting and redirecting screen data for generating a screen image of a remote mobile operating system from a server computer to a mobile client device. The mobile client device receives the screen data and generates the final screen image of the remote mobile operating system. The screen data include drawing application programming interface (API) calls to generate surfaces for applications running on the remote mobile operating system and data for compositing the surfaces together. The mobile client device makes the drawing API calls to generate the surfaces and generates the final screen image of the remote mobile operating system by compositing the surfaces in accordance with the compositing data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09654603&OS=09654603&RS=09654603
owner: Trend Micro Incorporated
number: 09654603
owner_city: Tokyo
owner_country: JP
publication_date: 20151120
---
This application is a continuation of U.S. application Ser. No. 13 901 379 filed on May 23 2013 now U.S. Pat. No. 9 225 799 which claims the benefit of U.S. Provisional Patent Application No. 61 825 829 filed on May 21 2013 all of which are incorporated herein by reference in their entirety.

The present invention relates generally to mobile devices and more particularly but not exclusively to computing infrastructures for supporting operation of mobile devices.

Mobile devices such as smartphones and tablets have become commonplace and are now employed as replacements for portable e.g. laptops and netbooks and desktop e.g. personal computers computing devices. For example smartphones are now employed not just to make voice calls over traditional mobile telephone networks but also to browse the Internet watch streamed video and play online games. Some employers even allow employees to bring their own devices the so called BYOD policy.

One problem with mobile devices is that they run mobile operating systems such as the ANDROID and the iOS operating systems. Unlike traditional desktop operating systems such as the WINDOWS operating system mobile operating systems are not as powerful and extensible allowing them to run securely on a mobile device that has limited computing resources. Accordingly mobile devices running mobile operating systems cannot readily take advantage of some computing infrastructures available to computers that run desktop operating systems.

In one embodiment a virtual mobile infrastructure performs client side rendering by intercepting and redirecting screen data for generating a screen image of a remote mobile operating system from a server computer to a mobile client device. The mobile client device receives the screen data and generates the final screen image of the remote mobile operating system. The screen data include drawing application programming interface API calls to generate surfaces for applications running on the remote mobile operating system and data for compositing the surfaces together. The mobile client device makes the drawing API calls to generate the surfaces and generates the final screen image of the remote mobile operating system by compositing the surfaces in accordance with the compositing data.

These and other features of the present invention will be readily apparent to persons of ordinary skill in the art upon reading the entirety of this disclosure which includes the accompanying drawings and claims.

In the present disclosure numerous specific details are provided such as examples of apparatus components and methods to provide a thorough understanding of embodiments of the invention. Persons of ordinary skill in the art will recognize however that the invention can be practiced without one or more of the specific details. In other instances well known details are not shown or described to avoid obscuring aspects of the invention.

Referring now to there is shown a schematic diagram of a computer that may be employed with embodiments of the present invention. The computer may be employed as a mobile client device a server computer for a virtual mobile infrastructure and other devices described below. The computer may have fewer or more components to meet the needs of a particular application. The computer may include a processor . The processor may comprise an ARM processor when the computer is a mobile client device or an x86 processor when the computer is a server computer for example. The computer may have one or more buses coupling its various components. The computer may include one or more user input devices e.g. keyboard touchscreen one or more data storage devices e.g. flash memory universal serial bus USB drive a display monitor e.g. touchscreen liquid crystal display one or more communications interfaces e.g. network adapter cellular interface and a main memory e.g. random access memory . The computer is a particular machine as programmed with software modules . The software modules comprise computer readable program code stored non transitory in the main memory for execution by the processor .

A mobile operating system is lightweight in that it consumes less computing resources such as processor and memory resources compared to desktop operating systems. A mobile operating system also supports communications over a mobile phone network such as a cellular network to provide telephony. In one embodiment a server computer comprises a single LINUX operating system server that runs several mobile operating systems in the form of ANDROID operating systems with each ANDROID operating system being implemented on a LINUX container. A mobile operating system running on a server computer is also referred to herein as a remote mobile operating system to distinguish it from a corresponding mobile operating system running on a mobile client device . In general components on a mobile client device are referred to herein as local components and components on the server computer are referred to herein as remote components.

In the example of the virtual mobile infrastructure includes one or more mobile client devices with each mobile client device comprising a mobile device that runs a mobile operating system. The mobile operating system of a mobile client device may be the same as a corresponding remote mobile operating system running on a server computer . In one embodiment the mobile client devices each comprises a smartphone or tablet that runs the ANDROID operating system. An ANDROID operating system running on a mobile client device is also referred to herein as a local ANDROID operating system and an ANDROID operating system running on a server computer is also referred to herein as a remote ANDROID operating system. 

In other embodiments a mobile operating system of a mobile client device and a corresponding remote mobile operating system may be different mobile operating systems. For example a mobile client device may be running an iOS operating system and the remote mobile operating systems may be ANDROID operating systems.

A mobile client device may communicate with the VMI computer system to access one of a plurality of remote mobile operating systems running on a server computer over a computer network which may include the Internet and or a private computer network. The remote mobile operating system which comprises the ANDROID operating system in this example includes a plurality of remote application programs also commonly known as applications or apps . A user of the mobile client device accesses the remote apps on the remote ANDROID operating system as if the remote apps are running on the mobile client device . For example the screen image of the remote ANDROID operating system is displayed on the touchscreen of the mobile client device . The user may even replace the mobile client device with another mobile client device to access the same remote apps on the same remote ANDROID operating system. This is particularly advantageous in workplaces that allow employees to use their own personal mobile client devices. In particular employees with different mobile client devices can work on remote apps running on remote mobile operating systems that are owned and managed by their employers.

The ANDROID operating system is a so called touchscreen mobile operating system in that it is primarily designed to work with touchscreen enabled smartphones and tablets. These smartphones and tablets do not have physical keyboards. Instead they have touchscreen keyboards also known as virtual keyboards that are displayed on the touchscreen. Accordingly the ANDROID operating system has provisions for an input method editor IME that allows a user to enter text by way of a touchscreen keyboard displayed by the IME. In one embodiment a mobile client device may provide text inputs to a corresponding remote ANDROID operating system using a local IME of the local ANDROID operating system. The text inputs are received by a local IME of a client application which provides the text inputs to a virtual IME running on the remote ANDROID operating system. The virtual IME provides the user inputs to the corresponding remote application running on the remote ANDROID operating system.

In one embodiment the VMI employs client side rendering to display a screen image of a remote ANDROID operating system on the mobile client device . More specifically the final screen image of the remote ANDROID operating system may be completed locally on the mobile client device . For example data for drawing surfaces and data for compositing the surfaces to create a final screen image may be generated on the remote ANDROID operating system and then sent to the mobile client device . There the final screen image is generated by locally drawing the surfaces and compositing the surfaces on the local ANDROID operating system.

Client side rendering minimizes network bandwidth consumption by not having to transmit the final screen image over the computer network. However graphics generation in general is computation intensive and increases battery consumption. In one embodiment a mobile client device performs client side rendering during normal operation but changes to server side rendering when its battery level is below a certain battery threshold. With server side rendering the final screen image is generated on the remote ANDROID operating system and the pixel information of the final screen image is sent to the mobile client device .

In the example of the plurality of server computers of the VMI computer system may share data storage devices by way of for example a distributed file system DFS . The VMI computer system may also take advantage of cloud services such as remote backups and other computing infrastructures such as administrator AD support database DB access and backup services that are typically available in an enterprise network.

As is well known an ANDROID operating system has three layers namely an ANDROID application layer an ANDROID system layer and a LINUX kernel. Referring to which shows the three layers of an ANDROID operating system the ANDROID application layer is the topmost layer and includes the applications. Below the ANDROID application layer is the ANDROID system layer which includes the application framework the libraries and the ANDROID runtime. The ANDROID runtime includes a Dalvik process virtual machine which is a process virtual machine for running an application. In contrast to a system virtual machine which supports execution of an entire operating system a process virtual machine supports execution of a single program. The ANDROID system runs on top of a LINUX kernel which provides device drivers and other kernel functions.

In marked contrast to hosted virtualization where each virtual machine has its own guest operating system that runs on and is separate from a host operating system the ANDROID operating systems of the server computer share the same LINUX kernel. More particularly each ANDROID operating system has its own applications and an ANDROID system with a Dalvik process virtual machine. However all of the remote ANDROID operating systems share the same single kernel a container does not have a kernel. In one embodiment the kernel includes a LINUX kernel and additional ANDROID kernel drivers for supporting an ANDROID operating system. The ANDROID kernel drivers are merged with the LINUX kernel to create the kernel which is then made the boot kernel of the LINUX operating system of the server computer . The server computer may comprise an x86 processor that runs the LINUX operating system and thus includes a LINUX kernel in the form of the kernel and a LINUX supervisor and console .

In one embodiment the kernel includes an ANDROID driver multiplexer which comprises computer readable program code for allowing multiple ANDROID systems to access the same kernel device driver. The ANDROID driver multiplexer multiplexes several ANDROID systems to a single kernel device driver as now explained with reference to .

In the example of the driver multiplexer creates a context for an ANDROID system if one is not available. A context comprises a set of data saved for an ANDROID system . When an ANDROID system accesses a kernel device driver the driver multiplexer checks to see if this is the first time the ANDROID system accesses the driver step . If so the driver multiplexer creates a context for accessing the driver for the ANDROID system step . When the ANDROID system has previously accessed the driver the driver multiplexer simply retrieves the saved context for the ANDROID system and switches to that context step to access the driver.

In the example of the ANDROID system makes a request to access the kernel device driver see arrow . If this is the first time the ANDROID system is accessing the kernel device driver the driver multiplexer creates a context for the ANDROID system . The driver multiplexer switches to the context to allow the ANDROID system to access the kernel device driver . The driver multiplexer saves all context data for the ANDROID system to the context . Thereafter the ANDROID system makes a request to access the kernel device driver see arrow . In this example the ANDROID system already has a saved context . Accordingly the driver multiplexer simply switches from the context or some other previous context to the context to allow the ANDROID system to access the kernel device driver .

In the example of the client mobile device may comprise a conventional smartphone running a local ANDROID operating system. The local ANDROID operating system has a plurality of applications on an application layer an ANDROID system and a LINUX kernel . The ANDROID system has a Dalvik process virtual machine for executing the applications on the ARM processor of the client mobile device .

In one embodiment the client mobile device includes the client application . In one embodiment the client application comprises computer readable program code for communicating and interfacing with a remote ANDROID operating system running on the server computer to allow a user of the client mobile device to access a remote application Like other applications the client application is running on application layer of the local ANDROID operating system.

Referring to the client application may connect to one of the plurality of remote ANDROID operating systems by way of a login server running on the server computer . During a registration process the client application logs into the login server to provide a username and password for accessing a particular remote ANDROID operating system see arrow . When the client application has been authenticated as being authorized to access the remote ANDROID operating system the login server provides the client application the remote ANDROID s connection address and a security token see arrow . Thereafter the client application may connect to the remote ANDROID operating system by providing access information e.g. the username and password and the security token see arrow . The remote ANDROID operating system allows access to the client application after authenticating the client application see arrow .

Continuing with on the server computer a remote access daemon receives user inputs see arrow and sensor information see arrow e.g. accelerometer or gyroscope information of the client device from the client application and provides the user inputs and sensor information to a corresponding component on the remote ANDROID operating system . In the case of client side rendering the remote access daemon may receive screen data for generating a final screen image and provide the screen data to the mobile client device where the screen data are processed to locally generate the final screen image for display on the touchscreen of the mobile client device . As will be more apparent below the screen data may comprise drawing API calls and compositing data intercepted on the remote ANDROID operating system and redirected to the client application on the local ANDROID operating system.

Generally speaking in an ANDROID operating system the final screen image to be displayed on the touchscreen comprises a plurality of surfaces that are composited together. Each of the surfaces may comprise a screen image for an application. More particularly each of the remote applications may issue drawing commands e.g. by making application programming interface API calls to the graphics engine to generate a surface see arrows . For example an application may issue drawing API calls to generate a surface for a background and another application may issue drawing API calls to generate a surface for icons. The graphics engine receives the drawing API calls and generates the corresponding surfaces see arrows . The graphics compositing engine receives the surfaces see arrows and creates the final screen image by compositing the surfaces together see arrow . In the just mentioned example the graphics compositing engine generates a final screen image showing a background and icons i.e. the composited screen images of the applications . The final screen image is stored in a frame buffer for subsequent displaying on the touchscreen. In the case of server side rendering a corresponding remote access daemon sends the pixel information of the final screen image to the mobile client device . That is in server side rendering the completed final screen image is sent to the mobile client device . Because of the relatively large size of the final screen image server side rendering consumes a large amount of network bandwidth.

In the case of client side rendering the final screen image generated by the remote ANDROID operating system is not forwarded to the mobile client device . Instead screen data for generating the final screen image are sent from the remote ANDROID operating system to the mobile client device . There the screen data are processed to locally generate the final screen image. More specifically for client side rendering drawing API calls made by the remote applications to generate surfaces and the compositing data for compositing the surfaces together are intercepted on the remote ANDROID operating system and redirected to the local ANDROID operating system.

In the example of client side rendering is performed by intercepting drawing API calls made by the applications . Compositing data for compositing the surfaces together to form the final screen image are also intercepted. The interception of drawing API calls and compositing data may be performed by a hook module running in each individual remote ANDROID operating system at the ANDROID system layer. The hook module may hook API calls to the ANDROID Skia graphics engine for 2D graphics and to the ANDROID OpenGL ES graphics engine for 2D or 3D graphics. The hook module may also hook compositing data for compositing multiple surfaces to generate the final screen image. The hook module may hook surface creation deletion locking unlocking events and each of the surface s attributes such as size position z order etc. More specifically in one embodiment the hook module may intercept the following 

In the example of a remote access daemon see in redirects the intercepted drawing API calls see arrow and compositing data see arrow to the mobile client device . There the client application running on the local ANDROID operating system receives the drawing API calls and makes the drawing API calls to the local graphics engine on the local ANDROID operating system to locally draw the corresponding surfaces . A surface compositor of the client application receives the surfaces see arrow and generates the final screen image see arrow that is displayed on the touchscreen of the mobile client device by compositing the surfaces together.

More specifically the client application may create the surfaces with double buffer front and back using the same ID and size as on the remote ANDROID operating system. The client application may then lock the surfaces to bind the front buffer to the context of the ANDROID Skia or OpenGL ES graphics engine whichever is applicable. The client application unflattens the stream of redirected drawing API calls and executes them by making the drawing API calls to the applicable graphics engine to draw the surfaces . The client application then unlocks the surfaces to trigger the surface compositor to generate the final screen image by compositing the surfaces . The client application thereafter updates the attributes of the surfaces as needed.

In one embodiment server side rendering is employed to display the final screen image of the remote ANDROID operating system on a mobile client device when the battery level of the mobile client device goes below a battery threshold. This embodiment of the present invention is now explained with reference to .

In one embodiment the virtual mobile infrastructure employs a local input method editor IME to provide user inputs to a remote ANDROID operating system. This feature of the virtual mobile infrastructure is schematically illustrated in .

In the example of a user of a mobile client device employs the client application to access a remote application running on a remote ANDROID operating system . The application employs a virtual IME to receive user inputs see arrow . The virtual IME may comprise an ANDROID application with IME services. The virtual IME displays its touchscreen keyboard whenever the application requires user inputs. Because the client application is accessing the remote ANDROID operating system the touchscreen keyboard of the virtual IME is also displayed on the mobile client device see arrow by client side rendering for example. When the user needs to enter text input the client application hides the touchscreen keyboard of the virtual IME from the client mobile device and invokes a local IME that uses a local IME service for example. This allows the user to enter text inputs via the touchscreen keyboard of the local IME . The client application receives the text inputs from the local IME and sends the text inputs to the virtual IME see arrow which then provides the text inputs to the remote application .

In the local ANDROID operating system on the left and the remote ANDROID operating system on the right are initially displaying the same screen image.

In the user touches a text input region on the screen of the local ANDROID operating system. The touch event is passed to the remote ANDROID operating system which invokes the virtual IME to display a touchscreen keyboard . Because the client application is displaying the screen image of the remote ANDROID operating system the touchscreen keyboard of the virtual IME is also displayed on the local ANDROID operating system.

In the virtual IME notifies the client application that user input is needed optionally the virtual IME also informs the client application the preferred keyboard type of the user. In response the client application invokes the local IME which displays a touchscreen keyboard . The touchscreen keyboard of the IME is displayed over the touchscreen keyboard of the remote ANDROID operating system. shows a portion of the touchscreen keyboard being visible on the local ANDROID operating system for illustration purposes only. In practice the touchscreen keyboard of the IME is displayed to cover up the touchscreen keyboard of the virtual IME . This way the user will not notice that the remote ANDROID operating system is still displaying the touchscreen keyboard of the virtual IME which is displayed underneath the touchscreen keyboard .

In the user enters text into the text input region using the touchscreen keyboard of the IME . The client application receives the text inputs from the IME and provides the text inputs to the virtual IME . This results in the text inputs being provided to the remote application and being shown on the touchscreen of the remote ANDROID operating system. The screen image of the remote ANDROID operating system is reflected on the local ANDROID operating system. This results in the text inputs appearing in the text input region of the local and remote ANDROID operating systems.

In the user performs an action that indicates end of user input. In the example of this is performed by the user by touching a go or search button on the touchscreen of the local ANDROID operating system. The client application informs the remote ANDROID operating system of the user action. The remote ANDROID operating system dismisses the virtual IME which in turn closes the touchscreen keyboard on the remote ANDROID operating system. Accordingly the touchscreen keyboard is no longer displayed on the remote and local ANDROID operating systems.

Before closing the virtual IME so informs the client application . In response as shown in the client application dismisses the IME to close the touchscreen keyboard .

While specific embodiments of the present invention have been provided it is to be understood that these embodiments are for illustration purposes and not limiting. Many additional embodiments will be apparent to persons of ordinary skill in the art reading this disclosure.

