---

title: Delayed shut down of computer
abstract: A computer-implemented computer shut-down method includes identifying that a computing device has been moved from an open configuration in which input and output mechanisms on the computing device are accessible to a user, to a closed configuration in which at least some of the input and output mechanisms are inaccessible to a user; starting a shut-down timer in response to identifying that the computing device has been moved from the open configuration to the closed configuration; waiting a predefined time period, as established by the shut-down timer, and determining from the shut-down timer that the computing device can be transitioned from an active state into a sleep state in which power consuming components of the computing device are powered down; and transitioning the computing device from the active state to the sleep state upon determining that the computing device can be transitioned.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454207&OS=09454207&RS=09454207
owner: GOOGLE INC.
number: 09454207
owner_city: Mountain View
owner_country: US
publication_date: 20150323
---
This application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. Nonprovisional patent application Ser. No. 13 300 502 filed on Nov. 18 2011 entitled DELAYED SHUT DOWN OF COMPUTER the disclosure of which is incorporated by reference herein in its entirety. This application also claims priority to U.S. Provisional Application Ser. No. 61 415 243 filed on Nov. 18 2010 entitled User Interaction in a Computer Operating System the entire contents of which are hereby incorporated by reference.

This document relates to systems and techniques for interacting with users of a computer operating system.

The core structures by which a computer e.g. a desktop PC laptop netbook or smart phone operates may include a basic input and output system or BIOS an operating system and other components that may be referred to as occupying a stack of software that provides basic functionality for operating a computer. The BIOS may be accessed when a computer is first turned on and booted and can provide basic functionality for the computer such as identifying testing and initializing system devices including storage devices that store code that is further needed to boot the computer. The code for the operating system can be stored on such an additional device and can provide for further booting of the computer until it is fully booted and ready to operate.

An operating system generally serves as an interface between the computer hardware and a user of the computer. An operating system may provide a variety of functions. For example the operating system can provide a graphical user interface GUI by which a user of the computer may receive output from the computer and may provide input to the computer. The operating system may also provide a platform on which various third party applications execute where the operating system provides services that are needed by the applications and also provides the mechanism by which the applications can communicate with other resources such as other applications peripheral devices e.g. printers cameras etc. and with services provided by the operating system itself.

This document describes systems and techniques that may be implemented as part of an operating system for a computing device or in a system that includes a number of different computing devices. For example various mechanisms may be used to synchronize a computing device with data stored in a cloud based system whereby a hosted computer server system is made available for members of the public to access the system and the system in turn provides various services such as data storage and back up document storage e mail routing and handling and other useful services. The computing device may be of a form that has relatively little local storage and that thus stores a user s data at the hosted server system. In addition the device may be configured so that it is essentially constantly connected to a network e.g. a wireless network and via the network to the internet. As a result various components on the device may be arranged to operate according to a nearly always on approach

Described in particular detail below are processes for delaying the shut down of a computer e.g. putting the computer into a sleep mode or suspend mode or fully turning the computer off in a situation that it would otherwise be shut down as soon as practical in order to conserve power and particularly battery power i.e. shut down may occur more quickly in certain instances when the device is not receiving AC power . Such shut down is typically triggered by a lack of user interaction with the device e.g. for a tablet or smartphone computer or closing of a cover on a device e.g. for a laptop or netbook computer . Using the techniques discussed below the shut down of such a device may be intentionally delayed by a determined amount based on determinations that the computer makes about its environment and other variables. For example a computer may delay shut down over a standard time based on the time of day e.g. delaying shut down during a work day under the assumption that the user may simply be moving from an office to a conference room while his or her laptop cover is closed versus late at night.

Also a computer may base the timing of shut down based on applications that are executing on the computer or content that is being displayed on the computer. For example a computer may delay shut down by a determined amount if a word processing document is open and optionally if it is open and has changes that have not been saved under the assumption that the user would have saved and closed the document before she intended to quit using the computer for a long period. The location of the computer may also be considered in making such a delay determination. For example a computer may delay shut down for a user who is at work or home but not delay if the user is somewhere else under the assumption that the user is likely leaving the unfamiliar location when they close the computer and thus will not be using it again for a long time. In addition location technologies e.g. GPS may be used to determine a velocity of the computer and quicker shut down may be triggered above a certain velocity under the assumption that a user intends not to use the device if they close the cover and are on a bicycle or in a car which are two examples of times when a computer might have a high velocity . Similarly a user s electronic calendar may be consulted in determining whether to shut down a device. For example if a user shuts a cover on the device at a time on her calendar that is between two meetings the system can assume she will be opening it soon at the next meeting and may avoid a shut down whereas if the calendar shows an ending meeting and nothing else on the calendar the device may shut down promptly under the assumption that the user is going to do something that does not require use of the computer like get some exercise . In addition the level of remaining battery may be blended with one or more of the prior considerations such that a device is shut down more readily when its batter is lower or below a predetermined threshold.

The determined delay in shutting down the computer may also depend on the immediate environment of the computer and on devices operating on the computer. For example if proximity sensors on the device indicate that there is something in close proximity to the device especially on its top or bottom the device may shut down more quickly under the assumption that the device has ben slipped into a carry bag and is not simply being carried in the user s hands. Similarly the orientation of the device relative to vertical can be determined and a system may determine that a vertical device higher than it is thick is more or less likely to indicate a long close than is a horizontal device. Moreover the activity of devices on a computer such as network interfaces may provide additional indications. For example a device may shut down more quickly or less quickly when a 3G or 4G interface is active on the device than when a WiFi interface is active.

In other examples the computer may learn about a user s propensity to re use a computer after making an indication that would normally be taken as an indication to shut down the computer such as by closing a cover. For example each time the user closes and reopens the cover the operating system may make note of the length of time the cover was closed and may record the state of one or more of the factors discussed above e.g. time of day geographic location applications open on the device velocity of the device battery level and presence and state of content in an application . After a sufficient number of such cycles the system may use standard statistical techniques to identify correlations between long closes which indicate that the device should have been shut down quickly and short closes which indicate that the device should not have been shut down so that it would be quickly available when the user reopened it. The statistical correlations may then be analyzed to form a model to apply for determining how much to delay the shut down of a device in the future. For example such analysis may determine that 90 of the instances on weekdays between 9 a.m. and 4 p.m. were short closes so that the generated model causes a greater delay in such situations. It may also determine that 95 of the instances after 5 p.m. when nothing but a web browser were open were long closes so that it may shut down more quickly in such situations.

Certain implementations of the techniques described here may provide one or more advantages. For example a user may benefit from having a computer that does not automatically shut down when he or she leaves a meeting or otherwise closes its cover. As a result the user can immediately get back to work and not have to wait for the computer to restart. Also the user can avoid that awkward situation of trying to balance an open laptop on her arm while standing outside a conference room and then attempting to carry the laptop a paper notebook and open the door at the same time. As a result the user s satisfication with the device may increase and the user may buy more devices from the same maker or recommend them to friends and other acquaintances. At the same time the device can shut down quickly when such action is appropriate and can therefore save electrical energy and avoid generating unnecessary heat. In one implementation a computer implemented computer shut down method is disclosed. The method comprises identifying that a computing device has been moved from an open configuration in which input and output mechanisms on the computing device are accessible to a user to a closed configuration in which at least some of the input and output mechanisms are inaccessible to a user starting a shut down timer in response to identifying that the computing device has been moved from the open configuration to the closed configuration waiting a predefined time period as established by the shut down timer and determining from the shut down timer that the computing device can be transitioned from an active state into a sleep state in which power consuming components of the computing device are powered down and transitioning the computing device from the active state to the sleep state upon determining that the computing device can be transitioned. Identifying that the computing device has been moved from the open configuration to the closed configuration can comprise receiving a signal from a lid switch on the computing device. Also identifying that the computing device has been moved from the open configuration to the closed configuration can comprise obtaining a signal of a predetermined type from a webcam connected to the computing device. The computing device can for example take a form of a clamshell device or of a slider device.

In some aspects the method also comprises monitoring a shut down sequence on the computing device that is initiated by moving the device from the open configuration to the closed configuration and delaying transitioning of the computing device from the active state to the sleep state until the later of the predefined time period and the completion of the shut down sequence. The method can also include receiving from a user of the computing device an input to change the predefined time period and saving the user input for later accessing by the shut down timer and subsequently identifying that the computing device has been moved from the closed configuration to the open configuration and cancelling the shut down timer. In yet other aspects the method comprises subsequently identifying that the computing device has been moved from the open configuration to the closed configuration and re starting the shut down timer.

In another implementation a computer implemented activity control system in a computing device is described. The system comprises a sensor arranged to determine when the computing device has been moved from an open configuration in which input and output mechanisms are accessible to a user to a closed configuration in which at least some of the input and output mechanisms are inaccessible to a user a shut down timer responsive to the determination that the computing device has been moved from the open configuration to the closed configuration and programmed to access data that defines a value for a variable shut down delay period and a computer activity manager responsive to the shut down delay timer and programmed to delay until an expiration of the shut down delay period a transition of the computing device from an active state into a sleep state in which power consuming components of the computing device are powered down. The system can also include a switch arranged to be triggered when the computing device is moved from the open configuration to the closed configuration. Moreover the system may include a user interface programmed to receive a user input of a delay period and to save the user provided delay period as the value of the variable shut down delay period.

In some aspects the sensor comprises a web cam interacting with software to correlate a presence of a predefined image in the web cam with the event of moving the device from the open configuration to the closed configuration. Also moving the device from an open configuration to the closed configuration can comprise performing actions to disable a virtual keyboard on the computing device. In addition the computing device can include a top portion and a bottom portion connected to the top portion by a sliding mechanism and wherein moving the device from an open configuration to a closed configuration comprises sliding the top portion over the bottom portion. In some aspects the system further comprises a shut down monitor responsive to information regarding status of applications operating on the computing device and wherein the computer activity manager is arranged to delay the transition of the computing device from the active state into the sleep state until the later of the shut down delay period and expiration of activity by applications as determined by the shut down monitor.

In yet another implementation a computer implemented activity control system in a computing device is disclosed that comprises a sensor arranged to determine when the computing device has been moved from an open configuration in which input and output mechanisms are accessible to a user to a closed configuration in which at least some of the input and output mechanisms are inaccessible to a user a shut down timer responsive to the determination that the computing device has been moved from the open configuration to the closed configuration and programmed to access data that defines a variable shut down delay period and means for transitioning the computing device from an active state into a sleep state in which power consuming components of the computing device are powered down only after an expiration of the shut down delay period.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

This document describes systems and techniques for providing interaction with a user of a computing device such as a mobile smart phone or netbook using for example elements of an operating system that runs on the device. The systems and techniques may provide various operating system components that may communicate with and be served from one or more hosted server systems in certain implementations. In particular the operating system may be designed so that it is run with an internet connection most of the time it is executing. As a result many of the operations performed by the operating system may be designed to assume that a network connection is available and to rely on caching techniques or other bridging approaches until a network connection can be restore. In particular the devices described here may have nearly always connected wireless data interfaces that communicate with data portions of one or more cellular telephone networks to reach the internet.

Described in particular detail here is a device that can vary the amount of time it takes for the device to shut down i.e. turn off completely or go into a power saving mode that takes more than a mere moment to recover from when a user takes an action sensed by the device that might or might not indicate an intent by the user will not be using the device for a long time and the device should thus go into an inactive state e.g. suspend or sleep mode from which recovery will take more than an insignificant amount of time. The device may make a decision to delay or not delay or a decision to delay a little versus delay a lot where the decision may select one of a few multiple discrete choices for delay or may be made along a continuum of delay based on a number of observations of the state of the device including the state of hardware on the device what devices on the computer are running the environment around the device e.g. the proximity of other objects the time of day the temperature accelerometer and velocity readings using instruments on the device and the geographic location of the device the state of objects running in the operating system which applications are running on the device and what they are doing including whether they are currently displaying documents or other content that may need to be saved by a user .

In the figure three different states of a portable computing device in this case a laptop computer having a clamshell design are shown. In a first state the computer is open and operating and the time is 12 o clock noon. A display on the computer indicates that a lock timer has been set to 10 seconds. The display is provided by way of example here though in actual usage the device would not display the amount left on the timer and the timer would not have begun operating at the point shown by state .

At state after five seconds the display is closed to the base of the computer an action that would normally cause the computer to begin immediately going into a hibernate or other form of inactive mode. Such change would include powering down a microprocessor on the computer turning off the display turning off a cooling fan and other associated mechanisms powering down a graphical processing unit GPU and performance of other power saving techniques on the device. Each of these actions may cause a delay in the operation of the device when the cover is re opened and such delay may be annoying to a user who did not intend to shut down but merely closed the cover momentarily.

Although not shown by the state the device has not fully powered down or begun the power down when it has been closed for only a few seconds because in this example the device has a built in delay of 10 seconds before it will even begin a shut down sequence and there may even be some indeterminate time after that sequence starts until the device passes the point that it can be reactivated without substantial user involvement such as entering an unlocking password . Instead a limited number of features may be powered down such as by switching off the display so as to give the user the impression that the device is powering down. But re activating the device may not at this point require anything more than opening the device again and it may be essentially immediately available to perform work e.g. in less than 1 second or less than 5 seconds for an average power up .

After 14 seconds and 9 seconds after closing the device at state the device is opened up for example because the user of the device decided that they did not want to stop using the device and instead needed to perform additional work using the device. Because the timer was set to expire after 10 seconds the device has not yet transitioned into its hibernating or other powered down state. Instead all systems on the device that take a substantial amount of time to power back up have stayed powered up and only limited systems have been powered down such as the display . Also in this example the timer has been reset to 10 seconds again so that if the user closes the device again it will not begin going into a hibernate or other inactive mode for 10 seconds after the closing. In certain embodiments also the device may immediate go to sleep in response of one input and not to another. For example entry of a control key combination may cause the device to go to sleep immediately and entry of such a combination may be assumed to be more intentional by a user. In contrast closing of a clamshell device may implement a predetermined delay as such action may be more likely to be intended as a temporary action e.g. as a user moves the device from one place to the next .

The particular delay time for beginning a process of powering down a device may be set by a user of the device. For example if the user does not want to maximize battery savings and frequently closes their computer and then immediately or soon after determines that they would like to begin working on their computer again the user may set a relatively long period for the timer to count down before the device begins to power down its various systems to go into a sleeping or hibernate mode.

While the device here is shown as having a clamshell arrangement which would include a switch near the hinge of the computer so that the switch may be depressed when the clamshell is closed and the computer may determine to go into a power down mode other implementations may also be used. For example a flat touchscreen tablet or slate computer may allow a user to power it down by pressing a power button on a front surface back surface or peripheral edge of the device. Such an action may cause a display on the device to turn off immediately so as to give a user the impression that the device is fully powering down. However other subsystems on the device such as a microprocessor memory controllers graphical processing unit and other such subsystems may stay on for the duration of a timeout delay as discussed above.

Apart from powering down systems the timer may be used to delay the onset of a security apparatus being reset on a computing device like that shown. For example certain computing devices may be arranged so that when they are placed into a sleep mode or other inactive mode a password or other security mechanism will be required by a user to bring the device back into fully active mode. Without the timer discussed here a user may be forced to reenter their password if they close their device or otherwise inactivate it and then quickly remember that they need to use the device again. With a timer such as the timer implementation discussed here the user may press a button or open their device quickly after they have done something to inactivate it and they may have a homepage or desktop for the device displayed nearly immediately to them without a need for them to reenter their password or other credentialing information to unlock the device. In short transition from an unlocked state to a locked state on the device may be intentionally delayed a determined and user selectable time period.

As described more fully above the delay time can vary and be computed automatically by the device. For example the delay time can be determine by the device based on a number of variables that can be identified at the time the device is closed. For example as mentioned above the state of applications on the device may be analyzed as may the time of day so that for example a delay is more likely to be imposed or a relatively longer delay will be imposed where the event occurs during a workday and an unsaved document is open on the device. Similarly the orientation of the device motion of the device both as measured via velocity and from accelerometers that might indicate the user is in a car rather than walking and other similar factors may also be considered in making the determination.

Also as noted above multiple such factors may be combined so as to create a score that determines an amount of delay the device will impose before putting itself into an inactive state. For example a combination of time of day and geographic location of a device may be combined and each component may be given a particular weight in computing the score where the score may be linearly related or otherwise correspond to the length of the imposed delay. Similarly a learning system may determine a delay based on prior observations of the state of the device and its surroundings when opening and closing events occur. For example a snapshot of the device may be taken each time it is closed and the time between closing and next reopening it may be recorded. Certain states of the device may then be correlated statistically to whether the user will likely open the device again soon or will not. Those states may then be used in a delay model by which a time to delay the shut down of the device many be a function of the prior learned correlations. Particular learning systems and statistical analysis for such systems are known and may be used in the context of the analysis described here.

In this manner the systems and methods described here can provide for a more convenient user experience with a computing device. The device may delay its powering down slightly after he user has indicated a command to power down and such delay may be used to allow the device to power up quickly if the user changes his or her mind quickly. At the same time the power down delay may be relatively short so that no excess battery power is used up for the device.

In the figure a computer is shown in the form of a basic clamshell laptop computer though the computer may take other forms such as a smart phone touch screen tablet or slate device. A number of visual representations of objects are shown on the screen of the computer and include icons and representations of applications loaded on the computer . For example an icon represents a particular word processing document that is accessible from the computer such as by being stored on persistent storage on the computer or at a server system that is accessible from computer . For example computer may store a cookie or other mechanism by which it may identify itself to a server system to indicate an account with the server system registered to a user of the computer . Such mechanisms may be used by computer in order to obtain information from the server system such as to obtain data that represents the document of icon . A user may then call up the document by selecting the icon.

A widget or gadget is represented by a clock on the display of computer and indicates a type of object that may also be displayed on the computer . The widget or gadget may take a variety of familiar forms and may be provided as code from third parties who draft applications to supplement functionality that is otherwise available on an operating system loaded on device . News feed represents an active application that is running on device in the form of a news aggregator that shows recent current event updates to a user of computer .

Icon represents an object in the form of a persistent search to be performed by computer . A persistent search is a search that is repeated automatically by a device such as computer . For example a user who is planning a vacation to Europe may establish a persistent search of airline flights to Europe so that the user may immediately be notified if a flight becomes available at a certain price.

A pair of boxes indicate contextual data that may be saved in Association with one of objects and . For example box indicates contextual information for a document or word processing document such as document . Various fields are shown in the box to indicate the type of contextual information that may be saved with the object. For example the object includes a name that describes the type of object that it is and an identification number that uniquely identifies the object with respect to all other objects stored on the computer .

The box also shows a time at which the object was initially created and a list of objects that were also open on the computer when the object was created. In addition the box includes a list of other objects that were open the last time the object was used. In this example a user was reviewing the website www.test.com both when the word processing object was created and the last time it was used. Also when the word processing document was created the persistent search object was active on the computer . Such a concurrence may indicate that the document was created by the user to contain information generated by the persistent search. A further stronger inference in that regard may be formed for example if the user copied the information to a clipboard from the persistent search results created the document and then pasted the search results or other copied data into the document. Such information may also be stored in association with the object as shown in box e.g. by determining when the document is last saved what information in the document is shared by other applications that are open at the time thus indicating that content was copied between the document and the object .

The box also shows objects that the document object has interacted with. In this example the document has interacted with an application web printer which may indicate that the document has been printed out on that printer. Particular direct interactions between objects may be stored because they may provide an indication of especially strong connections between the object and other objects. Such connections may be used to identify a user who is an intended user of an object in particular situations.

Box indicates contextual information that has been stored in associated with object . Again the object s named includes a unique identification number along with a time at which the object was created. As indicated in box four different other objects were active when the persistent search object was created. Those other objects include a word processing document a spreadsheet document and two different webpages that were being viewed on the computer when the persistent search object was created. Also box indicates that the persistent search object has interacted with a mapping application and a contacts application on the computer . Also an access log indicates the times at which the object has been accessed by a user and may also include information indicating what the user did with the object.

Using the information shown here a variety of services may be provided to a user with computer . For example when object is next launched on the computer the computer may look at the information box actually to data stored on the computer or another device though box represents such data in this figure to determine that a user of the device frequently has had the www.test.com webpage opened in a browser when the particular document has also been open for word processing. Such a determination may be used in appropriate circumstances to automatically launch the browser with that webpage active in the browser when the document is opened. In such a manner the user may cause multiple inferentially related applications to be activated by selecting only one icon for one of the applications.

In one implementation where the device is a telephone after turning on the telephone the telephone s operating system may be loaded from persistent memory and may present a graphical user interface containing a predetermined display of icons to the user. Each icon can be either an application or a proxy for an application available to the user when selected a chosen icon may if necessary pass the associated application s parameters and file location in memory to the operating system which in turn can execute the application . Each executed application uses a segment of the telephone s persistent memory as an application continues to run its memory requirements may increase. As the user executes more applications or the running applications consume additional memory the telephone s memory may eventually become inadequate to accommodate the memory demands of the applications .

In an exemplary implementation the memory management system may respond to memory shortages by terminating one or more applications when persistent memory has been exhausted and reviving the terminated application when the user returns to the application. In certain implementations because the terminated application window may be either fully or partially obscured by another application window the user may not be aware that the application has been terminated. When a user chooses to switch back to the application the application may be re launched and the user may not know that the application was temporarily terminated aside from perhaps a sluggish response in displaying the application.

In an illustrative implementation the operating system can rank the applications according to a user s interactions with the graphical user interface and each application may generate and save information regarding its current state in response to a signal from the operating system. The applications may save such state information themselves or may provide the information to the operating system which may in turn save the information to persistent storage e.g. flash memory .

If memory is exhausted the operating system may terminate one or more ranked applications and later recreate the terminated applications in response to a user request. For example once the operating system has loaded the user may select a document viewing application to read a stored document. Subsequently while the document viewer is still running the user may open a web browser and begin surfing the Internet. In the midst of the web browsing session the user in response to a notification that an email has arrived may select the telephone s email application to review the new email. As the user is reading the email the user may attempt to run a calendar application to create a reminder for an event mentioned in the email.

In an exemplary implementation as the user opens new applications the operating system may rank the applications according to one or more dynamic criteria. Here the operating system might rank the running applications in descending order of importance in the following manner email application web browser and document viewer. Such ordering may occur in various ways. For example the applications may be separated into various categories such as necessary business applications entertainment applications etc. In some implementations the operating system may recognize that a particular application lays dormant when it is in the background so it may classify that application as low priority. But another application may be constantly accessing information over a network e.g. a messaging program and may thus be ranked as a higher priority application. In some implementations applications are divided into two categories visible and invisible applications. Invisible applications i.e. those applications whose windows are not visible to the user are ranked lower than visible applications. In an alternative implementation the developers of the applications may self classify the applications or the user may classify or otherwise rank the applications and such classifications or rankings may be provided to the operating system .

As the user interacts with the applications each application may generate and save information regarding the current state of the application. For example when an application enters a state where it could be killed by the operating system at any time e.g. the application is no longer visible to the user the operating system may instruct the application to save its current state.

Returning to the illustrative example because the telephone s memory might be insufficient to run all four applications at once the operating system may choose to terminate the lowest ranked application in this example the document viewer as it opens the calendar application because it has run out of memory. In an alternative implementation the operating system may predict a pending memory shortage and terminate one or more applications to prevent memory from running out. For example if the amount of memory currently available drops below a predetermined threshold the operating system may kill low ranking applications to bring the amount of currently available memory above the threshold. In an alternative implementation the operating system may compare upcoming memory requests by applications with the amount of memory currently available if the amount requested exceeds the amount currently available the operating system may kill one or more applications.

In such a situation the operating system may identify the lowest ranked application or applications and terminate them temporarily. The operating system may also set a flag as an indication of applications that may need to be re launched automatically at a later time e.g. when memory frees up 

Selection of an application to kill may occur by other techniques. For instance the operating system may determine the amount of memory that is needed by a particular application and then identify other operating applications that can free up that amount of memory plus a certain safety zone of overhead memory. As one example an application might require 3000K of extra memory and three other applications might each be capable of freeing up 2000K 3000K and 35000K of memory respectively. The operating system may determine that the least damage to memory or the best use of available memory may be accomplished by killing the first two programs because they most closely approximate the amount of memory that is needed. Alternatively the operating system may be programmed to prefer killing as few applications as possible. In such a situation the third application in the example would be killed.

Once the user has finished using the calendar application the user may choose to return to the document viewing application. When the operating system detects an attempt by the user to return to the document viewing application which has been killed temporarily the operating system may recreate the application using the saved state information.

To do so the operating system may first sense a command to access the document viewing application and may note from the stored flag that such application was active but has been killed temporarily. The operating system may then launch the application and pass the saved state information to the application so that the application may be recreated in the form it was in or substantially the form it was in when it was temporarily killed. Alternatively the application may have stored its own state information in cooperation with the operating system and may itself access and implement such information.

The first process may be for example a document management program that displays one or more documents . The document management program may be for example a word processing application or a Web app that implements a word processing application in a Web browser. In certain instances the Web browser may be part of an operating system wherein the Web browser is the only native application for the operating system and all other applications operate as Web apps inside the Web browser.

The second process shows the execution of a mapping application . For example a different Web app running in a system may access a server based mapping service and may provide information in generally known manners for display of a geographical location using graphical tiles of a mapped geography. For example a location of a user of a device that is executing the processes may be indicated on a map using a pin or other icons. The separate processes may also be represented on a device as separate tabs at a single Web browser where the processes are sandboxed from one another including by implementations that generally prevent communications between different domains from occurring within a Web browser.

A set of arrows passing between the processes indicates messages and information that may be communicated from one of the processes to another and vice versa. For example a message may be initially sent from process to process . For example the message may indicate information that would cause a display for process to change. In this example for instance the message may include a latitude and longitude or address description that may be used to cause a different area of the map displayed in the mapping application to be shown.

In addition the process may pass to process information about the manner in which a command or commands that relate to the message are to be carried out by the process . In this example the information is in the form of a priority command . The priority command may notify the process regarding the priority that it should give to its execution relating to the message . For example if process is not a time sensitive form of process the priority command may indicate that a response to message is not to be treated as a high priority by process .

The message and priority command may be passed to process separately or together and directly or indirectly depending on the particular circumstances. For example when the message and priority command are passed together in a single larger message the process may parse the larger message to identify the message portion of the message and the priority command that is embedded within the message. In other examples additional information may be included with the message and may be identified and processed as is appropriate for the manner in which the process and the process are programmed to operate and interoperate. Interoperability of the process and the process may be maintained by the two processes adhering to an application programming interface API or other similar standard for formatting communications between the processes.

In certain implementations the process may pass a message back to the processor . One such message is a confirmation that indicates to the process that the process has fully acted on the message . In certain implementations the confirmation may occur simply by the process providing information back to process in response to receiving the message . In this particular example such information may include an image of a mapped area determined by the application that may be automatically integrated into the document that is being managed by process .

In this manner inter process communication may be enhanced by allowing one process to communicate additional information to another process including when the processes are part of separate windows or tabs that run in a sandboxed environment in a Web browser application. Such communication may allow a first process to control the manner in which another process executes certain code including the priority to which the second process gives the execution of the code. As a result tighter interoperability between processes may be provided while still maintaining high levels of security that prevent one of the processes from illicitly controlling or affecting one of the other processes.

The system in this example includes a computing device that communicates through a network such as the Internet and related connected networks with a server system . The server system may be housed as part of a larger data center in a system that provides various Web services to users of the system . For example the server system may include one or more Web servers that may provide HTML code for generating documents for display on the computing device .

The computing device includes a number of particular components that allow state information for the browser application which would normally be a stateless application to be stored so that a state of the computing device may be replicated at a later time on the device or on another device. For example if the user puts device into a sleep mode or turns off device the most current state of the device may have already been saved to server system e.g. when the user performed his or her last action with a web browser or may be uploaded to server system before the operating system allows the device to go into a sleep mode fully. The state information may have been previously stored at the server system for example if the device is programmed to upload an indicator of a change in state information every time there is a change in state information on the device . The state information may include document object models DOMs for pages currently displayed on the device in addition to other relevant information needed to recreate the state of the device.

Referring now to particular components that may be implemented in device a browser application is shown and may be an only application that executes natively on the device . Separately HTML may be stored on the device so that it may be rendered by the browser application . The HTML may take a variety of forms and may be represented in one or more examples as a document object model DOM tree. Also the device may store and implement JavaScript and JavaScript variables . For example when the HTML is rendered the HTML may include pointers or calls to various JavaScript programs that will run on the device . Those programs when executing may retrieve or generate variables or other information needed in the operation of the programs.

Also a user interface may be stored on the device and may represent various parameters including a current representation of what is displayed on a visual display or screen of the device . For example the user interface may store information about what tabs of the browser are open at a particular time and or whether a different type of applications supported by the operating system such as a floating pane displayed over the top of the browser as a particular state and other appropriate information that may be used to describe the current state of the display on the device and may be further used to reconstruct a display that matches the current displayed information on device .

A webpage saving application may also be implemented on the device and may track a current state of the browser and other browsers or other programs executing on the device . For example the webpage saving application may intercept calls to or from particular components on the device to determine changes that have been made with respect to content represented by the browser or to other information. The webpage saving application may then cause a communication to be generated by device and directed to server system to indicates a change that has been made in a current state of the browser . For example the device may provide to the server system information indicating that a browser tab has been opened and also providing a URL for that tab.

The webpage saving application and other components on the device may also have access to a data store of images . In certain aspects the images are simply operating system level images such as images for general icons and other basic information that is needed to run the device and to recreate the state of the device . The images may also be images on webpages or images used by Web apps on the device and may be stored on behalf of webpage saving application for later access in or by the application .

Using the system described here in one example the current state of the user s device may be captured and uploaded to a server system . The user may then move to another computing device such as by moving from a home computer to a network computer and when the user has booted up the other device and perhaps provided credentials to identify themselves to the server system either manually or via a saved cookie on the other device may have the full state of device replicated at the work computer or other such device. As a result the user may switch from one setting to another or may come back to a place they left more conveniently and may be able to use applications on the device more efficiently. For example if a user sets up applications or Web apps that are executing in the browser on the user s behalf the user may want keep those Web apps running at a later time or at another device. For example a user may prefer to have an email Web app a document editing app a mapping app and a general web browsing window open at all times and the state replicating techniques can allow the user to do that without having to manually recreate the state whenever the user moves from one machine to another.

Other components of system may be used to affect the manner in which the device enters an inactive state when a user provides an ambiguous indication about whether the user wants the device to enter the inactive state i.e. the user indication could be reasonably construed as a intent to stop using the device for a short period of time e.g. under 5 minutes or under 10 minutes or for a longer period of time e.g. more than 5 minutes or more than 10 minutes or more than 15 minutes . For example a timer may be included to recognize that am ambiguous user indication about whether to shut down the machine has occurred e.g. a cover has been shut the user has stopped typing or there has been a stop of other interaction such as touchscreen input and may begin counting to determine when a sufficient time has expired so that a shut down sequence can occur. A delay module may identify relevant variables for determining the delay period at the time of the event and may provide a time to the timer that is determined by the system to be an appropriate delay time under current circumstances. The variety of factors discussed above may be taken into account by the delay module . Also a learning module may obtain from the timer the times at which the cover was closed and reopened and may also gather data about the state of the device when such changes occurred such as the time of day the geographic location of the device e.g. using a GPS package the orientation of the device the applications executing on the device the content in any of those applications and the like. The learning model may analyze such information across many different instances of opening and closing the device and it or a separate server system may perform statistical analysis to develop a model that defines when a user is likely to want to use the computer again soon after shutting it and when the user is not. The particular data used by the system may be always particular for the user or may be data compiled for a number of users and provided by a server system to the device . Both types of data may be static or may be provided in a default form initially and then may be updated using the learning model and observations about actual activity over time for the user of the device .

In this example the device is shown as storing an image . The image may define what components are persistently stored on the device . For example an image may include basic operating system components beyond the firmwear on the device in particular programs where a single program may be part of the image of an operating system on the device that has a single native program in the form of a Web browser. Generally images may be used to ensure that multiple computers have a common baseline of components in them so as to improve the ability to manage and maintain the operability of such computers. In particular a company may want a certain number of software components available to its employees and other components not available so it may define an image and may install that image on the employees machines when they are first deployed.

Within this example the server system cooperates with the device and other devices that receive services from the system in order to maintain or repair images on the devices. As shown in the figure a number of particular components may be employed by server in providing such services. For example an image interface may be provided to interact with remote devices like device . The image interface may for example communicate with the devices to verify that the image on each of the devices is still accurate. For example where no applications are allowed to be added to a device such as when the only native application is a browser in the additional applications are web applications that are not persistently stored a hash may be made up from the native components on the device and that hash may be stored and compared to a subsequent hash that is computed each time that the device is booted. If the hashes do not match that may indicate that the core components for the operating system on the device have been compromised. In such a situation the device may send a message to the image interface which may cause the interface to in turn cause other components of the server system to perform certain operations.

For example an image re constructor may be programmed to identify gather and assemble particular components for an image which may be a replacement image for device . The image re constructor may initially look to an image index to identify the form of an image that is supposed to be installed on device . For example a particular revision number for an operating system may be provided for the device . Alternatively devices by different manufacturers or user bases may each have a custom image though devices in a line provided by a single manufacturer may have a common image. Therefore the image index may be able to receive an identifier for a manufacturer and model of a device or of a company that operates the device and to identify an image that is to be built in response to a request from such a device where the image may be built from common interchangeable components stored by the system .

In this example an image may be built up from image fragments. For example certain levels of an operating system may be part of the image and each level in a modular operating system may be a separate fragment for the image. Also different features in a common level may also be considered and stored as separate image fragments. The image re constructor or an image updater may use information from the image index which for example may map an image identifier to the various fragments or components that make up the overall image.

Also user device maps may perform functions like those previously described for the image index including by mapping particular users or user groups or particular types of machines to particular images. For example a user of a device may log into system and be provided with one or more webpages on which the user can select particular components or fragments for the image they would like to have presented on their device . Those components may be saved in association with an identifier for the user so that subsequent attempts to rebuild the image can automatically select those components that were previously selected by the user.

With an image reconstructed the image updater in cooperation with an operational interface that may control general operations and coordination between the components discussed here may supply an updated image through the image interface and the network to the device . The update may include an entire image for the device such as when the device has been wiped accidentally or purposefully through the network by the server system .

In certain implementations the server system may be employed to remotely wipe an image from device and in certain instances to replace the image with a new image. For example if device is stolen the system may wipe the image on device and may use an identifier that may be incorporated into firmware on the device to prevent the device from obtaining an image again. Alternatively the device may be remotely wiped by the system and may then be recovered by the proper owner so that the server system may then provide a new and updated image to the device once the owner has verified that the device is back in the proper hands.

For example when the device is initially being booted up a public key may be stored in a small read only segment of the firmware and the key may be used to check the kernel on the device . The key or a different identifier such as a hashed version or other hashed version when the key itself is a hashed version of one or more of the operating system components on the device may be checked against the components on the device at the time of booting such as by running the components through the same hash function that created the original identifier. If a match is not made that may indicate that the device has been compromised because the core code has changed when it should not have changed and that someone has attempted to change native files on the device for such as to turn the device into a bot or for other purposes.

A communication interface at a low level of the operating stack may then make a network connection to the server system before the user can interfere with the boot sequence and may indicate that a failure in the image has occurred on the device . The server system may then use the components discussed above to build a new image for the device and transfer the new image to device . Device may then replace the potentially corrupted image with the new image and operate with the new image including by completing the compromised image.

The device may also pass the compromised image or data that characterizes the compromised image back to the server system . The server system may then analyze the compromised image in an attempt to determine what caused the compromise. For example the server system may compare the compromised image to compromised images from other devices that were assigned the same initial image by the server system . If a number of matching compromised images are identified such an identification may indicate that a coordinated attack has occurred by a single entity against the devices.

Thus in the manners discussed here a remote re imaging system may provide mechanisms for updating a device such as device in a convenient manner. For example because the device does not persistently store much code frequent updates to an image may provide minimal disruptions to a user of the device . Also the use of cloud posted image data as discussed above may provide a convenient manner for wiping particular client devices and then reimaging them from the server system . In addition the server system may be able to store images for a large number of different user devices by simply using interchangeable components that together make up an entire image and then mapping combinations of those components to particular devices in the user device maps database so as to be able to reconstruct a particular image from a relatively unique combination of building blocks that are common across all devices or a particular large group of devices.

One example mechanism for identifying security breaches at an early stage during the boot process is shown by the example stack in the figure. The stack in this example is relatively compressed and includes at its lowest level a BIOS which may be implemented in firmware. The BIOS may perform traditional operations for a BIOS and may also include code for establishing a limited network connection with the server system . The limited connection in this example is used to report nefarious activity from the device to the server system before the boot process has gotten to a level that can be hacked easily or from the server system to the device . As one example a user may discover that the device has been stolen and may log on to the computer system using computer . The user may then request that the device be wiped shutdown or that it take a picture of the current user and report a current location of the device or other appropriate action. When the device is next booted the BIOS may notify server system through a message sent by way of network hardware which may include mechanisms for performing wireless communications. The server system may respond back with a status message. Normally the status message may indicate that everything is okay. However since the user has logged in and reported the device missing the server system in this example indicates to the device that there has been a problem.

The server system as shown by a return arrow between the network and the device may provide instructions for the subsequent operation of the device . For example the server system may instruct the device to take a digital image of a user of the device such as when the device senses that someone is typing on the device . Device having been fully booted up may upload the picture automatically and without notifying the current user presumably a thief . In addition such image may be accompanied by GPS data that indicates a current location of the device . In this manner law enforcement authorities may know where to go to recover the device and may also have proof that a particular user was using the device while it was stolen.

The remainder of the stack for the booting of device is also relatively compact. For example after a basic security check has been made using the BIOS code code for an operating system may be executed and basic components of the operating system may be launched. As part of the operating system launch or as part of a similar but separate action services may then be opened and made available on the device and applications such as a dedicated native Web browser application for the operating system may be launched.

Security checks may also be performed automatically and periodically including after a full boot has occurred. For example a watchdog timer may run on the device and may cause security on the device to be checked periodically. For example the stack shown here may be in its own system partition and when it is updated may have a function applied to its code so as to create a hash value. When the watchdog timer is triggered a similar hash can be performed to whatever the stack contains at the time if the operating system is one in which each of these components is always in the stack and does not change except during an update. The new hash may then be compared to the stored hash for the stack Hashes may also be performed on fewer than all the components in the stack . If the value has changed the server system may be notified and may subsequently send out a signal to the device such as to lock down the device to wipe storage on the device to reformat a storage medium on the device or to perform other such operations. The server system may also notify the legitimate user of the device by a back up channel such as a work email or text message notification.

The device in reporting problems to the server system can report immediately upon discovering a problem or a later time. For example the BIOS may generate an identifier to indicate problems with the device . The BIOS may then allow the other components of the stack to be executed so as to make the device fully featured. Once the device is fully booted up the network hardware may be caused to provide the identifier to the server system so that the server system knows and understands that the device has problems and so that the server system may send to device appropriate messages such as messages to reboot and reboot a particular process or processes and erase a storage medium on the device or to reformat a storage medium on the device .

In the figure the device is shown storing three particular values A B and C. Similarly server system is storing two of those values in the form of A and B in a corresponding manner. The server system is also storing a value for D. The values for A and B in storage are shown with brackets around them to indicate that those items are dirty and may not be trusted by other devices attempting to access the storage because they may have been changed by device in storage . Essentially the server system operates as if the device has checked out those values though if a request is made for them by another device the server system may inquire of the device to get their latest values and get control of them back from device . Also as shown in the figure only item B has been changed at the device from the version of the item that was obtained from the server system as shown by an apostrophe on item B in storage .

While operating device may perform various operations that result in values for items A B and or C being changed. At an appropriate point in time the device may submit such changes to the server system which may in turn update the values for the items in storage . The device may also indicate that it is done using the items and in response server system may unmark the items as being controlled types of values in the system . In this manner data may be cached conveniently between a Web app running on device and a data store for a server system .

The delay that is purposely introduced by the process described here may allow the user to get back into the device within a short time period after they indicate that they would like the device to go into a sleep or locked mode in case the user quickly changes their mind and needs to use the device again before fully putting it into the sleep mode. Where the delay is appropriately timed and short such a delay may introduce a minimal security burden to the process in that the proper and original user is likely to stay near the device throughout the delay period so that an interloper cannot take the device before it transitions to a locked mode.

The process begins at box where it begins monitoring a computing device to determine whether a user has indicated that it should perform a particular action. At box the process receives a user input regarding a locking time. For example a user may configure their computing device so as to have a delay before changing the device into a sleep mode that can vary for particular users. For example in this instance a user may identify a delay of 9 seconds so as to provide an adequate time for the user to change his or her mind and reestablish an active state of the device. In response to the users input regarding a delay time for locking the device at box the process adjusts a locking time parameter for the device. Such a parameter may be permanently stored on the device so that from one session to another the delay period for locking the device is the same and the user can begin to feel comfortable that they will be able to reanimate the device quickly if the time has not expired.

At box the process identifies that the device has been moved from the open configuration to a closed configuration such as by the user closing a shell cover on the device to push a power switch on the device or by the user directly pressing a switch to turn off the device or move it into a sleep mode. The relevant transition discussed here is a transition that requires substantial user input to return to an active operable mode for the device such that it is more than simply moving the device from a closed to open configuration that might turn off the screen but be readily reversible in that the device is not locked and substantial components have not powered down in response to the mode change. Nonetheless to give the user feedback that their input has been received a screen on the device may be blanked immediately after the device moves from open to closed configuration even though a delay in moving the device to a sleep mode that requires substantial user input to recover from is ongoing.

At box the process starts a shutdown timer that is tied to locking of the device at the expiration of the time parameter. The time parameter in this instance is the parameter that was selected by the user at box and applied by the device at box . For example the device may blank the screen and start a 9 second countdown timer as soon as it is closed but may not move to a different mode until the timer has expired. Thus at the process repeatedly checks to determine whether the time that was set has expired. If it is not expired the process checks at box whether the device has been opened. If the device has been opened the process returns to monitoring the computing device at box . Subsequently a user may set a new time in for the locking timer or may again move the device from opened to a closed configuration and thus repeat some or all of the actions discussed here.

As described above the particular amount of time applied by the timer can vary in a number of ways both based on the state of the device and surrounding context and on the manner that a user uses the device over time. For example as explained in detail above a number of parameters may be measured at the time of the input to enter the locked mode and may be combined to compute a delay period for a timer. And the actual use of the user may be tracked over time by correlating the state of the device via the various variables discussed above at the time of the locking input to how long it took for the user to start using the device or trying to use the device e.g. because the user was required to enter a password into a locked device again.

Once the timer does expire then the process locks the device at box . Such locking of the device may in addition to requiring user unlocking input to bring the device back to an active state also involve slowing particular processors on the device or removing the power to them entirely turning off a display screen turning off the air circulation fans and other items that draw electrical power and waiting for the user to reactivate and unlock the device.

The process begins at where the object is instantiated in an operating system. The object may take a variety of forms and for illustrative purposes here is a word processing document that may be edited in a word processing application. At box the process identifies contextual metadata that defines the state of other open objects at the time of the initiation. For example a user may have a Web browser open to a particular URL and the process may store an identifier for the Web browser and for the URL. Such contextual metadata may be relevant if it indicates that the user was viewing a webpage and then decided to take notes about the webpage in a word processing program. Thus it may be beneficial to create and store a correlation between the webpage URL in a browser application and the word processing document in a word processing application. And as a result the contextual metadata is stored at box and the information regarding the instantiated object is stored at box .

At box the object may be closed after a time such as after a user types information into a word processing document and is finished editing the document and subsequently a request may be received to open the object such as when the user wants to edit the document some more. When the object is reopened various other applications may be running at the time and they may again be relevant to the reason that this document was opened by a user. Again for example browsers may be open to topics that are relevant to the user and by extension relevant to the document that is the object.

As a result and to capture such information at box the process updates contextual metadata with information about the open objects other than the instantiated object. Thus the metadata repository for the object which may be part of a domain file that represents the object itself may be created added to and updated as the user continually opens closes and manipulates the object where the data tat is added t oit represents the context on which the object existed in each circumstance including as defined by other applications that were executing at the same time and information about what those other applications were doing. Thus at box the user goes through other cycles of closing and opening the object and the metadata is updated.

Such contextual meta data may eventually be used when it is determined to be sufficiently indicative of a user s intent to perform automatic actions. For example when the user opens a document a system may simultaneously executed a search to a search engine in a browser and may display the search results with the document if analysis of the contextual metadata indicates that the user typically performed the search upon opening the document e.g. if the document tracks stock prices for a company and the searches on the current price for the company so that he or she can cut and paste it into the document. 

Referring to a process illustrates the lifecycle of an application in the exemplary method for managing potential memory shortages on a computing device. The method begins at step where an application is executed. For example the operating system may load an application from persistent memory in response to a user request or at the behest of another application. Next at step the system determines whether the state of the application has changed. In some implementations the application monitor can note when an application takes focus when a new application has been created or when application has been terminated. In an alternative embodiment in addition to or in lieu of the changes mentioned above an application manager may monitor user inputs to the system e.g. key presses mouse clicks stylus or finger taps etc. to determine when an application may have changed state.

If a change of state is not detected the method proceeds to step where the system determines whether a memory shortage exists. If the system determines that a memory shortage does exist the method proceeds to step discussed below. If however a memory shortage does not exist step is repeated.

Once a state change is detected the method proceeds to step . At step state information is generated and stored. Because applications in certain states may be killed at any time after an application monitor detects a state change the application monitor may instruct the application to generate and store state information in persistent memory. In an illustrative implementation the state information may include information used to recreate the application as the application existed before it was terminated. For example the state information may include but is not limited to the location of the application s window on the display any changes to an application file made by the user and the user s preferred view mode. Once the state information is generated the application may store the state information to persistent memory.

After state information is generated and saved the method proceeds to step where the system determines whether a memory shortage exists. If the system determines that memory has run out the kernel may instruct the application terminator to make memory available by killing one or more applications. In an alternative implementation the kernel may determine whether memory is becoming scarce. The kernel may detect an imminent memory shortage by comparing memory requests from the applications with the memory currently available. The kernel may also determine whether the amount of memory available is lower than a predetermined threshold value. When a shortage is detected the kernel may take steps to free enough memory to ensure that selected applications will have sufficient memory to continue normal operation.

If the system has determined that memory is needed the method advances to step where an application terminator determines if the application is the lowest ranked application i.e. whether the application is at the bottom of the application hierarchy. If the application is not at the bottom of hierarchy the method returns to step where the system monitors the application for a change of state. If the application is at the bottom of the hierarchy the method proceeds to step where the application is killed. In some implementations the application terminator determines whether the application is the last application in a program stack. If so the application and any associated threads are killed.

At step they system determines if the application should be revived. In an illustrative implementation if the system detects a user attempt to return to an application that was killed the method returns to step where the application is revived using stored state information. For example the system may detect attempts by the user to close or minimize windows overlaying the killed application. In response the system loads state information for the application from persistent memory and uses the stored information to revive the application.

If the system does not detect an attempt to interact with the killed application the method returns to step where the system again determines whether to revive the application.

At box and after the processes have been running for a time process eight may determine that it needs action by process be or needs to receive information back from process B. And as a result at box process eight passes a message with information defining how fast that process be needs to work on the message on the half of process a. Thus at box Paul Blake process be receives the message and separate the main body of the message from the priority information at box . Process be then uses the priority information or other information that may be passed from process A. with the message to determine how to handle the message. For example process a may need a report on the current state of a computer device in order to complete its work and if waiting for information to do that will substantially slow and I ll let from process say that is needed immediately by the user process may a a provide information telling process be to prioritize its operations above all others. Thus at box Paul hundred process be may change its focus based on the priority information. For example if process be was previously working through a long but not time sensitive process it may state save state information for such activity and may put aside its work on process be intelligent has responded to process eight. In this manner processes can communicate back and forth with each other in a convenient manner and so as to provide more focused responses for requests that are made through the processes.

The process begins at box where a user operates a computing device in a normal manner. The computing device may execute an operating system that runs a single native application in the form of a Web Browser and other applications are run inside the Web browser such as running as Web apps. Each pane in the browser and each of the Web apps may be sandboxed in its own isolated process for security purposes.

At box the process periodically or in response to a state change on the device saves an image of one or more active DOMs on the device. Such activity may occur when the relevant state is the current status of a web page such as whether a user has interacted with active content e.g. JavaScript created content on a Web page. Other state information as an alternative to DOM information or in addition to the information may also be saved so as to fully capture the current state of the device and of different processes in the device. For example a list of each of the active processes on the device may be maintained and updated and particular parameters that define the current state of those processes may also be updated. Such information may at the same time or later be uploaded to a server that is providing information to the computing device and the server system may organize the information so that the last saved state of the device can be reconstructed later.

At box a request for such a reconstruction occurs. For example a boot process for a device that is registered via the server system with the same user as the first device may reach out to the server system automatically to obtain the most recent state information for the user account of the registered device. The server system may then access stored images for the particular device where a user or group of users may define an image for their devices that the devices are to take on automatically when they are booted . Also the device may use data that is associated with components of the image to reconstruct Web pages and other objects to the state they were in when the user last used a computer that was registered to the user s account with the server system whether the earlier computer and later computer were the same or different from each other.

The process begins at box where multiple different client devices are operated in ordinary manners by users of the devices. Each of the users may establish parameters for an image on their particular device such as at box and may submit the device images to the hosted server system which may receive the images at box . For example the user may want particular applications such as Web apps to be loaded when they boot their device and may want settings on the device set in a particular manner.

At box the server system compares images for particular devices to stored data at the server system. For example the server system may store components that together make up various different images and may simply store one copy of each component and a basic textual or similar file that maps the components to each of the images for the client devices. For example a binary list of digits may be used to identify an overall image were each position in the list may identify a particular component that may or may not be present in a particular image and where the presence of a one in that position for a particular device may indicate to the server system that the device has the particular component in its image. Thus for example at box the process replaces portions of the device images with smaller synonyms. In the example just described the synonyms may be simple bit values whereas in other implementations the synonyms may be alphanumeric identifiers that are unique for particular components in the system.

At box the server system saves a reduced size image with a device identifier that points to the device that belongs to the particular image. For example the system may store code for particular components at one location and may store a device identifier that is unique for a device along with the binary stream discussed above and in other location.

At a later date a particular device may request an image as indicated by box and the server system may access the image for that device and expand it at box . As one example a device may request an image every time it is booted and may not store its image locally when it is off. Such expansion may involve stepping through a binary list like that discussed above with the server system and gathering components where each value in the list is a one rather than a zero. Other techniques for gathering components or otherwise building an image for a device may also be used.

At box the server system transmits the image that it has built back to the client device at box the client device loads the image and allows the device to be operated fully by a user of the device. And using the techniques discussed here image data may be stored a hosted system in a manner in which its size is reduced across the system particularly when a large number of devices operate with respect to the system.

The process begins at box where a device is turned on by a user. At box the device accesses its boot firmware and begins the boot process in a familiar manner. The firmware may be part of a bios or other structure on the device. The firmware may also include mechanisms for wireless transmission between the device and the hosted server system and at box the process uses such functionality to send a message to the hosted server system. The message may be treated as a request to identify a change in circumstances of the device since the last time the device checked in with the hosted server system. At box the server system receives the message and identifies the device and parameters of the device. For example the hosted server system may use a device identifier to determine whether any events relevant to the device have occurred such as the user of the device reporting that the device has been stolen and should be locked out or wipe or reformat it. In addition the identity of the device may be used as discussed with respect to to identify an image for the device and begin gathering components for providing the image back to the device for further booting of the device.

At box the server system accesses stored information about the device such as that discussed immediately above with respect to reports by a user of the device and whether the device has been stolen. At box the server system generates and transmits data for actions to be performed on the device. As discussed with such actions may include providing an image for the device that is to be executed in booting by the device. Such actions may also relate to security to be implemented with respect to the device. For example if the message that was sent by the boot firmware indicates that that part of a stack on the device has been changed since the most recent update the actions to be performed on the device may include wiping the device or reformatting a storage structure such as flash memory or a hard drive on the device. Similar actions may be performed in response to an external indication from a user of the device that the device has been stolen. Thus actions on the device may be responsive to information received at boot time from the device or responsive to other information that is not received from the device but that is received from an external source such as a user calling in a report.

At box the client device receives the data and instructions and at box the client device uses the boot firmware to process the data that has been received and or to execute instructions that have been received. Other types of instructions that may be received include instructions to report back information about the device so that the device can be recovered. For example the device may take a digital photo using an onboard camera in an attempt to capture an image of a thief who is using the device and may transmit back the photo along with GPS data that indicates a location of the device as discussed above.

The process begins at box is and where both the client device and the hosted server device store account based information for the device. For example each device or system may store a user ID for a device that correlates the device to a particular user account with the hosted server system. At box the client device requests server side information and at box the hosted server system obtains the requested information and transmits it to the client device. The hosted server system may also store information for identifying changes that will be made to the request information in the future. In certain implementations the hosted server system may assume that any information that is provided to the client device for editing will be edited so that the hosted server system may mark or at least provisionally mark such data as being dirty when it is passed to the client device. At box the client device receives the requested information and in response to user interaction with the client device it may modify the requested information. At an appropriate time the modified information is transmitted back from the client device to the hosted server system. Such an appropriate time may be determined by a clock that periodically provides information back to the server system or by a particular event such as a user selecting a defined control in an application.

At box the server system receives the modified information and at box it uses stored information to identify changes to the requested information. For example the system may compare the information that is received back from the client device to the information that was previously marked dirty to determine whether any relevant changes have been made to the information that was given to the client device. At box the server system may replace a subset of the information with the updated subset. Thus for example where the system determines that there is not a match between the dirty data on the system and the data received back from the client device the server system may insert the changed information from the client device.

Computing device includes a processor memory a storage device a high speed interface connecting to memory and high speed expansion ports and a low speed interface connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as display coupled to high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In one implementation the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device memory on processor or a propagated signal.

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of functions is exemplary only. In one implementation the high speed controller is coupled to memory display e.g. through a graphics processor or accelerator and to high speed expansion ports which may accept various expansion cards not shown . In the implementation low speed controller is coupled to storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In addition it may be implemented in a personal computer such as a laptop computer . Alternatively components from computing device may be combined with other components in a mobile device not shown such as device . Each of such devices may contain one or more of computing device and an entire system may be made up of multiple computing devices communicating with each other.

Computing device includes a processor memory an input output device such as a display a communication interface and a transceiver among other components. The device may also be provided with a storage device such as a microdrive or other device to provide additional storage. Each of the components and are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the device such as control of user interfaces applications run by device and wireless communication by device .

Processor may communicate with a user through control interface and display interface coupled to a display . The display may be for example a TFT LCD Thin Film Transistor Liquid Crystal Display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may be provide in communication with processor so as to enable near area communication of device with other devices. External interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. Expansion memory may also be provided and connected to device through expansion interface which may include for example a SIMM Single In Line Memory Module card interface. Such expansion memory may provide extra storage space for device or may also store applications or other information for device . Specifically expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example expansion memory may be provide as a security module for device and may be programmed with instructions that permit secure use of device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory as discussed below. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory expansion memory memory on processor or a propagated signal that may be received for example over transceiver or external interface .

Device may communicate wirelessly through communication interface which may include digital signal processing circuitry where necessary. Communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. Such communication may occur for example through radio frequency transceiver . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to device which may be used as appropriate by applications running on device .

Device may also communicate audibly using audio codec which may receive spoken information from a user and convert it to usable digital information. Audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on device .

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium computer readable medium refers to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

A number of embodiments have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. For example much of this document has been described with respect to television advertisements but other forms of future viewership based advertisements may also be addressed such as radio advertisements and on line video advertisements.

In addition the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other embodiments are within the scope of the following claims.

