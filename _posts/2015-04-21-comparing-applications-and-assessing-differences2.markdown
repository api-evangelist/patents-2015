---

title: Comparing applications and assessing differences
abstract: An analysis including a comparison is performed of first and second applications and a determination is made regarding whether the first is a counterfeit version of the second application, or vice-versa. Based on the analysis and comparison, and based on an assessment of the first application, an assessment of the second application may be generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563749&OS=09563749&RS=09563749
owner: LOOKOUT, INC.
number: 09563749
owner_city: San Francisco
owner_country: US
publication_date: 20150421
---
This application is a divisional of U.S. patent application Ser. No. 13 484 132 entitled CRAWLING MULTIPLE MARKETS AND CORRELATING filed May 30 2012 which is a continuation in part of U.S. patent application Ser. No. 12 868 672 entitled SYSTEM AND METHOD FOR SECURITY DATA COLLECTION AND ANALYSIS filed on Aug. 25 2010 now U.S. Pat. No. 8 533 844 which is continuation in part of U.S. patent application Ser. No. 12 255 621 entitled SYSTEM AND METHOD FOR ATTACK AND MALWARE PREVENTION filed on Oct. 21 2008 now U.S. Pat. No. 8 108 933 each of which is incorporated by reference herein. This application is related to the following U.S. patent applications U.S. patent application Ser. No. 12 868 669 entitled SYSTEM AND METHOD FOR SERVER COUPLED MALWARE PREVENTION now U.S. Pat. No. 8 347 386 and U.S. patent application Ser. No. 12 868 676 entitled SYSTEM AND METHOD FOR MOBILE COMMUNICATION DEVICE APPLICATION ADVISEMENT now U.S. Publication No. 2011 0047594 all of which are incorporated by reference herein. This application is also related to the following co pending U.S. patent applications U.S. patent application Ser. No. 14 105 950 entitled ASSESSING APPLICATION AUTHENTICITY AND PERFORMING AN ACTION IN RESPONSE TO AN EVALUATION RESULT U.S. patent application Ser. No. 14 253 702 entitled MONITORING INSTALLED APPLICATIONS ON USER DEVICES U.S. patent application Ser. No. 14 253 739 entitled IDENTIFYING MANNER OF USAGE FOR SOFTWARE ASSETS IN APPLICATIONS ON USER DEVICES and U.S. patent application Ser. No. 14 301 007 MONITORING FOR FRAUDULENT OR HARMFUL BEHAVIOR IN APPLICATIONS BEING INSTALLED ON USER DEVICES. 

This disclosure relates generally to computer security and specifically to collecting applications for portable electronic devices and analyzing the applications through comparisons correlations and inferences.

Today s portable electronic devices such as cellular telephones smartphones wireless enabled personal data assistants tablet PCs netbooks and the like are becoming more common as platforms for various software applications. There are literally hundreds of thousands of mobile applications covering categories such as games entertainment music movies business news productivity and many more. These applications are made available to consumers through online marketplaces such as the Android Marketplace Apple AppStore Amazon AppStore and many others. An application may be offered for free or require payment. Developers may be compensated through commissions the placement of advertisements in the applications or both.

However while there are many positive software applications available on the market the ability to interact install and operate third party software inevitably leaves the device susceptible to vulnerabilities malware and other harmful software applications. Unlike desktop computers and other less portable computing devices that can install and run antivirus software to protect against harmful software applications portable electronic devices lack the processing power or resources for effectively running analogous software.

There exist many unscrupulous people who engage in software piracy and hacking. Many of the application marketplaces are flooded with unauthorized application copies or versions. Everybody suffers. The developer fails to receive compensation and may not have the resources to continue research and development on other products. The unauthorized version of the application may have been modified with a virus or other malware code. Thus the consumer suffers.

Therefore there is a need for improved techniques and systems for computer security including mobile application security.

A crawler program collects and stores application programs including application binaries and associated metadata from any number of sources such as official application marketplaces and alternative application marketplaces. An analysis including comparisons and correlations are performed among the collected data in order to detect and warn users about pirated or maliciously modified applications.

In a specific implementation there is a method for finding and collecting applications using a feedback loop where initial results determine future queries. The method includes retrieving by an application collector program a first application program and first metadata associated with the first application program from a source of application programs storing the first application program and first metadata parsing the first metadata to identify at least one keyword in the first metadata submitting to the source of application programs a first query based on the at least one keyword in the first metadata receiving a first search result responsive to the first query where the first search result identifies a second application program related to the first application program and retrieving the second application program and second metadata associated with the second application program from the source of application programs.

In another specific implementation there is a method for determining which application is legitimate when two or more applications look the same and claim to do the same thing. In a specific implementation a method for identifying counterfeit mobile application programs includes measuring at a server a degree of similarity between first metadata describing a first mobile application program and second metadata describing a second mobile application program. If the degree of similarity is within a threshold degree of similarity comparing the first mobile application program with the second mobile application program to identify differences between the first and second mobile application programs identifying at least one difference between the first and second mobile application programs and based on the identified at least one difference and the degree of similarity being within the threshold degree of similarity determining that one of the first or second mobile application programs is a counterfeit of the other first or second mobile application programs.

In another specific implementation there is a method for correlating applications and making assessments based on the correlation. In a specific implementation a method includes analyzing at a server a first mobile application program generating a first assessment of the first mobile application program correlating a second mobile application program with the first mobile application program using a correlation criterion and based on the first assessment of the first mobile application program and the correlation of the second mobile application program with the first mobile application generating a second assessment of the second mobile application program.

In another specific implementation there is a method for using multiple personalities to retrieve metadata and application binaries. In a specific implementation a method includes providing to a first source of application programs a first client personality indicating that a portable electronic device having the first client personality is requesting the application programs receiving from the first source a first listing of application programs that the first source makes available to portable electronic devices having the first client personality providing to the first source a second client personality different from the first client personality indicating that a portable electronic device having the second client personality is requesting the application programs and receiving from the first source a second listing of application programs that the first source makes available to portable electronic devices having the second client personality. The first listing includes a first application program and does not include a second application program and the second listing includes the second application program and does not include the first application program.

In other specific implementation there is a method for ordered searching. In this specific implementation a method includes examining a first entry in a list that identifies application programs available from a source of application programs where entries in the list correspond to the application programs available from the source and the entries are ordered by publication date of the corresponding application programs determining that an application program corresponding to the first entry has been previously retrieved upon determining that the application program corresponding to the first entry has been previously retrieved updating an overlap counter variable comparing the updated overlap counter variable with a threshold overlap value and based on the comparison examining a second entry in the list next to the first entry to determine whether an application program corresponding to the second entry has been retrieved or determining that application programs corresponding to remaining entries in the list have been previously retrieved and not examining the remaining entries.

Other objects features and advantages of the present invention will become apparent upon consideration of the following detailed description and the accompanying drawings in which like reference designations represent like features throughout the figures.

This disclosure is directed to a system and methods for using a server to provide protection from and removal of undesired applications or other data objects that may affect a mobile communication device or plurality of mobile communication devices regardless of the make or model of the mobile communication device s the mobile communication network or the software applications present on the mobile communication device s . As used herein all of the services associated with the identification analysis and removal of potentially undesired applications or other data objects as well as mobile communication device protection are described under the non limiting term security. Thus an embodiment of this disclosure is directed to providing security to a plurality of mobile communication devices such as a plurality of mobile communication devices for a group of employees or a plurality of mobile communication devices that access a particular network. An embodiment of this disclosure is directed to safely and securely gathering information about applications on mobile communication devices without taxing individual mobile communication devices or the mobile network and utilizing the information about applications to secure mobile communication devices. An embodiment of this disclosure is directed to using information gathered from mobile communication devices to generate user or device information that can be used to develop future products or services for mobile communication devices.

It should be appreciated that an embodiment of this disclosure can be implemented in numerous ways including as a process an apparatus a system a device a method a computer readable medium such as a computer readable storage medium containing computer readable instructions or computer program code or as a computer program product comprising a computer usable medium having a computer readable program code embodied therein. One will appreciate that the mobile communication device described herein may include any computer or computing device running an operating system for use on handheld or mobile devices such as smartphones PDAs tablets mobile phones and the like. For example a mobile communication device may include devices such as the Apple iPhone the Apple iPad the Palm Pre or any device running the Apple iOS Android OS Google Chrome OS Symbian OS Windows Mobile OS Palm OS or Palm Web OS . As used herein the mobile communication device may also be referred to as a mobile device a mobile client or simply as a device or as a client.

In the context of this document a computer usable medium or computer readable medium may be any medium that can contain or store the program for use by or in connection with the instruction execution system apparatus or device. For example the computer readable storage medium or computer usable medium may be but is not limited to a random access memory RAM read only memory ROM or a persistent store such as a mass storage device hard drives CDROM DVDROM tape erasable programmable read only memory EPROM or flash memory or any magnetic electromagnetic infrared optical or electrical system apparatus or device for storing information. Alternatively or additionally the computer readable storage medium or computer usable medium may be any combination of these devices or even paper or another suitable medium upon which the program code is printed as the program code can be electronically captured via for instance optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory.

Applications software programs or computer readable instructions may be referred to as components or modules or data objects or data items. Applications may be hardwired or hard coded in hardware or take the form of software executing on a general purpose computer such that when the software is loaded into and or executed by the computer the computer becomes an apparatus for practicing the disclosure. Applications may also be downloaded in whole or in part through the use of a software development kit or toolkit that enables the creation and implementation of an embodiment of the disclosure. In this specification these implementations or any other form that an embodiment of the disclosure may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the disclosure.

As previously mentioned security services may be provided to one or more mobile communication devices by a server or group of servers that operate together. There are many possible ways in which multiple servers may operate together to provide security services without departing from the scope of this disclosure. An embodiment of this system is shown in in which one or more servers communicate with one or more mobile communication devices over a cellular wireless Internet or other network . As mentioned above mobile communication device may also be referred to as a mobile client device client device device or client and may be referred to in the singular or plural form. The one or more servers may have access to a data storage that stores security information for the one or more mobile communication devices . Data assessment information information about the mobile communication devices or other objects for storage may be stored on servers and or data storage . Servers or data storage may be singular or plural or may be physical or virtualized. Data storage may be a database data table data structure file system or other memory store. Data storage may be hosted on any of the one or more servers or may exist externally from the one or more servers so long as the one or more servers have access to data storage . In an embodiment data storage is an external service provided by a third party such as the Simple Storage Service S or other products provided by Amazon Web Services LLC. One will appreciate that the configuration of the system illustrated in is non limiting and merely exemplary and that other configurations are possible without departing from this disclosure.

One will appreciate that communication between mobile communication device and server may utilize a variety of networking protocols and security measures. In an embodiment server operates as an HTTP server and the device operates as an HTTP client. To secure the data in transit mobile communication device and server may use Transaction Layer Security TLS . Additionally to ensure that mobile communication device has authority to access server and or to verify the identity of mobile communication device device may send one or more identifiers or authentication credentials to server . For example authentication credentials may include a user name and password device specific credentials or any other data that identifies mobile communication device to server . Authentication may allow server to store information specific to mobile communication device or an account associated with mobile communication device to provide customized services to device and to maintain a persistent view of the security status of mobile communication device .

In order to provide security services for mobile communication device one having ordinary skill in the art will appreciate that mobile communication device will transmit certain data to server . As will be discussed in more detail below server will analyze this data and provide a security related assessment response and or other action. The following describes the type s of data transmitted from mobile communication device to server the analysis performed by server and the action taken with or by mobile communication device .

One will appreciate that an embodiment of this disclosure may exist independently on mobile communications device or may be incorporated into an existing security system resident in the mobile communications device such as the one described in U.S. patent application Ser. No. 12 255 614 entitled SYSTEM AND METHOD FOR MONITORING AND ANALYZING MULTIPLE INTERFACES AND MULTIPLE PROTOCOLS filed on Oct. 21 2008 and incorporated in full herein. One having ordinary skill in the art will also appreciate that in order to implement an embodiment of this disclosure on a variety of mobile communications device platforms it may be necessary to incorporate a cross platform system such as the one disclosed in U.S. patent application Ser. No. 12 255 626 entitled SYSTEM AND METHOD FOR A MOBILE CROSS PLATFORM SOFTWARE SYSTEM filed on Oct. 21 2008 and incorporated in full herein. In addition as discussed further below aspects of this disclosure may be used to determine a security state for a mobile communications device as described in U.S. patent application Ser. No. 12 255 632 entitled SECURE MOBILE PLATFORM SYSTEM filed on Oct. 21 2008 and incorporated in full herein.

One having ordinary skill in the art will appreciate that mobile communication devices are exposed to different types of data. This data includes network data files executable and non executable applications emails and other types of objects that can be transmitted to received by or installed on a mobile communications device. Mobile communication devices also typically transmit and receive data through one or more network interfaces including Bluetooth WiFi infrared radio receivers and the like. Similarly data may be encapsulated in a layered communications protocol or set of protocols such as TCP IP HTTP Bluetooth etc. Current server client security models such as those currently available for desktop and laptop computers cannot extend their capabilities to provide adequate assessment and security to a plurality of mobile communication devices.

This disclosure contemplates at least two types of data that can be used to evaluate and protect mobile communication devices. The first type of data includes data about a mobile communication device i.e. device data. Device data pertains to the state capabilities operating system firmware version memory capacity available communication ports battery limitations hardware characteristics and other baseline information that may be common to all similar devices absent user customization. Device data may include the default specifications for a device as it is received from a manufacturer service provider or IT service. Device data may include state information common to all similar mobile communications after they have all been upgraded in some fashion. As will be discussed further below device data may be used to evaluate whether vulnerabilities exist due to unguarded communication ports operating system exploits device specific attacks and the like.

A second type of data that can be used to evaluate mobile communication devices is data that pertains to a particular application file or object that may be installed or run on a mobile communication device. As used herein this data is referred to as application data. Application data includes both data objects and information about data objects such as behavioral data or metadata. Data objects include application packages that may be particular to certain mobile communication devices. For example iPhone OS devices typically use IPA files or APP packages Android OS devices typically use APK files Windows Mobile devices typically use CAB EXE or DLL files and Symbian OS devices typically use SIS files. Devices may also support cross platform application formats such as the SWF format underlying Adobe s Flash runtime or JAR files that can be run on Java virtual machines.

Application data includes data objects that are malware or spyware and thereby can negatively affect a mobile communication device. Malware and spyware include applications files and other data objects that are purposefully designed to adversely affect or steal information from a mobile communication device. Application data also includes data objects that are not designed for nefarious reasons but may have coding flaws or other issues that can negatively affect a device. Application data also includes data objects that may be undesirable for various reasons. For example a data object may be undesirable because it compromises privacy overtaxes a device s battery or network connection and or has objectionable content. As used herein data objects may also be referred to as data items. Use of either term is not intended to limit the data to any one form.

Application data includes metadata about data objects. For example metadata is information about a specific data object rather than the data object itself. Metadata includes the location on a mobile communication device s filesystem where a data object is stored a hash of the data object the name of the data object a unique identifier present in or associated with the data object such as a GUID or UUID security information related to the data object such as its cryptographic signer information or level of permissions granted and characteristics of how the data object is installed on or integrates with the mobile communication device s operating system. Metadata for a data object may also include from where the data object came e.g. a URL from where it was downloaded an application marketplace from which it was downloaded a memory card from where it was installed or stored. Metadata may also be retrieved from an application marketplace. Such metadata called marketplace metadata includes information about a data object such as the number of downloads user comments about the data object the description of the data object permissions requested by the data object hardware or software requirements for the data object information about the data object s author the price of the data object the language or languages supported by the data object and other information that a marketplace may provide.

In an embodiment application data also includes behavioral data. Behavioral data includes information about how an application interacts with or uses a mobile communication device s resources such as memory usage battery usage network usage storage usage CPU usages API usage errors and crashes network services connected to e.g. remote host address and port and runtime library linkage. Behavioral data also includes information about how an application file or data object when it is run utilizes the functionalities of the mobile communication device s operating system such as notifications and messaging between processes or installed applications.

As will be explained further below both device data and application data are useful for providing an assessment of the security of a device based upon the data stored e.g. installed applications or passing through the device. One having ordinary skill in the art will appreciate that device data and application data are merely examples of the types of data that may be used in order to safeguard a mobile communication device or provide other functions related to a mobile communication device. Other types of data may also be evaluated by the disclosed system without departing from the scope of this disclosure. As used herein the term assessment refers to information relating to a data object that may be used to evaluate or otherwise further understand a data object s operation or effect of operation. For example an assessment may include a determination that an application is malicious or non malicious bad or good unsafe or safe or that an application may appear on a blacklist or whitelist. An assessment may include categorization or characterization data for a data object ratings such as security ratings privacy ratings performance ratings quality ratings and battery impact ratings for a data object trust ratings for a data object distribution data for a data object. Assessments may result from collecting and or processing data by server and may be exposed by server to users or other systems via an API user interfaces data feeds or other methods. One will appreciate that the previous description for an assessment is not meant to be limiting in any fashion.

What follows is a discussion about how device data and application data are collected and stored according to an embodiment of this disclosure. In general the following discussion includes communications between server and mobile communication devices over network . Any data transmitted or received during these communications may be stored on server or on data storage . In an embodiment data stored on data storage or server is associated with a particular account or device known to the system. The association between data and a device or account may allow server to provide tailored functionality for the account or device based on previously received data. In an embodiment some or all of the data is stored on server or data storage with an anonymous association to a particular account or device. For example data may be stored with an anonymous association for privacy purposes so that examination of the data on server or data store cannot tie the anonymously associated data to a particular account or device however a device can populate and update this anonymously associated data. Anonymous associations are described in further detail below. In an embodiment server will request information from mobile communication devices which will respond with the requested information. In an embodiment a mobile communication device will transmit device data and or application data to server for analysis and assessment. For example a user of mobile communication device may wish to download a file to his device but prior to installing the file may wish to send the file or identifying data associated with the file to the server in order to check if the file is malicious or otherwise undesirable. Server will then analyze this received information in order to provide a security assessment that is available to any of the mobile communication devices . In another example it may be useful to know how an assessed data object will affect the performance or behavior of a mobile communication device the assessment containing information such as average battery impact or average network usage of the data object. In an embodiment server stores assessments of data objects after analysis and can provide access to these assessments in a number of ways. The analysis performed by server will be discussed further below. The process by which server provides access to assessment information will be also be discussed further below.

To prevent taxing network and server with network traffic various methods may be used to reduce the amount of data requested by and transmitted to server . For example rather than transmitting whole data objects such as application files or application packages for analysis hashing functions or hashing algorithms may be applied to data and the resulting hash of the data may be sent to the server . The server may use the hash to uniquely identify the data object. If the server has previously performed an assessment of the data object identified by the hash the server may return that previous assessment if it is still valid. If the server has not yet performed an assessment for the data object the server may return a response indicating that the assessment is unknown and or request additional data from the mobile communication device . One having ordinary skill in the art will appreciate that a hashing algorithm will transform an arbitrary amount of data into a fixed length identifier. For example the SHA 1 hashing algorithm can digest an arbitrary amount of input data into a 160 bit hash. In another example metadata besides a hash of the data object may be sent in lieu of a data object itself e.g. metadata for an application may be sent for an assessment rather than the whole application. In many cases metadata such as a package name application name file name file size permissions requested cryptographic signer download source a unique identifier such as a UUID and other information may be sufficient as identifying information for a data object thus if server receives appropriate identifying information it can determine if the data object is undesirable. One skilled in the art will appreciate that there are a variety of methods by which a data object can be identified in such a way that can allow server to determine if a data object installed on device is malicious without having to transmit the entire data object to server .

In an embodiment of this disclosure server may request portions of a data object rather than a complete data object. A whole data object may be transmitted incrementally such that network is not burdened by network traffic. Alternatively or additionally server may request information about a particular application but may query a group of mobile communication devices that each has this application. In this manner server may receive a portion or chunk of data from one mobile communication device and another portion of data from a second mobile communication device and so forth as necessary. Server may then aggregate this information as it is being received thereby pooling from a number of mobile communication device having the application file data without taxing any specific mobile communication device. An example of this method is discussed further below.

In an embodiment server sends a notification to mobile communication device block . This notification can be an alert a message an instruction or other information related to application data or device data specific to mobile communication device . In an embodiment the notification is due to the device previously having sent application data corresponding to a data object that was not initially assessed by the server to be undesirable but was subsequently determined by the server to be undesirable. In block mobile communication device receives the notification and in block the mobile communication device takes action based upon the notification. As will be discussed in more detail below such actions may include deactivating one or more features or applications on the mobile communication device .

One having skill in the art will appreciate that the interaction between mobile communication device and server can include communication from the mobile communication device to the server as well as from the server to the mobile communication device. For example in an embodiment server may receive application data from mobile communication device but server may require additional information before providing an assessment or transmitting a notification. In block server may request the additional information from mobile communication device . Mobile communication device receives the request block gathers additional information as requested by server block then in block transmits the additional information to server . In block server receives the requested additional information. One will appreciate that this process may repeat as necessary.

In an embodiment a change in a data object includes any time a data object is added removed or modified. After transmitting application data for a data object mobile communication device waits for confirmation from the server before recording that it has successfully transmitted application data for the data object. After receiving application data for a data object from a mobile communication device server transmits a confirmation. If there was an error in transmission or with the data itself server returns an error. If mobile communication device receives an error from server or no response after transmitting application data for a data object mobile communication device will not record the application data for the data object as having been sent and the mobile communication device may retry sending the data at some point in the future. One skilled in the art will recognize that mobile communication devices are sometimes unable to connect to a network or may have their network connection interrupted in the middle of a transmission. As such a mobile communication device recording whether or not server has successfully received application data for a data object is important to the functioning of a reliable data collection system. In an embodiment any time application data for a data object has not been transmitted from mobile communication device and received by server it is considered to be changed and needs to be transmitted.

In an embodiment mobile communication device stores whether it has transmitted and server has successfully received application data for one or more data objects present on the device. In order to identify which data objects have had appropriate application data reported to server mobile communication device may store a database containing identification information for data objects that have been successfully reported to server to determine whether the device needs to transmit application data for those data objects. For example a data object that is a file on a filesystem may be identified by a hash of its contents. When the data object is first installed on a mobile communication device the database may contain no data for the data object. Because there is no identifying information for the data object the mobile communication device recognizes the data object as new and transmits application data for the data object to server indicating that the object is new. After transmitting application data for the data object to server and receiving confirmation that the server successfully received the application data the device stores the hash of the file contents and the location on the filesystem where the file resides in the database. If the data object were to be deleted the mobile communication device can detect that there is no file at the previously stored filesystem location and can report the deletion of the data object to server by reporting the filesystem location and or hash identification information for the data object. If the file were to be modified such as in the case of an application being updated the mobile communication device can detect that there is a file in the previously stored location on the filesystem but the content hash of the file does not match the stored content hash. In this case the mobile communication device can report to the server that the data object identified by the file location and or previous content hash has been updated and report the new content hash of the file.

In an example a security system installed on mobile communication device may report application data for a data object to server for purposes of receiving an assessment of the data object. If a mobile communication device downloads a new application that is malicious it is important that the security system detect this new item as soon as possible. Server can analyze the new application and provide a security assessment whereby actions can be taken based on the results. In another example a first version of an application may be safe but a second version of the application may be malicious. It is important that a security system recognize this update as different from the first version of the application so that it will produce a new assessment of the second version and not just report the first assessment. Server can analyze the updated application and provide a security assessment whereby actions can be taken based on the results.

In block of mobile communication device transmits identification information for the mobile communication device to server . In an embodiment the identification information is authentication information. In an embodiment the identification information is a non authoritative identifier for the device such as a device ID that is not considered to be secret. In an embodiment identification information includes device information for the mobile communication device e.g. make model hardware characteristics . In addition mobile communication device transmits information for the changed data object. Such information may include identifying information for the data object such as metadata e.g. hash package name file name file path cryptographic signer unique identifier such as a UUID and the like. In block server receives the identifier for mobile communication device and information for the changed data object. The received data is stored by server on the server or on data storage block . In an embodiment only some of the data received by server is stored. In block server provides an assessment for the changed data object using any of the techniques disclosed herein or from U.S. patent application Ser. No. 12 255 621 which is incorporated in full herein. The assessment may include instructions and or a categorization labeling the changed data object as safe malicious or unknown. In an embodiment some or all of the received data is stored on server or data storage and is associated with the device that transmitted the data. For example this may later allow server to determine which applications a device has encountered. In another embodiment some or all of the received data is stored on server or data storage in a way that server cannot directly tie the information to a particular device. For example server may store received data without any link to a particular device or account. In another example data may be anonymously associated with a device by the server associating the data with an identifier when stored. To ensure that server cannot associate the stored data with a particular device the identifier is only known to the device transmitting the data and is provided to the server whenever the device transmits data. The server does not store this identifier so that the identifier is never directly linked with a particular device or account on server or data store . In an embodiment server stores the results of the assessment on the server or on data storage . If when an assessment for a data object is required and a previous assessment for the data object exists and is considered valid server retrieves the previous assessment from data storage instead of performing a new assessment. Assessments may be considered to be for the same data object if the metadata relating to each object matches in a variety of ways including if the assessments relate to data objects with the same hash same package name same cryptographic signer or same file path. In block the assessment is transmitted to mobile communication device which receives this assessment from server block then processes the assessment or takes appropriate action block .

One having ordinary skill in the art will appreciate that the interaction between mobile communication device and server is dynamic in that server can proactively transmit notifications or instructions to remediate data objects whose assessment has changed thereby requiring action by mobile communication device . illustrates such an embodiment. In block of mobile communication device detects a change in a specific data object. In block mobile communication device sends identification information for the device and information about the changed data object to server . Server receives the identification information for mobile communication device and information about the changed data object block . In block server stores the changed data information on the server or on data storage . In block server may analyze and assess the changed data object and may report the assessment to mobile communication device block . As discussed previously if an assessment has already been performed for the data object that previously performed assessment may be retrieved and used instead of re performing the assessment. If server reports an assessment mobile communication device receives the assessment or other notification in block and processes the assessment block .

In an embodiment the assessment for the data object may change. For example a data object that may previously have been assessed as safe or unknown may later be identified as malicious causing some previously unknown vulnerability or causing an undesirable behavior such as network overuse or battery drainage. In block if server detects a change in assessment for a previously analyzed data object then in block server may transmit a notification remediation instructions or the like to mobile communication device . Mobile communication device receives the notification from server block then performs the recommended actions or remediation instructions block . In block mobile communication device transmits a confirmation that it performed the required actions which server receives block . In an embodiment the notification is only sent to mobile communication device if the data object is determined to be present on mobile communication device. In an embodiment the server stores information on the server or on data storage allowing the server to determine whether the mobile communication device currently has the data object or has previously requested an assessment for the data object.

One having skill in the art will appreciate that provides only one example of how server may report changes in assessment to a mobile communication device and some steps may be skipped without departing from this disclosure. For example mobile communication device may perform remediation instructions or other required actions without sending confirmation to server .

In an embodiment server may request additional information about a particular data object from mobile communication device . For example mobile communication device may send information about a changed data object to server however the information sent may be insufficient for server to perform a conclusive analysis. illustrates this embodiment. In block of mobile communication device detects that a data object has changed and transmits identification information for mobile communication device with information for the changed data object to server block . Server receives the identification information for mobile communication device and information for the changed data object block and stores the information for the changed data object on the server or on data storage block . In block server determines whether it requires additional information about the changed data object. For example server may attempt to assess whether the changed data object is safe or malicious but is unable to provide a conclusive assessment i.e. the assessment results in unknown . The determination of whether more information is needed can be performed either before the server performs an assessment if there is not enough data to even begin an assessment or after an assessment returns inconclusively due wholly or in part to a lack of data. If additional information is required then server may request the additional information from mobile communication device block .

In block of mobile communication device receives the request for additional information gathers the requested information block then transmits the additional information to server block . In an embodiment additional information includes behavioral data for a data object and application data for the data object such as the content for the data object. In block server receives the additional information from mobile communication device and stores the additional information block . Server may then analyze the changed data object information with the additional information to provide an assessment block which may be sent to the mobile communication device block . In block mobile communication device receives the assessment of the changed data object from server then processes the assessment block .

In an embodiment mobile communication device may elect to transmit additional information to server . For example server may analyze a data object but not provide a conclusive assessment. Rather than requesting additional information from mobile communication device the device may request an additional assessment by providing additional information for the data object to server . illustrates this embodiment.

In block of mobile communication device detects a change in a data object then in block mobile communication device sends its identification information and information for the changed data object to server . In block server receives the identification information for mobile communication device and the information for the changed data object. This information is stored by server on the server or on data storage block then analyzed by server to result in an assessment block . In block server transmits the assessment or an appropriate notification to mobile communication device . Mobile communication device receives the assessment from server block of . In block mobile communication device determines whether to send additional information about the data object. For example server may be unable to produce an assessment for the data object given the data it has available and thus needs more information to be able to produce an assessment. In block if mobile communication device determines that it should send additional information about the data object then this information is gathered. In block mobile communication device transmits the additional information to server which receives this information block and stores the received additional information block . One will appreciate that server will know that the additional information will pertain to the information previously received by server block since mobile communication device will transmit identification information with the additional information.

In block of server analyzes the additional information received from the mobile communication device . In an embodiment the additional information may be analyzed with the previously received information block . In block server transmits the assessment to mobile communication device which processes the assessment block . If mobile communication device still needs to send additional information it may repeat the process as necessary.

As noted previously server may have access to a plurality of mobile communication devices some of which may run or store the same application programs or data objects. Requesting data object information from a single mobile communication device can cause network traffic affecting not only the single mobile communication device but other devices on the network. In an embodiment if server requires information about a data object that is stored on more than one mobile communication device server can gather portions of the required information from each of the mobile communication devices rather than relying on a single device. illustrates an embodiment using a first and a second mobile communication device thereby optimizing data collection from two or more mobile communication devices.

In block of the first mobile communication device detects a change in a data object. The data object is also found on the second mobile communication device but may or may not realize the same change. The first mobile communication device transmits its identification information and information for its changed data object to server block . In block server receives the identification information for the first mobile communication device with the information for the changed data object. This information is stored by server block . In block server determines that it requires additional information about the data object. In block server identifies the second mobile communication device that server knows also stores the data object as well as additional information for the data object.

In block of server requests the additional information for the data object from the second mobile communication device. This request is received by the second mobile communication device block . In response the second mobile communication device will gather the additional information block then transmit the additional information to server block . Server receives block and stores the additional information about the data object from the second mobile communication device on server or on data storage block then analyzes this additional information with the previously received information from the first mobile communication device to render an assessment block . This assessment is transmitted to the first mobile communication device block which receives the assessment block and process the assessment block . One will appreciate that if relevant server may also transmit the assessment to the second mobile communication device.

In an embodiment server can gather additional information from multiple devices. In an embodiment server chooses which devices to request additional from by analyzing device information and application data previously stored by server. For example to characterize an application s usage of SMS messaging to determine whether or not it is abusing SMS for spam purposes server may request the count of SMS messages sent by an application from many mobile communication devices that have previously reported that they have installed the application. In an embodiment server attempts to analyze a data object to produce an assessment without first waiting to receive information about the data object from a device. Instead server may receive data from other sources and proactively request information from one or more devices to create an assessment for the data object.

In an embodiment application data for a data object that is gathered and transmitted by mobile communication device to server may include behavioral data about the data object. Usage of such data by server such as during analysis is discussed more in depth below. Behavioral data may include information about what the data object did when it ran on the device. Examples of behavioral data include information about network connections caused by the data object e.g. server names source destination addresses and ports duration of connection connection protocols amount of data transmitted and received total number of connections frequency of connections and network interface information for the connection DNS requests made behavior of the data object when run e.g. system calls API calls libraries used inter process communication calls number of SMS messages transmitted number of email messages sent information about user interfaces displayed URLs accessed overhead caused by the data object e.g. battery used CPU time used network data transmitted storage used memory used . Other behavioral data includes the context when a particular behavior occurred e.g. whether the phone s screen was off when the data object sent an SMS message whether the user was using the data object when it connected to a remote server etc. .

Because a large amount behavioral data is generated by data objects every time they run it is important for a mobile communication device not to gather or transmit all of the possible behavioral data otherwise the gathering and transmission of behavioral data may over utilize resources on the device server and the network . In an embodiment mobile communication device limits what type of behavioral data for a data object it gathers and transmits and how frequently to gather and transmit behavioral data based on the period of time since the data object has last changed. For example when a data object is first installed on a mobile communication device the device may gather and transmit the full amount of behavioral data available every day. After one week following installation of the data object the device may only send a limited subset of behavioral data in weekly intervals. A month after installation the device may only send a minimal amount of behavioral data in monthly intervals. In an embodiment if the data object were to be updated e.g. updating an application to a different version the device may transmit the full scope of behavioral data daily and reduce the scope and frequency of data gathered and transmitted after one week and or after one month. In an embodiment server sends configuration to mobile communication device requesting that the device send specific types of behavioral data at a specific frequency. The device stores the configuration so that it may determine whether to gather and or transmit behavioral data for data objects. In an embodiment the configuration information is specific to a particular data object. In an embodiment the configuration information is for all data objects encountered by the device. In an embodiment server requests behavioral data for a particular data object from the device so that the server can minimize unnecessarily gathered and transmitted behavioral data.

In an embodiment server can influence the gathering and transmission of behavioral data from device to server . For example server may transmit instructions to mobile communication device requesting behavioral data for a data object only if the server has information indicating that the device currently has the data object and if the server needs more behavioral data to better assess the data object. In an embodiment the server determines that it needs more behavioral data for an object based on the number of devices that have already reported behavioral data. For example the server may require at least one hundred 100 devices to report behavioral data for each data object in order to have a confident assessment. In an embodiment the difference of the behavioral data reported by different devices is used to determine how much behavioral data is needed for an assessment to be confident. For example if thirty 30 devices all reported battery usage by a data object within a small variance the server may not request any more behavioral data for that object however if those thirty 30 devices showed a wide variation of battery usage the server may request behavioral data from two hundred 200 devices.

In an embodiment a mobile communication device may only transmit behavioral data if the data is outside of normal bounds. In an embodiment the bounds are universal to all data objects. For example a bound on network usage may be set so that mobile communication device transmits behavioral data for a data object s network connections only if the data object maintains at least one open connection for more than 50 of the time it is running or if the data object transmits more than one megabyte of data in a 24 hour period. In an embodiment server can update bounds on a mobile communication device by transmitting updated bound information to the device. In an embodiment bounds may be particular to one or more data objects. For example a device may have a set of default bounds by which it will send behavioral data but the server may transmit bounds for a particular data object identifying that data object through identifying information such as a hash cryptographic signer package name or filesystem location. The updated bounds may instruct the device to send more or less behavioral data than the default set of bounds. For example a mobile communication device may default to never send behavioral data. When a new data object is installed on the device the device reports the installation event and metadata associated with the data object to the server. If the server has already characterized the data object through behavioral data from other devices the server may send bounds to the device specifying the typical behavior of the data object on other devices e.g. uses less than 100 kilobytes of data per day never sends SMS messages never sends email so that if the data object deviates from these bounds the mobile communication device will send the deviated behavioral data to the server. Such deviations may be useful in the case of a legitimate application that becomes exploited and begins exhibiting uncharacteristic behavior or in the case of a time bomb application that only starts becoming malicious after a certain time.

In an embodiment data transmitted from mobile communication device to server is configurable in order to protect user privacy prevent overuse of device network or server resources or for other reasons. Some example configurations include choosing what application data is sent from device to server how often application data is sent and how application data is re transmitted should initial transmissions fail. Example configurations may further include transmitting only identifying information e.g. no additional metadata or behavioral data never transmitting any application data never transmitting data object content only transmitting application data for data objects based on the source of the data objects only transmitting certain type of behavioral data only transmitting a certain amount of application data per day only transmitting one data object s content per day transmitting behavioral data a maximum of once per day per data object and the like. One skilled in the art will recognize that additional configurations are possible without departing from the scope of the disclosure. In an embodiment the configuration may be enforced by a mobile device and or server by the device only making certain transmissions and or the server only making certain requests from the device. In an embodiment the configuration is controlled by one or more parties. For example the configuration may be automatically set by server or software residing on mobile communication device or controlled by an administrator via server and or controlled by a user via mobile device . In an embodiment portions of the configuration are controlled by different parties. For example a user may be able to control whether or not data objects are reported to server but an administrator on server may control the behavioral data reporting frequency for all devices to optimize battery usage of the security system.

In an embodiment software on a mobile communication device displays a user interface dialog when it receives a request to transmit application data for a data object such as its content or behavioral data. As discussed above a request for the data object s content may be for the whole content or for a portion of the content the request identifying which portion of the content if a portion is requested. The user interface dialog displayed may identify the data object for which application data is to be transmitted and give the device s user a chance to allow or reject the transmission. In an embodiment the dialog allows the user to have the device remember his or her decision for future data objects. In an embodiment the dialog allows the user to view more in depth information about the application data to be sent and provides a way for the user to understand the privacy implications of sending the data such as linking to a privacy policy privacy description or other content that describes how the data is transmitted stored and used. In an embodiment a mobile communication device attempts to transmit a data object when it receives an indication that server needs more information to produce an assessment. In this instance the device may display a user interface dialog prompting the device s user to choose whether or not to transmit the data object s content when the device attempts to transmit a data object. In an embodiment some attempted transmission of certain types of application data such as a data object s content results in user interface dialog for confirmation while other types of application data such as metadata or behavioral data are transmitted without requiring a user confirmation.

Because a particular application may utilize multiple data objects it may be desirable for mobile communication device and or server to group multiple data objects together so that the application can be analyzed as a whole. In an embodiment mobile communication device or server may perform grouping by comparing application data between multiple data objects. For example application data that may be used to group data objects includes how data objects were installed e.g. data objects from the same installer may be grouped if data objects are linked together at runtime or dynamically whether multiple data objects are in the same filesystem directory and if data objects share a cryptographic signer. For example an application installer may extract an executable and multiple libraries to the filesystem on a mobile communication device. The mobile communication device may use the common installer to consider the data objects grouped and may store the grouping information for use in gathering behavioral data discussed below . In order for server to recognize the group each data object s application data may include identification information for the common installer. The server may explicitly store the grouped relationship on server or in data storage to efficiently access the grouping information during analysis.

Because behavioral data cannot always be attributed to a single data object when multiple objects execute together such as in the context of single process if the device operating system does not support granular behavioral data or through other mechanisms it may be desirable for mobile communication device to group multiple data objects together and report behavioral data for the group together. In an embodiment mobile communication device transmits information indicating that grouped data objects are associated and transmits application data for grouped data objects to server together. For example if a process on a mobile communication loads multiple components from different vendors and network data can only be gathered on a per process level and or if the process is detected to be connecting to a known malicious server then it may be desirable for all components loaded in the process to be identifiable by the server to determine the offending component. When the mobile communication device gathers behavioral data such as the IP addresses the process has connected to for the process the device reports identification information for all of the data objects that are associated with the process to the server. When the server receives behavioral data for a group of data objects it may analyze behavioral data from multiple devices and determine that only groups containing a particular data object will connect to the malicious server. Thus only the data object that results in connecting to the malicious server will be considered malicious. In an embodiment if a mobile communication device does not provide granular information about the behavior of particular data objects behavioral data for the device as a whole may be transmitted to the server as representing the group of all data objects installed on the device. For example if an operating system does not provide per process battery usage information devices running that operating system may transmit a list of applications installed on each device and the overall battery life for each device to server . The server can then perform analysis on this data to determine which applications are correlated to better or worse battery life and estimate each application s contribution to battery life when installed on a device. In an embodiment where multiple data objects in a group have different behavioral data gathering configurations the mobile communication device will join the configurations together. For example if mobile communication device is configured to report a large amount of behavioral data every day for one data object but is configured to only report anomalous behavioral data for another data object and the data objects are grouped the device may join the two configurations and report a large amount of behavioral data for the group. Alternatively if the second data object is configured to never report behavioral data for privacy reasons no behavioral data may be reported for the group to satisfy the privacy constraint.

One having skill in the art will appreciate that data transmitted by server or mobile communication device such as metadata behavioral data configuration information behavioral data bounds grouping data requests for additional data notifications and other forms of data may be formatted using binary formats or non binary formats. Examples include formatting data in XML JSON or as part of a URI. The data may be transmitted using a variety of protocols including TCP UDP DNS and HTTP. Other formats and or protocols may be used without departing from this disclosure.

The above are various non limiting examples of how data is gathered and collected from one or more mobile communication devices. Techniques for optimizing data collection are also disclosed above. As discussed mobile communication devices will transmit some or all of the above described data to server for analysis so that server can provide an assessment of the analyzed data. The following section describes non limiting examples of analysis techniques. One having skill in the art will appreciate that while the examples and disclosure below uses the data gathered using the methods described herein other types of data may be transmitted and that this disclosure is not limited to the data described herein.

One skilled in the art will appreciate that server may receive data from sources other than mobile communication devices for use in analyzing a data object and producing assessments. illustrates an embodiment in which server may receive data from multiple sources and transmit assessment information for multiple uses. One or more servers are illustrated as a cloud to emphasize that multiple servers may operate in coordination to provide the functionality disclosed herein. One or more mobile communication devices are illustrated as a group to emphasize that multiple devices may transmit and receive information to and from server . As disclosed above one or more mobile communication devices may transmit application data for data objects to server and devices may receive assessment data requests for more information notifications and the like from server .

In addition to gathering data from mobile communication devices server can receive information pertaining to data objects from a variety of data gathering systems. Such systems may be separate from server or may be part of server . In an embodiment a data gathering system directly updates a database or other storage on server or data storage with information for one or more data objects. In an embodiment a data gathering system communicates with server to provide information to server . There are many types of systems that may be used as data feeds to server . Some examples include web crawlers application marketplace data gathering systems honeypots and other systems that may feed information related to mobile device applications to server .

In an embodiment a web crawler downloads data objects that can run on mobile communication devices and retrieves information about data objects feeding both to server . For example the web crawler may utilize a search engine to look for web sites that host mobile applications. Once the crawler identifies sites hosting mobile downloads the crawler may retrieve web pages available on those sites examining the content of each page to determine additional pages to retrieve. For example a page on a mobile download site may contain links to other pages as well as links to download data objects. It may be desirable for data gathering systems to only transmit information to server that is relevant to mobile devices as there is much content available on the internet that does not affect mobile communication devices e.g. PC software . In an embodiment the crawler can identify if a data object available for download or that has already been downloaded is able to run on a mobile communication device. For example the crawler may examine a download URL for a specific string indicating that the URL corresponds to mobile application package e.g. SIS APK CAB IPA . In another example the crawler may examine a data object after it has been downloaded to determine if it affects mobile communication devices and if so whether it affects a specific mobile platform. In this case the crawler may examine the data object downloaded for characteristics such as its name whether it contains executable code compatible with any mobile platforms or if it contains data that is typical for a particular mobile device platform. In an embodiment the web crawler gathers marketplace metadata about data items and transmits the marketplace metadata to server . Some example marketplace metadata includes from which web sites a data object is available for download user ratings and comments for a data object the price of the data object if it is available for purchase the number of times the data object has been downloaded information about the author of the data object and other information pertaining to a data object that is available on web sites. As will be discussed below where a given data object is available can be used to determine how trustworthy a data object is. For example a data object available from a reputable company s web site may be considered more trustworthy than a data object uploaded on a mobile device forum by one of the forum s users.

Because many mobile applications are only available via mobile application marketplaces it may be important for server to receive information about data objects that are available in application marketplaces. In an embodiment an application marketplace data gathering system retrieves information about a data object such as the data object s content and marketplace metadata for the data object from mobile application marketplaces and reports the information to server . In an embodiment the application marketplace data gathering system is part of server . In alternative embodiment the application marketplace data gathering system is separate from server . Application marketplaces are often provided by mobile platform vendors e.g. Android Marketplace Blackberry App World Apple App Store Nokia Ovi Store or third parties e.g. GetJar Handango and may use a proprietary API. In an embodiment application marketplace data gathering system is configured to communicate with application marketplace servers via a proprietary protocol. In order to transmit the data received from application marketplace servers to server in a manner that is usable by server the marketplace data gathering system may transform application data for data objects from a proprietary format into a format that server can utilize for analysis. For example an application marketplace may provide an API to access users comments and ratings for an application however the data returned by that API may be different from another application marketplace s comment data. In another example an application market may proactively transmit data to marketplace data gathering system so that the data gathering system does not have to repeatedly query it. To allow server to be able to analyze comment data from multiple application marketplaces application marketplace data gathering system may transform differently formatted comment data into a standard format for transmission to server . In an embodiment an application marketplace data gathering system can search for certain terms in user reviews such as battery drain crash privacy settings does not work phone number contacts and the like which can be used to characterize an application as known bad or used to establish the trustworthiness of an application using the system components described herein. In an alternative embodiment application marketplace data gathering system can gather all comment data and analysis of the comment data can be performed by server . Similarly server or application marketplace data gathering system can be capable of recognizing positive reviews or scores for a data object thereby improving the assessment and or trustworthiness for the data object.

In addition to automated gathering of data object information it may be important for server to accept human information . Such information may include subjective trust scores for mobile application vendors specific keywords or other characteristics such as heuristics that may classify a mobile application as suspicious. One skilled in the art will recognize that other types of information related to the analysis of data objects for mobile devices may be provided by a human is possible without departing from the scope of this disclosure. In an embodiment server provides a user interface by which someone may provide information to server about a specific data object a group of data objects e.g. data objects from a particular developer all data objects on a specific platform or for the analysis system as a whole e.g. updated analysis heuristics . In an embodiment a server separate from server provides a user interface by which someone may provide information about a specific data object a group of data objects or for the analysis system as a whole. This separate server may transmit the user provided information to server where server stores it on server or in data storage . In an embodiment the separate server directly updates data storage with the user provided information.

In order to produce assessments for data objects or other forms of useful output server may use a variety of methods of analysis. In an embodiment because server has access to information collected about data objects from one or more sources server can process the information to produce an assessment for a data object. illustrates an embodiment in which server aggregates application data for a data object stores the information generates characterizations and categorizations for the data object assesses the data object to produce assessment information and transmits the assessment information. In block of application data e.g. data object content metadata behavioral data marketplace metadata is gathered for a data object. Some of the possible methods for gathering and types of data gathered have been discussed above. Such methods may include gathering data from devices from web sites from application marketplaces from people and from other sources. In block application data for the data object is stored on server or data storage so that the data may be used at a different time than when it is gathered.

In block device data is gathered and stored block on server or data storage . It may be desirable for device data to be linked to the application data for the device that reported so that assessments categorization and characterization can take into account the source of the data. For example if an application only malfunctions when installed on a particular device type it is important for server to be able analyze application data provided by devices in the context of what particular device type provided the data. In an embodiment when application data is stored it is associated with device data for the device that provided it. For example when a device transmits application data to server the device may transmit authentication information that allows server to retrieve previously stored data for the device . If the device has already transmitted device data to server the previously stored device data can then be associated with the new application data. In such a data gathering system it may be important to protect privacy and minimize individually identifiable information stored by server or data storage . In an embodiment application data for multiple devices having the same device data is aggregated so that the stored data is not linked to a particular device but rather a set of device data shared by one or more devices. In the design of such a system it may be important to take into account the balance between granularity of device data and the level to which the aggregated data can be ascribed to a particular device.

As part of analyzing a data object it may be desirable for server to characterize it and or categorize it block . In an embodiment server stores characterization and categorization data for data objects block . It may be desirable for characterization and categorization data to be updated as more data becomes available or analysis of the data changes. In an embodiment server performs additional analysis block and updates stored categorization and characterization data block for a data object when new or updated data for the data object used by analysis systems is available.

Characterization data includes information that describes a data object s functionality behavior and reputation such as its capabilities metrics for the data object analyses of other data relating to the data object and the like. In an embodiment server produces characterization data about a data object using application data device data marketplace data distribution data and other data available to server . While some methods are described below one skilled in the art will appreciate that there are other of methods for generating characterization information that can be employed without departing from the scope of this disclosure. In an embodiment server transmits characterization information as an assessment. One will appreciate that characterization information may be useful for a user to understand when deciding whether to install an application. For example if a user is considering downloading a game but the user receives an assessment indicating that the game has the capability to send the user s location to the internet the user may decide not to install the game. In another example if a user is considering downloading an instant messaging application and is concerned that the application may use a disproportionate amount of battery power the user may receive an assessment to see the application s average battery usage metric and decide that based on the metric the application is acceptable to install. In an embodiment characterization information is consumed as an input to one or more other analysis systems. For example an analysis system producing an assessment of the privacy risk of an application may use characterization information to determine if an application has risky capabilities such as sending location or contact list information to an internet server.

Capabilities are one form of characterization data that server may produce. In an embodiment server extracts capabilities from a data object. In certain mobile operating systems or application environments applications may request granular permissions to access privileged functionality on a device such as sending or receiving network data accessing the phone s location reading or writing contact entries and SMS messaging. In an embodiment server uses data about permissions requested by a data object to determine the capabilities of the data object. Server may determine permission data by a variety of means including metadata and behavioral data reported by devices marketplace data static analysis of data objects and dynamic analysis of data objects. For example applications on the Android operating system have to declare permissions at install time so server may analyze these declared permissions in an application package directly via metadata about an application package reported by one or more devices or via marketplace data to determine permission data.

In an embodiment server performs analysis of a data object s content to determine what APIs on a device the data object utilizes. In an embodiment the API analysis may include a search of the data object for data sequences indicating API calls an analysis of specific library function class or other import data structures in the data object an analysis of dynamic linker calls an analysis of calls to local or remote services static analysis of the data object dynamic analysis of the data object and analysis of behavioral data reported by one or more devices. In an embodiment server utilizes extracted API call information to determine that the application has a particular capability. For example if an application calls an API to interact with a GPS radio on a device server determines that the application has the capability to determine the device s location. Although such analysis may detect the vast majority of APIs used by a data object it is possible that advanced self modifying code may prevent thorough analysis of a data object. In an embodiment server detects if the code is or may possibly be self modifying. The capability of a data object to modify itself may signify that the data object is of higher risk than data objects that are more straightforward. While many instances of malware on PCs use self modifying code to hide from anti malware systems copy protection systems also often encrypt code to prevent unauthorized access thus self modification alone may not be sufficient to classify a data object as malicious it may be used by an analysis system in addition to other characteristics such as behavioral data to produce an assessment for the data object.

In an embodiment server analyzes behavioral data to determine capabilities for a data object. For example server may look for a data object making phone calls sending SMS messages accessing the internet or performing other actions that indicate a particular application capability. In some cases it is important not only to understand what single functions are utilized by a data object but also whether an application exchanges data between APIs. For example an application that uses the internet and can read a device s contact list may have multiple capabilities that have significantly different risks. For example an address book application that simply uses the internet to check for updates has less of a privacy risk than an address book application that reads contacts and sends those contacts to the Internet. In an embodiment server analyzes data object to determine if there are code paths by which data returned or produced by one API or service are sent to another API or service. For example server may perform taint tracking between two APIs to determine if whether an application transfers data between APIs. For example server may determine if there is a code path in a data object by which data returned by any call to the contact API on a mobile device can be provided to any network API on the device. If there is such a code path server determines that the data object has the capability of sending contacts to the internet. Having such a capability may be more valuable during further analysis by server or by a user than simply knowing that an application accesses contacts and that it accesses the internet. Many applications may use both permissions however fewer may actually send contact data to the internet. A user or an automated analysis system will be able to use the capability of knowing that there is a code path between two APIs as a much stronger indicator of capabilities than less granular capability measurements.

In an embodiment server runs a data object in a virtual e.g. simulated or emulated or physical device and analyzes the behavior of the data object when run. In an embodiment the virtual or physical device is instrumented so that it reports behavioral data for the data object. In an embodiment the virtual or physical device s network traffic calls and SMS messages are analyzed by server . For example a virtual device may be configured to always report a specific location via its location APIs that are unlikely to occur in any real world circumstance. By analyzing the device s network traffic for various encodings of that location such as a binary double encoding base encoding and text encoding server is able to determine whether the data object attempts to report the device s location to a server. In an embodiment server examines the difference in state of the virtual or physical device before the data object is run on the device and after the data object has run. For example a data object may exploit the kernel on a device upon which it is installed in order to install a stealth rootkit. In this case a virtual device may show a substantial difference in certain sections of memory such as in a system call dispatch table that should not change under ordinary circumstances. In an embodiment the physical or virtual device has a custom root certificate authority in its list of trusted certificates and server intercepts all TLS traffic using a server certificate that is signed by the custom certificate authority and proxies the traffic to its original destination. Because the device has a custom certificate authority the data object is able to establish a valid TLS connection through server and all encrypted traffic is able to be analyzed by server .

Aside from capabilities of a data object it may be important for server to gather metrics relating to a data object s effect of running on a device or its usage of capabilities on a device. For example overuse of network data email or SMS messaging may be considered abusive or indicative of a malicious or exploited application. In an embodiment server analyzes application data from many mobile communication devices such as metadata and behavioral data device data and other data it has available to it to produce metric data that characterizes a data object. For example server may determine how much battery usage an application requires on average for all devices or for a particular device type how much data a data object sends over any network interface or over cellular vs. Wi Fi network interfaces how many email messages or SMS messages a data object sends how many telephone calls an object makes and other metrics.

Server may produce other characterization information from what has been described above that may aid in further analysis by server to produce an assessment or that may be exposed directly by server . In an embodiment server analyzes network traffic information associated with a data object to produce network characterization data such as a list of the servers the data object has connected to the ports and protocols on those servers data object communicates with how much data is transmitted to and received from each server In an embodiment network characterization information includes what proportion of devices running a particular data object connect to each server. For example an application that connects to an IM server or a known malicious bot command and control server may connect to only one or a small number of servers on all devices that it is installed on however a web browser or application that allows user specified connections may connect to a very large number of different servers on different devices. In an embodiment if a data object connects to many different servers server informs one or more devices to not collect network behavioral data for that data object to minimize unnecessary data reporting. In an embodiment the network traffic information is gathered as behavioral data from mobile communication devices or gathered by server running the data object on a virtual or physical device.

In an embodiment server determines whether a data object causes a mobile communication device to access malicious Internet or other public or private networks. For example a data object that causes a mobile communication device to access a malicious website may subject the device to exploitation. An embodiment of this disclosure allows for resolution of transmitted Inter or Intranet addresses e.g. URLs to determine whether the address will direct the mobile communication device to a safe website rather than a nefarious website or phishing scam. This information can be stored as it relates to a particular data object.

In order for a user to apply application policy to a mobile device without having to make a separate decision for every single application it may be helpful to categorize applications so that the user may simply decide which categories of applications to allow or deny. In an embodiment server categorizes a data object using data it has available such as application data device data marketplace data and characterization data. For example if a data object is characterized as calling location APIs on a mobile communication device then server may categorize the data object as a mapping or other location based application. In an embodiment categories may directly map to capabilities such as applications that read your contact list or applications that can send your location to the internet. Other example categories include whether a data object transmits any information from a mobile communication device s contact list whether a data object causes other data such as a device s phone number to be transmitted by a mobile communication device and other behaviors that may affect the privacy security of a mobile communication device. In an embodiment server uses metric data for a data object to categorize it. For example server may have a category of heavy battery users that includes data objects that typically use more than 10 of a device s battery. Because the categorization may be dependent on device data in addition to characterization data the category of battery wasters may depend on what type of device an assessment is for. For example a data object that uses more than 10 of one device s battery may use only 5 of another device s battery.

In an embodiment if a data object does not directly provide categorization information server can deduce such information. For example if a data object communicates with a known instant messaging server server may determine that the data object is an IM application. For example applications that connect to servers belonging to a popular social network may be classified during analysis as social networking applications applications that connect to a known malicious IRC server may be classified as a malicious bot and applications that drain one or more devices batteries may be flagged as battery drainers.

Because the categorization of an application may be subjective and difficult to determine automatically it may be desirable to have one or more persons internal to an organization or as part of a collaborative community effort determine categories for an application. In an embodiment server exposes an interface by which users can suggest categories for a data object. For example server may define a category of applications that are inappropriate for children the applications having content that includes pornography or violence. In this example one or more users can sign in to a community voting system provided as a web application where they can search and browse all applications known to server . The list of applications may be populated by marketplace crawling and application data reported by devices. Each application may have a page whereby users can select their recommended category for that application. In an embodiment the user interface shows information about the data object such as aggregated application data characteristics for the data object and other information available to server so that users can make a decision based on the output of analysis. In an embodiment the user interface allows a user to select from a list of categories add new categories and add tags for a data object. In an embodiment the user interface has a discussion component so that that people may discuss the appropriate categorization for a data object. In an embodiment the category for an application is determined by a voting system by which users may select their preferred category for the application the category selected by the most users being the authoritative category for the application. In an embodiment the user interface is displayed on a mobile communication device displays a list of data objects installed on the device and allows a user to suggest categories for those data objects.

In an embodiment server processes application data and device data to determine distribution data for a data object. Distribution data may include how widely a given application is currently distributed what the growth of the application s distribution has been over the period of time that the application has been available what customer demographics such as geography have installed the application and other functions of the prevalence of an application amongst groups of mobile communication devices. For example server may examine how many mobile communication devices report having installed a data object at the current time to determine how prevalent that application is. In an embodiment server uses distribution data to determine trustworthiness of a data object or to analyze a data object for risk as is discussed below. For example an application that has been installed on many devices for a long period of time without being uninstalled is likely to be less risky than an application that is brand new and only installed on a few devices.

Because server may encounter legitimate applications that are in development and therefore are not distributed widely an embodiment of this disclosure is directed to server identifying which applications may be in development thereby preventing them from being classified as undesirable in an anti malware or other system. Server may receive application data for a data object indicating that the data object has characteristics inherent to applications in development such as debugging symbols debuggable permissions or flags linkage to debugging libraries and other characteristics. Applications in development may also be likely to have low distribution or isolated distribution. If server identifies that an application is in development it may store an indication of the application being considered in development and use the indication to prevent server from assessing the application as suspicious or undesirable or to decrease the likelihood that the server reaches such assessments. In an embodiment when determining whether a data object should be treated as in development server considers previous data objects encountered by devices that encountered the data object in question. If the devices frequently encounter data objects that are in development server is more likely to classify the data object as in development. If the devices infrequently encounter data objects in development server is less likely to classify the data object as under development.

In an embodiment server establishes the reputation or level of trust for the data object. In an embodiment the level of trust is determined manually or automatically and assigned to a single data object multiple data objects that are part of an application multiple versions of an application or for all applications from a given developer on one platform or multiple platforms. In an embodiment trust data is stored by server on the server or in data storage so it may be subsequently used directly or as part of producing an assessment.

In an embodiment trust is granted via a manual review process for an application. For example if server deems application to be risky based only on its capabilities e.g. has access to private data and or utilizes sensitive APIs a user viewing the assessment may choose not to download it even if the application is well regarded. To solve this problem the application may be assigned a trust rating by manual review. If the review deems the application to be trustworthy the assessment reports the application as not risky however if upon review the application is determined to be suspicious the assessment may continue to report the application as risky. Because a reputable application may consist of multiple data objects may be updated with new data objects or may have versions for multiple platforms it may be important to allow a trust rating to span multiple data objects applications and even platforms so that a manual review does not need to be completed for every version or file that is part of an application. Similarly because many reputable software vendors may produce multiple applications that can be assumed to be trustworthy it may be desirable to automatically grant a high level of trust to data objects identified to originate from those vendors. In an embodiment server grants a data object a high level of trust if the data object can be attributed to a trusted vendor or trusted applications through data available to server such as the data object s cryptographic signer package name or marketplace metadata.

In an embodiment server uses distribution data and application data to establish trust for an application. For example if a popular application such as Google Maps is installed on millions of mobile communication devices and there are multiple previous versions of the application all having the same cryptographic signer and similar distribution characteristics subsequent versions of the application with that cryptographic signer would be deemed to have a high level of trust. If server encounters another application that has the same name as a popular application such as Google Maps is installed on only a few devices and uses a different cryptographic signer server may grant the low distribution application a low level of trust. An anti malware system may use such data indicating that a data object has low trust to automatically assess a data object as undesirable or to flag it for manual review. In an embodiment trust data for an application may take into account associated applications such as applications determined to be created by the same developer on the same platform or on different platforms. For example if a company produces an application for one mobile platform that has a large number of users and good ratings and the company releases a new application on a different platform the new application may be given a high trust rating based on its association to the first application.

In an embodiment server analyzes application data to determine if a data object is part of a mobile communication device operating system or preloaded by a manufacturer or operator. In an embodiment if server determines that a data object is part of a mobile operating system or is preloaded it is be granted a high level of trust automatically.

In an embodiment server analyzes user generated ratings and comments for an application such as those gathered by application marketplace data gathering system . For example server may use ratings and reviews to determine a trust rating for the application. If an application has low ratings and negative comments indicating that the application crashes or is otherwise bad server assigns the application a low trust rating based on the reputation indicated in its comments however if an application has consistently high ratings and many reviews server assigns the application a high trust rating. In another example server uses ratings and reviews to as a subjective indicator of application quality for use in producing assessments for the application. If an application has a significant number of reviews with text indicating that the application drains battery or sucks battery server determines that the application has the reputation of having adverse battery effects and produces an assessment of the application indicating that.

In an embodiment server exposes trust data to third parties via an API. For example trusted applications may be considered certified by lookout. In an embodiment the trust level exposed by the API is binary e.g. trusted not trusted fuzzy e.g. 86 trusted 11 trusted or categorical e.g. fully trusted malicious suspicious semi trusted . Mobile application marketplaces may wish to display an indicator of this certification on an application download user interface as a signal that the application has a good reputation. In this case server may expose an API by which third parties can supply a data object or identification information for a data object such as a hash identifier package name or cryptographic signer. After receiving a data object or enough information to identify one server responds with an indication of whether the data object is considered certified or not. In an embodiment the response is an image indicating whether server considers the data object to be certified or not. In an embodiment the response contains a hyperlink to server whereby a user can verify that the certification for the application is genuine. In an embodiment the web page referenced by the hyperlink shows additional information about the application such as why it was considered trusted or not e.g. through manual review comments distribution data what permissions are requested by the application characteristics and capabilities the application has and commentary about the application during manual review.

Using data gathered by server or from an analysis system described herein server may produce an assessment block of . After producing the assessment server may store the assessment of the data object so that it may be retrieved at a later time block . Server may then transmit the assessment for the data object block . For example server may publish the assessment on an application provider website provide the assessment in the form of searchable reports transmit a notification to a mobile communication device transmit virus signatures containing the assessment that a given data object is known good or known bad and transmit a response to an API call querying for the assessment of the data object. Such information can be in the form of readable text a machine readable format or may include a score a badge an icon or other symbolic rating. One skilled in the art will appreciate that other situations in which server transmits an assessment for the data object are possible without departing from the scope of this disclosure.

In an embodiment assessment data includes the output from an analysis system such as characterization data categorization data trust data and distribution data. For example an assessment for a data object may include solely or in addition to other information detected capabilities for the data object average battery usage for the data object average number of SMS or email messages sent by the data object the most common servers the data object connects to the average amount of network data for the data object and trust ratings for the data object. One will appreciate that the above assessment data may be provided as an input into to server . For example a network operator or enterprise may operate a server that produces assessment data and feeds it data back to a master server. In another example users may determine assessment data and provide it to server via an interface such as a web application. In this case users may provide subjective trust data risk ratings a categorization or other assessment data that may be used by the server. In an embodiment server combines assessment data received from multiple sources to produce an aggregated assessment. For example if a malware author attempts to transmit an assessment to server indicating that a malicious application is safe in the hopes of causing server to produce a false assessment the server may utilize the number of unique sources providing assessments and the trustworthiness of those sources to produce the aggregated assessment. If one hundred assessments are received from different reliable sources such as network operators and enterprises that indicate the application to be malicious but ten thousand assessments from a particular unverified source indicate the application to be safe the server produces an aggregated assessment indicating the application to be malicious.

In an embodiment assessment data produced by server includes one or more ratings for a data object. For example an assessment for a data object may include a rating for the data object s privacy by server taking into account whether the application has the capability to send location data contact data SMS messages or files from a device to a server. In another example an assessment for a data object may include a rating for the data object s security by server taking into account whether there are any known vulnerabilities for the application whether the application listens for network connections on any ports whether it meets secure coding guidelines what the trust level of the application is and whether there are any anomalies in the application e.g. stealth code decrypted code structural anomalies . In another example an assessment for a data object may include a rating for the data object s battery impact such as estimated number of minutes of phone battery life reduction by server taking into account by taking into account the battery usage data reported by devices. In another example an assessment for a data object may include a rating for the data object s performance that is produced by server taking into account the average CPU usage of the application and the frequency which the application does not respond to user input events. In another example an assessment for a data object includes a quality rating that is produced by server taking into account the frequency of application crashes user comments user ratings and the average time the application is kept on devices. In an embodiment server provides multiple ratings as part of one assessment so as to provide information about a data object along multiple dimensions. In an embodiment assessments may be binary e.g. good bad or fuzzy e.g. 100 90 10 . In an embodiment multiple ratings are combined into an overall rating.

In an embodiment server processes multiple data sources available to server to produce a rating for the data object. For example server may utilize application data device data characterization data trust data distribution data and user supplied data to determine if an application is malicious. The server may utilize a variety of systems or models applied to the data available at the server to produce the assessment. For example producing an assessment of whether a data object is malicious may involve a malware detection system that includes a heuristic engine that analyzes characteristic data to identify behavior of data objects that are likely to be malicious. Some example heuristics include detecting whether a data object utilizes any capabilities to evade detection by hiding from application enumeration systems on an the OS it is installed on whether an application attempts to modify itself whether an application has capabilities associated with known spyware and whether an application connects to known malicious servers.

One skilled in the art may appreciate that part of the analysis performed at server to produce an assessment may be seen as extracting features for a data object and another portion of analysis may be seen as applying a model to those features to produce a useful assessment thus one may apply a variety of systems such as artificial intelligence systems or algorithms to process the features for a data object to reach a desired form of rating or assessment.

In an embodiment server produces multiple assessments for a data object that take into account different device data or configuration information. For example if server is configured to produce assessments of whether a data object will function correctly and if a data object malfunctions when installed on one type of device but functions correctly when installed on another device type server may produce two assessments for the data object. If server has an API by which a mobile communication device can request an assessment for a data object given identifying information for the data object and the mobile communication device has sent device data to server then server can provide the assessment for the data object that corresponds to the device requesting the assessment. If a device where the data object would malfunction requests an assessment then server will return the assessment indicating the malfunctioning behavior of the data object on that device . If a device where the data object would function correctly requests an assessment then server will return the assessment indicating the correctly functioning behavior on that device .

In an embodiment an assessment indicates whether a data object is allowed to run on a device given policy set by an administrator. If multiple policies are configured on server and data storage stores which policy is to be applied to a device then a given data object may have multiple assessments that depend on the policy of the device querying for an assessment. For example if a device with a strict privacy policy requests an assessment for an application that can share a user s location server transmits an assessment indicating that the application is disallowed. If a device with a lenient privacy policy requests an assessment for the same application server transmits an assessment indicating that the application is allowed. In an embodiment assessment data is not stored and only information used to produce the assessment such as application data device data distribution information characterization information trust data and categorization information is stored and the assessment is performed upon request by applying policy to the stored information.

Although automated analysis systems may produce acceptable results most of the time there may be situations in which manual analysis overrides the result of automatic analysis. In an embodiment server stores manual analysis results for a data object and transmits the manual analysis results as an assessment. For example server may categorize an application as a social networking application based on its behavioral data however the application may actually be a word processing application that allows the user to publish notes to a social network. In this case a user or administrator may override the categorization for the data object server storing the categorization and transmitting it in response to a request for an assessment for the data object. In another example an anti malware system identifies data objects having certain characteristics as undesirable. It may also be desirable for a user to manually configure server to treat particular data objects as undesirable. Server stores a list of data objects that are considered undesirable and when asked for an assessment for one of these data objects returns an assessment indicating that the data object is undesirable.

Because it may be desirable for assessments about a data object to reflect the most up to date information available in an embodiment server first produces an assessment and then updates it if additional application data or device data becomes available or if the analysis system itself is updated. In an embodiment if a data object is re assessed e.g. because of new application data device data or updated analysis systems server stores the new assessment and transmits it . For example after gathering device data and application data for a data object from ten devices server may generate an assessment for that data object. Then if server receives device data and application data from one thousand more devices it may re analyze the data object in light of the new data producing a new assessment for the data object. If the updated assessment is materially different from the first actions such as notifying devices or users may be performed by server .

In an embodiment server and mobile communication device are configured to function together to prevent malware or spyware from adversely affecting mobile communication devices. Because mobile communication devices are limited in memory processing ability and battery capacity it may be desirable for server to perform analysis such as the analysis described herein to determine if an application is considered to be malware or spyware rather than each device performing the analysis. Furthermore it may be desirable for server to store the results of the analysis so that if multiple devices encounter the same application the analysis does not need to be repeated. Additionally it may be desirable for server to collect data about potentially malicious applications using data collection systems described herein in order to provide data from a variety of sources for use by analysis systems.

In an embodiment when mobile communication device assesses a data object such as an application package or executable to determine whether the data object is malicious or otherwise undesirable the device sends a request to server for an assessment of the data object the request containing identifying information for the data object. In an embodiment the request transmitted by mobile communication device contains application data for the data object for use by the server in performing the assessment. For example in addition to transmitting identifying information such as an application s package name and hash mobile communication device may additionally transmit the permissions requested by the data object and information such as a list of APIs utilized determined by the device by performing static analysis.

In an embodiment mobile communication device gathers metadata for a data object by using operating system provided facilities and potentially additional processing. For example both the Blackberry and Android platforms provide mechanisms by which an anti malware application can query the list of packages installed on a device. Each also provides methods to query additional information about the packages such as cryptographic signature information and information about how the packages choose to integrate or expose themselves to the operating system.

In another example mobile communication device may extract features from a data object to assist in server producing an assessment. In an embodiment mobile communication device performs static analysis on the data object to extract application data to transmit to server . For example on Android the device may analyze the executable portion of an application packages typically called classes.dex . The device may extract a list of inter process communication calls directly or indirectly performed by the executable file that utilize the binder mechanism and transmit information about the calls to server for use in analyzing the application package.

In an embodiment server may analyze the data object immediately or may need to gather additional information using a process such as one disclosed herein. After producing an assessment for the data object the server transmits the assessment to mobile communication device . In an embodiment the assessment contains an indication of whether the data object is considered undesirable or not. For example server may transmit one of three assessments known good known bad and unknown. If the server determines that the data object is known to be good e.g. because it has a high trust level it will return an assessment that the data object is known good. If the server determines that the data object is known to be bad e.g. because it is determined to be a piece of malware it will return an assessment that the data object is known bad. If the server does not have enough information to make a determination it will return an assessment that the data object is unknown. In an embodiment the assessment contains a risk level of the data object or a confidence level of the known good or known bad assessment so that mobile communication device or its user can use the risk or confidence level to determine how to classify the data object.

In an embodiment the assessment transmitted by server to mobile communication device contains information as to why server determined that the data object was undesirable. For example server may transmit the name of a malware family the data object was determined to belong to or server may transmit an HTTP URL referencing server that mobile communication device can use to display additional information about the data object the URL containing an identifier that is decoded by server to allow it to retrieve stored information about the data object. The web page may display additional information such as the output from different analysis systems used to produce the assessment. For example the web page may display distribution information for the data object information about common servers connected to by the data object information provided by human analysis of the data object trust data associated with the data object information about the geographic distribution of the data object information about similar data objects and information about the author of the data object.

It may be desirable to minimize requests mobile communication device needs to send to server for assessments of data objects so that the device minimizes the amount of data it transmits and receives reduces time required to assess a data object optimizes battery consumption and minimizes load on server . In an embodiment a mobile communication device maintains a local cache of assessment information received from server . The local cache may be stored using a lightweight database such as SQLite or in a proprietary binary file format that is optimized for assessment storage. For example the cache may contain an indication as to whether a data object was undesirable or not a risk level associated with a data object and definition information such as identifying information for a data object. When a device scans a data object it can look up the data object s identifying information in the local cache. If an assessment for the data object is cached that assessment is used. If an assessment is not cached the device retrieves an assessment from server . In an embodiment when a mobile communication device inserts an assessment into its cache for a data object encountered on the device it generates definition information for the data object. For example a device may use the hash of a data object s content to ensure that it caches assessment results from a server. In an embodiment server transmits definition information with an assessment so that mobile communication device can apply the assessment to the appropriate set of applications. For example in some cases server may indicate that an assessment only applies to a specific data object identified by a hash of its contents while in other cases the server may indicate that an assessment applies to all data objects signed with the same cryptographic key.

In an embodiment a mobile communication device stores a local cache of definitions for known good data objects and known bad data objects for use by a recognition component described below operating on the mobile communication device. Using the recognition component the mobile communication device can determine an assessment for a suspect data object if the local cache contains a definition and corresponding assessment that corresponds to the suspect data object. For example the definitions may use criteria such as hash identifiers package names and cryptographic signers to match a data object. Each definition may have a corresponding assessment e.g. good bad . If a definition matches a suspect data object the definition s assessment is used for the suspect data object. If no definitions correspond to the data object such as the data being recognized as safe or not safe then the mobile communication device may transmit application data for the suspect data object to server for more comprehensive analysis.

In an embodiment the cache is used as the primary storage of anti malware definitions that determine whether anti malware software on mobile communication device will recognize a data object as malicious or not without having to consult server . In an embodiment the cache stores definition information used by a recognition component on the device. For example the cache may contain definition information such as package names cryptographic signers byte sequences patterns or logic that is used to match data objects on a device with cached assessments. If the cache contains an entry linking a particular byte sequence to an assessment of being a malicious application and a data object on a device contains that byte sequence then the device will determine that data object to be malicious without having to contact server . In an embodiment the cache only contains definition information all definitions corresponding to a single assessment of a data object being malicious. In an embodiment the cache may contain assessment information the assessment information possibly containing an identifier as discussed above which can be transmitted to server in order for the device to retrieve information for display to a user. Such an identifier being used to retrieve data from server allows the cache to minimize the information it stores about potential malware. In an embodiment a device cache serves as both a whitelist and a blacklist. The cache contains definition information for known good and known bad data objects so that if a data object is determined to be known good or known bad the device does not need to request an assessment from server . In an embodiment the cache that serves as both a blacklist and a whitelist is used by a recognition component on the mobile communication device to determine if data objects are recognizably bad or recognizably good. If a data object encountered by a device is neither recognizably good nor recognizably bad based on definition data stored in the cache then the device may transmit application data for the data object to server so the device can receive an assessment for the data object from the server. In an embodiment anti malware software on a mobile communication device is installed with a pre populated cache of definitions that are modified by the device as it receives new assessments or stored assessments are deemed to be invalid.

In an embodiment assessments and definitions cached on a device are only considered valid for a period of time so that the mobile communication device does not rely on data that is potentially out of date. In an embodiment cached assessments and definitions are stored indefinitely and considered to be valid without time constraint. In an embodiment a device only stores certain types of assessments and definitions. For example a device may only cache known good assessments or may only cache known bad assessments. In this case definitions are only stored if they have a corresponding assessment. In an embodiment part of the cache is stored in volatile storage such as RAM and part of the cache is stored on non volatile memory such as flash. Because volatile memory is typically more limited yet much faster than non volatile memory a device may store frequently accessed assessments and definitions in volatile memory while less frequently accessed assessments and definitions in non volatile memory. For example if an anti malware system analyzes data objects every time they are opened it may be desirable to very quickly determine an assessment for a data object if it has been recently scanned and not changed. By storing a recently used definition and assessment in volatile memory the device can recall the previous assessment very quickly.

In an embodiment server transmits cache control information with an assessment indicating whether the device should cache it and if so for how long. For example server may transmit an assessment for a popular application from a reputable company including cache control information indicating that a device should cache the assessment. If server transmits an assessment for a lesser known application it may include cache control information indicating that a device should not cache the assessment as the application may turn out to be considered undesirable in the future after more is known about it. In an embodiment server determines cache control information based on the confidence of an assessment. For example known good assessments for applications that have a high trust level may be considered to be highly confident while assessments indicating that an application is unknown due to lack of data available to the server may not be considered confident. In an embodiment when an assessment expires cached definition information associated with the assessment is also expired.

Because retrieving cached assessments is faster than retrieving assessments from server thereby minimizing the delay and overhead with determining whether a data object is malicious or not it may be desirable to maximize the number of assessments that can be determined locally from cached data. In an embodiment server transmits assessments to a mobile communication device without the device requesting the assessments and the mobile communication stores these assessments in its cache. Because all of the assessments available to server may require more storage than is desirable on mobile communication device server may only transmit a subset of its available assessments. In an embodiment server determines which assessments to transmit to mobile communication device by analyzing device data and application data. For example server may store the operating system a data object is compatible with associated with assessments for data objects in such a way that the server can query for all of the assessments related to a given operating system. Server may then only transmit assessments to a mobile communication device that are for data objects that are compatible with the operating system the device is running. The other assessments would not be transmitted to the device because the data objects referenced by the other assessments are not able to run on the device s operating system. In another example server may use a device s country language or area code to determine what assessments to transmit to the device. Users in the United States are unlikely to download Russian language applications just as users in Russia are unlikely to download Spanish language applications.

In an embodiment server stores which assessments it has already transmitted to a device and the device has successfully received so that assessments are not unnecessarily re transmitted. If a device has not received assessments that are desired the server transmits the assessments the next time the device connects. In order to efficiently track which assessments have already been received by a device server may group assessments such that a given device receives all assessments in one or more groups. For example a given group of assessments may have changes e.g. new data objects being assessed changes to existing assessments multiple times per day however a device may be configured to receive updated assessments only once per day. To determine what assessments to transmit to a device server may record the time when a device has last received up to date assessments for a group and only examine changes to the group since the device has last received assessments. For example if a device receives all of the assessments for a given group on Monday and two new assessments are added to the group on Tuesday then if the device connects on Wednesday the server only needs to query what assessments have changed in the group since Monday and will determine that it needs to transmit just the two added assessments. In an embodiment server utilizes a push service such as one described herein to alert a device that there are additional assessments that server is ready to transmit to the device. When using such a push service when server updates assessments that are part of a group all devices that receive assessments from that group can be updated with the latest assessments nearly immediately.

There are a variety of ways in which assessments can be grouped by server in order to selectively transmit assessments to a device. For example there may be more assessments for data objects compatible with a given operating system than it is desirable to store on a device. In this case the server may produce a group of assessments that correspond to the most prevalent data objects based on distribution data or market data available to server . In this case devices will cache assessments for the data objects they are most likely to encounter. It is also possible to further improve the likelihood that a device has assessments cached for data objects it encounters by server analyzing the application data available at the server corresponding to the data objects previously encountered by the device and predicting based on those previous encounters what data objects the device is likely to encounter in the future. Assessments for these likely data objects can then be transmitted to the device.

Because the optimal amount of assessment data to cache on a device may be different depending on a device s hardware user behavior or user preferences it may be desirable for that amount of data to be tunable. In an embodiment the amount of assessment data to cache on a mobile communication device is determined by server . For example server may examine the amount of storage available on a device the frequency by which a user downloads applications and how likely additional cached assessment data will be to reduce the number of required assessment requests transmitted by the device. If a device has a lot of available storage and its user downloads a lot of applications then the server may determine to cache a large amount of assessment data however if a device has little available storage and its user rarely downloads applications then the server may determine to cache only a small amount of data or no data. The server may also examine previous assessment requests made by the device to determine if those requests could have been avoided by the device caching additional assessment information. For example if a device currently receives assessments belonging to a particular group of applications and the server is evaluating whether device should receive assessments for an additional group of applications the server examines previously assessment requests to determine how many of those assessments were in the second group. If server determines that enough of the assessments requests would have been avoided then it will start transmitting assessments from both groups to the device. In an embodiment a user can control the amount of storage to allocate to cached assessments on a mobile communication device .

Instead of always producing an absolute assessment e.g. known good or known bad it may be desirable for server to report that it does not yet have an assessment. In an embodiment server transmits an assessment for a data object indicating that the object s undesirability is unknown. When mobile communication device encounters a data object it transmits a request to server for an assessment and receives an unknown assessment the device temporarily trusts the data object and retries the request for assessment at a later time. In order to avoid unnecessary requests the device increases the time delay between retries if it continues to receive unknown assessments. During such a period of temporary trust the device does not re transmit an assessment request every time a data object is scanned. For example in an anti malware system on a mobile device designed to scan files on a file system when they are accessed the first access to a data object may result in the device transmitting an assessment request to server . If the server returns an unknown assessment then the device stores a temporary entry in its assessment database indicating identifying information for the data object a temporary assessment indicating that the data object is allowed and the time period the assessment is valid for.

In an embodiment server transmits information about a data object in an unknown assessment and mobile communication device uses the data assessment from server as an input into a local analysis system. For example mobile communication device may have a heuristic system that analyzes the content of a data object to determine if it is malicious. In the case of a known good or known bad result from server then the device either does not run the heuristic system or discards the result from the heuristic system. If server returns an unknown result including a trust level for the data object device combines result from the heuristic system with the trust level provided by the server to determine whether to treat the data object as undesirable or not. For example mobile communication device may scale the result from local analysis based on the trust level reported by server . If a heuristic system on the device determines that a data object is 66 risky and an unknown assessment from server indicates that the data object has a suspicious 1 trust level the device determines that the data object is undesirable however if the unknown assessment from server indicates that the data object has a 70 trust level then device determines that the data object is desirable.

In order to respond to undesirable applications such as malware and spyware as soon as they are identified as such it may be desirable for server to transmit notifications to mobile communication device about data objects that are determined to be undesirable after previously being classified as good or unknown. In an embodiment server stores information about data objects encountered by mobile communication device so that if a data object encountered by the device was assessed to be good or unknown but was subsequently determined to be undesirable server may determine all of the devices that have encountered the data object and transmits a notification indicating that the data object is undesirable. In an embodiment server only transmits a notification to device if the data object that is the subject of the notification can operate on the device s operating system. For example if a device runs Blackberry and has encountered an Android spyware application server would not transmit a notification to the device however if the device encountered a Blackberry spyware application server would transmit a notification. As disclosed herein the determination of whether a data object can operate on a given device may be determined by analyzing device data for the device and application data for the data object.

In an embodiment the notification transmitted from server to device is designed to be consumed by the device and includes both identification information and remediation information for the data object. For example the notification may utilize a push service provided by a platform vendor and include the package name and content hash for a data object. The notification may also specify a remediation action such as killing any processes containing the data object requesting for a user to uninstall the data object and deleting the data object without user intervention. In an embodiment the notification includes information for display to a user about the data object such as remediation instructions an explanation for why the data object is considered undesirable or a request to take a particular action. In an embodiment the notification is in the form of a human readable message such as a text message email or telephone call. It may be desirable for server to perform both human readable and machine readable notification to ensure that a user responds to a dangerous data object. For example server may transmit an email message to a user and transmit a notification for the device to remove the data object without user intervention.

In an embodiment mobile communication device contains a database of all data objects that are present on the device and server transmits updated signature data to the device when a data object encountered by the device is determined to be undesirable. When the device receives the updated signature data it compares the updated signature data to data objects present on the device. If any objects that are present on the device are considered by the updated signature data to be undesirable then the device immediately initiates remediation actions not waiting for the next time the data object is scanned.

If an anti malware system performs an assessment for a data object it may be desirable to trust the data object as long as it hasn t changed to avoid having to re assess the data object. In an embodiment mobile communication device maintains a list of data objects identified that have been analyzed and are considered to be desirable. When a data object is desired to be scanned the device may first check this list to see if the data object is present. If the object is present the device does not re scan the object. After scanning a file and determining it to be desirable the device places an identifier for the data object in the list. Example identifiers include a file name filesystem node identifier or operating system specific data object handle. In an embodiment the mobile communication saves this list of data objects to non volatile storage so that the list can be preserved even if the device is rebooted or runs out of battery. When storing assessments and later accessing them it s important that any stored assessments are valid only for a particular set of data object content. If the data object s content changes a different assessment may be necessary as the data object may have been modified to include malicious code that was not present in the original data object. In an embodiment the list contains a cryptographic hash of the content of the data object. When the device determines whether the data object is considered to be on the list it compares the hash of the data object as stored on the device with the hash stored in the list. If the hash matches the data object is considered to be on the list. In an embodiment the anti malware software can determine when files are opened and closed. If a file on the list is opened with write access then it is removed from the list. While there are open writers to the file the file cannot be added to the list.

One will appreciate that an embodiment of this disclosure contemplate other ways for reducing network traffic while providing sufficient options for securing mobile communication devices. In an example a mobile communication device can request an analysis of all of the data resident on the device a scan when the mobile communication device first starts up or powers on or when the application responsible for monitoring the mobile communication is first launched. This provides a baseline analysis of the security of the mobile communication device. Future scans may be performed when new applications are accessed by the mobile communication device or at pre set time intervals or upon user request. Scans may be adjusted depending upon the access to network . If connectivity is an issue then only newer data may be assessed or suspect data. Scans may be queued and performed when connectivity improves.

In an embodiment an anti malware system on mobile communication device has the capability to perform both an on demand and a scheduled scan of all data objects present on a device. If the anti malware system utilizes server to perform assessments for the data objects it may be desirable to optimize the time required to perform the scan. Because network latency causes a delay between the time a request for an assessment is transmitted by a device and the time the device receives a response from server it may be desirable to pipeline requests in such a way that the device does not simply idle while waiting for a response. In an embodiment mobile communication device transmits a request to server to provide assessments for multiple data objects and server transmits assessments for those multiple data objects to the device. For example during an on demand scan a device may be configured to first enumerate all of the data objects on the device and then send a request to server to assess all of the enumerated data objects. In another example a device may enumerate ten data objects at a time then send a request to the server and receive a response for those ten data objects before scanning additional data objects. In another example a device may enumerate data objects and transmit assessment request continuing the enumeration process without waiting for assessment responses from the server. The device may only wait for responses when the enumeration is complete.

In an anti malware system that blocks the loading or executing of a data object until the system has reached a disposition it may be desirable to assess a data object before it needs to be loaded or executed. In an embodiment mobile communication device proactively scans data objects and stores the results so that when the data object is loaded the device can reference the previous scan result. For example when a device loads a program that depends on multiple other files e.g. an executable that is linked to shared libraries an anti malware system on the device may analyze the program to determine all of the libraries it depends on send a request to server for assessments for the program and its dependent libraries and then allow the program s execution to proceed once the device receives positive assessment results. When the device s operating system loads the libraries the application depends on no request to server is needed because the system already has up to date assessments for the libraries. If the libraries were not proactively analyzed the total load time for the program could be greater as the device may have to wait for multiple requests to server to occur in serial. In an embodiment software on a mobile communication device analyzes data objects after they are downloaded but before they are executed. For example anti malware software on a device may watch the download directory for new files or may simply wait for files to be created written to and then closed. After the download completes the software may initiate a scan of the new file so that once the file is opened the system already has assessed it and can recall the previous assessment.

If an anti malware system blocks user requested or system operations while it is assessing a data object it may be desirable to give the user an indication that an assessment is in progress especially if the assessment depends on a network connection that may have significant latency. In an embodiment an anti malware system on mobile communication device displays a user interface indicating that a data object is being scanned when the system is scanning the data object and blocking user requested operations. For example if an anti malware system prevents the execution of applications until the application and all of its dependent libraries have been assessed by interposing itself in the application launch process there can be a significant delay perceivable to the device s user. The annoyance associated with the delay may be mitigated by informing the user what is happening instead of the device simply seeming unresponsive. When a user launches an application the device displays a user interface view indicating that the anti malware system is assessing the application that the user launched. In an embodiment the user interface allows the device s user to skip waiting for the scan to finish. For example if the device s scanning of a data object needs to connect to server and the user doesn t want to wait the user may proceed without waiting for the assessment to return. If the assessment subsequently returns that the data object is malicious the device may initiate remediation actions such as killing any processes containing the data object and deleting the data object even though the data object was allowed to run.

A user may be interested in having an application assessed but does not wish to wait for a response from server . The user may choose to forego complete analysis and use the application while waiting for analysis results. In such a situation it would be helpful if server or the user s mobile communication device could provide a temporary trustworthiness evaluation prior to formal analysis. Reporting can be in the form of an interface element a notification a warning a risk rating or the like. In an embodiment the mobile communication device can run a local analysis to determine whether an application is temporarily trustworthy. It may also be desirable to show information about a data object on a user interface that indicates when an anti malware system is waiting for an assessment from a server so that users do not accidentally skip items that are high risk. In an embodiment the waiting user interface shows the result of local analysis while waiting for an assessment from server . For example the user interface may show the capabilities of the data object or a risk score for the data object. In an embodiment the device only allows a user to skip waiting for an assessment from server if local analysis determines that the data object is low risk. For example a risk score may be calculated by analyzing what sensitive functionality a data object accesses. A data object that accesses a user s contact list and browser history may be deemed more risky than a data object that doesn t access any sensitive functionality.

In an embodiment an anti malware system on device determines whether it should wait for a response from server before reaching a conclusion based on the context of the scan. For example scans that occur during system startup or when there is no active network connection should not block waiting for a response from the server. In order to determine if there is a network connection the anti malware system may rely on a variety of methods such as querying network interface state information provided by the operating system and analyzing whether requests to server time out. If the anti malware system intercepts system calls scans that occur as a result of the system trying to execute a data object should block while waiting for a response from server while scans that result from an application getting information about a data object e.g. file manager extracting an icon for the data object should not block while waiting for a response. In an embodiment if a request for a data object assessment is unable to be completed it is retried at a later time.

In an embodiment the anti malware system skips portions of server or local analysis if an accurate assessment can be produced without the additional analysis. For example if local analysis determines that a data object is not risky then the device may not request an assessment from server the device may only request an assessment from server if the data object being scanned has a minimum riskiness as determined by a local analysis component on the device. In an example the determination of whether to skip waiting for additional results is determined by both the results and which system returned each result. A bad result from local analysis before receiving a result from server may be enough to treat a data object as malicious however a good result from local analysis may still require the system to wait for an assessment from server to confirm that the data object is good before determining a final disposition.

In an embodiment if multiple analysis systems produce different results the anti malware system on a device analyzes the results of the systems to make a determination as to the final disposition of a data object the determination taking into account both what results were produced and which system produced each result. For example the anti malware system may determine that a single undesirable result is enough to flag a data object as undesirable. In another example server may be treated as authoritative or server may transmit a confidence level of its assessment so that device can determine whether to treat the assessment as authoritative or not. In another example known bad results from server may be authoritative but known good results from server can be overridden by a known bad result from a local analysis system on device .

In an embodiment server stores a list of malware or other undesirable applications that have been detected on the device and which are still active on the device. In order for this list to be populated mobile communication device sends events to server including whenever it encounters an undesirable application whenever an undesirable application is removed and whenever an undesirable application is ignored. The events include identifying information for data objects so that server can correlate the events with known data objects. For example because a user may choose to ignore malware it s important for the user to be able to see his or her list of ignored malware to avoid a situation where a malicious user installs malware on someone else s phone and configures anti malware software on the phone to ignore the malware preventing the system from automatically removing it. In this circumstance the legitimate user of the phone is able to tell that a piece of malware is active on his or her device but is ignored. In an embodiment because server has data indicating whether device currently has active malware network access can be allowed or denied to the device depending on its malware state by a network access control system querying server for the state of a given device.

In an embodiment of this disclosure server side or cloud analysis may be performed using a version of the three component system described in U.S. patent application Ser. No. 12 255 621 which is incorporated in full herein. An example of a three component system is illustrated in and includes a first component that may be used to recognize data that is safe or known good also referred to herein as forming part of or being included on a whitelist . A second component may be used to recognize data that is malicious wastes device resources or is known bad also referred to herein as forming part of or being included on a blacklist . A third component is a decision component that may be used to evaluate data that is neither known good nor known bad i.e. unknown. In an embodiment known good component and known bad component may reside on mobile communication device and decision component may reside on server . In an embodiment known good component known bad component and decision component may all reside on server . In an embodiment portions of known good component known bad component and or decision component may reside on mobile communication device and portions of known good component known bad component and or decision component may reside on server . In an embodiment known good component and known bad component reside on server while decision component resides on mobile communication device .

For example data store may contain malware definitions that are continuously updated and accessible by server . The mobile communications device may be configured to send application data such as a hash identifier for a suspect data object to server for analysis. Server may contain known good component known bad component and decision component or the components may be distributed across two or more servers. The one or more servers may thereby use application data to determine if the suspect data object is a recognizably safe data object. If the suspect data object is recognizably safe then the one or more servers may notify the mobile communications device or instruct the device that it may accept and process the data object. The one or more servers may then use application data to determine if the suspect data object is recognizably malicious. If the suspect data object is recognizably malicious then the one or more servers may notify the mobile communications device or instruct the device to reject the data object and not process it further. The known good and known bad components may have a variety of methods for recognizing known good and known bad data objects. The data logic and any other information used by known good and or known bad components to identify recognizably good or recognizably bad data objects respectively may be called signatures or definitions explained further below .

If the known good and know bad components are inconclusive one or more servers may perform additional analysis to reach a decision as to the disposition of the data object. In an embodiment server contains a decision component that uses one or more analysis systems to analyze application data for the data object and make a determination as to whether the data object is considered undesirable or not. In an embodiment if there is not enough information to perform the additional analysis then the one or more servers may request that a mobile communications device send additional application data to the server for analysis. For example a device may initially send a hash identifier package name and cryptographic signer information for a data object to a server for analysis. If the known good or known bad component fails to identify the data object as known good or known bad the server may request that the device send the whole data object to the server so that the data object itself may be analyzed. Upon receiving additional application data further analysis to reach a disposition for whether a device should accept or reject the data object may be performed by a decision component or manually. In an embodiment the server stores whether or not a given data object needs manual analysis so that an analysis team may easily determine what data objects need to be analyzed.

Because an assessment for a data object may rely on human analysis to be produces server may use analysis systems to produce store a list of suspicious data objects that need further study. In an embodiment some results from analysis systems on server produce assessments that are transmitted to mobile communication device and others identify data objects as needing human analysis. For example if server utilizes a set of heuristics to identify malicious applications some set of the heuristics may be well tested and provide acceptable accuracy in correctly identifying malicious behavior while another set of heuristics may be experimental requiring human analysis to determine if the results are acceptable.

The following describes each of the components identified above in more detail. A person skilled in the art will appreciate that since the total number of known good applications for mobile communication devices can be identified use of the known good component coupled to a database logic or other data store containing definitions for known good data objects e.g. application data such as hash identifiers may significantly reduce false positive undesirable application detection and reduce the need to perform computationally expensive analysis or to contact a server for analysis. One will also appreciate that use of a known good component may be particularly effective for data that contains executable software code. Executable software code for a given application rarely changes between different mobile communications devices so creating a database of known good application data or logic for evaluating application data may be an effective method for recognizing safe or trustworthy data. This database may vary in size depending upon the resources available on the mobile communications device. Alternatively aspects of this disclosure such as the known good component and known bad component may have access to a remote server with a larger library of application data for known good or bad data objects such as server coupled to a data store in .

In an embodiment of this disclosure known bad component may have access to a database logic or other data store containing definitions for known bad data objects that can be stored on the mobile communications device without occupying a significant amount of memory. For example virus and other malware or spyware definitions can include application data such as hash identifiers package names cryptographic signers byte sequences and byte patterns stored in a database or other memory cache. In other words there may be a known bad database that complements the known good database stored on mobile communications device . Additionally or alternatively known bad component may be capable of identifying malware using characteristics common to other malicious software code. When applied to network data or data files known bad component may have access to a database containing patterns or other characteristics of a protocol data unit or file format which presents a security threat. Known bad component may also identify data that undesirably affects a mobile communication device such as exposing vulnerabilities draining battery life transmitting private or unauthorized information to third parties or using up unnecessary device resources. Similar to the known good component and database any data identified as bad may be deleted quarantined or rejected from further processing by the mobile communications device. If a known bad data object is detected an embodiment of this disclosure may also display a notification or other message similar to that described in co pending U.S. patent application Ser. No. 12 255 635 entitled SECURITY STATUS AND INFORMATION DISPLAY SYSTEM filed on Oct. 21 2008 and incorporated in full herein.

Decision component may be used to evaluate data that cannot be characterized as either known good or known bad. Since a majority of the data received on the mobile communications device may fall within this category this component may reside on server . This component may utilize a variety of methods to produce an assessment for a data object including using any of the analysis systems disclosed herein. For example decision component may apply static analysis dynamic analysis distribution analysis or other methods of analysis in order to determine whether received data may be passed to its intended destination or rejected to prevent harm from befalling the device. Examples of this analysis are discussed below.

The following examples illustrate how one or more servers can be used to augment or replace the methods described in U.S. patent application Ser. No. 12 255 621.

Multiple systems containing known good component known bad component and decision component are possible. Depending on the specific types of data being analyzed and the types of security threats being prevented different orders of execution and logic applied to each component s output can be employed. In an embodiment if data is not determined to be good by known good component block it will be rejected from processing . Data that known good component determines to be good block is still analyzed by known bad component block . If known bad component determines data to be bad block it is rejected from processing otherwise data may be analyzed by decision component block . In an embodiment if data is not determined to be known good by known good component known bad component analyzes it. If known good component determines the data to be good it is allowed. If known bad component determines the data to be bad it will be rejected from processing . If known bad component does not determine the data to be bad the data may be analyzed by decision component to reach an assessment for the data.

An example analysis of network data or data files present on a mobile communication device is shown in . As shown in block may involve gathering data sent to or received from the mobile communications device. The data may be analyzed to identify its protocol and track state block . In block known good component resident on the mobile communication device may evaluate the gathered data for known good characteristics. Known good characteristics may include the characteristics previously discussed or described in U.S. patent application Ser. No. 12 255 621. If the data contains sufficient known good characteristics it may be allowed to proceed to its intended destination block for processing execution or other operation. Alternatively the data may be further analyzed by known bad component resident on the mobile communication device to confirm that the data is truly safe block . If known bad component determines that the data is truly safe then the data may be allowed to proceed to its intended destination block . Decision component may also be available to provide a final check block before allowing the data to proceed block .

Analysis of a data object may be performed at any time. For example the data object may be evaluated prior to access or download or after download but prior to installation or after installation prior to installation of a new version of the data object or after the installation of a new version of the data object if the data is an application. In an embodiment a data object that has not yet been downloaded to a device is evaluated by using identifying information about the data object. For example if an application market accessible to a mobile communication device makes applications available for download and provides identifying information about the data object such as a hash of the application s content or a package name for the application software on the mobile communication device can use the identifying information to determine an assessment for the application by evaluating the identifying information locally using any of the systems described herein or by transmitting the identifying information to server and receiving an assessment from the server. In this manner the software on the mobile communication device can assess whether applications are undesirable or not before a user downloads them.

At any point during the analysis if either known good component known bad component or decision component discussed further below determines that the data is not good or affirmatively contains security threats data inconsistencies etc. then in block the data will be blocked rejected deleted or quarantined. In an embodiment of this disclosure a signal event or security event information log may be updated to record the encounter with the contaminated data.

The analysis of executable data such as applications programs and or libraries on the mobile communications device may proceed as illustrated in . In block the executable is determined to need to be classified as either good or bad as a result from an attempt to access the executable installing the executable or the executable being downloaded or otherwise transferred to the mobile device. The executable may or may not be pre processed to extract additional application data such as a hash identifier cryptographic signer package name or other characteristics before being evaluated by known good component resident on the mobile communication device block . This evaluation may include comparing the executable s hash identifier or other characteristics against a database of known good characteristics identifying whether the executable has sufficient known good characteristics or any of the criteria discussed above or described in U.S. patent application Ser. No. 12 255 621.

If the executable is recognized as known good then in block it may be allowed to execute its code or proceed to its intended destination for processing or other operation. If known good component fails to allow the executable data then known bad component resident on the mobile communication device may perform its analysis block . If known bad component confirms that the executable is malicious then the executable may be quarantined rejected or deleted and the event may be logged block . If known bad component is unable to characterize the executable then the decision component may perform its analysis as described further below block . If decision component ultimately determines that the executable is safe then the executable is allowed block . If decision component ultimately determines that the executable is not safe or remains unsure then the executable may be quarantined block . One will appreciate that since executables may contain code that can cause significant harm to the mobile communications device it may require more rigorous analysis before the executable is allowed to proceed.

One will appreciate that known good component and known bad component can be kept lightweight on the resident mobile communication device by only storing definition information about those applications most likely to be accessed by the mobile communication device. As described above such information may be determined for example based upon device data the applications previously installed on the mobile communication device and the way the mobile communication device is used e.g. work versus entertainment accessing public networks versus private networks etc. . One will appreciate that each mobile communication device may store different definition information and that an embodiment of this disclosure contemplates such granularity.

As discussed above and throughout an embodiment of this disclosure is directed to server side analysis of data in the event that known good component and known bad component are unable to determine whether the data is safe. In an embodiment decision component resides on one or more servers in communication with the mobile communication device over network i.e. in the cloud. The decision component may rely on one or more analysis systems such as the analysis systems disclosed herein. Because decision component resides on computing resources that are more powerful than the mobile communication device it can provide a more robust analysis to determine if data should be considered bad or good for device . Furthermore analysis that takes place on server can take advantage of data collected by the server to produce an assessment that would not be possible only relying on data available to mobile communication device . For example decision component on server may determine that a data object is malicious if behavioral data reported by devices indicate that the data object sends premium rate SMS messages or dials premium rate phone numbers on devices that it is installed on.

In an embodiment decision component utilizes one or more types of internal analysis systems to characterize whether a data object is good or bad. The decision component is designed to detect security threats without specific definitions for the threats being protected against. In other words decision component may operate as an additional security component to compensate for any weaknesses from known good component or known bad component and to identify new threats that have not been previously identified.

One will appreciate that there are a number of analysis systems that may be utilized by decision component including but not limited to systems that use heuristic algorithms rule based or non rule based expert systems fuzzy logic systems neural networks or other methods by which systems can classify a data object. As described above such systems may use a variety of data available to decision component including but not limited to distribution data characterization data categorization data trust data application data and the like. For example decision component may analyze applications libraries or other executables on a mobile communications device. In an example the decision component may contain a neural network which analyzes characteristics of an executable and determines a security assessment based on network connection characteristics. Such characteristics may be determined based on information contained in the executable file format or as a result of processing the content of the executable file. In another example the decision component may contain an expert system which analyzes the behavior of an executable through function calls system calls or actions an executable may take on an operating system. If an executable access sensitive system calls in a way that signifies malicious behavior the system may flag that executable as potential malware and action may be taken.

If decision component is located on mobile communication device it may be desirable to update rules or analysis parameters independently of updating the executable code powering the decision component. In an embodiment the decision component contains a virtual machine based decision system by which an executable can be classified by a set of rules that may be updated independently of the decision component itself. Such a system is able to add new logic to detect certain new classes of undesirable applications on the fly without having to update the whole decision component. The system may pre process the executable so that the virtual machine s logic can symbolically reference the executable rather than having to process the executable itself.

In an example the decision component may consider third party information to evaluate data. A person having skill in the art will appreciate that a mobile communication device is capable of accessing an application provider such as Apple s App Store the Android Market or other software repository or digital distribution platforms for providing applications available for download and installation on the mobile communication device. In an embodiment server has access to such application providers and can collect information about specific applications. For example server can search for and collect user generated reviews or ratings about applications. An application that has favorable ratings may be deemed safe while an application with significantly negative ratings may be deemed undesirable. Because server may also determine trust data for data objects the assessment for an application with negative reviews may only indicate that the application is undesirable if the application has a low trust rating while an application with a high trust rating and negative reviews may still be considered desirable by an anti malware system.

The above examples illustrate how decision component may utilize a number of analytical methods in order to fully evaluate the threat level of data received by or transmitted from the mobile communications device. Other examples may be contemplated without departing from the scope of this disclosure.

One will appreciate that identifying recognizably good data objects and recognizably bad data objects such as by mobile communication device or server may be performed by a single component rather than by separate known good and known bad components. In an embodiment a single recognition component performs the functionality of identifying both recognizably good and recognizably bad data objects.

In an embodiment a recognition component utilizes definitions to determine an assessment for a data object. The recognition component first examines application data for a data object to determine if any definitions correspond to the data object. For example if the recognition component has access to definitions that are hashes of data objects content a definition that has the same hash as the hash of a given data object s content is determined to correspond to the data object. In another example if the recognition component accesses definitions that contain byte sequence signatures a definition with a byte sequence contained in a data object s content is determined to correspond to the data object. Each definition may be associated with an assessment so that the recognition component can examine application data for a data object to determine a corresponding definition determine a corresponding assessment for the definition and therefore produce an assessment that corresponds to the data object. For example the application data for a data object may include identifying information such as the data object s hash package name unique identifier or other application data such as the data object s content. In an embodiment the definitions used by a recognition component represent known data objects. In this case when the recognition component determines if an assessment for a known data object corresponds to a data object being analyzed the data object being analyzed and the known data object do not have to be exactly the same. For example if a first application from a particular developer is determined to be undesirable through analysis e.g. manual analysis automated analysis a definition may be created for the first application that matches the first application s package name. If the developer creates a modified application that has the same package name as the first application and the recognition component encounters the modified application the definition is determined to correspond to the modified application because the package name in the definition matches the modified application s package name. The recognition component then determines that the undesirable assessment for the first application applies to the modified application.

For example a recognition component may access a database of definitions each definition indicating a hash of a data object s content and an indication of whether a data object to which the definition corresponds is considered to be good or bad. In an embodiment the definitions used by one or more recognition components operating on server are stored on server or on data storage . In an embodiment known good component and known bad component are each implemented on server using a recognition component. For example a known good component may include a recognition component where all of the definitions accessed by the recognition component correspond to an assessment that a data object is considered to be good. In an embodiment known good and known bad components are each implemented as recognition components that match application data for a data object against known good and known bad application data. For example a known good component may have a list of known good hash identifiers package names and cryptographic signers that it tries to match with data objects being analyzed. In an embodiment if a data object has any characteristic in the known good list it is considered safe. In an embodiment server may use a similar known bad system that matches known bad application data to application data for a data object being analyzed. Other known good and known bad analysis systems are possible without departing from the scope of this disclosure. In an embodiment the recognition component produces a variety of assessments not simply good or bad. In an embodiment the recognition component uses a single assessment instead of storing multiple assessments if all definitions only have a single corresponding assessment such as in the case where the recognition component only identifies whether a data object is known bad. Other variations are also possible without departing from the scope of this disclosure.

In an embodiment mobile communication device performs analysis on a data object being scanned using a local decision component on the mobile communication device before transmitting data object information to server in the case where the recognition component on the mobile communication device does not determine an assessment. In an embodiment analysis by the local decision component and transmitting data object information to the server occur in parallel to minimize delay to a user. One skilled in the art that a variety of configurations of the components in a combined client server anti malware system are possible without departing from the scope of this disclosure.

In an embodiment mobile communication device transmits authentication information such as authentication credentials or session information to server whenever sending information about a data object so that server can associate information exchanged with a particular account on the server.

Previous portions of this disclosure described various systems and methods for collecting different types of data from one or more mobile communication devices and other sources as well as analyzing the collected data to produce assessments for data objects. The following is a discussion of how server can use assessments for display exposure via API and a variety of other purposes. Some examples of assessments that have been disclosed herein include output from one or more analysis systems e.g. characterization data categorization data trust data and distribution data and one or more ratings for a data object e.g. security rating privacy rating battery rating performance rating quality rating . One having ordinary skill in the art will appreciate that assessment information pertains to a wide variety of information which can be used to understand the effects of installing a given data object on a mobile communication device beyond a typical anti malware system s assessment of whether the data object is malicious or not. In addition this assessment information can be used to guide decisions regarding whether to download and install of different types of data objects. Such information can be useful to an individual user trying to decide whether to install a certain application on his mobile communication device. Such information can also be useful to an IT administrator trying to decide whether to deploy a certain application to a plurality of mobile communication devices. In an embodiment a user or IT administrator can use this assessment information for application policy enforcement.

One having skill in the art will appreciate that the data available to server and assessments produced by the server are useful beyond anti malware purposes. For example the assessments can detail whether a data object is known for excessively draining a mobile communication device s battery or if a data object utilizes an undesirable amount of network resources. Because server continues to gather store and analyze data to produce assessment information in an embodiment server can provide information that details how a data object is estimated to affect a mobile communication device before the data object is installed on the mobile communication device. For example server can provide estimated battery usage information and or network usage information for an application.

When users interact with assessments it may be desirable that the assessments represent an appropriate level of granularity so that users do not feel that the assessments are too broad or too narrow. In an embodiment server merges assessments for multiple data objects into a single assessment and transmits the merged assessment. For example if an application contains multiple data objects e.g. executable and multiple libraries a user may wish to see an assessment for the application as a whole not multiple assessments for its constituent data objects. Similarly if there are multiple versions of an application on a single platform or multiple platform that exhibit similar characteristics an enterprise policy administrator making a decision about the application may only wish to view a single assessment that encompasses all versions of the application.

In order to merge assessments for multiple data objects server may use application data such as file paths version numbers package names cryptographic signers installer source and other information to determine that a group of data objects pertain to a particular version of an application and or that one or more data objects or group of data objects belong to different versions of an application. For example if a set of executables are commonly seen in the same directory together server may determine that those executables are all related to the same application. In another example if an application package has both a package name and a version identifier embedded in it server may determine that two data objects with the same package name and human readable application name but different version identifiers are multiple versions of the same application.

Because it may be desirable for assessments to provide a consistent form of information between platforms an embodiment of this disclosure is directed to server including some or all of the same fields in assessments for data objects that run on different platforms. For example even though the location APIs on different smartphone operating systems are very different in their function server may perform operating system specific analysis on data objects to produce a cross platform assessment of whether each data object accesses the device s location. If the assessment were in the form of a list of capabilities for the data object both a mapping application on BlackBerry and a location based social network on Android would have the accesses device location capability. Similarly battery usage may be calculated differently on each platform but server may produce a cross platform assessment of the estimated daily battery use measured as a percentage of total battery capacity. In an embodiment merged assessments for multiple data objects include information about the range of characteristics and categorization for data objects. For example an assessment may show a trend in the battery usage of multiple versions of an application. An application that used a lot of battery in an old version but has recently decreased its battery usage may be acceptable while an application that has consistently high battery usage may be unacceptable.

An embodiment of this disclosure is directed toward server making assessments for data objects available via a web interface. For example users may wish to be able to learn more about the characteristics and capabilities of applications they have on their mobile devices. Server may expose as a web interface an index of applications for which assessments are available and an assessment for each of these applications. In order to facilitate easy location of applications server may organize applications in a variety of ways such as alphabetically by their characteristics by their categorization and by platform. In addition server may allow a user to search for applications using terms that match the application s name description or fields in the application s assessment e.g. all applications that run on Android OS and send location to the internet . Furthermore publicly displaying assessments may assist in the transparency of applications.

For example application vendors may direct users to the assessment page generated by server as an independent third party assessment of the capabilities of an application so that users can verify what the application is doing. In an embodiment server generates a web interface that allows a user to view an application s conditional assessment based on device data e.g. how much battery does this application use on a Motorola Droid how much network data does this application use on AT T Wireless and compare different conditional assessments e.g. this application s battery usage on a Motorola Droid vs. a HTC Hero how much network data does this application use on AT T Wireless vs. Verizon Wireless . Such conditional assessments may be helpful to identify anomalous behavior in particular circumstances for example the assessment page may indicate that a certain set of handsets operating system versions or other applications installed on a device cause a higher error rate or anomalous change in certain assessment characteristics for this application. In an embodiment server identifies data objects having extreme values for particular assessment values. For example server may generate a web page identifying which applications use more than 1 gigabyte of network data per month or which applications use more than 10 of a device s battery.

Because assessment data generated by server may be utilized to provide a variety of other products and services an embodiment of this disclosure is directed toward server exposing assessment data via an API. All functionality exposed by a web interface as described above may also be exposed as an API so that a variety of products and services may be built. For example server may provide an HTTP API by which supplying a data object s package name or content hash in the request URL will result in the server returning an assessment for the data object identified by the package name or content hash. In another example server may generate a JavaScript file that can be included by a remote web page and displays an interactive assessment view for a particular data object.

In an embodiment server can cause assessment data such as a rating or disposition as to whether an application is desirable or not to appear in an application marketplace. One will appreciate that application marketplaces may be implemented in a variety of ways such as using a web site using a mobile client application using a PC based client application and using a messaging service such as SMS. As such rather than subjective user provided review information an embodiment of this disclosure will provide objective assessment information for an application or other data object.

For example server may provide an API by which it may be queried for assessment data or server may proactively analyze all of the applications available in an application marketplace transmitting assessment data to the marketplace provider. In an embodiment a user can search the application marketplace for only those applications that meet certain desirable criteria such as security privacy device efficiency trustworthiness and the like. In an embodiment application providers can use the aggregated information in order to provide quality control measures. The application provider may only feature applications that meet certain battery efficiency criteria a standard for an acceptable number of crashes or errors certain network traffic limitations privacy protections and the like. In this fashion an embodiment of this disclosure can improve the offerings on an application marketplace thereby encouraging developers to create better applications. In an embodiment the assessment information may be used as a certification system wherein an application meeting certain criteria may be marked with a symbol badge or other icon denoting the positive assessment for the application. For example applications that have a high trust rating or applications that only access a minimal set of private information may be considered certified. In order to verify an application s certification the certification marker may have a link or other way for a user to retrieve a full assessment from server .

In an embodiment server transmits assessment information to mobile communication device for display. For example a mobile device may have an interface by which a user can explore assessments for all applications installed on the device. The interface may allow a user to view assessment information for a particular application as well as allow a user to view which applications match a set of assessment criteria e.g. all applications that send the device s location to the internet the top 10 battery users all applications that use more than 50 megabytes of network traffic per month . In an embodiment mobile communication device displays an interface as a part of an application marketplace an application download process or an application installation process on a mobile communication device so that a user browsing an application available for download or downloading installing an application sees assessment information for the application. When browsing downloading or installing an application the device transmits identification information to server and receives an assessment for the application displaying some or all of the assessment on a user interface. For example the interface may display the capabilities of the application or characteristics of the application. The interface may also be interactive allowing the user to explore aspects of the assessment requesting additional assessment information from server if necessary. In another example the device may display an indicator of trust for an application as determined by server and transmitted to device as part of an assessment The indicator of trust may be displayed in a variety of ways including as a certification seal e.g. Lookout certified or a rating e.g. A B C .

In some cases users will not read lengthy security explanations so it is important to display security information about applications in such a way that is easily understandable. In an embodiment a mobile communication device displays a graphical assessment indication for an application. For example notable aspects of assessments may be displayed as icons or badges for the application. Some examples include badges for being battery efficient being a battery hog accessing location having spy capabilities being a social network and being a file sharing app . The badge for each notable assessment may include an illustration making the badge easy to understand and coloration indicating whether the assessment is merely informational or something potentially critical. For example an application being efficient with battery use may have a green icon showing a full battery while an application that typically uses a lot of battery may have a red icon showing an empty battery.

Because server continually gathers information and improves assessments assessment information can be updated on application marketplaces and or mobile communication devices that have cached the assessment information. For example server may send a notification to the application marketplace or mobile communication device indicating that new assessment information is available. In another example server may simply transmit the updated assessment information so that old information is overwritten.

In addition to viewing assessments on a device for data objects that are installed on that device it may also be desirable to view assessments for data objects installed on a device from a web interface. For example a user may wish to use his or her PC to explore assessments for applications installed on his or her device. As discussed in an embodiment mobile communication device transmits application data for data objects it has installed to server . Because server may store which applications are currently installed on device the server can generate a user interface displaying assessments for those applications. For example server may generate and transmit a web interface allowing a user to view a list of all applications installed on a device view an assessment for each installed application and explore which installed applications match particular assessment values e.g. all applications that can access my location . To prevent disclosure of private information server may require that a user log in using authentication credentials in order to view assessments for the applications on his or her device. Furthermore an enterprise administrator may wish to view assessments for a group of devices from a central management console.

In an embodiment server generates a web interface that allows a user to view assessments for applications installed on multiple devices. For example the web interface may allow a user to explore all apps that are installed on a group of devices that match a certain assessment field e.g. file sharing applications view risk rating assessments for the group of devices view all of the capabilities for applications installed on the deployment and determine which devices and which apps are causing certain capabilities and risk exposures. A user may start by using server to generate an overall set of security privacy and battery risk ratings for the group of devices then click on a rating to view the list of applications most contributing to that risk rating. A user can then view which devices have a given application. In another example a user may start by using server to generate a list of all capabilities for applications installed on the group and then click a given capability to view all of the applications installed on the group that have that capability. From there the user may further explore which devices in the group have a given application installed. In an embodiment assessments for a group of devices are exposed by server in the form of an API for use by external services such as management consoles. For example server may expose risk ratings for the group of devices to a centralized security reporting system via an HTTP API.

On mobile communication devices battery and network data are often limited in such a way that applications can adversely affect the device s battery life and can cause network use overage charges. An embodiment of this disclosure is directed to using assessments to make users aware of applications network or battery usage and alert users in the case of an abusive application. Software on the device retrieves an assessment containing battery and network usage characteristics for an application from server and displays the assessment to the user. As described above a device requesting assessment information from server may include application data for the application. The assessment may be customized for the particular device the user is using by the device sending device data when retrieving the assessment or by sending authentication data that associates the assessment request with previously transmitted device data. For example the assessment may indicate that an application will likely reduce a user s model of phone s battery life by 5 or 1 hour whereas a different model phone that has different battery life characteristics may receive an assessment that the same application reduces the phone s battery life by 10 or 3 hours. The assessment display may occur as part of an on device application marketplace or as a user interface dialog before during or after installation of an application.

Furthermore after the user installs multiple applications it may be desirable for that user to understand which applications are most contributing to network usage or battery life based on the applications actual behavior on the device. In an embodiment the device collects behavioral data for the battery and network usage of an application and allows a user to view the actual behavioral data from an interface on the device. For example the interface may allow a user to view a particular application s battery and network usage as well as view the top network and battery using applications in order to identify which applications are contributing to network overage or short battery life. In an embodiment mobile communication device reports behavioral data for applications installed on the device to server and allow the user to view the actual behavioral data via a web interface generated by the server. One having ordinary skill in the art will appreciate that other characteristics of mobile applications can be monitored and shown to users as well.

Because a single application can cause significant problems with respect to battery life network usage or other limited resources it may be desirable to notify a user when an application is behaving undesirably. In an embodiment mobile communication device monitors the network and battery usage of applications installed on the device and notifies the device s user when an application exceeds desirable limits. For example the user may set thresholds for how much data applications may transmit and receive before he or she is notified. In another example a user is notified when the device determines that an application will adversely affect the user s battery life or phone bill. If a user typically uses a phone for 20 hours before plugging it in and an application on the device reduces the estimated battery life to less than 20 hours it s likely that the user will run out of battery. It may then be important to alert the user that there is an action he or she can take to avoid running out of battery namely uninstalling or otherwise disabling high battery using applications.

In an embodiment in order to prevent applications on a user s device from exceeding the user s data plan device or server predicts the future data usage of a device and gathers information about the device s data plan. In order to gather information about a device s data plan device or server connects to a network operator s servers to determine data plan information such as the data allocation per billing cycle what their billing cycle is and how much data has been used during the current billing cycle. Communications to the network operator s servers may occur in a variety of ways such as via an HTTP API or SMS messaging. If software on a device uses SMS messaging to retrieve a user s data plan information the software may automatically consume the response message sent by the network operator s servers in order to prevent the communication from showing up in the user s inbox. In order to predict future data usage server may analyze typical data usage for applications installed on a device and actual data usage on that device. If an application is newly installed typical data usage may be used while for an application that has been on the device for months actual data usage may be used. If applications on device use network data at a rate that would exceed the device s data plan allocation by the end of the billing cycle software on the device displays an alert indicating the likely overage charges. The alert may also display the applications most contributing to the data usage and give the user to uninstall or reconfigure the applications. Device may report the alert to server which may also send a notification e.g. via email indicating the potential for data overage. Software on device or server may display an indication of the current predicted data usage relative to the device s data allocation so that a user may adjust his or her application usage patterns accordingly. For example if a user is worried about exceeding his or her data plan he or she may check what the current predicted data usage is before engaging in a video chat.

Because the applications installed on a device may have a significant impact on the risk exposure of the device it may be desirable for a user or administrator to set policy for what applications are desirable to install on a device or group of devices. The following is a discussion of how protection policy can be implemented on one or more mobile communication devices. In an embodiment policy includes blacklists and whitelists. A blacklist is a set of applications or assessment criteria that are explicitly denied from running on a mobile communication device while a whitelist is a set of applications or assessment criteria that are explicitly allowed to run on a mobile communication device. For example a policy may allow only applications on a whitelist or only applications not on the blacklist. In an embodiment explicit application entries have higher priority than assessment criteria entries. For example a policy may specify certain capabilities e.g. sending a device s location to the internet that are blacklisted but specify certain applications that are whitelisted. In this case all applications that send location to the internet may be blocked unless they are explicitly on the whitelist because the explicit applications on the whitelist are of higher priority than the assessment criteria on the blacklist. One skilled in the art will appreciate that a variety of policy schemes can be implemented without departing from the scope of this disclosure.

Users may have individual preferences for the type of applications they want on their mobile devices. Some users for example may be sensitive to privacy issues while other issues may want to optimize their battery life. In order to allow users to utilize application assessments to gain greater insight into the applications they use or are considering to use an embodiment of this disclosure is directed to software on a mobile communication device allowing a user to set policies based on assessment criteria for applications the software blocking applications that exceed an undesirability threshold. When a user attempts to install an application the software requests an assessment for the application from server and receives the assessment from the server.

For example if the user attempts to install an application that has the capability of sending location information to the internet but has a policy to disallow any applications that can send his or her location to the internet then software on the mobile communication device will block the installation. In another example a user may set privacy security and battery life policy thresholds individually on a relative scale e.g. 0 to 10 . When the user installs an application software on the device retrieves an assessment for the application and compares the application s privacy security and battery ratings with the policy thresholds and alerts the user if the application exceeds the configured policy. Instead of blocking installation of an application that is undesirable a user may want to simply be warned of the undesirability.

In an embodiment the user can ignore the alert and choose to accept the application anyway. In an embodiment the device displays a user interface indicating that an application is undesirable for the user. For example a mobile device may display an indication of whether an application being viewed for possible download in an application marketplace meets the user s desirability criteria. In another example software on a device may allow a user to view all applications that do not meet desirability criteria. Such an interface may be useful if a user changes his or her criteria and wants to view applications that are now undesirable given the new criteria.

IT administrators parents network operators or other people responsible for multiple mobile communication devices may wish to set policy on multiple mobile communication devices without physical access to all of the devices. In an embodiment server allows a user or administrator to set policy for a device or group of devices. When a device attempts to install an application the device sends a request to server for an assessment of the application. Based on policy configured on server the assessment contains an indication of whether the application is allowed or disallowed and may also contain the policy criteria for why a disallowed application was assessed to be disallowed. In an example policy on server is configurable via a web interface.

In an embodiment server allows policy to be configured by assessment criteria as well as on a per application basis. For example an administrator may use server to block all applications that are in a certain category such as social networking applications or all applications that access certain capabilities such as the ability to transmit files or other sensitive data from a device. In an example an administrator may wish to only allow particular applications by creating a whitelist blocking all applications not on the whitelist. In a further example an administrator may permit all applications other than particular applications that are on a blacklist because they are known to be undesirable. Because the set of applications allowed or denied under a policy may be pre computed an embodiment of this disclosure is directed to server generating a set of policy definitions and transmitting the policy definitions to one or more mobile communication devices . For example if a group of devices has a policy to only allow applications that are on a whitelist server may transmit a list of identifying information for the whitelisted applications to a mobile device so that the device does not need to contact the server for assessments every time it encounters an application.

When configuring policy using abstract concepts such as application categorization and capabilities it may be desirable for a user or administrator to see what applications would be allowed denied or whether a particular application would be allowed denied if configuration changes were to be made. In an embodiment the policy configuration user interface on mobile communication device or server includes an interface for viewing applications that would be blocked or allowed as part of a configuration change. If the configuration change interface is displayed on mobile communication device the device may send requests for data to server to populate the interface. It may be desirable to show all of the applications allowed or blocked after the configuration change goes into effect or only the difference in applications allowed or blocked between the current configuration and the new configuration. Because the number of applications affected by a configuration change may be very large the interface may display summary information and allow a user to search for a particular application to determine whether the configuration change affects that application and whether the configuration change would result in that application being allowed or blocked. In an embodiment the interface displaying the effect of a configuration change indicates whether any popular applications would be blocked. For example application popularity may be determined based on overall distribution data determined by server or by the prevalence of the application in the group of devices being managed. In an embodiment the change result interface only displays changes that affect applications that are currently installed on at least one device in the group being managed.

In order to prevent a policy system from interfering with acceptable usage of mobile communication devices an embodiment of this disclosure is directed to server maintaining sets of acceptable apps and allowing a user or IT administrator to easily add those sets to a whitelist the whitelist automatically including changes to the sets of acceptable apps. For example server may maintain a list of applications that are popular overall or a list of popular applications by application category. In a policy configuration interface the server may present a way to include all popular applications or only popular applications in particular categories e.g. games social networks in the policy s whitelist. In an embodiment such dynamic list policies are of higher priority than assessment criteria entries on blacklists and whitelists but of lower priority than explicit application entries. In another example server may maintain a list of applications with high trust. In a policy configuration interface the server may present a way to include all high trust applications in the policy s whitelist. Whenever the high trust list is updated applications with high trust are effectively considered whitelisted when making policy assessments.

Because a mobile device deployment may already have a device management server or service in place it may be desirable for server to supply data to a device management server that actually performs the policy enforcement. In an embodiment server interfaces with a device management server to configure application policy on the device management server. For example the device management server may support configurable application blacklists and whitelists. If a user sets configuration on server to only allow applications that are on a whitelist or that match certain assessment criteria server generates the list of applications to be whitelisted and transmits the list of applications to the device management server in a format and over a protocol that the device management server supports. Similarly if a user configures a blacklist on server the server generates the list of applications that are on the blacklist and configures the device management server to enforce the blacklist. In an embodiment server is capable of configuring multiple device management servers. For example if an organization supports multiple mobile device operating systems and uses different mobile device management servers an administrator can configure a cross platform policy on server e.g. blocking all file sharing applications . Server may then identify all of the applications across multiple platforms whose assessments match the policy and configure the appropriate application policies on device management servers. Because each device management server may only support a subset of mobile device platforms that server supports server only transmits policy information to a device management server that corresponds to data objects that run on operating systems that are supported by the device management server. For example if a device management server only supports Blackberry devices server may only configure the device management server s blacklist and or whitelist with information about Blackberry applications.

In an embodiment policy compliance checking can be performed by either server or mobile communication device . For example if server performs compliance checking any compliance settings are stored on server so that any configuration performed on mobile communication device results in that configuration being transmitted to the server. When the device requests an assessment for an application from server the server includes in the assessment an indication of whether the application is allowed or disallowed by policy. In another example if mobile communication device performs compliance checking any compliance settings are stored on mobile communication device so that any configuration performed on server results in that configuration being transmitted to the device. When the device receives an assessment for an application it compares the assessment to the policy configuration to determine if the application is allowed.

In an embodiment policy management is integrated with a server coupled anti malware system so that signatures and assessments for applications provided by server enable device to block data objects that violate policy. For example when a device requests for an assessment from server the server s assessment indicates that an application is undesirable if the application is considered malicious or if it violates policy. In either case the assessment produced may indicate further information about why the application was found to be malicious or policy violating. In another example server may pre emptively transmit signatures for malicious or policy violating applications to mobile communication device so that the device can recognize whether a data object is desirable or undesirable without having to contact server .

If a device has installed an application that violates a protection policy in place on either the device or server or the assessment for an application has been updated to make it violate the protection policy it may be desirable for remediation actions to be taken by the device or other systems. In an embodiment if a device has an application installed that violates the protection policy for that device the server or software on the device can enact remediation actions to occur. Depending on whether policy compliance is determined at the device or server either the device or server may determine what remediation actions to take.

For example if a user installs an application and the assessment received from server indicates that the application is acceptable but at some point in the future server determines that the application is unacceptable server transmits an updated assessment to the device including remediation actions for the device to take. In another example if a user installs an application on a device and the device receives an assessment from server indicating that the application is acceptable but software on the device gathers behavioral data that shows that the application violates policy e.g. the application attempts to acquire the user s location the device may undertake pre configured remediation actions such as removing the application. The device may also transmit this behavioral data to server and indicate the policy violation. One skilled in the art will appreciate that using behavioral data to enforce policy can protect mobile communication device in a variety of situations such as when a vulnerability in an application is exploited when an application only behaves undesirably on a subset of devices e.g. a targeted attack against employees of a particular company or when an application only behaves undesirably after a period of time i.e. a time bomb .

When a device is detected to be violating policy a variety of remediation actions are possible for example any violating applications may have their processes ended may be uninstalled or isolated from accessing certain system functionality e.g. interne private data or may be restricted from accessing certain networks e.g. only allowed to access Wi Fi not the cellular network . It may also be desirable to isolate the whole device from accessing sensitive resources such as a corporate email or VPN server while it is out of compliance to prevent information leakage. Other remediation actions may include those disclosed in U.S. patent application Ser. No. 12 255 614 filed on Oct. 21 2008 and incorporated in full herein.

If an administrator is able to set policy using server it may also be desirable for a user to use server to view the compliance status of devices that the policy applies to. In an embodiment server determines whether a group of mobile communication devices is in compliance with application policy and which applications are installed on devices in the group. For example if mobile communication devices report the applications they have installed and server contains policy configuration the server can determine which devices currently violate the policy set by an administrator. To allow an administrator to view the compliance status server may generate a web interface listing whether or not all devices are in compliance and if any devices are out of compliance how many there are. The interface may also allow the administrator to view specific devices that are out of compliance view which applications make the devices out of compliance and initiate remediation actions e.g. removing an application remotely.

In an embodiment server presents a one click remediation action whereby an administrator can click a single button to remotely initiate remediation actions on all devices in the group the administrator is managing. For example if an administrator managed devices and 10 of the devices had applications that violated policy the administrator could click the one click remediation button on the web interface to cause the server to send indications to each of the 10 out of compliance devices to remove the undesirable applications without any user intervention required. Once the remediation actions completed each device may send an indication to server indicating whether it was successful or not. During the remediation process server may generate an interface by which the administrator can view the status of the remediation. Other methods of server exposing compliance status include server exposing an API e.g. for use by a security management console and server generating reports that can be downloaded.

In some cases it may be desirable for a user or administrator to receive a notification if he or she installs an application that is considered undesirable or if a previously installed application is newly considered to be undesirable based on an updated assessment. In an embodiment mobile communication device transmits information about the installation of a data object to server . If server determines the data object to be undesirable based on universal undesirability characteristics or characteristics for the user the server transmits a notification. For example if a user installs an application that is assessed as desirable but at some point in the future the application begins to exhibit malicious or other undesirable behavior such as wasting battery the server may change its assessment to indicate that the application is undesirable. The notification may take a variety of forms such as an email SMS message or user interface dialog displayed on a web page on a PC or on a mobile communication device.

For an IT administrator managing a plurality of mobile communication devices policies can be set for a specific application even if the application is available on multiple platforms and has multiple versions. For example it is not uncommon for an IT administrator to manage a fleet of mobile communication devices running different operating systems. The fleet of mobile communication devices can include iPhones BlackBerry devices and Android devices. However if a certain application is known to be undesirable on all three device operating systems such as a social networking application that can disclose private information then the IT administrator can block all versions of the application from installation regardless of platform. However if an application can share sensitive information on one platform but not others then the IT administrator can allow installation of the application on only the platforms that don t share sensitive information. As discussed above it may also be desirable for an IT administrator to make policy decisions about all versions of an application at once instead of having to maintain a policy that treats multiple versions of an application as separate decisions. Because there are some applications that are updated very frequently it would quickly become a very difficult task to manage application policy if an administrator could not treat all versions of a particular application as one policy decision.

Because an application may drastically change between updates it s desirable for an administrator to be aware of any changes that could affect the administrator s decision of whether or not to allow the application. An embodiment of this disclosure is directed to server sending a notification in the case of an application that is present on a blacklist or whitelist changing its capabilities or characteristics significantly. For example if a new version of an application that is on an administrator s whitelist has the capability to transmit files from a user s device while previous versions did not then server may send an email or text message to the administrator indicating the change. The policy management interface on server may also display a list of applications that may need attention based on changed characteristics.

In order to simplify configuration an embodiment of this disclosure is directed to software on mobile communication device or server may provide default policies that account for common use cases. For example a user may be able to select that they are concerned with battery life and location privacy but they are not concerned with network usage and phone number privacy. By selecting such concerns the device or server automatically configures policies and thresholds for undesirable applications. In an embodiment server or device contains pre set policies for compliance with regulations. For example financial industry or healthcare industry workers may be required to have a particular set of application policies in place to prevent the disclosure of sensitive information. Because the set of applications allowed or denied under these regulations may change over time server may automatically update the specific policy decisions that enforce the regulation without an administrator needing to specifically configure them. In order to allow for inspection and auditing server may generate a list of policy decisions it is employing to comply with regulation and may notify an administrator when policy decisions will change. If an administrator rejects certain policy decisions he or she may override the default policy set by server .

As it may be desirable to simplify the policy configuration process an embodiment of this disclosure is directed to server or mobile communication device presenting a series of questions to a user or administrator the answers to the questions being used to automatically set policy. For example when a user is first setting up application policy software on his or her device the software may ask whether the user has an unlimited data plan whether the user wants to allow services to access the device s location and whether the user wants to block all tools that can be used to spy on the device. Based on the answers to the questions the device may set policy of whether to block high data usage applications whether to alert the user in the case of a high data usage application whether to block applications that send a user s location to the internet and whether to block espionage applications. After this initial setup a user may desire to tweak policy decisions while other users may accept the automatically configured policy.

Because abusive applications may have a substantially negative impact on wireless networks an embodiment of this disclosure is directed to providing early warning information about potentially abusive applications. In an embodiment server may use information such as behavioral data and other data available to it in order to produce an assessment of whether an application has network access characteristics that may be harmful for mobile networks. For example an application that receives or transmits a large amount of data sends a large number of SMS messages or opens a large number of persistent connections may adversely affect a mobile network s performance. After assessing an application to determine if it is potentially harmful to a mobile network server stores the assessment. In an embodiment server notifies an administrator when a potentially harmful application is identified. For example the notification may be in the form of an email or text message that contains information about the potentially harmful data object.

In an embodiment server generates a web interface that displays applications that have been assessed as potentially harmful to a mobile network. The web interface may be designed to support a review workflow so that potentially harmful applications can be further analyzed by an administrator. After examining an application the administrator may want to take remediation action in some cases while in other cases the administrator may want to take no action. If an administrator chooses to take no action the application will not be considered potentially harmful unless its behavior significantly changes triggering server to identify the application for re review. In order to prevent multiple data objects for a given application being repeatedly identified as potentially harmful if an administrator chooses to ignore an application all versions of that application will also be ignored as server can determine whether multiple data objects belong to the same application or other grouping.

If an administrator is aware of a potentially harmful application he or she can take preemptive measures to avoid serious problems if the application is installed on more devices. In an embodiment server generates a web interface allowing an administrator to take remediation actions for an application that is considered harmful. A variety of remediation actions are possible. For example server may present an interface allowing the network administrator to communicate with the publisher of the application and work through a resolution for the harmful behavior. Server may extract the publisher s email address from marketplace data and allow a network administrator to type in a message via the server s web interface that server sends to the publisher. When server sends the email the reply to address in the outgoing email is specially set so that when the publisher responds server associates the response with the initial message and publishes the response in the web interface for administrator to view and potentially continue the conversation. In an embodiment server generates a web interface allowing an administrator to configure security software installed on a group of devices. For example the administrator may wish to configure the security software to block the potentially harmful application or isolate the application so that it cannot communicate via a cellular network. If the administrator desires to block the application server may use a variety of mechanisms such as those disclosed herein to block the application from being installed on devices or to remove the application if it is already installed on devices. Because server can identify multiple data objects that correspond to the same application if an administrator blocks an application all data objects for the application are considered to be blocked. If an application that was potentially harmful is fixed in a subsequent version server may allow the administrator to specify a range of versions of the application to block.

Because it may be desirable to prevent the download of undesirable applications an embodiment of this disclosure is directed to server generating network infrastructure configuration data. For example server may store a set of blacklisted data objects and be able to generate a set of intrusion prevention system or HTTP proxy rules. The rules may attempt to match identifiers used by mobile devices to download data objects from an application marketplace or to identify the content of undesirable data objects as they are transmitted across a network.

In an embodiment server generates network infrastructure configuration data to block network traffic associated with undesirable applications. Server generates network infrastructure configuration rules that prevent network communication associated with undesirable applications by server using behavioral data for an undesirable application to characterize the network communications associated with the application and generating rules that block similar network traffic e.g. traffic to the same IP address subnet or hostname . In order to prevent legitimate traffic from being blocked server may analyze how unique the undesirable application s network traffic is relative to desirable applications and only block network traffic that is particular to the undesirable application. For example if an application communicates with two servers one which is a well known server used by a variety of legitimate applications and another which is an unknown server only communicated with by this application server would treat the unknown server as particular to the undesirable application.

After determining the appropriate network traffic to block server generates firewall or other network configuration rules to block undesirable applications network traffic. For example if a malicious application is using a particular server to exfiltrate sensitive data from peoples phones behavioral data for the application may indicate the IP address port and protocol used to transmit the sensitive data. When an administrator wishes to block the malicious application s capability to steal data he or she may see the list of servers the application communicates with and how many other applications known to server typically communicate with that server. The administrator then has the ability to choose which servers to block. After selecting the servers to block server generates rules that block the network traffic. In an embodiment sever makes configuration data such as Snort intrusion detection and prevention system rules available for download via a web interface. In an embodiment server is configured to directly connect with a network infrastructure management system to deploy configuration data.

Because an administrator may be primarily concerned with a particular network an embodiment of this disclosure is directed to server producing both aggregate assessments and operator specific assessments to identify potentially harmful applications and generating a user interface containing both. For example if an application misbehaves only when running on a device connected to a particular type of mobile network the aggregate behavioral data may be within normal bounds however the behavioral data for a particular network may be harmful. A network administrator may want to view the behavior of an application on the type of network he or she is administrating. Because individual mobile networks may treat different behavior as abusive a user on server can configure the criteria for considering an application harmful to the network.

In an embodiment the system is connected to a network through which the system collects application programs application program metadata or both from any number of sources. In a specific implementation the application programs are mobile application programs which may be referred to as apps. Mobile application programs include software designed for portable electronic devices mobile Internet devices MID ultra mobile personal computers UMPC or mobile communication devices such as smartphones mobile phones tablet computers personal digital assistants and the like. It should be appreciated however that the system may instead or additionally be adapted to collect and analyze application programs designed for non portable electronic devices e.g. desktop computers .

Sources of application objects e.g. application programs application metadata or both may include application marketplaces forums application developer web sites other download sites user submissions blogs social networking sites e.g. Facebook news web sites e.g. CNET or combinations of these. The system uses the collected applications to make correlations and inferences to determine for example which application programs have been pirated have been maliciously modified or include copyrighted or trademarked content.

For example mobile application programs such as Android applications are typically available on many different markets. Even though multiple apps may visually and functionally appear the same legitimate apps are sometimes pirated or modified with malicious intent. There is currently no automated mechanism to detect and warn users about pirated or maliciously modified applications.

Consider the following example a user searching for an app finds glowing reviews for the app on the official Android market but finds the app to be extremely expensive. The same app i.e. an app that has exactly the same icon and claims to do exactly the same thing as the paid app is available for free in an alternative market. The unsuspecting user downloads the app from the alternative market but ends up installing malware that was repackaged into the free app. In a specific implementation the system provides a mechanism to 1 crawl multiple markets 2 extract and download app metadata information 3 download app binaries and 4 use manually supplied metadata to 5 correlate the information available across different markets as well as 6 correlate the apps to previously identified malicious apps in order to identify malware pirated apps phishing attacks and other forms of attacks on mobile devices e.g. brand hijacking or copyright infringement .

Referring to mobile application program marketplaces provide an online application distribution platform for mobile devices including Android iPhone and Windows devices. The marketplaces allow users to browse and download application programs published by third party developers. A specific example of a marketplace is the Android Market. The Android Market is an online software store developed by Google for Android operating system OS devices. show web page screen shots of the Android Market including a listing of a mobile application program that is available on the Android Market. shows a top portion of the web page. shows a bottom portion of the web page.

Another specific example of a marketplace is the App Store. The App Store is the distribution platform developed and maintained by Apple for distributing apps that were developed for iOS. As discussed above other examples of marketplaces for mobile application programs include Blackberry App World Nokia Ovi Store HP App Catalog and Windows Marketplace for Mobile. These marketplaces may be referred to as official marketplaces because they are maintained and owned by the respective operating system developers.

There are also third party mobile application program marketplaces such as the Amazon Appstore GetJar Handango and many others. These marketplaces may be referred to as alternative marketplaces. In some cases mobile application programs may be available directly from the application developers web sites . Other channels through which apps may be made available include discussion boards or forums .

Referring now to collection server is responsible for collecting the application objects including the application binaries and application metadata from the various different application sources and storing the data in application program and application metadata databases and respectively. Client device personality database stores a set of client device profiles to allow the collection server or a collector program e.g. app crawler program to emulate a particular client device when accessing an application source e.g. application marketplace . In a specific implementation the crawler varies information being sent to the application market e.g. User Agent Device Model Country Language Device capabilities to download different variations of the same app or apps only available to certain types of devices.

That is some sources of application programs may restrict or filter the available application programs based on factors such as the client device model manufacturer make version generation platform or operating system geographical location language setting client device capabilities e.g. processor and so forth. The collection server by selecting or using various client device personalities to contact the source allows the system to build a very comprehensive collection of applications. This in turn helps to provide insightful correlations and inferences.

In an embodiment the collection server extracts data from the application objects and stores the extracted data in database for analysis. Generally an application program includes an application binary or binary file. A binary file is a computer file which may include any type of data encoded in binary form. A binary file may represent a functional computer program or may be a part of a functional computer program. Binary files are usually thought of as being a sequence of bytes. That is the binary digits bits are grouped in eights. Binary files typically contain bytes that are intended to be interpreted as something other than text characters. Compiled computer programs are typical examples of binary files and compiled applications object files may be referred to as binaries. Binary files may also include images sounds compressed versions of other files and so forth in short any type of file content whatsoever.

A hex editor or viewer may be used to view file data as a sequence of hexadecimal or decimal binary or ASCII character values for corresponding bytes of a binary file. If a binary file is opened in a text editor each group of eight bits will typically be translated as a single character and there may be unintelligible display of characters e.g. q D 7 5 B b dot over a B L c I hacek over S ts i i . If the file is opened in some other application that application will have its own use for each byte maybe the application will treat each byte as a number and output a stream of numbers between 0 and 255 or maybe interpret the numbers in the bytes as colors and display the corresponding picture. If the file is itself treated as an executable and run then the operating system will attempt to interpret the file as a series of instructions in its machine language. Binary files include embedded control characters that tell the application that support that particular file type what to display or do.

Application program metadata as discussed above may be data about the application program rather than the application program itself. The metadata may be visible to a user accessing the application source such as through a web browser. Referring to now to metadata may include for example a title of the application a description of the application a textual description a graphical description e.g. screenshots of the application jpeg file format png file format gif file format a trailer e.g. video trailer of the application terms of use privacy policy release notes date of last update or release date the application was published on the web site version information operating system requirements one or more categories associated with the application a number of times the application has been installed or downloaded a size of the application e.g. in megabytes rate of installation price rating information e.g. 1 star 2 star 3 star 4 star or 5 star average rating content rating e.g. high maturity low maturity graphic violence brief nudity and so forth developer publisher a listing of other applications from the developer developer contact information e.g. email address web site address phone number or mailing address a listing of other applications viewed by users who also viewed the particular application a listing of other applications installed by users who also installed the particular application user reviews e.g. text of review date of review reviewer username or reviewer client device permissions a number of likes a number of dislikes and so forth.

An application program may be capable of executing without the application program metadata. For example the description of the application may be deleted and the application may be executed after the deletion of the description. The description of the application may be edited and the execution of the application program may be the same before and after the editing of the description. Deleting or modifying an application program binary file however may alter the execution of the application. For example the application program may not execute properly after the deletion or modification. There may be an error message when trying to execute the application program.

Analysis server is responsible for correlating the application objects e.g. application program binaries and metadata inferring relationships among the application objects and making assessments based on the correlations and relationships. Analysis results such as assessments correlations or information describing the relationship may be stored in results database . Reporting server acts as an interface to database for providing results from the application analysis to clients . Results may be provided programmatically such as through an application programming interface API as discussed in U.S. patent application Ser. No. 13 335 779 filed Dec. 22 2011 which is incorporated by reference along with all other references cited in this application. Instead or additionally results may be provided through a graphical user interface GUI such as to a dashboard or management console HTML page a report e.g. PDF report a data feed to a partner published to a web site an e mail and so forth. A client may be a mobile device user or end user an app developer marketplace owner or other entity.

The application receiver collects and stores application programs metadata or both that have been submitted to the system by the clients. For example a user may upload an application program to the system for an analysis. In a specific implementation after analyzing the application and providing the analysis results the system continues to maintain or store the application in application program database . Continuing to store the application allows the system to reanalyze the application and provide new or changed analysis results if any to the user. For example a reanalysis may be performed if a new or updated virus signature pattern is received.

To help ensure an extensive collection of data query generator generates forms or composes queries in order to discover new application programs application programs that may be related to application programs discovered previously associated application metadata e.g. application reviews or combinations of these. For example the query generator can be used to find sources e.g. web sites or marketplaces where application programs application metadata or both may be found. The queries may be submitted or otherwise provided to a search engine or source of applications which returns search results. Crawler crawls the search results to retrieve or download the application and associated metadata. Crawler may include a controller to instruct the crawler to begin or stop crawling and a client device emulator .

The crawler may be referred to as a spider robot or app crawler. In a specific implementation the crawler crawls across different markets to search and download apps for mobile devices. These markets may include official application markets e.g. Android Market or Apple App Store alternative app markets e.g. Amazon Appstore for Android forums download sites or combinations of these. The app crawler can gather metadata information for each app from each market and store it in a database. The metadata information may include information related to the app s ratings price number of ratings user comments app s icon on the market page which could be different from the app icon on the device and so forth.

In a specific implementation the crawler uses a feedback loop where metadata from a search result feeds subsequent or additional searches. That is initial results can determine future queries. shows a flow for a feedback loop. In a step query generator generates search terms which are used to compose a search query step . In a specific implementation a technique to help ensure comprehensive search term coverage and enumerate or discover app marketplaces includes obtaining a ranked list of Words e.g. top or most frequently used 50 000 words in the English language and creating a search query for each word combinations of words or both.

A search query may be a structured query that includes Boolean operators parentheses or both. Some examples of Boolean operators include OR AND and NOT. A search query may be a faceted query having a conjunction of topics or facets. For example a query such as flight OR airline AND travel OR fare OR compare OR ticket may find apps about purchasing airline tickets even if the app descriptions omit one of the words travel fare compare or ticket. A query may include a wildcard symbol e.g. or proximity operator such as NEAR NOT NEAR FOLLOWED BY NOT FOLLOWED BY SENTENCE PARAGRAPH FAR or combinations of these. For example the query syntax keyword1 NEAR n keyword2 where n is a number may specify that a maximum number of words between keyword1 and keyword2 is to be n. There can be particular field searches term modifiers word stemming wildcard searches fuzzy searches range searches term boosting field grouping and the like.

In a step the search query is submitted or provided to a search engine. For example the search query may be submitted to a source of application programs e.g. an app marketplace . In a step the application collector program receives a search result responsive to the query. The search result may identify an application program a source of application programs or both. For example the returned search result may list several applications e.g. by application title responsive to the query. The returned search result may include one or more sources of application programs such as a list of web sites or addresses e.g. universal resource locators URLs that host application programs e.g. application marketplaces developer web sites provide a forum for discussing application programs contain application program reviews and evaluations and so forth for crawler to crawl. In a specific implementation the crawler crawls search results from a search engine that has an indexed set of data rather than enumerating or following the links on a web page. In another specific implementation the crawler may follow the links on the web page. For example a web page having a review of an application may include a link to other reviews of the application. The crawler may follow or access the link to download the other reviews of the application so that the system can perform a comprehensive analysis of the application.

In a step the crawler retrieves gets obtains fetches or downloads and stores an application program associated metadata or both from the source. Data may be extracted from the downloaded application objects and stored in a database. In a specific implementation each application is uniquely identified using a package name or some other mechanism such as a hash of the application contents.

In this specific implementation the metadata information related to each application is stored against the unique application identifier as well the name of the application source or market from where it was obtained. The app crawler downloads each application from each of the different markets stores the application and extracts information embedded within the application itself such as Package Name Declared App Permissions Entitlements the application icon application signing certificate and so forth and stores all the information in a database. The metadata extracted from the application may be stored against the same unique application identifier that was used to store the metadata information. The application binary itself may be stored such that each binary can be uniquely identified to the specific market from where it was downloaded.

Table A below shows an example of an entry or record in a database table storing an application binary data extracted from the application binary and application metadata.

As shown in the example above Table A includes the fields Id Title App Binary Package Name Permissions Icon and Developer. The Id field stores an identifier for the application e.g. 01 . In a specific implementation the identifier is a hash of the application contents. The application may be provided as input to a hash function which returns hash value or code so that the application can be identified. Instead or additionally an application may be identified by its package name. The Title field stores the title or name of the application as displayed at the source e.g. marketplace for users to browse and see. The App Binary field stores the binary file of the application.

The Package Name field stores the package name of the application e.g. com.boogle.angry com.boogle.dig and com.etari.invader as declared inside the package file. For example an Android application package file APK is the file format used to distribute and install mobile application software onto devices having Google s Android operating system. To make an APK file a program for Android is first compiled and then all of its parts are packaged into one file. This holds all of that program s code such as .dex files resources assets certificates and manifest file.

The Permissions field identifies the features of the client device that the application program can access. For example the application Angry includes the permissions location and camera. The location permission allows the application to access the client device s geographical location information such as global positioning system GPS coordinates cell id or WiFi location. The camera permission allows the application to access the client device camera. The application Dig includes the permission contacts. With the contacts permission the application can access the contacts list on the client device e.g. telephone directory .

The application Invader includes the permissions calendar and SMS. The calendar permission allows the application to access calendar appointments saved on the client device. The SMS permission allows the application to send text messages from the client device. The Android Developers Reference for Android 4.0 r1 Feb. 1 2012 available at which is incorporated by reference includes an extensive list of permissions or features that an application may access. The system can analyze the application identify the permissions or features than the application can access and store a list of the permissions.

The Icon field stores the launcher icon to the application. The launcher icon is a graphic that represents the application. The Launcher icon is the graphic or image that is displayed on the home screen or electronic display of the client device. The Developer field stores the name of the application developer e.g. Boogle and Etari .

The database may include extracted data i.e. data that is extracted from the application program or binary. For example mobile application programs for the Android platform include a file called a manifest. The manifest file is an XML file that includes among other things the permissions or client device features that the application can access. These permissions may be specified within a permissions tag or element in the manifest file. In a specific implementation the crawler program is configured to parse an application program file locate a specific element within the file extract the values or attributes listed within the specific element and store the extracted values in the database. In a specific implementation the parsed application file is an Android manifest file the specific element is the permissions element and the extracted values are permissions. It should be appreciated however that the crawler program can parse any file or directory of the application program to extract and store the desired data.

It should be appreciated that Table A above is merely one example of how data may be stored. Data may be stored in any number of ways that may or may not include storing in a database field.

In a step the crawler program parses the metadata for keywords to form search terms for another query. The flow loops back to step so that the other query can be submitted. This feedback loop helps to discover new application programs new application metadata new application sources or combinations of these. The feedback loop of metadata acquired by a set of search terms can be used to feed additional searches that yield more data.

More particularly extracted metadata can be used to generate search terms so that the process of searching and downloading application objects can be continuously repeated. Each search iteration may yield new applications that can be collected in order to build a comprehensive database of applications. The extracted data may include words phrases numbers characters symbols images video graphics pictures or combinations of these. The extracted data e.g. words may be added to a word list that is stored at the system. The word list may include some initial seed words used to initialize the searching i.e. words not from extracted application metadata words from extracted application metadata or both. Composing a search query step may include selecting words from the word list where at least one of the words was extracted from application metadata. In a specific implementation a technique for building a word list includes extracting words from application metadata such as a name of a developer who was not in the word list. The developer name is added to the word list so that new search queries having the developer s name can be generated to discover new applications from the developer.

In a specific implementation a method for finding and collecting application programs includes retrieving a first application program and first metadata associated with the first application program from a source of application programs storing the first application program and first metadata parsing the first metadata to identify at least one keyword in the first metadata submitting to the source of application programs a first query including a search term based on the at least one keyword in the first metadata receiving a first search result responsive to the first query. The first search result may identify a second application program related to the first application program. The method may further include retrieving the second application program second metadata associated with the second application program or both from the source of application programs.

In another specific implementation a first query provided to a search engine includes a first search term. A first search result received from the search engine responsive to the first query identifies a first source for application programs. The crawler program accesses the first source and downloads from the first source a first application object. The first application object is parsed to identify keywords for a second search term. A second query is composed with the second search term and provided to the search engine. A second search result received from the search engine responsive to the second query identifies a second source for application programs. The crawler program access the second source and downloads from the second source a second application object.

The first source may be different from the second source. For example the first source may be the Android Marketplace and the second source may be the Amazon Appstore. In this example both sources are of the same type. That is both sources are application marketplaces. Alternatively the sources may be of different types. For example the first source may be an application marketplace. The second source may be an Internet or online forum.

A search term may include one or more identified keywords in the first application object. For example the first application object may include a first application program and first metadata specifying a name of a developer of the first application program. A search term may include the name of the developer so that other application programs from the developer can be found.

Instead or additionally a search term may include a derivation of the one or more identified keywords. A search term may be generated using for example query broadening stemming conflation lookup algorithms suffix stripping algorithms lemmatization stochastic algorithms n gram analysis affix stripping matching algorithms multilingual stemming morphology analysis or combinations of these.

As a specific example the first metadata may specify a title of the first application program. The second search term may include a variation of the title so that counterfeit knockoff or similar versions of the first application program may be found. For example the mobile application program Angry Birds developed by Rovio Mobile has become very successful. Other developers wishing to capitalize on the brand may develop applications with similar titles e.g. Angry Dogs Angry Cats Angry Fish and so forth . There may be an intent to deceive consumers into thinking that they are purchasing a legitimate application or an application developed by the same developers as Angry Birds when in fact these applications are not legitimate e.g. include malware or are unauthorized reproductions or derivations . It would be desirable to find these other mobile application programs so that these applications can be removed from the marketplace and users are not duped into downloading the applications. Thus a search term based on the keyword title Angry Birds may include the terms Angry Dogs Angry Cats Angry Fish and so forth.

In another specific implementation indexing techniques may be used to generate search terms. For example crawler may index the description of an application program calculate a frequency at which a word or phrase appears in the description and compose a search query by selecting those words or phrases having a high frequency. Articles such as a an and the may be ignored during the indexing.

Indexing may be performed across multiple applications or multiple descriptions of applications . In another specific implementation a technique for collecting and discovering new applications includes comparing first metadata describing a first application program with second metadata describing a second application program to identify a keyword that is in the first and second metadata. A query is formed based on the keyword that is in the first and second metadata. The query is provided e.g. transmitted or sent to a search engine. The search engine returns a result responsive to the query. The search result identifies a new source for application programs. The crawler program accesses the new source to retrieve application programs application metadata or both.

The above index may be created by extracting keywords from each application description. Search terms and queries can be generated by selecting the various index words.

Emulating various client devices allows the crawler program to obtain good data coverage of the target data source. That is to download from the source an exhaustive set of application programs so that a comprehensive database of application programs can be created for insightful correlations and inferences.

In brief in a step the crawler selects from client device personality database a client personality profile. In a step the client personality profile is provided to a source such as a source of mobile application programs. In a step the crawler receives from the source a listing of applications intended for client devices having the selected client personality profile. In a step the crawler retrieves from the source the application objects e.g. application programs associated metadata or both that the source makes available to client devices having the selected client personality profile. The process may loop back to step to select a different client personality profile so that applications intended for the different client personality profile can be retrieved from the source.

Table C below shows some attributes of a client personality profile. A client personality profile may include a subset of attributes in any combination.

Emulating a client device by providing the source with a particular client personality profile may be performed by for example inserting emulation data into an API request causing the source of data transmitted to the source to appear from a particular client personality for example from an IP address on a particular network or particular country transmitting emulation data to the source for example as part of a signup configuration or other information gathering process or inserting emulation data in the user agent field of an HTTP request.

In a specific implementation a method for helping to ensure a comprehensive collection of application programs includes providing to a source a first client personality indicating that a client device having the first client personality is requesting application objects receiving from the source a first listing of application objects that the first source makes available to client devices having the first client personality. The method further includes providing to the source a second client personality different from the first client personality. The second client personality indicates that a client device having the second client personality is requesting the application objects. The method further includes receiving from the source a second listing of application objects that the source makes available to client devices having the second client personality. The second listing may include a second application object and may not include the first application object. The first listing may include the first application object and may not include the second application object.

In various specific implementations the first personality specifies the client is of a first model and the second personality specifies the client is of a second model different from the first model. The first personality specifies the client is located in a first country and the second personality specifies the client is located in a second country different from the first country. The first personality specifies the client has a first set of capabilities and the second personality specifies the client has a second set of capabilities different from the first set of capabilities. The first personality specifies the client is from a first manufacturer and the second client personality specifies the client is from a second manufacturer different from the first manufacturer. The first personality specifies the client includes a first operating system and the second personality specifies the client includes a second operating system different from the first operating system. The first personality specifies the client is on a first carrier network and the second personality specifies the client is on a second carrier network different from the first carrier network.

The system can use multiple personalities to retrieve application metadata and binaries. The same query can be used across multiple personalities e.g. top apps served to this personality . Alternatively queries can be custom to each personality e.g. If a personality is a language then using language specific search terms .

In a step the crawler program accesses a source of applications e.g. visits a URL of a mobile application marketplace . In a step the crawler requests from the source a date ordered listing of applications available at the source. In a specific implementation the date ordered listing is a reverse chronologically ordered listing of the applications. The listing includes applications sorted by date of publication or release. In the listing recently published applications are positioned above or before less recently published applications. Table D below shows an example of a date ordered listing in reverse chronological order.

As seen in Table D the most recently published or newest application is Angry followed by Dig followed by Invader and so forth. In this reverse chronologically ordered or sorted listing the entry for Angry is at a top of the list because it has the most recent publication date. The entry for Donkey is at a bottom of the list because it has the earliest publication date. The entry for Angry is adjacent or next to the entry for Dig. The entry for Angry is positioned or located above the entry for Dig. 

In another specific implementation the date ordered listing is a chronologically ordered listing of the applications. In this specific implementation in the listing earlier published applications are in a position or order above or before recently published applications. Table E below shows an example of a date ordered listing in chronological order.

As seen in Table E the earliest published or oldest application is Donkey follows by Invader followed by Dig and so forth. In this chronologically ordered listing the entry for Donkey is at the top of the list because it has the earliest publication date. The entry for Angry is at the bottom of the list because it has the most recent publication date. In another specific implementation the application source may not provide a date ordered listing of applications. In this specific implementation the crawler program itself may perform the sorting.

In a step the crawler examines an entry in the listing to determine whether an application corresponding to the entry has been previously retrieved such as on a previous or prior visit to the source. In a specific implementation examining the entry includes comparing a title of the application in the listing with a stored title in data repository . If there is a match a determination may be made that the application has been retrieved on a previous occasion. If there is not a match a determination may be made that the application has yet to be retrieved.

Instead or additionally version information publication date or both of the application in the listing may be compared with the respective stored version information publication date or both of an application stored in the data repository of the system. Comparing versions publication dates or both helps to ensure that the latest version of an application is or has been retrieved. For example two applications may share the same title e.g. Angry but one application may be a later version e.g. version 2.0 of the other application e.g. version 1.0 . So comparing version information can help to ensure that the application Angry version 2.0 is retrieved from the source.

In a specific implementation an entry is examined without retrieving the corresponding application from the source. This helps to conserve computing resources such as network bandwidth and processing resources including the processing resources of the application source server.

In another specific implementation examining an entry in the listing to determine whether an application corresponding to the entry has been retrieved previously includes downloading the corresponding application. Downloading the corresponding application and comparing the downloaded application to the stored applications in the data repository can help to provide confirmation that the application program i.e. the same application program has in fact been or not been retrieved previously.

For example there may be errors e.g. typographical errors in the application version information. That is an application having version metadata that indicates the application is version 1.0 may be incorrect and the application version may in fact be version 2.0. Retrieving and comparing the application binary with previously stored application binaries helps to protect against such errors.

In a specific implementation the comparison includes hashing the downloaded application contents and comparing the hash value with hash values of the stored applications. If the hash values match a determination may be made that the application has been previously retrieved. If the hash values do not match a determination may be made that the application has not been previously retrieved. Application program comparisons may include comparing application binaries application hash identifier values application metadata e.g. application title or application version or combinations of these.

In a step based on the examination of the entry step if the corresponding application has been previously retrieved the crawler program updates an overlap counter variable. The overlap counter variable tracks a number of occurrences where an application found during a current crawl is the same application from a previous crawl of the application source.

In a step the crawler program compares the updated overlap counter variable with a threshold overlap value to determine whether a remaining entry next to the entry in the listing should be examined. Based on the comparison a determination may be made that all applications at the source have been previously retrieved and remaining entries may not be examined step . Alternatively based on the comparison a determination may be made that there may be applications at the source that have not been previously retrieved and a remaining next or adjacent entry may be examined step . As shown by loop the process iterates or repeats until based on the comparison of the updated overlap counter variable and the threshold overlap value a determination is made that all application programs at the source have been previously retrieved step .

The overlap threshold value can be a user configurable or user adjustable value. For example an administrator may change alter edit or modify the threshold value from a first value to a second value different from the first value. The threshold value may be the same for two or more different application sources. Alternatively the threshold value may be different for two or more different application sources. For example a first application marketplace known to have more coherency issues than a second application marketplace may be assigned a threshold value that is greater than a threshold value assigned to the second application marketplace. Alternatively a first application marketplace known to have fewer coherency issues than a second application marketplace may be assigned a threshold value that is less than a threshold value assigned to the second application marketplace. A threshold value can be specific to a particular application source.

In a specific implementation updating the overlap counter variable step includes incrementing the overlap counter variable e.g. adding 1 to the overlap counter variable . As an example consider Table D above. In a first iteration the entry for the application Angry is examined to determine whether the application has been previously retrieved step . Assuming that the application has been previously retrieved in this specific implementation updating the overlap counter variable step includes incrementing the overlap counter variable. So for example an increment value e.g. 1 may be added to the overlap counter variable so that the value of the variable is 1. 

The updated overlap counter variable e.g. 1 is compared to the threshold overlap value to determine whether a remaining entry next to the entry in the listing should be examined step . In a specific implementation if the overlap counter variable is less than the overlap threshold the next entry is examined. For example if the overlap threshold value is set at 2 a next entry in the listing would be examined because the value of the updated overlap counter variable e.g. 1 is less than the overlap threshold value e.g. 2 .

Thus in a second iteration a next entry for the application Dig is examined to determine whether the application has been previously retrieved step . Assuming that the application has been previously retrieved in this specific implementation the overlap counter variable is incremented so that the current or new value is 2 i.e. 1 1 2 . In step the updated overlap counter variable now having a value 2 is compared to the threshold overlap value e.g. 2 to determine whether a next remaining entry in the listing should be examined. In a specific implementation if the overlap counter variable is greater than or equal to the overlap threshold a determination is made that all application programs at the source have been previously retrieved and remaining entries are not examined step .

In the example above the remaining entries e.g. Invader and Donkey would not be examined because the updated overlap counter variable is greater than or equal to the overlap threshold e.g. 2 2 .

In another specific implementation updating the overlap counter variable step includes decrementing the variable e.g. subtracting 1 from the variable . In this specific implementation the overlap counter variable may be initialized with a user configurable predetermined value e.g. 2 . As an example consider again Table D above. In a first iteration the entry for the application Angry is examined to determine whether the application has been previously retrieved. Assuming that the application has been previously retrieved in this specific implementation updating the overlap counter variable includes decrementing the variable. So for example a decrement value e.g. 1 may be subtracted from the overlap counter variable so that the value of the variable is now 1 e.g. 2 1 1 .

The updated overlap counter variable e.g. 1 is compared to a threshold overlap value e.g. 0 or zero to determine whether a next remaining entry next to the entry in the listing should be examined. In a specific implementation if the overlap counter variable is greater than the overlap threshold the next remaining entry is examined. In this example the next remaining entry is examined because the updated overlap counter variable is greater than the threshold overlap value e.g. updated overlap counter variable 1 threshold overlap value 0 evaluates to true. 

Thus in a second iteration a next entry for the application Dig is examined to determine whether the application has been previously retrieved from the source. Assuming that the application has been previously retrieved in this specific implementation the overlap counter variable is decremented so that the current or new value is 0 i.e. 1 1 0 . The updated overlap counter variable now having a value of 0 is compared to the threshold overlap value e.g. 0 or zero to determine whether a next remaining entry in the listing should be examined. As discussed in this specific implementation if the overlap counter variable is greater than the overlap threshold the next remaining entry is examined the determination being that there may be applications at the source that have not been previously retrieved. If the overlap counter variable is less than or equal to the overlap threshold the remaining entries are not examined the determination being that all applications at the source have been previously retrieved.

In the example above the remaining entries e.g. Invader and Donkey would not be examined because the updated overlap counter variable is less than or equal to the overlap threshold e.g. 0 0 .

The crawler may be run at any desired frequency or interval. In a specific implementation in order to have a low latency the crawler is run or executed at a high frequency. This helps to ensure that the app data set including apps and app metadata is up to date. As an example the crawler may be run at 5 10 30 or 60 minute intervals. The crawler may be run daily or weekly. Some web sites may be crawled more frequently than other web sites. For example an app marketplace that often publishes new applications may be crawled more frequently than other app marketplaces that publish new applications less often or less frequently. An app marketplace that is more popular than another app marketplace may be crawled more frequently than other app marketplaces that are less popular. Although shows a single crawler it should be appreciated that there can be multiple crawlers e.g. two or more crawlers.

In a specific implementation a crawler downloads from an application source an application program and associated application metadata. For example the source may be an app marketplace web site that includes both the application program and the application metadata. In another specific implementation the crawler on a current crawl of the source downloads the application program but does not download the application metadata. For example the application metadata may have already been downloaded on a previous crawl of the web site.

The crawler on a current crawl of the source may download a portion of the application metadata and not download another portion of the application metadata. For example the downloaded portion of the application metadata on the current crawl may include some new user reviews that were not downloaded on a previous crawl. In another specific implementation a crawler on a current crawl downloads the application metadata but does not download the application program. For example the application program may have been previously submitted to the system by a user.

The crawler may download the application program and application metadata from the same source. Alternatively the crawler may download the application program and application metadata from different sources. A crawler may download from a first web site an application program and first application metadata associated with the first application program. The crawler may download from a second web site different from the first web site second application metadata that is associated with the first application program. For example the first web site may be an app marketplace having both the application program and the first application metadata. The second web site may be a forum having a discussion thread discussing the application program. The crawler can download the discussion thread the discussion thread being the second application metadata.

Collecting data from multiple places allows the system to develop a holistic and comprehensive analysis. Thus depending upon the situation or source encountered by the crawler the crawler may download the application program and not download the application metadata download the application metadata and not download the application program download the application program before or after downloading the application metadata or download the application metadata before or after downloading the application program. The crawler may download the application program and application metadata from different application sources.

In a specific implementation the crawler downloads from a source first and second application programs even if application metadata indicates that the first and second application programs are the same. For example the first and second application programs may have the same title e.g. Angry Birds thus indicating that the first and second application programs are the same. However one of the application programs may be illegitimate e.g. a knock off of the other application program. So the crawler may download both application programs and analyze both application programs to identify any differences or identify the legitimate or illegitimate application program. Further discussion of application analysis is provided below.

The correlation and comparison engine is responsible for correlating and comparing two or more application programs e.g. application binaries two or more associated application metadata or both. The two or more application programs may be from a same source of application programs. For example the two or more application programs may be from the same application marketplace e.g. Google Android Market . The two or more application programs may be from different application sources. For example one of the application programs may be from the Google Android Marketplace. The other application program may be from the Amazon AppStore. Likewise the two or more associated application metadata may each be from a same or different source.

The inference engine is responsible for analysis and drawing an inference based on the correlations and comparisons. For example although two applications may appear to be the same to a user browsing an application marketplace the two applications may actually be different. For example an application binary of a first application program may be different from an application binary of a second application program. Hash values of the application binaries may be different. Signing certificates application fingerprints signing keys package names entitlements permissions media assets ad network ad network account identifiers digital rights management DRM protection publisher names or combinations of these may be different between the two or more applications.

The inference engine can make an assessment determination or inference that one application is a counterfeit of the other application or that one application is illegitimate and the other application is legitimate. For example one application may be a repackaged version of the other application. The repackaged application may include malware or other undesirable code.

More particularly based on the metadata and binary information from the different markets the system correlates information related to each application across different markets. Different correlation criteria may be used to determine if two applications are the same or related.

1 Data present in the application binaries e.g. unique sequence of bits either all consecutive or dispersed across different parts of an application strings present in the application .

4 Identifiers in the application binary or metadata e.g. package name fingerprint of code signing certificate public key used to sign the app requested entitlements permissions .

5 Market metadata e.g. developer name account icon images description title one application having replaced another application in a market .

6 Statistical properties extracted from the application binary application metadata market metadata or a combination of these.

7 Extracted features that sufficiently characterize the unique properties of an application may be any of the above .

Consider for example the following scenario for identifying malware. An application with the package name com.trustme.honestapp contains a specific bit sequence that is known to be present in previously identified malicious application. The system therefore flags such an application as malicious.

Consider as another example the following scenario for identifying a pirated repackaged app. An application with a package name com.most.famous.app is available for a price in the official market but it s available for free in an alternative market. However the application is packaged with an add on Ad SDK in the alternative market and signed with a different code signing certificate. In this case based on the metadata related to price as well as the discrepancy between package name and code signing certificate the system infers that the application has been pirated and repackaged with an Ad SDK.

This technique can be used to identify pirated or maliciously modified application programs. In some cases a rogue or unscrupulous developer may take an application developed by another and modify the application. The unscrupulous developer may intend that the modified application look the same as the original application so that users are lead to believe that the modified application is the same as the original application is from the same developer as the original application or both. For example the modified application may have the same title as the original application.

The modified application program however may in fact be different from the original application program. For example the modified application may include an ad network that is different from the ad network of the original application. The modified application may include an ad network that had not been included in the original application.

An ad network also referred to as an advertising network is a company that connects advertisers to web sites that want to host advertisements. An application developer may host or use an ad network with the application program. This allows the application developer to receive payment through the placement of advertisements in the application program. Typically the ad network issues an account identifier to the developer which the developer can insert into the application. The account identifier allows the ad network to identify the developer who should receive payment when for example a user clicks on views or accesses an advertisement that is displayed with the application program. The rogue developer may modify the original application by replacing the account identifier with an account identifier associated with the rogue developer. The result is that advertising payments that should be paid to the original application developer are instead paid to the rogue developer.

As another example the modified application may include malware undesirable code or otherwise cause undesirable behavior e.g. sending text messages without user consent deleting phone directory copying sensitive information stored on the mobile device and so forth . The modified application can be like a Trojan Horse something that is presented as useful or harmless to induce the user to install and run the application. Running such a maliciously modified application can have many undesirable effects. The original developer may be deprived of payment from the would be user or purchaser of the application the original developer may be deprived of advertising revenue sensitive information that the user may store on the mobile device may be stolen the goodwill and reputation of the original developer may suffer just to name a few examples. Systems and techniques as described in this patent application can reduce or prevent such disasters from occurring.

More particularly in a specific implementation in step the system measures a degree of similarity between the first and second application metadata. For example a Levenshtein distance or edit distance may be used to measure the amount of difference between the first and second metadata e.g. the amount of difference between the application titles or descriptions . The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other with the allowable edit operations being insertion deletion or substitution of a single character. A Levenshtein distance is merely one example of a distance metric. Other distance metrics may instead or additionally be used e.g. longest common subsequence Damerau Levenshtein distance Hamming distance or others .

Similarity may be based on text e.g. two applications having the same or similar application titles images e.g. two applications having the same or similar icons video sound audio data or combinations of these. The system may use any competent image or media asset comparison technique to compare an image e.g. icon associated with one application program with an image associated with another application program. For example image comparisons may be based on pixel position color image size edge and boundary detection and others. Some specific examples of image comparison techniques include Hausdorff Distance histograms e.g. joint histograms color histograms keypoint matching and Scale invariant feature transform or SIFT keypoints . Acoustic fingerprinting may be used to compare application sounds. Video fingerprinting may be used to compare video.

In step if the degree of similarity is within a threshold degree of similarity the system compares the first application program with the second application program to identify any differences between the first and second application programs. The threshold degree of similarity may be configurable such as by an administrator. As an example the system may scan the application repository and identify applications that have a high degree of similarity between the application metadata. In other words the applications have a low degree of difference between the application metadata. For example the two applications may have the same title such as Angry Birds. 

An administrator may configure the threshold degree of similarity e.g. adjust the edit distance threshold value so that similar application titles or descriptions though not identical are identified. For example based on the threshold degree of similarity the system may identify a first application program having the title Angry Birds. The system may identify a second application program having the title Angry Dogs. An application program from a different developer having a similar though not identical title as another application program may indicate that the developer is attempting to improperly capitalize on the goodwill and reputation of the original developer.

Upon identifying two or more applications programs that may appear to users to be the same or be from the same developer the system compares the application programs e.g. compares the application program binaries to identify any differences. As discussed above a comparison can include a sequence of bits strings present in the application using a code similarity algorithm using code similarity based on name structure or graph structure media assets package name fingerprint of code signing certificate public key used to sign the application requested application entitlements requested application permissions statistical properties extracted from the application binary other application properties or combinations of these. For example a code similarity algorithm that fingerprints each component in an application e.g. Java class Objective C framework shared library can be used to determine what types code is shared between two applications and what code is unique. Such a code similarity algorithm may examine the structure of a given component for example the exposed API the control flow or instruction contents of the component s implementation linkage to other components or other aspects of the component to create a fingerprint that uniquely identifies that component as different from other components.

In step at least one difference may be identified between the first and second application programs. The at least one difference may include the first and second mobile application programs having different package names. For the Android platform the package name may be used to identify the application. The package name may be unique on the Android Market such that there may not be two or more application programs with the same package name on the Android Marketplace.

The at least one difference may include the first and second mobile application programs having been signed with different code signing certificates. Code signing is a mechanism whereby publishers of software and content can use a certificate based digital signature to verify their identities to users of the code thus allowing users to decide whether or not to install it based on whether they trust the publisher. So for example the original application developer may have a code signing certificate that is different from a code signing certificate of the rogue developer.

The at least one difference may include the first and second mobile application programs having different requested permissions. As discussed above a platform such as Android provides applications with an API that includes access to device hardware e.g. camera communication networks e.g. WiFi and cellular network settings and user data. So for example a rogue developer may modify the application program such that the program requests additional permissions that may not be needed for the original application to function. For example the additional permissions may include permissions to access personal user data stored on the device.

The at least one difference may include the first and second mobile application programs having different digital rights management DRM protection. For example if an application has DRM and then it can be an indication that the application e.g. game has been pirated repackaged if that DRM has either been modified or removed.

The at least one difference may include the first and second mobile application programs having different publisher names e.g. in market metadata. The at least one difference may include the first and second mobile application programs having different account identifiers issued by an ad network. The at least one difference may include the first and second mobile application programs having different behavior when probed or analyzed by an analysis system e.g. dynamic analysis.

The at least one difference may include the first and second applications having different code e.g. one application having additional code. Furthermore the at least one difference may include the first and second applications having different code the difference in code having risky functionality. For example when determining code in one application that is not present in another e.g. by code fingerprinting it is possible to analyze the functionality of that additional code using static analysis techniques. If an additional code performs benign functionality e.g. no data access or risky behavior it may be treated differently than if it performs risky functionality e.g. sending text messages accessing user data . Benign functionality in added code may not be considered a difference between the two applications while risky functionality in added code may be considered a difference.

In step the inference engine based on at least the identified at least one difference and the degree of the similarity between the first and second metadata being within the threshold degree determines that one of the first or second application programs is a counterfeit of the other first or second application programs. Factors that may be used to determine which of the first or second application programs is the counterfeit application program include the application price application source application release date other factors or combinations of these.

For example the application with the lower price may be identified as the counterfeit application because the rogue developer may price the counterfeit application at a lower price so that users are more likely to buy the lower priced application than the higher priced application. The application from the alternative marketplace may be identified as the counterfeit application because the official application marketplaces e.g. Android Marketplace may have better screening procedures to block undesired applications than the alternative marketplace.

It should be appreciated however that the first and second application programs may be from the same source. For example both the first and second application programs may be available on the official Android Marketplace. A rogue developer may upload a pirated application program into the same store as the legitimate application program. In this case other factors may be used to identify which of the two application programs is the counterfeit. The application with the later release date may be identified as the counterfeit application because generally the counterfeit application will have been released after the original application is released. Instead or additionally the ad network account identifier may be used to identify the counterfeit application.

In a specific implementation a method includes receiving from a developer a designation of a first source authorized by the developer to host a first application program designating the first source as the authorized source identifying a second application program hosted on a second source having application metadata similar to the application metadata of the first application program and determining based on the first source being the authorized source and the application metadata being similar that the second application program is the counterfeit.

The method may further include notifying or alerting the application developer. The notification may include sending an e mail or other message to the application developer to inform the developer that there may be a counterfeit of their application program that is hosted on the second source. This service provided by the system allows the application developer to take steps to remove the counterfeit application program from the second source. Instead or additionally the owner of the second source e.g. marketplace owner may receive the notification or alert so that the owner can remove the counterfeit application program.

It may not always be the case that an official application marketplace e.g. Android Marketplace is the authorized source. For example the developer may choose to upload their application to an alternative marketplace because fees e.g. listing fees and commissions may be less on the alternative marketplace than the official marketplace. Thus the alternative marketplace e.g. a marketplace not owned by the platform developer may be designated as the authorized distribution source. Providing the ability to designate a marketplace as the authorized or designated source helps to protect developers and consumers from counterfeit applications that may in fact be hosted on the marketplace of the platform owner e.g. Android Market or Apple App Store .

In another specific implementation the system provides a service to notify trademark owners if their mark is being improperly used in connection with an application program. In this specific implementation the system receives a mark. The mark can be a name word phrase logo symbol design image or a combination of these. The system scans the application repository to identify any applications having the received mark or an object similar to the received mark . Upon identifying an application having the received mark the system sends a notification e.g. e mail notification or otherwise alerts the trademark owner. In another specific implementation the system provides a service to notify copyright owners if their copyrighted material is being used in connection with an application program in a similar manner to notifying owners of trademarks and may be used for any sort of copyrighted material that can be digitized e.g. audio video software code images text .

In a step a second application program is correlated with the first application program using one or more correlation criterion. For example Table F below shows some of the application information that may be stored in the repository of the system.

In Table F a first column lists the application. A second column lists the developer. In this scenario the system may correlate the application Star Patrol e.g. first application program with Block Fighter e.g. second application program based on developer name. Correlation can be applied based on any unit of data associated with an application. As discussed above the correlation may be based on data present in the application binaries code similarity between application binaries media assets included in the application binaries identifiers in the application binaries identifiers in the application metadata developer author publisher market metadata statistical properties feature extraction application source DRM protection or combinations of these.

In a step based on the first assessment of the first application program and the correlation of the second application program with the first application program the system generates a second assessment of the second application program. For example the system may make a first assessment that the application program Star Patrol is malicious. Based on the malware assessment and the correlation of Block Fighter with Star Patrol a second assessment is generated. For example the second assessment may be that Block Fighter is malicious or is likely to be malicious. The second assessment may be the same similar or different from the first assessment.

In a specific implementation the second assessment may be generated without for example scanning the second application program. The second application program may not be stored in the application repository. For example the application repository may include metadata associated with the second application program such as the application title and developer name but not the application binary. Through the correlation however the system can generate an assessment for the application program.

An application may be published in multiple places. In an implementation the system provides a correlation of publishing factors to tie identities about a publisher across multiple markets. The correlated information can be used to identify distribution patterns across multiple markets to track the spread of malware across multiple markets to generate protection for one market based on data published in another market.

Referring now to such a system offers many benefits to developers consumers application marketplace owners trademark and copyright owners and others. For example in an implementation the system provides a programmatic interface that is made available to marketplace owners. In this implementation a developer submits an application to the marketplace for hosting. The application is received by the system through the programmatic interface analyzed and an assessment is returned. Based on the assessment the marketplace owner may decide to host or not host the application.

In another implementation the system provides a malware scanning service. A user may have an application installed on the device. Rather than submitting the entire application to the system an application identifier e.g. hash or application title may be submitted. Not having to submit the application helps to conserve computing resources e.g. network bandwidth . Upon receipt of the application identifier the system matches the application identifier to the corresponding application assessment. The corresponding application assessment is returned to the user. An example of a scanning service is further described in U.S. patent application Ser. No. 13 335 779 entitled System and Method for a Scanning API filed Dec. 22 2011 which is incorporated by reference.

The system may provide a graphical user interface e.g. web page or consumer portal for the user to enter the application identifier. The system can return an assessment including an application profile that may detail security information or privacy concerns about the application sources or marketplaces where the application is hosted and the like.

In another implementation the system provides a brand protection service. For example in this implementation a trademark owner may be notified by the system if a mark e.g. logo is used in an application program. This helps trademark owner to enforce their intellectual property rights and helps to prevent consumer confusion over the source of goods and services.

In a specific implementation a method includes crawling mobile app metadata and binaries from different sources to build organize and store a holistic view of each app for each market. In another specific implementation a method includes creating contextual views of markets e.g. language device type etc. by emulating particular types of clients when crawling. In another specific implementation a method includes using the crawled information to correlate apps based on the crawled data in one market or across multiple markets for many uses e.g. malicious pirated repackaged apps .

It is noted that at least one fundamental difference between generic web crawlers and the current disclosure is that generic crawlers organize the data to facilitate quick end user search and retrieval not to make inferences about other data items on the Internet itself. In a specific implementation the system in this disclosure however makes targeted downloads of mobile apps and its associated metadata and organizes the data to make inferences about other mobile apps on the web. Even focused web crawlers like a generic crawler organize their data for efficient query and retrieval and do not use the information to make inferences about other data items mobile apps on the Internet itself.

Further none of the crawlers 1 make a distinction between the crawled data itself mobile app and the metadata associated with the data e.g. user comments app ratings etc. 2 combine metadata information extracted from the data itself as well as other sources of metadata e.g. user ratings etc. which are typically available from a very different source into a holistic view or 3 use the data as well as the metadata to make correlation and inferences about other data items on the Internet. In the context of information retrieval the correlation is done against the query term that the end user has provided not against the crawled data itself.

In the description above and throughout numerous specific details are set forth in order to provide a thorough understanding of the disclosure. It will be evident however to one of ordinary skill in the art that the disclosure may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form to facilitate explanation. The description of the preferred an embodiment is not intended to limit the scope of the claims appended hereto. Further in the methods disclosed herein various steps are disclosed illustrating some of the functions of the disclosure. One will appreciate that these steps are merely exemplary and are not meant to be limiting in any way. Other steps and functions may be contemplated without departing from this disclosure.

