---

title: Application object framework
abstract: A system, a method, and a computer program product for providing an application object framework are disclosed. In response to a request, an application object of a software application is obtained from an application object framework. The application object framework loads a metadata corresponding to the requested application object. The metadata contains at least one metadata schema definition. The application object framework generates a runtime interface for execution of the requested application object based on the loaded metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600299&OS=09600299&RS=09600299
owner: SAP SE
number: 09600299
owner_city: Walldorf
owner_country: DE
publication_date: 20150417
---
This disclosure relates generally to data processing and in particular to in memory database processing using application object framework.

Businesses use a plurality of business process applications and or services in their business operations. Applications and or services can be programs that an end user runs to accomplish certain tasks and can work in conjunction with one or more back end systems which can store the data to be worked on such as for example business objects and other business data as well as logic for manipulating the data such as for example transactions or other business logic. Examples of back end systems may include database systems enterprise resource planning ERP systems and customer relationship management CRM systems. A user interface UI can be designed to work in concert with application programs and facilitates interaction between humans and computers by inviting and responding to user input. In order to accomplish various tasks a user can initiate various applications tasks agents etc. that may manipulate data in different ways to achieve results desired by the user.

Users can design and or create various business process objects such as sales orders invoices etc. A business object can be created using any known computing systems and languages e.g. one such exemplary language includes advanced business application programming ABAP high level programming language which is available from SAP SE Walldorf Germany . Such created objects can be stored in memory such as in a database. An example of such database includes a High Performance Analytic Appliance HANA which is a column oriented in memory database appliance available from SAP SE Walldorf Germany. Each created object comes with a particular view that is specific to the system where it is created and or stored. However conventional systems do not provide an efficient way of maintaining and or storing business data. This can lead to increased operational and or maintenance costs as well as decreased effectiveness of business systems.

In some implementations the current subject matter relates to a computer implemented method for providing an application object framework. The method can include obtaining in response to a request an application object of a software application from an application object framework loading by the application object framework a metadata corresponding to the requested application object the metadata containing at least one metadata schema definition and generating by the application object framework a runtime interface for execution of the requested application object based on the loaded metadata. At least one of the obtaining the loading and the generating can be performed by at least one processor of at least one computing system.

In some implementations the current subject matter can include one or more of the following optional features. The application object can include at least one persistent application object and at least one operation. The operations can include at least one of the following a create operation a read operation an update operation a delete operation a custom action operation an existence of action check operation and an operation on at least one property of the requested application object.

In some implementations the method can store results of the execution of the requested application object in a database communicatively coupled to the application object framework. The database can store an updated metadata for the requested application object based on the execution of the requested application object.

In some implementations the requested application object can be characterized by at least one of the following an object definition a definition of an application object node a definition of an application object root node a definition of an application object node attribute a definition of an application object action and a definition of an application object authorization. The requested application object can be also characterized by at least one static property and at least one dynamic property. The request application object can further include at least one extension providing extensibility to the software application.

Non transitory computer program products i.e. physically embodied computer program products are also described that store instructions which when executed by one or more data processors of one or more computing systems causes at least one data processor to perform operations herein. Similarly computer systems are also described that may include one or more data processors and memory coupled to the one or more data processors. The memory may temporarily or permanently store instructions that cause at least one processor to perform one or more of the operations described herein. In addition methods can be implemented by one or more data processors either within a single computing system or distributed among two or more computing systems. Such computing systems can be connected and can exchange data and or commands or other instructions or the like via one or more connections including but not limited to a connection over a network e.g. the Internet a wireless wide area network a local area network a wide area network a wired network or the like via a direct connection between one or more of the multiple computing systems etc.

The details of one or more variations of the subject matter described herein are set forth in the accompanying drawings and the description below. Other features and advantages of the subject matter described herein will be apparent from the description and drawings and from the claims.

In some implementations the current subject matter relates to an application object framework for maintaining and storing various data including business objects business processes business process applications and or any other data. The application object framework can be operable using High Performance Analytic Appliance HANA system as developed by SAP SE Walldorf Germany. In some implementations the current subject matter relates to a generic application object framework that can provide access to create read update and delete CRUD operations and associated business processes. The application object framework AOF can be a framework that can be based on the HANA platform using an extended services XS engine. The framework can be coded using a server side language Javascript.

In some implementations the application object framework can be used to provide transactional business applications and easy to use possibility to modify business data on database tables. The AOF can provide for enhanced development efficiency where a simple application object including basic CRUD functionality can be quickly enabled. The AOF can also provide for an enhanced supportability testability and extensibility. Using the application object framework extensibility features can be easily introduced. The application object framework can support an extensible metadata declaration to provide extensibility.

The framework component can be a central point of entry into the system and can provide a buffered application object interface for an application object name allowing access to runtime component . Once the client client and or has accessed the framework component the framework component can request the application object component to load a library corresponding to the requested application object including its definition structure attributes actions checks determinations etc. The framework component can also request the metadata component to load a corresponding metadata that can be associated with the requested application object. The metadata component can also obtain an appropriate metadata schema from the schema component which can provide information about metadata definitions associated with the requested application object. The framework component can also obtain information about transaction s that can use the requested application object. In response to the access by the client the framework component can return a runtime access interface to the client client and or client which can include metadata definition s .

In some implementations a runtime interface can be provided by the runtime component . The runtime component can execute various application object operations which can include create read update and or delete operations CRUD as well as any other methods and or custom actions. During creation of the runtime interface application object definition s can be loaded from a library file which can be obtained from the application object component . The application object definition s can be obtained based on the application object name which can contain a package name corresponding to a software package that can contain the requested application object and or an object name corresponding to the requested application object . The runtime component can also request the checks component to perform various checks on the information obtained about the requested application object. The checks component can perform checks of attribute s foreign key s etc. associated with the requested application object to determine whether or not such attribute s foreign key s etc. are valid. If the attribute s foreign key s etc. are not valid an appropriate error message can be generated and returned to the client. The error message can be stored in the message buffer component .

Additionally the runtime component and the framework component can access the message buffer component to add message s and or obtain message s associated with the requested application object. The operation of the message buffer component is discussed in further detail below.

In some implementations during generation of a runtime interface for the client the runtime component can request the authorizations component to perform one or more authorizations associated with the requested application object. The authorizations can include at least one of the following checking instance access for the application object checking parent instance access of a parent object of the application object in some implementations the objects can be stored in a hierarchical and or tree like structure in a memory location . The authorization component can also perform various other checks on the requested application object.

The runtime component can also access the context component to obtain various context that can be associated with the requested application object. The context can include at least one of the following user information action s associated with the requested application object timestamp s that may be requested when the application was accessed modified etc. as well any other information. In some implementations the context component can also provide at least one of the following current context such as a database connection current application user current operation and or request timestamp. The application object framework can be exposed as REST protocol using the REST adapter .

In some implementations the runtime object can also provide information for storage in the HANA component via the database component . An exemplary HANA component is discussed below in connection with . The database component can store various updates that may have been performed by the runtime component as a result of the CRUD operations and or any other custom operations. The database component can also update metadata definitions e.g. table metadata tables associated with the requested application object as well as perform various other operations.

In some implementations once a metadata definition for the requested application object is loaded from the metadata component the framework component can return a runtime access interface to the client including the metadata definition provided by the metadata component . Application object operations in the runtime component can be executed according to the exemplary sequence discussed below.

The runtime component can then call an operation logic e.g. execute any of the CRUD operations and or any custom actions that can be performed on the requested application object at . The operations can be performed based on the metadata definitions that can be supplied by the metadata component at . If an error message has been added to the message buffer component the execution of the operation logic can be stopped at . Otherwise after execution of the operation logic the checks component can be called to determine consistency of the performed operations for all nodes and or attributes associated with the application object based on the metadata definitions provided by the metadata component at . Keys can be generated for any newly created nodes and or sub nodes as a result of the execution of the operation logic at . The runtime component can call on the database component to perform updates to the data associated with the application object as a result of the execution operation logic at . The updates can be provided to the HANA component . The database component can transform Javascript object representation to relational table modifications representation. The operations performed by the runtime component on the requested application can be committed or rolled back if an error message exists in the message buffer component at .

Referring back to in some implementations the metadata definitions of an application object can be validated using the schema component by the framework component and can be performed on demand. In some implementations to improve performance of the system the schema check might not be performed each time the runtime interface for an application object is instantiated.

In some implementations the requested application object can be loaded based on a particular definition. This definition can be stored in a separate library that can be addressed using the name of the requested application object. The application object name can be split up into application package name and an object name. In some implementations the library can be loaded using the following code 

In some implementations the library can include a single definition property at the object definition this.definition and can further specify the metadata definition for the requested application object. An exemplary definition salesorder.xsjslib can contain the following code 

In some implementations the requested application object s definition can follow a particular application object framework schema. illustrates an exemplary schema that can be used for the requested application object s definition according to some implementations of the current subject matter. The schema can include an object level a root node level an attribute level an action level a non authorized action level and a custom action level . The schema can implement at least one of the following Javascript types having the indicated values Structure Javascript Object value Array Javascript Array value Function Javascript Function value String String value Boolean Boolean value Number Number value False Boolean and False value and Null Null value.

The object level can be a top level of the application object definition. It can include a type which can be a structure corresponding to a Javascript object and a definition. The definition can include a root and actions .

The root can contain definition of the application object root. It can include a true value which might be a required property in the definition and a type of a RootNode which can be a definition check that is performed against schema RootNode. The actions can define application object actions which might be a required property in the actions . The Javascript type of the actions can be Structure i.e. Javascript Object . The actions can include constraints which can define various listed constraints including their listed properties and how they can be implemented. The constraints can be required optional forbidden and or generic.

The required constraints can include various actions. Exemplary actions can include at least one of the following create e.g. create operation of the application object having a Javascript type Action performing a definition check against schema Action update e.g. update operation of the application object delete e.g. delete operation of the application object read e.g. read operation of the application object etc.

The optional constraints can include listed properties that can be allowed but that can be optional. Further some constraints can be forbidden i.e. listed properties that might not be allowed e.g. a keyword is protected . Additionally constraints can also be generic whereby generic property definitions can be allowed and defined by an unknown name. These properties can perform a definition check against a particular customer action schema.

In some implementations the schema can include nodes e.g. node which can define an application object node. The nodes can be part of a structure of the scheme . The node can include at least one of the following a table a sequence a history table a parent key read only property a check an attribute and any other type of node property. The table can specify a persistence table for the application object node and have a type of a string i.e. a definition check can be performed against string . The sequence can specify a sequence for the application object node. The history table can specify a persistence history table for the application object node. The parent key can specify a parent key table field for sub nodes. The read only property can specify if a node including attributes is modifiable externally. The read only property can be a Boolean parameter a function and or a null value. The check property can refer to consistency checks that can be performed on a node after a modification. The check property can be an array function. The attribute can specify attribute properties merged with metadata derived from the table definition. Other node properties can specify sub nodes of the current node.

In some implementations the schema can include a root node e.g. root node which can provide a definition of an application object root node. The root node definition can include a determinations property. The determinations property can specify determinations executed after application object modifications. The determinations property can include various constraints which can be at least one of the following an on create constraint an on update constraint and an on modify constraint. These constraints can be array functions. The on create constraint can specify determinations executed after application object creation. The on update constraint can specify determinations executed after application object update. The on modify constraint can specify determinations executed after application object creation or update.

In some implementations the schema can include an attribute component which can be a definition of an application object node attribute. The attributes can include at least one of the following a required attribute i.e. specifying that the attribute is mandatory a foreign key attribute i.e. specifying the application object name the attribute value is a foreign key a constant key attribute i.e. specifying that a constant key the attribute is a default with and which is used during read for selection a read only attribute i.e. specifying that the attribute is read only and not modifiable externally and a checks attribute i.e. specifying consistency checks on attribute after modifications .

In some implementations the schema can include an action component which can define an application object action. The action can include at least one of the following a check authorization action i.e. specifying an authorization check for the action a check enabled action i.e. specifying an enabled check for the action and a history event action i.e. specifying a history event name for the history table entry .

In some implementations the schema can include a no authorization action component which can define an application object action with no authorization check. This component can include a check authorization action which can indicate that check authorization is not allowed.

In some implementations the schema can include a custom action component which can define an application object action with no authorization check. The action can include execute action that can specify an execution logic of the custom action.

In some implementations the schema can include a metadata definition from the XS engine library file for the application logic that can be read as shown above this.definition and interpreted. A majority of metadata information can automatically be derived from the underlying database tables specified an object node definition. The following is an exemplary code indicative of the how the metadata information can be derived 

In some implementations all attributes defined in the table for a node definition can be automatically defined according to the table specification. The column name can correspond to an attribute name. Additionally the attribute type the length scale and or if it is mandatory attribute can be derived. The node primary key can be derived from this information as well. In some implementations the application object definition in the library file can only maintain the additional metadata that cannot be derived from the database tables. Both metadata information are merged at runtime and provided as metadata access to the runtime module.

In some implementations local client access to the application object framework can be provided using an application programming interface API such as a Javascript API. The following exemplary non limiting code can be used to provide access 

For local client access the application object framework library can be imported using .import command including the application object name. An object interface can be returned using the factory method getApplicationObject. The object interface can expose CRUD services and various business actions which can include at least one of the following create update delete exists read custom actions properties static properties and or other services. The create service can create an application object instance including any of its sub structures e.g. a root node a sub node item for each attribute . The update service can update an application instance including any of its sub structures using a root key. The delete service can delete an application object instance including any sub nodes . The exists service can check existence of an application object instance using a key. The read service can read an application object instance for a key and can return a null if no object is found. The custom actions service can call a custom action on application object instance including any sub structures using a key and action parameters received from an execution call. The properties services can retrieve dynamic properties of an application object instance for actions nodes and or attributes. The static properties services can retrieve static properties for an existing application object instance for actions nodes and or attributes.

In some implementations updates to application object instances can be performed on at least one of the following rules. At an attribute level if an attribute property is not provided in the object structure the persisted value is not overwritten. If an attribute property is provided in the object structure the new value overwrites the persisted value. At the node level if a node property is not provided in the object structure all instances of the node are not overwritten. If a node property is provided in the object structure the following merge logic can be applied equality of two node instances can be determined using the defined node key node instances provided and already existing are updated node instances provided and not already existing are created and node instances not provided and already existing are deleted.

In some implementations messages in the application object framework can be characterized by at least one of the following severity e.g. information warning error stops processing at specific processing steps fatal immediately stops processing message key identifying a text key in a text bundle a primary reference key of a message reference node a reference node in the application object instance a reference attribute in the reference node of the application object instance and message parameters. During processing of the object interface call messages can be issued with regard to at least one of the following processing functions check authorization check enabled action execute determination check consistency check read only and or any other functions. The check authorization function can be called for create update delete read and custom actions services for which an authorization can be checked for a passed object instance. The check enabled function can be called for create update and custom actions services for which a check can be called before execution for a passed object instance. The action execute function can be called for custom actions services for which a check can be called before execution for a passed object instance. The determination function can be applicable to only a root node and can be called for create update and custom actions services for which a check is performed before execution for a passed object instance. The check consistency function can be called for create update and custom actions services for which consistency checks can be called after execution for a passed object instance including any sub structures and or attributes . The check read only function can be called for create update and custom actions services for which a read only check of a node and or attributes can be called during a merge of a request and a persisted object. A context object that can be passed in as parameters can include at least one of the following functionalities get access to a current query instance for database access retrieve current application user get current called action get current request timestamp.

In some implementations by exposing an application object and its services as REST operations various properties including static properties of the object can be obtained. A key of an application object instance can be extracted from uniform resource locator URL parameters of the object if such parameters exist. Otherwise the key can be derived from the root node of the REST body structure e.g. JSON structure . Generated keys and messages can be mapped to the REST return structure. Any errors can be placed in the message buffer component . Additionally REST calls can be wrapped with a trace wrapper which can allow returning of traces by including a trace statement as part of the request URL. To expose an application object via REST a XSJS file can be created which can include the following exemplary non limiting code 

As shown by the code above initially a generic REST adapter library can be imported and can provided using a function expose which can handle the above REST mapping request and a response by specifying the application object name as a parameter. Thus an application object can be accessed via HTTP REST using HTTP methods e.g. GET POST PUT DELETE using following exemplary URL scheme 

In some implementations metadata of an application object can be retrieved using the REST adapter . The metadata REST call can be mapped to the metadata access of the application object framework runtime interface. Metadata of an application object can be mapped to the following URL scheme 

In some implementations dynamic and or static properties of an application object can be retrieved using the REST adapter . The dynamic properties of an application can be retrieved for a single instance specifying a key in the URL request before the properties URL path keyword. For multiple instances the URL parameter key can be specified multiple times. The scope for property retrieval can be stated using action URL parameter and node URL parameter. Both parameters can be repeated multiple times. Either actions or nodes can be listed by their name and or a reserved keyword all can be used to retrieve properties for all actions and or for all nodes. Dynamic properties for one or multiple application object instances can be retrieved using the following exemplary URL scheme 

In some implementations Static properties can be retrieved using staticProperties URL path keyword. The scope for property retrieval can be stated using action URL parameter and node URL parameter. Both parameters can be repeated multiple times. Nodes can be listed by their name and or reserved keyword all can be used to retrieve static properties for all nodes. Actions can be listed e.g. as JSON objects using the following . Parameters can be arbitrary objects e.g. arbitrary JSON objects which can be passed into the staticProperty evaluation for the corresponding action. Static properties can be retrieved for an application object using the following exemplary URL scheme 

In some implementations an application object definition can follow a strict schema and can be validated by the schema component . A validateMetadataDefinition function can return a list of error messages if there are schema violations in the provided object definition. If the object definitions are valid the message array is empty. A schema validation can be performed using the following exemplary non limiting code 

In some implementations the current subject matter can provide an application enabled extensibility to business applications. Extensibility of business applications can provide for at least one of the following benefits backend enhancement enhancement to application object logic whereby an application logic can be enhanced at specific predefined extension points providing custom extension fields whereby new extension fields can be defined with a specific type and or a specific label and or various analytics enhancements etc. In some implementations all backend extensions can be based on extension packages where an extension package can extend a base package and all objects having the same name in the extension package as in the base package can be considered to be extended. Application objects can be extended by defining an extension package and or creating a definition in an application object library with the same name. Alternatively custom extension fields can be defined.

An application object can be marked as extensible which can allow for its enhancement. At runtime a lookup can be performed for extensions for extensible application objects. The extensions can be merged to metadata being processed by the AOF system . For error analysis extensions can be switched off.

In some implementations the current subject matter can be implemented in various in memory database systems such as a High Performance Analytic Appliance HANA system as developed by SAP SE Walldorf Germany. Various systems such as enterprise resource planning ERP system supply chain management system SCM system supplier relationship management SRM system customer relationship management CRM system and or others can interact with the in memory system for the purposes of accessing data for example. Other systems and or combinations of systems can be used for implementations of the current subject matter. The following is a discussion of an exemplary in memory system.

The one or more modules software components or the like can be accessible to local users of the computing system as well as to remote users accessing the computing system from one or more client machines over a network connection . One or more user interface screens produced by the one or more first modules can be displayed to a user either via a local display or via a display associated with one of the client machines . Data units of the data storage application can be transiently stored in a persistence layer e.g. a page buffer or other type of temporary persistency layer which can write the data in the form of storage pages to one or more storages for example via an input output component . The one or more storages can include one or more physical storage media or devices e.g. hard disk drives persistent flash memory random access memory optical media magnetic media and the like configured for writing data for longer term storage. It should be noted that the storage and the input output component can be included in the computing system despite their being shown as external to the computing system in .

Data retained at the longer term storage can be organized in pages each of which has allocated to it a defined amount of storage space. In some implementations the amount of storage space allocated to each page can be constant and fixed. However other implementations in which the amount of storage space allocated to each page can vary are also within the scope of the current subject matter.

In some implementations the data storage application can include or be otherwise in communication with a page manager and or a savepoint manager . The page manager can communicate with a page management module at the persistence layer that can include a free block manager that monitors page status information for example the status of physical pages within the storage and logical pages in the persistence layer and optionally in the page buffer . The savepoint manager can communicate with a savepoint coordinator at the persistence layer to handle savepoints which are used to create a consistent persistent state of the database for restart after a possible crash.

In some implementations of a data storage application the page management module of the persistence layer can implement a shadow paging. The free block manager within the page management module can maintain the status of physical pages. The page buffer can include a fixed page status buffer that operates as discussed herein. A converter component which can be part of or in communication with the page management module can be responsible for mapping between logical and physical pages written to the storage . The converter can maintain the current mapping of logical pages to the corresponding physical pages in a converter table . The converter can maintain a current mapping of logical pages to the corresponding physical pages in one or more converter tables . When a logical page is read from storage the storage page to be loaded can be looked up from the one or more converter tables using the converter . When a logical page is written to storage the first time after a savepoint a new free physical page is assigned to the logical page. The free block manager marks the new physical page as used and the new mapping is stored in the one or more converter tables .

The persistence layer can ensure that changes made in the data storage application are durable and that the data storage application can be restored to a most recent committed state after a restart. Writing data to the storage need not be synchronized with the end of the writing transaction. As such uncommitted changes can be written to disk and committed changes may not yet be written to disk when a writing transaction is finished. After a system crash changes made by transactions that were not finished can be rolled back. Changes occurring by already committed transactions should not be lost in this process. A logger component can also be included to store the changes made to the data of the data storage application in a linear log. The logger component can be used during recovery to replay operations since a last savepoint to ensure that all operations are applied to the data and that transactions with a logged commit record are committed before rolling back still open transactions at the end of a recovery process.

With some data storage applications writing data to a disk is not necessarily synchronized with the end of the writing transaction. Situations can occur in which uncommitted changes are written to disk and while at the same time committed changes are not yet written to disk when the writing transaction is finished. After a system crash changes made by transactions that were not finished must be rolled back and changes by committed transaction must not be lost.

To ensure that committed changes are not lost redo log information can be written by the logger component whenever a change is made. This information can be written to disk at latest when the transaction ends. The log entries can be persisted in separate log volumes while normal data is written to data volumes. With a redo log committed changes can be restored even if the corresponding data pages were not written to disk. For undoing uncommitted changes the persistence layer can use a combination of undo log entries from one or more logs and shadow paging.

The persistence interface can handle read and write requests of stores e.g. in memory stores etc. . The persistence interface can also provide write methods for writing data both with logging and without logging. If the logged write operations are used the persistence interface invokes the logger . In addition the logger provides an interface that allows stores e.g. in memory stores etc. to directly add log entries into a log queue. The logger interface also provides methods to request that log entries in the in memory log queue are flushed to disk.

Log entries contain a log sequence number the type of the log entry and the identifier of the transaction. Depending on the operation type additional information is logged by the logger . For an entry of type update for example this would be the identification of the affected record and the after image of the modified data.

When the data application is restarted the log entries need to be processed. To speed up this process the redo log is not always processed from the beginning Instead as stated above savepoints can be periodically performed that write all changes to disk that were made e.g. in memory etc. since the last savepoint. When starting up the system only the logs created after the last savepoint need to be processed. After the next backup operation the old log entries before the savepoint position can be removed.

When the logger is invoked for writing log entries it does not immediately write to disk. Instead it can put the log entries into a log queue in memory. The entries in the log queue can be written to disk at the latest when the corresponding transaction is finished committed or aborted . To guarantee that the committed changes are not lost the commit operation is not successfully finished before the corresponding log entries are flushed to disk. Writing log queue entries to disk can also be triggered by other events for example when log queue pages are full or when a savepoint is performed.

With the current subject matter the logger can write a database log or simply referred to herein as a log sequentially into a memory buffer in natural order e.g. sequential order etc. . If several physical hard disks storage devices are used to store log data several log partitions can be defined. Thereafter the logger which as stated above acts to generate and organize log data can load balance writing to log buffers over all available log partitions. In some cases the load balancing is according to a round robin distributions scheme in which various writing operations are directed to log buffers in a sequential and continuous manner. With this arrangement log buffers written to a single log segment of a particular partition of a multi partition log are not consecutive. However the log buffers can be reordered from log segments of all partitions during recovery to the proper order.

As stated above the data storage application can use shadow paging so that the savepoint manager can write a transactionally consistent savepoint. With such an arrangement a data backup comprises a copy of all data pages contained in a particular savepoint which was done as the first step of the data backup process. The current subject matter can be also applied to other types of data page storage.

In some implementations the current subject matter can be configured to be implemented in a system as shown in . The system can include a processor a memory a storage device and an input output device . Each of the components and can be interconnected using a system bus . The processor can be configured to process instructions for execution within the system . In some implementations the processor can be a single threaded processor. In alternate implementations the processor can be a multi threaded processor. The processor can be further configured to process instructions stored in the memory or on the storage device including receiving or sending information through the input output device . The memory can store information within the system . In some implementations the memory can be a computer readable medium. In alternate implementations the memory can be a volatile memory unit. In yet some implementations the memory can be a non volatile memory unit. The storage device can be capable of providing mass storage for the system . In some implementations the storage device can be a computer readable medium. In alternate implementations the storage device can be a floppy disk device a hard disk device an optical disk device a tape device non volatile solid state memory or any other type of storage device. The input output device can be configured to provide input output operations for the system . In some implementations the input output device can include a keyboard and or pointing device. In alternate implementations the input output device can include a display unit for displaying graphical user interfaces.

In some implementations the current subject matter can include one or more of the following optional features. The application object can include at least one persistent application object and at least one operation. The operations can include at least one of the following a create operation a read operation an update operation a delete operation a custom action operation an existence of action check operation and an operation on at least one property of the requested application object.

In some implementations the method can store results of the execution of the requested application object in a database communicatively coupled to the application object framework. The database can store an updated metadata for the requested application object based on the execution of the requested application object.

In some implementations the requested application object can be characterized by at least one of the following an object definition a definition of an application object node a definition of an application object root node a definition of an application object node attribute a definition of an application object action and a definition of an application object authorization. The requested application object can be also characterized by at least one static property and at least one dynamic property. The request application object can further include at least one extension providing extensibility to the software application.

The systems and methods disclosed herein can be embodied in various forms including for example a data processor such as a computer that also includes a database digital electronic circuitry firmware software or in combinations of them. Moreover the above noted features and other aspects and principles of the present disclosed implementations can be implemented in various environments. Such environments and related applications can be specially constructed for performing the various processes and operations according to the disclosed implementations or they can include a general purpose computer or computing platform selectively activated or reconfigured by code to provide the necessary functionality. The processes disclosed herein are not inherently related to any particular computer network architecture environment or other apparatus and can be implemented by a suitable combination of hardware software and or firmware. For example various general purpose machines can be used with programs written in accordance with teachings of the disclosed implementations or it can be more convenient to construct a specialized apparatus or system to perform the required methods and techniques.

The systems and methods disclosed herein can be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

Although ordinal numbers such as first second and the like can in some situations relate to an order as used in this document ordinal numbers do not necessarily imply an order. For example ordinal numbers can be merely used to distinguish one item from another. For example to distinguish a first event from a second event but need not imply any chronological ordering or a fixed reference system such that a first event in one paragraph of the description can be different from a first event in another paragraph of the description .

The foregoing description is intended to illustrate but not to limit the scope of the invention which is defined by the scope of the appended claims. Other implementations are within the scope of the following claims.

These computer programs which can also be referred to programs software software applications applications components or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the term machine readable medium refers to any computer program product apparatus and or device such as for example magnetic discs optical disks memory and Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor. The machine readable medium can store such machine instructions non transitorily such as for example as would a non transient solid state memory or a magnetic hard drive or any equivalent storage medium. The machine readable medium can alternatively or additionally store such machine instructions in a transient manner such as for example as would a processor cache or other random access memory associated with one or more physical processor cores.

To provide for interaction with a user the subject matter described herein can be implemented on a computer having a display device such as for example a cathode ray tube CRT or a liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device such as for example a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example feedback provided to the user can be any form of sensory feedback such as for example visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including but not limited to acoustic speech or tactile input.

The subject matter described herein can be implemented in a computing system that includes a back end component such as for example one or more data servers or that includes a middleware component such as for example one or more application servers or that includes a front end component such as for example one or more client computers having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described herein or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication such as for example a communication network. Examples of communication networks include but are not limited to a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally but not exclusively remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

The implementations set forth in the foregoing description do not represent all implementations consistent with the subject matter described herein. Instead they are merely some examples consistent with aspects related to the described subject matter. Although a few variations have been described in detail above other modifications or additions are possible. In particular further features and or variations can be provided in addition to those set forth herein. For example the implementations described above can be directed to various combinations and sub combinations of the disclosed features and or combinations and sub combinations of several further features disclosed above. In addition the logic flows depicted in the accompanying figures and or described herein do not necessarily require the particular order shown or sequential order to achieve desirable results. Other implementations can be within the scope of the following claims.

