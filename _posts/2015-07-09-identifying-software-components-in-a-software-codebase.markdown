---

title: Identifying software components in a software codebase
abstract: Systems, methods, and computer program embodiments are disclosed for detecting third party software components in a software codebase. In an embodiment, a source file containing source code may be received at a server, and a code signature may be generated for the source file based on a determined structure of the source code. The generated code signature may then be compared to signatures stored in a reference database to identify matching third party software files. In an embodiment, the reference database may store a plurality of code signatures corresponding to third party software files. A list of the identified third party software files may be created and presented to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471285&OS=09471285&RS=09471285
owner: SYNOPSYS, INC.
number: 09471285
owner_city: Mountain View
owner_country: US
publication_date: 20150709
---
Embodiments of the systems and methods described herein are generally related to software and source code analysis.

Developers often incorporate third party software into software applications and codebases to add desired functionality reducing the burden to develop particular functionality internally. For example the growing number of quality open source software products have significantly reduced software development time at minimal cost. However individuals and organizations making use of third party software must manage quality and security vulnerabilities of the software as well as ensure compliance with license obligations associated with the software failure of which may lead to serious financial and legal repercussions.

As the size of a software codebase grows managing incorporated third party software components becomes increasingly complicated. For example third party software may be part of or used by multiple software files within a codebase by virtue of insertion into multiple software components file duplication and copy and paste of code segments. Further third party code may be modified or adapted for various uses potentially interspersing third party code with internally written code. Manual tracking of third party software is insufficient for this purpose and a robust automated solution is needed to ensure software security and compliance with license obligations.

Systems methods and computer program embodiments are disclosed for detecting third party software components in a software codebase. In an embodiment a source file containing source code may be received at a server and a code signature may be generated for the source file based on a determined structure of the source code. The generated code signature may then be compared to signatures stored in a reference database to identify matching third party software files. In an embodiment the reference database may store a plurality of code signatures corresponding to third party software files. A list of the identified third party software files may be created and presented to a user.

In an embodiment the code signature for the source file may be generated by first determining a programming language of the source file. A list of language reserved keywords and key phrases associated with the programming language may then be identified. Text that does not match a language reserved keyword or key phrase as well as language specific control characters and control character sequences may be removed from the source file. Each remaining keyword and key phrase may then be replaced with a corresponding compact byte representation to produce an encoded sequence. The encoded sequence may be hashed to produce a code signature.

Further embodiments features and advantages of the invention as well as the structure and operation of the various embodiments are described in detail below with reference to accompanying drawings.

The drawing in which an element first appears is typically indicated by the leftmost digit or digits in the corresponding reference number. In the drawings like reference numbers may indicate identical or functionally similar elements.

In the detailed description that follows references to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

Current solutions to automate the detection of third party software components within a software codebase suffer from limitations that do not address modifications to third party files and or require significant processing power and time. One common method for this detection relies on information embedded within headers of third party software files. For example open source software files typically include comments or informational lines at the beginning of the file that indicate information such as but not limited to copyright and licensing information file name open source project name authorship and version information. This method requires this information to be present within each third party software file and may not be able to detect the presence of third party software components when either headers are missing from third party files or code segments from third party files are incorporated into another file.

Another common solution relies on metadata associated with third party software files such as but not limited to file names and file paths. A developer may change file names and locations of files to adapt for use in a software codebase for example when file naming and folder hierarchy requirements are set. This method is inaccurate in these cases and further is unable to detect the presence of third party code segments within another source file.

An alternate approach to detection of third party software components within a software codebase relies on comparison of code samples from the software codebase to source code of third party software files. This method allows for third party code segments within the software codebase to be identified but may require significant processing time and power depending on the number of code samples being compared and the uniqueness of each code sample. This method may also be inaccurate when aspects of the third party software code are changed such as but not limited to variable class and function names. An approach for detection of third party software components within a software codebase is described below that addresses the previously described issues.

In an embodiment software indexer may crawl one or more third party sources in order to discover and retrieve third party software files. For example third party may be a website hosting an open source software project. In this case software indexer may retrieve a plurality of open source software files from third party source . In an embodiment a list of known third party sources such as third party source may be maintained by server . Software indexer may periodically or on demand browse each known third party source in order to retrieve new and updated third party software files.

Once the plurality of third party software files are retrieved software indexer may analyze each file to extract and derive identifying file attributes and information. In an embodiment this information may include but is not limited to authorship information license information and obligations copyright information code quality attributes encryption scheme file path and file origin. Signature generator may generate a code signature for each of the third party software files as will be discussed in further detail below.

In an embodiment updater may write the generated code signature as well as the identifying attributes and information to a reference database . This enables known third party software files to be identified based on a corresponding code signature and identifying attributes. As illustrated in reference database may store the data in a plurality of different data tables A B . . . . To improve performance of database queries and updates database may also include an index table . In an embodiment updater may query index table to assist with data insertions and updates and query manager may query index table to assist with data retrieval. In an embodiment the index table may point to entries in data tables which include the complete individual location points. Or in an embodiment where the database is de normalized the index table may itself include the individual location points in part or in full. In this way index table may be used to improve performance of database queries and updates.

In an embodiment a request may be received by server from client to determine third party software components present in a software codebase. For example an individual or company may be concerned about legal issues and potential security vulnerabilities associated with using third party code e.g. open source or commercially purchased software packages within a developed application codebase. The request may include a plurality of source files containing source code or references to a plurality of source files to analyze. If references to source files are received analyzer may retrieve the actual source files based on the received reference information.

For each received source file signature generator may generate a code signature for the source file based on the structure and content of the source code contained within the source file. In an embodiment signature generator may first determine a programming language of the source file. In an embodiment the programming language may be detected based on the file extension. For example the file extension py may indicate the Python programming language. In an embodiment the programming language may also be determined through analysis of the file content. For example aspects of the code structure such as language specific reserved keywords text sequences or indentation may be compared to known aspects associated with the programming language.

Once a programming language is identified signature generator may identify a list of language reserved keywords and key phrases associated with the programming language. For example terms such as break and return are language reserved keywords in the C programming language. The list of language reserved keywords and key phrases may be stored and maintained in reference database local database or external to reference database and server .

Signature generator may then remove text from the source file that does not match an identified language reserved keyword or key phrase. Signature generator may also remove language specific control characters and control character sequences from the source file. In an embodiment a list of language specific control characters and control character sequences may similarly be stored and maintained in reference database local database or external to reference database and server . The removal of content from the source file that does not match language reserved keywords or key phrases addresses issues associated with for example variable class and function name changes within the source file as the code signature no longer relies on naming conventions.

At this point signature generator may replace each language reserved keyword and key phrase in the source file with a corresponding compact byte representation to produce an encoded sequence. In an embodiment each language reserved keyword and key phrase may be mapped to a byte representation for example a single ASCII character. These mappings may be predefined and stored for example in reference database or local database or defined dynamically by signature generator . This drastically reduces the size of the encoded sequence for storage and processing. One of skill in the art will appreciate that the corresponding compact byte representations need not be exactly one byte in size but will typically be smaller in size than the corresponding language reserved keywords and key phrases.

In an embodiment signature generator may hash the encoded sequence to produce a code signature for the source file. Any available hash function may be used for this purpose such as but not limited to MD5 SHA1 SHA2 RIPEMD or Whirlpool. Signature generator may generate code signatures for third party software files in the same manner as described for source files of the software codebase.

The generated code signature enables identification of present third party software components regardless of basic modifications made to the contained third party software. For example changes to variable names function names or other syntactic changes to text separate from language reserved keywords and key phrases will not affect the identification of third party software components as these names do not affect the generated code signature. This may be particularly important when an organization makes use of a code compressor or minifier to reduce file sizes within a software portfolio. For example code compressors and minifiers often change variable and function names to shorter character representations in order to reduce file size.

Changes to code structure interspersing of internal code with third party software code and third party auto generated code may be addressed through generation of code signatures for code modules within a source file. A code module may be a portion of the source file determined by the syntax or semantics of the contained source code for example a class function or other logical division of code. In an embodiment analyzer may divide the source code of the source file into one or more code modules. Analyzer may use programming language specific characteristics to determine logical divisions for code modules. In an embodiment the level of granularity of code modules may be adjusted automatically or by a user. For example identification of third party software may be optimized by changing the granularity of code modules to represent methods functions and code blocks of a particular scope or size in contrast to encompassing classes and containers.

Once defined code signature generator may generate code signatures for each of the code modules as described previously. In an embodiment the generated code signatures for each of the code modules may be combined to produce a code signature for the source file. In an embodiment software indexer may similarly divide third party software files into code modules and generate code signatures for each code module.

As described above with respect to third party software files in an embodiment analyzer may parse the source file to determine identifying attributes of the source file such as but not limited to authorship information license information and obligations copyright information code quality attributes encryption scheme file path and file origin. Analyzer may then use the generated code signatures for the source file and or the code modules of the source file as well as identifying attributes to identify third party software components present within the source file.

In an embodiment analyzer may compare the code signature for the source file to code signatures of third party software files stored in reference database . Analyzer may then create a list of identified third party software files corresponding to matching code signatures. In an embodiment the list of identified third party software files may be stored in local database and or sent to client . In order to identify present third party software components according to an embodiment analyzer may also compare one or more of the generated code signatures for the code modules of the source file to code signatures stored in the reference database. This allows for partial matches of software files to be identified. As previously discussed this is particularly useful when changes to the structure of a source file have been made third party code has been interspersed with developed code or code automatically generated by third party software is being used.

In an embodiment local database may store code signatures for matching third party software files. In this manner local database may act as a cache for analyzer and query manager obviating the need to query reference database for each subsequent comparison. When comparing code signatures of a source file analyzer may first compare each code signature to code signatures stored in local database before attempting to query reference database .

The code signatures and partial matching procedures as described above enable identification of third party software components within a source file irrespective of particular changes to the third party software. However this may lead to false identification of third party software in some cases. This issue is addressed in multiple ways. First in an embodiment one or more thresholds may be used by analyzer to determine whether partial matches indicate the presence of a third party software component within a source file. For example if code modules are determined to be very small e.g. two to three lines of code on average matching of a single code module signature to a third party code signature may be coincidental or uninformative. Thresholds may be used to reduce identification of third party software due to low confidence matches and may specify a percentage or other quantitative indication of code signatures for a source file that must match code signatures for a third party software file. For example a percentage threshold of 20 may be set to indicate that 20 of the code module signatures for the source file must match code signatures for a third party software file stored in reference database to be identified as a matching third party software file.

Second in an embodiment the determined identifying attributes and information of the source file and third party software files may be used by analyzer to filter the list of identified third party software files. In an embodiment if inconsistencies are found between specific identifying attributes of the source file and an identified third party software file analyzer may remove the identified third party software file from the list. For example differences in authorship copyright ownership information and license information may indicate a false match when comparing code signatures of entire files and corresponding third party software files may be removed from the list. In an embodiment filtering parameters may be adjusted to ensure accuracy of third party software detection while minimizing false positive identification.

Presenter may present the list of identified third party software file to client . In an embodiment client may be operated by a user for example an individual requesting analysis of software files within a software codebase. In various embodiments the list of identified third party software files may be presented in a graphical user interface such as a web page or web application in a generated report or via an application programming interface API . The list of identified third party files may include additional information such as but not limited to authorship and origin information of each third party file matching code segments or modules and various statistics. The list may be combined with list of third party software files identified for other source files to provide statistics and an overall view of present third party software components within an entire software codebase.

Server may include signature generator software indexer query manager and updater . Software indexer query manager and updater may perform tasks similar to software indexer query manager and updater of respectively. Signature generator may perform tasks similar to signature generator of with respect to signature generation for third party software files.

Server may include signature generator analyzer and presenter . Analyzer and presenter may perform tasks similar to analyzer and presenter of respectively. Signature generator may perform tasks similar to signature generator of with respect to signature generation for source files within a software codebase. Each of the servers and modules in may be implemented on the same or different computing systems having server functionality in hardware software or any combination thereof.

The embodiment illustrated in may represent detection of third party software components within software residing in a home office or enterprise environment. In this case analysis of internal source code may occur within local area network which may be a private network preventing transmission of internal data over a public network. In an embodiment local area network may be part of a larger private wide area network connecting multiple sites of an enterprise. Retrieval and preparation of third party software files for comparison may occur outside of the home office or enterprise environment and transmission between network and local area network may be limited to for example signatures and attributes of known third party software files.

In an embodiment identifying attributes that may be extracted or derived from source file may include but are not limited to authorship information license information and obligations copyright information code quality attributes encryption scheme file path and file origin .

Authorship information may include individuals or organizations contributing to authorship of source file . License information and obligations may include any license information incorporated into the content or metadata of source file . For example source files adhering to open source licenses such as the GNU General Public License GPL or MIT License may have information about and terms of the license incorporated into the source file. In a further example the license name and license terms may be extracted from source file as identifying information.

Copyright information may include any copyright information incorporated into the content or metadata of source file . For example the content of a source file often contains a copyright symbol or the explicit term copyright. Associated text may be extracted as an identifying attribute of source file .

Code quality attributes may include explicit or derived indications of issues within source file . For example source file may contain a comment indicating a limitation or bug within the source code contained in the source file. Code quality attributes may also be derived through analysis of source file for example security vulnerabilities determined through source code analysis. Another example may include analysis of the number of code lines against the number of comment lines in source file to determine the documentation quality of source file . Yet another example may include analysis of variable definitions in relation to variable usage e.g. checking for variable definitions prior to usage to determine potential runtime issues. Code quality attributes may be used for purposes beyond detection of third party software components within a software codebase.

If source file has been encrypted encryption scheme may include identifying encryption information found in the content metadata or through analysis of source file . File path may indicate a location of source file within a directory structure. File origin may include information related to the origin of source file such as but not limited to a network address for example a uniform resource locator URL or Internet Protocol IP address of where source file was retrieved from and the name of a project which source file belongs to for example in the case that source file is part of an open source project.

At stage the generated code signature may be compared to code signatures stored in a reference database such as reference database of to identify matching third party software files. The reference database may store a plurality of code signatures corresponding to known third party software files. In an embodiment third party software files may be retrieved and analyzed by a software indexer such as software indexer of . The software indexer may extract and derive identifying attributes for retrieved third party software files and a signature generator such as signature generator of may generate a code signature for each third party software file. The identifying attributes and code signatures of third party software files may be written to the reference database.

At stage it is determined whether the generated code signature matches any of the code signatures stored in the reference database. If no matches are found the method ends. If one or more matches are found at stage a list may be created of identified third party software files corresponding to matching code signatures in the reference database. In an embodiment stages may be repeated using generated code module signatures for the source file. For example if no matches are found at stage when comparing the code signature for the complete source file to code signatures stored in the reference database stages may be executed for each generated code module signature for the source file. Code module signatures for the source file may be generated as described with respect to . This allows for third party software files to be identified based on partial file matches. At stage the created list of identified third party software files may be presented to a user for example in a graphical user interface a generated report or via an API.

At stage a list of language reserved keywords and key phrases associated with the programming language is identified. For example terms such as break and return are language reserved keywords in the C programming language. In an embodiment the list of language reserved keywords and key phrases may be stored and maintained in a reference database such as reference database of or a local database such as local database of .

At stage text that does not match a language reserved keyword or key phrase of the identified list is removed from the source file. At stage language specific control characters and control character sequences are removed from the source file. The removal of content from the source file that does not match language reserved keywords or key phrases addresses issues associated with for example variable class and function name changes within the source file as the code signature no longer relies on naming conventions.

At stage each language reserved keyword and key phrase of the source file is replaced with a corresponding compact byte representation to produce an encoded sequence. In an embodiment each language reserved keyword and key phrase may be mapped to a byte representation for example a single ASCII character. These mappings may be predefined or defined dynamically. This drastically reduces the size of the encoded sequence for storage and processing. As described previously one of skill in the art will appreciate that the corresponding compact byte representations need not be exactly one byte in size but will typically be smaller in size than the corresponding language reserved keywords and key phrases. Stage may be repeated for individual modules within the source file to create additional code sequences for those individual modules. Individual modules in a source file may be for example classes functions subroutines or blocks of a predetermined number of lines of code as described with respect to . In this manner creation of code sequences for individual modules may then represent code snippets within a source file.

Finally at stage the encoded sequences are hashed to produce code signatures for the source file including in an embodiment code signatures for individual modules of the source file. Any available hash function may be used for this purpose such as but not limited to MD5 SHA1 SHA2 RIPEMD or Whirlpool.

At stage file attributes may then be extracted or derived from the third party software file. These attributes may be used in determining the presence of the third party software file or contained software components within a software codebase. In an embodiment file attributes extracted or derived from the source file may include but are not limited to authorship information copyright ownership information license information license obligations encryption scheme file path and file origin as previously described in further detail.

In an embodiment certain identifying attributes for example license information and license obligations may be extracted or derived from files related to the third party software file. For example license information may be stored in a separate file within a folder hierarchy in which the third party software file resides. In an embodiment the folder hierarchy in which the third party software file resides may be scanned to identify additional files that may contain identifying attributes for the third party software file. These additional files may then be analyzed to extract or derive identifying information.

At stage one or more code signatures may be generated for the third party software file. In an embodiment code signatures may be generated in the same manner as described with respect to . The code signatures may similarly be used to determine the presence of the third party software file or contained software components within a software codebase.

Finally at stage the extracted and derived file attributes and the generated code signatures may be written to a reference database such as reference database of .

Computer system includes one or more processors also called central processing units or CPUs such as a processor . Processor may be connected to a communication infrastructure or bus .

One or more processors may each be a graphics processing unit GPU . In an embodiment a GPU is a processor that is a specialized electronic circuit designed to rapidly process mathematically intensive applications on electronic devices. The GPU may have a highly parallel structure that is efficient for parallel processing of large blocks of data such as mathematically intensive data common to computer graphics applications images and videos.

Computer system also includes user input output device s such as monitors keyboards pointing devices etc. which communicate with communication infrastructure through user input output interface s .

Computer system also includes a main or primary memory such as random access memory RAM . Main memory may include one or more levels of cache. Main memory has stored therein control logic i.e. computer software and or data.

Computer system may also include one or more secondary storage devices or memory . Secondary memory may include for example a hard disk drive and or a removable storage device or drive . Removable storage drive may be a floppy disk drive a magnetic tape drive a compact disk drive an optical storage device tape backup device and or any other storage device drive.

Removable storage drive may interact with a removable storage unit . Removable storage unit includes a computer usable or readable storage device having stored thereon computer software control logic and or data. Removable storage unit may be a floppy disk magnetic tape compact disk DVD optical storage disk and or any other computer data storage device. Removable storage drive reads from and or writes to removable storage unit in a well known manner.

According to an exemplary embodiment secondary memory may include other means instrumentalities or other approaches for allowing computer programs and or other instructions and or data to be accessed by computer system . Such means instrumentalities or other approaches may include for example a removable storage unit and an interface . Examples of the removable storage unit and the interface may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket a memory stick and USB port a memory card and associated memory card slot and or any other removable storage unit and associated interface.

Computer system may further include a communication or network interface . Communication interface enables computer system to communicate and interact with any combination of remote devices remote networks remote entities etc. individually and collectively referenced by reference number . For example communication interface may allow computer system to communicate with remote devices over communications path which may be wired and or wireless and which may include any combination of LANs WANs the Internet etc. Control logic and or data may be transmitted to and from computer system via communication path .

In an embodiment a tangible apparatus or article of manufacture comprising a tangible computer useable or readable medium having control logic software stored thereon is also referred to herein as a computer program product or program storage device. This includes but is not limited to computer system main memory secondary memory and removable storage units and as well as tangible articles of manufacture embodying any combination of the foregoing. Such control logic when executed by one or more data processing devices such as computer system causes such data processing devices to operate as described herein.

Based on the teachings contained in this disclosure it will be apparent to persons skilled in the relevant art s how to make and use the inventions using data processing devices computer systems and or computer architectures other than that shown in . In particular embodiments may operate with software hardware and or operating system implementations other than those described herein.

Identifiers such as a b i ii etc. are sometimes used for different elements or steps. These identifiers are used for clarity and do not necessarily designate an order for the elements or steps.

Embodiments of the present inventions have been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of specific embodiments will so fully reveal the general nature of the inventions that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present inventions. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of the present inventions should not be limited by any of the above described embodiments but should be defined only in accordance with the following claims and their equivalents.

