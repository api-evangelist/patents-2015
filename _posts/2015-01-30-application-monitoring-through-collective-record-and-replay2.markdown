---

title: Application monitoring through collective record and replay
abstract: Methods and systems for application monitoring through collective record and replay are disclosed herein. The method includes recording a number of execution traces for an application from a number of user devices at a runtime library, wherein the number of execution traces relates to non-deterministic data. The method also includes replaying the number of execution traces to determine whether a behavior of the application creates a security risk.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619654&OS=09619654&RS=09619654
owner: Microsoft Technology Licensing, LLC
number: 09619654
owner_city: Redmond
owner_country: US
publication_date: 20150130
---
This application is a continuation of co pending U.S. patent application Ser. No. 13 325 062 filed Dec. 14 2011 which is entitled Application Monitoring Through Collective Record and Replay the application of which is incorporated herein by this reference as though fully set forth herein.

Many multi user operating systems associate privileges with user accounts. When a user installs an application the application runs in the name of the user and inherits the user s ability to access the system resources. However modern browsers and device operating systems such as smartphone operating systems often treat applications as mutually untrusting potentially malicious principals. In most cases applications are isolated except for explicit inter process or inter application communication IPC channels. In addition applications can be unprivileged by default requiring user permission for additional privileges. In other words permission to use devices and access user private data through system application programming interfaces APIs may be granted to individual applications by the user.

However modern permission systems may be undermined by the presence of malicious software within applications. Such malicious software may compromise users privacy or violate platform providers security policies. Current approaches focus on preventing malicious applications from reaching end users through manual review of each application that is added to the marketplace. However this process is costly and time consuming. Moreover although approaches exist for monitoring applications in the wild such as event logging and crash reports or online taint flow analysis these methods are limited by either the small quantity of data collected or the high performance overhead on the end user.

The following presents a simplified summary of the innovation in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key nor critical elements of the claimed subject matter nor delineate the scope of the subject innovation. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.

An embodiment provides a method for application monitoring through collective record and replay. The method includes recording a number of execution traces for an application from a number of user devices at a runtime library wherein the number of execution traces relates to non deterministic data. The method also includes replaying the number of execution traces to determine whether a behavior of the application creates a security risk.

Another embodiment provides a system for application monitoring through collective record and replay. The system includes an application configured to send a number of execution traces to a central server s from a number of user devices wherein the number of execution traces relates to non deterministic data. The system also includes a runtime library configured to redirect the number of execution traces from the API to the runtime library record the number of execution traces on a memory device and replay the number of execution traces to determine whether the application is functioning as expected.

In addition another embodiment provides one or more non transitory computer readable storage media for storing computer readable instructions the computer readable instructions providing a collective record and replay system when executed by one or more processing devices. The computer readable instructions comprising code configured to perform probabilistic logging for an application to record a number of execution traces relating to non deterministic data from a number of user devices. The computer readable instructions also include code configured to determine whether the application is utilizing the number of non deterministic data for an unexpected purpose by replaying the number of executions traces.

This Summary is provided to introduce a selection of concepts in a simplified form these concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The same numbers are used throughout the disclosure and figures to reference like components and features. Numbers in the 100 series refer to features originally found in numbers in the 200 series refer to features originally found in numbers in the 300 series refer to features originally found in and so on.

As discussed above many modern applications include malicious software that violates the privacy of users and the security policies of platform providers. Such malicious software may gain access to users private data through several different mechanisms. In some instances a developer of an application may intentionally exploit user private data for unauthorized or illegal purposes. In other instances an application may unintentionally expose user private data to potentially malicious applications or third parties. In various embodiments user private data may be considered to be any data that is non deterministic or variable. The protection of such non deterministic data from malicious applications may ensure that users privacy rights are not violated.

Embodiments disclosed herein set forth a method and system for application monitoring through collective record and replay. The applications may include for example smartphone applications implemented on a mobile phone or Web applications implemented on a Web site among others. Moreover the applications may also include any types of computer programs which execute code that is related to any form of non deterministic data. Such a method and system may prevent applications from performing actions that are not desired by the user particularly in relation to non deterministic data.

To implement the collective record and replay procedure a number of execution traces for a particular application may be collectively recorded at a centralized location referred to herein as a runtime library from a number of different user devices. As used herein an execution trace is a sequence of application programming interface API calls and non deterministic data related to the API calls made by an application. Moreover the execution traces may be recorded from a number of different user devices based on an assigned probability. The assigned probability may dictate the number of execution traces which are recorded from each user device and thus may determine the performance overhead of the collective recording procedure. When a partial execution trace is recorded the assigned probability may also be used to decide whether to record the non deterministic data related to a given API call. The assigned probability can be either API independent i.e. all APIs have the same record not record probability or API dependent i.e. every API has its own record not record probability .

In various embodiments the data recorded may include both the parameters passed to the API and the data returned from the API. Furthermore partial execution traces may be probabilistically recorded in order to reduce the overhead cost. Once the execution traces have been recorded they may be aggregated replayed and analyzed in order to determine whether the particular application is likely to be using the non deterministic data for malicious purposes. Moreover if it is determined that the application is likely to be malicious the application may be blocked from the marketplace or removed from the user devices or both.

As a preliminary matter some of the figures describe concepts in the context of one or more structural components variously referred to as functionality modules features elements etc. The various components shown in the figures can be implemented in any manner for example by software hardware e.g. discreet logic components etc. firmware and so on or any combination of these implementations. In one embodiment the various components may reflect the use of corresponding components in an actual implementation. In other embodiments any single component illustrated in the figures may be implemented by a number of actual components. The depiction of any two or more separate components in the figures may reflect different functions performed by a single actual component. discussed below provides details regarding one system that may be used to implement the functions shown in the figures.

Other figures describe the concepts in flowchart form. In this form certain operations are described as constituting distinct blocks performed in a certain order. Such implementations are exemplary and non limiting. Certain blocks described herein can be grouped together and performed in a single operation certain blocks can be broken apart into plural component blocks and certain blocks can be performed in an order that differs from that which is illustrated herein including a parallel manner of performing the blocks. The blocks shown in the flowcharts can be implemented by software hardware firmware manual processing and the like or any combination of these implementations. As used herein hardware may include computer systems discreet logic components such as application specific integrated circuits ASICs and the like as well as any combinations thereof.

As to terminology the phrase configured to encompasses any way that any kind of functionality can be constructed to perform an identified operation. The functionality can be configured to perform an operation using for instance software hardware firmware and the like or any combinations thereof.

The term logic encompasses any functionality for performing a task. For instance each operation illustrated in the flowcharts corresponds to logic for performing that operation. An operation can be performed using for instance software hardware firmware etc. or any combinations thereof.

As utilized herein terms component system client and the like are intended to refer to a computer related entity either hardware software e.g. in execution and or firmware or a combination thereof. For example a component can be a process running on a processor an object an executable a program a function a library a subroutine and or a computer or a combination of software and hardware.

By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and or distributed between two or more computers. The term processor is generally understood to refer to a hardware component such as a processing unit of a computer system.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any non transitory computer readable device or media.

Computer readable storage media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk and magnetic strips among others optical disks e.g. compact disk CD and digital versatile disk DVD among others smart cards and flash memory devices e.g. card stick and key drive among others . In contrast computer readable media generally i.e. not storage media may additionally include communication media such as transmission media for wireless signals and the like.

The system may include a storage device adapted to store a collective record and replay module and a runtime library . The collective record and replay module can be used to monitor applications by logging execution traces from multiple user devices while the runtime library can store the execution traces relating to the applications. In some embodiments the runtime library may include a record runtime library and a replay runtime library. The storage device may include a hard drive an optical drive a thumbdrive an array of drives or any combinations thereof. Moreover the storage device may also be adapted to store an API and any number of applications . The applications may communicate with each other through the API .

A human machine interface HMI may connect the system to any number of user interface devices such as a touchscreen a speaker or a pointing device among others. The system may be linked through the bus to a display interface adapted to connect the system to a display device . The display device may include a computer monitor or a display screen of a mobile device among others.

A network interface controller NIC may be included to connect the system through the bus to a network . Through the network Web based applications may be downloaded and stored within the computer s storage device or may be accessed through a Web browser. The Web based applications may be stored on a remote server or computing device. The system may also be communicably coupled to multiple user devices not shown through the network . Moreover the system may download and record logs relating to API calls from the multiple user devices through the network . Further the system may be a server or other computing device configured to provide a centralized location for the recording and replaying of a number of execution traces for an application from a number of user devices. The number of execution traces may be sequences of API calls and non deterministic data related to the API calls made by an application. In various embodiments partial execution traces may be recorded instead of full execution traces in order to reduce the overhead. Moreover data relating to a particular execution trace may be recorded including both parameters passed to the API and data returned from the API.

In various embodiments full execution traces may not be recorded but rather partial execution traces may be probabilistically recorded. For example the probability of recording an execution trace may be a fixed value for all API calls or may be an API independent variable. Moreover the recorded data may include data relating to a particular API call such as parameters passed to the API and data returned from the API.

The recording of the number of execution traces from the number of user devices within the runtime library may be performed at any level of the application stack i.e. at any interface. The interface may be chosen in order to minimize the recording overhead on the client wherein the recording overhead may be characterized by the amount of time space and energy consumed by the recording process. For example in some embodiments the recording of the execution traces or the interposing on the events executed by a particular application may be performed at the level of the native platform libraries. However the method is not limited to the interposing on events at the level of the native libraries but rather may be implemented at any interface level.

Recording the number of execution traces from the number of user devices may include sending some number of execution traces from each of the number of user devices to the runtime library. The runtime library may be configured to record the execution traces within a memory device wherein the memory device may be located within the runtime library or may be communicably coupled to the runtime library such as through a wireless or wired connection. For example the memory device may include the storage device or memory device of the system discussed with respect to . Moreover the runtime library may be connected to the user devices through a network such as for example a wide area network WAN or a local area network LAN .

Furthermore in some embodiments the runtime library may be replaced with two separate runtime libraries including a record runtime library and a replay runtime library. The record runtime library or log transferring module may run on each user device in conjunction with the application. In various embodiments the record runtime library may be used to record one or more execution traces of an application on a particular user device. Based on configurations the record runtime library may either immediately send the recorded execution traces to a central server or wait until the user device is connected to a power supply or a non cellular network for example to send the recorded execution traces. In various embodiments the replay runtime library may run on the central server. For each potentially incomplete execution trace the replay runtime library may attempt to utilize the recorded API data first if it is available in the execution trace. Otherwise the replay runtime library may leverage the recorded data from the same API from other execution traces in order to reproduce the full execution trace from the partially recorded execution trace.

The runtime library may record the number of execution traces from the number of user devices by redirecting a number of application API calls from an API to the runtime library wherein the API may include a native library or any other type of application programming interface. The API may be the module that is normally responsible for recording and executing API calls from applications. Once the runtime library has received and recorded the redirected API calls the API calls may be sent back to the user devices to be executed as normal. A network may be configured to communicably couple the runtime library the application the API and the memory device or any combinations thereof. Furthermore the application and the API may be physically colocated within a user device while the memory device and the runtime library may be physically colocated within a centralized server.

In various embodiments the runtime library may probabilistically log or record the number of execution traces for a given event from the number of user devices wherein the given event may include a specific function of an application. Moreover the probabilistic logging of the number of execution traces may include determining a probability that a particular execution trace relating to a particular application will be recorded from an individual user device. Thus the performance overhead for the method may be shared between multiple user devices in order to decrease the burden on the users. In some embodiments the lower the probability that a particular execution trace may be recorded from an individual user device the lower the burden on the user. Moreover a lower probability of recording a particular event or execution trace from a particular user device may correspond to a lower total number of recorded execution traces from the user devices.

Further a variety of additional information relating to the API calls from the number of user devices may be recorded by the runtime library. For example information about where in the application or program a particular API call originated may be stored by the runtime library in order to enable the replaying of the execution traces within the API call at block . A number of methods for recording such information may be employed including for example tracking the application s execution history precisely using a path profiling algorithm or computing a hash of the call stack at the time when the function was invoked. Moreover a timestamp relative to the start of the application may be recorded in order to track additional information pertaining to a particular API call.

In some embodiments the recording of asynchronous events may be accomplished by intercepting the API through which the particular application registers the callback function. This is possible because a callback registration may be used to deliver such asynchronous events. The runtime library may then replace the reference to the callback function with a reference to a recording function in the runtime library. This ensures that when the callback is invoked from the library code the runtime library will be notified and may record the information relating to the particular callback.

At block the number of execution traces may be replayed to determine whether a behavior of the application is malicious. The runtime library may obtain the recorded execution traces by reading the execution traces from the memory device. The runtime library may then replay the number of execution traces by recombining each of the number of execution traces recorded from each of the number of user devices in order to generate a replay of an event relating to the application. The replaying of the execution traces may be performed in a manner that maintains the original ordering and latency of API calls within each execution trace. One execution trace may be replayed at a time. When there is an API call in the execution for which there is no recorded data recorded data of the same API from other execution traces may be combined to generate the data for the replay procedure. This may be repeated for each execution trace in the set of execution traces reported to the central server. Moreover in some embodiments replaying the number of execution traces may include executing an API call using the number of execution traces recorded by the runtime library and utilizing a result of the API call to analyze the behavior of the application.

Once the number of execution traces have been recombined and replayed the recombined execution traces may be analyzed in order to determine whether the behavior of the application is malicious. The behavior of the application may be considered to be malicious if the application utilizes any non deterministic data in an unauthorized manner or for an unexpected purpose wherein the unexpected purpose may include any function that is not approved or authorized by a user or a service provider or both. For example a malicious application may share the non deterministic data with an unapproved third party in an unauthorized manner.

The method is not intended to indicate that the steps of the method are to be executed in any particular order or that all of the steps are to be included in every case. Further steps may be added to the method according to the specific application. For example once the execution traces have been replayed at block the recombined execution traces may be sent to a separate device through a network to be analyzed. For example the separate device may analyze the recombined execution traces using a specific program that is configured to determine the behavior of the application. The separate device may be utilized by the particular service provider for each type of user device. Moreover a particular service provider may determine whether to remove a particular application from the user devices or block the particular application from the marketplace based on the information obtained from the recombined execution traces.

A runtime library may be configured to redirect the API calls from the native library to the runtime library as indicated by the arrow . The runtime library may be a module that is configured to implement the collective record and replay method described with respect to . The runtime library may store the number of execution traces within a memory device as indicated by the arrow . The memory device may include random access memory RAM read only memory ROM or flash memory among others. For example the memory device may include the storage device or memory device of the system discussed with respect to .

The runtime library may also communicate directly with the native library . In some embodiments the runtime library may send the API calls to the native library as indicated by the arrow in order to enable normal execution of the API calls. Moreover the native library may send the result of each API call back to the runtime library as indicated by the arrow . The runtime library may then inform the application of the result of each of the API calls from each of the user devices as indicated by the arrow . In addition the runtime library may record the result of each API call within the memory device .

The native library may be colocated within a particular user device while the runtime library may be located within a server or other device that is wirelessly connected to the native library through a network connection. Moreover the runtime library may be connected to multiple distinct native libraries located on multiple user devices wherein the multiple user devices are configured to execute the functions of the application . In this case the recording of the execution traces may be performed according to several different methods depending on the settings and capabilities of each user device. For example if a user device has continuous unlimited access to the Internet the native library within the user device may transmit the log of an execution immediately after the program execution ends. On the other hand if a user device has expensive or bandwidth limited access to the Internet logs from API calls may be stored and transmitted in a batch when a less expensive connection becomes available.

The runtime library can select one of the recorded inputs it has available for the particular API call at that program point and directly fill in the output data from the log i.e. from the memory device . However this selection process may have some degree of imprecision since the recorded inputs stored within the memory device may not be precise. In addition due to the probabilistic nature of the recording process described with respect to it is possible that multiple recorded events may be appropriate for a particular API call or that no recorded events may be available for a particular API call.

If no recorded events are available for a particular API call an input may be synthesized using random or crafted data an appropriate input may be derived using a technology such as symbolic execution or the API call may be stalled until an appropriate event is recorded by some client. Moreover in order to replay asynchronous events the runtime library may call corresponding callbacks from the memory device with recorded input parameters at certain times. The callback time may be dictated by the original ordering and latency of the API calls within the execution trace. Further once the runtime library has retrieved the recorded input information including the recombined execution traces normal execution of the API call event may continue at the application on the number of user devices as indicated by the arrow .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

