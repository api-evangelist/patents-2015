---

title: Dynamic code injection
abstract: Embodiments of the present invention disclose an approach for inserting code into a running thread of execution. A computer sets a first set of bits to a first value, wherein the first value indicates that a first set of instructions should be inserted onto a stack. The computer executes a second set of instructions associated with a first safepoint, wherein the second set of instructions comprises one or more instructions to determine if the first set of bits is set to the first value. The computer determines that the first set of bits is set to the first value, and the computer inserts the first set of instructions onto the stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471343&OS=09471343&RS=09471343
owner: International Business Machines Corporation
number: 09471343
owner_city: Armonk
owner_country: US
publication_date: 20150831
---
Various aspects of the present invention have been disclosed by an inventor or a joint inventor in the product IBM Software Development Kit Java Technology Edition Version 8 Beta Program made publically available on Apr. 25 2013. This disclosure is submitted under 35 U.S.C. 102 b 1 A . The following document is provided in support 

The present invention relates generally to the field of multitenant computing and more particularly to injecting code into running threads of execution.

In multitenant computing environments multiple client computers run tenant applications in a single instance of a virtual machine such as the Java Virtual Machine JVM . For clients executing applications based in the Java programming language the single virtual machine instance is the JVM which executes on a server computer and provides a virtual computing environment that accesses the physical resources of the server computer while maintaining isolation among the tenant applications and information that they access. The JVM executes Java bytecode using threads. Threads contain a program counter and a stack. The program counter keeps track of where the JVM is executing instructions e.g. the memory location currently being used and the number of instructions that have been executed on the thread. The stack is a last in first out LIFO data structure that contains frames which include the bytecode detailing instructions to be performed by the server computer physical resources.

During execution of the thread the thread can be at a safepoint or not at a safepoint. When at a safepoint the thread s representation of the JVM is well described and can be safely manipulated and seen by other threads in the JVM. When the thread reaches a safepoint the thread may be safely blocked for a period of time in order to perform actions that affect all threads such as garbage collection. During compilation of Java bytecode into compiled code the compiler can determine that a safepoint exists at a certain place in the code and insert additional instructions that instruct the thread executing the compiled code to perform certain functions outside of the compiled application code.

Embodiments of the present invention disclose a method computer program product and system for inserting code into a running thread of execution. A computer sets a first set of bits to a first value wherein the first value indicates that a first set of instructions should be inserted onto a stack. The computer executes a second set of instructions associated with a first safepoint wherein the second set of instructions comprises one or more instructions to determine if the first set of bits is set to the first value. The computer determines that the first set of bits is set to the first value and the computer inserts the first set of instructions onto the stack.

Embodiments of the present invention recognize that in virtualized multitenant environments certain operations may need to be performed that affect all threads and not just the thread s of a single tenant application. For example in the Java Virtual Machine JVM resource management may include allocating access to memory or CPU resources across tenant applications in order to ensure that one tenant does not dominate CPU capacity while other tenant applications lack necessary CPU capabilities. Embodiments of the present invention disclose injecting code into a running thread to achieve a desired behavior. Various embodiments may be useful for among other applications computing resource allocation statistics gathering determining stack depth and or controlling the lifetime of particular threads.

The present invention will now be described in detail with reference to the Figures. is a functional block diagram illustrating a multitenant computing environment environment generally designated in accordance with an embodiment of the present invention.

Environment includes server computer and client computers and all interconnected over network . Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and can include wired wireless or fiber optic connections. In general network can be any combination of connections and protocols that will support communications between server computer and client computers and .

In various embodiments of the present invention client computers and as well as server computer can be servers laptop computers tablet computers netbook computers personal computers PCs desktop computers personal digital assistants PDAs smart phones or any programmable electronic devices capable of communicating over network . In another embodiment server computer and client computers and represent a computing system utilizing clustered computers and components to act as a single pool of seamless resources when accessed by elements of environment . In general server computer can be any computing device or combination of devices with access to thread code injection module masking module resource allocation module and CPU allocation accumulator and capable of running code injection module masking module and resource allocation module . Server computer may include internal and external hardware components as depicted and described in further detail with respect to .

Server computer includes server operating system hardware resources and JVM . In some embodiments server operating system is the native operating system of server computer . In various embodiments server operating system includes an application programming interface API which allows JVM to access and allocate hardware resources such as CPU and physical memory for use by tenant applications and . In various embodiments CPU and physical memory are shared physical resources that tenant applications and can access by interacting with JVM . In some embodiments server operating system can run programs such as application services or daemons which apply to all tenant applications running in JVM .

JVM is a managed runtime environment that executes computer instructions written in Java bytecode by interpreting and or compiling the instructions into machine code that hardware resources can interpret. JVM performs just in time JIT compilation on a Java based programing language. This process converts the Java based source code into object code that CPU can interpret to perform various computer functions such as arithmetic read and write functions. Additionally JVM manages one or more threads of execution associated with tenant applications and such as threads and .

JVM includes tenant applications and . Tenant application is associated with a single client computer such as client computer and tenant application is associated with a different client computer such as client computer . In various embodiments tenant applications and represent computer readable software applications that access a shared pool of hardware resources in server computer through a single shared instance of JVM operating on server computer . In various embodiments tenant applications and are computer software code written in a programming language for compilation by JVM such as Java Jython Kotlin JRuby or other languages.

Tenant application includes thread . Thread is a mechanism within JVM for executing a discrete sequence of programmed instructions. In various embodiments thread can include a program counter and or a stack data structure such as stack . In some embodiments each tenant application such as tenant applications and includes one or more associated threads. Additionally in some embodiments additional threads may be maintained by JVM and or server operating system for operations such as garbage collection or hardware resource management. In various embodiments other tenant applications such as tenant application include one or more associated threads such as thread . Thread further includes analogous contents such as one or more stack data structures and an inject bit not shown .

Thread includes stack and inject bit . Stack comprises one or more frames such as frame . Stack is a last in first out LIFO data structure. In various embodiments a frame can be added to the stack pushed for execution. Similarly when a frame completes execution the frame is removed popped from the top of the stack and the thread proceeds to process the frame below the popped frame. In various embodiments frames include the necessary class information and reference information to modify and alter local variables. In various embodiments stack can include an associated bit that when activated masks the thread execution. Mask frame includes program instructions to activate the mask bit to indicate that interruption of the thread execution may result in an exception. Safepoint is a common component in the JVM that indicates a particular point in thread execution at which the execution may be suspended for a period of time without disrupting the execution of the thread. For example safepoints are commonly used to halt thread execution for the purposes of garbage collection. Safepoints occur at various intervals in the code such as after a return from method call or at a back jump of a loop. In various embodiments safepoints can be identified at compile time by a compiler e.g. a just in time compiler and the compiler can insert program instructions for the thread executing the instructions to perform functions outside of the original application code. In some embodiments of the present invention the instructions added at the safepoint include instructions to check one or more bits of information e.g. inject bit that when set to a particular value indicate that a set of program instructions should be injected onto the stack of the executing thread. In various embodiments of the present invention JVM injects a runnable interface at a thread safepoint in order to instruct the thread to execute the runnable method.

Inject bit is one or more bits of information stored in association with thread and when set to a particular value instructs thread to push a runnable piece of code such as a method onto the top of stack when a safepoint is reached. In an embodiment thread executes the program instructions in stack until a safepoint is reached. In this embodiment the safepoint includes instructions to check a series of bits stored in association with thread . In this embodiment one such bit e.g. inject bit instructs thread to push a runnable method onto the stack for execution by the thread before returning to the code that was running when the thread reached the safepoint. In various embodiments inject bit can be set for safepoints occurring at regular time intervals. For example inject bit may be set to trigger injection once per second but any safepoints that occur more frequently than once per second would have inject bit set to a value that does not trigger injection. In this example the thread will execute the injected runnable method at a regular interval. The injected runnable may include instructions to collect statistics manage resource allocation or terminate a thread.

JVM includes heap memory code injection module masking module resource allocation module and CPU allocation accumulator .

Heap memory is a memory data structure that is used to allocate class instances and arrays at runtime. In various embodiments heap memory provides for dynamic memory allocation that is divided into generations. In some embodiments heap memory has a young generation for short lived objects that are created and then immediately garbage collected and an old generation for objects that are used repeatedly by one or more threads.

Code injection module is software capable of pushing a frame of runnable code onto stack of thread . Additionally code injection module is capable of communicating with threads associated with other tenants operating on JVM . In various embodiments code injection module determines that thread has reached a safepoint checks inject bit to determine if an injection of code into stack should occur and if so injects a sequence of runnable code into the stack of the thread which then executes the injected code before popping the runnable code and returning to code that was executing prior to the safepoint.

Masking module is software capable of marking a particular thread as unsafe to halt for a code injection. In various embodiments masking module determines that a mask was called that stack reaches a safepoint and that inject bit is set then masking module clears the inject bit and sets a pending inject bit which thread will check when an unmask method is called.

Resource allocation module is an example implementation of code injection module directed to a specific embodiment in the context of resource allocation of CPU time amongst tenant applications and .

CPU allocation accumulator is a data structure that maintains the allotment granted to each tenant computer by JVM . In various embodiments CPU allocation accumulator includes the number of cycles of CPU that tenant application is on average permitted to use in a defined period of time. In certain embodiments CPU allocation accumulator maintains a running total of the number of cycles used in the specified time. Resource allocation module checks the status of running totals at safepoints such as safepoint and if tenant application exceeds its allotment then resource allocation module ceases execution of thread until tenant application receives an additional allotment of CPU cycles at the end of the defined period of time.

JVM determines that thread reaches a safepoint in its execution such as safepoint step . Safepoints in threads executing within the JVM occur at predetermined times for example at the invocation of a particular method. Safepoints indicate particular points in the execution of the thread at which operations other than the code of the executing tenant application such as tenant applications and may be safely executed by the thread. In one embodiment of the present invention safepoints include instructions to perform maintenance functions or other statistics gathering functions. In an embodiment a given safepoint includes instructions to check one or more bits of information stored within the thread to determine if any of the maintenance functions or statistics gathering functions should be performed while the thread is at a safepoint.

JVM determines whether the inject bit is set decision block . In one embodiment one or more of the bits such as inject bit checked during the safepoint includes instructions to inject or push a particular piece of runnable code to the top of stack . In various embodiments the injected code can include statistics gathering code or resource allocation code such as resource allocation module . In various embodiments inject bit can be set to instruct JVM to inject the runnable code at a safepoint or set to instruct JVM not to inject any runnable code at this safepoint. In some embodiments inject bit can be set to inject runnable code at predetermined time intervals such as once per second. If JVM determines that the injection bit is not set to inject runnable code into stack decision block NO branch then JVM waits until the next safepoint is reached in step . If JVM determines that inject bit bit is set and a runnable code should be injected into the stack at the safepoint then JVM proceeds to push a segment of runnable code to the top of the stack in step .

JVM pushes a segment of runnable code to the top of stack step . In various embodiments of the present invention the segment of runnable code can be an extension of the interface java.lang.RunnableQ. In other embodiments the runnable code can be injected using any type of code method or function that will initiate a runnable sequence of code. The runnable interface provides a mechanism for inserting a runnable method onto stack as well as other stacks that may be associated with other tenant applications. In various embodiments extensions of the runnable interface include runnable methods that instruct the thread to perform various functions such as collect statistics perform resource allocation functions terminate a thread or other functions.

JVM executes the injected runnable code step . Thread operating within tenant application in JVM now having a runnable method frame as at the top of stack executes the instructions pushed to the top of stack . In various embodiments the runnable code includes Java bytecode instructions that may relate to such functions as statistic collection resource management and or thread termination. In various embodiments the injected code is limited to code that will not break the tenant application code that was running prior to the injection. For example allowing input output resources in the injected code can cause exceptions if the code executing prior to the code injection was already using the input output resources. In other embodiments ensuring that the code being injected is pre resolved and that all class and or field references have been initialized avoids running a ClassLoader infrastructure which may lead to various exceptions or errors.

JVM pops the runnable method frame from stack and returns to execution of the code in stack on thread that was running prior to the code injection step . At the end of the runnable method executed in step the code instructions include instructions to pop i.e. remove the frame containing the injected code from stack . In some embodiments following the removal of the injected code thread returns to executing the frames that populated stack prior to the injection of the runnable code. In other embodiments the runnable code includes instructions to terminate thread in which case following the execution of the runnable code stack pops the frame containing the runnable method and thread terminates.

JVM calls a mask for thread step . In one embodiment thread includes a plurality of associated bits of information. In some embodiments one of the associated bits of information indicates whether or not a mask was called during the execution of the plurality of frames in stack for example by executing the code included in mask . In one embodiment a line of computer code executing on thread such as a method of Java bytecode instructs CPU to set the associated bit that indicates whether or not a thread is masked mask bit to a predefined value wherein the value indicates that the thread is masked. In various embodiments masking marks the thread so that code injection module does not instruct JVM to inject any code onto stack even if thread is at a safepoint and inject bit is set to indicate that an injection should occur.

JVM determines that thread reached a safepoint in execution step . Safepoints in threads executing within the JVM occur at predetermined times for example at the invocation of a particular method. Safepoint indicates particular points in the execution of thread at which operations other than the code of tenant application may be safely executed by thread . In one embodiment of the present invention safepoint includes instructions to perform maintenance functions or other statistics gathering functions. In another embodiment safepoint includes instructions to check one or more bits information stored within the thread to determine if any of the maintenance functions or statistics gathering functions should be performed while the thread is at safepoint .

JVM determines whether inject bit is set decision block . In one embodiment one or more of the bits checked during safepoint includes instructions to inject or push a particular piece of runnable code to the top stack . In various embodiments this bit can be set to instruct JVM to inject the runnable code at a safepoint or be set to instruct JVM not to inject any runnable code at this safepoint. In some embodiments the inject bit can be set to inject runnable code at predetermined time intervals such as once per second. If JVM determines that the inject bit is not set decision block NO branch then JVM continues to monitor thread activity until another safepoint occurs in step . If JVM determines that the inject bit is set and a sequence of runnable code should be injected onto stack decision block YES branch then JVM clears the inject bit and sets a separate pending inject bit in step .

JVM clears the inject bit and sets the pending inject bit step . In some embodiments JVM does not inject the runnable code onto stack because the mask bit indicates that an injection could result in errors and or exceptions. In various embodiments JVM clears inject bit and sets a pending inject bit which is distinct and separate from inject bit to active so that when thread executes an unmask method call thread checks the pending inject bit which indicates that there is a runnable code that should be injected onto stack . In alternative embodiments JVM does not inject the runnable code but resets inject bit to an active position so that at the next safepoint thread checks inject bit again and determines whether the thread is masked by checking the mask bit. In various embodiments the process of resetting inject bit to active repeats for subsequent safepoints until an unmask method is called for thread . Once the unmask method is called the next safepoint will result in the injection of the runnable section of code onto stack .

JVM determines that an unmask method has been called step . An unmask is called when executable bytecode instructs JVM to deactivate the associated mask bit and determine if the pending inject bit is set. In response to determining that the pending inject bit is set JVM proceeds to execute code injection module as described in or a functional equivalent thereof step .

In other embodiments JVM can attempt to set the inject bit to active after a mask has already been called on thread . In these embodiments JVM can check the mask bit stored in association with thread to determine that thread is masked. In response to determining that the thread is masked JVM can set the pending inject bit to active as described in step of . In these embodiments of the present invention an unmask method is called as described in step of . Responsive to determining that an unmask method was called these embodiments proceed to execute code injection module as in step of .

Thread transmits a request for the current CPU allocation with respect to tenant application step . In one embodiment thread transmits a request to CPU allocation accumulator to return the current CPU allocation for the tenant application associated with the thread on which resource allocation module is executing. In various embodiments CPU allocation accumulator maintains a running total of the CPU allocation for each tenant application in the memory of JVM . In these embodiments CPU allocation accumulator can also read and transmit the current state of the CPU allocation for each thread that transmits a request. CPU allocation may be measured in for example cycles per second.

Thread determines whether a tenant exceeded its CPU allocation for the current allocation period decision block . Thread analyzes the received CPU allocation to determine whether the running total of cycles that tenant application actually used in the current allocation period exceeded the maximum amount of cycles allocated to tenant application for the time period. In some embodiments CPU allocation accumulator begins a time period with the maximum number of cycles allowed by each tenant. As the tenant uses cycles CPU allocation accumulator subtracts those cycles from the initial amount to maintain a running total. If tenant application exceeds its allotment for the time period then the running total will reach zero cycles or negative cycles during the time period. In other embodiments CPU allocation accumulator may begin each time period with zero cycles for each tenant application. In the other embodiments thread compares the number of cycles for the tenant at the time of the request with a maximum number of cycles allowed for the tenant which may be for example a constant number stored in association with thread or in heap memory . If thread determines that a tenant did not exceed its CPU allocation for the current time period decision block NO branch then thread returns to request the current CPU allocation for a subsequent time period in step . If thread determines that tenant application did exceed its CPU allocation for the current time period decision block YES branch then thread suspends execution of tenant application for the duration of the next allocation time period in step .

Thread suspends execution of tenant application step . In one embodiment thread creates an await condition which stops the thread execution until the thread receives a signal that an additional allocation of CPU resources has been granted to tenant application .

Thread receives a signal that tenant application received an additional CPU allocation step . In an embodiment CPU allocation accumulator resets so that tenant application receives an additional allocation of CPU cycles at a regular interval of time for example once per second. In this embodiment the program code that resets the CPU allocation for the tenant application can include a program instruction to transmit a signal to thread that an additional allocation has occurred and thread can terminate the await condition and resume execution of the thread. In response to thread receiving the signal that the await condition has been satisfied then thread resumes thread execution for the threads associated with tenant application in step .

Server computer includes communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

Code injection module and masking module are stored in persistent storage for execution by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. Code injection module and masking module may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to server computer . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. code injection module and masking module can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network LAN a wide area network WAN and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of instructions which comprises one or more executable instructions for implementing the specified logical function s . In some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.

