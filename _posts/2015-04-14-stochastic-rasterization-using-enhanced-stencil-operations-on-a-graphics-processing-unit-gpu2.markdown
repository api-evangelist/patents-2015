---

title: Stochastic rasterization using enhanced stencil operations on a graphics processing unit (GPU)
abstract: Techniques are described for stochastic rasterization. A graphics processing unit (GPU) may discard samples of bounding polygons that together indicate movement of one or more primitives before a pixel shader process the samples. The GPU may leverage a stencil buffer and stencil test for discarding of such samples.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626762&OS=09626762&RS=09626762
owner: QUALCOMM Incorporated
number: 09626762
owner_city: San Diego
owner_country: US
publication_date: 20150414
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 979 931 filed Apr. 15 2014 the entire content of which is incorporated herein by reference.

This disclosure relates to graphics processing techniques and more particularly to stochastic rasterization techniques.

A graphics processing unit GPU may use motion blur e.g. motion defocus effects for reducing and or eliminating temporal aliasing e.g. hopping in an animation. To implement motion blur effects an object in a graphics scene may be sampled at multiple instances in time and the samples at the multiple instances in time for the object may be combined to represent the object as part of a single graphics frame. To achieve motion blur an object in a graphics scene may need to be sampled at a sampling rate that is greater than the rate at which the images in a graphics scene will be displayed e.g. a sampling rate that is greater than the display frame rate .

Processing a graphics scene that is sampled at a sampling rate that is greater than the display frame rate may significantly increase the amount of data that needs to be processed by a GPU and or increase the complexity of the processing implemented by the GPU. In some cases the sampling and processing that needs to be performed for graphics scenes that are sampled at a sampling rate that is greater than the display frame rate may be too complicated and or too slow for real time graphics particularly in processing environments that have a limited amount of computational resources computational speed and or power resources such as e.g. a mobile device and or a mobile phone.

This disclosure describes examples for efficient implementation of stochastic rasterization techniques by leveraging a stencil test to determine whether a sample is to be rendered prior to execution of a pixel shader. For example in stochastic rasterization a bounding polygon e.g. bounding shape may define a relative frame to frame movement of a primitive and the bounding polygon may include a plurality of sample values whose values are generally random within the bounding polygon hence stochastic. A graphics processing unit GPU may perform a stencil test on the sample values within the bounding polygon to discard at least some of the sample values prior to executing pixel shaders which may reduce the number of unnecessary pixel shader executions resulting in more efficient stochastic rasterization e.g. reduced GPU resources and faster rasterization .

Moreover in some examples the GPU or another processor may further partition the bounding polygon to reduce the processing of overlapping samples. Furthermore in some examples the bounding polygon may define a relative frame to frame movement of a cluster of primitives rather than a single primitive e.g. the bounding polygon defines a relative frame to frame movement of one or more primitives . In such examples stochastic rasterization may improve because primitives are processed in groups rather than one at a time.

In one example the disclosure describes a method of graphics processing the method comprising determining a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame wherein each bounding polygon covers a portion of the animation timeline and wherein the animation timeline corresponds to a movement of the one or more primitives determining temporal values for samples within each of the bounding polygons based on a sampling pattern prior to samples of respective bounding polygons being processed by a pixel shader of a graphics pipeline of a graphics processing unit GPU determining which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons discarding from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and maintaining a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed and executing one or more instances of the pixel shader to process the second set of samples of the bounding polygon.

In one example the disclosure describes a device for graphics processing the device comprising a memory unit configured to store a sampling pattern and a graphics processing unit GPU configured to determine a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame wherein each bounding polygon covers a portion of the animation timeline and wherein the animation timeline corresponds to a movement of the one or more primitives determine temporal values for samples within each of the bounding polygons based on the stored sampling pattern prior to samples of respective bounding polygons being processed by a pixel shader of a graphics pipeline of GPU determine which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons discard from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and maintain a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed and execute one or more instances of the pixel shader to process the second set of samples of the bounding polygon.

In one example the disclosure describes a computer readable storage medium having instructions stored thereon that when executed cause one or more processors of a device for graphics processing to determine a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame wherein each bounding polygon covers a portion of the animation timeline and wherein the animation timeline corresponds to a movement of the one or more primitives determine temporal values for samples within each of the bounding polygons based on a sampling pattern prior to samples of respective bounding polygons being processed by a pixel shader of a graphics pipeline of a graphics processing unit GPU determine which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons discard from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and maintain a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed and execute one or more instances of the pixel shader to process the second set of samples of the bounding polygon.

In one example the disclosure describes a device for graphics processing the device comprising means for determining a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame wherein each bounding polygon covers a portion of the animation timeline and wherein the animation timeline corresponds to a movement of the one or more primitives means for determining temporal values for samples within each of the bounding polygons based on a sampling pattern means for determining which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons prior to samples of respective bounding polygons being processed by a pixel shader of a graphics pipeline of a graphics processing unit GPU means for discarding from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and means for maintaining a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed and means for executing one or more instances of the pixel shader to process the second set of samples of the bounding polygon.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

In graphics processing a graphics processing unit GPU generates graphical content at a certain frame rate e.g. 30 frames per second fps . For fast moving objects in the graphical content the objects may appear as hopping rather than having a smooth transition frame to frame from one location to another. Such hopping is referred to as temporal aliasing. Motion defocusing or motion blurring are proposed techniques to address such temporal aliasing.

For example in video capture a camera captures many frames e.g. based on shutter speed and averages the frames to achieve an effective frame rate. As an example a camera may capture 150 frames per second and average five frames to generate a composite frame and repeat this process for an effective frame rate of 30frames per second e.g. 150 divided 5 equals 30 . The averaging of the frames produces blurring in the final composite frame that appears like a tail on the fast moving object. This blurring then appears as a smooth movement of the object rather than the object hopping from frame to frame.

Such a brute force approach of generating additional frames and then averaging for achieving the effective frame rate may not be practical in some cases. For example due to power and processing time a GPU may not be able to produce many additional frames on which averaging can be performed and still achieve the appropriate frame rate. This brute force approach may be considered as a high order rasterization approach that may be either too complicated or too slow for real time graphics.

In some examples rather than averaging many frames the GPU may add blurring or defocusing to objects on a frame so that the object appears to be moving fast. One example way to add such blurring for purposes of creating the perception of movement is referred to as stochastic rasterization.

This disclosure describes techniques for performing stochastic rasterization with a graphics processing unit GPU . Stochastic rasterization refers to the process of rasterizing a primitive based on a stochastic sampling pattern that specifies for each of a plurality of sampling locations e.g. pixel locations a time instance of an animation timeline at which the primitive is to be sampled at the respective sampling location.

Stated another way in graphics processing a GPU constructs an object by an interconnection of a plurality of primitives such as triangles. As a triangle of the object moves from frame to frame the movement of the triangles being an example of an animation timeline the triangle may be considered to have been in many positions between the position in one frame and the position in a next frame. Although the GPU may not render the primitive in any of these intermittent positions the primitive may be considered as passing through many time instances along the animation timeline.

As a simple example assume that a primitive of an object is moving from left to right in the graphical content. In this example in frame at time assume that the primitive of the object is at location and then in frame at time 33 milli second ms e.g. for 30 fps assume that the primitive of the object is at location e.g. one unit distant to the right relative to frame . In this example the animation timeline is movement of the primitive during the 33 ms from location to location but at time instance 16.5 ms along the animation timeline the location of the primitive was location ..

Accordingly the respective time instance of the animation timeline specified for each of the pixels by the stochastic sampling pattern may be a respective time instance of a frame time interval of the animation timeline. A frame time interval may refer to a time interval of an animation timeline that is between two consecutive graphics frames that are rendered and displayed. In other words the frame time interval may refer to a range of times between a first time instance of the animation timeline associated with a previous graphics frame that was rendered and displayed and a second time instance associated with a subsequent graphics frame to be rendered and displayed.

The stochastic sampling pattern may specify a temporal value to each of the samples e.g. pixels of a frame along the animation timeline. For instance in the previous example the stochastic sampling pattern may specify a temporal value to each of the samples of frame along the animation timeline e.g. the pixels that are located in the area in which the primitive moved from location to location . The temporal value of each of the samples along the animation timeline may be a random value hence the term stochastic between a minimum and a maximum value. The randomness of the temporal values reduces aliasing effects but increases noise. However aliasing effects tend to more negatively affect viewer experience than noise.

Each of the temporal values may correspond to a time instance of the primitive along the animation timeline. As a basic example assume that at time the primitive is at location in frame and at time the primitive is at location in frame . In this example at time instance . the primitive is at location .. The temporal value of 0.5 corresponds to the time instance .. In this example the samples of frame along the animation timeline e.g. located between location and location of the path of the primitive are assigned temporal values in a stochastic e.g. random manner. Accordingly some of the temporal values will equal 0.5 and others will not.

In stochastic rasterization the GPU determines a temporal value for a sample and determines where the primitive corresponding to that temporal value would be located along the animation timeline. The GPU then determines whether that particular sample is located inside or outside that primitive. If the sample is within the primitive the GPU renders the sample. Otherwise the GPU discards the sample. As an example assume that a sample located on the left end of the animation timeline has a temporal value of 0.5. In this example the GPU may determine that at a time instance of 0.5 the primitive would be located in the middle of the animation timeline. The GPU may then determine that the sample located at the left end of the animation timeline having a temporal value of 0.5 is not inside the time instance of the primitive located in the middle of the animation timeline. In this case the GPU would discard that sample.

It should be understood that a time instance of a primitive need not necessarily mean a rendered primitive. For example between frame at time and frame at time there are many time instances of the primitive e.g. at time . . . and so forth at . . . and so forth . . . and so forth or other granularities . The primitives between the frames are conceptual primitives. They are not actual primitives that are rendered. But in stochastic rasterization information of where the primitive would have been conceptually located at a time instance i.e. sampling location of the primitive is used to determine which samples are to be rendered.

For example to perform stochastic rasterization a rasterizer of the GPU may rasterize a bounding polygon that covers the primitive to be rendered over a range of time instances along an animation timeline. In other words the bounding polygon also referred to as a bounding shape bounds the movement path of the primitive along the animation timeline. As a basic example assume that the animation timeline of a primitive of height X is rightward by a distance of Y e.g. from a first frame to a second frame the primitive with height X moved rightward a distance of Y . For this example a bounding polygon may be a rectangle or possibly a trapezoid of height X and a width of Y because such a bounding polygon covers the primitive to be rendered over a range of time instances e.g. from the time of the first frame to the time of the second frame along an animation timeline e.g. movement rightward .

Rasterizing the bounding polygon may generate a plurality of samples that correspond to the bounding polygon. A pixel shader may for each of the sampling locations of the bounding polygon shade the sample at the respective sampling location based on temporal position from the stochastic sampling pattern and relative position mapping to the primitive at that temporal position. For example a pixel shader may determine a time instance of the primitive e.g. where the primitive would be located on the animation timeline also referred to as temporal position of the primitive based on a temporal value of a sample.

The pixel shader may then determine whether the sample being processed is inside or outside the time instance of the primitive e.g. inside or outside the primitive at that temporal position of the primitive . If the sample is outside of the primitive at that temporal positon the pixel shader may discard the sample corresponding to the sampling location such that further processing is not performed on the sample by the pixel shader or by subsequent stages of the graphics pipeline. If the sample is inside of the primitive at that temporal position the pixel shader may maintain the sample for further processing.

Stochastic rasterization may result in a relatively large number of samples e.g. pixels that are processed by a pixel shader stage of a pixel processing pipeline but will ultimately not contribute to the resulting graphics image. Typically such samples may be discarded by the pixel shader stage of the pixel processing pipeline. However discarding such samples at the pixel shader stage may still result in a large number of unnecessary invocations of the pixel shader which may reduce the performance of the pixel shader stage of the graphics pipeline.

In the techniques described in this disclosure for performing stochastic rasterization a GPU may use a stencil test to selectively discard samples e.g. pixels from a pixel processing pipeline of a GPU prior to the samples reaching the pixel shader stage of the pixel processing pipeline. As noted above stochastic rasterization may result in a relatively large number of samples e.g. pixels that are processed by a pixel shader stage of a pixel processing pipeline but will ultimately not contribute to the resulting graphics image. By selectively discarding such samples prior to the pixel shader stage of the pixel processing pipeline the number of samples processed by the pixel shader stage may be reduced thereby avoiding a large number of unnecessary invocations of the pixel shader. In this way the performance of a GPU that performs stochastic rasterization may be improved.

In some examples the stencil test may use a stencil mask that is determined based on a stochastic sampling pattern e.g. a stochastic sampling mask to determine which pixels are to be discarded. For example as described in more detail below rather than utilizing a single bounding polygon for a primitive the GPU may utilize a plurality of bounding polygons where each bounding polygon covers a portion of the animation timeline. The stencil mask may be formed such that only a subset of the samples pass through for a particular bounding polygon based on an animation timeline covered by the bounding polygon. In this manner the number of times the pixel shader is invoked is reduced promoting efficient stochastic rasterization.

In other words in some examples multiple bounding polygons and or multiple bounding polygon partitions that are each associated with a respective time interval that is smaller than the frame time interval may be used to perform stochastic rasterization. In such cases it may be known in advance that samples associated with instances in time that are outside of the time interval associated with a respective bounding polygon and or bounding polygon partition will always be discarded when processing the samples for the respective bounding polygon and or bounding polygon partition.

According to some aspects of this disclosure the values of a stencil mask that is used to perform a stencil test may be determined such that sampling locations which are associated with instances in time that are outside of the time interval associated with a respective bounding polygon and or bounding polygon partition will fail the stencil test thereby causing the samples associated with such sampling locations to be discarded. In this way the performance of a GPU that uses bounding polygons and or bounding polygon partitions that are associated with time intervals that are smaller than the frame time interval may be improved.

In some cases timeline segmentation and or bounding polygon partitioning may be used to perform stochastic rasterization. Timeline segmentation may involve subdividing the animation time interval between consecutive graphics frames into a plurality of smaller segmented time intervals that collectively span the animation time interval. A bounding polygon may be generated and rasterized for each of the segmented time intervals and shading may be performed for each of the rasterized bounding polygons.

Bounding polygon partitioning may involve subdividing the bounding polygon into a plurality of smaller bounding polygon partitions that collectively span the samples covered by the original bounding polygon. Each of the bounding polygons partitions may be rasterized and shading may be performed for each of the rasterized bounding polygons.

When performing stochastic rasterization overlapping primitives may significantly increase the number of samples that are processed but ultimately discarded. As the primitives become smaller the problem may become worse.

According to some aspects of this disclosure a plurality of primitives may be grouped together to form a cluster of primitives and a bounding polygon e.g. a bounding box may be formed that encompasses all of the primitives in the cluster of primitives. Stochastic rasterization may then be performed with respect to bounding polygon of cluster of primitives. Timeline segmentation and bounding polygon partition may consider cluster of primitives. Stencil operations may stay the same to discard the sample of each bounding polygon and the pixel shader may determine if each sample of bounding polygon is inside of any primitive of cluster at the temporal position e.g. time instance of the primitive and shade the sample accordingly or discard the sample if outside of all primitives at that temporal position. By using a bounding polygon that encompasses a plurality of primitives to perform stochastic rasterization instead of using individual bounding polygons for each of the primitives which may overlap each other the number of processes on each sample on screen may be reduced. In this way the performance of a graphics processing system that performs stochastic rasterization may be improved.

As illustrated in the example of computing device includes a user input interface a central processing unit CPU a graphics processing unit GPU a memory controller a memory a display interface a display and a bus . User input interface CPU GPU memory controller and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

User input interface may allow one or more user input devices not shown to be communicatively coupled to computing device . The user input devices may allow a user to provide input to computing device via user input interface . Example user input devices include a keyboard a mouse a trackball a microphone a touch pad a touch sensitive or presence sensitive display or another input device. In examples where a touch sensitive or presence sensitive display is used as a user input device all or part of user input interface may be integrated with display .

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . CPU may execute one or more software applications. The software applications may include for example a video game application a graphics application a word processor application an email application a spread sheet application a media player application a graphical user interface application an operating system or any other type of software application or program.

GPU may be configured to render and display graphics data that is received from CPU . In some examples GPU may be configured to perform graphics operations to render one or more graphics primitives to display . In such examples when one of the software applications executing on CPU requires graphics processing CPU may provide graphics data to GPU and issue one or more graphics commands to GPU . The graphics commands may include draw call commands GPU state programming commands memory transfer commands blitting commands etc. The graphics data may include vertex buffers texture data surface data etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

GPU may in some instances be built with a highly parallel structure that provides more efficient processing of vector operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to process tasks that that include a high degree of parallelism more quickly than CPU . In addition the highly parallel nature of GPU may in some examples allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU .

GPU may in some instances be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

In some examples GPU may include a GPU cache which may provide caching services for all or a portion of memory . In such examples GPU may use the cache to process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by reducing the need for GPU to access memory via bus which may experience heavy bus traffic during each read and write command. In some examples however GPU may not include a separate cache but instead utilize memory via bus . The GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM etc.

Memory controller facilitates the transfer of data going into and out of memory . For example memory controller may receive memory read and write commands and service such commands with respect to memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from both CPU and memory in other examples some or all of the functionality of memory controller may be implemented on one or both of CPU and memory .

Memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example memory may store program code and graphics data associated with the applications executing on CPU . Memory may additionally store information for use by and or generated by other components of computing device . For example memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example memory may store any combination of buffer objects pipe data or the like. In addition memory may store command streams for processing by GPU e.g. command queues . Memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data medium or an optical storage medium. In some examples memory may correspond to all or part of a data storage system.

CPU and or GPU may store rasterized image data in a frame buffer that is allocated within memory . Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rasterized image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computing device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

In some examples the techniques for performing stochastic rasterization described in this disclosure may be implemented in one or both of CPU and GPU . For example CPU may execute one or more software applications or programs e.g. a GPU driver that perform all or part of any of the stochastic rasterization techniques of this disclosure. As another example GPU may include a rasterization unit and or a pixel processing pipeline that is configured to perform all or part of any of the stochastic rasterization techniques of this disclosure. As another example GPU may include a programmable shader unit that is configured to execute one or more shader programs that perform all or part of any of the stochastic rasterization techniques of this disclosure. In additional examples memory may store one or more programs for execution by CPU and or GPU that perform any of the stochastic rasterization techniques of this disclosure.

In some examples CPU and or a GPU driver executing on CPU may perform one or more aspects of this disclosure. For instance CPU and GPU may together perform the real time stochastic rasterization techniques. As described above stochastic rasterization may provide quality motion blur to create the perception of movement of an object and may perform better and with less computational resources than post processing methods such as averaging many frames. Although stochastic rasterization functions well for motion blur for constant velocity objects the techniques described in this disclosure are not limited to examples of constant velocity objects. Moreover in some examples GPU may be configured to perform 8X multisample anti aliasing MSAA which is generally sufficient for stochastic rasterization. For instance as described above stochastic rasterization tends to limit the effects of aliasing at the cost of noise but the effects of aliasing is more drastic than noise.

Motion blur may be useful to avoid issues associated with hopping where in hopping an object appears to hop from frame to frame rather than smoothly transition from frame to frame i.e. the motion blur causes the viewer to perceive as if the object is moving smoothly rather than hopping . To apply such motion blur CPU e.g. through execution of a GPU driver may generate bounding polygons for primitives and or clusters of primitives. The bounding polygons may cover an animation timeline of one or more primitives from a first frame to a second frame e.g. a movement of the one or more primitives . For instance if the one or more primitives are moving upwards downwards rightwards or leftwards the bounding polygon may be rectangular with one edge of the bounding polygon touching the location in the second frame of the one or more primitives in the first frame and the another edge of the bounding polygon touching the location in the second frame of the one or more primitives in the second frame. In other words for a rightward moving primitive the left edge of the rectangular bounding polygon is at the location in the second frame that is the same location as the location of primitive in the first frame and the right edge of the rectangular bounding polygon is at the location in the second frame of the primitive.

In some examples CPU e.g. executing a GPU driver may partition a bounding polygon into a plurality of bounding polygon partitions and determine time intervals for each of the bounding polygon partitions. As a further example CPU e.g. executing a GPU driver may subdivide an animation timeline into a plurality of segmented time intervals i.e. timeline segments . In any of these examples CPU may output information of the bounding polygons to GPU and GPU may determine one or more bounding polygons based on the received information.

For each of the bounding polygons GPU may determine temporal values for samples e.g. pixels within the bounding polygons based on a sampling pattern. The sampling pattern may be a pattern defined by CPU e.g. by a GPU driver by an application or a pre programmed pattern . The sampling pattern may be considered as a small fixed tile e.g. 8 8 32 32 as some examples and may be the same for the rendering process of the frame.

Each location of the sampling pattern may be assigned a value e.g. between 0 and 1 and in some examples the values in the sampling pattern may be random but evenly distributed. Accordingly one example of the sampling pattern is a stochastic sampling pattern however other types of sampling patterns are possible. For ease of description the techniques are described with respect to a stochastic sampling pattern.

Some techniques store the stochastic sampling pattern in a texture buffer and determine the temporal values for the samples within the bounding polygons based on the values stored in the texture buffer. In the techniques described in this disclosure GPU may load the stochastic sampling pattern in a stencil buffer and in some examples in addition to loading the stochastic sampling pattern in the texture buffer. By loading the stochastic sampling pattern GPU may perform a stencil test to discard samples that do not need to be further processed prior to processing by a pixel shader as described in more detail.

The stencil buffer may be stored in the cache of GPU or in memory . The stencil buffer may be a two dimensional buffer with a plurality of storage locations. The size of the stencil buffer may be large enough to store the pixel values for each of the pixels that is to be displayed. For example each storage location in the stencil buffer may correspond to a location of a sample on a frame. Because the stochastic sampling pattern is a relatively small sized tile e.g. much smaller than the size of the stencil buffer GPU may repeat the stochastic sampling pattern across the stencil buffer.

The value stored at a particular location in the stencil buffer may be a temporal value of a sample in the bounding polygon having a corresponding location in the frame. For example assume that a sample located at in a frame is also within a bounding polygon. In this example the temporal value of the sample equals the value stored in location within the stencil buffer.

A temporal value of a sample indicates with which time instance of the one or more primitives that sample is associated. In other words the temporal value of the sample indicates with which temporal position of the one or more primitives that sample is associated. However a sample may not necessarily be covered by a time instance with which it is associated i.e. the temporal position of the primitive may not cover a sample having a temporal value that corresponds to that temporal position . For example at a time instance halfway between frame and frame a primitive would be at a halfway location within the bounding polygon. Again this primitive in a halfway location in the bounding polygon is not rendered but conceptually the halfway time between the time represented at frame and the time represented by frame the primitive would be located halfway in the bounding polygon.

In this example assume that the time instance of this conceptual primitive is . and the location of the conceptual primitive is halfway in the bounding polygon e.g. temporal position is . . All samples having a temporal value of 0.5 are associated with this conceptual primitive. However not all samples having a temporal value of 0.5 are located halfway in the bounding polygon. For instance due to the stochastic nature of the temporal values samples having a temporal value of 0.5 may be distributed throughout the bounding polygon.

In stochastic rasterization GPU may determine for a sample whether that sample is associated with a particular time instance e.g. temporal position of the primitive based on the temporal value of the sample. GPU may then determine whether that sample is covered or not by the primitive at that time instance. If the sample is covered GPU renders the sample. If the sample is not covered GPU discards the sample. GPU repeats such steps for each sample. In this way GPU renders a few samples per time instance of the primitive. This results in the appearance of motion blurring and smooth movement of the object that is formed by the primitive.

In this example primitive B will be rendered as part of frame and primitive A is illustrated conceptually. For instance primitive A illustrates the location of where the primitive was in frame and primitive B illustrates the location of where the primitive is in frame . As illustrated bounding polygon extends in frame from the corresponding location of where primitive A is located in frame to where primitive B is located in frame .

Primitive C is a conceptual primitive illustrating the time instance t of where the primitive would have been located in bounding polygon e.g. temporal position of the primitive at time instance t . The time instance t of primitive C represents a time between frame and frame . Therefore GPU may not render primitive C in a frame but conceptually it is possible to determine where primitive C is located. For example the application executing on CPU may define the velocity and or acceleration of the primitive and frame and frame may define set time instances e.g. 33 milli seconds of separation assuming 30 fps . Based on the velocity and or acceleration and the time between frame and frame it may be possible to determine the temporal position of primitive C.

Bounding polygon includes a plurality of samples having different temporal values. For ease of illustration some of the samples having the same temporal value are expanded to assist with visualizing. For instance illustrates samples each having the same temporal value and for ease samples A B and C are called out with reference numerals. GPU may determine the temporal values of the samples of bounding polygon including samples based on a stochastic sampling pattern as described above.

In the example illustrated in assume that samples A B and C all have the same temporal value e.g. 0.3 and the time instance of primitive C is 0.3. In this example for sample A GPU may determine the temporal value of sample A and then determine the temporal position of the primitive associated with sample A. For instance GPU may determine the temporal position of the primitive to be at the time instance of primitive C. GPU may determine whether sample A is inside or outside e.g. covered or not covered by primitive C. In this case because sample A is not covered by primitive C GPU may discard sample A from further processing.

Similarly for sample C GPU may determine the temporal value of sample C and then determine the temporal position of the primitive associated with sample C. For instance as above GPU may determine the temporal position of the primitive to be at the time instance of primitive C. GPU may determine whether sample C is inside or outside e.g. covered or not covered by primitive C. In this case because sample C is not covered by primitive C GPU may discard sample C from further processing. It should be understood that GPU may process each sample in various orders and therefore GPU may not process sample C after sample A and may process sample B before sample C.

For sample B however GPU may determine that sample B is covered by the time instance of primitive C and that sample B is associated with primitive C. In this example GPU may further process sample B such as render sample B as part of the final displayed frame.

In this manner some of the samples in bounding polygon are rendered and others are not. As only a few samples are rendered in bounding polygon it would appear as motion blurring.

One way to determine which primitives are to be rendered is by executing a pixel shader configured to make such a determination. For example GPU may implement a graphics processing pipeline and the graphics processing pipeline includes a pixel shader stage. In the pixel shader stage GPU executes instances of a pixel shader for each sample within bounding polygon . Part of the functionality of the pixel shader may be to determine whether the sample that it is processing is covered by the time instance of primitive e.g. temporal position of the primitive with which it is associated. If the pixel shader determines that the sample it is processing is not covered the pixel shader may discard that sample from further processing. Otherwise the pixel shader may further process the sample e.g. determine color for the sample and render the sample for display .

A rasterizer sometimes referred to as GRAS may rasterize the bounding polygon . A pixel shader may determine temporal values of samples in the bounding polygon based on a stochastic sampling pattern as part of a texture read where the values from the stochastic sampling pattern are stored in the texture buffer. However in the techniques described in this disclosure the stochastic sampling pattern may be stored in the stencil buffer to leverage the stencil test for efficient stochastic rasterization.

A pixel shader sometimes referred to as fragment shader may check each samples validity . For example the pixel shader may perform some inside outside test per sample based on the xy and t values with a predefined random t. In other words the pixel shader may be determine whether the sample that it is processing is associated with the time instance of the primitive that covers the sample in the bounding polygon.

The pixel shader may shade the samples that pass with predefined random t values . For example the pixel shader may shade the samples that pass with predefined random t values. In other words if the sample being processed is outside of primitive at the temporal position the pixel shader may not perform further tasks on that sample. Otherwise the pixel shader may further process the sample e.g. shade the sample including determining color for the sample and render the sample for display .

There may be additional processing on the sample that the pixel shader outputs including depth test and downsampling . For example a depth test after the pixel shader may determine any of the samples outputted by the pixel shader are occluded and may discard those pixels from rendering. An anti aliasing filter such as an MSAA filter may downsample and remove any aliasing.

However there may be issues with such stochastic rasterization techniques. In general the number of samples that are actually further processed by each instantiation of the pixel shader are fairly low but all samples within the bounding polygon e.g. bounding polygon are processed by an instantiation of the pixel shader. For example GPU executes an instance of a pixel shader for each sample to determine whether further processing of that sample is needed but only for a few samples does further processing occur resulting in unnecessary invocations of the pixel shader.

Such issues become more pronounced because of the single instruction multiple data SIMD capabilities of GPU and for smaller sized primitives. For instance in the SIMD capabilities each fiber corresponds to one instantiation of the execution of a pixel shader for one sample and a plurality of fibers forms a thread e.g. 32 fibers forms a thread for processing 32 samples in parallel . One condition may be that all fibers of a thread need to complete respective tasks until all fibers are free. Therefore if only a few samples of the 32 samples are going to be further processed then all other instantiations of the pixel shader remain idle to allow a few to be further processed. Also for smaller sized primitives the probability that a sample will belong to a time instance of that primitive is relatively small further reducing the chances of a sample actually being further processed by an instantiation of the pixel shader.

Another issue with some of these techniques for stochastic rasterization is that proximate primitives may have the same animation timeline but a bounding polygon for each primitive is generated and the stochastic rasterization is applied. Therefore essentially the same animation timeline is rasterized multiple times with different bounding polygons.

The techniques described in this disclosure may reduce the number of samples for which the pixel shader needs to be invoked prior to the pixel shader stage in GPU . For example GPU may be configured to selectively discard samples from a pixel processing pipeline of GPU prior to the samples arriving at a pixel shader stage of the pixel processing pipeline based on a stencil test. As described above GPU may load the stochastic sampling pattern in a stencil buffer including repeating the stochastic sampling pattern across the stencil buffer . Accordingly the values of the stencil buffer may be determined based on a stochastic sampling pattern and the values in the stencil buffer may correspond to temporal values of samples in the bounding polygon based on the location of the sample in the frame and the location of the value in the stencil buffer.

In one or more examples GPU may utilize a stencil test based on the values stored in the stencil buffer to selectively discard samples before the pixel shader. By selectively discarding samples prior to the pixel shader stage of the pixel processing pipeline the number of samples processed by the pixel shader stage may be reduced thereby avoiding a large number of unnecessary invocations of the pixel shader. In this way the performance of GPU when performing stochastic rasterization may be improved.

For example as described in more detail below rather than utilizing a single bounding polygon that covers the entire animation timeline of one or more primitives GPU may determine a plurality of bounding polygons that together cover an animation timeline one or more primitives from a first frame to a second frame. In this example each bounding polygon covers a portion of the animation timeline and as described above the animation timeline corresponds to a movement of the one or more primitives. In some examples CPU may determine the plurality of bounding polygons and output information of the bounding polygons to GPU . In such examples GPU may determine the plurality of bounding polygons that together cover an animation timeline one or more primitives from a first frame to a second frame based on the received information.

GPU may determine temporal values for samples within each of the bounding polygons based on a sampling pattern e.g. based on a stochastic sampling pattern stored in a stencil buffer . In some examples prior to samples of respective bounding polygons being processed by the pixel shader stage of the graphics pipeline of GPU GPU may determine via a stencil test which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons. For instance each bounding polygon may be associated with a different threshold condition and the threshold condition may be based the number of bounding polygons in the plurality of bounding polygons. The threshold condition for a bounding polygon may be based on the time instance that the bounding polygon covers.

As described in more detail by applying a stencil test that is specific to a particular bounding polygon GPU may discard samples whose temporal values are outside the time instance that the bounding polygon covers. In this way instantiations of the pixel shader are executed only for samples having temporal values within the time instance covered by the bounding polygon which reduces the number of unnecessary executions of the pixel shader. It might be possible that there are still some executions of the pixel shader for which the pixel shader determines that the sample is not be further processed but the chances of such a result are reduced.

Accordingly GPU may discard from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and maintain a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed. GPU may then execute one or more instances of a pixel shader to process the second set of samples of the bounding polygon.

Although example graphics pipeline is illustrated in as not including on chip tessellation stages in other examples a graphics pipeline that include on chip tessellation stages may be used to implement the stochastic rasterization techniques of this disclosure. Other graphics pipeline that include the same or different components in the same or different configuration may also be used to implement the stochastic rasterization techniques of this disclosure.

Graphics pipeline is configured to render one or more graphics primitives into a render target. Graphics pipeline includes a resources block an input assembler a vertex shader a geometry shader a rasterizer a stencil unit a pixel shader a depth test unit and an output merger .

Resources block may correspond to one or more memory resources used by pipeline stages in graphics pipeline such as e.g. one or more textures and or one or more buffers e.g. vertex buffers frame buffers stencil buffers etc. . For example a memory unit e.g. a stencil buffer may be configured to store values of a sampling pattern e.g. a stochastic sampling pattern from which rasterizer may determine the temporal values of a bounding polygon. This memory unit e.g. stencil buffer may be within local memory of GPU within memory or some combination of storage between the local memory and memory .

Moreover resources block may also correspond to units of GPU that control the functionality of various components. For example resources block may correspond to a control unit a scheduler and other such types of units used to perform the graphics processing of GPU .

The processing stages depicted in with straight corners represent fixed function processing stages and the processing stages depicted in with rounded corners represent programmable processing stages. For example as shown in input assembler rasterizer depth test unit and output merger are fixed function processing stages and vertex shader geometry shader and pixel shader are programmable processing stages.

A programmable processing stage may refer to a processing stage that is configured to execute a program e.g. a shader program that is defined by compiled by and or loaded onto a GPU that implements graphics pipeline by a host device e.g. CPU that uses the GPU. In some cases the program may be defined by a user level graphics application executing on a host device and loaded onto the GPU by a GPU driver executing on the host device. A fixed function processing stage may include hardware that is not configured to receive and execute programs from a host device. The hardware included in a fixed function processing stage may be hard wired to perform certain functions. Although the hardware included in a fixed function processing stage may be configurable the configurability of the hardware is based on one or more control signals as opposed to being based on a program e.g. a shader program .

Each of the programmable stages shown in graphics pipeline may be configured to execute a shader program of a particular type. For example vertex shader may be configured to execute a vertex shader program geometry shader may be configured to execute a geometry shader program and pixel shader may be configured to execute a pixel shader program.

A GPU that implements graphics pipeline may include one or more shader units that are configured to execute the different types of shader programs. Each of the different types of shader programs may execute on a common shader unit of a GPU that implements graphics pipeline and or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types.

Graphics pipeline begins rendering a set of primitives in response to receiving a draw call command and data indicative of one or more primitives to be rendered. The data indicative of the primitives to be rendered may include for example one or more vertex buffers one or more index buffers and or one or more state configurations indicative of the type of primitive to be rendered. The vertex buffers and or index buffers may in some examples be stored in resources block .

Input assembler may retrieve one or more vertices from resources block form geometry e.g. primitives based on the vertices and issue the vertices to vertex shader for further processing. Input assembler may also generate one or more system generated values for each of the vertices and supply the system generated values to vertex shader and or geometry shader . For example input assembler may generate vertex identification values that uniquely identify each of the vertices in a particular draw call and supply the vertex identification values to vertex shader and or geometry shader . As another example input assembler may generate primitive identification values that uniquely identify each of the primitives in a particular draw call and supply the primitive identification values to geometry shader .

Vertex shader may generate output vertices based on the vertices received from input assembler and based on a vertex shader program. From a programming perspective in order to generate the output vertices vertex shader may execute a respective instance of the vertex shader program for each of the vertices that are received from input assembler . In some examples the vertex shader program may perform per vertex processing on the input vertices to generate the output vertices. Per vertex processing may refer to processing that is performed independently for each of the vertices that are processed. Per vertex processing may include for example performing vertex transformations performing lighting operations performing fog operations performing vertex shading etc.

Geometry shader may generate output primitives based on input primitives that are received by geometry shader and based on a geometry shader program. The input primitives that are received by geometry shader may be formed based the output vertices that are generated by vertex shader . From a programming perspective in order to generate the output primitives geometry shader may execute a respective instance of the geometry shader program for each of the primitives that are received by geometry shader . In some examples the geometry shader program may perform per primitive processing on the input primitives to generate the output primitives. Per primitive processing may refer to processing that is performed independently for each of the primitives that are processed. Per primitive processing may include for example adding or deleting vertices adding or deleting the number of primitives that are output by geometry shader for each input primitive etc.

Rasterizer may generate source pixels or source samples based on the primitives received from geometry shader . For example for each of the primitives received from geometry shader rasterizer may rasterize the primitive to generate a plurality of source pixels that correspond to the primitive. Rasterizing a primitive may involve for example performing scan conversion on the primitive to determine which pixels correspond to the primitive and or interpolating attributes for the pixels that correspond to a primitive based on the attributes of the vertices of the primitive.

Stencil unit may receive the output from rasterizer and perform a stencil test on the outputted samples. As describe in more detail in the techniques described in this disclosure stencil unit may discard one or more samples outputted by rasterizer that fail the stencil test and maintain the samples outputted by rasterizer that pass the stencil test.

Pixel shader may generate output source pixels based on input source pixels received from stencil unit and based on a pixel shader program. By discarding samples prior to the pixel shader stage of GPU that includes pixel shader the number of instances of execution of pixel shader may be reduced. From a programming perspective in order to generate the output source pixels pixel shader may execute a respective instance of the pixel shader program for each of the pixels that are received from stencil unit . In some examples the pixel shader program may perform per pixel processing on the input source pixels to generate the output source pixels. Per pixel processing may refer to processing that is performed independently for each of the pixels that are processed. Per pixel processing may include for example performing pixel shading performing texture mapping etc.

Depth test unit receives the output from pixel shader and determines which pixels are occluded. Depth test unit culls out the occluded pixels and output the visible pixels to output merger .

Output merger may generate destination pixels based on the source pixels received from depth test unit . In some examples output merger may merge each of the source pixels received from depth test unit with a corresponding destination pixel stored in a render target to generate an updated version of the corresponding destination pixel. A destination pixel may correspond to a source pixel if the destination pixel has the same pixel location in the render target as the pixel location of the source pixel. To merge the source pixels with destination pixels output merger may perform one or more of a blending operation a compositing operation and a raster operation with respect to the source and destination pixels to be merged.

The resulting destination pixels are stored in a render target which in some examples may be a frame buffer. The render target may form part of resources block . The data stored in the render target may correspond to a rasterized composited version of the primitives received by graphics pipeline .

In some examples graphics pipeline may implement all or a part of the stochastic rasterization described in this disclosure. For example rasterizer may include a stencil test block that is configured to perform any of the stencil tests described in this disclosure. As another example a stencil test block may be located between rasterizer and pixel shader e.g. stencil unit illustrated in in graphics pipeline that is configured to perform any of the stencil tests described in this disclosure. For ease of description the techniques are described with respect to stencil unit performing functions of the stencil test but such techniques may be part of rasterizer .

For example rasterizer and or a stencil test block e.g. stencil unit may be configured to selectively discard samples from graphics pipeline of GPU prior to the samples arriving at a pixel shader stage e.g. pixel shader of the pixel processing pipeline based on values stored in a stencil buffer e.g. stencil mask . The values stored in the stencil buffer may be determined based on a stochastic sampling pattern. As described above by selectively discarding samples prior to the pixel shader stage of the pixel processing pipeline the number of samples processed by the pixel shader stage may be reduced thereby avoiding a large number of unnecessary invocations of pixel shader . In this way the performance of GPU when performing stochastic rasterization may be improved.

In some examples one or more programmable processing stages of graphics pipeline e.g. geometry shader may perform one or more aspects of this disclosure. For example geometry shader may generate bounding polygons for primitives and or clusters of primitives. As another example geometry shader may partition a bounding polygon into a plurality of bounding polygon partitions and determine time intervals for each of the bounding polygon partitions. As a further example geometry shader may subdivide a timeline into a plurality of segmented time intervals. In additional examples geometry shader may provide primitive specific reference values to a stencil test block in rasterizer or to a stencil test block in another portion of graphics pipeline for use in performing a stencil test.

However in the techniques described in this disclosure rather than utilizing a single bounding polygon geometry shader may determine a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame. In these examples each bounding polygon covers a portion of the animation timeline and the animation timeline corresponds to a movement of the one or more primitives.

For example illustrates a single bounding polygon that covers the entire animation timeline of the illustrated triangle from a first frame represented by the triangle on the left end to a second frame represented by the triangle on the right end . together illustrate a plurality of bounding polygons that together cover the animation timeline illustrated in . For instance illustrates one bounding polygon that covers a portion of the animation timeline e.g. the first half of the animation timeline and illustrates another bounding polygon that covers a another portion of the animation timeline e.g. the second half of the animation timeline .

In some examples geometry shader may determine the bounding polygons illustrated in based on information received from CPU . Also geometry shader is described as determining the plurality of bounding polygons because geometry shader outputs to rasterizer . However in examples where geometry shader does not exist some upstream shader e.g. vertex shader may be configured to determine the plurality of bounding polygons. It may even be possible for some other shader to determine the plurality of bounding polygons even in examples where geometry shader forms part of graphics pipeline .

Rasterizer may be configured to determine temporal values for samples within each of the bounding polygons e.g. bounding polygons illustrated in based on a sampling pattern. For instance a control unit e.g. a unit that forms part of resources block may be configured to load a stochastic sampling pattern into a stencil buffer and repeat the sampling pattern across the stencil buffer. As an example the control unit may load the stochastic sampling pattern illustrated in and repeat the stochastic sampling pattern across the stencil buffer.

The size of the stencil buffer may equal the size of the frame to be displayed and the stochastic sampling pattern may be a relatively small tile that is smaller than the size of the frame to be displayed e.g. 8 8 as illustrated in . Accordingly to fill the stencil buffer the control unit may repeat the stochastic pattern until the stencil buffer is full. In general GPU may load a stochastic sampling pattern and determine values of a stencil buffer based on the stochastic sampling pattern. One way in which GPU may determine values of the stencil buffer is by repeating the stochastic sampling pattern. There may be other ways in which GPU may determine values of the stencil buffer based on the stochastic sampling pattern and repeating the stochastic sampling pattern is provided merely as one example way.

Rasterizer may determine the temporal values of each sample in bounding polygons based on the values stored in the stencil buffer. For example each storage location in the stencil buffer corresponds to a location in the frame e.g. storage location in the stencil buffer corresponds to location in the frame . Based on a location of a sample in the bounding polygon rasterizer may be able to determine its value based on the corresponding location in the stencil buffer. In other words a temporal value of a sample equals a value in a storage location of the stencil buffer that corresponds to a location of the sample in the bounding polygon.

In accordance with example techniques described in this disclosure prior to samples of respective bounding polygons being processed by pixel shader stencil unit may determine which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons. For example stencil unit may receive threshold conditions for each of the bounding polygons and based on the threshold condition determines which samples should be further processed.

Stencil unit may determine which samples of the first bounding polygon are to further processed by comparing the temporal values within the first bounding polygon e.g. as determined from the stencil buffer to a first threshold condition e.g. temporal values less than or equal to 0.5 . For example stencil unit may perform a stencil test to compare values in the stencil buffer that correspond to the first bounding polygon to the threshold condition for the first bounding polygon and determine which samples within the first bounding polygon are to be further processed based on the stencil test.

In stencil unit may discard a first set of samples from the first bounding polygon and maintain a second set of samples from the first bounding polygon based on the determination of which samples are to be further processed. For example stencil unit may discard a first set of samples of the first bounding polygon having a temporal value greater than 0.5 and maintain for further processing a second set of samples of the first bounding polygon having a temporal value less than or equal to 0.5.

One or more instances of pixel shader may execute to process the second set of samples in the first bounding polygon e.g. to add motion blur . For example pixel shader may determine which samples of the second set of samples of the first bounding polygon are to be shaded based on if sample is inside of primitive at the temporal position. Pixel shader may shade one or more samples of the second set of samples in the first bounding polygon based on the determination e.g. determine color values for the one or more samples . For example pixel shader may apply bilinear interpolation to determine relative coordinates of a sample within the primitive at the temporal position and determine color values or texture for the sample based on the determined coordinates to shade the sample e.g. determine color . There may be various ways in which to pixel shader may shade a particular sample and the techniques described in this disclosure are not limited to any particular example.

It should be understood that it is possible although the chances are drastically reduced that there may still be some unnecessary invocations of pixel shader . For example for a sample having a temporal value of 0.2 pixel shader would execute for such as sample as it would have passed the stencil test. However if this sample is not located in a time instance corresponding to 0.2 in the first bounding polygon the sample will be discarded. Accordingly even though there may be some extra execution of pixel shader because many samples are discarded prior to pixel shader the extraneous invocations of pixel shader may be reduced.

Similarly illustrates a second bounding polygon that covers the second half of the animation timeline e.g. from 0.5 to 1 . This means that only samples having temporal value greater than 0.5 can possibly be rendered in the second bounding polygon. However it may be possible that there are samples within the second bounding polygon that have temporal values less than or equal to 0.5 e.g. due to the randomness of the stochastic sampling pattern . Accordingly a second different threshold condition i.e. different than the threshold condition for the first bounding polygon may be that only samples having temporal values greater than 0.5 should be maintained in the second bounding polygon and samples having temporal values less than or equal to 0.5 should be discarded from the second bounding polygon.

As with the first bounding polygon stencil unit may determine which samples of the second bounding polygon are to further processed by comparing the temporal values within the second bounding polygon e.g. as determined from the stencil buffer to a second threshold condition e.g. temporal values greater than 0.5 . For example stencil unit may perform a stencil test to compare values in the stencil buffer that correspond to the second bounding polygon to the threshold condition for the second bounding polygon and determine which samples within the second bounding polygon are to be further processed based on the stencil test.

In stencil unit may discard a first set of samples from the second bounding polygon and maintain a second set of samples from the second bounding polygon based on the determination of which samples are to be further processed. For example stencil unit may discard a first set of samples of the second bounding polygon having a temporal value less than or equal to 0.5 and maintain for further processing a second set of samples of the second bounding polygon having a temporal value greater than 0.5.

Similar to above one or more instances of pixel shader may execute to process the second set of samples in the second bounding polygon e.g. to add motion blur . For example pixel shader may determine which samples of the second set of samples of the second bounding polygon are to be shaded based on a location of the second set of samples within the second bounding polygon. Pixel shader may shade one or more samples of the second set of samples in the second bounding polygon based on the determination e.g. determine color values for the one or more samples .

Again it should be understood that it is possible although the chances are drastically reduced that there may still be some unnecessary invocations of pixel shader . For example for a sample having a temporal value of 0.8 pixel shader would execute for such as sample as it would have passed the stencil test. However if this sample is not located in a time instance corresponding to 0.8 in the second bounding polygon the sample will be discarded. Accordingly even though there may be some extra execution of pixel shader because many samples are discarded prior to pixel shader the extraneous invocations of pixel shader may be reduced.

In this example the animation timeline is broken in halves with there being two bounding polygons. Stencil unit may run stochastic sampling for each bounding polygon with corresponding stencil settings. One stencil setting may be the first threshold condition for the first bounding polygon e.g. less than or equal to 0.5 and another stencil setting may be the second threshold condition for the second bounding polygon e.g. greater than 0.5 . Due to the random but even distribution of the temporal values approximately half of the samples may be discarded by stencil unit before reaching pixel shader thereby almost doubling the rate of valid samples i.e. samples that are further processed .

In the above example the single bounding polygon was divided into two. However the techniques described in this disclosure are not so limited. In some examples for long bounding polygon geometry shader may determine more segments of the single bounding polygon e.g. more than two bounding polygons . For these multiple bounding polygons each may have a different threshold condition. For instance if there are ten bounding polygons then the threshold condition for the first bounding polygon may be 0 temporal value 0.1 for the second bounding polygon 0.1 temporal value 0.2 and so forth until 0.9 temporal value 1. In general the different threshold conditions may be based on the time instances covered by a bounding polygon. For instance the first bounding polygon covers the time instances from 0 to 0.1 and therefore the first threshold condition is 0 temporal value 0.1 the second bounding polygon covers the time instances from 0.1 to 0.2 and therefore the second threshold condition is 0.1 temporal value 0.2 and so forth.

Having more segments may provide even better rate of valid samples. In some examples whether a bounding polygon is considered long or not may be based on the size of the static primitive. In other words the number of segments that a bounding polygon is divided into e.g. the number of bounding polygons in the plurality of bounding polygons may be based on the size of the one or more primitives and the velocity the primitives have.

In some examples stencil unit and the stencil buffer may be specialized to implement the techniques described in this disclosure. For instance stencil unit and the stencil buffer may be configured to have different threshold conditions also referred to as a reference value s for different bounding polygons where in some examples the different threshold conditions are determined by geometry shader and outputted to stencil unit . To achieve this geometry shader may utilize gl StencilRefVal1 gl StencilRefVal2 as two API extensions for enhanced stencil operation to define a threshold condition e.g. for condition 0 temporal value 0.5 0 is StencilRefVal1 and 0.5 is StencilRefVal2 . The stencil comparison mode may still be global. In this way in performing the stencil test to compare values in the stencil buffer that correspond to the bounding polygon of the plurality of bounding polygons to the threshold condition for that bounding polygon stencil unit may determine whether values in the stencil buffer that correspond to the bounding polygon are greater than a first threshold value e.g. 0 and less than a second threshold value e.g. 0.5 .

Moreover as described above the stochastic sampling pattern may be a small tile e.g. 8 8 or 32 32 . Therefore only small stencil tile may be needed but the stencil buffer would need to be filled with values. This may be achieved by repeating the stencil tile but other ways may be possible.

Furthermore as described above the techniques described in this disclosure leverage a stencil test performed by stencil unit to discard samples of the bounding polygon. In some graphics pipelines a depth test and the stencil test are performed together on samples such as where there is an early z test and a late depth test . However because the stencil test is being utilized for discarding samples from a bounding polygon the late depth test may need to be separated from the stencil test. Accordingly illustrates depth test unit after pixel shader . For example depth test unit may perform a depth test separate from performing stencil unit performing the stencil test and may perform the depth test after the execution of the one or more instances of pixel shader . For instance depth test unit functions after pixel shader because pixel shader may modify depth values.

The following describes some example ways in which to implement example techniques described in this disclosure. It should be understood that these implementation examples are provided merely to assist with understanding and should not be considered as limiting.

For example in only one interval is illustrated. In two intervals are illustrated allowing for two bounding polygons. In four intervals are illustrated allowing for four bounding polygons.

In some examples the movement of the primitive may appear as if it coming towards the viewer or away from the viewer. One way for the viewer to perceive the movement of the primitive towards or away from is to increase or decrease the size of the primitive because of perspective projection.

For example geometry shader may determine a first bounding box that extends from 0 to 0.35. Geometry shader may also determine a second bounding box that extends from 0.30 to 0.70. Accordingly the first bounding box and the second bounding box may overlap in time. Geometry shader may similarly determine the third bounding box from 0.65 to 1.

Geometry shader determines range of time instances for each bounding polygon segment using a bounding box intersection algorithm. For example is a conceptual diagram illustrating a bounding polygon segment and corresponding bounding box. demonstrates the intersection of dynamic bounding box of primitive at time instance t and t with bounding box of original bounding polygon segment in .

As indicated in the example of the orientation of the primitive changes as it moves this in turn may cause the bounding polygon to alter in linear motion as well. For example is a conceptual diagram illustrating the movement of a primitive. In dynamic bounding box that covers a time instance of each of a plurality of time instances of the primitive is illustrated.

Geometry shader may utilize the linear motion of the primitive to determine the bounding box at any time instance along the animation timeline e.g. to determine the bounding box for each time instance illustrated in . For example let the time instance be defined by variable t where t is between 0 and 1. Each bounding box that covers a primitive at time instance t is given by a minimum and maximum x value and a minimum and maximum y value. The minimum and maximum x and y values for any given time instance t is based on the velocity and or rotation of the primitive.

In general the linear motion of the primitive may lead to the linear motion of dynamic bounding box that covers the primitive to change e.g. the size and location of the bounding box may change . The equation for the minimum and maximum coordinates of dynamic bounding box for a given time instance t may be given as x a t b x a t b y a t b and y a t b. In this example a b a b a b a and bare all constant parameter values calculated based on the velocity of each vertex of the primitive where the velocity information is provided by the application executing on CPU . Accordingly with the above example geometry shader may determine size and location of dynamic bounding box that covers each time instance of a primitive.

In this way the dynamic bounding box may be conservative even when vertices have different velocities. In other words if the vertices of the primitive have different velocities than the primitive may change in size and or orientation. However even for such a case the dynamic bounding box may cover the minimum area needed to encompass the time instance of the primitive e.g. the bounding box is conservative .

In the above examples GPU is described as determining bounding polygons for one primitive. However the techniques described in this disclosure are not so limited. For example geometry shader may determine a bounding polygon for a cluster of primitives. In this way geometry shader may use a cluster of primitives to avoid overlapping of too many bounding polygons for each of primitives. For example as described above with respect to for neighboring primitives there may be multiple overlapping bounding polygons one for each primitive especially if the primitives moved along generally the same animation timeline.

For example a shader e.g. geometry shader of GPU may determine a plurality of bounding polygons that together cover an animation timeline of one or more primitives from a first frame to a second frame . Each bounding polygon covers a portion of the animation timeline and the animation timeline corresponds to a movement of the one or more primitives. The one or more primitives may be a single primitive in some cases or a cluster of primitives in some cases.

In some examples the shader may determine the plurality of bounding polygons based on information received from CPU . Also in some examples the shader may determine a single bounding polygon that covers the entire animation timeline and segment the single bounding polygon to generate the plurality of bounding polygons but portions of two bounding polygons may overlap. In some examples the shader may segment the animation timeline into a plurality of timeline segments where each of the timeline segments form the animation timeline. In these examples the shader may determine the plurality of bounding polygons based on the plurality of timeline segments.

GPU via rasterizer may determine temporal values for samples within each of the bounding polygons based on a sampling pattern . For example GPU may load a stochastic sampling pattern and determine values of a stencil buffer based on the stochastic sampling pattern. As one example GPU may repeat the stochastic sampling pattern in the stencil buffer until each storage location of the stencil buffer is stores a value. In the techniques described in this disclosure a temporal value of a sample equals a value in a storage location of the stencil buffer that corresponds to a location of the sample in the bounding polygon. Based on this association of values in the stencil buffer to locations in the frame rasterizer may determine the temporal values for samples in each of the bounding polygons.

Prior to samples of respective bounding polygons being processed by pixel shader of graphics pipeline of GPU stencil unit may determine which samples within respective bounding polygons are to be further processed based on temporal values for the samples within respective bounding polygons and respective different threshold conditions for each of the respective bounding polygons . For example stencil unit may perform a stencil test to compare values in the stencil buffer that correspond to the bounding polygon of the plurality of bounding polygons to the threshold condition for that bounding polygon. Stencil unit may determine which samples within the bounding polygon are to be further processed based on the stencil test. In some examples to perform the stencil test stencil unit may determine whether values in the stencil buffer that correspond to the bounding polygon are greater than a first threshold value and less than a second threshold value.

Stencil unit may discard from further processing a first set of the samples within a bounding polygon of the plurality of bounding polygons and maintain a second set of the samples within the bounding polygon of the plurality of bounding polygons based on the determination from a threshold condition for that bounding polygon of which samples within the bounding polygon are to be further processed .

GPU may execute one or more instances of pixel shader to process the second set of samples of the bounding polygon . In some examples GPU may also store the stochastic sampling pattern in a texture buffer e.g. in addition to the stencil buffer . The one or more instances of pixel shader may retrieve the temporal values for the second set of samples from the texture buffer to determine whether a time instance of the one or more primitives covers the samples. In this way storage of the stochastic sampling pattern in the stencil buffer allows for a stencil test to discard samples that will not be further processed prior to execution of one or more instances of pixel shader and storage of the stochastic sampling pattern in the texture buffer allows for pixel shader for further processing of the samples.

The one or more instances of pixel shader may execute to add motion blur to the second frame as part of stochastic rasterization so that the viewer perceives the object formed from the one or more primitives as moving smoothly rather than hopping. In some examples the executing of the one or more instances of pixel shader may include determining which samples of the second set of samples are to be shaded based on a location of the second set of samples within the bounding polygon and shading e.g. determining color one or more samples of the second set of samples based on the determination.

In some examples the techniques of this disclosure provide one or more relatively fast stochastic rasterization algorithms that may use enhanced stencil operations on a GPU. Motion blur has received a lot of attention. Motion blur may be used for eliminating temporal aliasing e.g. hopping in animation.

Full sampling methods may either be too slow for real time graphics. Stochastic sampling may be feasible on current graphics hardware but performing stochastic rasterization is still expensive. For each primitive the rate of valid samples is typically low and there may be a large amount overlapping between bounding polygons of primitives. The low rate of valid samples and the overlapping may result in wasted computation in the fragment shader e.g. pixel shader .

In some examples the techniques of this disclosure may use an enhanced stencil operation in GPU hardware. In further examples the techniques of this disclosure may implement a variety of software algorithms to speed up motion blur on small triangles.

According to a first example a software algorithm may break a timeline into segments and drop invalid samples in the rasterizer for each segment. According to a second example a software algorithm may partition a bounding polygon and calculate corresponding time intervals for the rasterizer to drop invalid samples. According to a third example a software algorithm may group primitive into clusters and apply either first example algorithm or the second example algorithm with bounding boxes. In some examples the techniques of this disclosure may provide one or more shader application programming interface API extensions to expose aspects of this disclosure to graphics programmers.

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. In some examples the computer readable medium may be a non transitory computer readable storage medium. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

