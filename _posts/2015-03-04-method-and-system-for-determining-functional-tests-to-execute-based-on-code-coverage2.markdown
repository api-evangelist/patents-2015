---

title: Method and system for determining functional tests to execute based on code coverage
abstract: Techniques are disclosed for automatically determining tests to run on source code based on code coverage. In one embodiment, an extensible system takes as input a configuration file having pointers to an IP address of a server where tests are being run and a type of code coverage instrumentation. An agent configured to instrument source code and collect code coverage information is copied to the server at the IP address. During a training phase, the agent intercepts tests being run on source code and provides a dump of the interception results after each test is executed. Using such results, mappings of the tests to the source code is created and stored. During an execution phase, when new or modified source code file is being checked in, a testing application retrieves for execution tests which map to the source code file and to code dependent on the source code file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09639453&OS=09639453&RS=09639453
owner: VMware, Inc.
number: 09639453
owner_city: Palo Alto
owner_country: US
publication_date: 20150304
---
Software testing is commonly used to ensure that software is stable and functions as expected among other things. When a source code file is checked in to a source control system that merges working copies of code referred to as branches the system may build software from the source code and run tests on the software that is built. However such tests are typically high level static tests that have no relevance to the particular source code that was checked in. As a result the testing may not be targeted to the checked in code and hence provides a lower level of guaranteed stability on a given branch.

One embodiment provides a computer implemented method for testing source code. The method generally includes intercepting tests run on a first version of source code to determine the tests being run and code coverage from running the tests and storing mappings of the determined tests to the first version of the source code and the determined code coverage in a database. The method further includes upon a second version of the source code being checked in determining a set of tests to run on the second version of the source code and code that is dependent on the second version of the source code based on stored mappings and code coverage information in the database. In addition the method includes running the determined set of tests on the second version of the source code and the dependent code.

Further embodiments of the present invention include a non transitory computer readable storage medium storing instructions that when executed by a computer system cause the computer system to perform the method set forth above and a computer system programmed to carry out the method set forth above.

Embodiments presented herein provide techniques for automatically determining tests to run on source code based on code coverage. As used herein code coverage refers to the degree to which source code e.g. a percentage or number of lines of the source code is tested by a software test. One embodiment provides an extensible system that takes as input a configuration file including pointers to an IP address of a server where tests are run by a quality engineer QE on a type of code coverage instrumented product binary among other things. An agent that is configured to interpret the type of code coverage instrumentation and collect code coverage information is then copied over to the server at the IP address. As the QE runs tests on source code the agent quietly intercepts the testing collects the code coverage information to map each test to corresponding source code and provides the mappings and associated code coverage results to a learning system where the mappings and code coverage information may be persisted in a database. The code coverage information may be provided at for example the source code file level of granularity e.g. test X maps to files A B C or at the source code line level of granularity e.g. test Y maps to lines AA BB CC of file A .

When a new or modified source code file is checked in a testing application queries the database to retrieve a list of tests relevant to the source code file or specific lines of code or methods etc. if tests are mapped to lines of code or methods etc. and code that is dependent on the source code file. That is a reverse mapping of the source code file and dependent code to tests is used to identify relevant tests to run based on the mappings of tests to source code stored in the database. If too many relevant tests are identified then adequate code coverage may be obtained without running all relevant tests and the testing application may limit the number of tests to run according to a blacklist. Conversely if no relevant tests or too few relevant tests are identified then the testing application may add one or more default tests specified in a whitelist to improve code coverage. The testing application then runs the tests on the source code being checked in and the dependent code.

Reference will now be made in detail to several embodiments examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality. The figures depict embodiments for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and method illustrated herein may be employed without departing from the principles described herein.

During an initial learning phase agent that is copied to testing system and runs therein to intercept tests being performed and to determine code coverage. In one embodiment a code coverage instrumentation tool e.g. JaCoCo may instrument the source code either through static instrumentation performed on binary files that are then compiled or dynamic instrumentation of code that is loaded in memory. As tests are being run the instrumented instructions provide e.g. counters indicating the number of times particular lines of code methods etc. have been executed. Agent is configured to interpret such instrumentation and determine based on e.g. the counter values which lines or methods of the source code are executed also referred to as code coverage. For example the counters in the instrumented code may indicate that a particular line of code was executed three times or a particular function was executed five times during testing. Agent is responsible for understanding what the two and five times means and changing this information into a format namely a mapping between the test and portions of source code that is then persisted in database . Agent may also be configured to determine other information such as cyclomatic dependency indicating the number of decision points in the tests that are executed . It should be understood that different code coverage instrumentation tools may be employed and each code coverage instrumentation tool may instrument the code differently and employ different communication protocols. In one embodiment agent is able to interpret instrumentation by a variety of code coverage instrumentation tools with the particular type of code coverage instrumentation to interpret being specified in configuration file as discussed above. Alternatively different types of agents capable of interpreting respective coverage instrumentations may be copied to the IP address of testing system based on the code coverage instrumentation tool type specified in configuration file .

After each test is run agent maps portions of the source code indicated by the code coverage instrumentation to the test and reports the mapping to testing application . For example if test A were run on source code file X agent may generate a dump of code coverage instrumentation results showing that test A affected particular lines or methods in source code file X. Testing application may then store the mapping of test A to file X or the particular lines or methods in file X and the associated code coverage information in database . It should be understood that the mapping need not be relearned each time the test is run on the source code and testing application may instead monitor learned tests and only relearn tests that have changed. That is new tests or modified tests may be learned at a delta level.

During an execution phase after the learning phase testing application polls a continuous integration system e.g. Perforce revision control system to determine if a new version of a source code file is being checked in. Such a source code file may be a new file or an existing file that has been modified by a developer. In one embodiment the source code may be tested in a pre check in step prior to actually checking in the code to a branch to ensure that the branch is not destabilized by untested code. Upon determining that a new version of a source code file is being checked in testing application automatically retrieves a list of tests relevant to the source code file by querying database for tests which map to the source code file if any. That is testing application reverse maps the source code file or lines of code to relevant tests based on the mappings stored in the database . Relevant tests may include tests satisfying any feasible criteria such as tests having some desired code coverage or cyclomatic dependency score. Testing application then runs the relevant tests.

In addition testing application may retrieve tests relevant to source code which depends on the new version of the source code file. It should be understood that only running tests on the source code being checked in may be insufficient as application programming interfaces APIs within such source code may be used by other dependent code. To provide the best possibility of branch stability the dependent code may also be tested using relevant tests.

In another embodiment a blacklists and or whitelist may be employed to limit or increase the number of tests that are run respectively. When too many relevant tests are identified then adequate code coverage may be achieved by running a subset of the relevant tests and testing application may limit the number of tests that are run according to the blacklist. For example the blacklist may specify that when a file is touched by greater than 80 of the total tests then a subset of those tests needed to reach 100 code coverage or some fixed number e.g. 10 of tests with the greatest code coverage should be used. Conversely if no relevant tests or too few relevant tests are identified then the testing application may add default tests specified in a whitelist to improve code coverage.

At step agent intercepts testing of source code in testing system and determines code coverage. As discussed a code coverage instrumentation tool may instrument the source code either through static instrumentation performed on binary code files before compilation or dynamic instrumentation of code that is loaded in memory to collect code coverage information. During testing the instrumented instructions trace which portions of the code are being executed and provide e.g. counters indicating the number of times particular lines of code methods etc. have been executed so that agent can determine the portions of code that are touched by the testing i.e. the code coverage. After each test is run and agent gathers code coverage information for that test agent sends a signal e.g. a TCP IP message reporting the gathered information and the test run to testing application . This process is repeated after each test is run so that the test to source code mapping is clear.

At step agent transmits mappings of tests to source code determined based on the code coverage to testing application for storage in database . Testing application may then store the mappings of tests to source code provided by agent in database . As discussed information on code coverage is gathered for each test and reported by agent to testing application . As a result testing application is aware of the tests that have been run on each source code file as well as the code coverage of those tests. The mapping of source code to tests that is determined and stored may be at e.g. the source code file level of granularity or at the source code line level of granularity. At the source code file level source code files may be mapped to the test s executed on the files. At the source code line level particular lines of the source code may be mapped to test s executed on those lines. Such mappings as well as the code coverage information specifying the degree to which the source code files or lines are tested by each test are persisted in database for later use in testing new or modified source code as such code is checked in.

At step testing application determines dependents of the source code being checked in. As previously noted only running tests that affect the source code being checked in may be insufficient so testing application may crawl through the source code to store dependent application programming interfaces APIs within such source code that may be used by other dependent source code. To provide the best possibility of branch stability tests should and can also be run on the dependent source code as well.

In one embodiment dependent code may be identified as classes which import a class in the source code being checked in. In another embodiment functional dependencies in the source code may be provided in a heat map that the testing application then uses to identify dependent code.

At step testing application retrieves a list of tests relevant to the source code and dependent source code from database . As discussed database is populated with mappings of source code to tests and associated code coverage during a learning phase with the mappings being at e.g. the source code file method or source code line level of granularity. Testing application may then query database to retrieve the list of relevant tests which map back to the source code as well as code coverage associated with those tests.

It should be understood that not all tests mapping to the source code and the dependent code need to be retrieved. Testing application may instead query for relevant tests matching any feasible criteria such as having some desired code coverage or cyclomatic dependency score.

At step testing application determines whether there are too many relevant tests. There may be too many relevant tests if a large number of tests were previously run on the source code being checked in and the mappings of these tests to the source code were then stored in database . For example thousands of tests may be relevant to a common source code file and it may take an unacceptable amount of time to run all of those tests.

In one embodiment whether there are too many relevant tests may be determined based on criteria specified in a blacklist. Such a blacklist may be included in the configuration file discussed above.

If there are too many relevant tests then at step testing application selects a subset of the relevant tests based on the blacklist. As discussed the blacklist may be added to configuration file by a user and specifies the tests to run when too many relevant tests are identified. In one embodiment the blacklist may specify that a given number of tests or tests providing a given code coverage percentage should be run. For example the blacklist may specify e.g. that when a file is touched by greater than 80 of the total tests then a subset of those test needed to reach 100 coverage or some fixed number e.g. 10 of tests with the greatest code coverage should be used.

If there are not too many relevant tests then testing application further determines at step whether there are too few relevant tests. There may be too few relevant tests if e.g. a new source code file is checked in that is not yet mapped to any tests or a source code file mapping to very few tests is checked in. In such cases tests other than the relevant tests determined from mappings in database may need to be run to provide sufficient code coverage.

If there are too few relevant tests then testing application adds a set of default tests at step based on a whitelist. Similar to the blacklist the whitelist may be added to configuration file by a user. Such a whitelist may specify the set of default tests to run when there are too few relevant tests for the source code.

At step testing application runs the determined tests. As discussed these tests may include tests relevant to the source code a subset of the relevant tests specified by a blacklist and or default tests from a whitelist. Results of the testing may then be displayed to a user through a user interface UI listing e.g. the tests that were run the percentage coverage achieved results of the testing and the like.

CPU retrieves and executes programming instructions stored in the memory . Similarly CPU stores and retrieves application data residing in the memory . Interconnect facilitates transmission such as of programming instructions and application data between CPU I O device interface storage network interface and memory . CPU is included to be representative of a single CPU multiple CPUs a single CPU having multiple processing cores and the like. And memory is generally included to be representative of a random access memory. Storage may be a disk drive storage device. Although shown as a single unit storage may be a combination of fixed and or removable storage devices such as fixed disc drives floppy disc drives tape drives removable memory cards or optical storage network attached storage NAS or a storage area network SAN . Further system is included to be representative of a physical computing system as well as virtual machine instances hosted on a set of underlying physical computing systems. Further still although shown as a single computing system one of ordinary skill in the art will recognized that the components of system shown in may be distributed across multiple computing systems connected by a data communications network.

As shown memory includes an operating system and testing application . In one embodiment testing application may be configured to in conjunction with agent automatically learn mappings of source code to tests and persist such mappings in a database according to the method discussed above. In addition testing application may identify when new versions of source code are being checked in determine dependent code and retrieve and run one or more relevant tests based on the mappings which have been stored in the database according to the method discussed above.

Advantageously techniques disclosed herein map tests to source code so that when a source code file is checked in after modification a reverse mapping can be used to automatically retrieve tests to run for the source code file and other source code dependent on it. Doing so permits e.g. a set of tests with desired code coverage and that runs in a short period of time to be used. Further techniques disclosed herein are extensible in the sense that the agent is able to interpret different types of code coverage instrumentation and create the mappings of tests to source code. The particular type of code coverage instrumentation used simply needs to be specified in a configuration file. In addition a blacklist may be employed where a source code file or line of source code maps to too many tests providing repeated coverage to reducing the number of tests that are run. Conversely where the source code file or line maps to no tests or too few tests a set of default tests specified in a whitelist may be run to provide some code coverage.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Many variations modifications additions and improvements are possible. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

