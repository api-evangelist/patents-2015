---

title: Mechanism for class data sharing using extension and application class-loaders
abstract: The present disclosure involves systems, methods, and/or computer-readable mediums for reducing load time of an application. The systems, methods, and/or computer-readable mediums store metadata in an archive prior to execution of an application. The metadata corresponds to a type of class loading operation used to load a class required by the application, where different types of class loading operations perform different security checks as a part of loading classes. During execution of the application, based on the metadata and based in part on a request for the class loading operation to load the class, it is determined whether the class is stored in the archive. When the class is stored in the archive, a particular type of class loading operation loads the class from the archive and the system checks that the particular type of the class loading operation matches the type of the class loading operation in the metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09336018&OS=09336018&RS=09336018
owner: ORACLE INTERNATIONAL CORPORATION
number: 09336018
owner_city: Redwood City
owner_country: US
publication_date: 20150227
---
This application claims priority under 35 U.S.C. 119 from U.S. provisional application No. 61 988 044 entitled MECHANISM FOR CLASS DATA SHARING USING EXTENSION AND APPLICATION CLASS LOADERS filed on May 2 2014 the entire contents of which are fully incorporated by reference herein for all purposes.

Aspects of the present disclosure relate to class loading during execution of a software application and more specifically a mechanism for archiving and reusing class metadata while still preserving class loader context to enable faster class loading and support memory sharing by multiple processes.

A programming language is a formal constructed language designed to provide communicate instructions to a machine particularly a computer. A typical programming language includes a vocabulary and set of grammatical rules for instructing the machine to perform specific tasks. Typically a programming language is used to generate a software program that controls the behavior of the machine to express algorithms or otherwise to cause the machine to perform some function or functions. Well known programming languages include Java Javascript PHP C Python C SQL and Objective C.

Programming languages may use class loaders to load class files or other code containing objects for execution. For example the Java language uses a class loading mechanism to dynamically load class files of an application into the Java Virtual Machine during runtime. Loading classes from the extension and application classpath is a heavy weight process i.e. computationally intensive that typically requires multiple classpath searches JAR file lookups class verification etc. In a typical Java application environment the total time required to perform class loading may negatively impact overall application start up time.

Class Data Sharing is a process that was implemented to resolve such start up time issues by archiving loaded class metadata into a re mappable form before the execution of an application. However Class Data Sharing does not allow classes from the extension and application classpath to be stored in the archive without violating class loader context and Java semantics which can cause incorrect runtime behavior and security vulnerability.

Various examples described herein may use example terminology that coincides with terminology used for the Java programming language. Unless otherwise specified such terminology is intended to be language generic based on functional characteristics rather than implying any characteristics that are unique to the Java ecosystem. For example a class is any named section of software code that can be invoked including but not limited to a function a method a procedure an object and a Java class i.e. class is not required to be a Java class . As another example a class loader is any mechanism for loading a class prior to or during execution of code i.e. a classloader is not required to be a Java classloader . In yet another example a classpath is a parameter set either on the command line or through an environment variable that tells a computing environment and or compiler such as the Java virtual machine or the Java compiler where to look for user defined classes.

Aspects of the present disclosure include methods for reducing load time of an application. The method includes prior to execution of an application storing metadata in an archive the metadata corresponding to a class loading operation used to load a class required by the application wherein the metadata identifies a type of the class loading operation and wherein different types of class loading operations perform different security checks as a part of loading classes. The method further includes during execution of the application based at least in part on a request for the class loading operation to load the class determining based on the metadata whether the class is stored in the archive. When the class is stored in the archive loading by a particular class loading operation of a particular type the class from the archive and checking that the particular type of the class loading operation matches the type of the class loading operation in the metadata.

Other aspects of the present disclosure include non transitory computer readable medium encoded with instructions for reducing load time of an application. The instructions are executable by a processor or computing device. The instructions include prior to execution of an application storing metadata in an archive the metadata corresponding to a class loading operation used to load a class required by the application wherein the metadata identifies a type of the class loading operation and wherein different types of class loading operations perform different security checks as a part of loading classes. The method further includes during execution of the application based at least in part on a request for the class loading operation to load the class determining based on the metadata whether the class is stored in the archive. When the class is stored in the archive loading by a particular class loading operation of a particular type the class from the archive and checking that the particular type of the class loading operation matches the type of the class loading operation in the metadata.

Aspects of the present disclosure involve systems and or methods for performing various class loading processes among other processes during execution time of a computer program or software application developed using an object oriented programming language such as Java . In various aspects a system such as a virtual machine executing on a processing device may access or otherwise request mechanisms of the programming language referred to as class loaders to dynamically load files containing interpretable code e.g. bytecode during the runtime of the software application. Prior to execution of the application i.e. pre processing metadata which corresponds to the class loaders is generated that may be used during a class loading operation. The metadata may be stored or otherwise maintained in a shared archive and may include for example data that identifies a particular type of class loader and or class loading operation for loading classes in the system. In other embodiments the metadata may include classpath information that uniquely identifies the specific class files being loaded within the system. The metadata may further include an identifier such as a URL path string of a more comprehensive archive file such as a Java Archive JAR file that uniquely identifies files within the JAR file. In some embodiments the metadata may include manifest data resources signatures and or binary information associated with the JAR file. The metadata may also include a pointer to any entry for any of the metadata such as the identifier listed above that may be stored or otherwise maintained in a data structure such as a table which may group the metadata together.

Upon execution of the computer program or software application the metadata and or class loaders may be used to perform a variety of security checks and or optimizations when loading classes during runtime such as preserved class loading delegation class re verification package handling protection domain creation protection domain caching and or any other process associated with loading a class as will be described in further detail below.

As illustrated in a run time environment includes a JVM that includes various components such as a Java interpreter which may include a garbage collector a just in time JIT compiler such as the HotSpot compiler and or a bytecode verifier to check the validity of the executable code. The run time environment may run on top of lower level software such as an operating system in some embodiments.

In one embodiment the JVM represents a process virtual machine that executes bytecode stored or otherwise maintained within a Java class library . Generally speaking the Java class library represents a collection of related object code typically packaged in one or more JAR files. A common type of object contained in a JAR file is a Java class file that represents a named distinct unit of code.

Class files from the Java class library may be identified by the class loader to load classes in the JVM . More specifically the class loader is responsible for locating Java class files in the Java code library reading their contents and loading the classes into the JVM . The loading is typically performed dynamically in that it does not occur until the class is actually requested by an executing computer program or software application. In the illustrated embodiment code is loaded from the Java class library into the JVM e.g. from a disk or over a network by the class loader . Thus when the JVM needs to load bytecode for a particular class it requests the class loader to find the bytecode.

Class loaders e.g. class loaders contain a hierarchy with parent class loaders and child class loaders. The relationship between parent and child class loaders is analogous to the object relationship of super classes and subclasses. The bootstrap class loader is the root of the Java class loader hierarchy. Thus the JVM may first request that a bootstrap class loader also referred to herein as the NULL class loader load the required class files i.e. bytecode . Bootstrap classes are included in the rt.jar and several other JAR files in the jre lib directory. These archives are specified by the value of the bootstrap classpath which is stored in the sun.boot.class.path system property. The JVM generates the bootstrap class loader which loads the Java development kit JDK internal classes and java. packages included in the JVM . For example the bootstrap class loader loads java.lang.String. 

Second the JVM may request that an extension class loader load the required class files i.e. bytecode . Extension classes are classes which extend the Java platform. Every .JAR file in the extension directory jre lib ext or java.ext.dirs is assumed to be an extension and is loaded using the Java Extension framework. The extension class loader is a child of the bootstrap class loader. The extension class loader loads any JAR files placed in the extension classpath.

Third the JVM may request that an application class loader also referred to as the User class loader load the required bytecode or class files. Application classes are classes which build on the Java platform. To find application type classes the launcher refers to the application classpath a list of directories JAR archives and ZIP archives which contain the desired class files.

The bootstrap class loader is responsible for loading the core Java classes. The bootstrap class loader is unique in that it is not actually a subclass of java.lang.ClassLoader but is implemented by the JVM itself. The bootstrap class loader loads classes in some default manner e.g. from a local disk .

The extension class loader is responsible for loading classes from the jars in the JRE s extension directory e.g. jre lib ext or as specified by the java.ext.dirs system property . This provides a standard mechanism to introduce new functionality beyond the core Java classes introduced by the bootstrap class loader .

The system class loader is responsible for loading classes from the directories and jars listed on the command line and or the java.class.path system property when the JVM is invoked. If not otherwise specified any user instantiated class loader will have this loader as its parent.

Class loading in the J2EE JVM environment is component based. That is applications are not monolithic rather they are collections of components Enterprise JavaBeans EJBs Servlets Java Server Pages JSPs Resource Adapters etc. that have predefined packaging e.g. using JAR Web Application Archive WAR and Roshal Archive RAR files and deployment directory structures as well as an umbrella packaging structure e.g. Enterprise Archive EAR files .

Class loading and linking using the standard extension and application class class loaders may be a heavy weight and expensive process that often involves classpath searching JAR file lookups class verification etc. In a typical application environment the total class loading time takes a large portion of the application startup time. Moreover the memory containing class data loaded by the extension and application class loaders in one process cannot be directly shared by other processes.

Class Data Sharing represents a process and or mechanism that may address such issues by archiving loaded class metadata and storing the metadata into a re mappable form before the execution of an application. More specifically the Java runtime environment e.g. runtime environment loads a set of classes from the system JAR file into a private internal representation and dumps that representation to a file called a shared archive. During subsequent JVM invocations the shared archive is memory mapped saving the cost of loading the classes stored in the shared archive and allowing much of the JVM s metadata for these classes to be shared among multiple JVM processes and or Java applications. U.S. Pat. No. 7 814 472 entitled System And Method For Shared Code Sourcing In A Java Virtual Machine Environment and U.S. Pat. No. 7 954 096 entitled Shared Loader System And Method further describe the concepts of class loading and class data sharing and the disclosures of both patents are hereby incorporated by reference in their entirety.

The classes included in the shared archive however are handled as trusted system classes and have no notion of class loader other than the NULL class loader. Thus classes from the extension and application classpath cannot be put into the archive without violating the class loader context and Java semantics which can cause incorrect runtime behavior and security vulnerability. Aspects of the present disclosure involve the storage in the class archive of additional metadata that identifies classes from the extension classpath and application classpath. The metadata may be also used by the extension classpath and application classpath class loaders to load classes at runtime and perform security checks and or other verifications to ensure that all class loader contexts and Java semantics are satisfied.

The classpath table included in the shared archive includes three classpaths classpath represents the boot classpath classpath represents the extension classpath and classpath represents the application classpath. Each classpath may include one or more entries illustrated as Entry 1 Entry 2 and or Entry N and each classpath is indexed according to its individual entries. Thus classpath will have two entries indexed as 1 and 2 classpath will have at least two entries up to N entries and so on. It is contemplated that any classpath could have any number of entries.

According to one embodiment indices identifying the first boot classpath entry the first extension classpath entry and first application classpath entry may be recorded and used to identify the original type boot extension or application of each classpath entry included the classpath table . The first index starts with the boot classpath because the boot classpath was the first classpath added when generating the new all inclusive classpath. Thus in the illustrated embodiment index is recorded with classpath Entry 1 of classpath indicating that the type of classpath of entry is the boot classpath type. All entries sequentially following classpath Entry 1 of classpath are considered to be of the boot classpath type until another index is recorded signifying a change in type. In the illustrated embodiment index is recorded with classpath Entry 1 of classpath indicating that the type corresponding to classpath Entry 1 of classpath is the extension classpath type. All entries sequentially following sequentially following classpath Entry 1 of classpath are considered to be of the extension classpath type until a new index is recorded signaling that that the type of the classpath is changing. In the illustrated embodiment index is recorded indicating that the type of classpath is the application classpath type and so on.

Referring back based on the generated classpath one or more classes are loaded and stored in the shared archive in a manner that enables the classes to be accessed i.e. loaded and used by multiple JVM processes e.g. applications operation . Referring to and in one embodiment the JVM may employ the boot NULL class loader e.g. the class loader load one or more classes from the class library . In one embodiment the JVM may access a pre stored list of required classes to determine which classes need to be loaded and stored in the shared archive. The JVM employs class data sharing mechanisms to store the classes loaded by the class loader in a private internal representation in memory and then dumps referred to herein as dump time and or dumping the representation into a shared archive file. The boot NULL class loader is used to ensure that no Java code is actually executed during class archiving.

Referring again to classes 1 through N and are loaded into the shared archive . As each class is being loaded a reference and or pointer to the classpath e.g. the Jar file from which the class was originally is stored in the shared archive as class data. Thus as class 1 is being loaded and stored in the shared archive a reference and or pointer is stored in the shared archive . In the illustrated embodiment the reference indicates that the classpath Java cp Test.jar lib my.package.MainClass was used to originally load the class. As class 2 is being loaded and stored in the shared archive a reference and or pointer is stored in the shared archive indicating the classpath e.g. the Jar file from which class 2 was originally loaded. Any number of classes may be loaded into the shared archive each of which will include a reference and or pointer to the classpath e.g. the Jar file from which it was loaded as illustrated by class N and reference .

Referring back to as classes are being stored into the shared archive additional metadata in addition to normal class data generated by class data sharing processes may be stored in the shared archive to ensure that classes from the extension class and application classes may be loaded by their respective class loaders at runtime operation . In the illustrated embodiment any metadata being added and stored with a class in the archive is referred to as additional metadata. Thus as illustrated additional metadata is added to each class at and . As explained above the additional metadata may include and information required to identify classes from the extension classpath and application classpath perform security checks and or other verifications and ensure that all class loader contexts and Java semantics are satisfied. The additional metadata may include flags new path strings timestamps and or the like may be stored as additional metadata as will be described in detail below.

For example and in one embodiment as each class is being loaded into the shared archive a flag may be set and stored as metadata at and respectively. The flag identifies the type of the class being loaded in the shared archive. More specifically as class is being loaded and stored in the shared archive a flag indicating the class is of type boot is set and stored in the metadata at . As class is being loaded and stored in the shared archive a flag indicating the class is of type application is set and stored to the metadata at . As class is being loaded and stored in the shared archive a flag indicating the class is of type extension is set and stored to the metadata at . In one embodiment the flag may be set by accessing variables corresponding to the class at the virtual machine representation level. Specifically the highest two bits in the InstanceKlass  misc flags of the loaded class may be used to specify the type of the class with the bit being set as 0x0 for the boot class 0x1 for the extension class and 0x2 for the application class.

In addition to storing class type metadata e.g. the flag other metadata identifying the specific JAR file path string of the class being loaded may be stored in the shared archive. For example as class is being loaded and stored in the shared archive the original classpath string may be stored. As class is being loaded and stored in the shared archive metadata containing the original classpath string defining the classpath from which the class was loaded is stored at . As class is being loaded and stored in the shared archive metadata containing the original classpath string defining the classpath from which the class was loaded is stored at . As class is being loaded and stored in the shared archive metadata containing the original classpath string defining the classpath from which the class was loaded is stored at and so on.

In addition to the Jar file path string a timestamp indicating when the classpath was accessed may also be stored in the shared archive as metadata. Thus as class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file classpath was accessed is added as additional metadata at . As class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file classpath was accessed is added as additional metadata at . As class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file classpath was accessed is added as additional metadata at .

Manifest data for a Jar file classpath in the form of metadata may also be stored in the shared archive as additional metadata. Generally speaking manifest data for a Jar file list the contents of the Jar file defines extension and package related data of the Jar file and may also contain information about other files that are packaged in the Jar file. Thus as class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file classpath was accessed is added to the metadata at . As class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file classpath was accessed is added to the metadata at . As class is being loaded and stored in the shared archive a timestamp indicating when the Jar file identified in the Jar file path was accessed is added to the metadata at . In yet another embodiment resource data in the form of metadata may also be stored in the shared archive for faster resource loading. When all classes and resources from a JAR file are archived the original JAR file can be eliminated to save static memory.

In one embodiment bytecode verification may be performed on all classes stored in the archive. More specifically when an application and or extension class loader presents bytecodes of a newly loaded Java class to the JVM the bytecodes may first be inspected and verified to ensure that the instructions are correct cannot perform actions that are damaging. Specifically and in one embodiment bytecode verification for the extension and application classes may be performed at dump time. If a class is verified successfully the class state is set to linked in the class metadata. If a class fails verification for example due to a missing parent class the class is marked in the metadata as being in an error state. Any classes in the error state are removed from the system dictionary when writing or otherwise storing classes in the shared archive. At runtime no verification will be re performed for those classes which have been successfully verified during dump time.

In another embodiment a class may fail verification due to a bad class format or because the class contains bad code. In such an event the class will be marked in the metadata as being in an error state and will also be removed from the system directory at dump time. At runtime when such a class is requested it will be loaded dynamically and verified normally. A verification error will be thrown by the JVM accordingly.

All of the stored class data and or additional metadata may be used to ensure that the application classpath and extension classpath classes are able to be stored in the shared archive and loaded by their respective class loaders at run time for multiple JVM processes. Additionally the class data and added metadata allows for various security checks to be performed when loading the classes.

In one embodiment in response to the class loader request the JVM may perform an initial compatibility security check based on the type of the class loader operation . For example if the class loader is a boot or extension type class loader the JVM may verify that that boot classpath and extension classpath directories used at dump time match at runtime as the contents of the extension directories must not change. If the class loader is an application type the JVM may verify that application classpath cp used at dump time is equal to or a proper prefix of the application classpath at runtime as new path components may be appended at the end of application classpath at runtime. Violation of any of the path requirements will invalidate the dumped shared archive and no classes from the shared archive will be loaded during the runtime.

Once the compatibility check has been performed it is determined whether the type of the requesting class loader matches the type of the requesting class that the class loader is attempting to load operation . Referring to the example above class will only be returned to the class loader A if the type of class loader A matches type of the requested class i.e. the extension class type . In one embodiment to determine whether there is a match the type of the requesting class loader is compared to the flag stored in additional metadata . As stated above the flag may be set based on the type of the class. If the types do not match the class is not returned and the class loader delegates the process to the parent class loader which then loads the class according to normal delegation processes operation . If the types match the class is returned to the requesting class loader operation .

If the types match and the requesting class loader is an extension class loader or an application class loader various security checks and runtime efficiencies may be performed and or otherwise achieved to ensure that all class loader contexts and Java semantics are satisfied even though the class is being loaded from the shared archive using an extension type class loader or an application type class loader. Such security checks and runtime efficiencies may include for example Fast Runtime Protection Domain Manifest Package and Package Sealing and Pre Verification among others operation .

In one embodiment fast runtime protection domain and package handling may be achieved when the requesting class loader is an extension type class loader or an application type class loader. As explained above bytecode verification for extension and application classes may be performed during shared archive dumping time and before runtimer. When the class fails verification due to missing parent class at dump time the class is flagged as an error and then removed from the system dictionary in the shared archive. At runtime the class loaded dynamically and verification is performed on the dynamically loaded class data.

In one embodiment fast runtime protection domain and package handling may be achieved when the requesting class loader is an extension type class loader or an application type class loader. In some cases a class will be loaded from a Jar file that was not previously verified by the JVM . Stated differently the class will be loaded and stored into the shared archive even though the Jar file from which the class was loaded was not officially verified and signed referred to as an unsigned Jar file by the JVM . The ability to sign and verify Jar files is an important part of the Java s security architecture. For example the policy file of the JRE may insist that classes coming from particular Jar file path location be signed by a particular entity before granting a particular set of permissions.

Security for a class is also controlled in part by the protection domain that is in force at runtime. Generally speaking a protection domain represents all the permissions that are granted to a particular code source such as a class. Stated differently a protection domain ensures that all classes that belong to it are treated the same because they originate from the same location and were signed as explained above by the same entity.

In the Java context a protection domain is a grouping of a code source and permissions that is a protection domain represents all the permissions that are granted to a particular code source or class. In the default implementation of the Policy class a protection domain is one grant entry in the file. A protection domain is an instance of the ProtectionDomain class java.security.ProtectionDomain and is constructed as follows public ProtectionDomain CodeSource cs PermissionCollection p The above instance constructs a protection domain based on the given code source cs and set of permissions p . Thus when associated with a class the example protection domain instance above means that the given class was loaded from the site specified in the code source cs was signed by the public keys specified in the code source cs and should have permission to perform the set of operations represented in the permission collection object p . Each class may belong to one and only one protection domain which is set by the class loader when the class is defined.

All classes loaded from the same unsigned JAR file can share the same protection domain when they are being loaded by the same type of class loader. As explained above each class stored in the shared archive contains a pointer index to the Jar file path string from which it was originally loaded. Thus when a class is loaded from the shared archive and the shared path index is pointing to an extension or application path entry a ProtectionDomain Java instance if one has not already been created may be generated using the Jar file path string. The generated ProtectionDomain instance is cached into an array. The index of the ProtectionDomain in the cache array is the same as the corresponding Jar file path entry index stored as metadata in the shared class path table for the loaded class. Subsequently when classes from the same JAR file are loaded from the archive the cached ProtectionDomain instance is used and set for those classes providing faster access to the cached ProtectionDomain by the JVM .

In one embodiment package generation and sealing and or manifest generation may be achieved when the requesting class loader is an extension type class loader or an application type class loader.

Generally speaking package handling refers to how Java packages are generated manipulated and or used in the JVM and the Java environment. Generally speaking a package is a namespace that organizes a set of related classes and interfaces. Because software written in the Java programming language can be composed of hundreds or thousands of individual classes classes are often organized by placing related classes and interfaces into packages.

One example of package handling includes package sealing. Packages included within JAR files can be optionally sealed which means that all classes defined in that package must be archived in the same JAR file. A package may be sealed for example to ensure version consistency among the classes included in the package. Manifest data list the contests of the Jar file from which the class is being loaded and contains information about the files packaged in the JAR file. In particular the manifest data includes attributes that help ensure the security of packaged classes.

When a class loader instance defines the first class from a package it defines the Package object that the class belongs to using the attributes contained in the JAR file manifest. The defined Package object is then cached. A Package is considered as sealed if the manifest contains Sealed true attribute for the specific package name or the whole JAR file . Package sealing is checked by the class loader when loading subsequent classes within the same package to make sure the new classes are from the same URL base if the package is sealed. The cached Package object is used to perform a package sealing check.

As explained above manifest data may be stored in the shared class path table for a JAR file path along with the path string. Thus for application and extension classes loaded from the shared archive Manifest and Package java objects may be generated. When an extension or application class is found in the shared archive if the containing JAR file path entry does not have a cached Manifest instance a Manifest java instance is created and stored in an array. The index of the Manifest instance in the cache array is the same as the corresponding Jar file path entry index stored as metadata in the shared class path table for the loaded class. Subsequently the cached Manifest is used by all classes with the same JAR file path loaded from the shared archive. Using the Manifest instance the VM does upper call into Java to let the ClassLoader instance handle the package define and sealing check for the class as is generally understood in the art in a more direct and efficient manner.

Regardless of whether code is Java code being loaded on a platform that conforms to Java standards or other code being loaded to another platform that conforms to other standards of another programming language functional difficulties may exist when attempting to load the code. For example loading and linking class files or other code files using a class loading mechanism of a programming language other than Java may be a heavy weight and expensive process that often involves file path searching archive file lookups code file verification etc. Additionally memory containing the class files in one class loading process may not be directly shared by other class loading processes.

To remedy such issues class loading mechanisms implemented within the programming language may be used to load the classes into a re usable archive that allows multiple executing processes to access the archived class data. Additionally metadata may be added to the archive that enables processes to perform security checks and or other verifications such as verifying that the correct version of the class file is being loaded verify that the executing processes have access to all of the appropriate archive files versions etc.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus a switched fabric point to point connections and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up may be stored in ROM. The computing device further includes a hard disk drive for reading from and writing to a persistent memory such as a hard disk not shown and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical medium.

The hard disk drive and optical disk drive are connected to the system bus . The drives and their associated computer readable medium provide nonvolatile storage of computer readable instructions data structures program engines and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable medium which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks random access memories RAMs read only memories ROMs and the like may be used in the example operating environment.

A number of program engines may be stored on the hard disk optical disk or elsewhere including an operating system an application and one or more other application programs . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device connected to the USB or Serial Port . These and other input devices are often connected to the processor through the USB or serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port. A monitor or other type of display device may also be connected to the system bus via an interface not shown . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The embodiments of the present disclosure described herein are implemented as logical steps in one or more computer systems. The logical operations of the present disclosure are implemented 1 as a sequence of processor implemented steps executing in one or more computer systems and 2 as interconnected machine or circuit engines within one or more computer systems. The implementation is a matter of choice dependent on the performance requirements of the computer system implementing aspects of the present disclosure. Accordingly the logical operations making up the embodiments of the disclosure described herein are referred to variously as operations steps objects or engines. Furthermore it should be understood that logical operations may be performed in any order unless explicitly claimed otherwise or a specific order is inherently necessitated by the claim language.

The foregoing merely illustrates the principles of the disclosure. Various modifications and alterations to the described embodiments will be apparent to those skilled in the art in view of the teachings herein. It will thus be appreciated that those skilled in the art will be able to devise numerous systems arrangements and methods which although not explicitly shown or described herein embody the principles of the disclosure and are thus within the spirit and scope of the present disclosure. From the above description and drawings it will be understood by those of ordinary skill in the art that the particular embodiments shown and described are for purposes of illustrations only and are not intended to limit the scope of the present disclosure. References to details of particular embodiments are not intended to limit the scope of the disclosure.

