---

title: Apparatuses, methods and systems for determining a virtual machine state based on CPU registers
abstract: The CPU REGISTER ASSISTED VIRTUAL MACHINE SCREENSHOT CAPTURE TIMING APPARATUSES, METHODS AND SYSTEMS (“CRV”) transforms register retrieval requests, via CRV components, into boot success messages and screenshot capture command invocation outputs. A method comprises determining when to capture a screenshot of a virtual machine's display output by observing the values of a virtual CPU's registers, or the entropy of the virtual CPU's register values, obtained from a hypervisor in communication with the virtual machine's virtual CPU. The method further comprises determining when the virtual machine is at a boot success state and capturing a screenshot of the virtual machine display output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323638&OS=09323638&RS=09323638
owner: Datto, Inc.
number: 09323638
owner_city: Norwalk
owner_country: US
publication_date: 20150501
---
This application is a continuation of United States non provisional patent application Ser. No. 14 456 981 filed Aug. 14 2014 which claims priority under 35 USC 119 to U.S. provisional patent application Ser. No. 61 864 358 filed Aug. 9 2013 entitled CPU REGISTER ASSISTED MACHINE STATE VERIFICATION APPARATUSES METHODS AND SYSTEMS .

The entire contents of the aforementioned application s are expressly incorporated by reference herein.

This application may contain material that is subject to copyright mask work and or other intellectual property protection. The respective owners of such intellectual property have no objection to the facsimile reproduction of the disclosure by anyone as it appears in published Patent Office file records but otherwise reserve all rights.

The present innovations generally address the use of virtual machine and hardware based CPU registers to assist in the identification of operating system load states and more particularly include CPU REGISTER ASSISTED VIRTUAL MACHINE SCREENSHOT CAPTURE TIMING APPARATUSES METHODS AND SYSTEMS.

Modern computers utilize registers to perform low level operations and are directed by instructions from an architecture instruction set. Computer systems including servers may be backed up to local or remote storage. Periodically backup integrity may be evaluated to ensure backups were completed successfully.

The leading number of each reference number within the drawings indicates the figure in which that reference number is introduced and or detailed. As such a detailed discussion of reference number would be found and or introduced in . Reference number is introduced in etc.

In some embodiments an CPU REGISTER ASSISTED VIRTUAL MACHINE SCREENSHOT CAPTURE TIMING APPARATUSES METHODS AND SYSTEMS hereinafter CRV transforms register retrieval requests via CRV components into boot success messages and screenshot capture command invocation outputs.

In one embodiment a server can also be booted. CPU register profile monitoring can be used to observe the server register values and or their associated entropies as the server passes through various boot states and display output configurations. For example the server can initially be in an early boot display output configuration followed by a UI loading display output configuration which is ultimately followed by a boot failure. In an example CPU register profile monitoring embodiment the arrival of server at a boot failure state can be readily detected and a screenshot of the failure output can be captured for further processing

In alternative embodiments the CPU register state of an operating system that is not virtualized but is running on bare metal hardware can be discerned by a custom BIOS. In still other embodiments a hardware based device can be used to inspect the current register values of a booting server such as for example a PCI express card in communication with the booting server and configured to read the current register values. In other embodiments the register profiling and conditional statements capability described herein can be used to detect events other than or in addition to an operating system load state. For example the register states can similarly be used to determine if an application is currently running on a server e.g. Microsoft Exchange and or the like. Furthermore the detection of register states and the association of register states with events can be chained together such that for example an operating system loading state can be first determined and then an application load state can be subsequently determined. In still other embodiments custom conditional statements can be similarly created to detect a compromised operating system such as for example by purposely infecting a sandboxed virtual machine and executing a register profile procedure on said infected virtual machine in order to determine a conditional statement that can be utilized to detect a similarly compromised operating system. In still other embodiments the techniques described herein can be used to determine an operating system version a system type what software including custom software can be installed on a server what software is installed on a server the usage characteristics associated with a user of a server and or software on a server and or the like. Furthermore embodiments of the inventions can be used on any processing device configured with any software operating system or operating independently that supports or is capable of reading register states or their equivalents reading register values or their equivalents or determining register entropy values from a central processing unit or other similar processing unit e.g. a graphical processing unit and or the like.

In one embodiment an operating system and patch database can respond with an image response message . An example image response message substantially in the form of an HTTP S POST message including XML formatted data is provided below 

In one embodiment the operating system image virtualization server can then generate incremental operating system versions. Further detail with regard to operating system incremental version generation and snapshot creation can be found with respect to e.g. an example OSVG Component . In one embodiment OS image virtualization server can generate an operating system screenshot register profiler request . The profiler request can specify a base operating system an operating system incremental version such as a service pack level and or the like. In one embodiment the register profiling server can then initiate a procedure to collect register value data from a plurality of operating systems at various stages of boot launch. For example in one embodiment register profiling server can transmit a launch operating system request to operating system image virtualization server . A launch operating system request can specify a base operating system and or a particular snapshot that is to be profiled. An example launch operating system request substantially in the form of an HTTP S POST message including XML formatted data is provided below 

In one embodiment operating system image virtualization server can then respond with a launch operating system response . Upon being notified that the operating system image virtualization server has launched the target operating system for profiling the register profiling server can then initiate a boot screen register sample request . A boot screen register sample request can be a request that rapidly samples a hardware based or virtual machine based central processing unit s register values during a booting state. Executable code substantially in the form of a bash shell script suitable for rapidly sampling CPU register values is 

In response the operating system image virtualization server can respond with a boot screen register sample response stream which can contain an array of register values as well as in some embodiments a timestamp representing when a given set of register values was collected. In some embodiments the boot screen register sample response stream can be representative of only one set of register values while in other embodiments the stream can contain a plurality of register value states. An example CPU register response containing a current CPU register value sample is 

Upon observing that the operating system currently being booted will reach a launched or failure state imminently the user device can initiate a pre operating system loaded input which can then transmit an operating system preload signal . Upon receiving an operating system preload signal register profiling server can terminate the boot screen register sampling e.g. . After a given time quantum the operating system being booted on operating system image virtualization server can thereafter reach a successfully booted state. In response to observing the operating system image virtualization server reaching a successfully booted state the user client device can generate an operating system loaded input and transmit an operating system loaded signal to register profiling server . The register profiling server can thereafter begin again sampling register values to determine applicable register values of the target operating system while in the successfully booted state e.g. a GUI loaded screen extended register sample request . In some embodiments the operating system image virtualization server can then reply to the register profiling server with a GUI loaded screen extended register sample response stream . In some embodiments the contents of the GUI loaded screen extended register sample response stream can be substantially similar to that found with respect to a boot screen register sample response stream . In one embodiment after a period of time such as one hour the register sampling can be terminated by the register profiling server and the register profiling server can thereafter generate an operating system register profile and screenshot conditional statement for use in determining the boot state of an operating system being booted. Further detail with respect to generating an operating system register profiling screenshot conditional statement can be found with respect to B e.g example RPS Components.

In one embodiment the verification target virtual machine server can respond to the register retrieval request with a register retrieval response . A register retrieval response can contain the current register state e.g. the values currently loaded into the CPU registers. An example register retrieval response showing the CPU registers in a successfully booted state is 

In one embodiment the screenshot verification server can retrieve an operating system register profile and or a register value conditional statement and compare the received register values to the register conditional statement. Further detail with respect to comparing register profiles for an operating system loaded state to received register values e.g. can be found with respect to e.g. an example OBC Component. In some embodiments the screenshot verification server and the verification target server can engage in multiple rounds of register retrieval request register retrieval response communications. In one embodiment upon determining that the verification target virtual machine server has reached a specified boot state which can include but is not limited to a successfully booted state and or a failure boot state the screenshot verification server can initiate a screenshot capture request . The screenshot capture request can be a request to retrieve as an image the current display output from the booting operating system. In response the verification target virtual machine server can transmit a screenshot capture response to the screenshot verification server . The screenshot capture response can contain an image such as a JPEG image or a TIFF image representing the current visual output e.g. output that would be shown on a monitor connected to the booting machine from the booting server. Such output can be obtained by for example executing a command integrated into the booting operating system. In one embodiment the screenshot verification server can thereafter determine if the server reached a successfully booted state or is in a failed boot state can utilize optical character recognition in order to extract text from the received screenshot capture can log to a consolidated boot status log server the status of the current boot operation and or the like e.g. . In some embodiments the screenshot verification server can transmit a boot failure message and or a boot success message to a boot status log server . A boot status log server can in some embodiments aggregate boot failure and success messages for multiple verification target virtual machine servers over time such that an administrator can easily monitor and view screenshots of target operating systems in success and or failure boot states.

In one embodiment the generated decision tree can be folded and or collapsed in order to create a logical conditional statement. A logical conditional statement can be a representation of the decision tree as a series of if then statements as a plurality of switch statements and or executable instructions in any form suitable for evaluating inputs in relation to the decision tree. In other embodiments the decision tree can not be folded and can be stored in a format such as for example a directed graph. An example logical conditional statement suitable for use in an RPS component is 

In one embodiment the generated logical conditional statement can be transmitted to a screenshot verification server e.g. . The screenshot verification server can store the generated conditional statement and use the conditional statement during a screenshot verification procedure to determine if and or when a server has arrived at a given state. In one embodiment logical conditional statements can be created that represent multiple states of a server. For example a logical conditional statement can be created to represent a server in a successfully booted state such as when a graphical user interface and or a login prompt is displayed. In other embodiments a logical conditional statement can be generated to represent a server boot failure state such as can be present when the server encounters an unrecoverable error during booting.

In one embodiment the pixel color of an expected background pixel can be determined . The background pixel can be located at a given location which can depend on the server type the operating system major version the operating system incremental version and or the like. In one embodiment an inspection exclusion area can be determined using an inspection exclusion mask rule set. An inspection exclusion mask rule set can represent an area of an operating system display output that is not to be examined in order to determine a current operating system boot state. In one embodiment the color value of pixels that do not fall in the inspection exclusion area can be extracted and compared against the expected background pixel color previously determined . If all inspected values match the expected background pixel color the procedure can pause for a time quantum such as five seconds . In other embodiments if the color values of each inspected pixel do not match the expected background pixel color e.g. then a boot success message as well as a screenshot showing the current operating system display output can be sent to a boot status logging server . In one embodiment if the current loading state of a verification target server is not determined to be in a success state based on the current register values and the applicable conditional statement e.g. and the maximum boot loading wait time has elapsed e.g. then a screenshot of the current operating system display output can be taken .

In one embodiment the screenshot can be processed by an optical character recognition component in order to determine the text of any error messages that can be displayed on the current operating system display output e.g. . An open source program suitable for performing optical character recognition is Tesseract. An example Tesseract command suitable for extracting error message text from an operating system display output screen capture is 

In one embodiment screenshot verification server can then prepare a boot failure message including the extracted text of an error message a current screenshot of the operating system display output and or the like and forward the boot failure message to a boot status logging server e.g. .

Where p is the probability of a determined value in a register and n is the number of different outcomes or values a register can contain for a given CPU state. In some embodiments the Shannon entropy can be calculated for the values contained in a sample of registers over time. An example code to calculate the Shannon entropy for a given set of register values substantially in the form of PHP scripting language is provided below 

Referring back to a collection of samples containing register values over time taken while a computer is in a stable state are shown e.g. . Given the set of samples entropy values can be calculated in a plurality of ways to inform the CRV of the amount of information carried by a register during a time quantum. In some embodiments the entropy values can be calculated as a function of all the registers comprised in a sample e.g. . Alternatively in some embodiments the entropy can be calculated as a function of the observed register values for individual registers over time. For example h rax is the entropy calculated as a function of the values contained in the register rax over the period period of time corresponding to the time when SAMPLE to SAMPLEN where taken e.g. . Moreover an additional global entropy value can equally be calculated as a function of the entropy values calculated for each register over time for example h global .

It will readily evident to a person of the ordinary skill in the art that a plurality of additional methods exist to calculate entropy values from registers content captured over time can be employed to deduce the amount of information carried out by a register when a computer is in a stable state such methods can comprise computations which include but are not limited to sorting the entropy values before calculating a global entropy associating a weight value to a subset of entropy values before calculating a global entropy and other similar computational methods.

In some embodiments for each of the record sets e.g. the register profile server can divide the data in the sets into subsets containing an equal number of values e.g. . Thereafter for each of the computed subsets e.g. an entropy value is calculated as a function or all the values contained in the subset and a training set record entry can be constructed comprising the calculated entropy value the computer state associated with the values in the subset and the register from where the values where taken e.g. . When all the subsets have been exhausted e.g. for each of the registers comprised in a stream e.g. and all the streams in the loaded streams have been processed the training set contains all the necessary training data to be fed into a machine learning algorithm e.g. . An illustrative example of the training data contained by the training set in the form of Entropy State Register is provided below 

A person of the ordinary skill in the art can appreciate that the classifier can be similarly trained to differentiate between more than aformentioned states and a that a more comprehensive classifier can be generated by entering training data comprising other states including but not limited to BIOS loaded state network interface card NIC loaded state and the like states.

In some embodiments the machine learning algorithm can be executed examples of such machine algorithms include ID3 and C4.5 learning algorithms e.g. however it can be appreciated that other type of machine learning algorithms can be utilized in order to generate other types of intelligent classifier. An example pseudocode to generate a classifier in the form of a decision tree utlizing the C4.5 algorithm is provided below

In some embodiments once the machine learning algorithm has been successfully executed the algorithm can provide a classifier in the form of an entropy based decision tree e.g. other type of classifiers based on different types of data structures and or logic can also be generated from the machine learning algorithm . An example fragment of an entropy based decisition tree implementation substantially in the form of PHP scripting language is provided below 

Typically users which may be people and or other systems may engage information technology systems e.g. computers to facilitate information processing. In turn computers employ processors to process information such processors may be referred to as central processing units CPU . One form of processor is referred to as a microprocessor. CPUs use communicative circuits to pass binary encoded signals acting as instructions to enable various operations. These instructions may be operational and or data instructions containing and or referencing other instructions and data in various processor accessible and operable areas of memory e.g. registers cache memory random access memory etc. . Such communicative instructions may be stored and or transmitted in batches e.g. batches of instructions as programs and or data components to facilitate desired operations. These stored instruction codes e.g. programs may engage the CPU circuit components and other motherboard and or system components to perform desired operations. One type of program is a computer operating system which may be executed by CPU on a computer the operating system enables and facilitates users to access and operate computer information technology and resources. Some resources that may be employed in information technology systems include input and output mechanisms through which data may pass into and out of a computer memory storage into which data may be saved and processors by which information may be processed. These information technology systems may be used to collect data for later retrieval analysis and manipulation which may be facilitated through a database program. These information technology systems provide interfaces that allow users to access and operate various system components.

In one embodiment the CRV controller may be connected to and or communicate with entities such as but not limited to one or more users from user input devices peripheral devices an optional cryptographic processor device and or a communications network .

Networks are commonly thought to comprise the interconnection and interoperation of clients servers and intermediary nodes in a graph topology. It should be noted that the term server as used throughout this application refers generally to a computer other device program or combination thereof that processes and responds to the requests of remote users across a communications network. Servers serve their information to requesting clients. The term client as used herein refers generally to a computer program other device user and or combination thereof that is capable of processing and making requests and obtaining and processing any responses from servers across a communications network. A computer other device program or combination thereof that facilitates processes information and requests and or furthers the passage of information from a source user to a destination user is commonly referred to as a node. Networks are generally thought to facilitate the transfer of information from source points to destinations. A node specifically tasked with furthering the passage of information from a source to a destination is commonly called a router. There are many forms of networks such as Local Area Networks LANs Pico networks Wide Area Networks WANs Wireless Networks WLANs etc. For example the Internet is generally accepted as being an interconnection of a multitude of networks whereby remote clients and servers may access and interoperate with one another.

The CRV controller may be based on computer systems that may comprise but are not limited to components such as a computer systemization connected to memory .

A computer systemization may comprise a clock central processing unit CPU s and or processor s these terms are used interchangeable throughout the disclosure unless noted to the contrary a memory e.g. a read only memory ROM a random access memory RAM etc. and or an interface bus and most frequently although not necessarily are all interconnected and or communicating through a system bus on one or more mother board s having conductive and or otherwise transportive circuit pathways through which instructions e.g. binary encoded signals may travel to effectuate communications operations storage etc. The computer systemization may be connected to a power source e.g. optionally the power source may be internal. Optionally a cryptographic processor and or transceivers e.g. ICs may be connected to the system bus. In another embodiment the cryptographic processor and or transceivers may be connected as either internal and or external peripheral devices via the interface bus I O. In turn the transceivers may be connected to antenna s thereby effectuating wireless transmission and reception of various communication and or sensor protocols for example the antenna s may connect to a Texas Instruments WiLink WL1283 transceiver chip e.g. providing 802.1in Bluetooth 3.0 FM global positioning system GPS thereby allowing CRV controller to determine its location Broadcom BCM4329 FKUBG transceiver chip e.g. providing 802.11n Bluetooth 2.1 EDR FM etc. a Broadcom BCM4750 IUB8 receiver chip e.g. GPS an Infineon Technologies X Gold 618 PMB9800 e.g. providing 2G 3G HSDPA HSUPA communications and or the like. The system clock typically has a crystal oscillator and generates a base signal through the computer systemization s circuit pathways. The clock is typically coupled to the system bus and various clock multipliers that will increase or decrease the base operating frequency for other components interconnected in the computer systemization. The clock and various components in a computer systemization drive signals embodying information throughout the system. Such transmission and reception of instructions embodying information throughout a computer systemization may be commonly referred to as communications. These communicative instructions may further be transmitted received and the cause of return and or reply communications beyond the instant computer systemization to communications networks input devices other computer systemizations peripheral devices and or the like. It should be understood that in alternative embodiments any of the above components may be connected directly to one another connected to the CPU and or organized in numerous variations employed as exemplified by various computer systems.

The CPU comprises at least one high speed data processor adequate to execute program components for executing user and or system generated requests. Often the processors themselves will incorporate various specialized processing units such as but not limited to integrated system bus controllers memory management control units floating point units and even specialized processing sub units like graphics processing units digital signal processing units and or the like. Additionally processors may include internal fast access addressable memory and be capable of mapping and addressing memory beyond the processor itself internal memory may include but is not limited to fast registers various levels of cache memory e.g. level 1 2 3 etc. RAM etc. The processor may access this memory through the use of a memory address space that is accessible via instruction address which the processor can construct and decode allowing it to access a circuit path to a specific memory address space having a memory state. The CPU may be a microprocessor such as AMD s Athlon Duron and or Opteron ARM s application embedded and secure processors IBM and or Motorola s DragonBall and PowerPC IBM s and Sony s Cell processor Intel s Celeron Core 2 Duo Itanium Pentium Xeon and or XScale and or the like processor s . The CPU interacts with memory through instruction passing through conductive and or transportive conduits e.g. printed electronic and or optic circuits to execute stored instructions i.e. program code according to conventional data processing techniques. Such instruction passing facilitates communication within the CRV controller and beyond through various interfaces. Should processing requirements dictate a greater amount speed and or capacity distributed processors e.g. Distributed CRV mainframe multi core parallel and or super computer architectures may similarly be employed. Alternatively should deployment requirements dictate greater portability smaller Personal Digital Assistants PDAs may be employed.

Depending on the particular implementation features of the CRV may be achieved by implementing a microcontroller such as CAST s R8051 XC2 microcontroller Intel s MCS i.e. 8051 microcontroller and or the like. Also to implement certain features of the CRV some feature implementations may rely on embedded components such as Application Specific Integrated Circuit ASIC Digital Signal Processing DSP Field Programmable Gate Array FPGA and or the like embedded technology. For example any of the CRV component collection distributed or otherwise and or features may be implemented via the microprocessor and or via embedded components e.g. via ASIC coprocessor DSP FPGA and or the like. Alternately some implementations of the CRV may be implemented with embedded components that are configured and used to achieve a variety of features or signal processing.

Depending on the particular implementation the embedded components may include software solutions hardware solutions and or some combination of both hardware software solutions. For example CRV features discussed herein may be achieved through implementing FPGAs which are a semiconductor devices containing programmable logic components called logic blocks and programmable interconnects such as the high performance FPGA Virtex series and or the low cost Spartan series manufactured by Xilinx. Logic blocks and interconnects can be programmed by the customer or designer after the FPGA is manufactured to implement any of the CRV features. A hierarchy of programmable interconnects allow logic blocks to be interconnected as needed by the CRV system designer administrator somewhat like a one chip programmable breadboard. An FPGA s logic blocks can be programmed to perform the operation of basic logic gates such as AND and XOR or more complex combinational operators such as decoders or mathematical operations. In most FPGAs the logic blocks also include memory elements which may be circuit flip flops or more complete blocks of memory. In some circumstances the CRV may be developed on regular FPGAs and then migrated into a fixed version that more resembles ASIC implementations. Alternate or coordinating implementations may migrate CRV controller features to a final ASIC instead of or in addition to FPGAs. Depending on the implementation all of the aforementioned embedded components and microprocessors may be considered the CPU and or processor for the CRV.

The power source may be of any standard form for powering small electronic circuit board devices such as the following power cells alkaline lithium hydride lithium ion lithium polymer nickel cadmium solar cells and or the like. Other types of AC or DC power sources may be used as well. In the case of solar cells in one embodiment the case provides an aperture through which the solar cell may capture photonic energy. The power cell is connected to at least one of the interconnected subsequent components of the CRV thereby providing an electric current to all subsequent components. In one example the power source is connected to the system bus component . In an alternative embodiment an outside power source is provided through a connection across the I O interface. For example a USB and or IEEE 1394 connection carries both data and power across the connection and is therefore a suitable source of power.

Interface bus ses may accept connect and or communicate to a number of interface adapters conventionally although not necessarily in the form of adapter cards such as but not limited to input output interfaces I O storage interfaces network interfaces and or the like. Optionally cryptographic processor interfaces similarly may be connected to the interface bus. The interface bus provides for the communications of interface adapters with one another as well as with other components of the computer systemization. Interface adapters are adapted for a compatible interface bus. Interface adapters conventionally connect to the interface bus via a slot architecture. Conventional slot architectures may be employed such as but not limited to Accelerated Graphics Port AGP Card Bus Extended Industry Standard Architecture E ISA Micro Channel Architecture MCA NuBus Peripheral Component Interconnect Extended PCI X PCI Express Personal Computer Memory Card International Association PCMCIA and or the like.

Storage interfaces may accept communicate and or connect to a number of storage devices such as but not limited to storage devices removable disc devices and or the like. Storage interfaces may employ connection protocols such as but not limited to Ultra Serial Advanced Technology Attachment Packet Interface Ultra Serial ATA PI Enhanced Integrated Drive Electronics E IDE Institute of Electrical and Electronics Engineers IEEE fiber channel Small Computer Systems Interface SCSI Universal Serial Bus USB and or the like.

Network interfaces may accept communicate and or connect to a communications network . Through a communications network the CRV controller is accessible through remote clients e.g. computers with web browsers by users . Network interfaces may employ connection protocols such as but not limited to direct connect Ethernet thick thin twisted pair 10 100 1000 Base T and or the like Token Ring wireless connection such as IEEE 802.11a x and or the like. Should processing requirements dictate a greater amount speed and or capacity distributed network controllers e.g. Distributed CRV architectures may similarly be employed to pool load balance and or otherwise increase the communicative bandwidth required by the CRV controller. A communications network may be any one and or the combination of the following a direct interconnection the Internet a Local Area Network LAN a Metropolitan Area Network MAN an Operating Missions as Nodes on the Internet OMNI a secured custom connection a Wide Area Network WAN a wireless network e.g. employing protocols such as but not limited to a Wireless Application Protocol WAP I mode and or the like and or the like. A network interface may be regarded as a specialized form of an input output interface. Further multiple network interfaces may be used to engage with various communications network types 1013. For example multiple network interfaces may be employed to allow for the communication over broadcast multicast and or unicast networks.

Input Output interfaces I O may accept communicate and or connect to user input devices loll peripheral devices cryptographic processor devices and or the like. I O may employ connection protocols such as but not limited to audio analog digital monaural RCA stereo and or the like data Apple Desktop Bus ADB IEEE 1394a b serial universal serial bus USB infrared joystick keyboard midi optical PC AT PS 2 parallel radio video interface Apple Desktop Connector ADC BNC coaxial component composite digital Digital Visual Interface DVI high definition multimedia interface HDMI RCA RF antennae S Video VGA and or the like wireless transceivers 802.11a b g n x Bluetooth cellular e.g. code division multiple access CDMA high speed packet access HSPA high speed downlink packet access HSDPA global system for mobile communications GSM long term evolution LTE WiMax etc. and or the like. One typical output device may include a video display which typically comprises a Cathode Ray Tube CRT or Liquid Crystal Display LCD based monitor with an interface e.g. DVI circuitry and cable that accepts signals from a video interface may be used. The video interface composites information generated by a computer systemization and generates video signals based on the composited information in a video memory frame. Another output device is a television set which accepts signals from a video interface. Typically the video interface provides the composited video information through a video connection interface that accepts a video display interface e.g. an RCA composite video connector accepting an RCA composite video cable a DVI connector accepting a DVI display cable etc. .

User input devices often are a type of peripheral device see below and may include card readers dongles finger print readers gloves graphics tablets joysticks keyboards microphones mouse mice remote controls retina readers touch screens e.g. capacitive resistive etc. trackballs trackpads sensors e.g. accelerometers ambient light GPS gyroscopes proximity etc. styluses and or the like.

Peripheral devices may be connected and or communicate to I O and or other facilities of the like such as network interfaces storage interfaces directly to the interface bus system bus the CPU and or the like. Peripheral devices may be external internal and or part of the CRV controller. Peripheral devices may include antenna audio devices e.g. line in line out microphone input speakers etc. cameras e.g. still video webcam etc. dongles e.g. for copy protection ensuring secure transactions with a digital signature and or the like external processors for added capabilities e.g. crypto devices force feedback devices e.g. vibrating motors network interfaces printers scanners storage devices transceivers e.g. cellular GPS etc. video devices e.g. goggles monitors etc. video sources visors and or the like. Peripheral devices often include types of input devices e.g. cameras .

It should be noted that although user input devices and peripheral devices may be employed the CRV controller may be embodied as an embedded dedicated and or monitor less i.e. headless device wherein access would be provided over a network interface connection.

Cryptographic units such as but not limited to microcontrollers processors interfaces and or devices may be attached and or communicate with the CRV controller. A MC68HC16 microcontroller manufactured by Motorola Inc. may be used for and or within cryptographic units. The MC68HC16 microcontroller utilizes a 16 bit multiply and accumulate instruction in the 16 MHz configuration and requires less than one second to perform a 512 bit RSA private key operation. Cryptographic units support the authentication of communications from interacting agents as well as allowing for anonymous transactions. Cryptographic units may also be configured as part of the CPU. Equivalent microcontrollers and or processors may also be used. Other commercially available specialized cryptographic processors include Broadcom s CryptoNetX and other Security Processors nCipher s nShield SafeNet s Luna PCI e.g. 7100 series Semaphore Communications 40 MHz Roadrunner 184 Sun s Cryptographic Accelerators e.g. Accelerator 6000 PCIe Board Accelerator 500 Daughtercard Via Nano Processor e.g. L2100 L2200 U2400 line which is capable of performing 500 MB s of cryptographic instructions VLSI Technology s 33 MHz 6868 and or the like.

Generally any mechanization and or embodiment allowing a processor to affect the storage and or retrieval of information is regarded as memory . However memory is a fungible technology and resource thus any number of memory embodiments may be employed in lieu of or in concert with one another. It is to be understood that the CRV controller and or a computer systemization may employ various forms of memory . For example a computer systemization may be configured wherein the operation of on chip CPU memory e.g. registers RAM ROM and any other storage devices are provided by a paper punch tape or paper punch card mechanism however such an embodiment would result in an extremely slow rate of operation. In a typical configuration memory will include ROM RAM and a storage device . A storage device may be any conventional computer system storage. Storage devices may include a drum a fixed and or removable magnetic disk drive a magneto optical drive an optical drive i.e. Blueray CD ROM RAM Recordable R ReWritable RW DVD R RW HD DVD R RW etc. an array of devices e.g. Redundant Array of Independent Disks RAID solid state memory devices USB memory solid state drives SSD etc. other processor readable storage mediums and or other devices of the like. Thus a computer systemization generally requires and makes use of memory.

The memory may contain a collection of program and or database components and or data such as but not limited to operating system component information server component user interface component CRV database component cryptographic server component OSVG component RPS component OBC component and or the like i.e. collectively a component collection . The aforementioned components may be incorporated into e.g. be sub components of loaded from loaded by or otherwise operatively available to and from the CRV component s .

Any component may be stored and accessed from the storage devices and or from storage devices accessible through an interface bus. Although program components such as those in the component collection typically are stored in a local storage device they may also be loaded and or stored in other memory such as remote cloud storage facilities accessible through a communications network integrated ROM memory via an FPGA or ASIC implementing component logic and or the like.

The operating system component is an executable program component facilitating the operation of the CRV controller. Typically the operating system facilitates access of I O network interfaces peripheral devices storage devices and or the like. The operating system may be a highly fault tolerant scalable and secure system such as Unix and Unix like system distributions such as AT T s UNIX Berkley Software Distribution BSD variations such as FreeBSD NetBSD OpenBSD and or the like Linux distributions such as Red Hat Debian Ubuntu and or the like and or the like operating systems. However more limited and or less secure operating systems also may be employed such as Apple OS X Microsoft Windows 2000 2003 3.1 95 98 CE Millenium NT Vista XP Win7 Server and or the like. An operating system may communicate to and or with other components in a component collection including itself and or the like. Most frequently the operating system communicates with other program components user interfaces and or the like. The operating system once executed by the CPU may enable the interaction with communications networks data I O peripheral devices program components memory user input devices and or the like. The operating system may provide communications protocols that allow the CRV controller to communicate with other entities through a communications network . Various communication protocols may be used by the CRV controller as a subcarrier transport mechanism for interaction such as but not limited to multicast TCP IP UDP unicast and or the like.

An information server component is a stored program component that is executed by a CPU. The information server may be a conventional Internet information server such as but not limited to Apache Software Foundation s Apache Microsoft s Internet Information Server and or the like. The information server may allow for the execution of program components through facilities such as Active Server Page ASP ActiveX ANSI Objective C C and or .NET Common Gateway Interface CGI scripts dynamic D hypertext markup language HTML FLASH Java JavaScript Practical Extraction Report Language PERL Hypertext Pre Processor PHP pipes Python wireless application protocol WAP WebObjects and or the like. The information server may support secure communications protocols such as but not limited to File Transfer Protocol FTP HyperText Transfer Protocol HTTP Secure Hypertext Transfer Protocol HTTPS Secure Socket Layer SSL messaging protocols e.g. ICQ Internet Relay Chat IRC Presence and Instant Messaging Protocol PRIM Internet Engineering Task Force s IETF s Session Initiation Protocol SIP SIP for Instant Messaging and Presence Leveraging Extensions SIMPLE open XML based Extensible Messaging and Presence Protocol XMPP i.e. Jabber or Open Mobile Alliance s OMA s Instant Messaging and Presence Service IMPS Representational State Transfer REST and or the like. The information server provides results in the form of Web pages to Web browsers and allows for the manipulated generation of the Web pages through interaction with other program components. After a Domain Name System DNS resolution portion of an HTTP request is resolved to a particular information server the information server resolves requests for information at specified locations on the CRV controller based on the remainder of the HTTP request. For example a request such as http 123.124.125.126 myInformation.html might have the IP portion of the request 123.124.125.126 resolved by a DNS server to an information server at that IP address that information server might in turn further parse the http request for the myInformation.html portion of the request and resolve it to a location in memory containing the information myInformation.html. Additionally other information serving protocols may be employed across various ports e.g. FTP communications across port and or the like. An information server may communicate to and or with other components in a component collection including itself and or facilities of the like. Most frequently the information server communicates with the CRV database component operating system component other program components user interfaces and or the like.

Access from the Information Server Component to the CRV database component may be achieved through a number of database bridge mechanisms such as through scripting languages as enumerated below e.g. CGI and through inter application communication channels as enumerated below e.g. CORBA WebObjects etc. . Any data requests through a Web browser are parsed through the bridge mechanism into appropriate grammars as required by the CRV. In one embodiment the information server would provide a Web form accessible by a Web browser. Entries made into supplied fields in the Web form are tagged as having been entered into the particular fields and parsed as such. The entered terms are then passed along with the field tags which act to instruct the parser to generate queries directed to appropriate tables and or fields. In one embodiment the parser may generate queries in standard SQL by instantiating a search string with the proper join select commands based on the tagged text entries wherein the resulting command is provided over the bridge mechanism to the CRV as a query. Upon generating query results from the query the results are passed over the bridge mechanism and may be parsed for formatting and generation of a new results Web page by the bridge mechanism. Such a new results Web page is then provided to the information server which may supply it to the requesting Web browser. Also an information server may contain communicate generate obtain and or provide program component system user and or data communications requests and or responses.

Computer interfaces in some respects are similar to automobile operation interfaces. Automobile operation interface elements such as steering wheels gearshifts and speedometers facilitate the access operation and display of automobile resources and status. Computer interaction interface elements such as check boxes cursors menus scrollers and windows collectively and commonly referred to as widgets similarly facilitate the access capabilities operation and display of data and computer hardware and operating system resources and status. Operation interfaces are commonly called user interfaces. Graphical user interfaces GUIs such as the Apple Macintosh Operating System s Aqua IBM s OS 2 Microsoft s Windows 2000 2003 3.1 95 98 CE Millenium NT XP Vista 7 i.e. Aero Unix s X Windows web interface libraries such as but not limited to Dojo jQuery UI MooTools Prototype script.aculo.us SWFObject Yahoo User Interface any of which may be used and provide a baseline and means of accessing and displaying information graphically to users.

A user interface component is a stored program component that is executed by a CPU. The user interface may be a conventional graphic user interface as provided by with and or atop operating systems and or operating environments such as already discussed. The user interface may allow for the display execution interaction manipulation and or operation of program components and or system facilities through textual and or graphical facilities. The user interface provides a facility through which users may affect interact and or operate a computer system. A user interface may communicate to and or with other components in a component collection including itself and or facilities of the like. Most frequently the user interface communicates with operating system component other program components and or the like. The user interface may contain communicate generate obtain and or provide program component system user and or data communications requests and or responses.

A cryptographic server component is a stored program component that is executed by a CPU cryptographic processor cryptographic processor interface cryptographic processor device and or the like. Cryptographic processor interfaces will allow for expedition of encryption and or decryption requests by the cryptographic component however the cryptographic component alternatively may run on a conventional CPU. The cryptographic component allows for the encryption and or decryption of provided data. The cryptographic component allows for both symmetric and asymmetric e.g. Pretty Good Protection PGP encryption and or decryption. The cryptographic component may employ cryptographic techniques such as but not limited to digital certificates e.g. X.509 authentication framework digital signatures dual signatures enveloping password access protection public key management and or the like. The cryptographic component will facilitate numerous encryption and or decryption security protocols such as but not limited to checksum Data Encryption Standard DES Elliptical Curve Encryption ECC International Data Encryption Algorithm IDEA Message Digest 5 MD5 which is a one way hash operation passwords Rivest Cipher RC5 Rijndael AES RSA Secure Hash Algorithm SHA Secure Socket Layer SSL Secure Hypertext Transfer Protocol HTTPS and or the like. Employing such encryption security protocols the CRV may encrypt all incoming and or outgoing communications and may serve as node within a virtual private network VPN with a wider communications network. The cryptographic component facilitates the process of security authorization whereby access to a resource is inhibited by a security protocol wherein the cryptographic component effects authorized access to the secured resource. In addition the cryptographic component may provide unique identifiers of content e.g. employing and MD5 hash to obtain a unique signature for an digital audio file. A cryptographic component may communicate to and or with other components in a component collection including itself and or facilities of the like. The cryptographic component supports encryption schemes allowing for the secure transmission of information across a communications network to enable the CRV component to engage in secure transactions if so desired. The cryptographic component facilitates the secure accessing of resources on the CRV and facilitates the access of secured resources on remote systems i.e. it may act as a client and or server of secured resources. Most frequently the cryptographic component communicates with information server component operating system component other program components and or the like. The cryptographic component may contain communicate generate obtain and or provide program component system user and or data communications requests and or responses.

The CRV database component may be embodied in a database and its stored data. The database is a stored program component which is executed by the CPU the stored program component portion configuring the CPU to process the stored data. The database may be a conventional fault tolerant relational scalable secure database such as Oracle or Sybase. Relational databases are an extension of a flat file. Relational databases consist of a series of related tables. The tables are interconnected via a key field. Use of the key field allows the combination of the tables by indexing against the key field i.e. the key fields act as dimensional pivot points for combining information from various tables. Relationships generally identify links maintained between tables by matching primary keys. Primary keys represent fields that uniquely identify the rows of a table in a relational database. More precisely they uniquely identify rows of a table on the one side of a one to many relationship.

Alternatively the CRV database may be implemented using various standard data structures such as an array hash linked list struct structured text file e.g. XML table and or the like. Such data structures may be stored in memory and or in structured files. In another alternative an object oriented database may be used such as Frontier ObjectStore Poet Zope and or the like. Object databases can include a number of object collections that are grouped and or linked together by common attributes they may be related to other object collections by some common attributes. Object oriented databases perform similarly to relational databases with the exception that objects are not just pieces of data but may have other types of capabilities encapsulated within a given object. Also the database may be implemented as a mix of data structures objects and relational structures. Databases may be consolidated and or distributed in countless variations through standard data processing techniques. Portions of databases e.g. tables may be exported and or imported and thus decentralized and or integrated.

In one embodiment the database component includes several tables . A Users table may include fields such as but not limited to user id ssn dob first name last name age state address firstline address secondline zipcode devices list contact info contact type alt contact info alt contact type and or the like. The Users table may support and or track multiple entity accounts on a CRV. A Clients table may include fields such as but not limited to client id client name client ip client type client model operating system os version app installed flag and or the like. A Hosts table may include fields such as but not limited to host id ip address client id user id permission level boot state and or the like. An OSes table may include fields such as but not limited to os id os name major version num manufacturer release date iso file and or the like. An OS Patches table may include fields such as but not limited to os patch id os id patch number release date patch location iso file and or the like. A Conditional Statements table may include fields such as but not limited to conditional statement id os id os patch id decision tree statement contents and or the like. A Register Values table may include fields such as but not limited to register value id register name register value os id sample timestamp and or the like. A Boot Status Results table may include fields such as but not limited to boot status result id status value os id host id status timestamp and or the like. An Entropies table may include fields such as but not limited to entropy id register name entropy value os id sample timestamp machine state and or the like. A Virtual Machines table may include fields such as but not limited to vm id vm name vm hard drive file vm last booted timestamp and or the like. A Virtual Machine Images table may include fields such as but not limited to vm image id vm iso file vm image name vm image location last updated timestamp and or the likeIn one embodiment the CRV database component may interact with other database systems. For example when employing a distributed database system. In such an embodiment queries and data access by any CRV component may treat the combination of the CRV database component results and results from a second segment in a distributed database system as an integrated database layer. Such a database layer may be accessed as a single database entity for example through CRV database component by any CRV component.

In one embodiment user programs may contain various user interface primitives which may serve to update the CRV. Also various accounts may require custom database tables depending upon the environments and the types of clients the CRV may need to serve. It should be noted that any unique fields may be designated as a key field throughout. In an alternative embodiment these tables have been decentralized into their own databases and their respective database controllers i.e. individual database controllers for each of the above tables . Employing standard data processing techniques one may further distribute the databases over several computer systemizations and or storage devices. Similarly configurations of the decentralized database controllers may be varied by consolidating and or distributing the various database components . The CRV may be configured to keep track of various settings inputs and parameters via database controllers.

The CRV database may communicate to and or with other components in a component collection including itself and or facilities of the like. Most frequently the CRV database communicates with the CRV component other program components and or the like. The database may contain retain and provide information regarding other nodes and data.

The CRV component is a stored program component that is executed by a CPU. In one embodiment the CRV component incorporates any and or all combinations of the aspects of the CRV that was discussed in the previous figures. As such the CRV affects accessing obtaining and the provision of information services transactions and or the like across various communications networks. The features and embodiments of the CRV discussed herein increase network efficiency by reducing data transfer requirements the use of more efficient data structures and mechanisms for their transfer and storage. As a consequence more data may be transferred in less time and latencies with regard to data processing operations and transactions are also reduced. In many cases such reduction in storage transfer time bandwidth requirements latencies etc. will reduce the capacity and structural infrastructure requirements to support the CRV s features and facilities and in many cases reduce the costs energy consumption requirements and extend the life of CRV s underlying infrastructure this has the added benefit of making the CRV more reliable. Similarly many of the features and mechanisms are designed to be easier for users to use and access thereby broadening the audience that may enjoy employ and exploit the feature sets of the CRV such ease of use also helps to increase the reliability of the CRV. In addition the feature sets include heightened security as noted via the Cryptographic components and throughout making access to the features and data more reliable and secure.

The CRV component can transform register retrieval requests and or the like via various components described herein into boot success messages and screenshot captured responses. In one embodiment the CRV component takes inputs e.g. create OS variant input pre OS loaded input OS loaded input OS loaded signal pre OS loaded signal OS screenshot register profiler launch request create variants message image request launch OS request boot screen register sample request GUI loaded screen extended register sample request boot VM server input boot server request message boot notification message with OS metadata register retrival request screenshot capture request and or the like etc. and transforms the inputs via various components e.g. OSVG Component RPS Component OBC Component and or the like into outputs e.g. image response launch OS response boot screen register sample response stream GUI loaded screen extended register sample response stream register retrieval response screen capture response boot failure message boot success message and or the like .

The CRV component enabling access of information between nodes may be developed by employing standard development tools and languages such as but not limited to Apache components Assembly ActiveX binary executables ANSI Objective C C and or .NET database adapters CGI scripts Java JavaScript mapping tools procedural and object oriented development tools PERL PHP Python shell scripts SQL commands web application server extensions web development environments and libraries e.g. Microsoft s ActiveX Adobe AIR FLEX FLASH AJAX D HTML Dojo Java JavaScript jQuery jQuery UI MooTools Prototype script.aculo.us Simple Object Access Protocol SOAP SWFObject Yahoo User Interface and or the like WebObjects and or the like. In one embodiment the CRV server employs a cryptographic server to encrypt and decrypt communications. The CRV component may communicate to and or with other components in a component collection including itself and or facilities of the like. Most frequently the CRV component communicates with the CRV database component operating system component other program components and or the like. The CRV may contain communicate generate obtain and or provide program component system user and or data communications requests and or responses.

The structure and or operation of any of the CRV node controller components may be combined consolidated and or distributed in any number of ways to facilitate development and or deployment. Similarly the component collection may be combined in any number of ways to facilitate deployment and or development. To accomplish this one may integrate the components into a common code base or in a facility that can dynamically load the components on demand in an integrated fashion.

The component collection may be consolidated and or distributed in countless variations through standard data processing and or development techniques. Multiple instances of any one of the program components in the program component collection may be instantiated on a single node and or across numerous nodes to improve performance through load balancing and or data processing techniques. Furthermore single instances may also be distributed across multiple controllers and or storage devices e.g. databases. All program component instances and controllers working in concert may do so through standard data processing communication techniques.

The configuration of the CRV controller will depend on the context of system deployment. Factors such as but not limited to the budget capacity location and or use of the underlying hardware resources may affect deployment requirements and configuration. Regardless of if the configuration results in more consolidated and or integrated program components results in a more distributed series of program components and or results in some combination between a consolidated and distributed configuration data may be communicated obtained and or provided. Instances of components consolidated into a common code base from the program component collection may communicate obtain and or provide data. This may be accomplished through intra application data processing communication techniques such as but not limited to data referencing e.g. pointers internal messaging object instance variable communication shared memory space variable passing and or the like.

If component collection components are discrete separate and or external to one another then communicating obtaining and or providing data with and or to other component components may be accomplished through inter application data processing communication techniques such as but not limited to Application Program Interfaces API information passage distributed Component Object Model D COM Distributed Object Linking and Embedding D OLE and or the like Common Object Request Broker Architecture CORBA Jini local and remote application program interfaces JavaScript Object Notation JSON Remote Method Invocation RMI SOAP Representational State Transfer REST process pipes shared files and or the like. Messages sent between discrete component components for inter application communication or within memory spaces of a singular component for intra application communication may be facilitated through the creation and parsing of a grammar. A grammar may be developed by using development tools such as lex yacc XML and or the like which allow for grammar generation and parsing capabilities which in turn may form the basis of communication messages within and between components.

where Value is discerned as being a parameter because http is part of the grammar syntax and what follows is considered part of the post value. Similarly with such a grammar a variable Value may be inserted into an http post command and then sent. The grammar syntax itself may be presented as structured data that is interpreted and or otherwise used to generate the parsing mechanism e.g. a syntax description text file as processed by lex yacc etc. . Also once the parsing mechanism is generated and or instantiated it itself may process and or parse structured data such as but not limited to character e.g. tab delineated text HTML structured text streams XML and or the like structured data. Further the parsing grammar may be used beyond message parsing but may also be used to parse databases data collections data stores structured data and or the like. Again the desired configuration will depend upon the context environment and requirements of system deployment.

1. A method for determining when to capture a screenshot of a virtual machine s display output by using the entropy of the virtual machine s CPU registers comprising 

A retrieving via a processor from a hypervisor providing virtualization services to the virtual machine a plurality of virtual CPU register values for at least one virtual CPU register of the virtual machine 

B calculating for the at least one virtual CPU register an at least one register entropy value based on the plurality of virtual CPU register values 

C determining via the processor using the at least one register entropy value a first boot state value for the virtual machine and

D initiating an automated virtual machine display output capture when the first boot state value is equal to a second boot state value to generate a screenshot image file representing the virtual machine display output.

2. The method of embodiment 1 wherein the first boot state value and or the second boot state value indicate one of the following virtual machine states 

3. The method of embodiment 2 wherein the boot success state is present when an operating system running on the virtual machine has successfully finished booting.

4. The method of embodiment 2 wherein the boot in progress state is present when an operating system running on the virtual machine is currently booting.

5. The method of embodiment 2 wherein the boot error state is present when an operating system running on the virtual machine is experiencing an error condition.

6. The method of embodiment 1 wherein A B and C are repeated sequentially while the first boot state value indicates a boot in progress state and the second boot state value indicates a boot success state.

7. The method of embodiment 6 wherein the repeating of A B and C automatically terminates upon the elapsing of a time quantum.

8. The method of embodiment 7 wherein the time quantum is the estimated maximum time for an operating system to boot on the virtual machine.

9. The method of embodiment 7 wherein the elapsing of the time quantum indicates that the virtual machine is in a boot error state.

electronically capturing when the virtual machine is in a boot error state a screenshot image file representing the virtual machine display output 

performing on the screenshot image file representing the virtual machine display output of the booting virtual machine in a boot error state automated optical character recognition in order to determine a boot error message 

transmitting the error report to an administrator user as an indication of an unsuccessful backup image verification.

11. The method of embodiment 1 wherein the virtual machine is in communication with a virtual data store.

12. The method of embodiment 11 wherein the virtual data store content comprises a bootable operating system.

13. The method of embodiment 11 wherein the virtual data store content comprises the content of a backup image file.

14. The method of embodiment 13 wherein the backup image file is a representation of the block level data stored on a source computer block storage device wherein the source computer block storage device previously underwent a backup procedure in order to generate the backup image file.

1. An apparatus to determine when to capture a screenshot of a virtual machine s display output by calculating the entropy of the virtual machine s CPU registers comprising 

a processor disposed in communication with said memory and configured to issue a plurality of processing instructions stored in the memory wherein the processor issues instructions to 

A retrieve via a processor from a hypervisor providing virtualization services to the virtual machine a plurality of virtual CPU register values for at least one virtual CPU register of the virtual machine 

B calculate for the at least one virtual CPU register an at least one register entropy value based on the plurality of virtual CPU register values 

C determine via the processor using the at least one register entropy value a first boot state value for the virtual machine and

D initiate an automated virtual machine display output capture when the first boot state value is equal to a second boot state value to generate a screenshot image file representing the virtual machine display output.

2. The apparatus of embodiment 1 wherein the first boot state value and or the second boot state value indicate one of the following virtual machine states 

3. The apparatus of embodiment 2 wherein the boot success state is present when an operating system running on the virtual machine has successfully finished booting.

4. The apparatus of embodiment 2 wherein the boot in progress state is present when an operating system running on the virtual machine is currently booting.

5. The apparatus of embodiment 2 wherein the boot error state is present when an operating system running on the virtual machine is experiencing an error condition.

6. The apparatus of embodiment 1 wherein A B and C are repeated sequentially while the first boot state value indicates a boot in progress state and the second boot state value indicates a boot success state.

7. The apparatus of embodiment 6 wherein the repeating of A B and C automatically terminates upon the elapsing of a time quantum.

8. The apparatus of embodiment 7 wherein the time quantum is the estimated maximum time for an operating system to boot on the virtual machine.

9. The apparatus of embodiment 7 wherein the elapsing of the time quantum indicates that the virtual machine is in a boot error state.

electronically capture when the virtual machine is in a boot error state a screenshot image file representing the virtual machine display output 

perform on the screenshot image file representing the virtual machine display output of the booting virtual machine in a boot error state automated optical character recognition in order to determine a boot error message 

transmit the error report to an administrator user as an indication of an unsuccessful backup image verification.

11. The apparatus of embodiment 1 wherein the virtual machine is in communication with a virtual data store.

12. The apparatus of embodiment 11 wherein the virtual data store content comprises a bootable operating system.

13. The apparatus of embodiment 11 wherein the virtual data store content comprises the content of a backup image file.

14. The apparatus of embodiment 13 wherein the backup image file is a representation of the block level data stored on a source computer block storage device wherein the source computer block storage device previously underwent a backup procedure in order to generate the backup image file.

1. A non transitory medium to determine when to capture a screenshot of a virtual machine s display output by calculating the entropy of the virtual machine s CPU registers storing instructions comprising 

A retrieve via a processor from a hypervisor providing virtualization services to the virtual machine a plurality of virtual CPU register values for at least one virtual CPU register of the virtual machine 

B calculate for the at least one virtual CPU register an at least one register entropy value based on the plurality of virtual CPU register values 

C determine via the processor using the at least one register entropy value a first boot state value for the virtual machine and

D initiate an automated virtual machine display output capture when the first boot state value is equal to a second boot state value to generate a screenshot image file representing the virtual machine display output.

2. The non transitory medium of embodiment 1 wherein the first boot state value and or the second boot state value indicate one of the following virtual machine states 

3. The non transitory medium of embodiment 2 wherein the boot success state is present when an operating system running on the virtual machine has successfully finished booting.

4. The non transitory medium of embodiment 2 wherein the boot in progress state is present when an operating system running on the virtual machine is currently booting.

5. The non transitory medium of embodiment 2 wherein the boot error state is present when an operating system running on the virtual machine is experiencing an error condition.

6. The non transitory medium of embodiment 1 wherein A B and C are repeated sequentially while the first boot state value indicates a boot in progress state and the second boot state value indicates a boot success state.

7. The non transitory medium of embodiment 6 wherein the repeating of A B and C automatically terminates upon the elapsing of a time quantum.

8. The non transitory medium of embodiment 7 wherein the time quantum is the estimated maximum time for an operating system to boot on the virtual machine.

9. The non transitory medium of embodiment 7 wherein the elapsing of the time quantum indicates that the virtual machine is in a boot error state.

electronically capture when the virtual machine is in a boot error state a screenshot image file representing the virtual machine display output 

perform on the screenshot image file representing the virtual machine display output of the booting virtual machine in a boot error state automated optical character recognition in order to determine a boot error message 

transmit the error report to an administrator user as an indication of an unsuccessful backup image verification.

11. The non transitory medium of embodiment 1 wherein the virtual machine is in communication with a virtual data store.

12. The non transitory medium of embodiment 11 wherein the virtual data store content comprises a bootable operating system.

13. The non transitory medium of embodiment 11 wherein the virtual data store content comprises the content of a backup image file.

14. The non transitory medium of embodiment 13 wherein the backup image file is a representation of the Mock level data stored on a source computer block storage device wherein the source computer block storage device previously underwent a backup procedure in order to generate the backup image file.

1. A processor implemented method of determining a server machine state utilizing register values comprising 

querying via a processor a data store for a register conditional statement associated with the configuration identifier 

7. The method of embodiment 1 wherein the first state represents the server in a booting state and the second state represents the server in an operating system loaded success state.

8. The method of embodiment 1 wherein the first state represents the server in a booting state and the second state represents the server in an operating system loaded failure state.

9. The method of embodiment 1 wherein the first state represents the server in a state where a first application is not running and the second state represents the server in a state where the first application is successfully running.

10. The method of embodiment 1 wherein the first state represents the server in a state where a first device driver is not loaded and the second state represents the server in a state where the first device driver is loaded.

7. The apparatus of embodiment 1 wherein the first state represents the server in a booting state and the second state represents the server in an operating system loaded success state.

8. The apparatus of embodiment 1 wherein the first state represents the server in a booting state and the second state represents the server in an operating system loaded failure state.

9. The apparatus of embodiment 1 wherein the first state represents the server in a state where a first application is not running and the second state represents the server in a state where the first application is successfully running.

10. The apparatus of embodiment 1 wherein the first state represents the server in a state where a first device driver is not loaded and the second state represents the server in a state where the first device driver is loaded.

In order to address various issues and advance the art the entirety of this application for CRV including the Cover Page Title Headings Field Background Summary Brief Description of the Drawings Detailed Description Claims Abstract Figures Appendices and otherwise shows by way of illustration various embodiments in which the claimed innovations may be practiced. The advantages and features of the application are of a representative sample of embodiments only and are not exhaustive and or exclusive. They are presented only to assist in understanding and teach the claimed principles. It should be understood that they are not representative of all claimed innovations. As such certain aspects of the disclosure have not been discussed herein. That alternate embodiments may not have been presented for a specific portion of the innovations or that further undescribed alternate embodiments may be available for a portion is not to be considered a disclaimer of those alternate embodiments. It will be appreciated that many of those undescribed embodiments incorporate the same principles of the innovations and others are equivalent. Thus it is to be understood that other embodiments may be utilized and functional logical operational organizational structural and or topological modifications may be made without departing from the scope and or spirit of the disclosure. As such all examples and or embodiments are deemed to be non limiting throughout this disclosure. Also no inference should be drawn regarding those embodiments discussed herein relative to those not discussed herein other than it is as such for purposes of reducing space and repetition. For instance it is to be understood that the logical and or topological structure of any combination of any program components a component collection other components and or any present feature sets as described in the figures and or throughout are not limited to a fixed operating order and or arrangement but rather any disclosed order is exemplary and all equivalents regardless of order are contemplated by the disclosure. Furthermore it is to be understood that such features are not limited to serial execution but rather any number of threads processes services servers and or the like that may execute asynchronously concurrently in parallel simultaneously synchronously and or the like are contemplated by the disclosure. As such some of these features may be mutually contradictory in that they cannot be simultaneously present in a single embodiment. Similarly some features are applicable to one aspect of the innovations and inapplicable to others. In addition the disclosure includes other innovations not presently claimed. Applicant reserves all rights in those presently unclaimed innovations including the right to claim such innovations file additional applications continuations continuations in part divisionals and or the like thereof. As such it should be understood that advantages embodiments examples functional features logical operational organizational structural topological and or other aspects of the disclosure are not to be considered limitations on the disclosure as defined by the claims or limitations on equivalents to the claims. It is to be understood that depending on the particular needs and or characteristics of a CRV individual and or enterprise user database configuration and or relational model data type data transmission and or network framework syntax structure and or the like various embodiments of the CRV may be implemented that enable a great deal of flexibility and customization as described herein.

