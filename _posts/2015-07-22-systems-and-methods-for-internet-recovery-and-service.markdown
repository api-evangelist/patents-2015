---

title: Systems and methods for internet recovery and service
abstract: Systems and methods for Internet recovery and service. In some embodiments, an Information Handling System (IHS) may comprise a processor and a Basic I/O System (BIOS) coupled to the processor, the BIOS having program instructions stored thereon that, upon execution by the processor, cause the IHS to: transmit a request to a backend server for a service Operating System (OS), where the request includes an identification (ID) of the IHS that enables the backend server to select two or more of a plurality of service OS components; receive the selected service OS components over a network; assemble the selected service OS components into the service OS; and boot the service OS.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529602&OS=09529602&RS=09529602
owner: DELL PRODUCTS, L.P.
number: 09529602
owner_city: Round Rock
owner_country: US
publication_date: 20150722
---
This disclosure relates generally to computer systems and more specifically to systems and methods for Internet recovery and service.

As the value and use of information continues to increase individuals and businesses seek additional ways to process and store information. One option is an Information Handling System IHS . An IHS generally processes compiles stores and or communicates information or data for business personal or other purposes. Because technology and information handling needs and requirements may vary between different applications IHSs may also vary regarding what information is handled how the information is handled how much information is processed stored or communicated and how quickly and efficiently the information may be processed stored or communicated. The variations in IHSs allow for IHSs to be general or configured for a specific user or specific use such as financial transaction processing airline reservations enterprise data storage global communications etc. In addition IHSs may include a variety of hardware and software components that may be configured to process store and communicate information and may include one or more computer systems data storage systems and networking systems.

In many situations an IHS may need to be serviced or supported. For example the IHS may have hardware and or software that needs to be fixed updated removed installed or replaced from time to time. To address these and other problems certain systems and methods described herein may enable a computer manufacturer or service provider to allow customers to have access to automated simplified support actions or operations for example even when an IHS is not otherwise able to boot to its main Operating System OS or has other serious hardware or software failures.

Embodiments of systems and methods for Internet recovery and service are described herein. In an illustrative non limiting embodiment an Information Handling System IHS may include a processor and a Basic I O System BIOS coupled to the processor the BIOS having program instructions stored thereon that upon execution by the processor cause the IHS to transmit a request to a backend server for a service Operating System OS wherein the request includes an identification ID of the IHS that enables the backend server to select two or more of a plurality of service OS components receive the selected service OS components over a network assemble the selected service OS components into the service OS and boot the service OS.

In some cases the IHS may not include a usable copy of the service OS in a local memory storage device. In other cases the IHS may include an older version of the service OS in a local memory storage device. Moreover the ID may be stored in the BIOS. For example the ID may uniquely identify the IHS s type family or version.

The service OS components may include a given one of a plurality of bootloaders and the given bootloader may be selected by the backend server based at least in part upon the ID. Additionally or alternatively the service OS components may include a given one of a plurality of bootloader customizations and the given bootloader customization may be selected by the backend server based at least in part upon the ID. Additionally or alternatively the service OS components may include a given one of a plurality of driver packages and the given driver package may be selected by the backend server based at least in part upon the ID. Additionally or alternatively the service OS components may include a given one of a plurality of service OS applications and the given service OS application may be selected by the backend server based at least in part upon the ID.

In various implementations the program instructions may further cause the IHS to receive a manifest file from the backend server over the cloud and the manifest file may include a list of each of the selected service OS components. To receive the service OS components the program instructions may further cause the IHS to download each of the plurality of service OS components into the memory in a layered fashion and assemble the downloaded service OS components into the service OS in the memory.

Moreover the downloaded service OS components may include a service OS application and the service OS application may be configured to upon execution by the IHS enable a user to perform one or more support related operations while at least one other service OS component is being downloaded. The program instructions may further cause the IHS to transmit another request to the backend server where the request includes the ID of the IHS and receive another service OS over the cloud where the other service OS includes one or more service OS components distinct from corresponding components in the service OS.

In another illustrative non limiting embodiment a computer implemented method may include receiving a request at a backend server for a service OS where the request includes an ID of an IHS selecting by the backend server two or more of a plurality of service OS components based upon the ID and providing by the backend server to the IHS a manifest file that includes a list of each of the selected service OS components where the IHS is configured to retrieve the selected service OS components assemble the selected service OS components into the service OS and boot the service OS.

In yet another illustrative non limiting embodiment a memory device may have program instructions stored thereon that upon execution by an IHS cause the IHS to receive a request for a service OS where the request includes an ID of a malfunctioning IHS select service OS components based on the ID the service OS components including a bootloader a driver package and a service OS application provide to the malfunctioning IHS a manifest file that includes a list of the selected service OS components where the malfunctioning IHS is configured to retrieve the listed service OS components assemble the selected service OS components into the service OS and boot the service OS.

In some embodiments one or more of the techniques described herein may be performed at least in part by an IHS operated by a user. In other embodiments these techniques may be performed by an IHS having a processor and a memory coupled to the processor the memory including program instructions stored thereon that upon execution by the processor cause the IHS to execute one or more operations. In yet other embodiments a non transitory computer readable medium or memory device may have program instructions stored thereon that upon execution by an IHS cause the IHS to execute one or more of the techniques described herein.

To facilitate explanation of the various systems and methods discussed herein the following description has been split into sections. It should be noted however that the various sections headings and subheadings used herein are for organizational purposes only and are not meant to limit or otherwise modify the scope of the description or the claims.

The inventors hereof have recognized a need for providing systems and methods for service and support to computing devices. Existing tools intended to facilitate service and or support of a client device or Information Handling System IHS do not adequately address numerous problems such as for example situations when the IHS fails to boot a main Operating System OS for any reason whether due to a hardware of software problem such that the IHS is said to be in a degraded state. To address these and other concerns embodiments described herein provide Basic I O System BIOS and or service OS level intelligence to enable a client device to self diagnose and to receive automated service and support. Additionally or alternatively in some embodiments the main OS may be modified to implement one of more of the foregoing features.

The term degraded state as used herein refers to the state of an IHS that is not capable of booting a main OS e.g. WINDOWS MAC OS LINUX etc. either fully or partially e.g. in WINDOWS s safe mode or the like . When operating in a degraded state the IHS may still be able to execute BIOS instructions and or a service OS SOS .

The term BIOS as used herein refers to a type of firmware used during an IHS s booting process e.g. power on or reset . The BIOS initializes and tests an IHS hardware components and loads a boot loader or an OS from a memory device. The BIOS additionally provides an abstraction layer for the hardware which enables software executed by the IHS to interact with certain I O devices such as keyboards displays etc. Incidentally the Unified Extensible Firmware Interface UEFI was designed as a successor to BIOS to address certain technical issues. As a result modern IHSs predominantly use UEFI firmware and the term BIOS as used herein is intended also encompass UEFI firmware and future variations thereof.

The term service OS as used herein refers to one or more program instructions or scripts distinct from an IHS s main OS such that upon execution by an IHS e.g. upon failure by the IHS to load the main OS enable one or more support diagnostics or remediation operations to be performed independently of the state of the main OS. The service OS may include one or more service and support applications as described in more detail below. In some cases an SOS may be stored in a recovery partition of a hard drive. Additionally or alternatively an SOS may be stored in a Non Volatile Memory NVM or flash memory built into the client system. Additionally or alternatively the SOS may be stored in a remote location so as to allow an IHS to boot remotely from the cloud. 

In some embodiments service capabilities may be invoked either pre boot or pre OS. Pre boot capabilities may be built into the BIOS UEFI and pre OS capabilities may be provided by a service OS. For example pre boot services may include using enhanced BIOS diagnostics tools to detect hardware failure providing a Quick Response QR code to simplify access to support services etc. Meanwhile pre OS services may include enabling a service OS to provide customer automated assistance using built in remediation scripts to help diagnose and remediate the device improve support efficiency using live chat remote control support etc. In some implementations pre boot services may be focused on no boot scenarios whereas pre OS services may be focused on operations such as remediation boot from web re imaging from web etc.

As will be understood by a person of ordinary skill in the art in light of this disclosure virtually any IHS environment that requires service or support may implement one or more aspects of the systems and methods described herein. Furthermore certain aspects of the connected systems described herein may be implemented by computer manufacturers software providers and or service or support companies.

Turning now to a diagram illustrating an example of an environment where systems and methods for providing service and support to computing devices may be implemented is depicted according to some embodiments. As shown each of any number of client devices A N may be an IHS or other computing device generically referred to as IHS client client device or device including for example desktops laptops tablets smartphones and any other all in one AIO data processing device. In some situations devices may be located in geographically distributed or remote locations such as offices homes etc. Each device may be operated by an individual end consumer e.g. lay person or customer of a computer manufacturer or software provider for instance. In some cases two or more of client devices A N may be deployed within or managed by the same organization e.g. a business .

Tools intended to facilitate service and or support of client devices include service technicians live support operators and or backend service . Service technicians include trained employees or contractors that can travel to the site of device or that can receive the physical device e.g. at a retail store by mail etc. or part s thereof in order to make repairs for example. Live support operator s may be available for instance when device fails but it is sufficiently operational that it can still connect the user to operator s via chat email text messages Voice Over Internet Protocol VoIP call etc. Additionally or alternatively the user of client device may place a conventional phone call to live support operator s e.g. using a 1 800 number or the like . In some cases live support operator s may interactively guide the user in an effort to correct problems with client device e.g. troubleshooting .

Backend service may include one or more servers and or IHSs configured to perform one or more automated operations with respect to device . In various implementations backend service may be configured to communicate with a service OS prior to and or independently of IHS being able to boot a main OS and it may enable one or more support diagnostics or remediation operations to be performed remotely including but not limited to telemetry error reporting tracking chat etc.

Entities may have access to network . In various embodiments telecommunications network may include one or more wireless networks circuit switched networks packet switched networks or any combination thereof to enable communications between two or more of IHSs. For example network may include a Public Switched Telephone Network PSTN one or more cellular networks e.g. third generation 3G fourth generation 4G or Long Term Evolution LTE wireless networks satellite networks computer or data networks e.g. wireless networks Wide Area Networks WANs metropolitan area networks MANs Local Area Networks LANs Virtual Private Networks VPN the Internet etc. or the like.

For purposes of this disclosure an IHS may include any instrumentality or aggregate of instrumentalities operable to compute calculate determine classify process transmit receive retrieve originate switch store display communicate manifest detect record reproduce handle or utilize any form of information intelligence or data for business scientific control or other purposes. For example an IHS may be a personal computer e.g. desktop or laptop tablet computer mobile device e.g. Personal Digital Assistant PDA or smart phone server e.g. blade server or rack server a network storage device or any other suitable device and may vary in size shape performance functionality and price. An IHS may include Random Access Memory RAM one or more processing resources such as a Central Processing Unit CPU or hardware or software control logic Read Only Memory ROM and or other types of NVMs.

Additional components of an IHS may include one or more disk drives one or more network ports for communicating with external devices as well as various I O devices such as a keyboard a mouse touchscreen and or a video display. An IHS may also include one or more buses operable to transmit communications between the various hardware components.

CPU s are coupled to northbridge controller or chipset via front side bus . Northbridge controller may be configured to coordinate I O traffic between CPU s and other components. For example in this particular implementation northbridge controller is coupled to graphics device s e.g. one or more video cards or adaptors via graphics bus e.g. an Accelerated Graphics Port or AGP bus a Peripheral Component Interconnect or PCI bus or the like . Northbridge controller is also coupled to system memory via memory bus and to hard disk drive HDD . Memory may be configured to store program instructions and or data accessible by CPU s . In various embodiments memory may be implemented using any suitable memory technology such as static RAM SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. Conversely HDD may include any magnetic solid state SSD or hybrid data storage device capable of storing an OS and other applications.

Northbridge controller is coupled to southbridge controller or chipset via internal bus . Generally speaking southbridge controller may be configured to handle various of IHS s I O operations and it may provide interfaces such as for instance Universal Serial Bus USB audio serial parallel Ethernet or the like via port s pin s and or adapter s over bus . For example southbridge controller may be configured to allow data to be exchanged between IHS and other devices such as other IHSs attached to a network e.g. network . In various embodiments southbridge controller may support communication via wired or wireless general data networks such as any suitable type of Ethernet network for example via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fiber Channel SANs or via any other suitable type of network and or protocol.

Southbridge controller may also enable connection to one or more keyboards keypads touch screens scanning devices voice or optical recognition devices or any other devices suitable for entering or retrieving data. Multiple I O devices may be present in IHS . In some embodiments I O devices may be separate from IHS and may interact with IHS through a wired or wireless connection. As shown southbridge controller is further coupled to one or more PCI devices e.g. modems network cards sound cards or video cards and to one or more SCSI controllers via parallel bus .

Southbridge controller is also coupled to BIOS UEFI module and to Super I O Controller via Low Pin Count LPC bus . BIOS UEFI module includes non volatile memory having program instructions stored thereon. Those instructions may be usable by CPU s to initialize and test other hardware components and or to load an OS onto IHS . Super I O Controller combines interfaces for a variety of lower bandwidth or low data rate devices. Those devices may include for example floppy disks parallel ports keyboard and mouse temperature sensor and fan speed monitoring control among others. In various implementations southbridge controller may be configured to allow data to be exchanged between BIOS UEFI and another IHS attached to network e.g. a remote server or other source of technical service using wired or wireless capabilities of network adapter .

In some cases IHS may be configured to provide access to different types of computer accessible media separate from memory . Generally speaking a computer accessible medium may include any tangible non transitory storage media or memory media such as electronic magnetic or optical media e.g. magnetic disk a hard drive a CD DVD ROM a Flash memory etc. coupled to IHS via northbridge controller and or southbridge controller .

The terms tangible and non transitory as used herein are intended to describe a computer readable storage medium or memory excluding propagating electromagnetic signals but are not intended to otherwise limit the type of physical computer readable storage device that is encompassed by the phrase computer readable medium or memory. For instance the terms non transitory computer readable medium or tangible memory are intended to encompass types of storage devices that do not necessarily store information permanently including for example RAM. Program instructions and data stored on a tangible computer accessible storage medium in non transitory form may afterwards be transmitted by transmission media or signals such as electrical electromagnetic or digital signals which may be conveyed via a communication medium such as a network and or a wireless link.

A person of ordinary skill in the art will appreciate that IHS is merely illustrative and is not intended to limit the scope of the disclosure described herein. In particular any computer system and or device may include any combination of hardware or software capable of performing certain operations described herein. In addition the operations performed by the illustrated components may in some embodiments be performed by fewer components or distributed across additional components. Similarly in other embodiments the operations of some of the illustrated components may not be performed and or other additional operations may be available.

For example in some implementations northbridge controller may be combined with southbridge controller and or be at least partially incorporated into CPU s . In other implementations one or more of the devices or components shown in may be absent or one or more other components may be added. Accordingly systems and methods described herein may be implemented or executed with other IHS configurations.

As mentioned above in various embodiments certain service capabilities may be built at least in part into a client device s BIOS UEFI . In that regard shows block diagram of an example of BIOS UEFI module . Particularly BIOS UEFI includes NVM mailbox configured to store program instructions that upon execution provide and or receive one or more service and support parameters or information to or from control logic of CPU s to implement one or more service and support applications described in detail below. In some cases NVM mailbox may serve as a mailbox to track issues and other information persistently. As noted above however at least a part of the aforementioned service capabilities may be provided via a service OS that is stored at least in part within a designated a partition of HDD and or on a remote IHS accessible to BIOS UEFI via network .

In some embodiments a variety of service and support applications may be at least partially embedded into BIOS UEFI module and or NVM mailbox as described below.

Systems and methods described herein may include a service and support application configured to provide automated services. In some embodiments client device BIOS level intelligence may be provided to execute self diagnosis and to assist in automated services. Service capabilities are built into client device BIOS diagnostics pre boot service OS on disk or boot from cloud. Moreover these capabilities may be integrated with a services backend for automated client device error reporting tracking chat remediation etc.

In some embodiments an automated diagnostics procedure of an automated service and support application may include performing a BIOS diagnostics to discriminate hardware from software issues e.g. broken HDD or corrupt OS . Then BIOS UEFI s NVM mailbox may be used to track issues persistently from BIOS pre OS OS and or backend sources.

Upon detection of a failure a determination may be made as to the severity of that failure e.g. whether the failure is severe such as in a no video situation a no network scenario etc. or whether it is a simple failure such as an OS problem and remedial action s may then be taken by the automated service and support application as deemed appropriate. For example if a network is not available a Quick Response QR code or audio may be used to provide diagnostic failure and device identification information. Conversely if the network is available the automated service and support application may activate a phone home capability upon detection of a failure and it may boot the client device to a service OS.

In that scenario the client device may connect directly with a backend service Application Programming Interface API to initiate a warranty check e.g. via hardware service tag as hardware ID generate a service case update debug data initiate recovery or remediation operations etc. In some cases the automated service and support application may trigger an automatic dispatch of customer replaceable units CRUs parts or components within the client device.

At the point of need which often coincides with the point of failure the automated service and support application may make service offers based on failure diagnoses. For example such service offers may include an out of warranty upsell warranty upgrade additional service offers e.g. HDD recovery for dead drive upsell warranty carry in capability e.g. report closest repair facilities for carry in service etc.

Moreover with respect to recovery and remediation the automated service and support application may provide remote control remote scripting diagnostics live customer support backup re imaging and OS re install via local factory image or via web and the like.

Systems and methods described herein may include a service and support application configured to provide technical support in no video situations which are otherwise difficult to troubleshoot. In many cases when client device is not capable of outputting a video signal users have no other option but to place a phone call to the manufacturer because the device itself can provide no help.

To address this and other concerns a service and support application as described herein may include a audio only support system for example similar to an automated phone support system or Interactive Voice Response IVR but that is local to client device and capable of running in a pre OS or pre Boot environment. While a customer is interacting with the service and support application client device can run a diagnostics procedure. When appropriate the service and support application may handoff the local automated audio support to online voice support from the IHS manufacturer. If network is unavailable client device may prompt the user to connect directly to a nearby device distinct from client device to perform one or more of these operations.

In some embodiments the service and support application may include pre OS availability of audio based troubleshooting offline audio support concurrent with diagnostics and or merging or handover between offline and online audio support. The service and support application may also prompt the user to make peer to peer P2P connection to a nearby device readout codes for diagnosis dispatch verification and or prompt the user to add or insert external storage to which to output diagnostic results.

Systems and methods described herein may include a service and support application configured to provide an automated and authenticated mayday beacon with a cost effective 1 to 1 support for verified client device s failures.

When client device experiences a fault or hang before its main OS is made available a wireless signal beacon e.g. Bluetooth Wi Fi etc. may be sent e.g. on a periodic basis containing verification of the device credentials issued at the time of manufacture details regarding the fault and a direct link to the manufacturer s support decision tree location and or whether a premium account is linked. The beacon may be authenticated directly to a support representative with all failure information logged and available. This technique may prevent erroneous support calls by verifying the user has actually experienced a failure and authenticating that the proper support level has been funded which promotes a low cost one on one support service.

In some embodiments the service and support application may be configured to broadcast a distress signal with credentials to make authenticated jump to a support site provided by backend services from a secondary device or infrastructure. A certificate may be issued from the manufacturer containing client device s platform user information and or service level. Such a certificate and a landing page for service may be passed automatically while client device is out of service. Also the service may be rendered utilizing secondary device or infrastructure via authenticated and verified client device experiencing failure.

Systems and methods described herein may include a service and support application configured to provide network e.g. Internet recovery and service.

When client device fails it may phone home and boot from backend services a service OS to provide automated service and support. A service and support application in BIOS UEFI may include for example a boot loader where to go e.g. an IP address booting proper image for machine and or a service application. As such the service and support application may provide a smarter BIOS UEFI smart diagnostics in BIOS UEFI intelligent boot selection to local drive or web and IP awareness among other features.

In some implementations the service OS may be supported on many platforms and on many versions of those platforms. For example a single platform e.g. having a model name or number may be shipped from the manufacturer with different hardware configurations e.g. different CPUs etc. thus each combination of platform and version requiring that different specific drivers be built into or provided for in the service OS.

In some embodiments the service and support application may be configured to provide a Unified Extensible Firmware Interface UEFI BIOS module with smart diagnostics and IP support intelligently controls boot to a service OS. Client device connects to backend services to get proper and latest service OS for that particular device. Backend service or server may receive a client manifest and it may dynamically serve a service OS kernel drivers and a service application to client device for recovery and or remediation.

Systems and methods described herein may include a service and support application configured to improve customer experience while downloading a recovery OS by reducing the perception of wait time.

When client device has a malfunction it can boot to an alternate or service OS. In some cases the alternate or service OS is downloaded via network before client device is able to boot. The download time is variable often nontrivial and may negatively affect customer perception. To counter this the service and support application may estimate the download time of the alternate or service OS and based on an assessment of the delay may pull forward one or more low bandwidth activities and or options that the customer may need or desire to do anyway e.g. updating contact information thus helping save customer time and reducing the perception of delay.

In some embodiments the service and support application may be configured to prioritize lower bandwidth tasks based on estimated OS load time. Prioritization of activities may be based for example upon data about malfunction. As such the application may enable user input or interaction while OS is downloading e.g. updating contact information describing the problem that happened before failure etc. . The application may also submit a phone number for text alerts when failed client device is ready and it may start a local interactive debug troubleshooting operation while the OS is being downloaded.

Systems and methods described herein may include a service and support application configured to provide identity continuity in the servicing of a failed client device .

When client device fails and needs service a user may need to enter service credentials on a service web portal provided by backend service or server whether accessing the portal directly or via a service OS. However the user may not recall such infrequently used credentials at the point of need. By storing both a main OS s user credential hash and a service portal token a service and support application can authenticate the user and then automatically submit the service portal token to log user into the service portal without manual entry of customer credentials. This method may also be used to allow access to customers Wi Fi profiles and other type of data that needs protection.

In some embodiments the service and support application may be configured to use a BIOS s mailbox to communicate one or more services token s to enable a single sign on procedure while protecting the token s with user credentials.

Systems and methods described herein may include a service and support application configured to perform smart diagnosis and triage of client device failures.

In some cases the application may provide an automated method of hardware exoneration identifying software versus hardware issues with targeted debug. POST may be used to detect issues during power on sequence then those results may be used for firmware based diagnostics for next level of hardware diagnostics. Main OS POST and firmware based diagnostic results may be stored on the client device s BIOS s NVM or mailbox as device health data. In case client device is not able to boot its main OS a service OS may be started and uses health data to either run even more extensive hardware diagnostics or to run software fault detection and remediation test. Cloud connection to client device s manufacturer or backend service may facilitate the download of updated tests reporting of issues and initiation of replacement parts dispatch.

In some embodiments the service and support application may be configured to use a BIOS s NVM or mailbox to aggregate device health data. The application may use firmware and or a service OS. Each stage of diagnostics may use information from previous diagnostics results to target more detailed but specific subsequent tests.

Systems and methods described herein may include a service and support application configured to perform smart diagnosis using hosted resources. When client device cannot boot after repeated attempts it may begin a process to perform self evaluation and potentially self repair operations. Because having all executable diagnostics and repair modules present in the non bootable system would be costly operations may involve successively loading software modules from a remote support source . But modules loaded through internet wireless networks are likely slow to download and therefore should be reduced or minimized to be tailored exactly as needed for a given process.

To address these and other problems in some embodiments a service and support application may be configured to upload test results to backend service which automatically determines a subsequent module to be downloaded based on client device data and or historic analysis of other client devices. The application may provide a remote boot of diagnostic and repair software modules. Appropriate modules may be selected and or minimized to the next diagnosis stage in order to facilitate transfer over slow communications channels. A service may provide a reverse proxy for a hosted module to be loaded so that client device may boot from a single Uniform Resource Locator URL for each process.

Systems and methods described herein may include a service and support application configured to intelligently alter a boot order to aid in automated client device diagnosis and repair. When client device fails to completely boot it does not move on to another component as set in the boot order if a previously attempted component remains available for boot. Often the process gets stuck trying to boot and repair the main OS indefinitely. The pre set boot order remains static and unaltered.

In some embodiments by building intelligence into BIOS UEFI for determining a boot order for client device a service and support application may be configured to break out of a failing sequence and load alternative OSs and or repair and diagnostic modules from various local or remotely available resources selected by their availability performance or content. Depending upon the success of each stage client device may change the boot order again to try another source. A successful repair may lead back to booting the main OS as the primary boot resource. An alternative or service OS may result as the final stage if the main OS cannot be made bootable.

In some embodiments the service and support application may be configured to dynamically change a boot order based upon conditions of client device . The application may also set client device in temporary or permanent boot orders based upon the completion stage of the diagnosis and repair.

Systems and methods described herein may include a service and support application configured to export failure and diagnostic data from a malfunctioning client device. Client device may sometimes malfunction such that it cannot provide output or accept input from a user. It may still function at a low level however in order to capture its own failure codes and run diagnostics. These codes and diagnostic results are written to internal storage and are useful for system remediation but unfortunately remain captive on the malfunctioning client device.

To address these and other problems a service and support application may create an embedded capability that is triggered by a malfunction identifies the failure diagnostics data and exports the data upon insertion of an external storage device. The external device may then be taken to a functioning IHS or other client device which can receive the data for local analysis and or upload it for analysis or recordkeeping.

In some embodiments the service and support application may be configured to export the data to an external device having a marker file. The marker file may be generated by an IHS manufacturer or software provider and identifies the external device as belonging to an authorized service technician or other party. As such a service mode may be provided for malfunction situations in which a user cannot interact with or extract data from failed client device . Normal behavior that occurs when inserting an external storage device may be overridden in the service mode and instead client device may export related failure debug data to the external device. The service mode may be independent of the main OS.

Systems and methods described herein may include a service and support application configured to provide technician access to only services data on an encrypted drive. For diagnosis and remediation client device may use services data e.g. system telemetry failure and diagnostics data services history etc. . If a system has OS volume encryption e.g. BitLocker and fails over to a service OS the service OS cannot typically access the services data due to encryption. That is the latest and most valuable services data is trapped.

To address these and other concerns service and support application may create a separate services data partition in local storage e.g. client device s own hard drive also encrypted for consistency with user intent. The key for the services data partition may be different than the key used for the remainder of the volume encryption and may be stored by backend service with user permission to allow service technician access in controlled support situations. As such services data may be kept outside the inaccessible encrypted OS partition while still protected.

In some embodiments the service and support application may be configured to create a services data partition that is encrypted differently e.g. different key and or encryption algorithm than client device s main OS volume for purposes of services access. Access to the separately encrypted data may be useful to services applications and only visible to an authorized technician. Also the application may provide the ability to pull encryption key from cloud and decrypt service data on device distinct from the client device for example using technician credentials e.g. when network is not accessible by client device .

Systems and methods described herein may include a service and support application configured to protect the service OS administrator s password while allowing technician one time execution with elevated privileges. An initial password for a service OS may be created using a One Time Password OTP technique and a seed stored on client device s BIOS UEFI s NVM mailbox . The seed and a hardware service tag may be sent to backend services to provide a mechanism for service technician or live support operator s to run privileged applications in the service OS without using a master password. In some embodiments application of OTP in a support scenario may enable higher security for remote management and debug operations. NVM mailbox may be used for storing initial seed at factory tied to the client hardware service tag. A service technician at failure time may generate a code to request administrator permissions.

Systems and methods described herein may include a service and support application configured to provide automatic system stop and boot to a service OS for forensics analysis. In some embodiments detection of suspicious activity for secure systems may result in automated boot to service OS with automated forensics lockdown and analysis outside the potentially compromised main OS. The application may combine security intrusion or behavior capabilities with a service OS to provide new forensics features. For example detection of intrusion or malware in client device may initiate lock down mode boot to the service OS. The service OS then connects or phones home to backend services report a potential security incident and initiates data forensics collection. Client device may maintain a lockdown mode at BIOS level controlled by policy to maintain security of network and data for forensic analysis.

Systems and methods described herein may include a service and support application configured to migrate contents of an internal storage partition to a replacement storage device.

In some embodiments data contained on a secondary partition of client device s internal drive storage may be migrated from an old or existing drive to a replacement or upgraded drive by storing it in Dynamic RAM DRAM while the drive is hot swapped. If DRAM capacity is insufficient overflow may be handled by external storage e.g. USB drive for example. In another embodiment a Solid State Drive SSD portion may instead be a secondary partition on a standard hard drive. As such an application may migrate a specified drive partition into DRAM use external storage for data that exceeds the capacity of DRAM and or recognize and provisions replacement storage with contents of drive partition.

Systems and methods described herein may include a service and support application configured to increase the effectiveness of a service OS by utilizing a custom hypervisor.

A conventional service OS may be configured to run on client device only when the main OS is suspended. Such a conventional service OS may not be able to effectively monitor real time events in the main OS as they occur. For example a conventional service OS may only be able to examine the state of the primary disk data etc. using residual data collected by the main OS when the main OS was running. To address these and other concerns a service OS as described herein may run in a hypervisor in a first tier next to the main OS or in a second tier and the hypervisor may allow the service OS full access to the resources of the primary OS. Accordingly dynamic state of the primary OS may be monitored either constantly or periodically and actions and reports may occur immediately a watchdog OS .

In some embodiments a hypervisor environment may provide a service OS of client device with full access to the resources of the main OS but not necessarily vice versa for example to keep the main OS from being corrupted . The service OS may run as a peer of the primary OS. The peer service OS may be configured to monitor for process memory disk and other resources of the main OS and may be allowed to alter them as required.

At block method includes attempting to boot client device . For example block may be executed in response to a power on or reset event. Block determines whether a Power On Self Test POST procedure has been successfully performed upon client device by BIOS UEFI . If so then block determines whether a main OS has been successfully booted. In some cases a successful boot of the main OS may include a complete success in other cases however a successful boot may include cases where the main OS is booted in safe mode or the like with less than all of its functionality available to a user. If block detects successful boot of the main OS then control of client device is passed to the main OS at block and the method ends. In that case support and or service issues may be handled by the main OS.

Conversely if the POST operation fails at block service and support may be provided in a pre boot environment at block . Examples of service and support procedures available to client device in such a scenario include but is not limited to detecting network availability use of QR codes or the like with or without network connections collection and transmission of telemetry data and or event logs alerts and indications of failures and procedures for dealing with no video scenarios as outlined above.

If the main OS fails to boot at block block then determines whether a service OS can be booted. In some cases the service OS may be initiated from a memory local to the client device. For example the service OS may be stored in NVRAM or in a designated partition of HDD . Alternatively the service OS may be loaded from a backend service over network e.g. cloud boot . If the service OS is not capable of being booted at block then service and support may again be provisioned within the pre boot environment at block . Otherwise service and support operations may be provided in a pre OS environment at block before method ends.

In various implementations BIOS UEFI may be configured to use a boot strike count as part of a failure detection procedure. That is the number of unsuccessful main OS and or service OS boot attempts may be kept by BIOS UEFI and that information may be used by one or more of the aforementioned service and support operations in subsequent boot attempts.

As noted above in some cases service and support may be provided to a computer device such as client device by backend services via network . In that regard is a flowchart of a method for providing backend services and support to a computing device. In some embodiments method may be performed at least in part by BIOS UEFI and or CPU s of client device in cooperation with backend services for example when client device is operating in degraded state e.g. no video hard drive fault etc. either in pre boot environment or pre OS environment of .

At block method includes determining whether access to network is available to client device . If not then service and support operations may be provided as local remediation operations e.g. QR code services etc. at block . If there is network access however block includes client device phoning home to reach backend services which in turn may perform one or more checks. Examples of such checks include but are not limited to warranty and service entitlement checks performed using the client device s service tag or other identifying information such as the customer account token.

At block method includes uploading client device telemetry and or debug data to backend services . For example the telemetry and or debug data may be used by backend service to iteratively improve diagnostics and fault isolation. Then at block method includes any number of remote remediation and service operations performed by backend services . Examples of such operations include but are not limited to auto dispatch for CRUs point of need services such as warranty upsells warranty upgrades service offers etc. and HDD recovery with optional reporting of closest location office or store available for carry in service by the user . Other operations may include remote control of one or more components of client device chat support backup re imaging OS re install via local factory image or cloud etc.

In cases of IHS malfunction downloading a recovery or service OS from a remote source over the Internet is considered a method of last resort. Even if the service OS is only 300 MB in size that still translates into a 5 minute download on a typical cable Internet connection. Hence it makes for a much better support experience to load the service OS from a local source whenever possible e.g. from the IHS own HDD from a peer device in the same local network as the IHS etc. Yet it remains that oftentimes the service OS is not locally available in which case it may be obtained and booted from the cloud.

To address these and other problems systems and methods described herein may include a service and support application configured to provide network e.g. Internet recovery and service. In various embodiments these systems and methods may be implemented at least in part by BIOS UEFI of a malfunctioning IHS in cooperation with backend server for example.

In some cases BIOS instructions may determine whether a dedicated recovery partition in HDD is available with a copy of the service OS that is perhaps the primary OS cannot be booted in its own partition meanwhile a service OS within the recovery partition may still be accessible. Additionally or alternatively BIOS instructions may determine whether a peer device e.g. another one of client devices preferably within the same local network has the service OS. If so method boots to the locally identified or acquired service OS as shown in block .

If a local service OS is not available BIOS UEFI then phones home by establishing a connection with backend server for example to a predetermined IP address stored in BIOS UEFI . To that end BIOS UEFI may be Internet capable in some cases by implementing its own a network stack e.g. IPv4 IPv6 DNS FTP HTTP etc. . In addition as discussed in more detail below BIOS UEFI may be capable of performing UEFI image boot via DRAM.

At block BIOS UEFI may issue a request to backend server for a manifest file. The request may include an identification ID of the malfunctioning IHS which in turn may be in some cases stored in BIOS UEFI BIOS ID . This ID may uniquely identify the malfunctioning IHS s type family and or version.

In many cases a single platform e.g. having a model name or number may be shipped from the manufacturer with different hardware configurations e.g. different CPUs etc. thus each combination of platform and version may require that different specific drivers be built into or provided for in the service OS. Additionally or alternatively the request may include a service tag or the like which uniquely identifies the IHS amongst other IHSs even those of the same type family and version.

In some cases the IHS s request may include telemetry or other malfunction data collected by the IHS during or before the malfunction took place. Telemetry or malfunction data may be used by backend server to identify the severity of the malfunction error code s e.g. virus HDD failure etc. BIOS information mailbox information the quality or speed of the network connection available to the IHS etc. In various implementations the ID and telemetry or malfunctioning data may be used by backend server to create the manifest file requested by the IHS at block for example by selecting certain service OS components more suitable to the malfunction and IHS at hand. Therefore the manifest file may be dynamically updated upgraded and or versioned by backend server . In some embodiments the manifest file may be provided in Extensible Markup Language XML format or the like.

Examples of service OS components selectable by the backend server include but are not limited to bootloaders customizations e.g. different OS kernel and or initial RAM file systems or initramfs drivers drive packages and service OS applications e.g. splash screen etc. . These various service OS components may be stored in a layered manner such that each component is layered upon the next in order so that the receiving IHS may then assemble the service OS using those layered components. For instance a splash screen component may be overlaid upon a driver package component which in turn may be layered upon a bootloader customization component which in turn may be layered upon a bootloader.

As such backend service may be configured to provide the manifest file containing a list of service OS components most likely to enable booting of the malfunctioning IHS based upon its ID and telemetry or other malfunction data. Moreover in some cases backend service may keep a record of requests received by client devices so that if a second request for a service OS by the same IHS is received within a predetermined time from a first request e.g. on the same day within the same hour within 15 minutes of each other etc. a different manifest file may be provided to that IHS that incorporates changes to the original manifest file listing different service OS components that are more likely to be able to succeed where a previous one failed.

As an example if a first attempt to download and boot a service OS results in a failure and a subsequent request for the manifest file a second manifest file may be provided with a different driver package component having even fewer drivers. Additionally or alternatively updates and improvements to the service OS and tools may be provided over time so that future system failures and or recoveries can incorporate more advanced and improved e.g. the latest failure handling capabilities.

At block the malfunctioning client device receives the manifest file and downloads a bootloader component and a service OS application or splash screen. At block the malfunctioning client device boots via the bootloader and control passes to BIOS UEFI to start the service OS. The service OS connects again with the backend service to re get the manifest file and finishes downloading other service OS components. Additionally or alternatively two distinct manifest files may be provided a first file listing a subset of service OS components absolutely necessary to boot e.g. bootloader and splash screen and a second file listing additional service OS components e.g. customizations and drivers . Once all service OS components in the manifest file have been obtained at block the fully assembled service OS is booted.

Once the fully assembled service OS takes over control of the IHS it may perform a number of technical support operations. In various embodiments the service OS may execute one or more diagnostics which may employ different tools depending upon the results of those diagnostics. For example if HDD is functioning and yet the primary OS cannot be booted the service OS may execute one of more primary OS corruption tools. If HDD is in a bare metal environment e.g. a new HDD the service OS may execute an application to re image the primary OS from the cloud or Internet. And if HDD has failed the service OS may automate support services e.g. automatic warranty entitlement checks auto dispatch of new HDD to the customer etc. .

In sum using method client device connects to backend services to get proper and latest service OS for that particular device. Backend service or server may receive a client manifest and it may dynamically serve a service OS kernel drivers and a service application to client device for recovery and or remediation.

Moreover method can be scaled and extended to all of a manufacturer s client devices by having a layered concept of building and loading a service OS that is custom tailored for each client device. In various implementations backend server may have the client s ID name built into the name of the files made up to download the Service OS components needed for the particular client device. In this way there can be common components for example the same bootloader may be used for a wide number of different machine types but unique driver pack layers may exist for each individual type. In some cases within a single type or family of devices differing models may each have their own driver layer to download.

In some implementations the service OS may be based on Linux and it may be downloaded directly into memory to boot in a layered fashion. As such a malfunctioning IHS may download the shared base get the driver portion needed for that IHS download any further customizations and the service OS support app and build the proper service OS for itself by layers into DRAM for example.

In addition method allows backend server to be able to version control the service OS so that if newer updates are made to the service OS in any way better support application more or better upgraded toolsets etc. those updates may be made dynamically. This allows faster iterations on new improvements to be made so that a machine that fails today and boots the service OS from the cloud may have a different and improved version of the service OS via the same mechanism if a failure occurred in the future.

The manifest file s may include error security checking mechanisms to ensure the downloaded Service OS arrives properly. In addition additional security may be provided in that many machines have Secure Boot enabled and the service OS may support booting in Secure Boot enabled systems meaning that BIOS UEFI may include appropriate keys to allow the service OS to boot.

When implementing method download times are often variable nontrivial and can negatively affect customer perception. To address this system and methods described herein also reduce the perception of wait times while method is being executed. These system and methods may estimate the download time of the various service OS components listed in the manifest file and based on a best assessment of the delay pull forward some low bandwidth activities and options that the customer may need or desire to do anyway e.g. updating contact information describing the problem that happened before failure etc. to save customer time and reduce wait times. In various implementations these systems and methods may be implemented by the service OS application or splash screen component of the service OS being assembled.

At block the method determines whether there are any listed activities that can be pulled forward and performing during the download. If not block performs a customer survey e.g. in exchange for a discount and or sets an alarm or SMS alert for when the system is ready e.g. the download is complete or the service OS has been assembled and booted etc. . More broadly block may include any activities that will keep a customer occupied thus reducing the perceived wait. If there are activities listed at block then block uses built in or light download capabilities to offer activities to the user e.g. update mailing address describe the problem etc. . In various implementations a difference between blocks and is that the activities of block can include anything e.g. busywork whereas block pulls forward activities related to the service issue.

At block method determines if the service OS has been downloaded with all its components as provided in the manifest file. If not control returns to block and a new activity is selected. Otherwise block boots the service OS and allows execution to be continued.

In various implementations method enables prioritization of lower bandwidth tasks based on estimated OS load time and or based on data about malfunction. Additionally or alternatively method allows user input while OS is downloading for example submitting a phone number for a subsequent SMS alert when the system is back up. Yet additionally or alternatively method may initiate local interactive debugging or troubleshooting while other components of the service OS are still downloading.

It should be understood that various operations described herein may be implemented in software executed by logic or processing circuitry hardware or a combination thereof. The order in which each operation of a given method is performed may be changed and various operations may be added reordered combined omitted modified etc. It is intended that the invention s described herein embrace all such modifications and changes and accordingly the above description should be regarded in an illustrative rather than a restrictive sense.

Although the invention s is are described herein with reference to specific embodiments various modifications and changes can be made without departing from the scope of the present invention s as set forth in the claims below. Accordingly the specification and figures are to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope of the present invention s . Any benefits advantages or solutions to problems that are described herein with regard to specific embodiments are not intended to be construed as a critical required or essential feature or element of any or all the claims.

Unless stated otherwise terms such as first and second are used to arbitrarily distinguish between the elements such terms describe. Thus these terms are not necessarily intended to indicate temporal or other prioritization of such elements. The terms coupled or operably coupled are defined as connected although not necessarily directly and not necessarily mechanically. The terms a and an are defined as one or more unless stated otherwise. The terms comprise and any form of comprise such as comprises and comprising have and any form of have such as has and having include and any form of include such as includes and including and contain and any form of contain such as contains and containing are open ended linking verbs. As a result a system device or apparatus that comprises has includes or contains one or more elements possesses those one or more elements but is not limited to possessing only those one or more elements. Similarly a method or process that comprises has includes or contains one or more operations possesses those one or more operations but is not limited to possessing only those one or more operations.

