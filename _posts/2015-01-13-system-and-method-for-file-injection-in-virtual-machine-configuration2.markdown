---

title: System and method for file injection in virtual machine configuration
abstract: An embodiment method for virtual machine file injection includes receiving a request for a first image having an operating system and a first set of injected files for a virtual machine. The first set of injected files is compared with second sets of injected files in second images stored on a non-transitory computer readable medium. In response to the first set and second set of injected files not exactly matching, a nearest non-complete candidate image and third files are transmitted, with the third files being files from the first set of injected files that are not in the second set of injected files of the nearest non-complete candidate image.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626213&OS=09626213&RS=09626213
owner: Futurewei Technologies, Inc.
number: 09626213
owner_city: Plano
owner_country: US
publication_date: 20150113
---
This application claims the benefit of the following provisionally filed U.S. Patent application Application Ser. No. 61 927 092 filed Jan. 14 2014 and entitled System and Method for File Injection in Virtual Machine Configuration which application is hereby incorporated by reference.

The present invention relates to a system and method for configuring virtual machines and in particular embodiments to a system and method for file injection in virtual machine configuration.

Cloud computing platforms such as the OpenStack platform are used as infrastructure for cloud computing service platforms. OpenStack for example aims to serve large scale systems that launch virtual machines in a massive fashion. In some cloud computing environment customers start one or more images on a server cluster with the cloud computing platform separating the processing memory and computing resources for each started image so that the individual images act as if the image is operating on a separate computer server. The ability to sequester each running image prevents conflicts between images. To make the massive launch process more efficient bottlenecks in the launch process of single virtual machines should be removed or minimized. When launching a virtual machine a user should be able specify the files to be put into the image of the operating system before the virtual machine is booted.

An embodiment method for virtual machine file injection includes receiving a request for a first image having an operating system and a first set of injected files for a virtual machine. The first set of injected files is compared with second sets of injected files in second images stored on a non transitory computer readable medium. In response to the first set of injected files and second set of injected files not exactly matching a nearest non complete candidate image and third files are transmitted with the third files being files from the first set of injected files that are not in the second set of injected files of the nearest non complete candidate image.

Another embodiment method for virtual machine file injection includes sending a request to an image service. The request identifies a first image of an operating system and a first set files. A nearest non complete candidate image and second files are received from the image service and the second files are files from the first set files that are not in the nearest non complete candidate image. The nearest non complete candidate image is started as a first virtual machine on a cloud computing platform the nearest non complete candidate image is modified with the second files to form a second image.

An embodiment system includes an image service device comprising a first processor and a first non transitory computer readable medium connected to the first processor. The first non transitory computer readable medium has stored thereon instructions for causing the first processor to receive a request for a first image identifying an operating system and a first set of files that are not part of the operating system. The first non transitory computer readable medium further has stored thereon instructions for causing the first processor to access one or more second images stored on a second non transitory computer readable medium and compare the first set of files with a second set of files in each of the second images. The first non transitory computer readable medium further has stored thereon instructions for causing the first processor to determine whether one or more the second sets of files matches the first set of files. The first non transitory computer readable medium further has stored thereon instructions for causing the first processor to transmit in response to none of the second sets of files matching the first set of files a nearest non complete candidate image and third files. The third files are files from the first set of files that are not in the nearest non complete candidate image.

The making and using of the presently preferred embodiments are discussed in detail below. It should be appreciated however that the present invention provides many applicable inventive concepts that can be embodied in a wide variety of specific contexts. The specific embodiments discussed are merely illustrative of specific ways to make and use the invention and do not limit the scope of the invention.

In large scale data centers users have the ability to launch multiple virtual machines with similar or even identical sets of injected files. For example multiple virtual machines having identical file sets and thus identical capabilities may be launched on a cloud computing platform permitting a controlling user to isolate system processes and incrementally add to or remove processing power bandwidth or the like from an overall installation. However different capabilities are frequently used on different virtual machines. The different capabilities are provided by different file sets installed on a base operating system. For example a web server installation may have multiple virtual machines running with more or fewer virtual machines started based on the traffic or processing demand. Such web server virtual machines may each have an operating system such as a Linux operating system distribution UNIX operating system Windows operating system or the like. Such an operating system provides the basic functionality for processing or the like and may be run in a virtualized environment such as OpenStack VMWare or another cloud computing platform. In such an example webserver components such as a web server scripting language interpreters compilers middleware connectivity security components business logic components database connections configuration files or the like may be added to the base operating system. In other examples other images may include other components such as business logic customized storage security components secondary or separate web servers modified configurations or the like.

The images with the operating system and supporting files are copied to a virtual server manager for execution. However it is inefficient and a waste of computational resources if the same file injection process is performed for each of the virtual machines. Embodiment systems and methods provide for optimized image creation and retrieval resulting in more rapid creation and startup of one or more image instances. In such embodiments an image services component receives a request for an image having one or more files injected into the operating system and finds an existing image from image storage that most closely matches the requested image. The nearest image along with any files that were requested but not included in the nearest image are delivered to a virtual machine VM manager which starts the image and adds any additional required files and removes excess files that were part of the nearest image. The resulting complete image then contains the operating system and required files and the complete image is then copied and cataloged for use in other virtual machines.

In some embodiments the server pool has a hypervisor running in bare metal or native mode directly on the individual server platforms without any operating system underlying the hypervisor. In other embodiments the hypervisor runs on the individual server platforms in hosted mode on top of an operating system. The hypervisor presents guest operating systems running on top of the hypervisor with a virtual operating platform and manages the execution of the guest operating systems by emulating a plain server environment for each of the running guest operating system images. Multiple instances of a variety of operating systems may share the virtualized hardware resources provided by the server pool .

A VM manager runs in the hypervisor where used and hosts one or more images A . . . N that are being run as virtual machines. The images A . . . N are in some embodiments standalone operating system instances that operate independently as if they were on individual servers. The VM manager requests images A . . . N from the image service in response to incoming VM requests and receives starts and modifies the running images A . . . N so that they have the requested file sets. The VM manager also monitors the images A . . . N while running as virtual machines.

The cloud computing system further has in some embodiments an image service that is in communication with image storage . In some embodiments the image service presents an application programming interface API that allows requests for images to be received from the VM manager . In some embodiments the image storage is a database file system or other storage system with a nontransitory computer readable medium that stores images with any injected files. Additionally the image storage may store an image manifest image description file or the like describing each image so that the image service can determine which files have been injected into the particular image.

A management console permits control and administration of the VM manager and in some embodiments the running images A . . . N. In some embodiments the management console is a graphical user interface GUI or command line interface that sends commands to the VM manager or displays data from the VM manager to a user. In some embodiments the management console is a component running on the VM manager or on a computer or server that is remote from or separate from the server pool . Thus a user may remotely interact with the VM manager thought he management console . A queue handles ordering and scheduling of requests for VM instances. One or more databases are also provided for access by the images A . . . N.

In an embodiment operation and file injection in large scale deployment of virtual machines is performed using one or more OpenStack components. In some embodiments where the cloud computing platform uses the OpenStack system the VM manager controlling launch of images as virtual machines is carried out by the OpenStack compute service Nova Compute which is a cloud computing fabric controller. In some embodiments Nova Compute directly downloads operating system image files without injected files from the an image service such as OpenStack s Glance image service which generally provides discovery registration and delivery services for disk and server images. In some embodiments The VM manager checks with image services to determine whether an image with the same set of required files is available. If there is an exact match the VM manager downloads it and bypasses the file injection process. If the required operating system OS has no files injected the Nova Compute VM manager receives the image file without injected files from the image service performs file injection and boots the image as a virtual machine. After the virtual machine is booted the Nova Compute VM manager takes a snapshot of it which is essentially an image of the operating system with all injected files. The snapshot is then uploaded to the Glance image service and can be used by subsequently launched virtual machines. In this way the file injection process only needs to be performed when the first virtual machine is launched and the copied image can be used to launch virtual machines with the same set of injected files.

If there are images with some but not all required files partial overlap or subset the image service provides the image with the most overlap or a nearest non complete image. If there exists an image with all required files and some extras superset or with some required files and some excess files this image is preferred compared to images with partial overlaps or smaller overlaps. This is because file removals are cheaper than file injections. In those two cases snapshots are not taken and uploaded before file injection and removal and in some embodiments are instead taken after file injection and file removal.

In the case when an image service such as Glance receives multiple requests at the same time it estimates the overall cost of file injection removal and snapshot generation using a distance metric calculation that determines which base image is closest to the requested images based on the number of missing files the byte size of the missing files the time needed to transfer additional missing files or other factors. It then sends out images and any missing required files to minimize the overall cost of generating all of the requested images. An embodiment computes the distance from the requested set of OS and files with that of precompiled predefined systems and selects the OS and file combination that minimizes the download impact on the server. In an embodiment extra files can be included in the downloaded image and which are then removed if this reduces or removes the cost of downloading the image. Based upon the OS and files requested the server requests a compiled image from a subset of a combination of IOS and injected files that minimizes the download cost to the server in terms of transfer times or minimizes the download cost in combination with injection costs or file removal costs. In some embodiments factors reflecting the congestion on the network or at the server may be used to adjust the calculation of the download costs.

In an embodiment optimization the file injection process is performed only when the first virtual machine is launched and it has been discovered that later launch processes for the same images will be about 20 faster than the launch of the original image. A great deal of time and computational resources are saved when a large number of virtual machines are launched with the same set of injected files.

Embodiments may be implemented in applications such as cloud computing data centers OpenStack compatible servers and the like. Further while embodiments are described herein in the context of OpenStack embodiments may be implemented in any cloud computing platform that implements virtual machines launched from images and OS and injected files.

The bus may be one or more of any type of several bus architectures including a memory bus or memory controller a peripheral bus video bus or the like. The CPU may comprise any type of electronic data processor. The memory may comprise any type of non transitory system memory such as static random access memory SRAM dynamic random access memory DRAM synchronous DRAM SDRAM read only memory ROM a combination thereof or the like. In an embodiment the memory may include ROM for use at boot up and DRAM for program and data storage for use while executing programs. The memory may in some embodiments have instructions stored thereon for causing the processor to perform the methods and processes described herein.

The mass storage device may comprise any type of non transitory storage device configured to store data programs and other information and to make the data programs and other information accessible via the bus. The mass storage device may comprise for example one or more of a solid state drive hard disk drive a magnetic disk drive an optical disk drive or the like.

The video adapter and the I O interface provide interfaces to couple external input and output devices to the processing unit . As illustrated examples of input and output devices include the display coupled to the video adapter and the mouse keyboard printer coupled to the I O interface . Other devices may be coupled to the processing unit and additional or fewer interface cards may be utilized. For example a serial interface such as Universal Serial Bus USB not shown may be used to provide an interface for a printer.

The processing unit also includes one or more network interfaces which may comprise wired links such as an Ethernet cable or the like and or wireless links to access nodes or different networks. The network interface allows the processing unit to communicate with remote units via one or more networks . For example the network interface may provide wireless communication via one or more transmitters transmit antennas and one or more receivers receive antennas. In an embodiment the processing unit is coupled to a local area network or a wide area network for data processing and communications with remote devices such as other processing units the Internet remote storage facilities or the like.

If no complete matching image file is found in block the cost of completing the non complete image files is determined in block . In different embodiments the cost of completing non complete image files is determined by download costs by download costs in combination with injection costs by a graph distance metric calculation or by another metric.

In an embodiment where the download cost is used to determine the nearest candidate non complete image the candidate non complete image files are compared to the requested image file. Assuming that the operating system files represent the largest portion of a requested image file the candidate non complete image files will have the requested operating system files. Thus the additional files from each candidate non complete image file are compared to the requested additional files. For each candidate non complete image the download cost Cost of the missing files that is the files that were requested but that are not in the particular candidate non complete image is determined according to Equation 1 Cost 1 In equation 1 Sis size of each missing file. Thus the total cost Cost is the sum of the sizes of all missing files and the cost is proportion al to the absolute size of the missing files.

In an embodiment where the download cost in combination with injection cost are considered as part of the cost of completing the image the sum of injection costs for missing files may be included in the download cost. Thus for each candidate non complete image the injection cost Cost of the missing files that is the files that were requested but that are not in the particular candidate non complete image is determined according to Equation 2 Cost 2 In equation 2 Sis the size of each missing file and Iis the injection cost of each missing file. In such an embodiment the size of each missing file may represent the time or computing resources necessary to move the missing file to VM manager which may vary depending on network conditions. Thus the total cost Cost is the sum of the sizes of all missing files plus the cost of injecting each missing file into the image. In some embodiments the injection cost Imay be determined for the individual files or may be determined for each a file set. The injection cost Imay include for example the cost of registering a file or component with the operating system setting permissions creating or modifying a new or existing configuration file or the like.

In other embodiments the cost of removing excess files in each candidate non embodiment image may be calculated as part of the cost of completing the image. Thus for each candidate non complete image the download injection cost Cost of the missing files is determined according to Equation 3 Cost 3 In equation 3 Sis the size or transfer cost of each missing file Iis the injection cost of each missing file and Ris the cost of removing each excess file. In some embodiments Iis the time to inject a missing file and Ris expressed as a time to remove a particular file. In such an embodiment Smay be converted from a file size into a time to transfer the missing files. Thus the total cost Cost is the sum of the sizes of all missing files or cost of moving the missing files plus the cost of injecting each missing file into the image plus the cost of removing excess files.

In other embodiments the cost of transporting the excess files in each candidate non embodiment image prior to removing those excess files may also be calculated as part of the cost of completing the image. Thus for each candidate non complete image the download injection cost Cost is determined according to Equation 4 Cost 4 In equation 4 Sis the size or transfer cost of each missing file Iis the injection cost of each missing file Tis the transport cost of the excess files Ris the cost of removing each excess file. As discussed above the variables in Equation 4 may be converted into the same unit to normalize the results. Thus the total cost Cost is the sum of the sizes of all missing files or cost of moving the missing files plus the cost of injecting each missing file into the image plus the cost of transporting the excess files plus the cost of removing excess files after transport to the VM manager .

In yet other embodiments the costs may be weighted to account for various environment conditions such a processing speed computing load resource bottlenecks network congestion or the like. Thus for each candidate non complete image the download injection cost Cost is determined according to Equation 5 Cost 5 In equation 5 Sis the size or transfer cost of each missing file Iis the injection cost of each missing file Ris the cost of removing each excess file. The variables and are tuning variables used to weight each of the factors in Equation 5. For example when a network between the images service and VM manager is congested may be increased to account for the extra time it would take to move the missing files to the VM manager. In another example and may be modified according to the processing or memory loads of the VM manager . Since the tuning variables are used to reflect dynamic conditions the tuning variables may also be dynamic with the values for each variable set based on conditions at a particular time. Additionally while the tuning variables are shown above as modifying the calculations of Equation 3 such an embodiment is not limiting as any of the calculations may be tuned for environmental conditions.

In some embodiments a request for multiple images may be sent to the image service . In such an embodiment the image service may calculate the stored image that while non complete is closest to all of the requested image files. Such a calculation may be performed using a graph distance metric calculation. Such a graph distance metric calculation may be an optimization using the equations listed above. The graph distance metric calculates the cost associated with completing each of the requested images from a candidate non complete image with the cost being the sum of the cost to achieve each completed image. Such a calculation may be optimized by determining the costs of all possible combinations of image generation from a single base image to the completed set of requested images. For example where three image files are requested a set of candidate non complete images are identified. The cost for each combination of image generation orders may be determined by determining the cost of forming the first image directly from a candidate image and then the cost of forming the second image from the first image and separately forming the second image directly from the first image. The cost is further calculated by separately determining the cost of forming the third image directly from each of the second images directly from the first image and directly from the candidate image. The process is repeated for each possible combination of image orders with the order resulting in the lowest cost being selected for the production of the images. In such an embodiment the image service may send instructions to the VM manager indicating the order of forming the images and which base image from which each new image is formed.

In block the nearest non complete image is determined by the image service . The nearest candidate non complete image may be considered to be the image with the lowest cost of completion. In block the nearest non complete image is sent to the VM manager where it is installed and or executed. Any missing additional files are copied to the VM manager in block and in block the missing requested additional files are installed in the image and any excess files removed from the image. In block a copy of the newly completed image is made by the VM manager and sent to the image service which catalogs the image by making an image description file and storing the image in the image storage. Additional instances of the newly completed image are installed or started in block . The additional image instances may be started from images copied directly from the newly installed and running image for example when a VM manager receives a request to start multiple instances of the same image. The additional image instance may also be started from the image service for example when the image is requested from another cloud computing platform or at a different time.

While this invention has been described with reference to illustrative embodiments this description is not intended to be construed in a limiting sense. Various modifications and combinations of the illustrative embodiments as well as other embodiments of the invention will be apparent to persons skilled in the art upon reference to the description. It is therefore intended that the appended claims encompass any such modifications or embodiments.

