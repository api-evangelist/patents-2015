---

title: API prioritization and detection
abstract: Methods, computing systems and computer program products implement embodiments of the present invention that include receiving, by a computer, application code including a set of software elements, and identifying dependencies between the software elements. Based on the dependencies, a respective ranking score can be calculated for each of the software elements, the respective ranking score for a given software element indicating a likelihood that the given software element is configured as an application programming interface (API).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09606815&OS=09606815&RS=09606815
owner: International Business Machines Corporation
number: 09606815
owner_city: Denmark
owner_country: US
publication_date: 20150226
---
This invention relates generally to computer software analysis and specifically to analyze application code to prioritize and detect in the application code one or more software elements that are configured as an application programming interface API .

In computer programming an application programming interface API comprises a set of routines protocols and tools for building software applications. APIs can define a software component in terms of its operations inputs outputs and underlying types. APIs can also define functionalities that are independent of their respective implementations which allows definitions and implementations to vary without compromising each other.

Typically APIs often come in the form of a library that includes specifications for routines data structures object classes and variables. In other cases such as Simple Object Access Protocol SOAP and Representational State Transfer REST services an API may simply comprise a specification of remote calls exposed to the API consumers.

The description above is presented as a general overview of related art in this field and should not be construed as an admission that any of the information it contains constitutes prior art against the present patent application.

There is provided in accordance with an embodiment of the present invention a method including receiving by a computer application code including a set of software elements identifying dependencies between the software elements and calculating based on the dependencies a respective ranking score for each of the software elements the respective ranking score for a given software element indicating a likelihood that the given software element is configured as an application programming interface API .

There is also provided in accordance with an embodiment of the present invention an apparatus including a memory configured to store application code and a processor configured to receive application code including a set of software elements to identify dependencies between the software elements and to calculate based on the dependencies a respective ranking score for each of the software elements the respective ranking score for a given software element indicating a likelihood that the given software element is configured as an application programming interface API .

There is further provided in accordance with an embodiment of the present invention a computer program product the computer program product including a non transitory computer readable storage medium having computer readable program code embodied therewith the computer readable program code including computer readable program code configured to receive application code including a set of software elements computer readable program code configured to identifying dependencies between the software elements and computer readable program code configured to calculate based on the dependencies a respective ranking score for each of the software elements the respective ranking score for a given software element indicating a likelihood that the given software element is configured as an application programming interface API .

As software development shifts to mobile platforms enterprises are looking for efficient ways to reuse their existing legacy systems by exposing application programming interfaces APIs in the legacy systems. These APIs are intended to be invoked from within mobile applications or from within any other new software artifacts developed within the enterprises or provided to third party vendors. In many cases thousands of classes files and hundreds of thousands of methods functions may need to be processed to determine whether they should be exposed as APIs.

Embodiments of the present invention provide methods and systems for detecting and prioritizing APIs in an existing software artifact comprising application code. In some embodiments a static and or dynamic analysis based solution can be implemented to detect and prioritize the APIs based on the legacy system itself.

As described hereinbelow an analysis can be performed to identify dependencies between various software elements at different levels in the application code and for each given software element a respective ranking score can be computed to indicate the given software element s likelihood to be a part of the API of the software artifact. In embodiments described herein examples of software elements at different levels in the application code include functions and methods at a low or lowermost level in the application code and packages and folders at a high i.e. uppermost level in the application code.

In some embodiments the ranking score for a given software element can be computed based on a percentage of external software elements e.g. components classes methods folders files and functions that are accessing the given software element. Additionally or alternatively the score for the given software element can be computed based on a number of accesses that the external software elements have to the given software element. Therefore a given software element s score can be directly related to the number of external accesses to the given software element.

In embodiments where a given software element e.g. a function or a method comprises an API that is used by third party products but not accessed by any external software elements the ranking score can be computed based on low level software elements e.g. files and or classes and high level software elements e.g. folders and or packages that contain the given software element.

In additional embodiments the ranking score may comprise a reverse score. For example if the software element comprises a given class that includes a given method and no additional classes use the given class then the software element can be assigned a high ranking score. The reason for the high ranking score is that if there is any functionality that was implemented to be used by a third party the functionality may not be used at all in the given software element itself. On the other hand if a given class implements a first given method that is widely used internally and a second given method that is not used at all then the first given method may be completely unused and is probably not an API candidate.

Therefore systems implementing embodiments of the present invention can prioritize API candidates e.g. functions methods and classes based on a number of external components within the legacy systems that access them and their respective number of invocations. Additionally software elements that appear to be unused and can in fact be used by third party systems or new applications can be prioritized based on the reverse ratio of references to other software elements within the same parent. Embodiments of the present invention can take into account the scope of the invocation and prioritize software elements that are not invoked at all based on other software elements.

In operation processor executes from memory an analysis application that is configured to identify in application code software elements and dependencies between the identified software elements and to compute based on the dependencies a respective ranking score for each of the software elements. In one embodiment analysis application is configured to perform a static analysis on application code . In a second embodiment analysis application is configured to perform a dynamic analysis on application code while processor executes the application code.

Upon computing the ranking scores analysis application can store the identified software elements and the computed ranking scores to an API ranking table in memory . As shown in each software element has a corresponding i.e. respective ranking score .

Software elements comprise low level software elements and high level software elements also known as components that comprise multiple low level software elements. Examples of low level software elements include but are not limited to files classes objects and functions. Examples of high level software elements include but are not limited to folders libraries Java Archives JARS and packages. Typically each high level software element comprising one or more low level software elements .

In embodiments of the present invention scores also referred to herein as ranking scores indicate i.e. rank a likelihood that a given software element is configured as an API. For example a first given software element having a high respective ranking score indicates that the first given software element is likely configured as an API. Likewise a second given software element having a low respective ranking score indicates that the second given software element is not likely configured as an API.

In some embodiments processor can sort software elements by their respective ranking scores and store the sorted software elements and their respective ranking scores to API ranking table . If the API ranking table is sorted in reverse order i.e. high to low order a first given software element at or near the top of the sorted table has a high ranking and is therefore likely to be configured as an API and a second given software element at or near the bottom of the sorted table is therefore not likely to be configured as an API.

As explained hereinbelow a given ranking score for a given software element can be calculated based on dependencies between the given software element and other software elements in application code . Dependencies can be either low level or high level. Low level dependencies comprise dependencies e.g. a function call or an inheritance between low level software elements . High level dependencies comprise dependencies between high level software elements . A high level dependency between two high level software elements occurs if there is a dependency between a first given low level software element in a first given high level software element and a second given low level software element in a second high level software element .

Processor comprises a general purpose central processing unit CPU or special purpose embedded processors which are programmed in software or firmware to carry out the functions described herein. The software may be downloaded to computer in electronic form over a network for example or it may be provided on non transitory tangible media such as optical magnetic or electronic memory media. Alternatively some or all of the functions of the processor may be carried out by dedicated or programmable digital hardware components or using a combination of hardware and software elements.

The present invention may be a system a method and or a computer program product. The computer program product may include a computer readable storage medium or media having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.

The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be for example but is not limited to an electronic storage device a magnetic storage device an optical storage device an electromagnetic storage device a semiconductor storage device or any suitable combination of the foregoing. A non exhaustive list of more specific examples of the computer readable storage medium includes the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a static random access memory SRAM a portable compact disc read only memory CD ROM a digital versatile disk DVD a memory stick a floppy disk a mechanically encoded device such as punch cards or raised structures in a groove having instructions recorded thereon and any suitable combination of the foregoing. A computer readable storage medium as used herein is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Computer readable program instructions described herein can be downloaded to respective computing processing devices from a computer readable storage medium or to an external computer or external storage device via a network for example the Internet a local area network a wide area network and or a wireless network. The network may comprise copper transmission cables optical transmission fibers wireless transmission routers firewalls switches gateway computers and or edge servers. A network adapter card or network interface in each computing processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing processing device.

Computer readable program instructions for carrying out operations of the present invention may be assembler instructions instruction set architecture ISA instructions machine instructions machine dependent instructions microcode firmware instructions state setting data or either source code or object code written in any combination of one or more programming languages including an object oriented programming language such as Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program instructions may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider . In some embodiments electronic circuitry including for example programmable logic circuitry field programmable gate arrays FPGA or programmable logic arrays PLA may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry in order to perform aspects of the present invention.

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer readable program instructions.

These computer readable program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer a programmable data processing apparatus and or other devices to function in a particular manner such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function act specified in the flowchart and or block diagram block or blocks.

The computer readable program instructions may also be loaded onto a computer other programmable data processing apparatus or other device to cause a series of operational steps to be performed on the computer other programmable apparatus or other device to produce a computer implemented process such that the instructions which execute on the computer other programmable apparatus or other device implement the functions acts specified in the flowchart and or block diagram block or blocks.

Software elements in application code typically have a software hierarchy that indicates dependencies between the software elements. Examples of software hierarchies include but are not limited to inheritances and call stacks.

The example shown in comprises an order processing system having multiple functions method that are represented as nodes . Web page comprise a user interface that invokes one of the following three functions 

In call stack edges D N indicate dependencies of different functions on each other e.g. calls within application code and edges A C indicate how functions can be invoked from web page . In embodiments where analysis application performs a static analysis on application code the static analysis may not detect that the functions represented by nodes A C can be executed i.e. since they are at root level and appear to be unused since they do not have any incoming dependencies.

When analyzing application code analysis application can detect if a given software element is either used or unused. A given unused software element comprises a given function that calls other functions within the scope of application code . Therefore the given function probably has a useful role in application code and is likely to be configured as an API. For example in call stack the unused software elements comprise software elements referenced by nodes A C. In some embodiments as shown in the software elements referenced by nodes A C i.e. the unused software elements have no incoming dependencies.

In some embodiments analysis application can use a reverse page rank algorithm when calculating respective ranking score for a given low level software element e.g. a function and a given high level software element that contains the given low level software element. In the example shown in call stack 

On the other hand a used software element e.g. functions in application code comprise a given software element that is accessed by other software elements within application code . Therefore the given software element may be essential to the other software elements and is likely to be configured as an API.

In alternative embodiments analysis application can use a regular page rank algorithm when calculating the respective ranking score for a given low level software element e.g. a function and a given high level software element that contains the given low level software element. In the example shown in call stack function UpdateActivitiesDatabase i.e. node K receives a high ranking score since it is called by four other functions referenced by nodes F and I K which in turn are called by three other functions referenced by nodes A F and G .

In additional embodiments analysis application can calculate the ranking scores based on the semantics of the software elements. In other words if semantics indicate that a given software element is configured as an API or has some probability of being such analysis application can calculate the respective ranking score based on the detected semantics. For example Java code may contain accessors also known as getters and setters that are typically part of an API. Therefore if analysis application detects that a given software element comprises an accessor the analysis application can assign the respective ranking score a high value either a sole factor in the score or in combination with other scoring methods. is a flow diagram that schematically illustrates a method of prioritizing and detecting APIs in application code in accordance with an embodiment of the preset invention. In a receiving step processor receives application code and in an analysis step the processor executes analysis application to initiate an analysis of the application code. As described supra the analysis comprises a static analysis or a dynamic analysis.

The analysis performed by analysis application comprises the following steps and . In a first identification step processor identifies multiple high and low level software elements in application code and in a second identification step the processor identifies high level dependencies between the identified high level software elements and low level dependencies between the low level software elements. In a calculation step processor uses the identified high and low level dependencies to calculate a respective ranking score for each of the identified high and low level software elements.

In a first embodiment for each function public method F in a component C that is called from within application code analysis application can compute the following functions to analyze and rank the functions methods in application code 

In a first example of the first embodiment a given software element can be ranked using the following formula Total rank Func inv count ext Func inv num ext Files inv num ext Func inv count int Func inv num int Files inv num int Total number of relations in system

In a second example of the first embodiment a given software element can be ranked using the following formula Total rank Func inv count ext Func inv count int Func inv num ext Func inv num int Files inv num ext Files inv num int

In a second embodiment for each function public method F in a component C that is not called from within application code analysis application can compute the following functions to analyze and rank the functions methods in application code 

In an example of the second embodiment a given software element can be ranked as a linear combination of Comp reverse page rank and Func reverse page rank using the following formula Total rank Comp reverse page rank 1 10 Func reverse page rank

In the formula described supra for the second embodiment a the fewer other functions invoked the higher the likelihood of F being used as an external API and b the fewer components are using C the higher the likelihood of C being a sort of facade or UI e.g. web page for the system and therefore the higher the likelihood that F is part of an API. Additionally if C is not used externally then analysis application can rank the functions within the components based on their own reverse page rank so as to distinguish between entry points invoking other functionality and unused utility functions left in the code.

In some embodiments a given software element that is not called from within application code is located at a root level of a software hierarchy for the application code and or calls additional software elements in the application code. In the call stack shown in the software elements ranked by the second embodiment include software elements A B and C.

In additional embodiments combinations of different other counters can be used and with different weights. Therefore the goal is to prioritize software elements based on the context of their invocations or non invocations whereas the context is defined by other software elements e.g. components .

Returning to the flow diagram processor sorts software elements by their respective ranking scores and stores the sorted software elements and their respective ranking scores to API ranking table in a sorting step and processor presents API ranking table to a user in a presentation step . Finally in a third identification step the user identifies one or more of the software elements in API ranking table as an API function and the method ends.

The flowchart s and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be appreciated that the embodiments described above are cited by way of example and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather the scope of the present invention includes both combinations and subcombinations of the various features described hereinabove as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art.

