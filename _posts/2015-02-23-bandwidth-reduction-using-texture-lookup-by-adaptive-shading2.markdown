---

title: Bandwidth reduction using texture lookup by adaptive shading
abstract: An example method of providing a solid texture map to a graphics processing unit (GPU) includes dividing a tile of renderable content into a plurality of partitions. The method also includes determining that a set of partitions of the plurality of partitions is a solid color. The method further includes generating a solid texture map indicating that the set of partitions of the plurality of partitions is a solid color. The method also includes providing access to the solid texture map to a GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569862&OS=09569862&RS=09569862
owner: QUALCOMM Incorporated
number: 09569862
owner_city: San Diego
owner_country: US
publication_date: 20150223
---
This application claims the benefit of priority from U.S. provisional patent application No. 62 037 785 filed Aug. 15 2014 which is incorporated by reference.

The present disclosure generally relates to graphics processing systems and more particularly to rendering textures in a graphics processing system.

Computing devices may be equipped with one or more high performance graphics processing units GPUs that provide high performance with regard to computations and graphics rendering. Computing devices may use a GPU to accelerate the rendering of graphics data for display. Examples of such computing devices may include a computer workstation mobile phones e.g. smartphones embedded systems personal computers tablet computers and video game consoles.

Rendering generally refers to the process of converting a three dimensional 3D graphics scene which may include one or more 3D graphics objects into two dimensional 2D rasterized image data. In particular GPUs may include a 3D rendering pipeline to provide at least partial hardware acceleration for the rendering of a 3D graphics scene. The 3D graphics objects in the scene may be subdivided by a graphics application into one or more 3D graphics primitives e.g. points lines triangles patches etc. and the GPU may convert the 3D graphics primitives of the scene into 2D rasterized image data.

This disclosure relates to providing a texture map indicating solid color partitions of a tile. Methods systems and techniques for providing the texture map to a GPU are provided.

According to an embodiment a method of providing a solid texture map to a graphics processing unit GPU includes dividing a tile of renderable content into a plurality of partitions. The method also includes determining that a set of partitions of the plurality of partitions is a solid color. The method further includes generating a solid texture map indicating that the set of partitions of the plurality of partitions is a solid color. The method also includes providing access to the solid texture map to a GPU.

According to another embodiment a system for providing a solid texture map to a GPU includes a tile generator executing on a computing device. The tile generator divides a tile of renderable content into a plurality of partitions and determines that a set of partitions of the plurality of partitions is a solid color. The system also includes a solid texture map generator that generates a solid texture map indicating that the set of partitions of the plurality of partitions is a solid color and provides access to the solid texture map to a GPU.

According to another embodiment a computer readable medium has stored thereon computer executable instructions for performing operations including dividing a tile of renderable content into a plurality of partitions determining that a set of partitions of the plurality of partitions is a solid color generating a solid texture map indicating that the set of partitions of the plurality of partitions is a solid color and providing access to the solid texture map to a GPU.

According to another embodiment an apparatus for providing a solid texture map to a graphics processing unit GPU includes means for dividing a tile of renderable content into a plurality of partitions means for determining that a set of partitions of the plurality of partitions is a solid color means for generating a solid texture map indicating that the set of partitions of the plurality of partitions is a solid color and means for providing access to the solid texture map to a GPU.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of the present disclosure. Some embodiments may be practiced without some or all of these specific details. Specific examples of components modules and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

Rendering may refer to the process of converting 3D graphics primitives that correspond to 3D objects in a graphics scene into 2D rasterized image data. A computing device may use a graphics processing unit GPU including a 3D graphics rendering pipeline to accelerate the rendering of graphics primitives. In particular the 3D graphics rendering pipeline may include processing stages that are configured to render 3D graphics primitives. The processing stages may include programmable processing stages and fixed function processing stages. Programmable processing stages may be configured to execute a user specified program that may be compiled and loaded onto the GPU. Fixed function processing stages may be hardwired to perform one or more functions which may be configurable.

In computer graphics texture mapping is the process of applying an image onto the surface of a primitive. Texture mapping enhances the realism of computer generated imagery and has become an important and critical part of the graphics pipeline. For example rendering the walls of a house in plain color may provide the appearance of a dull and not very realistic image of the house. To enhance the scene and the graphics a brick pattern texture may be applied to the walls of the house.

GPUs may include vertex shaders which operate on every vertex sent to the graphics card and fragment or pixel shaders which operate on every pixel to be rasterized. GPUs may also include other types of shaders e.g. geometry shaders . Fragment shaders calculate the final output color of a pixel that will be stored in the frame buffer. Fragment shaders may use the input variables to color or texture the fragment.

A texture map may refer to a rectangular array of color data. A pixel in texture memory may be referred to as a texel. Texture memory may refer to memory that stores the texture data. The texture map may be mapped to any surface by using texture coordinates. In an example the texture map is a two dimensional image e.g. photograph having a width and a height. In another example the texture map is a one dimensional texture having an arbitrary width and a height of one texel. In another example the texture map is a three dimensional texture having a width height and depth.

High quality high speed texture mapping is typically confined to costly hardware systems. For example an obstacle faced by designers of texture mapping systems is the requirement of high memory bandwidth to texture memory. High bandwidth is typically necessary because of the high number of accesses to texture memory per second. The GPU may include a shader e.g. fragment or pixel shader that computes the color for a fragment or pixel by performing a texture lookup for a texture coordinate. A texture lookup is generally an expensive hardware operation in terms of memory bandwidth performance and power.

The cost of excessive texture lookups for one single color is huge because they consume a lot of memory bandwidth as well as power and degrade the performance. It may be desirable to reduce that cost. Others have addressed similar problems using texture compression. Texture compression reduces the size of textures being transferred to GPU memory but does not address the problem of expensive texture lookups for solid color partitions. Additionally the encoding and decoding of texture compression is slow and requires extra hardware change.

In rendering content large portions of the textures may be in solid colors. The present disclosure provides techniques to reduce the memory bandwidth for texture shading using a lookup map for solid color regions. Additionally the present disclosure may optimize the encoding and decoding of graphics instructions without extra hardware support.

As illustrated in the example of computing device includes a user interface a CPU a memory controller a system memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User interface CPU memory controller GPU and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may include a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a software application e.g. a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface GUI application or a browser or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct GPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. To process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause it to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc.

Memory controller facilitates the transfer of data going into and out of system memory . For example memory controller may receive memory read and write commands and service such commands with respect to system memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to system memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from both CPU and system memory in other examples some or all of the functionality of memory controller may be implemented on one or both of CPU and system memory .

System memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example system memory may store user applications and graphics data associated with the applications. System memory may additionally store information for use by and or generated by other components of computing device . For example system memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. In addition system memory may store command streams for processing by GPU . System memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to perform graphics operations to render one or more graphics primitives to display and to texture map an image to a pixel for display. Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to display . The graphics commands may include e.g. draw call commands GPU state programming commands memory transfer commands general purpose computing commands kernel execution commands etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU . Graphics data may include a texture map that is stored in system memory and used by GPU to determine the color for a pixel to be rendered on display . In some examples GPU may be further configured to perform general purpose computing for applications executing on CPU .

GPU may in some instances be built with a highly parallel structure that provides more efficient processing of vector operations than CPU . For example GPU may include a plurality of processing units that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU . In addition the highly parallel nature of GPU may allow GPU to process certain types of vector and matrix operations for general purposed computing applications more quickly than CPU .

GPU may in some instances be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by reducing the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however computing device may not include GPU cache but instead GPU may use system memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM etc.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within system memory . The software application that executes on CPU may store the image data e.g. texel colors width height and color depth in memory . The image data may be loaded from an image file or generated using code. Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computing device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

In some examples the techniques described in this disclosure may be implemented in any of the components in computing device illustrated in including e.g. CPU GPU and system memory .

CPU is configured to execute a software application such as browser a graphics API a GPU driver and an operating system . Browser may include one or more instructions that cause graphics images to be displayed and or one or more instructions that cause a non graphics task e.g. a general purposed computing task to be performed on GPU . Although browser may be described as issuing instructions it should be understood that any software application executable in computing device and that processes and or displays graphical data may be used to issue the instructions.

Browser may issue instructions to graphics API which may translate the instructions received from browser into a format that is consumable by GPU driver . Memory may store one or more commands . Commands may be stored in one or more command buffers e.g. a ring buffer and include one or more state commands and or one or more draw call commands. A state command may instruct GPU to change one or more of the state variables in GPU such as e.g. the draw color. A draw call command may instruct GPU to render a geometry defined by a group of one or more vertices e.g. defined in a vertex buffer stored in memory or to draw content of a texture onto display .

GPU driver receives the instructions from browser via graphics API and controls the operation of GPU to service the instructions. For example GPU driver may formulate one or more commands place the commands into memory and instruct GPU to execute the commands . In some examples GPU driver may place the commands into memory and communicate with GPU via operating system e.g. via one or more system calls.

GPU includes a command engine and one or more processing units . Command engine is configured to retrieve and execute commands stored in memory . In response to receiving a state command command engine may be configured to set one or more state registers in GPU to particular values based on the state command and or to configure one or more of the fixed function processing units based on the state command. In response to receiving a draw call command command engine may be configured to cause processing units to render the geometry represented by vertices based on primitive type data stored in memory . Command engine may also receive shader program binding commands and load particular shader programs into one or more of the programmable processing units based on the shader program binding commands.

Processing units may include one or more processing units each of which may be a programmable processing unit or a fixed function processing unit. A programmable processing unit may include for example a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU from CPU . A shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc.

In some examples a programmable shader unit may include a plurality of processing units that are configured to operate in parallel e.g. an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register e.g. a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units may include for example vertex shader units pixel shader units geometry shader units hull shader units domain shader units compute shader units and or unified shader units.

The one or more processing units may form a 3D graphics rendering pipeline which may include one or more shader units that are configured to execute a shader program. Pixel shaders are programs executed on GPU . In processing units may include a fragment shader or pixel shader that computes and sets colors for pixels covered by a texture object e.g. texture image displayed on display . This process may be referred to as rasterization which is the conversion from 2D vertices in screen space each with a z value depth value and various shading information associated with each vertex into pixels on the screen. Pixel shader includes a pixel shader A and a pixel shader B and is executed for each pixel fragment and uses the interpolated vertex attributes as input to compute a color. Although pixel shader A and pixel shader B are illustrated as being in pixel shader it should be understood that they may be separate components in the pipeline. A pixel shader can be as simple as returning a constant color. Each pixel fragment that is drawn on display is operated on by pixel shader . The term fragment and pixel may be used interchangeably in the disclosure.

Display may display the contents of tile texture map . In an example a texture image may have texture coordinates u v that are used to look up the right color from tile texture map of a pixel. Pixel shader in GPU may render texture onto an object that is displayed on display and use texture coordinates to look up the color for a pixel in a bound texture map. In an example pixel shader performs per pixel shading computations by performing a texture lookup for the current texture coordinate. Accordingly to look up the color for each pixel pixel shader may access tile texture map stored in memory which can require high memory bandwidth to texture memory.

The present disclosure provides techniques to reduce the memory bandwidth for texture shading using a lookup map for solid color regions of renderable content. is a block diagram illustrating renderable content being divided into a plurality of partitions according to some embodiments. Browser may divide renderable content of a webpage into one or more layers. Although a webpage is described as being the renderable content this is not intended to be limiting and the renderable rendered content may be any text image or graphics on a page that is or is not associated with a network such as the Internet .

In webpage is divided into layers and . Webpage may have elements or properties that indicate to browser whether to divide the webpage into layers and how many layers. In an example webpage contains a transparent portion corresponding to layer and an animated portion e.g. an object moving from one side of display to another side corresponding to layer . In this example the animated portion of webpage is rendered at a different layer than the transparent portion of webpage . Webpage may include multiple layers that may or may not overlap.

For one or more of the layers browser may divide the respective layer into a plurality of tiles. For example browser may divide layer into a plurality of tiles including a tile A. Layer is divided into tiles of five columns and four rows for a total of 20 tiles. Browser may divide each of the tiles into a plurality of partitions . The plurality of partitions may be horizontal or vertical partitions e.g. for particular languages having a vertical layout direction and each of the partitions may be of unequal or equal sizes relative to each other. The height or width of each partition may be fine tuned.

Browser may divide tile A into plurality of partitions which includes 16 partitions partitions A P. Some of the partitions of plurality of partitions are solid colors and some are not. Browser generates a solid texture map indicating which partition s in the tile is a solid color. In an example browser scans each pixel to generate a solid texture map and determines which shader to use adaptively e.g. pixel shader A or pixel shader B based on a threshold. Pixel shader A may be a modified pixel shader that uses the solid texture map to render a pixel on display and pixel shader B may be an unmodified pixel shader that uses the tile texture map to render a pixel on display . For efficiency it may be desirable for browser to simultaneously scan each pixel to generate the solid texture map and to determine which shader to use in order to scan each pixel only once. If during a first time interval browser scans each pixel to generate a solid texture map and during a second time interval determines which shader to use adaptively based on a threshold browser may be considered to perform these two actions simultaneously if at least a portion of the first time interval overlaps with at least a portion of the second time interval. Additionally when browser is confident that a tile is not able to reach the threshold browser may discard the solid texture map as it may be necessary for the unmodified shader to use this information. Browser may provide access to the solid texture map to GPU . Browser may store the solid texture map into a texture buffer that is accessible by GPU .

In some embodiments if a condition is satisfied browser provides access to the solid texture map to GPU and GPU may perform an optimized texture lookup operation using the solid texture map. In contrast if the condition is not satisfied browser does not provide access to the solid texture map to GPU and GPU may perform a normal texture lookup operation e.g. uses tile texture map to lookup the texture for the pixel . In an example the condition is satisfied if the respective tile has a threshold percentage of partitions that is a solid color. In another example the condition is satisfied if the respective tile has a threshold number of partitions that is a solid color.

Browser includes a tile generator and a solid texture map generator . In some embodiments tile generator generates solid texture map based on content to be rendered and stores solid texture map into texture memory for retrieval by GPU . In an example browser stores solid texture map into memory accessible by CPU and then sends solid texture map into memory accessible by GPU . In another example browser stores solid texture map into memory accessible by CPU and then makes solid texture map also accessible to GPU .

Texture memory may be allocated from memory . Tile generator determines whether a set of one or more partitions of plurality of partitions is a solid color. For each tile solid texture map generator may generate a solid texture map indicating whether one or more partitions in the tile is a solid color. In partitions E H and M are a solid color e.g. white and the remaining partitions of plurality of partitions e.g. A D I L and N P are not a solid color.

Solid texture map may be a small texture map including one entry for each partition in the tile. For example for tile A solid texture map generator may generate a solid texture map including 16 values where each value indicates whether a particular partition of plurality of partitions is a solid color. The first value may correspond to partition A and the last value may correspond to partition P with the other partitions falling in between in order. In an example solid texture map includes FFFFTTTTFFFFTFFF where F indicates that a partition is not a solid color and T indicates that a partition is a solid color. It should be understood that different values may indicate that a partition is a solid color. In other examples an F value or 0 value may indicate that a partition is a solid color. Browser provides access to solid texture map to GPU . Browser may store solid texture map in memory for retrieval by GPU .

Additionally for each partition that is a solid color solid texture map may also indicate the color of the respective partition. In such an example if the partition is not a solid color the color value may be left blank. A solid texture map that indicates whether a partition is a solid color and its solid color if applicable may be advantageous when partitions in a tile are different solid colors.

In another example tile generator determines whether tile A has a major color. A major color is the majority solid color in the tile. Tile generator may scan each partition and for partitions that are a solid color determine a major color of the tile. In some embodiments solid texture map generator generates solid texture map where solid texture map includes the major color. The major color may be passed as a uniform to pixel shader .

Solid texture map generator may provide a mark in solid texture map that tracks the solid color partitions. For example if a partition is a solid color that is the same as the major color solid texture map generator may indicate in the solid texture map that the partition is a solid color. For example in tile A s major color is white and solid texture map may include FFFFTTTTFFFFTFFF and white. Additionally if a partition is not the major color solid texture map generator may indicate the partition as not being a solid color.

If browser sends the solid texture map including the major color to pixel shader pixel shader A may compute the color for each pixel by first checking solid texture map which tracks the solid color partitions and then determines if the pixel should use the major color. If the pixel does not use the major color then pixel shader B may perform a normal texture lookup operation e.g. uses tile texture map to lookup the texture for the pixel .

In some embodiments if a partition is not a solid color solid texture map generator indicates this in the solid texture map . Additionally if a partition is a solid color that is different from the major color solid texture map generator may indicate the partition as not being a solid color.

A solid texture map including the major color may provide for a reduction in bandwidth and power consumption. In particular rather including the major color in the solid texture map for each partition that is the major color the major color is only included once. In this example all partitions corresponding to a T value are the major color. Additionally frame rate performance may be improved for the tiles with a lot of solid color partitions. On the tiles with few or no solid partitions however the overhead of doing extra work in pixel shader may slow down the performance and consume more power. On these tiles normal texture lookup may tend to work better. Therefore adaptive selection of pixel shader A or pixel shader B based on a threshold of the percentage or threshold number of solid color partitions of each texture may be helpful. In an example if the threshold is reached pixel shader A uses solid texture map and pixel shader B uses tile texture map . In this example pixel shader may include a modified pixel shader e.g. pixel shader A that uses solid texture map to render a pixel on display . Additionally if the threshold is not reached pixel shader may use an unmodified pixel shader e.g. pixel shader B that uses tile texture map to render a pixel on display .

Pixel shader may look up a texture using tile texture map or solid texture map . In some embodiments pixel shader determines if a particular pixel to be rendered on display maps to a partition with a solid color. In response to determining that the particular pixel maps to a partition that is a solid color pixel shader A may be adaptively selected and may use solid texture map to look up the texture. In response to determining that the particular pixel maps to a partition that is not a solid color pixel shader B may be adaptively selected and may use tile texture map stored in memory to look up the texture.

In some embodiments pixel shader may be provided with access to solid texture map corresponding to a tile and determines whether the tile has a threshold percentage of partitions that is a solid color. In response to determining that the respective tile has the threshold percentage of partitions that is a solid color pixel shader A may perform a texture lookup using solid texture map . In an example pixel shader A retrieves the color pixel by pixel based on the xy coordinates for the non solid partitions of the tile. For solid partitions pixel shader A may perform a lookup only using solid texture map because it has the color information. Additionally pixel shader B may retrieve the color pixel by pixel based on the xy coordinates for the rest of the tile.

In contrast in response to determining that the respective tile does not have the threshold percentage of partitions that is a solid color pixel shader B may perform a texture lookup using tile texture map . In an example pixel shader B performs the texture lookups for all partitions only using tile texture map stored in texture memory.

Pixel shader provides an output that stores a 2D image. In an example output is a frame buffer allocated from memory . Fragments can be discarded or passed on to the frame buffer and the final image may be passed on to the drawing buffer and shown to the user or alternatively saved to an off screen buffer for later usage such as to save as texture data.

As discussed above and further emphasized here are merely examples which should not unduly limit the scope of the claims. For example the techniques described in this disclosure may be implemented in any of the components shown in including e.g. graphics API GPU driver command engine and processing units . For example the techniques for rendering a texture or texture mapping may be implemented in command engine and or in a graphics pipeline implemented by processing units .

Method includes blocks . In a block a tile of renderable content is divided into a plurality of partitions. In an example tile generator divides tile A of renderable content into plurality of partitions . In a block it is determined that a set of partitions of the plurality of partitions is a solid color. In an example tile generator determines that partitions E H and M of plurality of partitions is a solid color. In a block a solid texture map is generated indicating that the set of partitions of the plurality of partitions is a solid color. In an example solid texture map generator generates solid texture map indicating that the set of partitions of the plurality of partitions is a solid color. In a block access to the solid texture map is provided to a GPU. In an example solid texture map generator provides access to solid texture map to GPU .

In some embodiments blocks may be performed for any number of occurrences of any number of layers or tiles of the renderable content. It is also understood that additional processes may be performed before during or after blocks discussed above. It is also understood that one or more of the blocks of method described herein may be omitted combined or performed in a different sequence as desired

Those of skill would further appreciate that the various illustrative logical blocks configurations modules circuits and steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks configurations modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present disclosure.

The blocks or actions of a method described in connection with the embodiments disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module e.g. browser tile generator or solid texture map generator may reside in random access memory RAM flash memory read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers hard disk a removable disk a compact disc read only memory CD ROM or any other form of storage medium known in the art. Software modules may execute on one or more processors. An exemplary storage medium is coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an application specific integrated circuit ASIC . The ASIC may reside in a computing device or a user terminal. In the alternative the processor and the storage medium may reside as discrete components in a computing device or user terminal.

The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the disclosed embodiments. Various modifications to these embodiments will be readily apparent to those skilled in the art and the principles defined herein may be applied to other embodiments without departing from the scope of the disclosure. Thus the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope possible consistent with the principles and novel features as defined by the following claims. Thus the present disclosure is limited only by the claims.

