---

title: Tracking changes that affect performance of deployed applications
abstract: An application monitoring infrastructure that enables application configuration changes on multiple machines across multiple OS types to be tracked by identifying data containers that are to be monitored for changes, detecting a change to a monitored data container, and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed. The data containers that are to be monitored for changes are identified from templates, and a unique template is provisioned for each of the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411847&OS=09411847&RS=09411847
owner: VMware, Inc.
number: 09411847
owner_city: Palo Alto
owner_country: US
publication_date: 20150203
---
This application is a continuation of U.S. patent application Ser. No. 13 491 305 entitled Tracking Changes That Affect Performance of Deployed Applications filed Jun. 7 2012 which is related to U.S. patent application Ser. No. 13 491 329 entitled Correlating Performance Degradation of Applications to Specific Changes Made to Applications filed Jun. 7 2012.

With the transition to virtualized infrastructure in recent years outages due to configuration changes to applications have been on the rise. Some of the more common configuration changes include code push and changes to the clustering configuration number of threads allocated to applications and datastore configuration. Although many of these changes are tested prior to rolling them out in the production environment outages and significant performance degradations are not discovered indeed cannot be discovered if they result from scale issues e.g. when the changes are rolled out in a cloud environment having virtual machines that number in the millions.

One or more embodiments disclosed herein provide an application monitoring infrastructure that enables application configuration changes on multiple machines across multiple OS types to be tracked and correlated to performance degradation and outages.

A method for tracking configuration changes of applications according to an embodiment includes the steps of identifying data containers that are to be monitored for changes detecting a change to a monitored data container and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed wherein the data containers that are to be monitored for changes are identified from templates and a unique template is provisioned for each of the applications.

A method for tracking configuration changes of applications according to another embodiment includes the steps of identifying data containers that are to be monitored for changes receiving notifications of file events transforming multiple file events into a normalized file event detecting a change to a monitored data container based on the normalized file event and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed.

Further embodiments of the present invention include without limitation a non transitory computer readable storage medium that includes instructions that enable a computer system to implement one or more aspects of the above methods as well as a computer system configured to implement one or more aspects of the above methods.

Each of health monitoring server central monitoring server and monitored machines includes hardware components of a conventional computing device such as processor and system memory and system level software. Health monitoring server further includes software components running on top of its system level software one of which is shown in as health monitor . Health monitor communicates with central monitoring server over a network to retrieve application performance data and change data from central monitoring server through an application programming interface API . Health monitor also processes the retrieved performance data and change data to generate various GUIs that are presented to the system administrator through a display .

Central monitoring server further includes software components running on top of its system software which are shown in as central monitor and API . Central monitor communicates with monitored machines to collect application performance and change data from them and store them in an event store . Central monitor makes such collected data available to health monitor through API .

Each of monitored machines includes one or more applications running on top of its system software. It also includes a performance monitoring agent that monitors the performance and or behavior of applications such as central processing unit CPU usage physical memory usage and latency and a change monitoring agent that monitors changes to various files and folders designated by the system administrator as being monitoring targets. Some examples of applications that can be tracked include web server applications such as Tomcat JBoss Websphere Weblogic and IIS and database applications such as MySQL PostgreSQL Oracle and MSSQL. Monitored machines may be physical or virtual machines. Physical machines include any computing device such as server grade computing platforms desktop and laptop computing devices and mobile computing devices such as tablet computers and smart phones.

Monitoring template for an application identifies the application being monitored and paths of folders and files to be monitored some recursively for that application. In the example given in TABLE 1 the application being monitored is Apache Tomcat and the folders and files that are to be monitored recursively have a recursive flag set to be true. Within a monitored folder a regular expression filter is used to determine which files are monitored. In addition monitoring template may designate folders and files to be monitored using environmental or system variables so that files that affect the performance of the application and whose location on the file system is determined by environment system variables may be monitored and tracked according to embodiments described herein. Using monitoring template the folders and files for any application being monitored may be custom defined. By using monitoring template the number of folders and files to be monitored can be reduced to a manageable practical number.

Change monitoring agent monitors changes to various files and folders of particular applications being monitored as specified in monitoring templates . As shown change monitoring agent includes two modules. The first is an event processor that receives notifications from the system software of monitored machine that a certain folder or file has been changed. The particular components of system software that are providing the notifications are a file system FS monitor a database DB monitor and for Microsoft Windows systems a registry monitor . In one embodiment a Java library known as jpathwatch is used to monitor file system changes such as file creation and deletion file modification file renaming and changes in subfolders. As will be further described below in conjunction with event processor evaluates the changes detected by FS monitor DB monitor and registry monitor and produces change events for further processing by change tracker which is the second module within change monitoring agent shown in . Change tracker receives change events from event processor and processes the versioning of the changes to files using a versioning tool to store any changes to the files in change repository which may be provisioned in system memory or local storage. In one embodiment the versioning tool known as Git is used.

The method begins at step when FS monitor detects one or more change events on the same file or folder during a configurable time period Tmin. In some situations multiple change events relating to effectively the same change are triggered and this time period is set so that such change events can be captured and analyzed collectively. In one embodiment this time period is set as 2 milliseconds. At step event processor determines whether or not the file or folder should be monitored based on the installed applications that it discovered through application monitor and the monitoring templates . For each monitored folder event processor registers with the underlying system software for change event notifications. If the file or folder for which the change event is detected at step is not specified in a monitoring template s filter of an installed application the method ends. On the other hand if the file or folder for which the change event is detected at step is specified in a monitoring template of an installed application step is executed where event processor determines the application ID App ID of the installed application for which the file or folder is being monitored. Then at step event processor determines whether a single file event is being processed. If a single event is being processed step is executed where event processor issues a change event including the App ID and the path to the changed file to change tracker . If on the other hand a folder event or multiple file events are being processed step is executed.

At step event processor determines whether it can transform a folder event or multiple file events into a single normalized event without relying on any OS specific knowledge. For example if two or more modify events are triggered for the same file within the time period Tmin event processor may interpret all such modify events as a single modify event. In such situations event processor at step transforms the multiple events into a single normalized event. Thereafter step is executed where event processor issues a change event including the App ID and the path s to any changed files to change tracker . The method ends after step as there are no more change events to process.

If at step event processor determines that it cannot transform a folder event or multiple events into a single normalized event without relying on any OS specific knowledge steps and are executed. At step event processor determines the OS type and at step event processor determines whether it can transform the folder event or multiple events into a single normalized event with reliance on OS specific knowledge. For example in Windows OS a file creation triggers five separate events create delete recreate modify and modify. Event processor at step transforms all such events into a single normalized file creation event and at step issues a change event including the App ID and the path to the newly created file to change tracker . Another example is a folder copy event in Windows OS which triggers a folder create event and multiple file events for each file in the folder. Event processor at step transforms the folder copy event and the subsequent file events into a single normalized folder event and at step issues a change event including the App ID and the paths to the files in the folder to change tracker . With Linux OS where a folder copy event triggers only a single folder event event processor at step transforms the folder copy event into a single normalized folder event and at step issues a change event including the App ID and the paths to the files in the folder to change tracker . In all three examples given above the method ends after step as there are no more change events to process.

In some situations where normalization may not be desired or cannot be implemented each change event is processed as a separate change event at step . The method ends when it is determined at step that all change events have been processed.

When change tracker pulls a change event with a file path and a change type create delete or modify from a queue of change events maintained by event processor change tracker accesses the files at the indicated file path. This method begins at step with the accessing of one such file. In some situations the accessed file may be an archive file such as a JAR file or a WAR file and change tracker checks for this at step . If the accessed file is an archive file change tracker extracts a file to process from the archive file at step and step is executed thereafter. If not the method proceeds directly to step and the accessed file is processed.

At step the processed file is checked for changes. If there are no changes the file is not versioned and the method jumps to step . If there are changes a change ID and a time stamp for the changes is generated at step . If the changed file is binary file as determined at step a hash of the binary file is generated step and stored in change repository along with the change ID and the time stamp step . If on the other hand the changed file is a text file a diff operation is performed on the text file against the prior version of the text file to generate a diff file step and the diff file is stored in change repository along with the change ID and the time stamp step .

If the file being processed is an archive file as determined at step step is executed to see if there is any more file to be extracted from the archive file. If there is any more file to be extracted from the archive file the method returns to step where another file is extracted. If there are no more files to be extracted from the archive file or the file being processed is not an archive file change tracker executes step to see if there are any more files to process. The method ends if there are no more files to process and returns to step if there is at least one more file to process.

As previously described central monitor of central monitoring server communicates with monitored machines to collect performance and change data from them and store them in event store . The frequency of the collection is configurable. The performance data that are collected include App ID and time history of the CPU usage memory usage and latency. The change data that are collected and stored in event store include the change ID App ID time stamp path of changed file and the diff file.

Health monitor of health monitoring server accesses the performance data and the change data through API to carry out a method for generating and processing inputs made to an application performance monitoring UI. The steps of this method are illustrated in .

At step health monitor displays a list of applications being monitored on a UI. A system administrator viewing the UI may select an application of interest e.g. travel web server. Upon receiving this selection at step health monitor displays a performance monitoring UI for the selected application at step . A sample performance monitoring UI is illustrated in and shows a time history of CPU usage and latency . A user selectable warning symbol is displayed at a particular point in time of the illustrated time histories as an indicator of when performance degradation of the selected application has occurred. When the system administrator makes an input selection e.g. a mouse click or a tap on a touch screen on warning symbol and health monitor receives this selection at step health monitor queries central monitoring server for change events that are close in time to the performance degradation. In response to the query central monitoring server searches change data of the selected application maintained in event store and returns the requested data to health monitor . At step health monitor displays the change events on another UI one example of which is illustrated in . Upon viewing the change events the system administrator may implement fixes or roll back the changes that caused the performance degradation by making an input selection on top of one of the change events step . In the sample illustration of the code change implemented at 13 40 06 can be rolled back by manipulating cursor to that location and making an input selection on that highlighted line. In response to the input selection health monitor issues an undo command identifying the change event by its change ID through API step . Central monitoring server passes this undo command to the appropriate monitored machine and in turn the monitored machine executes the undo command using its versioning tool.

If the monitored machine is a virtual machine as an alternative to the pinpoint rolling back the entire virtual machine may be rolled back to the most recent snapshot that was taken prior to the point in time performance degradation was observed.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Virtualization systems in accordance with the various embodiments may be implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned. Furthermore various virtualization operations may be wholly or partially implemented in hardware. For example a hardware implementation may employ a look up table for modification of storage access requests to secure non disk data.

Many variations modifications additions and improvements are possible regardless the degree of virtualization. The virtualization software can therefore include components of a host console or guest operating system that performs virtualization functions. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claim s .

