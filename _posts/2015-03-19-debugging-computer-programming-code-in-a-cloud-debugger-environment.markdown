---

title: Debugging computer programming code in a cloud debugger environment
abstract: A method for capturing breakpoint information from a debuggee software process includes generating a breakpoint condition based upon a breakpoint request received from a user computing device corresponding to a user and transmitting the generated breakpoint condition to debuglets, each corresponding to a software process executed by a debuggee service. The debuggee service executes on a distributed system, and each debuglet translates the generated breakpoint condition to a physical breakpoint condition set to the respective software process. The method also includes receiving a request from one of the debuglets to update active breakpoint information captured by the debuglet upon the physical breakpoint condition being hit by one of the software processes and transmitting a notification from the processing device indicating the physical breakpoint condition being hit to the user computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262300&OS=09262300&RS=09262300
owner: Google Inc.
number: 09262300
owner_city: Mountain View
owner_country: US
publication_date: 20150319
---
This U.S. patent application claims priority under 35 U.S.C. 119 e to U.S. Provisional Application 62 016 305 filed on Jun. 24 2014 which is hereby incorporated by reference in its entirety.

A conventional development cycle for computer software code includes repeated steps of authoring testing debugging and modifying the code during initial development phases or long after deployment of the product. Traditional debugger tools however are generally ineffective for debugging computer software code developed on distributed systems such as the cloud environment. As a result developers resort to printf debugging or no debugging at all. This lack of debugging capabilities on distributed systems leads to increased time spent fixing problems as they occur or preventing them in the first place.

Known debuggers are primarily directed toward process state debugging rather than distributed service debugging. Developers on the cloud environment have an increased need to debug their services or requests rather than simply debug a specific software process or thread. Developers generally debug software processes on distributed systems by collecting monitoring and tracking information to draw conclusions. This process can take minutes to days to carry out. The product is only pushed back to production once it has been fixed. In fact most available debugging tools are directed toward achieving the highest fidelity by resolving every aspect of symbols variables and memory while the software process is stopped. Thus live debugging of the process cannot be achieved because the software process must be stopped to perform the debugging.

One aspect of the disclosure provides a method for capturing a breakpoint condition from a debuggee software process. The method includes generating at a processing device a breakpoint condition based upon a breakpoint request received from a user computing device corresponding to a user. The method also includes transmitting the generated breakpoint condition from the processing device to debuglets each corresponding to a software process executed by a debuggee service executing on a distributed system. Each debuglet translates the generated breakpoint condition to a physical breakpoint condition set to the respective software process. The method further includes receiving at the processing device a request from one of the debuglets to update active breakpoint information captured by the debuglet upon the physical breakpoint condition being hit by one of the software processes. The method further includes transmitting a notification from the processing device indicating the physical breakpoint condition being hit to the user computing device.

Implementations of the disclosure may include one or more of the following optional features. In some implementations prior to generating the breakpoint condition based upon the breakpoint request the method may include receiving at the processing device a user identifier included with the breakpoint request. The method may further include authorizing at the processing device user access rights to capture the active breakpoint information from the debuggee software processes using the user identifier.

In some examples the execution of the respective software process that hit the physical breakpoint condition is stopped for only a period of time sufficient for the respective debuglet to capture the active breakpoint information. Execution of the respective software process may be immediately resumed after the active breakpoint information is captured.

In some implementations each debuglet translates the generated breakpoint condition to a specific programming language and executable associated with the respective software process. Each of the debuglets may be dependent upon the programming language of their respective software process.

In some examples receiving the request from one of the debuglets to update active breakpoint information further includes receiving breakpoint information e.g. a call stack and or variables corresponding to the physical breakpoint condition being hit. Additionally or alternatively one of the debuglets may translate the breakpoint information prior to transmittance to the processing device.

The method may further include a notification transmitted to the remaining debuglets that did not capture the active breakpoint information indicating the physical breakpoint condition being hit. The remaining debuglets may remove the physical breakpoint from the respective debuggee software processes in response to the notification. The method may further include storing the breakpoint condition and the captured active breakpoint information in non transitory memory.

Another aspect of the disclosure provides a system for capturing a breakpoint condition from a debuggee software process. The system includes one or more debugger service processing devices executing a debugger service and one or more debuglet controller processing devices in communication with the one or more debugger service processing devices and executing the debuglet controller. The debugger service generates a breakpoint condition based upon a breakpoint request received from a user computing device in communication with the distributed system and corresponding to a user. The debuglet controller transmits the generated breakpoint condition to debuglets each corresponding to a software process executed by a debuggee service executing on the distributed system. Each debuglet translates the generated breakpoint condition to a physical breakpoint condition set to the respective software process. The system also includes receiving a request from one of the debuglets to update active breakpoint information captured by the debuglet upon the physical breakpoint condition being hit by one of the software processes. The system further includes transmitting a notification indicating the physical breakpoint condition being hit to the user computing device.

In some implementations the debuglet controller stops execution of only the respective software process that hit the physical breakpoint condition only for a period of time sufficient for the respective debuglet to capture the active breakpoint information. In some examples the debuglet controller resumes execution of the respective software process immediately after the active breakpoint information is captured.

Prior to generating the breakpoint condition the debugger service may receive a user identifier included with the breakpoint request and authorize user access rights to capture the active breakpoint information from the debuggee software processes using the identifier. In some implementations the system includes a breakpoint store in communication with the one or more debugger service processing devices and the one or more debuglet controller processing devices. The breakpoint store may store the breakpoint condition generated by the debugger service and the active breakpoint information captured by the respective debuglet upon the physical breakpoint condition being hit. The terms breakpoint hit and breakpoint condition hit are used interchangeably and can mean that the corresponding breakpoint is executed and its condition is satisfied.

In some examples the debuglet controller transmits a notification indicating the physical breakpoint condition being hit to the remaining debuglets that did not capture the active breakpoint information. The remaining debuglets may remove the physical breakpoint from the respective debuggee software process in response to the notification. In some examples the debugger service receives the breakpoint request from an integrated development environment executing on a user computing device.

In some implementations the debugger service includes a debugger application programming interface for setting a breakpoint retrieving a breakpoint deleting a breakpoint and listing breakpoints. The debuglet controller may include a debuglet controller application programming interface that enables the debuglets to register their respective debuggees to query for active breakpoints to set and to update active breakpoint information e.g. when the breakpoint hits and fails . Receiving the request from one of the debuglets to update active breakpoint information may further include receiving breakpoint information e.g. a call stack and or variables corresponding to the physical breakpoint condition being hit.

The details of one or more implementations of the disclosure are set forth in the accompanying drawings and the description below. Other aspects features and advantages will be apparent from the description and drawings and from the claims.

Developers debugging scalable network or web services are challenged to identify a specific software process related to a desired request and set a breakpoint on that specific process. As used herein the terms software process may simply be preferred to the term process . This often requires the developers to resort to running a single process and directing network traffic or emulating the desired request with the specific process. As a result processes execution context is interrupted during a debugging session and users interaction with services running these processes on the scalable networks or web services is also interrupted. As used herein the term developer will be used interchangeably with the term user . Accordingly the terms developer and user may refer to a client accessing a cloud computing platform using client devices such as computing devices e.g. desktop computers laptops tablets and smartphones . Applications or services on distributed systems such as a cloud environment do not require that the client have the specific software for running the applications or services but instead enable the client to interact with the application or services using an internet connection and a user interface such as a web browser. When the client corresponds to a developer the developer may utilize an integrated development environment IDE user interface that provides a single software application including features such as a source code editor build automation tools and debuggers. Implementations of the present disclosure are directed toward providing a capability for the developer user to access and debug one or more services operating on the cloud environment including but not limited to infrastructure as a service IaaS platform as a service PaaS and software as a service SaaS where IaaS is the most basic and each higher model abstracts from the details of the lower models. In contrast to the aforementioned conventional methods of identifying each specific process running on a service to be debugged implementations herein are directed toward providing debugging as an application service whereat a collection of processes run by a corresponding service may be debugged as a single process to reduce or eliminate interruptions to the service s users and its processes being executed.

Referring to in some implementations a debugging environment includes a user e.g. a developer interfacing with a computing device e.g. a computer laptop etc. executing an IDE . The computing device is in communication with a cloud computing environment i.e. cloud via a network to use a debugging orchestrator executing in the cloud computing environment to request and set a breakpoint on each one of a plurality of software processes P P P . . . Prunning on a service .

The cloud provides elastic scalable cloud computing and or cloud storage capabilities. Cloud computing may provide Internet based computing whereby shared servers provide resources software and data to computers and other devices on demand. For example the cloud may be a cloud computing service that includes at least one server computing device which may include a service abstraction layer and a hypertext transfer protocol wrapper over a server virtual machine instantiated thereon. The server computing device may be configured to parse HTTP requests and send HTTP responses. Cloud computing may be a technology that uses the Internet and central remote servers to maintain data and applications. Cloud computing can allow users to access and use applications such as the debugging orchestrator without installation and access personal files at any computer with internet access. Cloud computing allows for relatively more efficient computing by centralizing storage memory processing and bandwidth. The cloud can provide scalable on demand computing power storage and bandwidth while reducing user hardware requirements e.g. by freeing up CPU and memory usage .

In the example shown Service X corresponds to a debuggee indicating a service that the user desires to debug. The user may need access rights to debug the service and each of its processes P. As used herein the term debuggee may refer to a user service being debugged or as a target service. However the term debuggee does not refer to any one specific software process i.e. process but instead refers to a collection of processes Prunning on the service to fulfill the same function. Service X executes the plurality of processes Pthat each run under a secure respective debuglet or debugger agent . Service X may execute in any operating platform or environment as part of a distributed system. Examples of operating platforms or environments that can run Service X may include infrastructure as a service IaaS e.g. GOOGLE COMPUTE ENGINE GCE using raw virtual machines platform as a service PaaS e.g. GOOGLE APP ENGINE GCE and software as a service SaaS . In some implementations the distributed system may include a cloud environment whereat one or more of different computing devices are executing the software processes Pexecuted by the service .

In some implementations the user through the computing device sets a conditional breakpoint using the IDE to implement debugging of the service . As used herein the term breakpoint refers to a point in software code where the execution context of the debuggee is sampled and the sample itself. A breakpoint will not stop the debuggee process execution but rather resumes the process execution as soon as the execution context is sampled. In some implementations the conditional breakpoint set by the user may be associated with a capture list including the desired code run by service to be debugged. The IDE sends a breakpoint request for a breakpoint to the debugging orchestrator hereinafter orchestrator . In some implementations the orchestrator may correspond to a cloud debugger service executed by one or more remote servers i.e. cloud debugger servers that orchestrates debugging functionality between the user and one or more debugees e.g. a service such as Service X executing on resources of a cloud environment . Details of the cloud debugger service architecture and an example implementation thereof are described below with reference to the exemplary implementations of respectively. The orchestrator generally indicates a debugger that refers to a service that enables the user e.g. clients developers to set and retrieve breakpoint information from one or more debugees. As used herein the term breakpoint information collectively refers to a call stack and memory state e.g. local variables objects within the breakpoint.

The orchestrator may include a set of Application Programming Interfaces APIs that allow any IDE to communicate with the orchestrator and the service processes P e.g. debuggee being debugged. Each software processes Pruns alongside a respective debuglet . As used herein the term debuglet refers to a respective debugger agent running alongside each respective debugee process Pfor executing actions such as setting and retrieving breakpoints between the orchestrator and the respective debuggee process P.

The orchestrator publishes the breakpoint request from the IDE to all the debuglets running with each software processes P. The debuglets subsequently set the breakpoint on each of the processes Pof the service . When the set breakpoint is hit by one of the processes P the respective debuglet captures information corresponding to the breakpoint and reports back to the orchestrator . The user may be notified of the hit breakpoint via a notification sent from the orchestrator to the IDE . The orchestrator may then cancel and disable the breakpoint previously set on the other processes Pallowing these processes Pto never stop running. In some implementations in the event of a race condition between the breakpoint hitting on two or more processes P the orchestrator will ignore the later captured information received by any secondary debuglets respective to processes Pthat also hit the breakpoint. In the illustrated example if the breakpoint is hit by P the orchestrator will disable the breakpoint from the other processes P P. In this example debugging capabilities of Pare sent back to the IDE from the orchestrator wherein the IDE enables the user to examine breakpoint information e.g. stack and variables within the captured breakpoint and then set a new breakpoint . Thereafter the orchestrator sets this new breakpoint to all service processes Pand resumes process P. In some examples process Pmay hit the new breakpoint whereat debugging capabilities of Pare sent back to the IDE in the same manner described above with reference to P.

The example of merely illustrates how the orchestrator in association with the debuglets running with each software processes Pin the service e.g. a job or Service X may receive a breakpoint request from the user and publish that request to all the debuglets . Using the breakpoint request published by the orchestrator the debuglets may set the breakpoint to all the processes P. In some implementations each debuglet is configured for different languages to support the respective software process on a specific operating platform or environment. Accordingly debuglets are language dependent and may correspond to their respective languages whereat the orchestrator supports at least a Java debuglet a C debuglet and Python debuglet. Additionally an open API may be provided to allow third parties to develop debuglets for other languages such as Ruby Scala or node.js Javascript. Language dependent debuglets will be described in greater detail below with reference to .

In some implementations the debugger service includes Debugger API business logic to provide functionality for setting a breakpoint SetBreakpoint retrieving a breakpoint GetBreakpoint deleting a breakpoint DeleteBreakpoint and listing breakpoints ListBreakpoints . The following pseudo code illustrates one example of implementing the API business logic of the debugger service . Other implementations are possible as well.

The debugger service further communicates an authorizer to authorize access by the user through verification that the user has debugging rights on a debuggee project resource. For instance the UI may send a user identifier corresponding to the user to the debugger service wherein the debugger service uses the user identifier to verify if the user has debugging rights on the requested debuggee project resource. As used herein the term debuggee project resource refers to a set of processes that run in a context of a specific service environment version and set of binaries files. Also as used herein the term debuggee project resource is interchangeable with the term debuggee. In other words the set of processes refer to software that the user desires to debug wherein the set of processes are executed by one or more computing devices over a distributed system e.g. the cloud environment . In some implementations the authorizer provides an authorization authority for access control list ACL management rather than the debugger service including its own ACL which may become out of sync with other project ACLs managed elsewhere. d

The debugger service also communicates with a breakpoint store that includes persistent non transitory storage for debuggee and breakpoint resources. As used herein the term breakpoint resource includes breakpoint information that may indicate a breakpoint specification such as source code location and breakpoint condition breakpoint collected information such as call stack and local variables and breakpoint state which is indicative of either one of active and final states. A new breakpoint is created active with an immutable specification until it hits or fails. Upon a hit or fail the breakpoint transitions to the final state and the breakpoint collected information is stored with the breakpoint resource in the breakpoint store . A breakpoint in the final state is immutable again and never changes its data or state.

In some implementations the breakpoint store stores debuggee identifiers that are periodically registered by respective debuglets and provides the debuggee identifiers when the UI queries the debugger service for the list of debuggees . In other implementations the breakpoint store stores breakpoints created by the debugger service based upon a selected debuggee identifier. In some implementations the breakpoint store stores an updated active breakpoint upon being hit.

A debuglet controller may include Debuglet Controller API business logic that enables debuglets to register their respective debugees to query for active breakpoints to set and to update breakpoints back when the breakpoint changes state e.g. hits or fails . The debuglet controller communicates with the breakpoint store the authorizer and one or more debuglets . The debuglet controller may further transmit notifications to the UI via notification channels indicating that a set breakpoint was hit by one of the software processes Pof the debuggee . The debuglet controller authorizes a debuggee service account access via the authorizer by verifying that the debuglet has debuggee rights to the debuggee project resource. In some implementations the API business logic of the debuglet controller may be implemented by the following pseudo code.

The debugging orchestrator may include the debugger service the breakpoint store and the debuglet controller .

The debuglet implements the actual debugger functionality corresponding to the debuggee . In some implementations the debuglet translates the breakpoint resource to a specific language and executable being debugged e.g. translate file line to address to set breakpoint . In additional implementations the debuglet further translates back a call stack once a breakpoint is hit by the debuggee e.g. translate call stack addresses back to file line . As set forth in disclosure above with reference to a debuglet runs in very close proximity to a respective debuggee software processes Pbeing debugged within the cloud environment which may include part of the same process or attached to the debuggee process. In some implementations the debuglet shares the same service account as the debuggee for communicating with the debuglet controller .

Some implementations are directed toward each debuglet being configured differently for different languages and different operating environments and platforms. For instance each debuglet may run on a distributed system e.g. cloud environment of one or more different platforms while the respective software process Pis in any programming language. Exemplary programming languages can include Java Python or C . For example a Java debuglet runs as a java agent within a java virtual machine and is capable of establishing all the information needed for registration within the debuglet controller from its operating environment or platform. In some implementations the Java debuglet can be implemented using the following pseudo code for capturing a set breakpoint at the respective debuggee .

In the implementation of the pseudo code listed above for the Java debuglet lines 070 110 indicate a period of time where the software process thread momentarily e.g. a short period of time stops running. This short period of time is described in further detail below with reference to the example operations in diagram of .

The C debuglet on the other hand is complicated by a need for symbol files. Symbols files are large and require additional resources to read and process them. Accordingly the C debuglet may include an assist task that converts breakpoint information back and forth for the debuglet . For instance the assist task may convert the file line breakpoint location to an address in the debugged process P. The symbol assist may use an external symbol server to retrieve correct symbol files. In some implementations the C debuglet runs as a process alongside the respective debuggee process Pand uses ptrace to attach and monitor that process P. The C debuglet can be implemented using the following pseudo code for capturing a set breakpoint at the respective debuggee .

In the pseudo code listed above for the C debuglet lines 100 140 indicate a short period of time where the process thread momentarily stops running. This short period of time is described in further detail below with reference to the non limiting example operations in diagram of .

The debuglet controller and the debugger service may operate in a passive manner. The notification channels are operative to reduce the user visible latency from the breakpoint to result. In other words the notification channels allows the client user to listen for a notification that a breakpoint was hit rather than poll the server for results. The notification channels may also reduce the load on the debuglet controller and the debuglet . For example a large number of debuglets may not be required to poll the server for work just to find out that nothing has changed but rather the debuglets may wait for a notification indicating new work. Accordingly the debugger service and the debuglet controller use the notification channels to publish breakpoint events that may be learned by subscribers to optimize their access to the debugger services. A notification message is configured to include just enough data to hint the subscriber of what action to take. In some implementations a notification message can be implemented using the following pseudo code.

Once the notification is received the subscriber can call one of the debugger services to find more information about the breakpoint . For instance the user via the UI can subscribe to UPDATE events in order to update the UI with a new active breakpoint state or FINAL events to get the breakpoint results. The debuglet can subscribe to the NEW events to set a new breakpoint to the debuggee or FINAL DELETE events to clear an already set breakpoint .

A service owner may decide which set of software processes Pare part of the same debuggee . Each debuggee includes a globally unique identifier across all debugees and may include any arbitrary value. The debuggee is bound to a project which is the authorization resource identifier that includes the source context. The authorization resource identifier enables the user to identify the set of source code files associated with the debuggee executed software processes P. Once a debuggee has been published it is deemed available for breakpoint information collection. The debuggee and the breakpoint resource may be stored in the breakpoint store .

In some implementations the cloud debugger service includes an architecture that enables scaling by the number of individual software processes Pbeing debugged over the distributed system . For instance the number of debugged processes Pmay be very high even though the number of users who are actively debugging at the same time is low. Moreover the cloud debugger service may selectively store debug information in a database for later retrieval.

Exemplary implementations of the present disclosure include the life of a breakpoint starting with the user via the UI browsing through source code and selecting a line of that code. At time the debugger service receives a query from the UI for a list of debuggees and uses the list to pick a desired debuggee identifier. At time the debugger service searches the breakpoint store for the desired debuggee identifier expressed in the request. The desired debuggee identifier corresponds to a service Pn the user desires to debug e.g. a debuggee . At time the debugger service receives the desired debuggee identifier from the breakpoint store and at time the UI receives the desired debuggee identifier from the debugger service . The UI uses the debuggee identifier to request to set a breakpoint condition . At time the debugger service receives the request to set the breakpoint condition and the debuggee identifier from the UI . The debugger service authorizes e.g. via the authorizer the calling user against the debuggee project generates the set breakpoint condition and stores the breakpoint information corresponding to the set breakpoint condition at the breakpoint store at time . Subsequently the debugger service transmits a notification at time that is received by all debuglets of the service at time indicating that a new breakpoint condition was generated.

Based upon the notification indicating that the new breakpoint condition was created the debuglets translate the generated breakpoint condition to a physical breakpoint that is set it to their respective debuggee processes Pat time . Times and indicate the physical breakpoint being evaluated several times by each debuglet until the physical breakpoint hits at time whereat the debuglet captures active breakpoint information corresponding to the active physical breakpoint that was hit. At time all the debuggee processes Presume execution. Thus between times and the debuggee process Pis momentarily stopped for a short period of time to capture the active breakpoint information.

At time the debuglet controller receives a request from the debuglet to update the active breakpoint information that was captured by the debuglet e.g. active breakpoint update request and after the debuglet controller authorizes the debuglet against the debuggee process P e.g. registered project the debuglet controller stores the active breakpoint information at the breakpoint store at time and transmits a notification received by the UI at time indicating the active physical breakpoint . All other debuglets of the same debuggee receive this notification at time and remove the physical breakpoint from their respective debuggee processes Pat time .

Based upon the notification received from the debuglet controller sent via notification channels the UI requests the debugger service to retrieve the active breakpoint information which is received by the debugger service at time . After the debugger service authorizes the user identifier the active breakpoint information is retrieved from the breakpoint store at time and returned to the debugger service at time and the UI at time . Here the user can command the process Pto resume in some implementations or stop execution of the process Pentirely to explore more.

The implementations provided by the example operations in diagram of illustrate that the running debuggee process does not stop for a prolong amount of time for the user to examine its state but rather defines the runtime context elements to capture ahead of time before the breakpoint is actually hit. Once the breakpoint condition hits the debuglet captures the predefined state and resumes the debuggee execution. Accordingly the capture happens while the process Pn is stopped during a short time frame appropriate to the service being debugged. For instance the debuggee process Pis only momentarily stopped between times and until the active breakpoint that hit is captured. Thus performance degradation of the debuggee is reduced due to the non stopping breakpoint e.g. a watchpoint only interrupting the debuggee for the short time frame while the capture takes place and is then immediately removed.

In some implementations the capture context of the watchpoint is computed ahead of time. Here when the user e.g. developer sets the watchpoint line the debugger service already knows to compute the variables to capture as well as how to capture the stack whereat the debuglets perform this computation differently for different programming language or any other context the user desired to capture. This is done without interrupting the running debuggee process P. The debuglet may set a breakpoint to the debuggee process Pwhile associating the capture list with the breakpoint and once the breakpoint hits the debuglet captures and evaluates the condition first. If the condition is true the debuglet executes the capture list with only a limited variable buffer and then resumes the debuggee . Once the debuggee is resumed the debuglet formats the captured values which might include looking up symbols or formatting data into representable format e.g. strings and trees and returns the data to the user . In some implementations the capture is done without any external communication at the time of the capture except debuglet to debuggee which is language dependent . In some implementations a further optimization can include the debuglet to opt not to capture values that are immutable such as strings in Java and just take a reference at capture time whereat the copy of the actual value can happen after the process thread is resumed.

Generally traditional debuggers are used as a personal tool or as a tool shared by a small group. Once a developer debugs a process no other developer can debug the same process at the same time and thus all other users become merely spectators of the debug session. The cloud debugger service enables multiple developers to debug and share debug results from a single process or multiple jobs. Here the debugger service accepts debug requests from one or more developers and routes them to the appropriate debuglets via the debuglet controller . Once results become available the debugger service picks the results up from the debuglets and returns it to the requesting developer via the UI associated with the debug request . Accordingly multiple developers are enabled by the cloud debugger service to send requests to a single process Por job at the same time. Every debug request includes its own identity allowing users to exchange those identities e.g. over URL to view the same results. In some implementations the debugger service API enables developers to use their favorite debugging tool to connect to that service for debugging rather than limiting the developers to one tool.

The cloud debugger server includes at least one processing device for executing the debugger service and the debuglet controller . Components of the cloud debugger server are described in further detail with reference to the processing device shown in .

In some implementations the breakpoint store is external to the cloud debugger server . In other implementations the breakpoint store is integrated within the cloud debugger server . The auditor is utilized for auditing the user setting the breakpoint the user retrieving the breakpoint with potential PII and the debuglet updating the breakpoint information.

The distributed system may be the cloud environment . The distributed system may include processing and storage devices . The distributed system may be executed by one or multiple computing devices over the internet. In some implementations the distributed system includes services and that may be debugged by the cloud debugger service . Thus services and are indicative of debugees and each includes one or more running software processes P. The services and may all include different software programming languages. Service indicates a Java Service with a respective debuglet on environment A. For instance environment A may correspond to the GOOGLE APPLICATION ENGINE GAE . Service indicates a Python Service with a respective debuglet on Environment B. For instance environment B may correspond to the GOOGLE COMPUTE ENGINE GCE . Service indicates the C service with a respective debuglet on environment C. For instance environment C may correspond to a supervisory platform that orchestrates multiple cloud computing environments. In some implementations service utilizes a symbol assist for converting breakpoint information back and forth for the debuglet . The symbol assist may retrieve appropriate symbols from a symbol server . In some implementations the symbol server may be maintained by the cloud debugger service .

The computing device includes a processing device i.e. processor memory a storage device a high speed interface controller connecting to the memory and high speed expansion ports and a low speed interface controller connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a graphical user interface GUI on an external input output device such as display coupled to high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information non transitorily within the computing device . The memory may be a computer readable medium a volatile memory unit s or non volatile memory unit s . The non transitory memory may be physical devices used to store programs e.g. sequences of instructions or data e.g. program state information on a temporary or permanent basis for use by the computing device . Examples of non volatile memory include but are not limited to flash memory and read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM e.g. typically used for firmware such as boot programs phase change memory PCM as well as disks or tapes. Examples of volatile memory include but are not limited to random access memory RAM dynamic random access memory DRAM or static random access memory SRAM .

The storage device is capable of providing mass storage for the computing device . In some implementations the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. In additional implementations a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device or memory on processor .

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of duties is exemplary only. In some implementations the high speed controller is coupled to the memory the display e.g. through a graphics processor or accelerator and to the high speed expansion ports which may accept various expansion cards not shown . In some implementations the low speed controller is coupled to the storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers as a laptop computer or as part of a rack server system

In some implementations the server may further include the breakpoint store e.g. in the memory . The processing device executes the debugger service and the debuglet controller . For example the debugger service executing on the processing device may receive the breakpoint request from a computing device corresponding to a user developer generate the breakpoint condition notify the new breakpoint condition to the debuglets and store the breakpoint condition at the breakpoint store . The debugger service may further retrieve a list of registered debuglets from the breakpoint store and provide the list to the user . In another example the debuglet controller of the processing device may receive a request from one of the debuglets to update active breakpoint information captured by the debuglet upon a physical breakpoint condition being hit by one of the software processes Pof the distributed service . The debuglet controller may further transmit a notification indicating the physical breakpoint condition being hit to the computing device corresponding to the user and to each of the debuglets such that the user can analyze the active breakpoint condition and the remaining debuglets can cancel the physical breakpoint .

The storage device of the cloud debugger server may provide mass storage for the processing device . In some implementations the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations.

The communication device may facilitate communication between the cloud debugger server and each user via the UI the distributed system and the breakpoint store . The communication device may further communicate with the authorizer and the auditor .

At operation the debugger service transmits the generated breakpoint condition to a plurality of debuglets each respective to corresponding ones of software processes Pexecuted by the debuggee as illustrated in between times and . The software processes Pcan be executed by the debuggee services . Specifically each debuglet is operative to translate the generated breakpoint condition to a physical breakpoint condition set to the respective software process P as illustrated between times and of the diagram of . For example each debuglet is dependent upon the programming language of its respective software process P whereat each debuglet may translate the generated breakpoint condition to the specific programming language and executable associated with the respective software process P.

At operation the debuglet controller receives a request from one of the debuglets to update active breakpoint information captured by the debuglet upon the physical breakpoint condition being hit by one of the software processes Pas illustrated in the diagram of between times and . For example the active breakpoint information may include a call stack corresponding to the physical breakpoint condition being hit wherein the call stack is translated by one of the debuglets prior to being received at the processing device e.g. at the debuglet controller . Moreover the debuglet controller stores the active breakpoint information at the breakpoint store as illustrated at time in the diagram of .

At operation the debuglet controller transmits a notification to the computing device corresponding to the user via the as illustrated in the diagram of at time . The notification indicates the physical breakpoint condition being hit when the update active breakpoint information is received. Here the user via the UI of the computing device may request the processing device to retrieve active breakpoint information from the breakpoint store in response to the notification as illustrated in the diagram of between times and . In some implementations the debuglet controller transmits the notification to remaining debuglets that did not capture the active breakpoint information as illustrated in the diagram of at time . Here the remaining debuglets may remove the physical breakpoint condition from the respective debuggee software processes P as illustrated in the diagram of at time .

Examplary implementations are directed towards minimizing the amount of changes made by the debuglets to the debugger process memory and state e.g. by minimizing the amount of writes to the debuggee memory by the debuglet and minimizing the amount of code executed in the debugger process Pon behalf of the debuglet to reduce the risk of a bug or malformed request causing the debuggee process Pto change its execution or process injected data. In some implementations debuglets run using the same account as the debuggee thus do not require the debuggee to enable other accounts access to its processes P. In some implementations debuglets do not open incoming ports for communication with the debuglet controller but rather use only outgoing connection to a well known endpoint the debuglet controller . In some implementations the cloud debugger server performs an authorization check on all requests thus reducing the debuggee DoS attack surface.

Various implementations of the systems and techniques described here can be realized in digital electronic and or optical circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product non transitory computer readable medium apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Moreover subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a computer readable medium for execution by or to control the operation of data processing apparatus. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them. The terms data processing apparatus computing device and computing processor encompass all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. A propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus.

A computer program also known as an application program software software application script or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio player a Global Positioning System GPS receiver to name just a few. Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user one or more aspects of the disclosure can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display monitor or touch screen for displaying information to the user and optionally a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

One or more aspects of the disclosure can be implemented in a computing system that includes a backend component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a frontend component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such backend middleware or frontend components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN an inter network e.g. the Internet and peer to peer networks e.g. ad hoc peer to peer networks .

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. In some implementations a server transmits data e.g. an HTML page to a client device e.g. for purposes of displaying data to and receiving user input from a user interacting with the client device . Data generated at the client device e.g. a result of the user interaction can be received from the client device at the server.

While this specification contains many specifics these should not be construed as limitations on the scope of the disclosure or of what may be claimed but rather as descriptions of features specific to particular implementations of the disclosure. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multi tasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other implementations are within the scope of the following claims. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

