---

title: Time travel debugging for browser components
abstract: Various technologies described herein pertain to performing time travel debugging. A computer-executable program can be executed. The computer-executable program can be executable under control of a virtual machine. The virtual machine can interact with a browser system during execution of the computer-executable program. Moreover, nondeterministic events can be logged via an interrogative virtual machine interface (VMI) during the execution of the computer-executable program. The nondeterministic events can be logged as part of event logs. Moreover, the interrogative VMI is between the virtual machine and the browser system. Further, snapshots of the virtual machine can be captured during the execution of the computer-executable program. The snapshots can be captured via the interrogative VMI. At least a portion of the execution of the computer-executable program can be replayed based at least in part on a snapshot and at least a portion of the event logs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09588870&OS=09588870&RS=09588870
owner: Microsoft Technology Licensing, LLC
number: 09588870
owner_city: Redmond
owner_country: US
publication_date: 20150626
---
This application claims priority to U.S. Provisional Patent Application No. 62 143 435 filed on Apr. 6 2015 and entitled TIME TRAVEL DEBUGGING FOR BROWSER COMPONENTS the entirety of which is incorporated herein by reference.

Developers commonly spend significant amounts of time debugging programs. Developers often apply the scientific method when debugging programs for instance a developer may observe behavior of a program on different inputs first to reproduce a bug then to localize the bug in source code of the program. Reproducing localizing and then fixing bugs typically involve forming and validating hypotheses about root causes of the bugs. A root cause of a bug is a first point at which a state of a program diverges from an intended state. To validate a hypothesis a developer often halts program execution and examines the state of the program. Especially early in debugging when the developer s query is still elusive execution is commonly halted too soon or too late to validate a hypothesis. Overshooting e.g. late halting of the execution of the program can be expensive because returning to an earlier point in an execution of a program commonly involves restarting and re running the program.

A virtual machine can be useful for capturing a state of a program. For example a virtualization layer can act as a boundary for encapsulating program state which can enable snapshotting migrating and resuming complex multi level software applications. A virtual machine interface VMI of a virtual machine can provide an introspection point for logging events that affect program execution.

Some conventional virtual machines which virtualize at the x86 level provide strong and efficient isolation. By virtualizing at the x86 level these conventional virtual machines can provide precise snapshots that capture hardware level information. However with these conventional approaches a full virtual machine snapshot can be on the order of hundreds of MBs in size and an x86 level event log can grow on the order of hundreds of MBs per day.

A debugger can be used to halt program execution and examine the state of the program e.g. via a graphical user interface GUI . However tool support for debugging has remained relatively unchanged for many years. Accordingly the cost of restarting and re running the program when a breakpoint is placed too late in the execution of the program remains.

Described herein are various technologies that pertain to performing time travel debugging. A computer executable program can be executed. The computer executable program can be executable under control of a virtual machine. The virtual machine can interact with a browser system during execution of the computer executable program. Moreover nondeterministic events can be logged via an interrogative virtual machine interface VMI during the execution of the computer executable program. The nondeterministic events can be logged as part of event logs. Moreover the interrogative VMI is between the virtual machine and the browser system. Further snapshots of the virtual machine can be captured during the execution of the computer executable program. The snapshots can be captured via the interrogative VMI. At least a portion of the execution of the computer executable program can be replayed based at least in part on a snapshot and at least a portion of the event logs.

The above summary presents a simplified summary in order to provide a basic understanding of some aspects of the systems and or methods discussed herein. This summary is not an extensive overview of the systems and or methods discussed herein. It is not intended to identify key critical elements or to delineate the scope of such systems and or methods. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Various technologies pertaining to performing time travel debugging with browser components are now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of one or more aspects. It may be evident however that such aspect s may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing one or more aspects. Further it is to be understood that functionality that is described as being carried out by certain system components may be performed by multiple components. Similarly for instance a component may be configured to perform functionality that is described as being carried out by multiple components.

Moreover the term or is intended to mean an inclusive or rather than an exclusive or. That is unless specified otherwise or clear from the context the phrase X employs A or B is intended to mean any of the natural inclusive permutations. That is the phrase X employs A or B is satisfied by any of the following instances X employs A X employs B or X employs both A and B. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from the context to be directed to a singular form.

Referring now to the drawings illustrates a computing system that performs time travel debugging. The computing system includes at least one processor and memory . The at least one processor is configured to execute instructions loaded into the memory e.g. system s and or component s loaded into the memory are executable by the processor . As described in greater detail herein the memory includes instructions configured to perform time travel debugging for a browser system .

According to various examples the computing system can be or include a computing device. Pursuant to various illustrations the computing device can be a desktop computing device a mobile computing device e.g. a laptop computing device a mobile telephone a tablet computing device a wearable computing device a handheld computing device a portable gaming device a personal digital assistant PDA etc. a gaming console a set top box an in vehicle communications and infotainment system or the like. In accordance with other examples the computing system can be or include one or more server computing devices. For instance the computing system can be or include one or more datacenters where a datacenter includes a plurality of server computing devices. Additionally or alternatively the computing system can be a distributed computing system.

The memory of the computing system includes a computer executable program and a virtual machine VM e.g. a managed runtime etc. . The computer executable program can include a sequence of instructions that are executable under control of the virtual machine . The virtual machine can compile and or interpret the computer executable program for the processor and perform the instructions included in the computer executable program .

The memory further includes the browser system e.g. a web browser . The browser system can be configured to retrieve present and traverse information available on a network in a file system e.g. of the computing system or a disparate computing system or the like. Moreover an interrogative virtual machine interface VMI is an interface between the virtual machine and the browser system . The interrogative VMI enables nondeterministic events to be exposed to the virtual machine . The interrogative VMI exposes minimal amounts of state belonging to otherwise opaque black box components. A minimal amount of state from a particular black box component can be a least amount of state for accurately snapshotting and logging events for such black box component.

The virtual machine can be a process virtual machine that runs as an application inside a host operating system and supports a process. The virtual machine can provide a platform independent programming environment that abstracts details of the underlying hardware or operating system and enables the computer executable program to be executed on differing platforms.

According to an example the computer executable program can be or include a script written in a scripting language e.g. JavaScript etc. following this example the script can be interpreted and executed by the virtual machine . However it is contemplated that other types of computer executable programs and other types of virtual machines other types of managed runtimes are intended to fall within the scope of the hereto appended claims e.g. a computer executable program written in the Java programming language and Java web toolkit JWt a computer executable program written in the C programming language and Windows Presentation Foundation WPF etc. .

The virtual machine includes an execution component that can be configured to receive the computer executable program . Moreover the execution component can be configured to execute the computer executable program .

According to an example the execution component can be or include an interpreter. According to an exemplary scenario the interpreter can directly perform the instructions of the computer executable program . In accordance with another exemplary scenario the interpreter can translate the instructions of the computer executable program to an intermediate representation and can execute the intermediate representation. According to yet another exemplary scenario the instructions of the computer executable program can include precompiled code and the interpreter can execute such precompiled code e.g. the precompiled code can be machine independent code . Moreover it is contemplated that a combination of the foregoing exemplary scenarios can be implemented by the interpreter. Further pursuant to an illustration it is contemplated that the interpreter can be a bytecode interpreter yet other types of interpreters are intended to fall within the scope of the hereto appended claims.

By way of another example the execution component can additionally or alternatively be or include a just in time JIT compiler. The JIT compiler can convert intermediate language instructions of the computer executable program to machine instructions for execution by the processor . Further the JIT compiler can execute the machine instructions.

The virtual machine can further include a snapshot component configured to record a sequence of snapshots of the virtual machine e.g. VM snapshots during execution of the computer executable program at various times. The snapshot component can be configured to record the snapshots via the interrogative VMI Moreover the snapshots recorded by the snapshot component can be stored in a data store of the computing system . The computer executable program during execution by the execution component stores data in variables which represent storage locations in the memory e.g. call stack heap etc. . At a given point during the execution of the computer executable program content of the storage locations in the memory can be recorded as a snapshot of the virtual machine .

According to an example the snapshots in the sequence can be periodically recorded by the snapshot component at a predefined time interval. Pursuant to another example a time interval at which the snapshots are sequentially recorded by the snapshot component can be dynamically adjusted following this example the time interval can be dynamically adjusted during the execution of the computer executable program .

Moreover the virtual machine can include an event logger component configured to log nondeterministic events during execution of the computer executable program as part of event logs . The event logs for example can be stored in the data store . The event logger component can log the nondeterministic events that affect execution of the computer executable program via the interrogative VMI . For instance the virtual machine can be extended to define the interrogative VMI which enables the event logger component to capture various nontraditional events. Moreover the event logs can enable a variety of debugging analyses.

Due to the interrogative VMI the snapshot component and the event logger component can efficiently capture application level semantics in order to reduce the size of the snapshots and the event logs . By raising the abstraction level of the interrogative VMI to that of the application of interest the snapshot component and or the event logger component can ignore portions of architectural state in an operating system OS and the hardware when capturing the snapshots and or the event logs .

According to an example the virtual machine can be a runtime environment layered atop a lower level runtime environment. Such virtualized interfaces can enable various useful services. For example the virtual machine can hide sensitive low level resources from untrusted applications e.g. such resources can be hidden from the computer executable program and cause potentially dangerous operations to pass dynamic security checks. Moreover if the event logger component of the virtual machine logs the nondeterministic data that the virtual machine exchanges with the computer executable program then the event logs can later be used by a time travel debugger to replay the execution of the computer executable program these replayed executions for instance can be useful for security forensics and debugging of the computer executable program . The virtual machine can also define an encapsulation boundary for a state of the computer executable program e.g. the snapshots can be useful for suspend resume services and for migrating applications across different machines .

Various properties of the interrogative VMI are now described. The interrogative VMI can reduce a size of a virtual machine state in comparison to conventional low level virtual machines . Smaller virtual machines are faster to snapshot faster to load and faster to transfer across a network as compared to larger virtual machines. In turn this makes it cheaper to perform suspension resumption and migration of a virtual machine. Small virtual machines also allow datacenter operators to place more virtual machines on a single physical server which allows for enhanced server utilization.

Moreover the interrogative VMI can cause a size of the nondeterministic event logs to be reduced relative to conventional low level virtual machines . For many debugging and forensics scenarios static snapshots of the virtual machine may provide insufficient context thus the snapshots can be supplemented with the event logs that describe how the virtual machine evolves between the snapshots . Small event logs combined with small snapshots make it feasible to store long term execution traces for complex applications e.g. the computer executable program .

Further the interrogative VMI can enable the snapshots and the event logs to be semantically complete. The snapshots and the event logs can include information for understanding the execution history of the computer executable program by the virtual machine . Thus execution analyses can be performed without using heuristics for inferring application state e.g. such heuristics may be fallible .

Moreover the interrogative VMI enables efficient generation of the snapshots by the snapshot component and the event logs by the event logger component . Accordingly snapshotting and event logging can be fast and can have low computational overheads due to the interrogative VMI e.g. as compared to snapshotting and event logging for conventional low level virtual machines .

Interrogative virtualization is supported by the interrogative VMI . A level of abstraction of the interrogative VMI for the virtual machine is raised as compared to some conventional VMIs for some traditional virtual machines more particularly the interrogative VMI is moved away from interfaces presented by the hardware or the operating system and towards an application level semantic interface. For example managed language runtimes and application frameworks can mediate a program s interactions with the local machine and the outside world. Virtualizing at the application visible level of abstraction allows large amounts of architectural state that is oftentimes captured by low level approaches to be ignored. However not all of the low level state can be ignored as is common with conventional managed language runtimes and application frameworks. For example a raw bitmap for a display may be hidden by the application visible graphics interface but this state may be needed for understanding the execution history of the computer executable program . Thus interrogative virtualization makes modifications to the high level application interface instead providing the interrogative VMI that exposes events to the virtual machine which are hidden from the computer executable program . The virtual machine can interrogate nominally black box components via the interrogative VMI to enable the snapshot component and the event logger component to capture the application level semantics while safely ignoring many details at the hardware or operating system level.

Many traditional VMIs tend to be designed to provide efficient and strong isolation between different virtual machines. As a result these traditional VMIs provide narrow low level interfaces to minimize the trusted computing base and leverage hardware support for virtualization. However virtualizing at a low level involves a trade off isolation becomes cheap but other virtual machine operations become expensive. For instance conventional virtual machine snapshots oftentimes are large because they include substantial amounts of architectural state. Further execution traces commonly grow quickly due to the vast number of low level nondeterministic events. Moreover application level program analysis is often overdetermined since a conventional virtual machine commonly includes data from multiple layers in the software and hardware stack when often the top layers without the lower layers enable understanding execution of a computer executable program.

In contrast to traditional VMIs the interrogative VMI for the virtual machine can be high level and wide enough to capture application semantics. Compared to low level narrow virtualization interfaces the interrogative VMI can enable implementing various virtual machine operations using an order of magnitude less time and space. To provide strong efficient isolation the interrogative VMI can be nested within a low level virtualization framework which can provide security thus security need not be sacrificed for performance.

The virtual machine can also include the time travel debugger the time travel debugger can also be referred to as a time travel debugger component . The time travel debugger can be configured to test and debug the computer executable program . The time travel debugger is a debugger that steps forwards and backwards through execution of a computer executable program e.g. the computer executable program during a debugging session. In contrast conventional debuggers oftentimes tend to step forwards through execution of a computer executable program during a debugging session without being able to step backwards through such execution. For instance the time travel debugger allows execution to be reversed during a debugging session e.g. if a breakpoint is set too late so as to not require re execution of a computer executable program with the breakpoint moved to be earlier in time . The time travel debugger supports forward and reverse debugging of the computer executable program . As noted above when the computer executable program is executed by the execution component the snapshot component can record the snapshots and the event logger component can record nondeterministic events in the event logs to capture the execution of the computer executable program . The time travel debugger can be configured to replay the execution of the computer executable program by stepping the execution of the computer executable program both forwards and backwards in time.

The time travel debugger can be configured to replay at least a portion of the execution of the computer executable program based at least in part on a snapshot from the snapshots and at least a portion of the event logs . Using the interrogative VMI the time travel debugger can enable time travel debugging for the browser system . Conventionally time travel debugging often is too expensive to run on production servers or on resource limited end user machines with poor network connections.

The time travel debugger can be configured to perform backwards facing variants for traditional forward facing operations like step forward and step out. By instrumenting the interrogative VMI the event logger component can log nondeterministic events e.g. the event logs and the snapshot component can capture the snapshots of the virtual machine . Later during a debugging session the time travel debugger can be configured to travel to time t by identifying a snapshot from the snapshots that temporally precedes time t loading the snapshot that temporally preceded time t and then replaying the event logs from the snapshot to the time t. For example a most recent snapshot from the snapshots that occurred before t can be loaded by the time travel debugger however it is contemplated that a differing snapshot from the snapshots that occurred before t can alternatively be loaded by the time travel debugger .

By logging events and tracking state at the level of the interrogative VMI storage overheads can be reduced in comparison to systems that introspect at a lower level e.g. x86 instructions or systems calls and UNIX signals . With the interrogative VMI sizes of the snapshots of the state of the virtual machine and the nondeterministic event logs can be decreased as compared to lower level approaches. For instance heap intensive applications can have compressed snapshots that are less than 500 KB in size. Moreover for interactive games and applications the event logs may grow at about 1 KB per second. The time travel debugger can also provide more robust higher fidelity replay than conventional systems that lack the vantage point of the interrogative VMI and which consequently rely on inference methods to reconstruct state that is readily available in the interrogative system as described herein.

The virtual machine and the interrogative VMI enable nondeterminism logging of event logs and capturing of snapshots . Further the snapshots and the event logs can be device and address independent. According to an example it is contemplated that the time travel debugger on a program bug can report an error state as well as a last k seconds of events before the bug. Pursuant to an illustration the snapshots and the event logs can be at the JavaScript HTML level which can be saved for later debugging or transmitted to another computing system. Moreover the other computing system need not have the same version of JavaScript HTML engines or operating system. However the claimed subject matter is not limited to the foregoing illustration.

Turning to illustrated is a system that employs interrogative virtualization to enable time travel debugging. The system includes a script based virtual machine thus as set forth in the example of the virtual machine can be the script based virtual machine . The script based virtual machine can interpret and execute the computer executable program . More particularly the computer executable program can be a script written in a scripting language e.g. JavaScript etc. and thus the script based virtual machine can interpret and execute such script. Moreover the script based virtual machine can include the execution component the snapshot component the event logger component and the time travel debugger .

The system further includes the browser system . The browser system can include various components. As depicted the browser system can include a storage component a runtime library a network component and a renderer component . However it is contemplated that the browser system may lack one or more of the foregoing components and or may include differing components. Moreover the interrogative VMI is an interface between the script based virtual machine and the browser system .

The script based virtual machine can include one or more execution contexts. As illustrated the script based virtual machine is shown as including an execution context and an execution context . However it is contemplated that the script based virtual machine can include more or less than two execution contexts. The execution contexts of the script based virtual machine are collectively referred to herein as execution contexts . Each of the execution contexts can be single threaded and event driven.

According to an illustration as the execution context or any of the other execution contexts runs its initialization code callback functions that respond to events are defined. After the initialization code terminates subsequent code execution can be driven by reception of events and firing of associated handlers. Since the execution context is single threaded a call chain that is initiated by an event handler is atomic once started the call chain runs to completion and at any given time the execution context has at most one active call chain. Moreover different execution contexts can exchange data using an asynchronous pass by value communication channel e.g. postMessage .

The components of the browser system e.g. the storage component the runtime library the network component the renderer component etc. can be event driven black box components. These components can be black boxes because from the perspective of the computer executable program such components hide their implementations behind opaque interfaces. However the execution contexts are event driven so the black box components can export event driven interface s to interoperate with the computer executable program .

The script based virtual machine can include an interface component configured to interact with the black box components of the browser system via exposed interfaces e.g. application programming interfaces APIs of the black box components. Accordingly the black box components of the browser system can be interrogated by the interface component of the script based virtual machine via the interrogative VMI .

Pursuant to an example the renderer component can be a black box component of the browser system . Internally the renderer component can be written in C and it may use multiple threads or processes to calculate visual layouts and update a bitmap. However from the perspective of an execution context e.g. one of the execution contexts a frame in a web page the renderer component exposes a single threaded event driven API through the Document Object Model DOM . To receive notifications about changes to DOM state by the renderer component the computer executable program can register callbacks which the renderer component triggers when the relevant state changes. The computer executable program can modify DOM state through a variety of synchronous and asynchronous APIs. However even the synchronous APIs can be implemented as remote procedure call RPC messages that trigger event handlers in the renderer component to provide synchronous semantics the browser system can pause the caller until the renderer component has responded to the RPC request.

The script based virtual machine can include one or more message driven execution contexts some of which may be black boxes with respect to the computer executable program . Other examples of black box components include the network component e.g. a network stack in the browser system and the storage component e.g. database interfaces used by server side scripting language frameworks .

Given the event driven nature of the script based virtual machine the interrogative VMI can include an aggregate set of event channels. By interposing on messages exchanged via these channels the interactions between the various components in the script based virtual machine may be captured. However black box components oftentimes do not generate events for various changes to internal state. For example the computer executable program can request the renderer component to perform a Cascading Style Sheets CSS animation that periodically modifies a user visible DOM state. At any given moment the computer executable program can synchronously request the renderer component for a view of the DOM. However these synchronous queries hide the fact that the renderer component executes in parallel with the computer executable program . The renderer component typically updates the visual display without triggering script side notifications meaning that the script side view of the DOM can desynchronize from the true DOM state inside the renderer component . This may be sufficient if it is desired to isolate and analyze the execution contexts . However if it is desired to isolate and analyze the complete script based virtual machine for a client side web page or a Node application missing events can impact correctness performance or both. Moreover the script based virtual machine may include multiple execution contexts and black box components. It is to be appreciated that a debugger for a web page can produce erroneous results if it lacks sufficient insights into rendering events. Further logging and replay can be more efficient when the VMI event interface is semantically complete such as the interrogative VMI .

To ensure this semantic completeness the black box components can be modified so that these components export a wider variety of events. This approach is referred to herein as interrogative virtualization and includes interrogating the black box components to reveal specific parts of their hidden states. Interrogative virtualization extends the virtualization interface itself to improve the performance or correctness of operations upon virtual machines.

For example if the script based virtual machine runs inside of a web browser e.g. the browser system the renderer component can be changed to report a tick count associated with an animation. The renderer component can be configured to perform the animation and associate the tick count with the animation where the tick count can be indicative of how close the animation is to a final repaint. Following this example the tick count associated with the animation can be exposed to the script based virtual machine via the interrogative VMI .

According to another example if the script based virtual machine runs within a server side Node deployment the storage component e.g. the database stack can be modified to enable logging objects that are read and written to storage. Pursuant to a further example the network component can download an external resource e.g. the renderer component can cause the network component to download the external resource etc. following this example an event indicative of the external resource being downloaded by the network component can be exposed to the script based virtual machine via the interrogative VMI . By way of yet another example a callback list managed by the renderer component can be exposed to the script based virtual machine via the interrogative VMI .

The script based virtual machine supports nested virtualization. In general large interfaces may negatively impact security. Such interfaces can increase a threat surface that is visible to an attacker and their rich semantics can cause defenders to reason about a variety of corner cases. Interrogative virtualization adds communication channels to the virtual interface so at first glance interrogative virtualization seems to negatively impact security there appear to be more opportunities for an attacker to escape an isolation container of the script based virtual machine . However the application visible execution interface need not be conflated with a structural isolation boundary. The former is the interface that applications directly invoke whereas the latter is the interface at which isolation and security are enforced.

As shown in nested virtualization can be used to layer the interrogative VMI e.g. with a rich wide interface atop a smaller low level VMI e.g. a security monitor VMI defined by a virtual machine monitor VMM e.g. a hypervisor . The VMM can provide services that allow multiple operating systems to execute on hardware of a computing system e.g. the computing system . Isolation enforcement is performed by the VMM but other management decisions involving the script based virtual machine are performed by an interrogative VM VMM . The interrogative VMM can be similar to a library OS for the VM yet since the interrogative interface is sufficiently expressive to capture the application level semantics the library OS s internal state need not be included in the snapshots e.g. the snapshots or the event logs e.g. the event logs . For example the interrogative VMI does not expose raw memory addresses so even though the VMM may internally manipulate raw addresses those addresses are not mentioned in the event logs or the snapshots. By excluding unnecessary architectural state from the interrogative VMI sizes of snapshots and event logs can be reduced by an order of magnitude.

The interrogative VMI can be constructed by extending the script based virtual machine used by a web browser e.g. the browser system . Interfaces e.g. the interface component of the script based virtual machine to black box components such as the storage component the runtime library the network component e.g. the network stack and the renderer component can be modified to include a number of interrogative APIs to expose hidden state. Using the interrogative VMI an efficient snapshotting mechanism e.g. executed by the snapshot component can be implemented for the script based virtual machine this can facilitate VM suspension migration and resumption. Further the interrogative VMI can be augmented to record e.g. via the event logger component the nondeterministic events that enter and leave the script based virtual machine . The result can be for instance a fully functional interrogative VMI for the client side of a web application.

Hidden state can be exposed via the interrogative VMI . The script based virtual machine can allow scripting language code to perform computations. To allow scripting language code to access local storage exchange network traffic and interact with the display the script based virtual machine can communicate with external input output I O modules. Runtime information about the IO stack as well as the script based virtual machine can be captured via the interrogative VMI . Below are some examples that enable application level semantics to be captured.

CSS SVG Animation State Browsers commonly use a dedicated thread to perform CSS and Scalable Vector Graphics SVG animations. These animations typically run in parallel with script execution and once triggered they conventionally run to completion e.g. not paused or resumed by scripting language code .

Internally the renderer component can associate a tick count with each animation. The tick count represents how close the animation is to its final repaint. The renderer component can expose these tick counts to the script based virtual machine via the interrogative VMI . The tick counts can be employed as logical clock values to synchronize the concurrent execution of the script based virtual machine and the renderer component . Moreover the renderer component can allow the script based virtual machine to pause or restart an animation from a given tick count via the interrogative VMI .

Event Listeners As described herein the scripting language code can be event driven. For instance after a page s initialization code runs subsequent code can be triggered by the arrival of events like key presses and mouse clicks. The scripting language code can register callback functions for events e.g. using the addEventListener evtName callback method . An application can register multiple callbacks for the same event.

Callback lists are managed by the renderer component such callback lists typically cannot be accessed from a conventional virtual machine. In contrast the script based virtual machine can access the callback lists managed by the renderer component via the interrogative VMI . At snapshot time the script based virtual machine can use the interrogative VMI to enumerate and the callback lists and serialize such lists. At resurrection time the script based virtual machine can use an interface of the renderer component that restores the serialized lists.

External Resources Objects in the DOM can refer to resources that are hosted on external servers. For example img elements refer to images and iframe elements refer to HTML documents. To fetch such external content the renderer component can bypass the script based virtual machine and directly communicate with the network component e.g. the network stack .

Accordingly the network component can expose a set of additional events to the script based virtual machine via the interrogative VMI . Examples of such events exposed by the network component include an event that indicates when the network component has finished downloading a resource. This allows the interrogative VMI to be employed by the script based virtual machine to log the fetched value as well as determine when the download completed with respect to other concurrent activities like execution of a computer executable program e.g. the computer executable program .

Timers Applications can spawn and cancel one time or recurring timers. According to an example a setTimeout interface can be used by the script based virtual machine to spawn a one time timer a setInterval interface can be used by the script based virtual machine to spawn a recurring timer a clearTimeout interface can be used by the script based virtual machine to cancel a one time timer and a clearInterval interface can be used by the script based virtual machine to cancel a recurring timer. The renderer component for instance can manage these timers yet the renderer component typically does not expose their state to conventional virtual machines.

These four interfaces can be interposed on from within the script based virtual machine to keep track of and expose active timers and their associated callbacks. According to another example the renderer component can be modified to expose the timers to the script based virtual machine via the interrogative VMI . By way of another example the script based virtual machine can add new active timers when the application creates them and timestamp their creation and remove them when the application clears them. Following this example when a one time timer fires e.g. upon expiration of the timer the script based virtual machine removes it from the active set. Moreover pursuant to this example when an interval timer fires the script based virtual machine updates its timestamp.

State snapshots e.g. captured by the snapshot component of the script based virtual machine are now described in greater detail. To capture a snapshot of the script based virtual machine the snapshot component can wait for each execution context to quiesce. Each execution context can be single threaded so quiescence can occur when the local event loop has finished executing an event handler stack state need not be captured since the context has no outstanding call chains. Once the execution contexts are paused the snapshot component can capture black box state using the interrogative APIs of the interrogative VMI .

DOM Elements A DOM element may have a set of string properties a nested tree of DOM elements and event listeners. The snapshot component can capture this information using existing DOM interfaces and the VMI extensions. To resurrect the DOM state in a snapshot each DOM object can be recreated using existing DOM interfaces e.g. to create an element to set an attribute etc. .

In general the renderer component can execute in parallel with the script based virtual machine . However the renderer component can block during synchronous RPC exchanges with the script based virtual machine . Accordingly to avoid race conditions at snapshot time the interface of the renderer component can be extended to support a synchronous no op RPC that prevents the renderer component from generating GUI events repainting the screen and so on. Using this no op RPC the snapshot component can pause the renderer component before serializing the state of the script based virtual machine . This ordering can mitigate the execution contexts from including references to stale renderer side state.

Canvas Context Canvas elements in the DOM can have an associated context object that includes the visual state of the canvas. The context object can be retrievable using an interface that gets a context object of a canvas. The snapshot component can record each canvas s visual state as a bitmap. During snapshot inflation the bitmap can be reapplied to restore the canvas to its previous state.

Heap Managed languages often have garbage collectors that can efficiently walk the heap. The snapshot component can identify live scripting language objects and serialize such objects. Primitive values like numbers and strings can be serialized. Moreover arrays and objects can be serialized as bags of properties. Object references including references to DOM objects can be rewritten to point to the target object s location in the snapshot.

Event Queue When the snapshot component runs execution contexts are quiescent. However the contexts may have non empty event queues. Each event can include one or more callbacks to invoke and one or more arguments to pass to the callbacks. The snapshot component can serialize this information and place it in the snapshot.

CSS SVG Animation State The snapshot component can record the tick count of active CSS and SVG animations. When the snapshot is later inflated the interrogative interface can be used to resume each animation at the suspension time tick count.

Timers The snapshot component can calculate and record the remaining time left on each active timer the interval duration for recurring timers and each timer s associated callback. One time timers can be restored during snapshot inflation using an interface that sets a timeout. For recurring timers the interface that sets the timeout can be used for initiation to resume the interrupted recurrence. Further an interface that sets an interval can be used to resume the normal interval.

Nondeterministic event logging e.g. performed by the event logger component of the script based virtual machine is now described in greater detail. While snapshots depict the script based virtual machine at particular moments in time the nondeterministic event logs describe how the script based virtual machine evolves between snapshots. Using the interrogative VMI event logs grow slowly because compared to raw x86 code the scripting language code can be more deterministic. The event logger component can use the interrogative VMI during the execution of the computer executable program to log an event that is scheduled a DOM tree difference between events for a DOM change a tick count associated with an animation a value change for a window state a value from a synchronous source and a timer identifier.

The following table provides an overview of the events that can be tracked via the interrogative VMI . In the text below these events are described in more detail.

The event logger component can serialize black box object references. Some nondeterministic events can refer to objects that reside in a black box component. For example the network component e.g. the network stack can expose a Hypertext Transfer Protocol HTTP connection to the script based virtual machine using an XMLHttpRequest XHR object. When an execution context does var xhr new XMLHttpRequest the network component can create a new internal object and then pass that C object from the network component to the script based virtual machine . Such hosted objects have a scripting language wrapper but can reside within the black box component.

Hosted objects can subsequently be referenced by events. For example when HTTP data arrives the network component can pass an event object to the execution context the target property of the event can be the XMLHttpRequest object that was created via a new operator where the new operator creates an instance of an object type. At logging time the identity of the XMLHttpRequest object can be recorded in the event. According to an example edge relationships between objects in a heap graph can be preserved.

Object Tagging In general a hosted object can be created via the new operator before it can appear in an event. For example an XMLHttpRequest object can be created and initialized before it can generate network events. At logging time the interrogative VMI interposes on the new operator and assigns a unique integer identifier to each hosted object. By interposing on the event interface script based virtual machine can log the identifier of the hosted object in each event.

Later at replay time the interrogative VMI can be used by the script based virtual machine to assign identifiers as above hosted objects can receive the same logging time identifiers since replay is deterministic. At replay time the interrogative VMI also can be used by the script based virtual machine to maintain a map that associates an identifier with its hosted object. When replaying an event the script based virtual machine can use the interrogative VMI to extract the hosted object identifier from the event log fetch the associated hosted object from the map and attach that hosted object to the event that is passed to the execution context.

DOM Paths Object tagging typically does not work for DOM elements since a DOM element can be referenced by an event without a prior scripting language call to the new operator. For example HTML of a page can register a scripting language click handler for a button element. When the button is clicked the browser can generate an event which references the button. Following this illustration the execution context has not previously seen that DOM element and thus has not been tagged.

To solve the foregoing the interrogative VMI can be used to log a DOM element using the element s path in the HTML tree. For example the DOM path 2 5 represents the DOM node that is found by examining the second child of the tag and the fifth child of that tag.

Moreover during execution various nondeterministic browser interfaces schedule events. As a result the order of events is nondeterministic and is to be controlled during program replay.

Logging Events An event loop of the script based virtual machine can log each event. A type of an event can be a string such as mouseclick and can be logged. Moreover a target node of an event can be logged using object identifiers or DOM paths. A callback function of an event can be logged as the integer index of the callback in a callback list of the target node.

Unlike most events timers do not have an event object timers have a callback function. When a timer fires e.g. at expiration of the timer the timer s unique identifier can be logged. The interrogative VMI can use this identifier to lookup the callback function associated with the timer during replay.

In comparison exemplary psuedocode of the event loop of the script based virtual machine to log event schedules is now set forth.

As set forth in the above pseudocode GUI changes can be logged at line 3 and events can be logged at line 4.

Replaying Events During replay of the script based virtual machine the event loop can ignore real events that are generated by the browser. Instead the script based virtual machine can control script execution directly using the event log. Below is exemplary pseudocode for the event loop of the script based virtual machine to re execute a script during replay.

Moreover scripting language code can force updates to a state of the renderer component e.g. by dynamically adding an image to the DOM tree . However an update to the renderer component may not be initiated by an execution context. For example if the user types a string into a textbox or selects an item in a drop down list a state of the renderer component may be updated. The interrogative VMI can be used to capture these state changes in the event log.

DOM Elements The renderer component can be frozen while an execution context is executing an event handler during this time scripting language code can modify a state of the renderer component . As a result GUI changes that are not initiated by an execution context can occur between events. Accordingly the script based virtual machine can log DOM changes that occur between events. Since the DOM is a tree that mirrors an HTML structure of a page the interrogative VMI can log the DOM changes as a tree diff. At replay time the script based virtual machine can replay the changes on live GUI objects.

A benefit of using a tree diff is that the event log need not record an intermediate state between events as that state is irrelevant to deterministic program replay. This design leads to shorter logs than a na ve approach that logs every individual change to the web page s state. For example consider a scenario where a user types Jeff into a text field and hits a Submit button that triggers an event. No scripting language code runs while the user is typing into the text field. The text field has four intermediate states corresponding to each additional character added to the text field but only the full entry is utilized. In this scenario the log includes one entry for that text field with the string Jeff .

CSS SVG Animations Modern browsers typically execute CSS SVG animations in parallel with script execution. The interrogative VMI extensions can be used to pause animations while scripting language code executes and to log the tick counts of active animations as they play. While this changes the semantics of animations in a target browser it is noted that some browsers do not play animations in parallel with script execution. During replay the interrogative VMI extensions can be used to explicitly reset animations to appropriate tick counts before dispatching an event from the log.

Window State A global window object can include a number of properties related to the status of the GUI such as scrollbar position currently active DOM element and size of the browser viewport. Like with animations the interrogative VMI logs these values prior to event execution and resets these values prior to dispatching a replayed event.

External Resources DOM elements can refer to external network resources. For example img elements refer to images and iframe elements refer to HTML files. Using the interrogative extensions to the network component the interrogative VMI can record external network fetches at logging time and return the logged data at replay time.

It is further contemplated that the GUI may not be the only source of nondeterminism for an execution context. Below are various examples of non GUI sources of nondeterminism.

Synchronous sources The interrogative VMI can log return values from the nondeterministic functions Date and Math.random . The interrogative VMI can also log read values from the localStorage interface and from Cookies. During replay the interrogative VMI interposes on these interfaces to return logged values.

Timer IDs Each timer created with the setInterval interface and the setTimeout interface can have a unique identifier associated with it which the renderer component can determine. The interrogative VMI can log identifier values returned from these interfaces. During replay the interrogative VMI can interpose on these interfaces to return the same identifiers and interact with the VMI s timer extensions to update its active timer state.

XMLHttpRequest Like DOM elements XMLHttpRequest objects commonly are frozen while an event executes. The interrogative VMI can maintain a list of the live XMLHttpRequest objects and check them for property changes before a new event is dispatched. If an object s properties have changed the event log records the changes as a diff from the object s previous state. During replay the interrogative VMI can use the hosted object map to find the relevant XMLHttpRequest and apply the deltas from the log before handing the associated event to an execution context.

Pursuant to an example the script based virtual machine can be configured to perform a reverse execution of the computer executable program to a causal event based on the snapshot s and or the event logs. According to an illustration the script based virtual machine can be a JavaScript virtual machine that can include the time travel debugger . The interrogative VMI and the time travel debugger can enable a reverse step to a causal event. For instance JavaScript programs frequently utilize callbacks via timers XHR promises e.g. from the ECMAScript Harmony 6th Edition ES6 standard etc. to implement event handling. Similar features exist in other programming languages such as the async construct for C . When debugging these callbacks a common challenge may be to understand why a particular function was set as a callback and what the call stack was at that time. In a traditional debugger this information is typically lost by the time the callback code is executed. In contrast the techniques set forth here can retain the logical time at which each callback is set and what the callback is. By storing such logical time at which each callback is set and what the callback is the time travel debugger can enable direct reverse executing to a causal source. Accordingly the foregoing functionality can enable a developer to understand where the callback was registered and the state of the program at such point in time.

By way of illustration snapshots and or event logs can include identities of callbacks and corresponding logical times at which the callbacks are set during the execution of the computer executable program. Thus the identities of the callbacks and the corresponding logical times at which the callbacks are set during the execution can be stored. The identities of the callbacks and the corresponding logical times can be exposed to the script based virtual machine via the interrogative VMI during the execution of the computer executable program. Further the time travel debugger can replay at least a portion of the execution of the computer executable program based at least in part on the identities of the callbacks and the corresponding logical times. For instance the time travel debugger can perform a reverse execution of the computer executable program to a causal event based at least in part on the identities of the callbacks and the corresponding logical times.

Now turning to illustrated is a system that performs time travel debugging. The system includes the virtual machine the computer executable program the snapshots and the event logs . The virtual machine can include the execution component the snapshot component the event logger component and the time travel debugger . The time travel debugger can be a time travel debugger for a web browser e.g. the browser system .

The time travel debugger can receive an input e.g. from a developer that sets a breakpoint in the computer executable program . The time travel debugger can enable traveling backwards in time from that point to previously executed statements. Conventional time travel debuggers often trade replay fidelity for performance or vice versa. In contrast the time travel debugger can provide both replay fidelity and performance. By leveraging the interrogative VMI the time travel debugger can handle interactions with black boxes while still providing efficient logging and replay.

The time travel debugger can use the snapshots captured by the snapshot component and the event logs captured by the event logger component . The time travel debugger can reinflate a snapshot S to return to a time that is represented by S. To return to a time t that is between two snapshots the time travel debugger can load the last snapshot temporally preceding t and then replay the event logs until t is reached.

During execution of the computer executable program by the execution component e.g. before a time travel debugging session has started the time travel debugger can enable the event logger component to capture the nondeterministic event logs and can enable the snapshot component to create snapshots e.g. at regular intervals etc. . The snapshots can be created at quiescent points between events since handlers may run for a few milliseconds the snapshots can be captured at regular intervals. The snapshot interval can set an upper bound on a cost to seek to an arbitrary point in the execution of the computer executable program .

The time travel debugger can include an analysis component configured to evaluate latency of time travel operations. Based on the latency the analysis component can cause the snapshot component to record one or more additional snapshots of the virtual machine during replay of the execution of the computer executable program . If the snapshot interval is too large jumping through time can be slow since the time travel debugger may have to replay many events to reach the desired execution point. However if the time travel debugger records too many snapshots during normal program execution the computer executable program may suffer poor performance. Thus at replay time the analysis component can be configured to opportunistically cause the snapshot component to generate snapshots to reduce the latency of future time travel operations. By way of illustration if the time travel debugger is time travelling towards t and starts from a far away snapshot where distance is defined in terms of events the analysis component can cause the snapshot component to generate a new snapshot at an event that more closely precedes t. This optimization can be based on the common debugging scenario in which a developer explores a set of program states that are temporally nearby.

When a snapshot exists that is close to t returning to t can typically be instantaneous or nearly instantaneous from the perspective of a human developer. Further the runtime cost of inflating a snapshot can be a few hundreds of milliseconds and replaying an individual event may take a few milliseconds.

According to an exemplary scenario the time travel debugger can repeatedly inflate and replay from the same snapshot as the developer interacts with debugger features like step back which returns to a previously executed statement e.g. in a script etc. . If the computer executable program includes a large amount of state full snapshot inflation may introduce developer visible delays. By way of example in such a scenario the time travel debugger can avoid restoring the entire heap and instead roll back the memory pages that changed during replay from the last snapshot. However the claimed subject matter is not limited to the foregoing example.

The time travel debugger can provide a variety of reverse facing complements to conventional debugger features. Below implementation of these features atop the interrogative VMI is described. The time travel debugger can employ various interrogative methods to introspect execution of the computer executable program at the level of individual statements. As set forth below the time travel debugger can time travel to a particular basic block a particular statement within that block or to the last statement of the basic block that jumped to the current block and so forth.

Logical timestamps for basic blocks can be used. Although the time travel debugger can return to previous execution states using the interrogative VMI the time travel debugger also can pause execution at an appropriate point during a replayed event handler. Existing debuggers commonly allow developers to place conditional breakpoints at specific program statements in contrast the time travel debugger can allow for breakpoints to be placed at a desired logical time during execution.

To support logical time breakpoints the interrogative VMI introduces an additional interrogative interface the interrogative VMI can expose the number of times that a basic block has executed. The time travel debugger can use these logical timestamps in conditional breakpoints to determine when to pause execution during time travel backwards to a particular basic block.

The time travel debugger can represent logical time as a two tuple where the first element is a function call count from the start of program execution and the second element is the basic block count within the current function call. With this design the time travel debugger tracks function call counts through the lifetime of the computer executable program however basic block counts can be discarded once a function call terminates. Function call counts can be included in state snapshots and can be reset when the time travel debugger loads a snapshot.

The time travel debugger can further include a step back component configured to identify a previously executed statement prior in the computer executable program . For instance the previously executed statement can be prior to a breakpoint. The step back component can be configured to identify the previously executed statement based on one or more of the snapshots and at least a portion of the event logs . Based on such identification the step back component can provide various step back functionality. Within a particular basic block with no function calls the previously executed statement is the previous statement in the basic block. However when the previous statement is a function call the previously executed statement is the last statement to execute in the called function.

To support the step back component with low overhead the interrogative VMI can expose a location and logical time of the previous jump or return statement. If a current statement is at the start of a basic block or follows a function call then the previous statement is the previous jump or return statement. Otherwise the previous statement is the previous statement in the current basic block.

Examples of debugger features that can be provided by the step back component include step back step back over and step back out of.

Step back complements step forward and lets a developer return to a previously executed program statement. To implement step back the step back component places a time aware breakpoint on the previously executed program statement. Then the step back component replays execution from the previous snapshot that is closest to the logical time of the breakpoint.

Step back over complements step over and lets a developers return to a previously executed program statement in a current function. To implement step back over the step back component places a time aware breakpoint on the previous program statement in the current basic block at the current logical time and replays execution from the nearest snapshot. If the current statement is the first statement in its basic block then a jump immediately preceded it in this case step back over has the same behavior as step back.

Step back out of complements step out of and travels back to a statement that called the current function. When implementing step back out of the step back component places a time aware breakpoint on the call site of the current function using the logical time associated with the caller s stack frame. Then the step back component replays execution from the previous snapshot closest to the logical time of the breakpoint.

Moreover the time travel debugger can include a reverse execute component configured to perform a reverse execution of the computer executable program from a current breakpoint in the computer executable program to a previous breakpoint in the computer executable program . The reverse execute component can be configured to perform the reverse execution based on one or more of the snapshots and at least a portion of the event logs . Reverse execute complements continue execution and travels back to the previous breakpoint. With reverse execution the time travel debugger may not know if when each of the currently placed breakpoints will execute. Thus the time travel debugger does not know which will execute closest in logical time to the current program statement.

To implement reverse execute the reverse execute component can be configured to perform a temporal search to identify the previous breakpoint. The reverse execute component further places a time aware breakpoint at the current program statement loads the nearest previous snapshot and executes until the current program statement. During execution the reverse execute component can record the logical time and location of triggered breakpoints. A last breakpoint to trigger before the current program statement can be determined to be the time travel destination by the reverse execute component .

If the reverse execute component does not encounter a breakpoint it performs the same procedure but reinflates the program state from two snapshots away instead of one. This process repeats until the reverse execute component finds a breakpoint that triggers or reaches the beginning of execution. In the latter case the program uses the first statement in program execution as the time travel destination. Once the reverse execute component identifies a time travel destination it places an appropriate time aware breakpoint and replays execution from the closest snapshot to that destination.

Moreover the acts described herein may be computer executable instructions that can be implemented by one or more processors and or stored on a computer readable medium or media. The computer executable instructions can include a routine a sub routine programs a thread of execution and or the like. Still further results of acts of the methodologies can be stored in a computer readable medium displayed on a display device and or the like.

Referring now to a high level illustration of an exemplary computing device that can be used in accordance with the systems and methodologies disclosed herein is illustrated. For instance the computing device may be used in a system that performs time travel debugging. The computing device includes at least one processor that executes instructions that are stored in a memory . The instructions may be for instance instructions for implementing functionality described as being carried out by one or more components discussed above or instructions for implementing one or more of the methods described above. The processor may access the memory by way of a system bus . In addition to storing executable instructions the memory may also store snapshots event logs and so forth.

The computing device additionally includes a data store that is accessible by the processor by way of the system bus . The data store may include executable instructions snapshots event logs etc. The computing device also includes an input interface that allows external devices to communicate with the computing device . For instance the input interface may be used to receive instructions from an external computer device from a user etc. The computing device also includes an output interface that interfaces the computing device with one or more external devices. For example the computing device may display text images etc. by way of the output interface .

It is contemplated that the external devices that communicate with the computing device via the input interface and the output interface can be included in an environment that provides substantially any type of user interface with which a user can interact. Examples of user interface types include graphical user interfaces natural user interfaces and so forth. For instance a graphical user interface may accept input from a user employing input device s such as a keyboard mouse remote control or the like and provide output on an output device such as a display. Further a natural user interface may enable a user to interact with the computing device in a manner free from constraints imposed by input device such as keyboards mice remote controls and the like. Rather a natural user interface can rely on speech recognition touch and stylus recognition gesture recognition both on screen and adjacent to the screen air gestures head and eye tracking voice and speech vision touch gestures machine intelligence and so forth.

Additionally while illustrated as a single system it is to be understood that the computing device may be a distributed system. Thus for instance several devices may be in communication by way of a network connection and may collectively perform tasks described as being performed by the computing device .

Turning to a high level illustration of an exemplary computing system that can be used in accordance with the systems and methodologies disclosed herein is illustrated. For instance the computing system can be or include the computing system . Additionally or alternatively the computing system can be or include the computing system .

The computing system includes a plurality of server computing devices namely a server computing device . . . and a server computing device collectively referred to as server computing devices . The server computing device includes at least one processor and a memory the at least one processor executes instructions that are stored in the memory. The instructions may be for instance instructions for implementing functionality described as being carried out by one or more components discussed above or instructions for implementing one or more of the methods described above. Similar to the server computing device at least a subset of the server computing devices other than the server computing device each respectively include at least one processor and a memory. Moreover at least a subset of the server computing devices include respective data stores.

Processor s of one or more of the server computing devices can be or include the processor . Further a memory or memories of one or more of the server computing devices can be or include the memory . Moreover a data store or data stores of one or more of the server computing devices can be or include the data store .

The computing system further includes various network nodes that transport data between the server computing devices . Moreover the network nodes transport data from the server computing devices to external nodes e.g. external to the computing system by way of a network . The network nodes also transport data to the server computing devices from the external nodes by way of the network . The network for example can be the Internet a cellular network or the like. The network nodes include switches routers load balancers and so forth.

A fabric controller of the computing system manages hardware resources of the server computing devices e.g. processors memories data stores etc. of the server computing devices . The fabric controller further manages the network nodes . Moreover the fabric controller manages creation provisioning de provisioning and supervising of virtual machines instantiated upon the server computing devices .

A computing system comprising at least one processor and memory that comprises a virtual machine that is executable by the processor the virtual machine comprising an execution component configured to execute a computer executable program an event logger component configured to log nondeterministic events during execution of the computer executable program as part of event logs the event logger component further configured to log the nondeterministic events via an interrogative virtual machine interface VMI the interrogative VMI being between the virtual machine and a browser system a snapshot component configured to record a sequence of snapshots of the virtual machine during the execution of the computer executable program the snapshot component further configured to record the snapshots via the interrogative VMI and a time travel debugger configured to replay at least a portion of the execution of the computer executable program based at least in part on a snapshot from the sequence of snapshots and at least a portion of the event logs.

The computing system according to Example 1 wherein the interrogative VMI enables the snapshots and the event logs to be semantically complete.

The computing system according to any of Examples 1 2 wherein the snapshots and the event logs are device and address independent.

The computing system according to any of Examples 1 3 wherein a tick count associated with an animation is exposed to the virtual machine via the interrogative VMI wherein the browser system further comprises a renderer component configured to perform the animation and associate the tick count with the animation the tick count being indicative of how close the animation is to a final repaint.

The computing system according to any of Examples 1 4 wherein a callback list managed by a renderer component of the browser system is exposed to the virtual machine via the interrogative VMI.

The computing system according to any of Examples 1 5 wherein an event indicative of an external resource being downloaded by a network component of the browser system is exposed to the virtual machine via the interrogative VMI.

The computing system according to any of Examples 1 6 wherein at least one of the snapshots or the event logs comprise identities of callbacks and corresponding logical times at which the callbacks are set during the execution of the computer executable program.

The computing system according to any of Examples 1 7 during the execution of the computer executable program the event logger component further configured to use the interrogative VMI to log an event that is scheduled a Document Object Model DOM tree difference between events for a DOM change a tick count associated with an animation a value change for a window state a value from a synchronous source and a timer identifier.

The computing system according to any of Examples 1 8 the time travel debugger further configured to identify the snapshot from the sequence of snapshots the snapshot temporally preceding a time t load the snapshot that temporally preceded the time t and replay the event logs from the snapshot to the time t.

The computing system according to any of Examples 1 8 the time travel debugger further configured to perform a reverse execution of the computer executable program to a causal event based at least in part on the snapshot and the portion of the events logs.

The computing system according to any of Examples 1 10 the time travel debugger further comprising an analysis component configured to evaluate latency of time travel operations and based on the latency cause the snapshot component to record an additional snapshot of the virtual machine during the replay of the portion of the execution of the computer executable program.

The computing system according to any of Examples 1 11 the time travel debugger further comprising a reverse execute component configured to perform a reverse execution of the computer executable program from a current breakpoint in the computer executable program to a previous breakpoint in the computer executable program the reverse execute component configured to perform the reverse execution based at least in part on the snapshot and the portion of the event logs.

The computing system according to any of Examples 1 12 the time travel debugger further comprising a step back component configured to identify a previously executed statement prior to a breakpoint in the computer executable program the step back component configured to identify the previously executed statement based at least in part on the snapshot and the portion of the event logs.

The computing system according to any of Examples 1 13 wherein the interrogative VMI is layered atop a low level VMI defined by a virtual machine monitor.

A method of performing time travel debugging comprising executing a computer executable program the computer executable program being executable under control of a virtual machine the virtual machine interacts with a browser system during execution of the computer executable program logging nondeterministic events via an interrogative virtual machine interface VMI during the execution of the computer executable program the nondeterministic events being logged as part of event logs the interrogative VMI being between the virtual machine and the browser system capturing snapshots of the virtual machine during the execution of the computer executable program the snapshots being captured via the interrogative VMI and replaying at least a portion of the execution of the computer executable program based at least in part on a snapshot and at least a portion of the event logs.

The method according to Example 15 further comprising utilizing the interrogative VMI to log an event that is scheduled a Document Object Model DOM tree difference between events for a DOM change a tick count associated with an animation a value change for a window state a value from a synchronous source and a timer identifier.

The method according to any of Examples 15 16 further comprising replaying the portion of the execution of the computer executable program based on identities of callbacks and corresponding logical times at which the callbacks are set during the execution of the computer executable program wherein at least one of the snapshots or the event logs comprise the identities of the callbacks and the corresponding logical times.

The method according to any of Examples 15 17 replaying the portion of the execution of the computer executable program further comprising identifying the snapshot from the snapshots the snapshot temporally preceding a time t loading the snapshot that temporally preceded the time t and replaying the event logs from the snapshot to the time t.

A method of performing time travel debugging comprising executing a computer executable program the computer executable program being executable under control of a virtual machine the virtual machine interacts with a browser system during execution of the computer executable program storing identities of callbacks and corresponding logical times at which the callbacks are set during the execution of the computer executable program wherein the identities of the callbacks and the corresponding logical times are exposed to the virtual machine via an interrogative virtual machine interface VMI during the execution of the computer executable program the interrogative VMI being between the virtual machine and the browser system and replaying at least a portion of the execution of the computer executable program based at least in part on the identities of the callbacks and the corresponding logical times.

The method according to Example 19 replaying the portion of the execution of the computer executable program further comprising performing a reverse execution of the computer executable program to a causal event based at least in part on the identities of the callbacks and the corresponding logical times.

As used herein the terms component and system are intended to encompass computer readable data storage that is configured with computer executable instructions that cause certain functionality to be performed when executed by a processor. The computer executable instructions may include a routine a function or the like. It is also to be understood that a component or system may be localized on a single device or distributed across several devices.

Further as used herein the term exemplary is intended to mean serving as an illustration or example of something. 

Various functions described herein can be implemented in hardware software or any combination thereof. If implemented in software the functions can be stored on or transmitted over as one or more instructions or code on a computer readable medium. Computer readable media includes computer readable storage media. A computer readable storage media can be any available storage media that can be accessed by a computer. By way of example and not limitation such computer readable storage media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein include compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc BD where disks usually reproduce data magnetically and discs usually reproduce data optically with lasers. Further a propagated signal is not included within the scope of computer readable storage media. Computer readable media also includes communication media including any medium that facilitates transfer of a computer program from one place to another. A connection for instance can be a communication medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of communication medium. Combinations of the above should also be included within the scope of computer readable media.

Alternatively or in addition the functionality described herein can be performed at least in part by one or more hardware logic components. For example and without limitation illustrative types of hardware logic components that can be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

What has been described above includes examples of one or more embodiments. It is of course not possible to describe every conceivable modification and alteration of the above devices or methodologies for purposes of describing the aforementioned aspects but one of ordinary skill in the art can recognize that many further modifications and permutations of various aspects are possible. Accordingly the described aspects are intended to embrace all such alterations modifications and variations that fall within the scope of the appended claims. Furthermore to the extent that the term includes is used in either the details description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

